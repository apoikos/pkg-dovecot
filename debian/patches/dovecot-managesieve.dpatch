#! /bin/sh -e

## DP: Source for MANAGESIEVE
## DP: Author: Stephan Bosch <stephan@rename-it.nl>
## DP: Version: 0.10.2

# Patch obtained from http://www.rename-it.nl/dovecot/1.1/dovecot-1.1-managesieve-0.10.2.tar.gz

. $(dirname $0)/DPATCH

exit 0
@DPATCH@
diff -urN dovecot-1.1.1/dovecot-managesieve/AUTHORS dovecot-1.1.1-managesieve/dovecot-managesieve/AUTHORS
--- dovecot-1.1.1/dovecot-managesieve/AUTHORS	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/AUTHORS	2008-02-13 08:48:19.000000000 -0700
@@ -0,0 +1,10 @@
+Stephan Bosch <stephan@rename-it.nl>
+
+This package is partly based on and built for the Dovecot Secure 
+IMAP server written by Timo Sirainen <tss@iki.fi>. The managesieve
+service is a modified version of Dovecot's imap service 
+implementation.
+
+Currently depends on the CMU Sieve implementation located in the
+dovecot-sieve package. The AUTHORS file there references the CMU
+authors.
diff -urN dovecot-1.1.1/dovecot-managesieve/ChangeLog dovecot-1.1.1-managesieve/dovecot-managesieve/ChangeLog
--- dovecot-1.1.1/dovecot-managesieve/ChangeLog	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/ChangeLog	2008-05-04 08:27:58.000000000 -0600
@@ -0,0 +1,309 @@
+2008-04-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c:
+	Misplaced managesieve_parser_reset() call could break things in rare
+	occasions.
+	[9ad0783596ac] [tip]
+
+	* README:
+	Minor typo in the README.
+	[74e8cb23aaf3]
+
+	* NEWS:
+	Updated NEWS.
+	[a8198d09730e]
+
+	* INSTALL, README:
+	Updated documentation to match wiki.
+	[d721cc96dd31]
+
+	* src/managesieve-login/client-authenticate.c:
+	Fixed SASL conversation for SASL mechanisms that need more than two
+	client responses.
+	[fd7c75362f9a]
+
+2008-03-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.1 for changeset 1d8e0f019d22
+	[a951da18b8d8]
+
+	* configure.in:
+	Released v0.10.1.
+	[1d8e0f019d22] [0.10.1]
+
+	* NEWS:
+	Updated NEWS file.
+	[abd768086f01]
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Fixed assert bug in sieve-storage save occuring when save was
+	canceled.
+	[a35209b66170]
+
+	* NEWS:
+	Updated NEWS file.
+	[0729a6aa443e]
+
+	* README:
+	Updated README file.
+	[f559718ec326]
+
+2008-03-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve.c:
+	Fixed bug: compiled script was saved to sieve/tmp and left there.
+	[22ec735aeea9]
+
+	* src/lib-cmusieve/sieve.c, src/lib-sievestorage/sieve-storage-save.c,
+	src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage.c:
+	Made log lines sieve-storage specific.
+	[cc0b1f5a3fdf]
+
+2008-02-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Fixed bug in the saving a script to disc by incorporating related
+	changes from maildir-save.c (tmp files).
+	[1ccf54331bbb]
+
+2008-02-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Amended README file with proxy configuration.
+	[41b45cac234d]
+
+2008-02-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Minor changes to the documentation.
+	[dd6a0b1f411e]
+
+	* README:
+	Added Known Issues section to the README.
+	[8a726b60606e]
+
+2008-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Added DESIGN file to tarball distribution.
+	[3ee68d9bb40b]
+
+	* .hgignore, COPYING:
+	Removed duplicate licence.
+	[0a20481bf71b]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.0 for changeset 1fc40a7b807e
+	[b662dc260864]
+
+	* configure.in:
+	Released v0.10.0.
+	[1fc40a7b807e] [0.10.0]
+
+	* INSTALL:
+	Minor changes to the INSTALL file.
+	[c4ab1821769d]
+
+	* NEWS, configure.in:
+	Updated NEWS file.
+	[34b025d7db3a]
+
+	* src/lib-cmusieve/sieve.h, src/managesieve-login/client.c, src
+	/managesieve-login/managesieve-proxy.c:
+	Incorporated minor changes to the imap implementation into
+	managesieve and fixed a few compiler warnings.
+	[499c6577f171]
+
+	* INSTALL, README:
+	Moved compile info from README to separate INSTALL file.
+	[844cc1514cd8]
+
+	* README:
+	Added notice about the patch to the README.
+	[4910acccd984]
+
+	* DESIGN, NEWS, README, TODO:
+	Updated README to new situation and spliced off NEWS, TODO and
+	DESIGN files.
+	[f8280a8a986c]
+
+	* src/managesieve/cmd-putscript.c:
+	Adjusted to changes in dovecot-1.1.
+	[6938e4f41779]
+
+2008-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-putscript.c:
+	Removed inappropriate references to 'message' from cmd_putscript.c
+	[e230e3139ce0]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-script.c, src/managesieve/cmd-putscript.c:
+	Adjusted to changes in dovecot-1.1.
+	[d170f3343646]
+
+2008-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-save.h, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-putscript.c,
+	src/managesieve/common.h, src/managesieve/main.c:
+	Incorporated v1.1 imap (relevant) changes in client.c into
+	managesieve.
+	[29e1d96c679c]
+
+2008-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/commands.c:
+	Incorporated v1.1 imap changes in commands.c into managesieve.
+	[69899aa6fd71]
+
+	* src/managesieve/main.c:
+	Incorporated v1.1 imap changes in main.c into managesieve.
+	[e92b5cee9005]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Incorporated v1.1 imap-login changes in imap-proxy.c into
+	managesieve-login.
+	[3e8cbe6a965b]
+
+	* src/managesieve-login/client-authenticate.c:
+	Incorporated v1.1 imap-login changes in client-authenticate.c into
+	managesieve-login.
+	[1b2ae7648f1f]
+
+	* src/managesieve-login/client.c, src/managesieve-login/client.h,
+	src/managesieve/main.c:
+	Incorporated v1.1 imap-login changes in client.c/client.h into
+	managesieve-login.
+	[71920eb2b1ea]
+
+2008-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve.c, src/lib-cmusieve/sieve.h:
+	Updated cmu sieve implementation to mathch new libsieve API.
+	[79fde30ec4e7]
+
+	* src/managesieve/cmd-putscript.c:
+	Cleaned up putscript command implementation. The script is now
+	passed to the compiler as a script object and not as a script path.
+	[9d260008a304]
+
+	* src/managesieve-login/Makefile.am, src/managesieve/Makefile.am:
+	Included extra libraries to compile against new sieve plugin.
+	[0656fb1ab0a3]
+
+2008-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Minor change in script storage error handling.
+	[862e79b43158]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-script.c, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-script.c, src/lib-sievestorage/sieve-storage.c,
+	src/managesieve/cmd-putscript.c:
+	Fixed various bugs resulting from the script object merge.
+	[c2720aaa01e3]
+
+	* src/lib-cmusieve/sieve-error-private.h, src/lib-cmusieve/sieve-
+	error.c, src/lib-cmusieve/sieve-script.c, src/managesieve/main.c:
+	Incorporated changes in the libsieve interface and dovecot.
+	[496b349b8b6c]
+
+	* src/Makefile.am:
+	Fixed bug in makefile.
+	[03a629108c0a]
+
+	* configure.in, src/Makefile.am, src/lib-cmusieve/Makefile.am, src
+	/lib-cmusieve/sieve-common.h, src/lib-cmusieve/sieve-error-
+	private.h, src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-
+	error.h, src/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve
+	/sieve-script.c, src/lib-cmusieve/sieve-script.h, src/lib-
+	sievestorage/Makefile.am, src/lib-sievestorage/sieve-storage-
+	private.h, src/lib-sievestorage/sieve-storage-save.c, src/lib-
+	sievestorage/sieve-storage-save.h, src/lib-sievestorage/sieve-
+	storage-script.c, src/lib-sievestorage/sieve-storage-script.h, src
+	/lib-sievestorage/sieve-storage.c, src/lib-sievestorage/sieve-
+	storage.h, src/managesieve-login/Makefile.am,
+	src/managesieve/Makefile.am, src/managesieve/cmd-deletescript.c,
+	src/managesieve/cmd-getscript.c, src/managesieve/cmd-putscript.c,
+	src/managesieve/cmd-setactive.c:
+	Merged managesieve script object with libsieve script object to
+	remove conflict.
+	[04015ad664ff]
+
+	* src/lib-cmusieve/Makefile.am, src/lib-cmusieve/sieve-error.c, src
+	/lib-cmusieve/sieve-error.h, src/lib-cmusieve/sieve.c, src/lib-
+	cmusieve/sieve.h, src/managesieve/cmd-putscript.c:
+	Added renewed error handling to script compilation.
+	[85b13786220f]
+
+2008-01-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/Makefile.am, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-putscript.c, src/managesieve/main.c:
+	Re-enabled compiling scripts upon PUTSCRIPT.
+	[94941c84c15d]
+
+	* configure.in:
+	Fixed bug in configure script.
+	[e9ce47319f1e]
+
+	* src/lib-cmusieve/Makefile.am, src/lib-cmusieve/sieve.c, src/lib-
+	cmusieve/sieve.h:
+	Forgot to add new files.
+	[43de7f9e8ed1]
+
+	* .hgignore, configure.in, src/Makefile.am, src/lib-cmusieve/sieve-
+	cmu.c, src/managesieve-login/Makefile.am, src/managesieve-
+	login/client.c:
+	Added link to cmusieve implementation in dovecot-sieve-1.1.
+	[24afa34fdc90]
+
+2008-01-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Fixed signal handing related assert fail in managesieve/main.c.
+	[87bd5155de04]
+
+	* .hgignore, src/managesieve-login/managesieve-login:
+	Accidentally added managesieve-login binary.
+	[150201234662]
+
+	* .hgignore, AUTHORS, COPYING.LGPL, INSTALL, Makefile.am, NEWS,
+	README, autogen.sh, configure.in, src/Makefile.am, src/lib-cmusieve
+	/sieve-cmu.c, src/lib-managesieve/Makefile.am, src/lib-managesieve
+	/managesieve-parser.c, src/lib-managesieve/managesieve-parser.h, src
+	/lib-managesieve/managesieve-quote.c, src/lib-managesieve
+	/managesieve-quote.h, src/lib-sievestorage/Makefile.am, src/lib-
+	sievestorage/sieve-storage-list.c, src/lib-sievestorage/sieve-
+	storage-list.h, src/lib-sievestorage/sieve-storage-private.h, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-save.h, src/lib-sievestorage/sieve-storage-script.c, src
+	/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h, src
+	/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client-authenticate.h, src
+	/managesieve-login/client.c, src/managesieve-login/client.h, src
+	/managesieve-login/managesieve-login, src/managesieve-login
+	/managesieve-proxy.c, src/managesieve-login/managesieve-proxy.h,
+	src/managesieve/Makefile.am, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-havespace.c, src/managesieve/cmd-listscripts.c,
+	src/managesieve/cmd-logout.c, src/managesieve/cmd-putscript.c,
+	src/managesieve/cmd-setactive.c, src/managesieve/commands.c,
+	src/managesieve/commands.h, src/managesieve/common.h,
+	src/managesieve/main.c, stamp.h.in:
+	Started repository for MANAGESIEVE implementation as separate
+	package.
+	[e81ad896fdf8]
+
diff -urN dovecot-1.1.1/dovecot-managesieve/configure.in dovecot-1.1.1-managesieve/dovecot-managesieve/configure.in
--- dovecot-1.1.1/dovecot-managesieve/configure.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/configure.in	2008-05-04 08:28:15.000000000 -0600
@@ -0,0 +1,95 @@
+AC_INIT([dovecot-managesieve], [0.10.2], [dovecot@dovecot.org], [dovecot-1.1-managesieve])
+AC_CONFIG_SRCDIR([src])
+
+AC_CONFIG_HEADERS([dmanagesieve-config.h])
+AM_INIT_AUTOMAKE
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AM_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[  --with-dovecot[=DIR]    Dovecot base directory (../)],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+
+AC_ARG_WITH(dovecot-sieve,
+[  --with-dovecot-sieve[=DIR]    Dovecot-sieve plugin base directory (../)],
+    dovecot_sievedir="$withval",
+    dovecot_sievedir=../dovecot-sieve-1.1
+)
+
+top=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $top
+cd $dovecot_sievedir
+dovecot_sievedir=`pwd`
+cd $top
+AC_SUBST(dovecotdir)
+AC_SUBST(dovecot_sievedir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+if test -f "$dovecot_sievedir/src/sieve-cmu.c"; then
+  # compiling against old cmu sieve plugin
+  echo "compiling against old dovecot-sieve plugin."
+  SIEVE_PLUGIN_INCLUDE=$top/src/lib-cmusieve
+  SIEVE_PLUGIN_LIB=$top/src/lib-cmusieve/libsieve_cmu.la
+  have_old_sieve_plugin=yes
+else
+  # compiling against native dovecot sieve plugin
+  echo "compiling against new dovecot-sieve plugin."
+  SIEVE_PLUGIN_INCLUDE=$dovecot_sievedir/src/lib-sieve
+  SIEVE_PLUGIN_LIB=$dovecot_sievedir/src/lib-sieve/libsieve.la
+  have_old_sieve_plugin=no
+fi
+AM_CONDITIONAL(HAVE_OLD_SIEVE_PLUGIN, test "$have_old_sieve_plugin" = "yes")
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(SSL_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_SUBST(SIEVE_PLUGIN_INCLUDE)
+AC_SUBST(SIEVE_PLUGIN_LIB)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/lib-sievestorage/Makefile
+src/lib-managesieve/Makefile
+src/managesieve/Makefile
+src/managesieve-login/Makefile
+src/lib-cmusieve/Makefile
+stamp.h])
+
+AC_OUTPUT
diff -urN dovecot-1.1.1/dovecot-managesieve/COPYING dovecot-1.1.1-managesieve/dovecot-managesieve/COPYING
--- dovecot-1.1.1/dovecot-managesieve/COPYING	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/COPYING	2008-02-14 03:37:37.000000000 -0700
@@ -0,0 +1,4 @@
+See AUTHORS file for list of copyright holders.
+
+Everything is licenced under LGPLv2.1 (see COPYING.LGPL) unless otherwise 
+mentioned at the beginning of the file.
diff -urN dovecot-1.1.1/dovecot-managesieve/COPYING.LGPL dovecot-1.1.1-managesieve/dovecot-managesieve/COPYING.LGPL
--- dovecot-1.1.1/dovecot-managesieve/COPYING.LGPL	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/COPYING.LGPL	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,510 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -urN dovecot-1.1.1/dovecot-managesieve/DESIGN dovecot-1.1.1-managesieve/dovecot-managesieve/DESIGN
--- dovecot-1.1.1/dovecot-managesieve/DESIGN	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/DESIGN	2008-02-13 06:05:56.000000000 -0700
@@ -0,0 +1,28 @@
+Design
+------
+
+The overall design of the daemon is entirely borrowed from the existing
+imap daemon. I have tried to apply the dovecot framework and programming
+paradigms as much as possible. This package contains the following
+directories:
+
+lib-managesieve: parser and quote functions (bound to disappear)
+lib-sievestorage: defines a storage for the sieve scripts (a bit crude)
+managesieve-login: the initial login daemon (derived from src/imap-login)
+managesieve: the actual managesieve daemon (derived form src/imap)
+lib-cmusieve: wrapper around dovecot-sieve-1.x to give the old sieve
+  implementation an identical interface as the new library. This makes 
+  the choice for a specific implementation arbitrary and the transition to
+  the new version a seemless process. 
+
+This package currently still requires the dovecot tree to be patched to add
+support for the new managesieve daemons. For dovecot-1.0 (<= v9), the 
+contents of this package was included in the patch, but now the managesieve 
+implementation is separated from the changes in the dovecot tree. Eventually 
+the need for the patch will disappear when Timo adds support for defining 
+arbitrary new services.
+
+The daemon currently implements all existing MANAGESIEVE commands except the 
+HAVESPACE command which always says 'ok'. It also implements the required
+support for UTF-8 strings. 
+
diff -urN dovecot-1.1.1/dovecot-managesieve/dmanagesieve-config.h.in dovecot-1.1.1-managesieve/dovecot-managesieve/dmanagesieve-config.h.in
--- dovecot-1.1.1/dovecot-managesieve/dmanagesieve-config.h.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/dmanagesieve-config.h.in	2008-05-04 08:29:12.000000000 -0600
@@ -0,0 +1,55 @@
+/* dmanagesieve-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
diff -urN dovecot-1.1.1/dovecot-managesieve/INSTALL dovecot-1.1.1-managesieve/dovecot-managesieve/INSTALL
--- dovecot-1.1.1/dovecot-managesieve/INSTALL	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/INSTALL	2008-04-26 02:33:40.000000000 -0600
@@ -0,0 +1,53 @@
+Compile
+-------
+
+Prerequisites:
+	* A patched and compiled dovecot-1.1 tree:
+		To enable support for the new managesieve service, Dovecot needs to be 
+		patched. The patch is available from the same source as this package. 
+		
+		Package and patch are named as follows:
+		  Patch: dovecot-1.1.X-managesieve-<managesieve version>.diff.gz
+		  Package: dovecot-1.1-managesieve-<managesieve version>.tar.gz
+		
+		Nothing special needs to be done to compile the patched tree. You can use:
+			./configure
+			make
+			sudo make install
+		as usual. 
+		
+		Note that this package will compile against an unpatched dovecot tree, but 
+		keep in mind that dovecot will not know about managesieve without the patch.
+
+	* A compiled dovecot-sieve-1.1 tree. 
+		Currently, no special version dependencies are known to compile against the
+		sieve plugin, but of course the most recent version is recommended. 
+
+If you downloaded this package using Mercurial, you have a script called 
+autogen.sh in your source tree. You should execute that first:
+
+./autogen.sh
+
+After this executed successfully or when you downloaded the tarball,
+configure needs to be executed with the following parameters:
+
+	--with-dovecot=<path>
+		Path to the patched and compiled dovecot-1.1 source tree
+	--with-dovecot-sieve=<path>	
+		Path to the compiled dovecot-sieve-1.1 source tree
+
+For example:
+
+./configure --with-dovecot=../dovecot-1.1 \
+	--with-dovecot-sieve=../dovecot-sieve-1.1
+
+As usual, to compile and install, execute the following:
+
+make
+sudo make install 
+
+Configure
+---------
+
+Refer to README file.
+ 
diff -urN dovecot-1.1.1/dovecot-managesieve/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/Makefile.am	2008-02-14 03:48:53.000000000 -0700
@@ -0,0 +1,11 @@
+SUBDIRS = src
+
+EXTRA_DIST = \
+	COPYING.LGPL \
+	ChangeLog \
+	DESIGN
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
diff -urN dovecot-1.1.1/dovecot-managesieve/NEWS dovecot-1.1.1-managesieve/dovecot-managesieve/NEWS
--- dovecot-1.1.1/dovecot-managesieve/NEWS	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/NEWS	2008-04-26 02:45:15.000000000 -0600
@@ -0,0 +1,171 @@
+Dovecot 1.1:
+
+v0.10.2
+	* Fixed bug that caused SASL mechanisms that require more than a single client
+	  response to fail. Reported by Steffen Kaiser and occured when he tried using 
+	  the (obsolete) LOGIN mechanism.
+  * Updated installation and configuration documentation to match the 
+    information provided in the wiki
+
+v0.10.1
+	* Fixed bug introduced in v0.10.0: compiled scripts were also written to disk
+	  in the sieve/tmp directory and left there. This accumulates much .sievec 
+	  junk in that directory over time. 
+	* Fixed bug in tmp file generation for sieve-storage: errors other than EEXIST
+	  would cause the daemon to sleep() loop indefinitely. 
+	  
+	+ Improved log lines to be more recognizable as being generated from 
+	  managesieve.
+	+ Added short proxy configuration explanation to the README file
+	+ Added 'Known Issues' section to the README file
+	- Fixed assert bug in sieve-storage occuring when save is canceled.
+  
+v0.10.0
+	* Upgraded to Dovecot 1.1:
+		- The actual managesieve implementation is now a separate package. 
+		  The dovecot tree still needs to be patched though to make dovecot 
+		  recognize the new managesieve service.
+		- Incorporated changes to imap/imap-login into the equivalent 
+		  managesieve processes.
+		- Removed cmusieve implementation from managesieve sources. It is 
+		  now linked externally from the dovecot-sieve-1.1 package. 
+		- Restructured README.managesieve file into separate README, NEWS, 
+		  TODO, DESIGN and INSTALL files. 
+	* Added support for new libsieve implementation (to be released). This 
+	  package can be compiled with either the new or the old Sieve
+	  implementation (autodetected). If the new Sieve becomes stable, this 
+	  package will be merged with it to make a single package for Dovecot 
+	  Sieve support.
+   
+Dovecot 1.0:
+
+(development forked, v9 is still maintained for Dovecot v1.0)
+
+v9
+
++ Definitively fixed the segfault mentioned in V8. It proved to be 
+  very time-constrained and thus hard to reproduce. The error turned out
+  to be related to the input handling of the login daemon during 
+  authentication. 
++ Checked for changes in the imap daemon that weren't propagated to the 
+  managesieve implementation due to code duplication.
++ Fixed a bug in the autodetection of the sieve storage location.
++ Fixed bug in the sieve storage that failed to refresh the symlink if
+  the storage was moved. 
++ Improved error handing in the sieve-storage implementation in various 
+  places. 
++ Fixed the situation in which the active script link is located in the 
+  sieve storage. 
++ Added managesieve configuration to dovecot-example.conf and made the example
+  in this file more concise. 
+
+v8
+
++ Fixed a few incompatibilities with 1.0.7 version. For instance, the "Logged
+  in" message is now sent by the -login process and not by the managesieve 
+  daemon anymore. This caused a segfault every once in a while. 
++ Probably fixed the settings problem reported by Steffen Kaiser regarding 
+  login_dir. 'dovecot -n' now reports correct results, but testing will show
+  whether the whole problem is solved.
++ The managesieve daemon now accepts the sieve_storage and sieve configuration
+  settings, so it is now possible to explicitly configure the location of the
+  sieve storage and the active script respectively. The daemon still falls back
+  to using the mail_location (MAIL) settings if nothing else is specified. 
++ The cyrus timsieved does not use the + character in string literals and many
+  clients have adopted to this behaviour. The latest managesieve (08) advises to
+  accept a missing + from clients. The server should not send any + characters 
+  as well. This behavior is now implemented on the server. 
++ Cleaned up sieve-storage.c: split up the sieve_storage_create function in 
+  various sub-functions for obtaining the various paths and directories.
++ Forced manual intervention if rescueing a non-symlink file at the active script
+  path fails somehow. Previously, this presented the admin with a log message 
+  that it had just eaten the script, which is not very nice. 
++ Restructured the README.managesieve file and added some more explanation with
+  regard to the configuration of the daemon.
+
+v7 
+
+- Robin Breathe indicated that the regex capability was missing in the server's
+  SIEVE listing. It turns out I forgot to make arrangements for setting 
+  ENABLE_REGEX in the cmu libsieve sources, so the regex extension was not
+  compiled in. I copied the configure.in section regarding ENABLE_REGEX from 
+  dovecot-sieve-1.0.2 and that fixed the problem.
+
+v6
+
+- Corked the client output stream while producing the capability greeting and on 
+  other some other occasions as well. Some naive client implementations expect to 
+  receive this as a single tcp frame and it is a good practice to do so anyway.
+  Using this change the Thunderbird sieve extension (v0.1.1) seemed to work. However,
+  scripts larger than a tcp frame still caused failures. All these issues are fixed
+  in the latest version of the sieve add-on (currently v0.1.4). 
+- Cleaned up the new proxy source. My editor made the indentation a complete mess
+  in terms of TABs vs spaces. 
+- Added TRYLATER response codes to BYE and NO messages where appropriate.  
+- Recopied the libsieve library into this patch to incorporate any changes that were
+  made (only sieve-cmu.c still needs to be compared to the old cmu-sieve.c). This 
+  also solves the __attribute__((unused)) GCC dependencies. These were fixed long
+  ago by Timo....  the code duplication beast strikes again. 
+- Removed spurious return value from void function in 
+  src/lib-sieve/sieve-implementation.c as reported by Robin Breathe. GCC fails to
+  report these issues. The function involved is currently not used and serves only
+  as an example on how dovecot could support multiple sieve backends... 
+
+v5 
+
+- Applied patch by Uldis Pakuls to fix master_dump_settings bug
+- Added some compilation/installation info to this README
+- Moved README to source tree root as README.managesieve
+- Fixed minor error handling bug in sieve_storage.c with respect to a missing
+  root directory.
+- Now sieve capabilities are reported as they are specified by the implementing
+  library and not in forced upper case. The sieve RFC now explicitly states
+  that sieve capability identifiers are case-sensitive. This broke compatibility
+  with SquirrelMail/Avelsieve. 
+- Disabled ANONYMOUS login entirely until proper support is implemented. V4
+  claimed to do so as well, but in fact it only stopped announcing it.
+- Implemented managesieve-proxy. It is not so much a clean copy of imap-proxy,
+  since the managesieve greeting is much more complex and requires parsing. 
+  Configuration is identical to imap-proxy. This seems to be a little under-
+  documented however (http://wiki.dovecot.org/PasswordDatabase/ExtraFields).  
+
+v4
+
+- Added managesieve_implementation_string setting to the managesieve 
+  configuration. This can be used to customize the default "IMPLEMENTATION" 
+  capability response.
+- Denied ANONYMOUS login until proper support is implemented
+- Fixed problem with authenticate command regarding continued responses. In
+  V3 only initial response would work. Problem was caused by rc2 -> rc28 
+  upgrade. One of the clear reasons why code duplication is a very bad idea.
+- Fixed readlink bug as indicated by Timo: return value of readlink can also
+  be -1.
+- Fixed bug in the regular file rescue code, as introduced in the previous 
+  version. Used stat instead of lstat. This caused the symlink to be rescued 
+  subsequently in the next activation, thus still overwriting the initially 
+  rescued script.
+
+v3
+
+- Updated source to compile with dovecot 1.0.rc27 
+- Daemon now uses the same location for .dovecot.sieve as dovecot-lda
+  This is typically ~/.dovecot.sieve
+- If .dovecot.sieve is a regular file, it is now moved into the script storage as
+  dovecot.orig.sieve, preventing deletion of (important) active scripts 
+  upon upgrade.
+- Changed error handling to yield a BYE message when the managesieve 
+  daemon exits unexpectedly (upon login) before any commands are entered. 
+  Horde-ingo would wait indefinitely for a response. 
+
+v2
+
+- Fixed the bug (missing CRLF) in the authenticate command
+- Modified the sieve storage library making the interface much less crude.
+- The scripts put on the server using the putscript command are now 
+  checked before they are accepted.
+- The reported SIEVE capability is now directly read from the sieve 
+  implementation (in this case cmu), listing much more than "FILEINTO 
+  VACATION".
+- Imported instance of libsieve source into this patch for implementation
+  of script checking and capability listing. THIS NEEDS TO BE CHANGED! 
+- Fixed some minor bugs in the putscript command
diff -urN dovecot-1.1.1/dovecot-managesieve/README dovecot-1.1.1-managesieve/dovecot-managesieve/README
--- dovecot-1.1.1/dovecot-managesieve/README	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/README	2008-04-26 02:57:01.000000000 -0600
@@ -0,0 +1,163 @@
+
+MANAGESIEVE implementation for Dovecot (1.1)
+
+Compile
+-------
+
+Refer to INSTALL file.
+ 
+Configure
+---------
+
+**NOTE**: If you have used the sieve plugin before and you have .dovecot.sieve 
+files in user directories, you are advised to make a backup first. Although the 
+managesieve daemon takes care to move these files to the sieve storage before it 
+is substituted with a symbolic link, this is not a very well tested operation, 
+meaning that there is a possibility that existing sieve scripts get lost.
+
+Along with all other binaries that dovecot uses, the managesieve and 
+managesieve-login binaries are installed during make install. The only thing you 
+need to do to activate the ManageSieve support in dovecot is to add managesieve 
+to the protocols= configuration line in your dovecot.conf. The managesieve 
+daemon will listen on port 2000 by default. As the implementation of the 
+managesieve daemon is largely based on the original IMAP implementation, it is 
+very similar in terms of configuration. In addition to most mail daemon config 
+settings, the managesieve daemon accepts a few more. The following settings can 
+be configured in the protocol managesieve section:
+
+listen = *:2000
+    IP or host address where to listen in for connections. 
+
+login_executable = /usr/libexec/dovecot/managesieve-login
+    Login executable location. 
+
+mail_executable = /usr/libexec/dovecot/managesieve
+    managesieve executable location. See mail_executable for IMAP for examples 
+    how this could be changed. 
+    
+managesieve_max_line_length = 65536
+    Maximum managesieve command line length in bytes. This setting is directly 
+    borrowed from IMAP. But, since long command lines are very unlikely with 
+    ManageSieve, changing this will not be very useful. 
+
+sieve_storage =
+    This specifies the path to the directory where the uploaded scripts are 
+    stored. In terms of '%' variable substitution it is identical to dovecot's 
+    mail_location setting used by the mail protocol daemons. Scripts are stored 
+    as separate files with extension .sieve, all other files are ignored when 
+    scripts are listed by a ManageSieve client. If this setting remains 
+    unspecified, the mail_location setting is used as explained below. 
+
+sieve = ~/.dovecot.sieve
+    Specifies the location of the symbolic link pointing to the active script in
+    the sieve storage directory. This must match the sieve setting used by 
+    deliver. Variable substitution with % is recognized. If a regular file 
+    exists at this location, it is moved to the sieve_storage location before 
+    the symbolic link is installed. It is renamed to dovecot.orig.sieve and 
+    therefore listed as dovecot.orig by a ManageSieve client. 
+
+mail_location =
+    If, for some inobvious reason, the sieve_storage remains unset, the 
+    managesieve daemon uses the specification of the mail_location to find out 
+    where to store the sieve files. However, this is provided only for backwards 
+    compatibility and you should always use the sieve_storage setting in stead. 
+
+managesieve_implementation_string = dovecot
+    To fool ManageSieve clients that are focused on CMU's timesieved you can 
+    specify the IMPLEMENTATION capability that the dovecot reports to clients 
+    (e.g. 'Cyrus timsieved v2.2.13'). 
+
+Scripts are stored at the location specified by the sieve_storage setting. The
+active sieve script is managed as a symbolic link pointing to the active script
+in the sieve storage direcotory. The location of this symlink can be specified
+with the 'sieve' setting. Make sure this setting is identical to what deliver is
+using for the Sieve plugin. The default location is ~/.dovecot.sieve. Note that
+if a file starting with '.' is placed inside a Maildir, it will be recognized as
+a folder, so try to avoid that.
+
+The current version of the managesieve daemon places the script storage 
+directory in the mail folder as specified by the 'mail_location' setting if no 
+'sieve_storage' is specified. Actually, it is placed in the CONTROL= directory 
+of 'mail_location' if specified, otherwise the sieve directory is placed in the 
+root of the mail location. In a mail or mail control directory, scripts are 
+always stored in a 'sieve' subdirectory. Note that for some mail storage types 
+(e.g. mbox) this script directory is listed as a mail folder, so be sure to put 
+the sieve scripts somewhere else if you can.
+
+A storage location specified by 'sieve_storage' is always generated 
+automatically if it does not exist (as far as the system permits the user to do 
+so; no root privileges are used). This is similar to the behaviour of the mail 
+daemons. Note that when 'mail_location' is used to specify the script storage 
+location, only the 'sieve' subdirectory is generated automatically.
+
+The following provides an example configuration for ManageSieve in dovecot.conf. 
+Only sections relevant to ManageSieve are shown. Refer to dovecot-example.conf 
+in your patched dovecot tree for a full example with comments, but don't forget 
+to add managesieve to the protocols setting if you use it.
+
+# Start imap, pop3 and managesieve services
+protocols = imap pop3 managesieve
+
+protocol managesieve {
+  # Specify an alternative address:port the daemon must listen on
+  # (default: *:2000)
+  #listen = localhost:2000
+
+  sieve=~/.dovecot.sieve
+  sieve_storage=~/sieve
+}
+
+Proxying
+--------
+
+Like Dovecot's imapd, the ManageSieve login daemon supports proxying to multiple
+backend servers. Although the underlying code is copied from the imapd sources
+for the most part, it has some ManageSieve-specifics that have not seen much
+testing. 
+
+The proxy configuration wiki page for POP3 and IMAP should apply to ManageSieve 
+as well:
+
+http://wiki.dovecot.org/PasswordDatabase/ExtraFields/Proxy
+
+Known Issues
+------------
+
+* Although this ManageSieve server should comply with the draft specification of 
+  the ManageSieve protocol, quite a few clients don't. This is particularly true 
+  for the TLS support. However, now that Cyrus' Timsieved has changed its 
+  behavior towards protocol compliance, all those clients will follow 
+  eventually. 
+
+  Clients known to have TLS issues:
+	- Thunderbird Sieve add-on: author is working on it
+	- AvelSieve: patch on the wiki:	http://wiki.dovecot.org/ManageSieve
+	- KMail + kio_sieve: ...?
+
+  Unfortunately, there is no reliable way to provide a workaround for this
+  problem. We will have to wait for the authors of these clients to make the
+  proper adjustments. 
+  
+* Other client issues:
+
+	- SmartSieve, WebSieve: 
+	    These clients are specifically written for Cyrus timsieved and fail on 
+	    multiple stages of the protocol when connected to Dovecot ManageSieve.
+	    
+* The current implementation of the daemon does not have quota enforcement as
+  recommended in the specification. So keep in mind that malicious users could
+  fill your filesystem with loads of spurious scriptfiles.
+  
+* The ANONYMOUS authentication mechanism is currently not supported and 
+  explicitly denied. 
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about 
+this package. You can post to the list without subscribing, the mail then waits 
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/imparse.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/imparse.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/imparse.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/imparse.c	2008-05-04 08:29:12.000000000 -0600
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+#include "imparse.h"
+
+int imparse_isatom(const char *s)
+{
+    int len = 0;
+
+    if (!*s) return 0;
+    for (; *s; s++) {
+	len++;
+	if (*s & 0x80 || *s < 0x1f || *s == 0x7f ||
+	    *s == ' ' || *s == '{' || *s == '(' || *s == ')' ||
+	    *s == '\"' || *s == '%' || *s == '*' || *s == '\\') return 0;
+    }
+    if (len >= 1024) return 0;
+    return 1;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/Makefile.am	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,34 @@
+noinst_LTLIBRARIES = libsieve_cmu.la
+
+MOSTLYCLEANFILES = imparse.c map.c
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_sievedir)/src/ \
+	-I$(dovecot_sievedir)/src/libsieve 
+
+sieve_plugin=$(dovecot_sievedir)/src/libsieve/libsieve.la
+
+libsieve_cmu_la_DEPENDENCIES = $(sieve_plugin)
+libsieve_cmu_la_LIBADD = $(sieve_plugin)
+
+libsieve_cmu_la_SOURCES = \
+	imparse.c \
+	map.c \
+	sieve-error.c \
+	sieve-script.c \
+	sieve.c 
+
+noinst_HEADERS = \
+	sieve-common.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve.h
+
+imparse.c map.c: $(dovecot_sievedir)/src/$@
+	cp $(dovecot_sievedir)/src/$@ $@
+
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/Makefile.in dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/Makefile.in
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/Makefile.in	2008-05-04 08:28:51.000000000 -0600
@@ -0,0 +1,478 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-cmusieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+am__DEPENDENCIES_1 = $(dovecot_sievedir)/src/libsieve/libsieve.la
+am_libsieve_cmu_la_OBJECTS = imparse.lo map.lo sieve-error.lo \
+	sieve-script.lo sieve.lo
+libsieve_cmu_la_OBJECTS = $(am_libsieve_cmu_la_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libsieve_cmu_la_SOURCES)
+DIST_SOURCES = $(libsieve_cmu_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+HAVE_DOVECOT_LIBS_FALSE = @HAVE_DOVECOT_LIBS_FALSE@
+HAVE_DOVECOT_LIBS_TRUE = @HAVE_DOVECOT_LIBS_TRUE@
+HAVE_OLD_SIEVE_PLUGIN_FALSE = @HAVE_OLD_SIEVE_PLUGIN_FALSE@
+HAVE_OLD_SIEVE_PLUGIN_TRUE = @HAVE_OLD_SIEVE_PLUGIN_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MODULE_LIBS = @MODULE_LIBS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+noinst_LTLIBRARIES = libsieve_cmu.la
+MOSTLYCLEANFILES = imparse.c map.c
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_sievedir)/src/ \
+	-I$(dovecot_sievedir)/src/libsieve 
+
+sieve_plugin = $(dovecot_sievedir)/src/libsieve/libsieve.la
+libsieve_cmu_la_DEPENDENCIES = $(sieve_plugin)
+libsieve_cmu_la_LIBADD = $(sieve_plugin)
+libsieve_cmu_la_SOURCES = \
+	imparse.c \
+	map.c \
+	sieve-error.c \
+	sieve-script.c \
+	sieve.c 
+
+noinst_HEADERS = \
+	sieve-common.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/lib-cmusieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/lib-cmusieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_cmu.la: $(libsieve_cmu_la_OBJECTS) $(libsieve_cmu_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_cmu_la_LDFLAGS) $(libsieve_cmu_la_OBJECTS) $(libsieve_cmu_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/imparse.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/map.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-script.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am \
+	uninstall-info-am
+
+
+imparse.c map.c: $(dovecot_sievedir)/src/$@
+	cp $(dovecot_sievedir)/src/$@ $@
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/map.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/map.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/map.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/map.c	2008-05-04 08:29:13.000000000 -0600
@@ -0,0 +1,55 @@
+#include "lib.h"
+#include "map.h"
+
+#include <unistd.h>
+
+static ssize_t read_full_n(int fd, void *data, size_t size)
+{
+	ssize_t ret, all_ret = 0;
+
+	while (size > 0) {
+		ret = read(fd, data, size);
+		if (ret <= 0)
+			return ret;
+
+		data = PTR_OFFSET(data, ret);
+		all_ret += ret;
+		size -= ret;
+	}
+
+	return all_ret;
+}
+
+void map_refresh(int fd, int onceonly ATTR_UNUSED, const char **base,
+		 unsigned long *len, unsigned long newlen,
+		 const char *name, const char *mboxname ATTR_UNUSED)
+{
+	ssize_t ret;
+	void *p;
+
+	if (newlen == 0) {
+		/* the file is a broken zero-byte file */
+		*len = 0;
+		return;
+	}
+
+	*base = p = i_malloc(newlen);
+	*len = newlen;
+
+	ret = read_full_n(fd, p, newlen);
+	if (ret < 0) {
+		i_error("read_full_n(%s) failed: %m", name);
+		ret = 0;
+	}
+
+	*len = ret;
+}
+
+void map_free(const char **base, unsigned long *len ATTR_UNUSED)
+{
+	char *x = (char *) *base;
+
+	i_free(x);
+	*base = NULL;
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve.c	2008-03-01 15:48:42.000000000 -0700
@@ -0,0 +1,367 @@
+/* Copyright (C) 2005-2006 Timo Sirainen */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "array.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "libsieve/sieve_interface.h"
+
+#include "sieve.h"
+#include "sieve-script.h"
+
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+/* data per script */
+typedef struct script_data {
+	struct sieve_error_handler *ehandler;
+} script_data_t;
+
+static sieve_interp_t *_interp;
+
+struct et_list *_et_list = NULL;
+
+static int
+cmu_sieve_compile(script_data_t *sdata, const char *script_path,
+		      const char *compiled_path);
+
+/* gets the header "head" from msg. */
+static int getheader
+(void *v ATTR_UNUSED, const char *phead ATTR_UNUSED, const char ***body ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+static int getsize(void *mc ATTR_UNUSED, int *size ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int getenvelope
+(void *mc ATTR_UNUSED, const char *field ATTR_UNUSED, 
+	const char ***contents ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+static int getbody
+(void *mc ATTR_UNUSED, const char **content_types ATTR_UNUSED,
+	int decode_to_plain ATTR_UNUSED, sieve_bodypart_t **parts_r ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int getinclude(void *sc, const char *script, int isglobal,
+		      char *fname, size_t size)
+{
+	script_data_t *sdata = (script_data_t *) sc;
+	const char *script_path, *compiled_path, *home, *script_dir;
+	int ret;
+
+	if (strchr(script, '/') != NULL) {
+		i_info("include: '/' not allowed in script names (%s)",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+
+	if (isglobal) {
+		script_dir = getenv("SIEVE_GLOBAL_DIR");
+		if (script_dir == NULL) {
+			i_info("include: global_script_dir not set "
+			       "(wanted script %s)", str_sanitize(script, 80));
+			return SIEVE_FAIL;
+		}
+		script_path = t_strdup_printf("%s/%s", script_dir, script);
+	} else {
+		home = getenv("SIEVE_DIR");
+		if (home == NULL)
+			home = getenv("HOME");
+		if (home == NULL) {
+			i_info("include: sieve_dir and home not set "
+			       "(wanted script %s)", str_sanitize(script, 80));
+			return SIEVE_FAIL;
+		}
+		script_path = t_strdup_printf("%s/%s", home, script);
+	}
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = cmu_sieve_compile(sdata, script_path, compiled_path);
+	if (ret < 0) {
+		i_info("include: Error compiling script '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+	if (ret == 0) {
+		i_info("include: Script not found: '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+
+	if (i_strocpy(fname, compiled_path, size) < 0) {
+		i_info("include: Script path too long: '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+	return SIEVE_OK;
+}
+
+static int sieve_redirect
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED,  void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+static int sieve_discard
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_reject
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_fileinto
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_keep
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_notify
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED,
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int autorespond
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED,
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int send_response
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+/* vacation support */
+sieve_vacation_t vacation = {
+    1,				/* min response */
+    31,				/* max response */
+    &autorespond,		/* autorespond() */
+    &send_response		/* send_response() */
+};
+
+/* imapflags support */
+static char *markflags[] = { "\\flagged" };
+static sieve_imapflags_t mark = { markflags, 1 };
+
+static int sieve_parse_error_handler(int lineno, const char *msg, 
+				     void *ic ATTR_UNUSED,
+				     void *sc)
+{
+    script_data_t *sd = (script_data_t *) sc;
+
+	sieve_error(sd->ehandler, t_strdup_printf("line %d", lineno), "%s", msg);
+    return SIEVE_OK;
+}
+
+static int sieve_execute_error_handler(const char *msg, 
+				       void *ic ATTR_UNUSED,
+				       void *sc ATTR_UNUSED,
+				       void *mc ATTR_UNUSED)
+{
+    i_info("sieve runtime error: %s", msg);
+    return SIEVE_OK;
+}
+ 
+static int
+cmu_sieve_compile(script_data_t *sdata, const char *script_path,
+		      const char *compiled_path)
+{
+	struct stat st, st2;
+	sieve_script_t *script;
+	bytecode_info_t *bc;
+	const char *temp_path;
+	FILE *f;
+	int fd, ret;
+
+	if (stat(script_path, &st) < 0) {
+		if (errno == ENOENT) {
+			if (getenv("DEBUG") != NULL) {
+				i_info("cmusieve: Script not found: %s",
+				       script_path);
+			}
+			return 0;
+		}
+		i_error("cmusieve: stat(%s) failed: %m", script_path);
+		return -1;
+	}
+	if ( compiled_path != NULL ) {
+		if (stat(compiled_path, &st2) < 0) {
+			if (errno != ENOENT) {
+				i_error("cmusieve: stat(%s) failed: %m", script_path);
+				return -1;
+			}
+		} else {
+			if (st.st_mtime < st2.st_mtime)
+				return 1;
+		}
+	}
+
+	/* need to compile */
+	f = fopen(script_path, "r");
+	if (f == NULL) {
+		i_error("cmusieve: fopen(%s) failed: %m", script_path);
+		return -1;
+	}
+
+	ret = sieve_script_parse(_interp, f, sdata, &script);
+	if (ret != SIEVE_OK) {
+		if ( sieve_get_errors(sdata->ehandler) == 0 ) {
+			sieve_error(sdata->ehandler, "unknown location", 
+				"parse error %d", ret);
+		}
+		return -1;
+	} 
+
+	if (sieve_generate_bytecode(&bc, script) < 0) {
+		i_error("sieve_generate_bytecode() failed");
+		return -1;
+	}
+
+	if ( compiled_path != NULL ) {
+		/* write to temp file */
+		temp_path = t_strconcat(compiled_path, ".tmp", NULL);
+		fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+		if(fd == -1) {
+			i_error("cmusieve: open(%s) failed: %m", temp_path);
+			return -1;
+		}
+
+		if (sieve_emit_bytecode(fd, bc) < 0) {
+			i_error("cmusieve: sieve_emit_bytecode() failed");
+			return -1;
+		}
+
+		if (close(fd) < 0)
+			i_error("cmusieve: close() failed: %m");
+
+		/* and finally replace the script */
+		if (rename(temp_path, compiled_path) < 0) {
+			i_error("cmusieve: rename(%s, %s) failed: %m", temp_path, compiled_path);
+			return -1;
+		}
+	}
+	return 1;
+}
+
+struct sieve_binary *sieve_compile_script
+    (struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	script_data_t sdata;
+	const char *script_path = sieve_script_path(script);
+	const char *compiled_path;
+	int ret;
+
+	memset(&sdata, 0, sizeof(sdata));
+	sdata.ehandler = ehandler;
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = cmu_sieve_compile(&sdata, script_path, NULL);
+	if (ret <= 0)
+		return NULL;
+
+	return (struct sieve_binary *) 1; 
+}
+
+const char *sieve_get_capabilities(void)
+{
+	return sieve_listextensions(_interp);
+}
+
+bool sieve_init(const char *plugins ATTR_UNUSED)
+{
+    int res;
+
+    _interp = NULL;
+
+    res = sieve_interp_alloc(&_interp, NULL);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_interp_alloc() returns %d\n", res);
+
+    res = sieve_register_redirect(_interp, &sieve_redirect);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_redirect() returns %d\n", res);
+    res = sieve_register_discard(_interp, &sieve_discard);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_discard() returns %d\n", res);
+    res = sieve_register_reject(_interp, &sieve_reject);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_reject() returns %d\n", res);
+    res = sieve_register_fileinto(_interp, &sieve_fileinto);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_fileinto() returns %d\n", res);
+    res = sieve_register_keep(_interp, &sieve_keep);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_keep() returns %d\n", res);
+    res = sieve_register_imapflags(_interp, &mark);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_imapflags() returns %d\n", res);
+    res = sieve_register_notify(_interp, &sieve_notify);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_notify() returns %d\n", res);
+    res = sieve_register_size(_interp, &getsize);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_size() returns %d\n", res);
+    res = sieve_register_header(_interp, &getheader);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_header() returns %d\n", res);
+
+    res = sieve_register_envelope(_interp, &getenvelope);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_envelope() returns %d\n", res);
+    res = sieve_register_body(_interp, &getbody);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_body() returns %d\n", res);
+    res = sieve_register_include(_interp, &getinclude);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_registerinclude() returns %d\n", res);
+    res = sieve_register_vacation(_interp, &vacation);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_vacation() returns %d\n", res);
+    res = sieve_register_parse_error(_interp, &sieve_parse_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_parse_error() returns %d\n", res);
+    res = sieve_register_execute_error(_interp,  &sieve_execute_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_execute_error() returns %d\n", res);
+
+	return TRUE;
+}
+
+void sieve_deinit(void)
+{
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-common.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-common.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-common.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-common.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,10 @@
+#ifndef __SIEVE_COMMON_H
+#define __SIEVE_COMMON_H
+
+/* sieve-error.h */
+struct sieve_error_handler;
+
+/* sieve-script.h */
+struct sieve_script;
+
+#endif /* SIEVE_COMMON_H */
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-error.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-error.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-error.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-error.c	2008-02-13 05:04:52.000000000 -0700
@@ -0,0 +1,395 @@
+#include <stdio.h>
+
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+
+#include "sieve-error-private.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#define CRITICAL_MSG \
+	"internal error occurred: refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+	
+	if ( ehandler->log_master )
+		i_error("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+
+	ehandler->verror(ehandler, location, fmt, args);
+	ehandler->errors++;
+}
+
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master )
+		i_warning("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+		
+	ehandler->vwarning(ehandler, location, fmt, args);
+	ehandler->warnings++;
+}
+
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master )
+		i_info("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+	
+	if ( ehandler->log_info )	
+		ehandler->vinfo(ehandler, location, fmt, args);
+}
+
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	char str[256];
+	struct tm *tm; 
+	
+	tm = localtime(&ioloop_time);
+	
+	i_error("sieve: error: %s: %s", location, t_strdup_vprintf(fmt, args));
+	
+	if ( ehandler == NULL ) return;
+	
+	sieve_error(ehandler, location, "%s", 
+		strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ? 
+			str : CRITICAL_MSG );	
+}
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler) {
+	if ( ehandler == NULL ) return 0;
+	
+	return ehandler->errors;
+}
+
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler) {
+	if ( ehandler == NULL ) return 0;
+
+	return ehandler->errors;
+}
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_info = enable;	
+}
+
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_master = enable;
+}
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool)
+{
+	ehandler->pool = pool;
+	ehandler->refcount = 1;
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL ) return;
+
+	ehandler->refcount++;
+}
+
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler)
+{
+	if ( *ehandler == NULL ) return;
+
+    i_assert((*ehandler)->refcount > 0);
+
+    if (--(*ehandler)->refcount != 0)
+        return;
+
+	if ( (*ehandler)->free != NULL )
+		(*ehandler)->free(*ehandler);
+
+	pool_unref(&((*ehandler)->pool));
+
+	*ehandler = NULL;
+}
+
+/* Output errors directly to stderror (merge this with logfile below?) */
+
+static void sieve_stderr_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	fprintf(stderr, "%s: error: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	fprintf(stderr, "%s: warning: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	fprintf(stderr, "%s: info: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_stderr_ehandler_create( void ) 
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+	
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("stderr_error_handler", sizeof(struct sieve_error_handler));
+//		("stderr_error_handler", 128);	
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool);
+
+	ehandler->verror = sieve_stderr_verror;
+	ehandler->vwarning = sieve_stderr_vwarning;
+	ehandler->vinfo = sieve_stderr_vinfo;
+	
+	return ehandler;	
+}
+
+/* Output errors to a string buffer */
+
+struct sieve_strbuf_ehandler {
+    struct sieve_error_handler handler;
+
+	string_t *errors;
+};
+
+static void sieve_strbuf_verror
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+    struct sieve_strbuf_ehandler *handler =
+        (struct sieve_strbuf_ehandler *) ehandler;
+
+	str_printfa(handler->errors, "%s: error: ", location);
+	str_vprintfa(handler->errors, fmt, args);
+	str_append(handler->errors, ".\n");
+}
+
+static void sieve_strbuf_vwarning
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+    struct sieve_strbuf_ehandler *handler =
+        (struct sieve_strbuf_ehandler *) ehandler;
+
+	str_printfa(handler->errors, "%s: warning: ", location);
+    str_vprintfa(handler->errors, fmt, args);
+    str_append(handler->errors, ".\n");
+}
+
+static void sieve_strbuf_vinfo
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+    struct sieve_strbuf_ehandler *handler =
+        (struct sieve_strbuf_ehandler *) ehandler;
+	
+	str_printfa(handler->errors, "%s: info: ", location);
+    str_vprintfa(handler->errors, fmt, args);
+    str_append(handler->errors, ".\n");
+}
+
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+(string_t *strbuf)
+{
+    pool_t pool;
+    struct sieve_strbuf_ehandler *ehandler;
+
+    pool = pool_alloconly_create("strbuf_error_handler", 256);
+    ehandler = p_new(pool, struct sieve_strbuf_ehandler, 1);
+	ehandler->errors = strbuf;
+    
+	sieve_error_handler_init(&ehandler->handler, pool);
+
+    ehandler->handler.verror = sieve_strbuf_verror;
+    ehandler->handler.vwarning = sieve_strbuf_vwarning;
+    ehandler->handler.vinfo = sieve_strbuf_vinfo;
+
+    return &(ehandler->handler);
+}
+
+/* Output errors to a log file */
+
+struct sieve_logfile_ehandler {
+	struct sieve_error_handler handler;
+	
+	const char *logfile;
+	bool started;
+	int fd;
+	struct ostream *stream;
+};
+
+static void sieve_logfile_vprintf
+(struct sieve_logfile_ehandler *ehandler, const char *location, 
+	const char *prefix,	const char *fmt, va_list args) 
+{
+	string_t *outbuf;
+	
+	if ( ehandler->stream == NULL ) return;
+	
+	T_BEGIN {
+		outbuf = t_str_new(256);
+		str_printfa(outbuf, "%s: %s: ", location, prefix);	
+		str_vprintfa(outbuf, fmt, args);
+		str_append(outbuf, ".\n");
+	
+		o_stream_send(ehandler->stream, str_data(outbuf), str_len(outbuf));
+	} T_END;
+}
+
+inline static void sieve_logfile_printf
+(struct sieve_logfile_ehandler *ehandler, const char *location, const char *prefix,
+	const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	sieve_logfile_vprintf(ehandler, location, prefix, fmt, args);
+	
+	va_end(args);
+}
+
+static void sieve_logfile_start(struct sieve_logfile_ehandler *ehandler)
+{
+	int fd;
+	struct ostream *ostream = NULL;
+	struct tm *tm;
+	char buf[256];
+	time_t now;
+
+	fd = open(ehandler->logfile, O_CREAT | O_APPEND | O_WRONLY, 0600);
+	if (fd == -1) {
+		i_error("sieve: Failed to open logfile %s (logging to STDERR): %m", 
+			ehandler->logfile);
+		fd = STDERR_FILENO;
+	}
+	/* else
+		fd_close_on_exec(fd, TRUE); Necessary? */
+
+	ostream = o_stream_create_fd(fd, 0, FALSE);
+	if ( ostream == NULL ) {
+		/* Can't we do anything else in this most awkward situation? */
+		i_error("sieve: Failed to open log stream on open file %s. "
+			"Nothing will be logged.", 
+			ehandler->logfile);
+	} 
+
+	ehandler->fd = fd;
+	ehandler->stream = ostream;
+	ehandler->started = TRUE;
+	
+	if ( ostream != NULL ) {
+		now = time(NULL);	
+		tm = localtime(&now);
+
+		if (strftime(buf, sizeof(buf), "%b %d %H:%M:%S", tm) > 0) {
+			sieve_logfile_printf(ehandler, "sieve", "info",
+				"started log at %s", buf);
+		}
+	}
+}
+
+static void sieve_logfile_verror
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "error", fmt, args);
+}
+
+static void sieve_logfile_vwarning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "warning", fmt, args);
+}
+
+static void sieve_logfile_vinfo
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "info", fmt, args);
+}
+
+
+static void sieve_logfile_free
+(struct sieve_error_handler *ehandler)
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+		
+	if ( handler->stream != NULL ) {
+		o_stream_destroy(&(handler->stream));
+		if ( handler->fd != STDERR_FILENO )
+			close(handler->fd);
+	}
+}
+
+struct sieve_error_handler *sieve_logfile_ehandler_create(const char *logfile) 
+{
+	pool_t pool;
+	struct sieve_logfile_ehandler *ehandler;
+	
+	pool = pool_alloconly_create("logfile_error_handler", 256);	
+	ehandler = p_new(pool, struct sieve_logfile_ehandler, 1);
+	sieve_error_handler_init(&ehandler->handler, pool);
+
+	ehandler->handler.verror = sieve_logfile_verror;
+	ehandler->handler.vwarning = sieve_logfile_vwarning;
+	ehandler->handler.vinfo = sieve_logfile_vinfo;
+	ehandler->handler.free = sieve_logfile_free;
+	
+	/* Don't open logfile until something is actually logged. 
+	 * Let's not pullute the sieve directory with useless logfiles.
+	 */
+	ehandler->logfile = p_strdup(pool, logfile);
+	ehandler->started = FALSE;
+	ehandler->stream = NULL;
+	ehandler->fd = -1;
+	
+	return &(ehandler->handler);	
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-error.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-error.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-error.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-error.h	2008-02-13 05:06:32.000000000 -0700
@@ -0,0 +1,117 @@
+#ifndef __SIEVE_ERROR_H
+#define __SIEVE_ERROR_H
+
+#include "lib.h"
+#include "compat.h"
+
+#include <stdarg.h>
+
+struct sieve_error_handler;
+
+typedef void (*sieve_error_vfunc_t)
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+
+/* For these functions it is the responsibility of the caller to
+ * manage the datastack.
+ */
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN {
+		sieve_verror(ehandler, location, fmt, args);
+	} T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN {
+		sieve_vwarning(ehandler, location, fmt, args);
+	} T_END;
+
+	va_end(args);
+}
+
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN {
+		sieve_vinfo(ehandler, location, fmt, args);
+	} T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { 
+		sieve_vcritical(ehandler, location, fmt, args);
+	} T_END;
+	
+	va_end(args);
+}
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable);
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable);
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler);
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler);
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler);
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler);
+
+/* Error handlers */
+
+struct sieve_error_handler *sieve_stderr_ehandler_create(void);
+struct sieve_error_handler *sieve_strbuf_ehandler_create(string_t *strbuf);
+struct sieve_error_handler *sieve_logfile_ehandler_create(const char *logfile);  
+
+#endif /* __SIEVE_ERROR_H */
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,38 @@
+#ifndef __SIEVE_ERROR_PRIVATE_H
+#define __SIEVE_ERROR_PRIVATE_H
+
+#include "sieve-error.h"
+
+struct sieve_error_handler {
+    pool_t pool;
+	int refcount;
+
+    int errors;
+    int warnings;
+
+    /* Should we copy log to i_error, i_warning and i_info? */
+    bool log_master;
+
+    /* Should the errorhandler handle or discard info log?
+     * (This does not influence the previous setting)
+     */
+    bool log_info;
+
+    void (*verror)
+        (struct sieve_error_handler *ehandler, const char *location,
+            const char *fmt, va_list args);
+    void (*vwarning)
+        (struct sieve_error_handler *ehandler, const char *location,
+            const char *fmt, va_list args);
+    void (*vinfo)
+        (struct sieve_error_handler *ehandler, const char *location,
+            const char *fmt, va_list args);
+
+    void (*free)
+        (struct sieve_error_handler *ehandler);
+};
+
+void sieve_error_handler_init
+    (struct sieve_error_handler *ehandler, pool_t pool);
+
+#endif /* __SIEVE_ERROR_PRIVATE_H */
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve.h	2008-02-13 08:12:00.000000000 -0700
@@ -0,0 +1,23 @@
+/* Copyright (c) 2002-2007 Dovecot authors, see the included COPYING file */
+
+#ifndef __SIEVE_H
+#define __SIEVE_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+#include "sieve-error.h"
+
+struct sieve_binary;
+struct sieve_script;
+
+bool sieve_init(const char *plugins);
+void sieve_deinit(void);
+
+struct sieve_binary *sieve_compile_script
+    (struct sieve_script *script, struct sieve_error_handler *ehandler);
+
+const char *sieve_get_capabilities(void);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-script.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-script.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-script.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-script.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,201 @@
+#include "lib.h"
+#include "compat.h"
+#include "istream.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+#include "sieve-script-private.h"
+
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+/* Script object */
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	int ret;
+	pool_t pool;
+	struct stat st;
+	const char *filename, *dirpath;
+
+	if ( exists_r != NULL )
+		*exists_r = FALSE;
+
+//	t_push();
+
+	/* Extract filename from path */
+	filename = strrchr(path, '/');
+	if ( filename == NULL ) {
+		dirpath = "";
+		filename = path;
+	} else {
+		dirpath = t_strdup_until(path, filename);
+		filename++;
+	}
+	
+	if ( name == NULL || *name == '\0' ) {
+		const char *ext;
+		
+		/* Extract the script name */
+		ext = strrchr(filename, '.');
+		if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+			name = filename;
+		else
+			name = t_strdup_until(filename, ext);
+	} 
+		
+	/* First obtain stat data from the system */
+	
+	if ( (ret=stat(path, &st)) != 0 && (errno != ENOENT || exists_r == NULL) ) {
+		if ( errno == ENOENT ) 
+			sieve_error(ehandler, name, "sieve script does not exist");
+		else
+			sieve_critical(ehandler, name, "failed to stat sieve script file '%s': %m", path);
+		script = NULL;
+	} else {
+		/* Only create/init the object if it stat()s without problems */
+
+		if ( ret == 0 && !S_ISREG(st.st_mode) ) {
+			sieve_critical(ehandler, name, 
+				"sieve script file '%s' is not a regular file.", path);
+			script = NULL;
+		} else {
+			if ( exists_r != NULL )
+				*exists_r = ( ret == 0 );
+
+			if ( script == NULL ) {
+				pool = pool_alloconly_create("sieve_script", 1024);
+				script = p_new(pool, struct sieve_script, 1);
+				script->pool = pool;
+			} else 
+				pool = script->pool;
+	
+			script->refcount = 1;
+			script->ehandler = ehandler;
+			sieve_error_handler_ref(ehandler);
+	
+			memcpy((void *) &script->st, (void *) &st, sizeof(st));
+			script->path = p_strdup(pool, path);
+			script->filename = p_strdup(pool, filename);
+			script->dirpath = p_strdup(pool, dirpath);
+			script->name = p_strdup(pool, name);
+		}
+	}
+	
+//	t_pop();
+
+	return script;
+}
+
+struct sieve_script *sieve_script_create(const char *path, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+void sieve_script_ref(struct sieve_script *script)
+{
+	script->refcount++;
+}
+
+void sieve_script_unref(struct sieve_script **script)
+{
+	i_assert((*script)->refcount > 0);
+
+	if (--(*script)->refcount != 0)
+		return;
+
+	if ( (*script)->stream != NULL )
+		i_stream_destroy(&(*script)->stream);
+
+	sieve_error_handler_unref(&(*script)->ehandler);
+
+	pool_unref(&(*script)->pool);
+
+	*script = NULL;
+}
+
+/* Stream manageement */
+
+struct istream *sieve_script_open
+(struct sieve_script *script, bool *deleted_r)
+{
+	int fd;
+
+	if ( deleted_r != NULL )
+		*deleted_r = FALSE;
+
+	if ( (fd=open(script->path, O_RDONLY)) < 0 ) {
+		if ( errno == ENOENT ) 
+			if ( deleted_r == NULL ) 
+				/* Not supposed to occur, create() does stat already */
+				sieve_error(script->ehandler, script->name, 
+					"sieve script '%s' does not exist", script->name);
+			else 
+				*deleted_r = TRUE;
+		else
+			sieve_critical(script->ehandler, script->path, 
+				"failed to open sieve script: %m");
+		return NULL;
+	}	
+
+	script->stream = i_stream_create_fd(fd, SIEVE_READ_BLOCK_SIZE, TRUE);
+	
+	return script->stream;
+}
+
+void sieve_script_close(struct sieve_script *script)
+{
+	i_stream_destroy(&script->stream);
+}
+
+uoff_t sieve_script_get_size(struct sieve_script *script)
+{
+	return script->st.st_size;
+}
+
+/* Comparison */
+
+int sieve_script_cmp
+(struct sieve_script *script1, struct sieve_script *script2)
+{	
+	return ( script1->st.st_ino == script2->st.st_ino ) ? 0 : -1;
+}
+
+unsigned int sieve_script_hash(struct sieve_script *script)
+{	
+	return (unsigned int) script->st.st_ino;
+}
+
+inline bool sieve_script_older
+(struct sieve_script *script, time_t time)
+{
+	return ( script->st.st_mtime < time );
+}
+
+/* Inline accessors */
+
+inline const char *sieve_script_name(struct sieve_script *script)
+{
+	return script->name;
+}
+
+inline const char *sieve_script_filename(struct sieve_script *script)
+{
+	return script->filename;
+}
+
+inline const char *sieve_script_path(struct sieve_script *script)
+{
+	return script->path;
+}
+
+inline const char *sieve_script_binpath(struct sieve_script *script)
+{
+	return t_strconcat(script->dirpath, "/", script->name, ".svbin", NULL);
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-script.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-script.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-script.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-script.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,38 @@
+#ifndef __SIEVE_SCRIPT_H
+#define __SIEVE_SCRIPT_H
+
+#include "sieve-common.h"
+
+struct sieve_script;
+
+struct sieve_script *sieve_script_create
+	(const char *path, const char *name, 
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+void sieve_script_ref(struct sieve_script *script);
+void sieve_script_unref(struct sieve_script **script);
+
+/* Stream manageement */
+
+struct istream *sieve_script_open(struct sieve_script *script, bool *deleted_r);
+void sieve_script_close(struct sieve_script *script);
+
+uoff_t sieve_script_get_size(struct sieve_script *script);
+
+int sieve_script_cmp
+	(struct sieve_script *script1, struct sieve_script *script2);
+unsigned int sieve_script_hash(struct sieve_script *script);
+inline bool sieve_script_older(struct sieve_script *script, time_t time);
+
+static inline bool sieve_script_equals
+	(struct sieve_script *script1, struct sieve_script *script2)
+{
+	return ( sieve_script_cmp(script1, script2) == 0 );
+}
+
+inline const char *sieve_script_name(struct sieve_script *script);
+inline const char *sieve_script_filename(struct sieve_script *script);
+inline const char *sieve_script_path(struct sieve_script *script);
+inline const char *sieve_script_binpath(struct sieve_script *script);
+
+#endif /* __SIEVE_SCRIPT_H */
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,29 @@
+#ifndef __SIEVE_SCRIPT_PRIVATE_H
+#define __SIEVE_SCRIPT_PRIVATE_H
+
+#include "sieve-script.h"
+
+struct sieve_script {
+    pool_t pool;
+    unsigned int refcount;
+
+    struct stat st;
+
+    struct sieve_error_handler *ehandler;
+
+    /* Parameters */
+    const char *name;
+    const char *filename;
+    const char *dirpath;
+    const char *path;
+
+    /* Stream */
+    int fd; /* FIXME: we could use the stream's autoclose facility */
+    struct istream *stream;
+};
+
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r);
+
+#endif /* __SIEVE_SCRIPT_PRIVATE_H */
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/Makefile.am	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,15 @@
+noinst_LIBRARIES = libmanagesieve.a
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-charset \
+	-I$(dovecot_incdir)/src/lib-mail
+
+libmanagesieve_a_SOURCES = \
+	managesieve-quote.c \
+	managesieve-parser.c 
+
+noinst_HEADERS = \
+	managesieve-quote.h \
+	managesieve-parser.h 
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/Makefile.in dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/Makefile.in
--- dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/Makefile.in	2008-05-04 08:28:51.000000000 -0600
@@ -0,0 +1,458 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-managesieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libmanagesieve_a_AR = $(AR) $(ARFLAGS)
+libmanagesieve_a_LIBADD =
+am_libmanagesieve_a_OBJECTS = managesieve-quote.$(OBJEXT) \
+	managesieve-parser.$(OBJEXT)
+libmanagesieve_a_OBJECTS = $(am_libmanagesieve_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libmanagesieve_a_SOURCES)
+DIST_SOURCES = $(libmanagesieve_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+HAVE_DOVECOT_LIBS_FALSE = @HAVE_DOVECOT_LIBS_FALSE@
+HAVE_DOVECOT_LIBS_TRUE = @HAVE_DOVECOT_LIBS_TRUE@
+HAVE_OLD_SIEVE_PLUGIN_FALSE = @HAVE_OLD_SIEVE_PLUGIN_FALSE@
+HAVE_OLD_SIEVE_PLUGIN_TRUE = @HAVE_OLD_SIEVE_PLUGIN_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MODULE_LIBS = @MODULE_LIBS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+noinst_LIBRARIES = libmanagesieve.a
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-charset \
+	-I$(dovecot_incdir)/src/lib-mail
+
+libmanagesieve_a_SOURCES = \
+	managesieve-quote.c \
+	managesieve-parser.c 
+
+noinst_HEADERS = \
+	managesieve-quote.h \
+	managesieve-parser.h 
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/lib-managesieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/lib-managesieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libmanagesieve.a: $(libmanagesieve_a_OBJECTS) $(libmanagesieve_a_DEPENDENCIES) 
+	-rm -f libmanagesieve.a
+	$(libmanagesieve_a_AR) libmanagesieve.a $(libmanagesieve_a_OBJECTS) $(libmanagesieve_a_LIBADD)
+	$(RANLIB) libmanagesieve.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-parser.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-quote.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,672 @@
+#include "lib.h"
+#include "istream.h"
+#include "ostream.h"
+#include "strescape.h"
+#include "managesieve-parser.h"
+
+#define is_linebreak(c) \
+	((c) == '\r' || (c) == '\n')
+
+#define LIST_ALLOC_SIZE 7
+
+enum arg_parse_type {
+	ARG_PARSE_NONE = 0,
+	ARG_PARSE_ATOM,
+	ARG_PARSE_STRING,
+	ARG_PARSE_LITERAL,
+	ARG_PARSE_LITERAL_DATA
+};
+
+struct managesieve_parser {
+	/* permanent */
+	pool_t pool;
+	struct istream *input;
+	struct ostream *output;
+	size_t max_line_size;
+	enum managesieve_parser_flags flags;
+
+	/* reset by managesieve_parser_reset(): */
+	size_t line_size;
+	struct managesieve_arg_list *root_list;
+	struct managesieve_arg_list *cur_list;
+
+	enum arg_parse_type cur_type;
+	size_t cur_pos; /* parser position in input buffer */
+
+	int str_first_escape; /* ARG_PARSE_STRING: index to first '\' */
+	uoff_t literal_size; /* ARG_PARSE_LITERAL: string size */
+
+	const char *error;
+
+	unsigned int literal_skip_crlf:1;
+	unsigned int literal_nonsync:1;
+	unsigned int eol:1;
+	unsigned int fatal_error:1;
+};
+
+/* @UNSAFE */
+#define LIST_REALLOC(parser, old_list, new_size) \
+	p_realloc((parser)->pool, old_list, \
+		  sizeof(struct managesieve_arg_list) + \
+		  (old_list == NULL ? 0 : \
+		   sizeof(struct managesieve_arg_list) * (old_list)->alloc), \
+		  sizeof(struct managesieve_arg_list) * (new_size))
+
+static void managesieve_args_realloc(struct managesieve_parser *parser, size_t size)
+{
+	parser->cur_list = LIST_REALLOC(parser, parser->cur_list, size);
+	parser->cur_list->alloc = size;
+
+  parser->root_list = parser->cur_list;
+}
+
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size)
+{
+	struct managesieve_parser *parser;
+
+	parser = i_new(struct managesieve_parser, 1);
+        parser->pool = pool_alloconly_create("MANAGESIEVE parser", 8192);
+	parser->input = input;
+	parser->output = output;
+	parser->max_line_size = max_line_size;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+	return parser;
+}
+
+void managesieve_parser_destroy(struct managesieve_parser **parser)
+{
+	pool_unref(&(*parser)->pool);
+	i_free(*parser);
+	*parser = NULL;
+}
+
+void managesieve_parser_reset(struct managesieve_parser *parser)
+{
+	p_clear(parser->pool);
+
+	parser->line_size = 0;
+
+	parser->root_list = NULL;
+	parser->cur_list = NULL;
+
+	parser->cur_type = ARG_PARSE_NONE;
+	parser->cur_pos = 0;
+
+	parser->str_first_escape = 0;
+	parser->literal_size = 0;
+
+	parser->error = NULL;
+
+	parser->literal_skip_crlf = FALSE;
+	parser->eol = FALSE;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+}
+
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal)
+{
+	*fatal = parser->fatal_error;
+	return parser->error;
+}
+
+/* skip over everything parsed so far, plus the following whitespace */
+static int managesieve_parser_skip_to_next(struct managesieve_parser *parser,
+				    const unsigned char **data,
+				    size_t *data_size)
+{
+	size_t i;
+
+	for (i = parser->cur_pos; i < *data_size; i++) {
+		if ((*data)[i] != ' ')
+			break;
+	}
+
+	parser->line_size += i;
+	i_stream_skip(parser->input, i);
+	parser->cur_pos = 0;
+
+	*data += i;
+	*data_size -= i;
+	return *data_size > 0;
+}
+
+static struct managesieve_arg *managesieve_arg_create(struct managesieve_parser *parser)
+{
+	struct managesieve_arg *arg;
+
+	i_assert(parser->cur_list != NULL);
+
+	/* @UNSAFE */
+	if (parser->cur_list->size == parser->cur_list->alloc)
+		managesieve_args_realloc(parser, parser->cur_list->alloc * 2);
+
+	arg = &parser->cur_list->args[parser->cur_list->size];
+	parser->cur_list->size++;
+
+	return arg;
+}
+
+static void managesieve_parser_save_arg(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t size)
+{
+	struct managesieve_arg *arg;
+
+	arg = managesieve_arg_create(parser);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		/* simply save the string */
+		arg->type = MANAGESIEVE_ARG_ATOM;
+		arg->_data.str = p_strndup(parser->pool, data, size);
+		break;
+	case ARG_PARSE_STRING:
+		/* data is quoted and may contain escapes. */
+		i_assert(size > 0);
+
+		arg->type = MANAGESIEVE_ARG_STRING;
+		arg->_data.str = p_strndup(parser->pool, data+1, size-1);
+
+		/* remove the escapes */
+		if (parser->str_first_escape >= 0 &&
+		    (parser->flags & MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE) == 0) {
+			/* -1 because we skipped the '"' prefix */
+			str_unescape(arg->_data.str +
+				     parser->str_first_escape-1);
+		}
+		break;
+	case ARG_PARSE_LITERAL_DATA:
+		if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) != 0) {
+			/* save literal size */
+			arg->type = MANAGESIEVE_ARG_LITERAL_SIZE;
+			arg->_data.literal_size = parser->literal_size;
+		} else if ((parser->flags &
+			    MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE) != 0) {
+			arg->type = MANAGESIEVE_ARG_LITERAL;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		} else {
+			arg->type = MANAGESIEVE_ARG_STRING;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		}
+		break;
+	default:
+		i_unreached();
+	}
+
+	parser->cur_type = ARG_PARSE_NONE;
+}
+
+static int is_valid_atom_char(struct managesieve_parser *parser, char chr)
+{
+	if (IS_ATOM_SPECIAL((unsigned char)chr)) {
+		parser->error = "Invalid characters in atom";
+		return FALSE;
+	} else if ((chr & 0x80) != 0) {
+		parser->error = "8bit data in atom";
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static int managesieve_parser_read_atom(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t data_size)
+{
+	size_t i;
+
+	/* read until we've found space, CR or LF. */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == ')' ||
+			 is_linebreak(data[i])) {
+			managesieve_parser_save_arg(parser, data, i);
+			break;
+		} else if (!is_valid_atom_char(parser, data[i]))
+			return FALSE;
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_read_string(struct managesieve_parser *parser,
+				   const unsigned char *data, size_t data_size)
+{
+	size_t i;
+	int utf8_len;
+
+	/* QUOTED-CHAR        = SAFE-UTF8-CHAR / "\" QUOTED-SPECIALS
+	 * quoted             = <"> *QUOTED-CHAR <">
+	 *                    ;; limited to 1024 octets between the <">s
+	 */
+
+	/* read until we've found non-escaped ", CR or LF */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '"') {
+			managesieve_parser_save_arg(parser, data, i);
+
+			i++; /* skip the trailing '"' too */
+			break;
+		}
+
+		if (data[i] == '\\') {
+			if (i+1 == data_size) {
+				/* known data ends with '\' - leave it to
+				   next time as well if it happens to be \" */
+				break;
+			}
+
+			/* save the first escaped char */
+			if (parser->str_first_escape < 0)
+				parser->str_first_escape = i;
+
+			/* skip the escaped char */
+			i++;
+
+			if ( !IS_QUOTED_SPECIAL(data[i]) ) {
+				parser->error = "Escaped quoted-string character is not a QUOTED-SPECIAL.";
+				return FALSE;
+			}
+
+			continue;
+		}
+
+		/* Enforce valid UTF-8
+		 */
+		if ( (utf8_len = UTF8_LEN(data[i])) == 0 ) {
+			parser->error = "String contains invalid character.";
+			return FALSE;
+		}
+		
+		if ( utf8_len > 1 ) {
+			bool overlong = FALSE;
+
+			if ( (i+utf8_len-1) >= data_size ) {
+				/* Known data ends in the middle of a UTF-8 character;
+				 * leave it to next time.
+				 */
+				break;
+			}
+
+			/* Check for overlong UTF-8 sequences */
+			switch (utf8_len) {
+			case 2:
+				if (!(data[i] & 0x1E)) overlong = TRUE;
+				break;
+			case 3:	
+				if (!(data[i] & 0x0F) && !(data[i+1] & 0x20)) overlong = TRUE;
+				break;
+			case 4:
+				if (!(data[i] & 0x07) && !(data[i+1] & 0x30)) overlong = TRUE;				
+				break;
+			case 5:
+				if (!(data[i] & 0x03) && !(data[i+1] & 0x38)) overlong = TRUE;
+				break;				
+			case 6:
+				if (!(data[i] & 0x01) && !(data[i+1] & 0x3C)) overlong = TRUE;
+				break;				
+			default:
+				i_unreached();
+			} 
+
+			if ( overlong ) {
+				parser->error = "String contains invalid/overlong UTF-8 character.";
+				return FALSE;
+			}
+
+			i++;
+			utf8_len--;
+	
+			/* Parse the series of UTF8_1 characters */
+			for (; utf8_len > 0; utf8_len--, i++ ) {  
+				if (!IS_UTF8_1(data[i])) {
+					parser->error = "String contains invalid UTF-8 character.";
+			    return FALSE;
+				}
+			}
+		}
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_literal_end(struct managesieve_parser *parser)
+{
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		if (parser->line_size >= parser->max_line_size ||
+		    parser->literal_size >
+		    	parser->max_line_size - parser->line_size) {
+			/* too long string, abort. */
+			parser->error = "Literal size too large";
+			parser->fatal_error = TRUE;
+			return FALSE;
+		}
+	}
+
+	parser->cur_type = ARG_PARSE_LITERAL_DATA;
+	parser->literal_skip_crlf = TRUE;
+
+	parser->cur_pos = 0;
+	return TRUE;
+}
+
+static int managesieve_parser_read_literal(struct managesieve_parser *parser,
+				    const unsigned char *data,
+				    size_t data_size)
+{
+	size_t i, prev_size;
+
+	/* expecting digits + "}" */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '}') {
+			parser->line_size += i+1;
+			i_stream_skip(parser->input, i+1);
+
+			return managesieve_parser_literal_end(parser);
+		}
+
+		if (parser->literal_nonsync) {
+			parser->error = "Expecting '}' after '+'";
+			return FALSE;
+		}
+
+		if (data[i] == '+') {
+			parser->literal_nonsync = TRUE;
+			continue;
+		}
+
+		if (data[i] < '0' || data[i] > '9') {
+			parser->error = "Invalid literal size";
+			return FALSE;
+		}
+
+		prev_size = parser->literal_size;
+		parser->literal_size = parser->literal_size*10 + (data[i]-'0');
+
+		if (parser->literal_size < prev_size) {
+			/* wrapped around, abort. */
+			parser->error = "Literal size too large";
+			return FALSE;
+		}
+	}
+
+	parser->cur_pos = i;
+	return FALSE;
+}
+
+static int managesieve_parser_read_literal_data(struct managesieve_parser *parser,
+					 const unsigned char *data,
+					 size_t data_size)
+{
+	if (parser->literal_skip_crlf) {
+
+		/* skip \r\n or \n, anything else gives an error */
+		if (data_size == 0)
+			return FALSE;
+
+		if (*data == '\r') {
+			parser->line_size++;
+			data++; data_size--;
+			i_stream_skip(parser->input, 1);
+
+			if (data_size == 0)
+				return FALSE;
+		}
+
+		if (*data != '\n') {
+			parser->error = "Missing LF after literal size";
+			return FALSE;
+		}
+
+		parser->line_size++;
+		data++; data_size--;
+		i_stream_skip(parser->input, 1);
+
+		parser->literal_skip_crlf = FALSE;
+
+		i_assert(parser->cur_pos == 0);
+	}
+
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		/* now we just wait until we've read enough data */
+		if (data_size < parser->literal_size) {
+			return FALSE;
+		} else {
+			managesieve_parser_save_arg(parser, data,
+					     (size_t)parser->literal_size);
+			parser->cur_pos = (size_t)parser->literal_size;
+			return TRUE;
+		}
+	} else {
+		/* we want to save only literal size, not the literal itself. */
+		parser->eol = TRUE;
+		managesieve_parser_save_arg(parser, NULL, 0);
+		return TRUE;
+	}
+}
+
+/* Returns TRUE if argument was fully processed. Also returns TRUE if
+   an argument inside a list was processed. */
+static int managesieve_parser_read_arg(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+	if (data_size == 0)
+		return FALSE;
+
+	while (parser->cur_type == ARG_PARSE_NONE) {
+		/* we haven't started parsing yet */
+		if (!managesieve_parser_skip_to_next(parser, &data, &data_size))
+			return FALSE;
+		i_assert(parser->cur_pos == 0);
+
+		switch (data[0]) {
+		case '\r':
+		case '\n':
+			/* unexpected end of line */
+			parser->eol = TRUE;
+			return FALSE;
+		case '"':
+			parser->cur_type = ARG_PARSE_STRING;
+			parser->str_first_escape = -1;
+			break;
+		case '{':
+			parser->cur_type = ARG_PARSE_LITERAL;
+			parser->literal_size = 0;
+			parser->literal_nonsync = FALSE;
+			break;
+		default:
+			if (!is_valid_atom_char(parser, data[0]))
+				return FALSE;
+			parser->cur_type = ARG_PARSE_ATOM;
+			break;
+		}
+
+		parser->cur_pos++;
+	}
+
+	i_assert(data_size > 0);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		if (!managesieve_parser_read_atom(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_STRING:
+		if (!managesieve_parser_read_string(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_LITERAL:
+		if (!managesieve_parser_read_literal(parser, data, data_size))
+			return FALSE;
+
+		/* pass through to parsing data. since input->skip was
+		   modified, we need to get the data start position again. */
+		data = i_stream_get_data(parser->input, &data_size);
+
+		/* fall through */
+	case ARG_PARSE_LITERAL_DATA:
+		if (!managesieve_parser_read_literal_data(parser, data, data_size))
+			return FALSE;
+		break;
+	default:
+		i_unreached();
+	}
+
+	i_assert(parser->cur_type == ARG_PARSE_NONE);
+	return TRUE;
+}
+
+/* ARG_PARSE_NONE checks that last argument isn't only partially parsed. */
+#define IS_UNFINISHED(parser) \
+        ((parser)->cur_type != ARG_PARSE_NONE || \
+	 (parser)->cur_list != parser->root_list)
+
+static int finish_line(struct managesieve_parser *parser, unsigned int count,
+		       struct managesieve_arg **args)
+{
+	parser->line_size += parser->cur_pos;
+	i_stream_skip(parser->input, parser->cur_pos);
+	parser->cur_pos = 0;
+
+	if (count >= parser->root_list->alloc) {
+		/* unused arguments must be NIL-filled. */
+		parser->root_list =
+			LIST_REALLOC(parser, parser->root_list, count+1);
+		parser->root_list->alloc = count+1;
+	}
+
+	parser->root_list->args[parser->root_list->size].type = MANAGESIEVE_ARG_EOL;
+
+	*args = parser->root_list->args;
+	return parser->root_list->size;
+}
+
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args)
+{
+	parser->flags = flags;
+
+	while (!parser->eol && (count == 0 || parser->root_list->size < count ||
+				IS_UNFINISHED(parser))) {
+		if (!managesieve_parser_read_arg(parser))
+			break;
+
+		if (parser->line_size > parser->max_line_size) {
+			parser->error = "MANAGESIEVE command line too large";
+			break;
+		}
+	}
+
+	if (parser->error != NULL) {
+		/* error, abort */
+		parser->line_size += parser->cur_pos;
+		i_stream_skip(parser->input, parser->cur_pos);
+		parser->cur_pos = 0;
+		*args = NULL;
+		return -1;
+	} else if ((!IS_UNFINISHED(parser) && count > 0 &&
+		    parser->root_list->size >= count) || parser->eol) {
+		/* all arguments read / end of line. */
+                return finish_line(parser, count, args);
+	} else {
+		/* need more data */
+		*args = NULL;
+		return -2;
+	}
+}
+
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args)
+{
+	const unsigned char *data;
+	size_t data_size;
+	int ret;
+
+	ret = managesieve_parser_read_args(parser, count, flags, args);
+	if (ret == -2) {
+		/* we should have noticed end of everything except atom */
+		if (parser->cur_type == ARG_PARSE_ATOM) {
+			data = i_stream_get_data(parser->input, &data_size);
+			managesieve_parser_save_arg(parser, data, data_size);
+		}
+	}
+	return finish_line(parser, count, args);
+}
+
+const char *managesieve_parser_read_word(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == '\r' || data[i] == '\n')
+			break;
+	}
+
+	if (i < data_size) {
+		data_size = i + (data[i] == ' ' ? 1 : 0);
+		parser->line_size += data_size;
+		i_stream_skip(parser->input, data_size);
+		return p_strndup(parser->pool, data, i);
+	} else {
+		return NULL;
+	}
+}
+
+const char *managesieve_arg_string(struct managesieve_arg *arg)
+{
+	if (arg->type == MANAGESIEVE_ARG_STRING) 
+		return arg->_data.str;
+
+	return NULL;
+}
+
+int managesieve_arg_number
+	(struct managesieve_arg *arg, uoff_t *number)
+{
+	int i = 0;
+	const char *data;
+
+	*number = 0;
+
+	if (arg->type == MANAGESIEVE_ARG_ATOM) {
+		data = arg->_data.str;
+		while (data[i] != '\0') {
+			if (data[i] < '0' || data[i] > '9')
+				return -1;
+	
+			*number = (*number)*10 + (data[i] -'0');
+			i++;
+		}
+    
+		return 1;
+	}
+
+	return -1;
+}
+
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as string", arg->type);
+	return NULL;
+}
+
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as literal size", arg->type);
+	return 0;
+}
+
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as list", arg->type);
+	return NULL;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,189 @@
+#ifndef __MANAGESIEVE_PARSER_H
+#define __MANAGESIEVE_PARSER_H
+
+/*
+ * QUOTED-SPECIALS    = <"> / "\"
+ */
+#define IS_QUOTED_SPECIAL(c) \
+	((c) == '"' || (c) == '\\')
+
+/* 
+ * ATOM-SPECIALS      = "(" / ")" / "{" / SP / CTL / QUOTED-SPECIALS
+ */
+#define IS_ATOM_SPECIAL(c) \
+	((c) == '(' || (c) == ')' || (c) == '{' || \
+	 (c) <= 32 || (c) == 0x7f || \
+	 IS_QUOTED_SPECIAL(c)) 
+
+/* 
+ * CHAR               = %x01-7F
+ */
+#define IS_CHAR(c) \
+	(((c) & 0x80) == 0)
+
+/* 
+ * TEXT-CHAR          = %x01-09 / %x0B-0C / %x0E-7F
+ *                       ;; any CHAR except CR and LF
+ */
+#define IS_TEXT_CHAR(c) \
+	(IS_CHAR(c) && (c) != '\r' && (c) != '\n')
+
+/*
+ * SAFE-CHAR          = %x01-09 / %x0B-0C / %x0E-21 /
+ *                      %x23-5B / %x5D-7F
+ *                      ;; any TEXT-CHAR except QUOTED-SPECIALS
+ */
+#define IS_SAFE_CHAR(c) \
+	(IS_TEXT_CHAR(c) && !IS_QUOTED_SPECIAL(c))
+
+/* UTF8-1             = %x80-BF
+ */
+#define IS_UTF8_1(c) \
+	(((c) & 0xC0) == 0x80)
+
+/* UTF8-2             = %xC0-DF UTF8-1
+ */
+#define IS_UTF8_2S(c) \
+  (((c) & 0xE0) == 0xC0)
+
+/* UTF8-3             = %xE0-EF 2UTF8-1
+ */
+#define IS_UTF8_3S(c) \
+  (((c) & 0xF0) == 0xE0)
+
+/* UTF8-4             = %xF0-F7 3UTF8-1
+ */
+#define IS_UTF8_4S(c) \
+  (((c) & 0xF8) == 0xF0)
+
+/* UTF8-5             = %xF8-FB 4UTF8-1
+ */
+#define IS_UTF8_5S(c) \
+  (((c) & 0xFC) == 0xF8)
+
+/* UTF8-6             = %xFC-FD 5UTF8-1
+ */
+#define IS_UTF8_6S(c) \
+  (((c) & 0xFE) == 0xFC)
+
+/* SAFE-UTF8-CHAR     = SAFE-CHAR / UTF8-2 / UTF8-3 / UTF8-4 /
+ *                      UTF8-5 / UTF8-6
+ */
+#define UTF8_LEN(c) \
+  ( IS_SAFE_CHAR(c) ? 1 : \
+    IS_UTF8_2S(c) ? 2 : \
+    IS_UTF8_3S(c) ? 3 : \
+    IS_UTF8_4S(c) ? 4 : \
+    IS_UTF8_5S(c) ? 5 : \
+    IS_UTF8_6S(c) ? 6 : 0 )
+
+enum managesieve_parser_flags {
+	/* Set this flag if you wish to read only size of literal argument
+	   and not convert literal into string. Useful when you need to deal
+	   with large literal sizes. The literal must be the last read
+	   parameter. */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE	= 0x01,
+	/* Don't remove '\' chars from string arguments */
+	MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE	= 0x02,
+	/* Return literals as MANAGESIEVE_ARG_LITERAL instead of MANAGESIEVE_ARG_STRING */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE	= 0x04
+};
+
+enum managesieve_arg_type {
+	MANAGESIEVE_ARG_ATOM = 0,
+	MANAGESIEVE_ARG_STRING,
+
+	/* literals are returned as MANAGESIEVE_ARG_STRING by default */
+	MANAGESIEVE_ARG_LITERAL,
+	MANAGESIEVE_ARG_LITERAL_SIZE,
+
+	MANAGESIEVE_ARG_EOL /* end of argument list */
+};
+
+struct managesieve_parser;
+
+struct managesieve_arg {
+	enum managesieve_arg_type type;
+
+	union {
+		char *str;
+		uoff_t literal_size;
+	} _data;
+};
+
+#define MANAGESIEVE_ARG_STR(arg) \
+	((arg)->type == MANAGESIEVE_ARG_STRING || \
+   (arg)->type == MANAGESIEVE_ARG_ATOM || \
+	 (arg)->type == MANAGESIEVE_ARG_LITERAL ? \
+	 (arg)->_data.str : _managesieve_arg_str_error(arg))
+
+#define MANAGESIEVE_ARG_LITERAL_SIZE(arg) \
+	(((arg)->type == MANAGESIEVE_ARG_LITERAL_SIZE) ? \
+	 (arg)->_data.literal_size : _managesieve_arg_literal_size_error(arg))
+
+struct managesieve_arg_list {
+	size_t size, alloc;
+	struct managesieve_arg args[1]; /* variable size */
+};
+
+
+/* Create new MANAGESIEVE argument parser. output is used for sending command
+   continuation requests for literals.
+
+   max_line_size can be used to approximately limit the maximum amount of
+   memory that gets allocated when parsing a line. Input buffer size limits
+   the maximum size of each parsed token.
+
+   Usually the largest lines are large only because they have a one huge
+   message set token, so you'll probably want to keep input buffer size the
+   same as max_line_size. That means the maximum memory usage is around
+   2 * max_line_size. */
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size);
+void managesieve_parser_destroy(struct managesieve_parser **parser);
+
+/* Reset the parser to initial state. */
+void managesieve_parser_reset(struct managesieve_parser *parser);
+
+/* Return the last error in parser. fatal is set to TRUE if there's no way to
+   continue parsing, currently only if too large non-sync literal size was
+   given. */
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal);
+
+/* Read a number of arguments. This function doesn't call i_stream_read(), you
+   need to do that. Returns number of arguments read (may be less than count
+   in case of EOL), -2 if more data is needed or -1 if error occurred.
+
+   count-sized array of arguments are stored into args when return value is
+   0 or larger. If all arguments weren't read, they're set to NIL. count
+   can be set to 0 to read all arguments in the line. Last element in
+   args is always of type MANAGESIEVE_ARG_EOL. */
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args);
+
+/* just like managesieve_parser_read_args(), but assume \n at end of data in
+   input stream. */
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args);
+
+/* Read one word - used for reading tag and command name.
+   Returns NULL if more data is needed. */
+const char *managesieve_parser_read_word(struct managesieve_parser *parser);
+
+/* Returns the managesieve argument as string. If it is no string this returns NULL */
+const char *managesieve_arg_string(struct managesieve_arg *arg);
+
+/* Returns 1 if the argument is a number. If it is no number this returns -1.
+ * The number itself is stored in *number.
+ */
+int managesieve_arg_number
+  (struct managesieve_arg *arg, uoff_t *number);
+
+/* Error functions */
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg);
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg);
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,176 @@
+#include "lib.h"
+#include "str.h"
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+/* Turn the value string into a valid MANAGESIEVE string or literal, no matter 
+ * what. QUOTED-SPECIALS are escaped, but any invalid (UTF-8) character
+ * is simply removed. Linebreak characters are not considered invalid, but
+ * they do force the generation of a string literal.
+ */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp)
+{
+	size_t i, extra = 0;
+	bool 
+		last_lwsp = TRUE, 
+		literal = FALSE, 
+		modify = FALSE,
+		escape = FALSE;
+	int utf8_len;
+
+ 	if (value == NULL) {
+		str_append(str, "\"\"");
+		return;
+	}
+
+	if (value_len == (size_t)-1)
+		value_len = strlen((const char *) value);
+
+	for (i = 0; i < value_len; i++) {
+		switch (value[i]) {
+		case ' ':
+		case '\t':
+			if (last_lwsp && compress_lwsp) {
+				modify = TRUE;
+				extra++;
+			}
+			last_lwsp = TRUE;
+			break;
+		case '"':
+		case '\\':
+			escape = TRUE;
+			last_lwsp = FALSE;
+			break;
+		case 13:
+		case 10:
+			literal = TRUE;
+			last_lwsp = TRUE;
+			break;
+		default:
+			/* Enforce valid UTF-8
+			 */
+			if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) {
+				modify = TRUE;
+				extra++;
+				break;
+			}
+
+			if ( utf8_len > 1 ) {
+				int c = utf8_len - 1;
+
+		 		if ( (i+utf8_len-1) >= value_len ) {
+				  	/* Value ends in the middle of a UTF-8 character;
+					 * Kill the partial UTF-8 character
+					 */
+				  	extra += i + utf8_len - value_len;
+					modify = TRUE;
+					break;        	
+				}
+
+				/* Parse the series of UTF8_1 characters */
+				for (i++; c > 0; c--, i++ ) {
+					if (!IS_UTF8_1(value[i])) {
+						extra += utf8_len - c;
+						modify = TRUE;
+						break;
+					}
+				}
+			}
+   			
+			last_lwsp = FALSE;
+		}
+	}
+
+	if (!literal) {
+		/* no linebreak chars, return as (escaped) "string" */
+		str_append_c(str, '"');
+	} else {
+		/* return as literal */
+		str_printfa(str, "{%"PRIuSIZE_T"}\r\n", value_len - extra);
+	}
+
+	if (!modify && (literal || !escape))
+		str_append_n(str, value, value_len);
+	else {
+		last_lwsp = TRUE;
+		for (i = 0; i < value_len; i++) {
+			switch (value[i]) {
+			case '"':
+			case '\\':
+				last_lwsp = FALSE;
+				if (!literal) 
+					str_append_c(str, '\\');
+				str_append_c(str, value[i]);
+				break;
+			case ' ':
+			case '\t':
+				if (!last_lwsp || !compress_lwsp)
+					str_append_c(str, ' ');
+				last_lwsp = TRUE;
+				break;
+			case 13:
+			case 10:
+				last_lwsp = TRUE;
+				str_append_c(str, value[i]);
+				break;
+			default:
+	  			/* Enforce valid UTF-8
+				 */
+				if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) 
+					break;
+      
+				if ( utf8_len > 1 ) {
+					int c = utf8_len - 1;
+					int j;
+
+					if ( (i+utf8_len-1) >= value_len ) {
+						/* Value ends in the middle of a UTF-8 character;
+						 * Kill the partial character
+						 */
+					 	i = value_len;
+						break;
+					}
+
+					/* Parse the series of UTF8_1 characters */
+					for (j = i+1; c > 0; c--, j++ ) {
+						if (!IS_UTF8_1(value[j])) {
+							/* Skip until after this erroneous character */
+							i = j;
+							break;
+						}
+					}
+
+					/* Append the UTF-8 character. Last octet is done later */
+					c = utf8_len - 1;
+					for (; c > 0; c--, i++ ) 
+						str_append_c(str, value[i]);
+				}
+     
+				last_lwsp = FALSE;
+				str_append_c(str, value[i]);
+				break;
+			}
+		}
+	}
+
+	if (!literal)
+		str_append_c(str, '"');
+}
+
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len)
+{
+	string_t *str;
+	char *ret;
+
+	if (value == NULL)
+		return "\"\"";
+
+	t_push();
+	str = t_str_new(value_len + MAX_INT_STRLEN + 5);
+	managesieve_quote_append(str, value, value_len, TRUE);
+	ret = p_strndup(pool, str_data(str), str_len(str));
+	t_pop();
+
+	return ret;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,17 @@
+#ifndef __IMAP_QUOTE_H
+#define __IMAP_QUOTE_H
+
+/* Return value suitable for sending to client, either as quoted-string or
+   literal. Note that this also converts TABs into spaces, multiple spaces
+   into single space and NULs to #128. */
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len);
+
+/* Append to existing string. */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp);
+
+#define managesieve_quote_append_string(str, value, compress_lwsp) \
+	managesieve_quote_append(str, (const unsigned char *)(value), \
+			  (size_t)-1, compress_lwsp)
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/Makefile.am	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,20 @@
+noinst_LIBRARIES = libsievestorage.a
+
+INCLUDES = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(docecot_incdir)/src/lib-mail \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+libsievestorage_a_SOURCES = \
+	sieve-storage-save.c \
+	sieve-storage-script.c \
+	sieve-storage-list.c \
+	sieve-storage.c 
+
+noinst_HEADERS = \
+	sieve-storage-save.h \
+	sieve-storage-script.h \
+	sieve-storage-list.h \
+	sieve-storage-private.h \
+	sieve-storage.h
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/Makefile.in dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/Makefile.in
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/Makefile.in	2008-05-04 08:28:51.000000000 -0600
@@ -0,0 +1,466 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sievestorage
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libsievestorage_a_AR = $(AR) $(ARFLAGS)
+libsievestorage_a_LIBADD =
+am_libsievestorage_a_OBJECTS = sieve-storage-save.$(OBJEXT) \
+	sieve-storage-script.$(OBJEXT) sieve-storage-list.$(OBJEXT) \
+	sieve-storage.$(OBJEXT)
+libsievestorage_a_OBJECTS = $(am_libsievestorage_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libsievestorage_a_SOURCES)
+DIST_SOURCES = $(libsievestorage_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+HAVE_DOVECOT_LIBS_FALSE = @HAVE_DOVECOT_LIBS_FALSE@
+HAVE_DOVECOT_LIBS_TRUE = @HAVE_DOVECOT_LIBS_TRUE@
+HAVE_OLD_SIEVE_PLUGIN_FALSE = @HAVE_OLD_SIEVE_PLUGIN_FALSE@
+HAVE_OLD_SIEVE_PLUGIN_TRUE = @HAVE_OLD_SIEVE_PLUGIN_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MODULE_LIBS = @MODULE_LIBS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+noinst_LIBRARIES = libsievestorage.a
+INCLUDES = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(docecot_incdir)/src/lib-mail \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+libsievestorage_a_SOURCES = \
+	sieve-storage-save.c \
+	sieve-storage-script.c \
+	sieve-storage-list.c \
+	sieve-storage.c 
+
+noinst_HEADERS = \
+	sieve-storage-save.h \
+	sieve-storage-script.h \
+	sieve-storage-list.h \
+	sieve-storage-private.h \
+	sieve-storage.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/lib-sievestorage/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/lib-sievestorage/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libsievestorage.a: $(libsievestorage_a_OBJECTS) $(libsievestorage_a_DEPENDENCIES) 
+	-rm -f libsievestorage.a
+	$(libsievestorage_a_AR) libsievestorage.a $(libsievestorage_a_OBJECTS) $(libsievestorage_a_LIBADD)
+	$(RANLIB) libsievestorage.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage-list.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage-save.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage-script.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c	2008-03-01 15:40:08.000000000 -0700
@@ -0,0 +1,444 @@
+#include "lib.h"
+#include "home-expand.h"
+#include "ioloop.h"
+#include "mkdir-parents.h"
+
+#include "sieve-error-private.h"
+
+#include "sieve-storage-private.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define CREATE_MODE 0770 /* umask() should limit it more */
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+static void sieve_storage_verror
+	(struct sieve_error_handler *ehandler ATTR_UNUSED, 
+		const char *location ATTR_UNUSED, const char *fmt, va_list args);
+
+static const char *sieve_get_active_script_path(void)
+{
+  const char *script_path, *home;
+
+  home = getenv("HOME");
+
+  /* userdb may specify Sieve path */
+  script_path = getenv("SIEVE");
+  if (script_path != NULL) {
+	if (*script_path == '\0') {
+		/* disabled */
+		return NULL;
+	}
+
+    if ( *script_path != '/' && *script_path != '~') {
+      /* relative path. change to absolute. */
+      script_path = t_strconcat(getenv("HOME"), "/",  
+        script_path, NULL);
+    }
+  } else {
+    if (home == NULL) {
+      /* we must have a home directory */
+      i_error("sieve-storage: userdb(%s) didn't return a home directory or "
+        "sieve script location, can't find it",
+        getenv("USER"));
+      return NULL;
+    }
+
+    script_path = SIEVE_SCRIPT_PATH;
+  }
+
+  /* No need to check for existance here */
+
+  return script_path;
+}
+
+/* Obtain the directory for script storage from the mail location
+ */
+static const char *sieve_storage_get_dir_from_mail(const char *data)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	struct stat st;
+	size_t len;
+	const char *root_dir, *dir, *p, *d;
+
+	root_dir = dir = d = NULL;
+
+	if (debug)
+		i_info("sieve-storage: using mail-data: %s", data);
+
+	/* check if we're in the form of mailformat:data
+	   (eg. maildir:Maildir) */
+	p = data;
+	while (i_isalnum(*p)) p++;
+	
+	if (*p == ':') {
+		d = p+1;
+	} else {
+		d = data;
+	}
+
+	if (d == NULL || *d == '\0') {
+		/* Ok, this is bad. Check whether we might be chrooted, bail out otherwise */
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0)
+			root_dir = "/";
+		else {
+			i_error("sieve-storage: sieve storage directory not given and mail root provides no alternative.");
+            return NULL;
+		}
+	} else {
+		/* <scriptdir> */
+		p = strchr(d, ':');
+		if (p == NULL)
+			/* No additional parameters */
+			root_dir = d;
+		else {
+			dir = t_strdup_until(d, p);
+ 
+			do {
+				p++;
+				/* Use control dir as script dir if specified */
+				if (strncmp(p, "CONTROL=", 8) == 0)
+					root_dir = t_strcut(p+8, ':');
+				p = strchr(p, ':');
+			} while (p != NULL);
+			
+			if ( root_dir == NULL || *root_dir == '\0' )
+				root_dir = dir;
+		}
+	}
+
+	/* Not found */
+	if ( root_dir == NULL || *root_dir == '\0' ) {
+		if (debug)
+            i_info("sieve-storage: couldn't find root dir from mail-data.");
+        return NULL;
+    }
+
+	/* Strip trailing '/' */
+    len = strlen(root_dir);
+    if (root_dir[len-1] == '/')
+        root_dir = t_strndup(root_dir, len-1);
+
+	/* Superior mail directory must exist; it is never auto-created by the 
+	 * sieve-storage.
+ 	 */
+	if (stat(root_dir, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			i_error("sieve-storage: root dir from mail data: stat(%s) failed: %m", root_dir);
+			return NULL;
+		} else {
+			i_error("sieve-storage: root directory specified by mail data does not exist: %s", root_dir);
+			return NULL;
+		}
+	} 
+
+	/* Never store scripts directly in the root of the mail or mail:CONTROl directory.
+	 */
+	root_dir = t_strconcat( root_dir, "/sieve", NULL );
+
+	return root_dir;
+}
+
+static const char *sieve_storage_get_relative_link_path
+	(const char *active_path, const char *storage_dir) 
+{
+	const char *link_path, *p;
+	size_t pathlen;
+	
+	/* Determine to what extent the sieve storage and active script 
+	 * paths match up. This enables the managed symlink to be short and the 
+	 * sieve storages can be moved around without trouble (if the active 
+	 * script path is common to the script storage).
+	 */		
+	p = strrchr(active_path, '/');
+	if ( p == NULL ) {
+		link_path = storage_dir;
+	} else { 
+		pathlen = p - active_path;
+
+		if ( strncmp( active_path, storage_dir, pathlen ) == 0 &&
+			(storage_dir[pathlen] == '/' || storage_dir[pathlen] == '\0') ) 
+		{
+			if ( storage_dir[pathlen] == '\0' ) 
+				link_path = ""; 
+			else 
+				link_path = storage_dir + pathlen + 1;
+		} else 
+			link_path = storage_dir;
+	}
+
+	/* Add trailing '/' when link path is not empty 
+	 */
+	pathlen = strlen(link_path);
+    if ( pathlen != 0 && link_path[pathlen-1] != '/')
+        return t_strconcat(link_path, "/", NULL);
+
+	return t_strdup(link_path);
+}
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user)
+{
+	struct sieve_storage *storage;
+	const char *storage_dir;
+
+	t_push();
+
+	storage_dir = sieve_storage_get_dir_from_mail(data);
+	if (storage_dir == NULL) {
+		if (getenv("DEBUG") != NULL)
+			i_info("sieve-storage: failed to obtain storage directory from mail-data.");
+		t_pop();
+		return NULL;
+	} 
+
+	storage = sieve_storage_create(storage_dir, user);
+
+	t_pop();
+
+	return storage;
+}
+
+struct sieve_storage *sieve_storage_create(const char *data, const char *user)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	pool_t pool;
+	struct sieve_storage *storage;
+	const char *home, *tmp_dir, *link_path, *path;
+	const char *active_path, *active_fname, *storage_dir;
+
+	t_push();
+
+	/* Find out where the active script is stored (e.g. ~/.dovecot.sieve) */
+
+	active_path = sieve_get_active_script_path();
+	if (active_path == NULL) {
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+
+	/* Get the filename for the active script link */
+	active_fname = strrchr(active_path, '/');
+	if ( active_fname == NULL ) 
+		active_fname = active_path;
+	else
+		active_fname++;
+
+	if ( *active_fname == '\0' ) {	
+		/* Link cannot be just a path */
+		i_error("sieve-storage: Path to active symlink must include the link's filename. Path is: %s", 
+			active_path);
+
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+
+	/* Find out where to put the script storage */
+
+	storage_dir = NULL;
+
+	if ( data == NULL || *data == '\0' ) {
+		/* We'll need to figure out the storage location ourself.
+		 *
+         * It's $HOME/sieve or /sieve when (presumed to be) chrooted.  
+		 */
+		home = getenv("HOME");
+        if ( home != NULL && *home != '\0' ) {
+			size_t len;
+
+            if (access(home, R_OK|W_OK|X_OK) == 0) {
+                if (debug) {
+                    i_info("sieve-storage: root exists (%s)",
+                           home);
+                }
+
+				/* Check for trailing '/' */
+    			len = strlen(home);
+    			if (home[len-1] == '/')
+            		path = t_strconcat(home, "sieve", NULL);
+				else
+            		path = t_strconcat(home, "/sieve", NULL);
+			
+                storage_dir = path;
+            } else {
+                if (debug) {
+                    i_info("sieve-storage: access(%s, rwx): "
+                           "failed: %m", home);
+                }
+            }
+		} else {
+			if (debug)
+                i_info("sieve-storage: HOME not set");
+        }
+
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0) {
+            storage_dir = "/sieve";
+			if (debug)
+				i_info("sieve-storage: /sieve exists, assuming chroot");
+        }
+	} else {
+		storage_dir = data;
+	}
+
+	if (storage_dir == NULL || *storage_dir == '\0') {
+        if (debug)
+            i_info("sieve-storage: couldn't find storage dir");
+        return NULL;
+    }
+
+	if (debug)
+ 		i_info("sieve-storage: using sieve script storage directory: %s", storage_dir);    
+
+	/* Expand home directoties in path */
+	storage_dir = home_expand(storage_dir);
+	active_path = home_expand(active_path);
+
+	/* Ensure sieve local directory structure exists (full autocreate):
+	 *  This currently currently only consists of a ./tmp direcory
+	 */
+	tmp_dir = t_strconcat( storage_dir, "/tmp", NULL );	
+	if (mkdir_parents(tmp_dir, CREATE_MODE) < 0 && errno != EEXIST) {
+		i_error("sieve-storage: mkdir_parents(%s, CREATE_MODE) failed: %m", tmp_dir);
+		t_pop();
+		return NULL;
+	}
+
+	/* Create storage object */
+	pool = pool_alloconly_create("sieve-storage", 512+256);
+    storage = p_new(pool, struct sieve_storage, 1);	
+	storage->pool = pool;
+	storage->dir = p_strdup(pool, storage_dir);
+	storage->user = p_strdup(pool, user);
+	storage->active_path = p_strdup(pool, active_path);
+	storage->active_fname = p_strdup(pool, active_fname);
+
+	/* Get the path to be prefixed to the script name in the symlink pointing 
+	 * to the active script.
+	 */
+	link_path = sieve_storage_get_relative_link_path
+		(storage->active_path, storage->dir);
+	if (debug)
+		i_info("sieve-storage: relative path to sieve storage in active link: %s", link_path);
+
+	storage->link_path = p_strdup(pool, link_path);
+
+	t_pop();
+
+	return storage;
+}
+
+void sieve_storage_free(struct sieve_storage *storage)
+{
+	sieve_error_handler_unref(&storage->ehandler);
+
+	pool_unref(&storage->pool);
+}
+
+/* Error handling */
+
+struct sieve_error_handler *sieve_storage_get_error_handler(struct sieve_storage *storage)
+{
+	struct sieve_storage_ehandler *ehandler;
+
+	if ( storage->ehandler == NULL ) {
+		pool_t pool = pool_alloconly_create("sieve_storage_ehandler", 512);
+		ehandler = p_new(pool, struct sieve_storage_ehandler,1);
+		sieve_error_handler_init(&ehandler->handler, pool);
+
+		ehandler->handler.verror = sieve_storage_verror;
+		ehandler->storage = storage;
+		
+		storage->ehandler = (struct sieve_error_handler *) ehandler;
+	}
+
+	return storage->ehandler;
+}
+
+static void sieve_storage_verror
+(struct sieve_error_handler *ehandler, const char *location ATTR_UNUSED,
+    const char *fmt, va_list args)
+{
+	struct sieve_storage_ehandler *sehandler = (struct sieve_storage_ehandler *) ehandler; 
+	struct sieve_storage *storage = sehandler->storage;
+
+	sieve_storage_clear_error(storage);
+	
+	if (fmt != NULL) {
+        storage->error = i_strdup_vprintf(fmt, args);
+    }
+}
+
+void sieve_storage_clear_error(struct sieve_storage *storage)
+{
+	i_free(storage->error);
+	storage->error = NULL;
+}
+
+void sieve_storage_set_error(struct sieve_storage *storage, const char *fmt, ...)
+{
+	va_list va;
+
+	sieve_storage_clear_error(storage);
+
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		storage->error = i_strdup_vprintf(fmt, va);
+		va_end(va);
+	}
+}
+
+void sieve_storage_set_internal_error(struct sieve_storage *storage)
+{
+	struct tm *tm;
+	char str[256];
+
+	tm = localtime(&ioloop_time);
+
+	i_free(storage->error);
+	storage->error =
+	  strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+	  i_strdup(str) : i_strdup(CRITICAL_MSG);
+}
+
+void sieve_storage_set_critical(struct sieve_storage *storage,
+             const char *fmt, ...)
+{
+	va_list va;
+	
+	sieve_storage_clear_error(storage);
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		i_error("sieve-storage: %s", t_strdup_vprintf(fmt, va));
+		va_end(va);
+		
+		/* critical errors may contain sensitive data, so let user
+		   see only "Internal error" with a timestamp to make it
+		   easier to look from log files the actual error message. */
+		sieve_storage_set_internal_error(storage);
+	}
+}
+
+const char *sieve_storage_get_last_error(struct sieve_storage *storage)
+{
+  /* We get here only in error situations, so we have to return some
+     error. If storage->error is NULL, it means we forgot to set it at
+     some point.. */
+  return storage->error != NULL ? storage->error : "Unknown error";
+}
+
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,21 @@
+#ifndef __SIEVE_STORAGE_H
+#define __SIEVE_STORAGE_H
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user);
+struct sieve_storage *sieve_storage_create(const char *data, const char *user);
+void sieve_storage_free(struct sieve_storage *storage);
+
+struct sieve_error_handler *sieve_storage_get_error_handler(struct sieve_storage *storage);
+
+/* Set error message in storage. Critical errors are logged with i_error(),
+   but user sees only "internal error" message. */
+void sieve_storage_clear_error(struct sieve_storage *storage);
+void sieve_storage_set_error(struct sieve_storage *storage,
+	const char *fmt, ...) ATTR_FORMAT(2, 3);
+void sieve_storage_set_critical(struct sieve_storage *storage,
+	const char *fmt, ...) ATTR_FORMAT(2, 3);
+void sieve_storage_set_internal_error(struct sieve_storage *storage);
+
+const char *sieve_storage_get_last_error(struct sieve_storage *storage);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,112 @@
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-list.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context {
+	pool_t pool;
+	struct sieve_storage *storage;
+
+	const char *active;
+	const char *dir;
+	DIR *dirp;
+
+	unsigned int seen_active:1; // Just present for assertions
+};
+
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage)
+{	
+	struct sieve_list_context *ctx;
+	const char *active;
+	pool_t pool;
+	DIR *dirp;
+
+	/* Open the directory */
+	if ( (dirp = opendir(storage->dir)) == NULL ) {
+		sieve_storage_set_critical(storage, "opendir(%s) failed: %m",
+					   storage->dir);
+		return NULL;
+	}
+
+	t_push();
+
+	/* Get the name of the active script */
+	if ( (active = sieve_storage_get_active_scriptname(storage)) 
+		== NULL ) {
+		t_pop();
+		return NULL;
+	}
+
+	pool = pool_alloconly_create("sieve_list_context", 4096);
+	ctx = p_new(pool, struct sieve_list_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->dirp = dirp;
+	ctx->active = p_strdup(pool, active);
+	ctx->seen_active = FALSE;
+
+	t_pop();
+
+	return ctx;
+}
+
+const char *sieve_storage_list_next
+	(struct sieve_list_context *ctx, bool *active)
+{
+	const struct sieve_storage *storage = ctx->storage;
+	struct dirent *dp;
+	const char *scriptname;
+
+	*active = FALSE;
+
+	for (;;) {
+		if ( (dp = readdir(ctx->dirp)) == NULL )
+			return NULL;
+
+		scriptname = sieve_storage_file_get_scriptname
+			(storage, dp->d_name);	
+		
+		if (scriptname != NULL ) {
+			/* Don't list our active sieve script link if the link 
+			 * resides in the script dir (generally a bad idea).
+			 */
+			if ( *(storage->link_path) == '\0' && 
+				strcmp(storage->active_fname, dp->d_name) == 0 )
+				continue;
+		
+			break;
+		}
+	}
+
+	if ( ctx->active != NULL && 
+		strcmp(scriptname, ctx->active) == 0 ) {
+		*active = TRUE;
+		ctx->active = NULL;
+	}
+
+	return scriptname;
+}
+
+int sieve_storage_list_deinit(struct sieve_list_context **ctx)
+{
+	if (closedir((*ctx)->dirp) < 0) {
+		sieve_storage_set_critical((*ctx)->storage, "closedir(%s) failed: %m",
+					   (*ctx)->storage->dir);
+	}
+
+	pool_unref(&(*ctx)->pool);
+	*ctx = NULL;
+	return 1;
+}
+
+
+	
+    
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,29 @@
+#ifndef __SIEVE_LIST_H
+#define __SIEVE_LIST_H
+
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context;
+
+/* Create a context for listing the scripts in the storage */
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage);
+
+/* Get the next script in the storage. */
+const char *sieve_storage_list_next(struct sieve_list_context *ctx, bool *active);
+
+/* Destroy the listing context */
+int sieve_storage_list_deinit(struct sieve_list_context **ctx);
+
+#endif
+
+
+	
+    
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,46 @@
+#ifndef __SIEVE_STORAGE_PRIVATE_H
+#define __SIEVE_STORAGE_PRIVATE_H
+
+#include "sieve-storage.h"
+#include "sieve-error-private.h"
+
+enum sieve_storage_flags {
+	/* Print debugging information while initializing the storage */
+	SIEVE_STORAGE_FLAG_DEBUG     = 0x01,
+	/* Use CRLF linefeeds when saving mails. */
+	SIEVE_STORAGE_FLAG_SAVE_CRLF   = 0x02,
+};
+
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+struct sieve_storage;
+
+struct sieve_storage_ehandler {
+	struct sieve_error_handler handler;
+	struct sieve_storage *storage;
+};
+
+/* All methods returning int return either TRUE or FALSE. */
+struct sieve_storage {
+	pool_t pool;
+	char *name;
+	char *dir;
+
+	/* Private */	
+	char *active_path;
+	char *active_fname;
+	char *link_path;
+	char *error;
+	char *user; /* name of user accessing the storage */
+
+	struct sieve_error_handler *ehandler;
+
+	enum sieve_storage_flags flags;
+};
+
+struct sieve_script *sieve_storage_script_init_from_path
+(struct sieve_storage *storage, const char *path, const char *scriptname,
+    bool *exists_r);
+
+#endif
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c	2008-03-01 16:26:46.000000000 -0700
@@ -0,0 +1,324 @@
+#include "lib.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "array.h"
+#include "buffer.h"
+#include "ostream.h"
+#include "str.h"
+
+#include "sieve-script.h"
+
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-save.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <utime.h>
+#include <sys/stat.h>
+
+struct sieve_save_context {
+	pool_t pool;
+
+	struct sieve_storage *storage;
+	const char *scriptname;
+	struct sieve_script *scriptobject;
+
+	struct istream *input;
+	struct ostream *output;
+	int fd;
+	const char *tmp_path;
+
+	unsigned int failed:1;
+	unsigned int moving:1;
+	unsigned int finished:1;
+};
+
+static const char *sieve_generate_tmp_filename(const char *scriptname)
+{
+	static struct timeval last_tv = { 0, 0 };
+	struct timeval tv;
+
+	/* use secs + usecs to guarantee uniqueness within this process. */
+	if (ioloop_timeval.tv_sec > last_tv.tv_sec ||
+		(ioloop_timeval.tv_sec == last_tv.tv_sec &&
+		ioloop_timeval.tv_usec > last_tv.tv_usec)) {
+		tv = ioloop_timeval;
+	} else {
+		tv = last_tv;
+		if (++tv.tv_usec == 1000000) {
+			tv.tv_sec++;
+			tv.tv_usec = 0;
+		}
+	}
+	last_tv = tv;
+
+	return t_strdup_printf("%s-%s.M%sP%s.%s.sieve", scriptname, dec2str(tv.tv_sec), 
+		dec2str(tv.tv_usec), my_pid, my_hostname);
+}
+
+static int sieve_storage_create_tmp
+(struct sieve_storage *storage, const char *scriptname, const char **fpath_r)
+{
+	struct stat st;
+	unsigned int prefix_len;
+	const char *tmp_fname = NULL;
+	string_t *path;
+	int fd;
+
+	path = t_str_new(256);	
+	str_append(path, storage->dir);
+	str_append(path, "/tmp/");
+	prefix_len = str_len(path);
+
+	for (;;) {
+		tmp_fname = sieve_generate_tmp_filename(scriptname);
+		str_truncate(path, prefix_len);
+		str_append(path, tmp_fname);
+
+		/* stat() first to see if it exists. pretty much the only
+		   possibility of that happening is if time had moved
+		   backwards, but even then it's highly unlikely. */
+		if (stat(str_c(path), &st) == 0) {
+			/* try another file name */	
+		} else if (errno != ENOENT) {
+			sieve_storage_set_critical(storage,
+				"stat(%s) failed: %m", str_c(path));
+			return -1;
+		} else {
+			/* doesn't exist */
+			fd = open(str_c(path),
+				O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0777);
+
+			if (fd != -1 || errno != EEXIST)
+				break;
+			/* race condition between stat() and open().
+				highly unlikely. */
+		}
+	}
+
+    *fpath_r = str_c(path);
+    if (fd == -1) {
+        if (ENOSPACE(errno)) {
+            sieve_storage_set_error(storage, 
+				"Not enough disk space");
+        } else {
+            sieve_storage_set_critical(storage,
+                "open(%s) failed: %m", str_c(path));
+        }
+    } 
+
+    return fd;
+}
+
+
+static int sieve_storage_script_move(struct sieve_save_context *ctx,
+  const char *dst)
+{
+	int failed;
+
+	t_push();
+
+	/* Using rename() to ensure existing files are replaced
+	 * without conflicts with other processes using the same
+	 * file. The kernel wont fully delete the original until
+	 * all processes have closed the file.
+	 */
+	if (rename(ctx->tmp_path, dst) == 0)
+		failed = FALSE;
+	else {
+		failed = TRUE;
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error
+			  (ctx->storage, "Not enough disk space");
+		} else {
+			sieve_storage_set_critical
+			  (ctx->storage, "link(%s, %s) failed: %m", ctx->tmp_path, dst);
+		}
+	}
+
+	/* Always destroy temp file */
+	(void)unlink(ctx->tmp_path);
+
+	t_pop();
+	return !failed;
+}
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input)
+{
+	struct sieve_save_context *ctx;
+	pool_t pool;
+	const char *path;
+
+	/* Prevent overwriting the active script link when it resides in the 
+	 * sieve storage directory.
+	 */
+	if ( *(storage->link_path) == '\0' ) {
+		const char *svext;
+		size_t namelen;
+
+		svext = strrchr(storage->active_fname, '.');
+		namelen = svext - storage->active_fname;
+		if ( svext != NULL && strncmp(svext+1, "sieve", 5) == 0 &&
+			strlen(scriptname) == namelen && 
+			strncmp(scriptname, storage->active_fname, namelen) == 0 ) 
+		{
+			sieve_storage_set_error(
+				storage, "Script name '%s' is reserved for internal use.", 
+				scriptname); 
+			return NULL;
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_save_context", 4096);
+	ctx = p_new(pool, struct sieve_save_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->scriptname = scriptname;
+	ctx->scriptobject = NULL;
+
+	T_BEGIN {
+		ctx->fd = sieve_storage_create_tmp(storage, scriptname, &path);
+		if (ctx->fd == -1) {
+			ctx->failed = TRUE;
+			pool_unref(&pool);
+			ctx = NULL;
+		} else {
+			ctx->input = input;
+			ctx->output = o_stream_create_fd(ctx->fd, 0, FALSE);
+			ctx->tmp_path = p_strdup(pool, path);
+			ctx->failed = FALSE;
+		}
+	} T_END;
+
+	return ctx;
+}
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx)
+{
+	if (o_stream_send_istream(ctx->output, ctx->input) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+		return -1;
+	}
+	return 0;
+}
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx)
+{
+	int output_errno;
+
+	ctx->finished = TRUE;
+	if (ctx->failed && ctx->fd == -1) {
+		/* tmp file creation failed */
+		return -1;
+	}
+
+	t_push();
+	output_errno = ctx->output->stream_errno;
+	o_stream_destroy(&ctx->output);
+
+	if (fsync(ctx->fd) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+					  "fsync(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+	}
+	if (close(ctx->fd) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+					  "close(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+	}
+	ctx->fd = -1;
+
+	if (ctx->failed) {
+		/* delete the tmp file */
+		if (unlink(ctx->tmp_path) < 0 && errno != ENOENT) 
+			i_warning("sieve-storage: Unlink(%s) failed: %m", ctx->tmp_path);
+
+		errno = output_errno;
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error(ctx->storage,
+					       "Not enough disk space");
+		} else if (errno != 0) {
+			sieve_storage_set_critical(ctx->storage,
+				"write(%s) failed: %m", ctx->tmp_path);
+		}
+
+		t_pop();
+		return -1;
+	}
+	t_pop();
+
+	return 0;
+}
+
+static void sieve_storage_save_destroy(struct sieve_save_context **ctx)
+{
+	if ((*ctx)->scriptobject != NULL)
+		sieve_script_unref(&((*ctx)->scriptobject));
+
+	pool_unref(&(*ctx)->pool);
+	*ctx = NULL;
+}
+
+struct sieve_script *sieve_storage_save_get_tempscript
+	(struct sieve_save_context *ctx)
+{
+	bool exists = FALSE;
+
+	if (ctx->failed) 
+		return NULL;
+
+	ctx->scriptobject = sieve_storage_script_init_from_path
+		(ctx->storage, ctx->tmp_path, ctx->scriptname, &exists);	
+
+	if ( !exists ) {
+		sieve_storage_set_critical(ctx->storage, 
+			"save: Temporary script file with name '%s' got lost, "
+			"which should not happen (possibly deleted externally).", 
+			ctx->tmp_path);
+		sieve_script_unref(&ctx->scriptobject);
+		return NULL;
+	}
+
+	return ctx->scriptobject;
+}
+
+int sieve_storage_save_commit(struct sieve_save_context **ctx)
+{
+	const char *dest_path;
+	bool failed = FALSE;
+
+	i_assert((*ctx)->output == NULL);
+	i_assert((*ctx)->finished);
+
+	T_BEGIN {
+		dest_path = t_strconcat((*ctx)->storage->dir, "/", 
+			(*ctx)->scriptname, ".sieve", NULL);
+
+		failed = !sieve_storage_script_move((*ctx), dest_path);
+	} T_END;
+
+	sieve_storage_save_destroy(ctx);
+
+	return !failed;
+}
+
+void sieve_storage_save_cancel(struct sieve_save_context **ctx)
+{
+	(*ctx)->failed = TRUE;
+
+	if (!(*ctx)->finished) 
+		(void)sieve_storage_save_finish(*ctx);
+	else
+		(void)unlink((*ctx)->tmp_path);
+
+	i_assert((*ctx)->output == NULL);
+
+	sieve_storage_save_destroy(ctx);
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h	2008-01-07 07:00:35.000000000 -0700
@@ -0,0 +1,24 @@
+#ifndef __SIEVE_SAVE_H
+#define __SIEVE_SAVE_H
+
+#include "sieve-storage.h"
+
+struct sieve_save_context;
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input);
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx);
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx);
+
+struct sieve_script *sieve_storage_save_get_tempscript
+  (struct sieve_save_context *ctx);
+
+void sieve_storage_save_cancel(struct sieve_save_context **ctx);
+
+int sieve_storage_save_commit(struct sieve_save_context **ctx);
+
+#endif
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c	2008-03-01 15:44:48.000000000 -0700
@@ -0,0 +1,502 @@
+#include "lib.h"
+#include "mempool.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "file-copy.h"
+
+#include "sieve-script-private.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+#include <fcntl.h>
+
+struct sieve_storage_script {
+	struct sieve_script script;	
+
+    struct sieve_storage *storage;
+};
+
+struct sieve_script *sieve_storage_script_init_from_path
+(struct sieve_storage *storage, const char *path, const char *scriptname, 
+	bool *exists_r)
+{
+	pool_t pool;
+	struct sieve_storage_script *st_script = NULL;	
+
+	/* Prevent initializing the active script link as a script when it
+     * resides in the sieve storage directory.
+	 */
+	if ( *(storage->link_path) == '\0' ) {
+		const char *fname;
+
+		fname = strrchr(path, '/');
+		if ( fname == NULL )
+			fname = path;
+		else
+			fname++;
+
+		if ( strcmp(fname, storage->active_fname) == 0 ) {
+			if ( exists_r != NULL )
+				*exists_r = FALSE;
+			return NULL;
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_storage_script", 4096);	
+	st_script = p_new(pool, struct sieve_storage_script, 1);
+	st_script->script.pool = pool;
+	st_script->storage = storage;
+
+	if ( sieve_script_init(&st_script->script, path, scriptname, 
+		sieve_storage_get_error_handler(storage), exists_r) != NULL ) {
+
+		return &st_script->script;
+	}
+
+	pool_unref(&pool);
+
+	return NULL;
+}
+
+struct sieve_script *sieve_storage_script_init
+	(struct sieve_storage *storage, const char *scriptname, bool *exists_r)
+{	
+	struct sieve_script *script;
+	const char *path;
+
+	T_BEGIN {
+		path = t_strconcat( storage->dir, "/", scriptname, ".sieve", NULL );
+
+		script = sieve_storage_script_init_from_path
+			(storage, path, scriptname, exists_r);
+	} T_END;
+
+	return script;
+}
+
+const char *sieve_storage_file_get_scriptname
+	(const struct sieve_storage *storage ATTR_UNUSED, const char *filename)
+{
+	const char *ext;
+
+	ext = strrchr(filename, '.');
+
+	if ( ext == NULL || ext == filename || strcmp(ext,".sieve") != 0 ) 
+		return NULL;
+	
+	return t_strdup_until(filename, ext);
+}
+
+static const char *sieve_storage_read_active_link
+	(struct sieve_storage *storage, bool *not_link)
+{
+  char linkbuf[PATH_MAX];
+  int ret;
+
+	if ( not_link != NULL )
+		*not_link = FALSE;
+
+	ret = readlink(storage->active_path, linkbuf, sizeof(linkbuf));
+
+	if ( ret < 0 ) {
+		if (errno == EINVAL) {
+			/* Our symlink is no symlink. Report 'no active script'.
+			 * Activating a script will automatically resolve this, so
+			 * there is no need to panic on this one.
+			 */
+			i_warning
+			  ("sieve-storage: Active sieve script symlink %s is no symlink.",
+			   storage->active_path);
+			if ( not_link != NULL )
+				*not_link = TRUE;
+			return "";
+		}
+
+		if (errno != ENOENT ) {
+			/* We do need to panic otherwise */
+			sieve_storage_set_critical
+			  (storage,
+			  	"Performing readlink() on active sieve symlink '%s' failed: %m", 
+					storage->active_path);
+			return NULL;
+		}
+
+		return "";
+	}
+
+	/* ret is now assured to be valid, i.e. > 0 */
+	return t_strndup(linkbuf, ret);
+}
+
+static const char *sieve_storage_parse_link
+	(struct sieve_storage *storage, const char *link)
+{
+	const char *fname, *scriptname, *scriptpath;
+
+	/* Split link into path and filename */
+	fname = strrchr(link, '/');
+	if ( fname != NULL ) {
+		scriptpath = t_strdup_until(link, fname+1);
+		fname++;
+	} else {
+		scriptpath = "";
+		fname = link;
+	}
+
+	/* Check the script name */
+	scriptname = sieve_storage_file_get_scriptname(storage, fname);
+
+	/* Warn if link is deemed to be invalid */
+	if ( scriptname == NULL ) {
+		i_warning
+			("sieve-storage: Active sieve script symlink %s is broken: "
+				"invalid scriptname (points to %s).",
+				storage->active_path, link);
+		return NULL;
+	}
+
+	/* Check whether the path is any good */
+	if ( strcmp(scriptpath, storage->link_path) != 0 &&
+		strcmp(scriptpath, storage->dir) != 0 ) {
+		i_warning
+			("sieve-storage: Active sieve script symlink %s is broken: "
+				"invalid/unknown path to storage (points to %s).",
+				storage->active_path, link);
+		return NULL; 
+	}
+
+	return scriptname;
+}
+
+const char *sieve_storage_get_active_scriptname
+	(struct sieve_storage *storage)
+{
+	const char *link, *scriptname;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, NULL);
+
+	if ( link == NULL || *link == '\0' ) 
+		return link;
+
+	/* Parse the link */
+	scriptname = sieve_storage_parse_link(storage, link);
+
+	if (scriptname == NULL) {
+		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 * Activation should fix this situation.
+		 */
+		return "";
+	}
+
+	return scriptname;
+}
+
+struct sieve_script *
+  sieve_storage_get_active_script(struct sieve_storage *storage, bool *no_active)
+{
+	bool exists, no_link;
+	struct sieve_script *script;
+	const char *scriptname, *link;
+
+	*no_active = FALSE;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, &no_link);
+	
+	if ( link == NULL )
+		/* Error */
+		return NULL;
+
+	if ( *link == '\0' )
+	{
+		if (no_link) {
+			/* Try to open the active_path as a regular file */
+			return sieve_storage_script_init_from_path
+				(storage, storage->active_path, ".dovecot", NULL);
+		}
+
+		*no_active = TRUE;
+		return NULL;
+	}
+
+	/* Parse the link */
+	scriptname = sieve_storage_parse_link(storage, link);
+
+	if (scriptname == NULL) {
+  		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 */
+		*no_active = TRUE;
+		return NULL;
+	}
+	
+	exists = TRUE;
+	script = sieve_storage_script_init(storage, scriptname, &exists);	
+
+	if ( !exists ) {
+		i_warning
+		  ("sieve-storage: Active sieve script symlink %s "
+		   "points to non-existent script (points to %s).",
+		   storage->active_path, link);
+	}
+	
+	*no_active = !exists;
+	return script;
+}
+
+int sieve_storage_script_is_active(struct sieve_script *script)
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	const char *aname;
+
+	t_push();
+	
+	aname = sieve_storage_get_active_scriptname(st_script->storage);
+	
+	if (aname == NULL) {
+		/* Critical error */
+		t_pop();
+		return -1;
+	}
+
+ 	/* Is the requested script active? */
+	if ( strcmp(script->name, aname) == 0 ) {
+		t_pop();
+		return 1;
+	}
+
+	t_pop();
+	return 0;
+}
+
+int sieve_storage_script_delete(struct sieve_script **script) 
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) *script;
+	struct sieve_storage *storage = st_script->storage;
+	int ret = 0;
+
+
+	/* Is the requested script active? */
+	if ( sieve_storage_script_is_active(*script) ) {
+		sieve_storage_set_error(storage, "Cannot delete the active sieve script.");
+		ret = -1;
+	} else {
+		ret = unlink((*script)->path);
+
+		if ( ret < 0 ) {
+			if ( errno == ENOENT ) 
+				sieve_storage_set_error(storage, "Sieve script does not exist.");
+			else
+				sieve_storage_set_critical(
+					storage, "Performing unlink() failed on sieve file '%s': %m", 
+					(*script)->path);
+		}	
+	}
+
+	/* Always deinitialize the script object */
+	sieve_script_unref(script);
+
+	return ret;	
+}
+
+static bool sieve_storage_rescue_regular_file(struct sieve_storage *storage)
+{
+	struct stat st;
+	
+	/* Stat the file */
+	if ( lstat(storage->active_path, &st) != 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_critical(storage, 
+				"Failed to stat active sieve script symlink (%s): %m.", 
+				storage->active_path); 
+			return FALSE;	
+		} 
+		return TRUE;
+	}
+
+  	if ( S_ISLNK( st.st_mode ) ) {
+		if ( getenv("DEBUG") != NULL )
+	    	i_info( "sieve-storage: nothing to rescue %s.", storage->active_path);
+    	return TRUE; /* Nothing to rescue */
+  	}
+
+	/* Only regular files can be rescued */
+	if ( S_ISREG( st.st_mode ) ) {
+		const char *dstpath;
+
+ 		t_push();
+
+		dstpath = t_strconcat
+			( storage->dir, "/dovecot.orig.sieve", NULL );
+		if ( file_copy(storage->active_path, dstpath, 1) < 1 ) {
+			sieve_storage_set_critical(storage, 
+				"Active sieve script file '%s' is a regular file and copying it to the "
+				"script storage as '%s' failed. This needs to be fixed manually.",
+				storage->active_path, dstpath);
+			t_pop();
+			return FALSE;	
+		} else {
+			i_info("sieve-storage: Moved active sieve script file '%s' "
+				"to script storage as '%s'.",
+				storage->active_path, dstpath); 
+			t_pop();
+			return TRUE;
+    	}
+		t_pop();
+  	}
+
+	sieve_storage_set_critical( storage,
+		"Active sieve script file '%s' is no symlink nor a regular file. "
+		"This needs to be fixed manually.", storage->active_path );
+	return FALSE;	
+}
+
+int sieve_storage_deactivate(struct sieve_storage *storage)
+{
+	int ret;
+
+	if ( !sieve_storage_rescue_regular_file(storage) ) 
+		return -1;
+
+	/* Delete the symlink, so no script is active */
+	ret = unlink(storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_error(storage, "sieve_storage_deactivate(): "
+				"error on unlink(%s): %m", storage->active_path);
+			return -1;
+		} else 
+		  return 0;
+	} 
+
+	return 1;
+}
+
+int
+sieve_storage_script_activate(struct sieve_script *script)
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	struct sieve_storage *storage = st_script->storage;
+	struct stat st;
+	const char *active_path_new, *script_path;
+	struct timeval *tv, tv_now;
+	const char *aname;
+	int activated = 0;
+	int ret;
+
+	t_push();	
+
+	/* Find out whether there is an active script, but recreate
+	 * the symlink either way. This way, any possible error in the symlink
+	 * resolves automatically. This step is only necessary to provide a
+	 * proper return value indicating whether the script was already active.
+	 */
+	aname = sieve_storage_get_active_scriptname(storage);
+
+	/* Is the requested script already active? */
+	if ( aname == NULL || strcmp(script->name, aname) != 0 ) 
+		activated = 1; 
+
+	/* Check the scriptfile we are trying to activate */
+	if ( lstat(script->path, &st) != 0 ) {
+		sieve_storage_set_critical(storage, 
+		  "Stat on sieve script %s failed, but it is to be activated: %m.", 
+			script->path);
+		t_pop();
+		return -1;
+	}
+
+	/* Rescue a possible .dovecot.sieve regular file remaining from old 
+	 * installations.
+	 */
+	if ( !sieve_storage_rescue_regular_file(storage) ) {
+		/* Rescue failed, manual intervention is necessary */
+		t_pop();
+		return -1;
+	}
+
+	/* Just try to create the symlink first */
+	script_path = t_strconcat
+	  ( storage->link_path, script->name, ".sieve", NULL );
+		
+ 	ret = symlink(script_path, storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno == EEXIST ) {
+			/* The symlink already exists, try to replace it */
+			tv = &ioloop_timeval;
+
+			for (;;) {	
+				/* First the new symlink is created with a different filename */
+				active_path_new = t_strdup_printf
+					("%s-new.%s.P%sM%s.%s.sieve",
+						storage->active_path,
+						dec2str(tv->tv_sec), my_pid,
+						dec2str(tv->tv_usec), my_hostname);
+
+				ret = symlink(script_path, active_path_new);
+		
+				if ( ret < 0 ) {
+					/* If link exists we try again later */
+					if ( errno == EEXIST ) {
+						/* Wait and try again - very unlikely */
+						sleep(2);
+						tv = &tv_now;
+						if (gettimeofday(&tv_now, NULL) < 0)
+							i_fatal("gettimeofday(): %m");
+						continue;
+					}
+
+					/* Other error, critical */
+					sieve_storage_set_critical
+						(storage, "Creating symlink() %s to %s failed: %m", 
+							active_path_new, script_path);
+					t_pop();
+					return -1;
+				}
+	
+				/* Link created */
+				break;
+			}
+
+			/* Replace the existing link. This activates the new script */
+			ret = rename(active_path_new, storage->active_path);
+
+			if ( ret < 0 ) {
+				/* Failed; created symlink must be deleted */
+				(void)unlink(active_path_new);
+				sieve_storage_set_critical
+					(storage, "Performing rename() %s to %s failed: %m", 
+						active_path_new, storage->active_path);
+				t_pop();
+				return -1;
+			}	
+		} else {
+			/* Other error, critical */
+			sieve_storage_set_critical
+				(storage,
+					"Creating symlink() %s to %s failed: %m",
+					storage->active_path, script_path);
+			t_pop();
+			return -1;
+		}
+	}
+
+	t_pop();
+	return activated;
+}
+
+
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h
--- dovecot-1.1.1/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,29 @@
+#ifndef __SIEVE_FILE_H
+#define __SIEVE_FILE_H
+
+#include "sieve-script.h"
+
+#include "sieve-storage.h"
+
+struct sieve_script *sieve_storage_script_init
+    (struct sieve_storage *storage, const char *scriptname, bool *exists_r);
+
+const char *sieve_storage_file_get_scriptname
+	(const struct sieve_storage *storage, const char *filename);
+
+const char *
+	sieve_storage_get_active_scriptname(struct sieve_storage *storage);
+
+struct sieve_script *
+	sieve_storage_get_active_script(struct sieve_storage *storage, bool *no_active);
+
+int sieve_storage_script_is_active(struct sieve_script *script);
+
+int sieve_storage_script_delete(struct sieve_script **script);
+
+int sieve_storage_deactivate(struct sieve_storage *storage);
+
+int sieve_storage_script_activate(struct sieve_script *script);
+
+#endif
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/src/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/src/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/Makefile.am	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,5 @@
+if HAVE_OLD_SIEVE_PLUGIN
+OLDPLUGIN = lib-cmusieve
+endif
+
+SUBDIRS = $(OLDPLUGIN) lib-managesieve lib-sievestorage managesieve managesieve-login
diff -urN dovecot-1.1.1/dovecot-managesieve/src/Makefile.in dovecot-1.1.1-managesieve/dovecot-managesieve/src/Makefile.in
--- dovecot-1.1.1/dovecot-managesieve/src/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/Makefile.in	2008-05-04 08:28:51.000000000 -0600
@@ -0,0 +1,492 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = lib-cmusieve lib-managesieve lib-sievestorage \
+	managesieve managesieve-login
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+HAVE_DOVECOT_LIBS_FALSE = @HAVE_DOVECOT_LIBS_FALSE@
+HAVE_DOVECOT_LIBS_TRUE = @HAVE_DOVECOT_LIBS_TRUE@
+HAVE_OLD_SIEVE_PLUGIN_FALSE = @HAVE_OLD_SIEVE_PLUGIN_FALSE@
+HAVE_OLD_SIEVE_PLUGIN_TRUE = @HAVE_OLD_SIEVE_PLUGIN_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MODULE_LIBS = @MODULE_LIBS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+@HAVE_OLD_SIEVE_PLUGIN_TRUE@OLDPLUGIN = lib-cmusieve
+SUBDIRS = $(OLDPLUGIN) lib-managesieve lib-sievestorage managesieve managesieve-login
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-libtool clean-recursive ctags \
+	ctags-recursive distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic maintainer-clean-recursive \
+	mostlyclean mostlyclean-generic mostlyclean-libtool \
+	mostlyclean-recursive pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/client.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/client.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/client.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/client.c	2008-01-07 07:22:48.000000000 -0700
@@ -0,0 +1,540 @@
+#include "common.h"
+#include "str.h"
+#include "ioloop.h"
+#include "network.h"
+#include "istream.h"
+#include "ostream.h"
+#include "var-expand.h"
+#include "commands.h"
+
+#include "managesieve-quote.h"
+#include "sieve-storage.h"
+
+#include "client.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+static struct client *my_client; /* we don't need more than one currently */
+
+static void client_idle_timeout(struct client *client)
+{
+	client_send_bye(client, "Disconnected for inactivity.");
+	client_destroy(client, "Disconnected for inactivity");
+}
+
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage)
+{
+	struct client *client;
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd_in, TRUE);
+	net_set_nonblock(fd_out, TRUE);
+
+	client = i_new(struct client, 1);
+	client->fd_in = fd_in;
+	client->fd_out = fd_out;
+	client->input = i_stream_create_fd(fd_in, managesieve_max_line_length, FALSE);
+	client->output = o_stream_create_fd(fd_out, (size_t)-1, FALSE);
+
+	o_stream_set_flush_callback(client->output, client_output, client);
+
+	client->io = io_add(fd_in, IO_READ, client_input, client);
+	client->parser = managesieve_parser_create(client->input, client->output,
+					    managesieve_max_line_length);
+	client->to_idle = timeout_add(CLIENT_IDLE_TIMEOUT_MSECS,
+				      client_idle_timeout, client);
+
+	client->cmd.pool = pool_alloconly_create("command pool", 8192);
+	client->cmd.client = client;
+
+	client->storage = storage;
+
+	i_assert(my_client == NULL);
+	my_client = client;
+
+	if (hook_client_created != NULL)
+		hook_client_created(&client);
+	return client;
+}
+
+static const char *client_stats(struct client *client)
+{	
+	static struct var_expand_table static_tab[] = {
+		{ 'i', NULL },
+		{ 'o', NULL },
+		{ '\0', NULL }
+	};
+	struct var_expand_table *tab;
+	string_t *str;
+
+	tab = t_malloc(sizeof(static_tab));
+	memcpy(tab, static_tab, sizeof(static_tab));
+
+	tab[0].value = dec2str(client->input->v_offset);
+	tab[1].value = dec2str(client->output->offset);
+
+	str = t_str_new(128);
+	var_expand(str, logout_format, tab);
+	return str_c(str);
+}
+
+static const char *client_get_disconnect_reason(struct client *client)
+{
+	errno = client->input->stream_errno != 0 ?
+		client->input->stream_errno :
+		client->output->stream_errno;
+	return errno == 0 || errno == EPIPE ? "Connection closed" :
+		t_strdup_printf("Connection closed: %m");
+}
+
+void client_destroy(struct client *client, const char *reason)
+{
+	int ret;
+
+ 	i_assert(!client->handling_input);
+	i_assert(!client->destroyed);
+	client->destroyed = TRUE;
+
+	if (!client->disconnected) {
+		client->disconnected = TRUE;
+		if (reason == NULL)
+			reason = client_get_disconnect_reason(client);
+		i_info("%s %s", reason, client_stats(client));	
+	}
+
+	if (client->command_pending) {
+		/* try to deinitialize the command */
+		i_assert(client->cmd.func != NULL);
+		i_stream_close(client->input);
+		o_stream_close(client->output);
+		client->input_pending = FALSE;
+
+		ret = client->cmd.func(&client->cmd);
+		i_assert(ret);
+	}
+
+	managesieve_parser_destroy(&client->parser);
+	if (client->io != NULL)
+		io_remove(&client->io);
+	if (client->to_idle_output != NULL)
+        timeout_remove(&client->to_idle_output);
+    timeout_remove(&client->to_idle);
+
+	i_stream_destroy(&client->input);
+	o_stream_destroy(&client->output);
+
+	if (close(client->fd_in) < 0)
+		i_error("close(client in) failed: %m");
+	if (client->fd_in != client->fd_out) {
+		if (close(client->fd_out) < 0)
+			i_error("close(client out) failed: %m");
+	}
+
+	pool_unref(&client->cmd.pool);
+	i_free(client);
+
+	/* quit the program */
+	my_client = NULL;
+	io_loop_stop(ioloop);
+}
+
+void client_disconnect(struct client *client, const char *reason)
+{
+	i_assert(reason != NULL);
+
+	if (client->disconnected)
+		return;
+
+	i_info("Disconnected: %s %s", reason, client_stats(client));
+	client->disconnected = TRUE;
+	(void)o_stream_flush(client->output);
+
+	i_stream_close(client->input);
+	o_stream_close(client->output);
+}
+
+void client_disconnect_with_error(struct client *client, const char *msg)
+{
+	client_send_bye(client, msg);
+	client_disconnect(client, msg);
+}
+
+int client_send_line(struct client *client, const char *data) 
+{
+	struct const_iovec iov[2];
+
+	if (client->output->closed)
+		return -1;
+
+	iov[0].iov_base = data;
+	iov[0].iov_len = strlen(data);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	if (o_stream_sendv(client->output, iov, 2) < 0)
+		return -1;
+	client->last_output = ioloop_time;
+
+	if (o_stream_get_buffer_used_size(client->output) >=
+	    CLIENT_OUTPUT_OPTIMAL_SIZE) {
+		/* buffer full, try flushing */
+		return o_stream_flush(client->output);
+	}
+	return 1;
+}
+
+void client_send_response(struct client *client,
+  const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+	
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL ) {
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL ) {
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void client_send_command_error(struct client_command_context *cmd,
+			       const char *msg)
+{
+	struct client *client = cmd->client;
+	const char *error, *cmd_name;
+	bool fatal;
+
+	if (msg == NULL) {
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_disconnect_with_error(client, msg);
+			return;
+		}
+	}
+
+	if (cmd->name == NULL)
+		error = t_strconcat
+			("Error in MANAGESIEVE command: ", msg, NULL);
+	else {
+		cmd_name = t_str_ucase(cmd->name);
+		error = t_strconcat
+			("Error in MANAGESIEVE command ", cmd_name, ": ", msg, NULL);
+	}
+
+	client_send_no(client, error);
+
+	if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+		client_disconnect_with_error(client,
+			"Too many invalid MANAGESIEVE commands.");
+	}
+
+	/* client_read_args() failures rely on this being set, so that the
+	   command processing is stopped even while command function returns
+	   FALSE. */
+	cmd->param_error = TRUE;
+}
+
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage)
+{
+  const char *error;
+
+  error = sieve_storage_get_last_error(storage);
+
+  client_send_no(client, error);
+}
+
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args)
+{
+	int ret;
+
+	i_assert(count <= INT_MAX);
+
+	ret = managesieve_parser_read_args(cmd->client->parser, count, flags, args);
+	if (ret >= (int)count) {
+		/* all parameters read successfully */
+		return TRUE;
+	} else if (ret == -2) {
+		/* need more data */
+		if (cmd->client->input->closed) {
+            /* disconnected */
+            cmd->param_error = TRUE;
+        }
+		return FALSE;
+	} else {
+		/* error, or missing arguments */
+		client_send_command_error(cmd, ret < 0 ? NULL :
+					  "Missing arguments");
+		return FALSE;
+	}
+}
+
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...)
+{
+	struct managesieve_arg *managesieve_args;
+	va_list va;
+	const char *str;
+	unsigned int i;
+
+	if (!client_read_args(cmd, count, 0, &managesieve_args))
+		return FALSE;
+
+	va_start(va, count);
+	for (i = 0; i < count; i++) {
+		const char **ret = va_arg(va, const char **);
+
+		if (managesieve_args[i].type == MANAGESIEVE_ARG_EOL) {
+			client_send_command_error(cmd, "Missing arguments.");
+			break;
+		}
+
+		str = managesieve_arg_string(&managesieve_args[i]);
+		if (str == NULL) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			break;
+		}
+
+		if (ret != NULL)
+			*ret = str;
+	}
+	va_end(va);
+
+	return i == count;
+}
+
+void _client_reset_command(struct client *client)
+{
+	pool_t pool;
+	size_t size;
+
+	/* reset input idle time because command output might have taken a
+	   long time and we don't want to disconnect client immediately then */
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	client->command_pending = FALSE;
+    if (client->io == NULL && !client->disconnected) {
+        i_assert(i_stream_get_fd(client->input) >= 0);
+        client->io = io_add(i_stream_get_fd(client->input),
+                    IO_READ, client_input, client);
+    }
+    o_stream_set_flush_callback(client->output, client_output, client);
+
+	pool = client->cmd.pool;
+	memset(&client->cmd, 0, sizeof(client->cmd));
+
+	p_clear(pool);
+	client->cmd.pool = pool;
+	client->cmd.client = client;
+
+	managesieve_parser_reset(client->parser);
+
+	/* if there's unread data in buffer, remember that there's input
+	   pending and we should get around to calling client_input() soon.
+	   This is mostly for APPEND/IDLE. */
+	(void)i_stream_get_data(client->input, &size);
+	if (size > 0 && !client->destroyed)
+		client->input_pending = TRUE;
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+static bool client_skip_line(struct client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			client->input_skip_line = FALSE;
+			i++;
+			break;
+		}
+	}
+
+	i_stream_skip(client->input, i);
+	return !client->input_skip_line;
+}
+
+static bool client_handle_input(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	if (cmd->func != NULL) {
+		/* command is being executed - continue it */
+		if (cmd->func(cmd) || cmd->param_error) {
+			/* command execution was finished */
+			if (!cmd->param_error)
+				client->bad_counter = 0;
+			_client_reset_command(client);
+			return TRUE;
+		}
+
+		/* unfinished */
+        if (client->command_pending)
+            o_stream_set_flush_pending(client->output, TRUE);
+		return FALSE;
+	}
+
+	if (client->input_skip_line) {
+		/* we're just waiting for new line.. */
+		if (!client_skip_line(client))
+			return FALSE;
+
+		/* got the newline */
+		_client_reset_command(client);
+
+		/* pass through to parse next command */
+	}
+
+	if (cmd->name == NULL) {
+		cmd->name = managesieve_parser_read_word(client->parser);
+		if (cmd->name == NULL)
+			return FALSE; /* need more data */
+		cmd->name = p_strdup(cmd->pool, cmd->name);
+	}
+
+	if (cmd->name == '\0') {
+        /* command not given - cmd_func is already NULL. */
+    } else {
+        /* find the command function */
+        struct command *command = command_find(cmd->name);
+
+        if (command != NULL) {
+            cmd->func = command->func;
+        }
+    }
+
+	client->input_skip_line = TRUE;
+	if (cmd->func == NULL) {
+		/* unknown command */
+		client_send_command_error(cmd, "Unknown command.");
+		_client_reset_command(client);
+	} else {
+		i_assert(!client->disconnected);
+
+		client_handle_input(cmd);
+	}
+
+	return TRUE;
+}
+
+void client_input(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+
+	if (client->command_pending) {
+		/* already processing one command. wait. */
+		io_remove(&client->io);
+		return;
+	}
+
+	client->input_pending = FALSE;
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		client_destroy(client, NULL);
+		return;
+	case -2:
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		_client_reset_command(client);
+		break;
+	}
+
+	client->handling_input = TRUE;
+	o_stream_cork(client->output);
+	do {
+		t_push();
+		ret = client_handle_input(cmd);
+		t_pop();
+	} while (ret && !client->disconnected);
+    o_stream_uncork(client->output);
+    client->handling_input = FALSE;
+
+	if (client->command_pending)
+		client->input_pending = TRUE;
+
+	if (client->output->closed)
+		client_destroy(client, NULL);
+}
+
+int client_output(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+	bool finished;
+
+	client->last_output = ioloop_time;
+    timeout_reset(client->to_idle);
+    if (client->to_idle_output != NULL)
+        timeout_reset(client->to_idle_output);
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, NULL);
+		return 1;
+	}
+
+	if (!client->command_pending)
+		return 1;
+
+	/* continue processing command */
+	o_stream_cork(client->output);
+	client->output_pending = TRUE;
+	finished = cmd->func(cmd) || cmd->param_error;
+
+	/* a bit kludgy check. normally we would want to get back to this
+	   output handler, but IDLE is a special case which has command
+	   pending but without necessarily anything to write. */
+	if (!finished && client->output_pending)
+		o_stream_set_flush_pending(client->output, TRUE);
+
+	o_stream_uncork(client->output);
+
+	if (finished) {
+		/* command execution was finished */
+		client->bad_counter = 0;
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			client_input(client);
+	}
+	return ret;
+}
+
+void clients_init(void)
+{
+	my_client = NULL;
+}
+
+void clients_deinit(void)
+{
+	if (my_client != NULL) {
+		client_send_bye(my_client, "Server shutting down.");
+		client_destroy(my_client, "Server shutting down");
+	}
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/client.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/client.h
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/client.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/client.h	2008-01-07 06:41:10.000000000 -0700
@@ -0,0 +1,102 @@
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "commands.h"
+
+struct client;
+struct sieve_storage;
+struct managesieve_parser;
+struct managesieve_arg;
+
+struct client_command_context {
+	struct client *client;
+
+	pool_t pool;
+	const char *name;
+
+	command_func_t *func;
+	void *context;
+
+	unsigned int param_error:1;
+};
+
+struct client {
+	int fd_in, fd_out;
+	struct sieve_storage *storage;
+
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+	struct timeout *to_idle, *to_idle_output;
+
+	time_t last_input, last_output;
+	unsigned int bad_counter;
+
+	struct managesieve_parser *parser;
+	struct client_command_context cmd;
+
+	unsigned int disconnected:1;
+	unsigned int destroyed:1;
+	unsigned int command_pending:1;
+	unsigned int input_pending:1;
+	unsigned int output_pending:1;
+	unsigned int handling_input:1;
+	unsigned int input_skip_line:1; /* skip all the data until we've
+					   found a new line */
+};
+
+/* Create new client with specified input/output handles. socket specifies
+   if the handle is a socket. */
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage);
+void client_destroy(struct client *client, const char *reason);
+
+/* Disconnect client connection */
+void client_disconnect(struct client *client, const char *reason);
+void client_disconnect_with_error(struct client *client, const char *msg);
+
+/* Send a line of data to client. Returns 1 if ok, 0 if buffer is getting full,
+   -1 if error */
+int client_send_line(struct client *client, const char *data);
+
+void client_send_response(struct client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+  client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(cmd, resp_code, msg) \
+  client_send_response(client, "BYE", resp_code, msg)
+
+/* Send BAD command error to client. msg can be NULL. */
+void client_send_command_error(struct client_command_context *cmd,
+			       const char *msg);
+
+/* Send storage or sieve related errors to the client */
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage);
+
+/* Read a number of arguments. Returns TRUE if everything was read or
+   FALSE if either needs more data or error occurred. */
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args);
+/* Reads a number of string arguments. ... is a list of pointers where to
+   store the arguments. */
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...);
+
+void clients_init(void);
+void clients_deinit(void);
+
+void _client_reset_command(struct client *client);
+void client_input(void *context);
+int client_output(void *context);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-capability.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-capability.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-capability.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-capability.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,31 @@
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "ostream.h"
+
+#include "sieve.h"
+
+bool cmd_capability(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	const char *sievecap, *sieveimpl;
+
+	sievecap = sieve_get_capabilities();
+	if (sievecap == NULL)
+		sievecap = "";
+
+	t_push();		
+	sievecap = t_strconcat("\"SIEVE\" \"", sievecap, "\"", NULL);
+  	sieveimpl = t_strconcat("\"IMPLEMENTATION\" \"", 
+    managesieve_implementation_string, "\"", NULL);
+
+	client_send_line(client, sieveimpl);
+	client_send_line(client, sievecap);
+	client_send_line(client, "OK \"Capability completed.\"");
+	t_pop();
+
+	return TRUE;
+
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-deletescript.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-deletescript.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-deletescript.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-deletescript.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,41 @@
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+bool cmd_deletescript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+
+	/* <scrip name>*/
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	exists = TRUE;
+	script = sieve_storage_script_init(storage, scriptname, &exists);
+
+	if (script == NULL) {
+		if (!exists) 
+			client_send_no(client, "Script does not exist.");
+		else 
+			client_send_storage_error(client, storage);
+
+		return TRUE;
+	}
+
+	if (sieve_storage_script_delete(&script) < 0)
+		client_send_storage_error(client, storage);
+	else
+		client_send_ok(client, "Deletescript completed.");
+
+	/* Script object is deleted no matter what in 
+	 * sieve_script_delete()
+	 */
+
+	return TRUE;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-getscript.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-getscript.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-getscript.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-getscript.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,117 @@
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+#include "istream.h"
+
+#include "sieve-storage-script.h"
+
+struct cmd_getscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;	
+	uoff_t scriptsize;
+
+	struct sieve_script *script;
+	struct istream *scriptstream;
+	bool failed;
+	bool exists;
+};
+
+static bool cmd_getscript_finish(struct cmd_getscript_context *ctx)
+{
+  struct client *client = ctx->client;
+
+	if (ctx->script != NULL)
+		sieve_script_unref(&ctx->script);
+
+	if (ctx->failed) {
+		if (client->output->closed) {
+			client_disconnect(client, "Disconnected");
+			return TRUE;
+		}
+
+		if (!ctx->exists) {
+			client_send_no(client, "Script does not exist.");
+			return TRUE;
+		}
+		
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	client_send_line(client, "");
+	client_send_ok(client, "Getscript completed.");
+	return TRUE;
+}
+
+static bool cmd_getscript_continue(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx = cmd->context;
+
+	if (o_stream_send_istream(client->output, ctx->scriptstream) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", sieve_script_name(ctx->script));
+		ctx->failed = TRUE;    
+	}
+
+	/* FIXME: Check whether there is a bug in the io_stream_sendfile function
+	 * as the eof indicator of the input stream is never set. The stream_sendfile
+	 * function does not use read functions of the inputstream and therefore
+	 * the eof indicator will not be updated. Workaround: check v_offset == size 
+	 * as well.
+	 */
+	if (ctx->scriptstream->eof || ctx->scriptstream->closed ||
+		ctx->scriptstream->v_offset == ctx->scriptsize ) {
+		if (client->output->closed || ctx->scriptstream->v_offset < ctx->scriptsize) 
+			ctx->failed = TRUE;
+	} else if (!ctx->failed) 
+		/* unfinished */
+		return FALSE;
+
+	return cmd_getscript_finish(ctx);
+}
+
+bool cmd_getscript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx;
+	const char *scriptname;
+	bool deleted_r;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	ctx = p_new(cmd->pool, struct cmd_getscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->failed = FALSE;
+	
+	ctx->exists = TRUE;
+	ctx->script = sieve_storage_script_init(client->storage, scriptname, &ctx->exists);
+
+	if (ctx->script == NULL) {
+		ctx->failed = TRUE;
+		return cmd_getscript_finish(ctx);
+	}
+			
+	ctx->scriptstream = sieve_script_open(ctx->script, &deleted_r);
+
+	if ( ctx->scriptstream == NULL ) {
+		ctx->failed = TRUE;
+		ctx->exists = !deleted_r;
+		return cmd_getscript_finish(ctx);
+	}
+
+	ctx->scriptsize = sieve_script_get_size(ctx->script);
+
+	client_send_line(client, t_strdup_printf("{%"PRIuUOFF_T"}", ctx->scriptsize));
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_getscript_continue;
+	cmd->context = ctx;
+
+	return cmd_getscript_continue(cmd);
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-havespace.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-havespace.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-havespace.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-havespace.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,38 @@
+#include "common.h"
+#include "commands.h"
+
+bool cmd_havespace(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct managesieve_arg *args;
+	const char *scriptname;
+	uoff_t size;
+	int ret;
+
+	/* <scriptname> <size> */
+	if (!(ret=client_read_args(cmd, 2, 0, &args)))
+	  return FALSE;
+
+	if ( ret > 2 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( (scriptname = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid string for scriptname.");
+		return TRUE;
+	}
+
+	if ( managesieve_arg_number(&args[1], &size) < 0 ) {
+		client_send_no(client, "Invalid scriptsize argument.");
+		return TRUE;
+	}
+
+	if ( size == 0 ) {
+		client_send_no(client, "Cannot upload empty script.");
+		return TRUE;
+	}
+
+	client_send_ok(client, "Putscript would succeed.");
+	return TRUE;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-listscripts.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-listscripts.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-listscripts.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-listscripts.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,46 @@
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "sieve-storage.h"
+#include "sieve-storage-list.h"
+#include "managesieve-quote.h"
+
+bool cmd_listscripts(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct sieve_list_context *ctx;
+	const char *scriptname;
+	bool active;
+	string_t *str;
+
+	if ( (ctx = sieve_storage_list_init(client->storage))
+		== NULL ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	/* FIXME: This will be quite slow for large script lists. Implement
+	 * some buffering to fix this. Wont truely be an issue with managesieve
+	 * though.
+	 */
+	while ((scriptname = sieve_storage_list_next(ctx, &active)) != NULL) {
+		t_push();
+		str = t_str_new(128);
+	  
+		managesieve_quote_append_string(str, scriptname, FALSE);
+		
+		if ( active ) 
+		  str_append(str, " ACTIVE");
+		
+		client_send_line(client, str_c(str));
+		t_pop();
+	}
+  
+	if ( sieve_storage_list_deinit(&ctx) < 0 ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+	
+	client_send_ok(client, "Listscripts completed.");
+	return TRUE;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-logout.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-logout.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-logout.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-logout.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,12 @@
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+
+bool cmd_logout(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	client_send_line(client, "OK \"Logout completed.\"");
+	client_disconnect(client, "Logged out");
+	return TRUE;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-putscript.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-putscript.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-putscript.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-putscript.c	2008-02-13 05:10:03.000000000 -0700
@@ -0,0 +1,376 @@
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "commands.h"
+#include "managesieve-parser.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-save.h"
+#include "sieve.h"
+
+#include <sys/time.h>
+
+struct cmd_putscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;
+
+	struct istream *input;
+
+	const char *scriptname;
+	uoff_t script_size;	
+
+	struct managesieve_parser *save_parser;
+	struct sieve_save_context *save_ctx;
+};
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx);
+static bool cmd_putscript_continue_script(struct client_command_context *cmd);
+
+static void client_input_putscript(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+
+	i_assert(!client->destroyed);
+
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		cmd_putscript_finish(cmd->context);
+		/* Reset command so that client_destroy() doesn't try to call
+		   cmd_putscript_continue_script() anymore. */
+		_client_reset_command(client);
+		client_destroy(client, "Disconnected in putscript");
+		return;
+	case -2:
+		cmd_putscript_finish(cmd->context);
+		if (client->command_pending) {
+			/* uploaded script data, this is handled internally by
+			   mailbox_save_continue() */
+			break;
+		}
+
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		cmd->param_error = TRUE;
+		_client_reset_command(client);
+		return;
+	}
+
+	if (cmd->func(cmd)) {
+		/* command execution was finished. Note that if cmd_sync()
+		   didn't finish, we didn't get here but the input handler
+		   has already been moved. So don't do anything important
+		   here..
+
+		   reset command once again to reset cmd_sync()'s changes. */
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			client_input(client);
+	}
+}
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx)
+{
+	managesieve_parser_destroy(&ctx->save_parser);
+	
+	io_remove(&ctx->client->io);
+	o_stream_set_flush_callback(ctx->client->output,
+				    client_output, ctx->client);
+
+	if (ctx->input != NULL)
+		i_stream_unref(&ctx->input);
+
+	if (ctx->save_ctx != NULL)
+	{
+		ctx->client->input_skip_line = TRUE;
+		sieve_storage_save_cancel(&ctx->save_ctx);
+	}
+}
+
+static bool cmd_putscript_continue_cancel(struct client_command_context *cmd)
+{
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+
+	(void)i_stream_read(ctx->input);
+	(void)i_stream_get_data(ctx->input, &size);
+	i_stream_skip(ctx->input, size);
+
+	if ( cmd->client->input->closed ||
+		ctx->input->v_offset == ctx->script_size ) {
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool cmd_putscript_cancel(struct cmd_putscript_context *ctx, bool nonsync)
+{
+	ctx->client->input_skip_line = TRUE;
+
+	if (!nonsync) { /* Rediculous for managesieve */
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* we have to read the nonsynced literal so we don't treat the uploaded script
+	   as commands. */
+	ctx->input = i_stream_create_limit(ctx->client->input, ctx->script_size);
+
+	ctx->client->command_pending = TRUE;
+	ctx->cmd->func = cmd_putscript_continue_cancel;
+	ctx->cmd->context = ctx;
+	return cmd_putscript_continue_cancel(ctx->cmd);
+}
+
+static bool cmd_putscript_finish_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	struct sieve_script *script;
+	int ret;
+	
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+	
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+          MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1 || client->output->closed) {
+		if (ctx->storage != NULL)
+			client_send_command_error(cmd, NULL);
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args[0].type == MANAGESIEVE_ARG_EOL) {
+		/* last (and only) script */
+		bool success = TRUE;
+
+		/* eat away the trailing CRLF */
+		client->input_skip_line = TRUE;
+
+		script = sieve_storage_save_get_tempscript(ctx->save_ctx);
+
+		if ( script == NULL ) {
+			client_send_storage_error(client, ctx->storage);
+        	cmd_putscript_finish(ctx);
+        	return TRUE;
+		}
+
+		T_BEGIN {
+			struct sieve_error_handler *ehandler;
+			string_t *errors;
+
+			errors = t_str_new(1024);
+			ehandler = sieve_strbuf_ehandler_create(errors);
+			if ( script == NULL || (sieve_compile_script(script, ehandler) == NULL)) {
+				client_send_no(client, str_c(errors));
+				success = FALSE;
+			} else {
+				ret = sieve_storage_save_commit(&ctx->save_ctx);
+				if (ret < 0) {
+					client_send_storage_error(client, ctx->storage);
+					success = FALSE;
+				} 
+			}
+			sieve_error_handler_unref(&ehandler);
+		} T_END;
+
+		cmd_putscript_finish(ctx);
+
+		if ( success ) {
+			client_send_ok(client, "Putscript completed.");
+		}
+		
+		return TRUE;
+	}
+
+	client_send_command_error(cmd, "Too many command arguments.");
+	cmd_putscript_finish(ctx);
+	return TRUE;
+}
+
+static bool cmd_putscript_continue_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	bool nonsync = FALSE;
+	int ret;
+
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+				    MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1 || client->output->closed) {
+		cmd_putscript_finish(ctx);
+		client_send_command_error(cmd, "Invalid arguments.");
+		client->input_skip_line = TRUE;
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args->type != MANAGESIEVE_ARG_STRING) {
+		/* Validate the script argument */
+	  	if (args->type != MANAGESIEVE_ARG_LITERAL_SIZE ) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			return cmd_putscript_cancel(ctx, FALSE);
+		}
+
+		ctx->script_size = MANAGESIEVE_ARG_LITERAL_SIZE(args);
+		nonsync = TRUE;
+	} else {
+	  	/* FIXME */
+		client_send_no(client, "This MANAGESIEVE implementation currently does not allow "
+			       "quoted strings to be used for script contents.");
+		return cmd_putscript_cancel(ctx, FALSE);		
+	}
+
+	if (ctx->script_size == 0) {
+		/* no script content, abort */
+		client_send_no(client, "PUTSCRIPT aborted (empty script).");
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* save the script */
+	ctx->input = i_stream_create_limit(client->input, ctx->script_size);
+	ctx->save_ctx = sieve_storage_save_init(ctx->storage, ctx->scriptname, ctx->input);
+
+	if ( ctx->save_ctx == NULL ) {
+		/* save initialization failed */
+		client_send_storage_error(client, ctx->storage);
+		return cmd_putscript_cancel(ctx, nonsync);
+	}
+
+	/* after literal comes CRLF, if we fail make sure we eat it away */
+	client->input_skip_line = TRUE;
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_putscript_continue_script;
+	return cmd_putscript_continue_script(cmd);
+}
+
+static bool cmd_putscript_continue_script(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+	bool failed;
+	int ret;
+
+	if (ctx->save_ctx != NULL) {
+		while (ctx->input->v_offset != ctx->script_size) {
+			ret = i_stream_read(ctx->input);
+			if (sieve_storage_save_continue(ctx->save_ctx) < 0) {
+				/* we still have to finish reading the script
+			   	  from client */
+				sieve_storage_save_cancel(&ctx->save_ctx);
+				break;
+			}
+			if (ret == -1 || ret == 0)
+                break;
+		}
+	}
+
+	if (ctx->save_ctx == NULL) {
+		(void)i_stream_read(ctx->input);
+		(void)i_stream_get_data(ctx->input, &size);
+		i_stream_skip(ctx->input, size);
+	}
+
+	if (ctx->input->eof || client->input->closed) {
+		bool all_written = ctx->input->v_offset == ctx->script_size;
+
+		/* finished */
+		i_stream_unref(&ctx->input);
+		ctx->input = NULL;
+
+		if (ctx->save_ctx == NULL) {
+			/* failed above */
+			client_send_storage_error(client, ctx->storage);
+			failed = TRUE;
+		} else if (!all_written) {
+			/* client disconnected before it finished sending the
+			   whole script. */
+			failed = TRUE;
+			sieve_storage_save_cancel(&ctx->save_ctx);
+			client_disconnect(client, "EOF while appending");
+		} else if (sieve_storage_save_finish(ctx->save_ctx) < 0) {
+			failed = TRUE;
+			client_send_storage_error(client, ctx->storage);
+		} else {
+			failed = client->input->closed;
+		}
+
+		if (failed) {
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		}
+
+		/* finish */
+		client->command_pending = FALSE;
+		managesieve_parser_reset(ctx->save_parser);
+		cmd->func = cmd_putscript_finish_parsing;
+		return cmd_putscript_finish_parsing(cmd);
+	}
+
+	return FALSE;
+}
+
+bool cmd_putscript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx;
+	const char *scriptname;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname) || 
+		*scriptname == '\0')
+		return FALSE;
+
+	ctx = p_new(cmd->pool, struct cmd_putscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->scriptname = scriptname;
+
+	io_remove(&client->io);
+	client->io = io_add(i_stream_get_fd(client->input), IO_READ,
+			    client_input_putscript, client);
+	/* putscript is special because we're only waiting on client input, not
+	   client output, so disable the standard output handler until we're
+	   finished */
+	o_stream_unset_flush_callback(client->output);
+
+	ctx->save_parser = managesieve_parser_create(client->input, client->output,
+					      managesieve_max_line_length);
+
+	cmd->func = cmd_putscript_continue_parsing;
+	cmd->context = ctx;
+	return cmd_putscript_continue_parsing(cmd);
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-setactive.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-setactive.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/cmd-setactive.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/cmd-setactive.c	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,54 @@
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+bool cmd_setactive(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+	int ret;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	if ( *scriptname != '\0' ) {
+		exists = TRUE;
+		script = sieve_storage_script_init(storage, scriptname, &exists);
+
+		if (script == NULL) {
+			if (!exists)
+				client_send_no(client, "Script does not exist.");
+			else
+				client_send_storage_error(client, storage);
+
+			return TRUE;
+		}
+	
+		ret = sieve_storage_script_activate(script);
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ? 
+				"Setactive completed." :
+				"Script is already active.");
+
+		sieve_script_unref(&script);
+	} else {
+		ret = sieve_storage_deactivate(storage);
+		
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ?
+ 				"Active script is now deactivated." :
+				"No scripts currently active.");	
+	}
+
+	return TRUE;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/commands.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/commands.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/commands.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/commands.c	2008-03-01 15:20:34.000000000 -0700
@@ -0,0 +1,109 @@
+#include "common.h"
+#include "array.h"
+#include "commands.h"
+
+#include <stdlib.h>
+
+/* Might want to combine this somewhere in a commands-common.c 
+ * to avoid duplicate code 
+ */
+
+const struct command managesieve_commands[] = {
+	{ "CAPABILITY", cmd_capability },
+	{ "LOGOUT", cmd_logout },
+	{ "PUTSCRIPT", cmd_putscript },
+	{ "GETSCRIPT", cmd_getscript },
+	{ "SETACTIVE", cmd_setactive },
+	{ "DELETESCRIPT", cmd_deletescript },
+	{ "LISTSCRIPTS", cmd_listscripts },
+	{ "HAVESPACE", cmd_havespace }
+};
+
+#define MANAGESIEVE_COMMANDS_COUNT N_ELEMENTS(managesieve_commands) 
+
+static ARRAY_DEFINE(commands, struct command);
+static bool commands_unsorted;
+
+void command_register(const char *name, command_func_t *func)
+{
+	struct command cmd;
+
+	cmd.name = name;
+	cmd.func = func;
+	array_append(&commands, &cmd, 1);
+
+	commands_unsorted = TRUE;
+}
+
+void command_unregister(const char *name)
+{
+	const struct command *cmd;
+	unsigned int i, count;
+
+	cmd = array_get(&commands, &count);
+	for (i = 0; i < count; i++) {
+		if (strcasecmp(cmd[i].name, name) == 0) {
+			array_delete(&commands, i, 1);
+			return;
+		}
+	}
+
+	i_error("Trying to unregister unknown command '%s'", name);
+}
+
+void command_register_array(const struct command *cmdarr, unsigned int count)
+{
+	commands_unsorted = TRUE;
+	array_append(&commands, cmdarr, count);
+}
+
+void command_unregister_array(const struct command *cmdarr, unsigned int count)
+{
+	while (count > 0) {
+		command_unregister(cmdarr->name);
+		count--; cmdarr++;
+	}
+}
+
+static int command_cmp(const void *p1, const void *p2)
+{
+	const struct command *c1 = p1, *c2 = p2;
+
+	return strcasecmp(c1->name, c2->name);
+}
+
+static int command_bsearch(const void *name, const void *cmd_p)
+{
+	const struct command *cmd = cmd_p;
+
+	return strcasecmp(name, cmd->name);
+}
+
+struct command *command_find(const char *name)
+{
+    void *base;
+    unsigned int count;
+
+    base = array_get_modifiable(&commands, &count);
+    if (commands_unsorted) {
+        qsort(base, count, sizeof(struct command), command_cmp);
+                commands_unsorted = FALSE;
+    }
+
+    return bsearch(name, base, count, sizeof(struct command),
+               command_bsearch);
+}
+
+void commands_init(void)
+{
+	i_array_init(&commands, 16);
+	commands_unsorted = FALSE;
+	
+	command_register_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+}
+
+void commands_deinit(void)
+{
+	command_unregister_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+	array_free(&commands);
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/commands.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/commands.h
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/commands.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/commands.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,45 @@
+#ifndef __COMMANDS_H
+#define __COMMANDS_H
+
+struct client_command_context;
+
+#include "managesieve-parser.h"
+
+typedef bool command_func_t(struct client_command_context *cmd);
+
+struct command {
+	const char *name;
+	command_func_t *func;
+};
+
+/* Register command. Given name parameter must be permanently stored until
+   command is unregistered. */
+void command_register(const char *name, command_func_t *func);
+void command_unregister(const char *name);
+
+/* Register array of commands. */
+void command_register_array(const struct command *cmdarr, unsigned int count);
+void command_unregister_array(const struct command *cmdarr, unsigned int count);
+
+struct command *command_find(const char *name);
+
+void commands_init(void);
+void commands_deinit(void);
+
+/* MANAGESIEVE commands: */
+
+/* Non-Authenticated State */
+bool cmd_logout(struct client_command_context *cmd);
+
+bool cmd_capability(struct client_command_context *cmd);
+
+/* Authenticated State */
+bool cmd_putscript(struct client_command_context *cmd);
+bool cmd_getscript(struct client_command_context *cmd);
+bool cmd_setactive(struct client_command_context *cmd);
+bool cmd_deletescript(struct client_command_context *cmd);
+bool cmd_listscripts(struct client_command_context *cmd);
+bool cmd_havespace(struct client_command_context *cmd);
+
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/common.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/common.h
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/common.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/common.h	2008-01-07 07:18:59.000000000 -0700
@@ -0,0 +1,39 @@
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#include "lib.h"
+#include "client.h"
+
+/* Disconnect client after idling this many milliseconds */
+#define CLIENT_IDLE_TIMEOUT_MSECS (60*30*1000)
+
+/* If we can't send anything to client for this long, disconnect the client */
+#define CLIENT_OUTPUT_TIMEOUT_MSECS (5*60*1000)
+
+/* Stop buffering more data into output stream after this many bytes */
+#define CLIENT_OUTPUT_OPTIMAL_SIZE 2048
+
+/* Disconnect client when it sends too many bad commands in a row */
+#define CLIENT_MAX_BAD_COMMANDS 20
+
+/* RFC-2683 recommends at least 8000 bytes. Some clients however don't
+   break large message sets to multiple commands, so we're pretty liberal
+   by default. */
+#define DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH 65536
+
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING PACKAGE
+
+enum client_workarounds {
+  WORKAROUND_NONE    = 0x00,
+};
+
+extern struct ioloop *ioloop;
+extern unsigned int managesieve_max_line_length;
+extern const char *managesieve_implementation_string;
+extern enum client_workarounds client_workarounds;
+extern const char *logout_format;
+
+//extern void (*hook_mail_storage_created)(struct sieve_storage *storage);
+extern void (*hook_client_created)(struct client **client);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/main.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/main.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/main.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/main.c	2008-01-07 07:18:28.000000000 -0700
@@ -0,0 +1,315 @@
+/* Copyright (c) 2006-2008 Dovecot Sieve authors, see the included AUTHORS file */
+
+#include "common.h"
+#include "ioloop.h"
+#include "network.h"
+#include "ostream.h"
+#include "str.h"
+#include "lib-signals.h"
+#include "restrict-access.h"
+#include "fd-close-on-exec.h"
+#include "process-title.h"
+#include "randgen.h"
+#include "module-dir.h"
+#include "dict-client.h"
+
+#include "sieve-storage.h"
+#include "sieve.h"
+
+#include "commands.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+
+#define IS_STANDALONE() \
+        (getenv("LOGGED_IN") == NULL)
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+struct client_workaround_list {
+	const char *name;
+	enum client_workarounds num;
+};
+
+struct client_workaround_list client_workaround_list[] = {
+	{ NULL, 0 }
+};
+
+struct ioloop *ioloop;
+unsigned int managesieve_max_line_length;
+const char *managesieve_implementation_string;
+enum client_workarounds client_workarounds = 0;
+const char *logout_format;
+
+static struct io *log_io = NULL;
+static struct module *modules = NULL;
+static char log_prefix[128]; /* syslog() needs this to be permanent */
+
+void (*hook_client_created)(struct client **client) = NULL;
+
+static void sig_die(int signo, void *context ATTR_UNUSED)
+{
+	/* warn about being killed because of some signal, except SIGINT (^C)
+	   which is too common at least while testing :) */
+	if (signo != SIGINT)
+		i_warning("Killed with signal %d", signo);
+	io_loop_stop(ioloop);
+}
+
+static void log_error_callback(void *context ATTR_UNUSED)
+{
+	io_loop_stop(ioloop);
+}
+
+static void parse_workarounds(void)
+{
+	struct client_workaround_list *list;
+	const char *env, *const *str;
+
+	env = getenv("MANAGESIEVE_CLIENT_WORKAROUNDS");
+	if (env == NULL)
+		return;
+
+	for (str = t_strsplit_spaces(env, " ,"); *str != NULL; str++) {
+		list = client_workaround_list;
+		for (; list->name != NULL; list++) {
+			if (strcasecmp(*str, list->name) == 0) {
+				client_workarounds |= list->num;
+				break;
+			}
+		}
+		if (list->name == NULL)
+			i_fatal("Unknown client workaround: %s", *str);
+	}
+}
+
+static void open_logfile(void)
+{
+	const char *user;
+
+	if (getenv("LOG_TO_MASTER") != NULL) {
+		i_set_failure_internal();
+		return;
+	}
+
+ 	if (getenv("LOG_PREFIX") != NULL)
+		strncpy(log_prefix, getenv("LOG_PREFIX"), sizeof(log_prefix));
+	else {
+		user = getenv("USER");
+		if (user == NULL) {
+			if (IS_STANDALONE())
+				user = getlogin();
+			if (user == NULL)
+				user = "??";
+		}
+		if (strlen(user) >= sizeof(log_prefix)-6) {	
+			/* quite a long user name, cut it */
+ 			user = t_strndup(user, sizeof(log_prefix)-6-2);
+			user = t_strconcat(user, "..", NULL);
+		}
+		i_snprintf(log_prefix, sizeof(log_prefix), "imap(%s): ", user);
+	}
+
+	if (getenv("USE_SYSLOG") != NULL) {
+		const char *env = getenv("SYSLOG_FACILITY");
+		i_set_failure_syslog(log_prefix, LOG_NDELAY,
+				     env == NULL ? LOG_MAIL : atoi(env));
+	} else {
+		/* log to file or stderr */
+		i_set_failure_file(getenv("LOGFILE"), log_prefix);
+	}
+
+	if (getenv("INFOLOGFILE") != NULL)
+		i_set_info_file(getenv("INFOLOGFILE"));
+
+	i_set_failure_timestamp_format(getenv("LOGSTAMP"));
+}
+
+static void drop_privileges(void)
+{
+	const char *version;
+
+	version = getenv("DOVECOT_VERSION");
+	if (version != NULL && strcmp(version, PACKAGE_VERSION) != 0) {
+		i_fatal("Dovecot version mismatch: "
+			"Master is v%s, managesieve is v"PACKAGE_VERSION" "
+			"(if you don't care, set version_ignore=yes)", version);
+	}
+
+	/* Log file or syslog opening probably requires roots */
+	open_logfile();
+
+	/* Most likely needed. Have to open /dev/urandom before possible
+	   chrooting. */
+	random_init();
+	
+	/* Load the plugins before chrooting. Their init() is called later. */
+	/* FIXME: MAIL_PLUGINS is a rather odd config value for a MANAGESIEVE
+	 * server 
+	 */
+	if (getenv("MAIL_PLUGINS") != NULL) {
+		const char *plugin_dir = getenv("MAIL_PLUGIN_DIR");
+
+		if (plugin_dir == NULL)
+			plugin_dir = MODULEDIR"/managesieve";
+		modules = module_dir_load(plugin_dir, getenv("MAIL_PLUGINS"),
+			TRUE, version);
+	}	
+
+	restrict_access_by_env(!IS_STANDALONE());
+}
+
+static void internal_error()
+{
+  struct tm *tm;
+  char str[256];
+
+  tm = localtime(&ioloop_time);
+
+  printf("BYE \"%s\"\n",
+    strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+    i_strdup(str) : i_strdup(CRITICAL_MSG));
+}
+
+static void main_init(void)
+{
+	struct sieve_storage *storage;
+	struct client *client;
+	const char *user, *str, *sieve_storage, *mail;
+
+	lib_signals_init();
+	lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+	lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+	lib_signals_ignore(SIGPIPE, TRUE);
+	lib_signals_ignore(SIGALRM, FALSE);
+
+	user = getenv("USER");
+	if (user == NULL) {
+		if (IS_STANDALONE())
+			user = getlogin();
+		if (user == NULL) {
+			internal_error();
+			i_fatal("USER environment missing");
+		}
+	}
+
+	if (getenv("DEBUG") != NULL) {
+		const char *home;
+
+        home = getenv("HOME");
+        i_info("Effective uid=%s, gid=%s, home=%s",
+               dec2str(geteuid()), dec2str(getegid()),
+               home != NULL ? home : "(none)");
+	}
+	
+	if (getenv("STDERR_CLOSE_SHUTDOWN") != NULL) {
+		/* If master dies, the log fd gets closed and we'll quit */
+		log_io = io_add(STDERR_FILENO, IO_ERROR,
+				log_error_callback, NULL);
+	}
+
+	sieve_init("");
+	dict_driver_register(&dict_driver_client);
+	clients_init();
+	commands_init();
+
+	module_dir_init(modules);	
+
+	/* Settings */
+	str = getenv("MANAGESIEVE_MAX_LINE_LENGTH");
+	managesieve_max_line_length = str != NULL ?
+		(unsigned int)strtoul(str, NULL, 10) :
+		DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH;
+
+	logout_format = getenv("MANAGESIEVE_LOGOUT_FORMAT");
+	if (logout_format == NULL)
+		logout_format = "bytes=%i/%o";
+
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+    str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	parse_workarounds();		
+
+	mail = getenv("MAIL"); 
+	sieve_storage = getenv("SIEVE_STORAGE");
+	if ( (sieve_storage == NULL || *sieve_storage == '\0') && 
+		!(mail == NULL || *mail == '\0') ) { 
+		storage = sieve_storage_create_from_mail(mail, user);
+	} else 
+		storage = sieve_storage_create(sieve_storage, user);
+
+	if (storage == NULL) { 
+    	internal_error();
+
+		/* failed */
+		if (sieve_storage != NULL && *sieve_storage != '\0')   
+			i_fatal("Failed to create sieve storage with data: %s", sieve_storage);
+		else if (mail != NULL && *mail != '\0')   
+			i_fatal("Failed to create sieve storage with mail-data: %s", mail);
+		else {
+			const char *home;
+	    
+			home = getenv("HOME");
+			if (home == NULL) home = "not set";
+	    
+			i_fatal("SIEVE_STORAGE and MAIL environment missing and "
+				"autodetection failed (home %s)", home);
+		}
+	}
+	
+	client = client_create(0, 1, storage);
+	
+	client_send_ok(client, "Logged in.");
+}
+
+static void main_deinit(void)
+{
+	if (log_io != NULL)
+		io_remove(&log_io);
+	clients_deinit();
+
+	module_dir_unload(&modules);
+	commands_deinit();
+	dict_driver_unregister(&dict_driver_client);
+	sieve_deinit();
+	random_deinit();
+
+	lib_signals_deinit();
+	closelog();
+}
+
+int main(int argc ATTR_UNUSED, char *argv[], char *envp[])
+{
+#ifdef DEBUG
+	if (getenv("LOGGED_IN") != NULL && getenv("GDB") == NULL)
+		fd_debug_verify_leaks(3, 1024);
+#endif
+	if (IS_STANDALONE() && getuid() == 0 &&
+	    net_getpeername(1, NULL, NULL) == 0) {
+		printf("NO \"managesieve binary must not be started from "
+		       "inetd, use managesieve-login instead.\"\n");
+		return 1;
+	}
+
+	/* NOTE: we start rooted, so keep the code minimal until
+	   restrict_access_by_env() is called */
+	lib_init();
+	drop_privileges();
+
+	process_title_init(argv, envp);
+	ioloop = io_loop_create();
+
+	main_init();
+	io_loop_run(ioloop);
+	main_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+
+	return 0;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/Makefile.am	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,59 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-DMODULEDIR=\""$(moduledir)"\" \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_LDFLAGS = -export-dynamic
+
+libs = \
+	../lib-managesieve/libmanagesieve.a \
+	../lib-sievestorage/libsievestorage.a \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+
+managesieve_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS) 
+
+managesieve_DEPENDENCIES = $(libs)
+
+cmds = \
+	cmd-capability.c \
+	cmd-logout.c \
+	cmd-putscript.c \
+	cmd-getscript.c \
+	cmd-setactive.c \
+	cmd-deletescript.c \
+	cmd-listscripts.c \
+	cmd-havespace.c 
+
+managesieve_SOURCES = \
+	$(cmds) \
+	client.c \
+	commands.c \
+	main.c 
+
+noinst_HEADERS = \
+	client.h \
+	commands.h \
+	common.h 
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve/Makefile.in dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/Makefile.in
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve/Makefile.in	2008-05-04 08:28:52.000000000 -0600
@@ -0,0 +1,550 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+pkglibexec_PROGRAMS = managesieve$(EXEEXT)
+subdir = src/managesieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(pkglibexecdir)"
+pkglibexecPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(pkglibexec_PROGRAMS)
+am__objects_1 = cmd-capability.$(OBJEXT) cmd-logout.$(OBJEXT) \
+	cmd-putscript.$(OBJEXT) cmd-getscript.$(OBJEXT) \
+	cmd-setactive.$(OBJEXT) cmd-deletescript.$(OBJEXT) \
+	cmd-listscripts.$(OBJEXT) cmd-havespace.$(OBJEXT)
+am_managesieve_OBJECTS = $(am__objects_1) client.$(OBJEXT) \
+	commands.$(OBJEXT) main.$(OBJEXT)
+managesieve_OBJECTS = $(am_managesieve_OBJECTS)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = ../lib-managesieve/libmanagesieve.a \
+	../lib-sievestorage/libsievestorage.a $(am__DEPENDENCIES_1) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(managesieve_SOURCES)
+DIST_SOURCES = $(managesieve_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+HAVE_DOVECOT_LIBS_FALSE = @HAVE_DOVECOT_LIBS_FALSE@
+HAVE_DOVECOT_LIBS_TRUE = @HAVE_DOVECOT_LIBS_TRUE@
+HAVE_OLD_SIEVE_PLUGIN_FALSE = @HAVE_OLD_SIEVE_PLUGIN_FALSE@
+HAVE_OLD_SIEVE_PLUGIN_TRUE = @HAVE_OLD_SIEVE_PLUGIN_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MODULE_LIBS = @MODULE_LIBS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+pkglibexecdir = $(libexecdir)/dovecot
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-DMODULEDIR=\""$(moduledir)"\" \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_LDFLAGS = -export-dynamic
+libs = \
+	../lib-managesieve/libmanagesieve.a \
+	../lib-sievestorage/libsievestorage.a \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+
+managesieve_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS) 
+
+managesieve_DEPENDENCIES = $(libs)
+cmds = \
+	cmd-capability.c \
+	cmd-logout.c \
+	cmd-putscript.c \
+	cmd-getscript.c \
+	cmd-setactive.c \
+	cmd-deletescript.c \
+	cmd-listscripts.c \
+	cmd-havespace.c 
+
+managesieve_SOURCES = \
+	$(cmds) \
+	client.c \
+	commands.c \
+	main.c 
+
+noinst_HEADERS = \
+	client.h \
+	commands.h \
+	common.h 
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/managesieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/managesieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pkglibexecPROGRAMS: $(pkglibexec_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkglibexecdir)" || $(mkdir_p) "$(DESTDIR)$(pkglibexecdir)"
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(pkglibexecPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(pkglibexecPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(pkglibexecdir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-pkglibexecPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pkglibexecdir)/$$f"; \
+	done
+
+clean-pkglibexecPROGRAMS:
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+managesieve$(EXEEXT): $(managesieve_OBJECTS) $(managesieve_DEPENDENCIES) 
+	@rm -f managesieve$(EXEEXT)
+	$(LINK) $(managesieve_LDFLAGS) $(managesieve_OBJECTS) $(managesieve_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-capability.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-deletescript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-getscript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-havespace.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-listscripts.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-logout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-putscript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-setactive.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/commands.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(pkglibexecdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pkglibexecPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-pkglibexecPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-pkglibexecPROGRAMS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pkglibexecPROGRAMS ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-pkglibexecPROGRAMS install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-pkglibexecPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client-authenticate.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client-authenticate.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client-authenticate.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client-authenticate.c	2008-04-26 04:46:14.000000000 -0600
@@ -0,0 +1,343 @@
+#include "common.h"
+#include "base64.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+#include "auth-client.h"
+#include "client.h"
+#include "client-authenticate.h"
+#include "managesieve-proxy.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+
+#define MANAGESIEVE_SERVICE_NAME "managesieve"
+
+/* FIXME: The use of the ANONYMOUS mechanism is currently denied 
+ */
+static bool _sasl_mechanism_acceptable
+	(const struct auth_mech_desc *mech, bool secured) {
+
+	/* a) transport is secured
+	   b) auth mechanism isn't plaintext
+       c) we allow insecure authentication
+	 */
+
+	if ((mech->flags & MECH_SEC_PRIVATE) == 0 &&
+		(mech->flags & MECH_SEC_ANONYMOUS) == 0 &&
+ 		(secured || !disable_plaintext_auth ||
+		(mech->flags & MECH_SEC_PLAINTEXT) == 0)) {
+    		return 1;     
+	}  
+
+	return 0;
+}
+
+const char *client_authenticate_get_capabilities(bool secured)
+{
+	const struct auth_mech_desc *mech;
+	unsigned int i, count;
+	string_t *str;
+
+	str = t_str_new(128);
+	mech = auth_client_get_available_mechs(auth_client, &count);
+
+	if ( count > 0 ) {
+		if ( _sasl_mechanism_acceptable(&(mech[0]), secured) ) {
+			str_append(str, mech[0].name);
+		}
+     
+		for (i = 1; i < count; i++) {
+			if ( _sasl_mechanism_acceptable(&(mech[i]), secured) ) {
+				str_append_c(str, ' ');
+				str_append(str, mech[i].name);
+			}
+		}
+	}
+
+	return str_c(str);
+}
+
+static void client_auth_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	char *line;
+	bool fatal;
+
+	if (client->destroyed)
+		return;
+
+	if (!client_read(client))
+		return;
+
+	if (client->skip_line) {
+		if (i_stream_next_line(client->input) == NULL)
+			return;
+
+		client->skip_line = FALSE;
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			/* FIXME: What to do? */
+		}
+	  
+		sasl_server_auth_client_error(&client->common, msg);
+		return;
+	case -2:
+		/* not enough data */
+		return;
+	}
+
+	if (args[0].type != MANAGESIEVE_ARG_STRING || 
+		args[1].type != MANAGESIEVE_ARG_EOL) {
+		sasl_server_auth_client_error(&client->common, "Invalid AUTHENTICATE client response.");
+		return;
+	}
+
+	line = MANAGESIEVE_ARG_STR(&args[0]);
+
+    auth_client_request_continue(client->common.auth_request, line);
+	io_remove(&client->io);
+
+	/* clear sensitive data */
+	safe_memset(line, 0, strlen(line));
+}
+
+static void client_auth_failed(struct managesieve_client *client)
+{
+    /* get back to normal client input. */
+    if (client->io != NULL)
+        io_remove(&client->io);
+    client->io = io_add(client->common.fd, IO_READ,
+                client_input, client);
+}
+
+static bool client_handle_args(struct managesieve_client *client,
+			       const char *const *args, bool success)
+{
+	const char *reason = NULL, *host = NULL, *destuser = NULL, *pass = NULL;
+	string_t *resp_code;
+	unsigned int port = 2000;
+	bool proxy = FALSE, temp = FALSE, nologin = !success, proxy_self;
+
+	for (; *args != NULL; args++) {
+		if (strcmp(*args, "nologin") == 0)
+			nologin = TRUE;
+		else if (strcmp(*args, "proxy") == 0)
+			proxy = TRUE;
+		else if (strcmp(*args, "temp") == 0)
+			temp = TRUE;
+		else if (strncmp(*args, "reason=", 7) == 0)
+			reason = *args + 7;
+		else if (strncmp(*args, "host=", 5) == 0)
+			host = *args + 5;
+		else if (strncmp(*args, "port=", 5) == 0)
+			port = atoi(*args + 5);
+		else if (strncmp(*args, "destuser=", 9) == 0)
+			destuser = *args + 9;
+		else if (strncmp(*args, "pass=", 5) == 0)
+			pass = *args + 5;
+	}
+
+	if (destuser == NULL)
+		destuser = client->common.virtual_user;
+
+	 proxy_self = proxy &&
+        login_proxy_is_ourself(&client->common, host, port, destuser);	
+  	if (proxy && !proxy_self) {
+		/* we want to proxy the connection to another server.
+		don't do this unless authentication succeeded. with
+		master user proxying we can get FAIL with proxy still set.
+
+		proxy host=.. [port=..] [destuser=..] pass=.. */
+
+		if (!success)
+			return FALSE;
+		if (managesieve_proxy_new(client, host, port, destuser, pass) < 0)
+			client_destroy_internal_failure(client);
+		return TRUE;
+	}
+
+	if (!proxy && host != NULL) {
+		/* MANAGESIEVE referral
+
+		   [nologin] referral host=.. [port=..] [destuser=..]
+		   [reason=..]
+
+		   NO (REFERRAL sieve://user;AUTH=mech@host:port/) Can't login.
+		   OK (...) Logged in, but you should use this server instead.
+		   .. [REFERRAL ..] (Reason from auth server)
+		*/
+		resp_code = t_str_new(128);
+		str_printfa(resp_code, "REFERRAL sieve://%s;AUTH=%s@%s",
+			    destuser, client->common.auth_mech_name, host);
+		if (port != 2000)
+			str_printfa(resp_code, ":%u", port);
+
+		if (reason == NULL) {
+			if (nologin)
+				reason = "Try this server instead.";
+			else 
+				reason = "Logged in, but you should use "
+					"this server instead.";
+		}
+
+		if (!nologin) {
+			client_send_okresp(client, str_c(resp_code), reason);
+			client_destroy(client, "Login with referral");
+			return TRUE;
+		}
+		client_send_noresp(client, str_c(resp_code), reason);
+	} else if (nologin || proxy_self) {
+		/* Authentication went ok, but for some reason user isn't
+		   allowed to log in. Shouldn't probably happen. */
+		if (proxy_self) {
+			client_syslog(&client->common,
+				"Proxying loops to itself");
+        }
+
+		if (reason != NULL)
+			client_send_no(client, reason);
+		else if (temp)
+			client_send_no(client, AUTH_TEMP_FAILED_MSG);		
+		else
+			client_send_no(client, AUTH_FAILED_MSG);
+	} else {
+		/* normal login/failure */
+		return FALSE;
+	}
+
+	i_assert(nologin || proxy_self);
+
+	managesieve_parser_reset(client->parser);
+
+	if (!client->destroyed) 
+		client_auth_failed(client);
+	return TRUE;
+}
+
+static void sasl_callback(struct client *_client, enum sasl_server_reply reply,
+			  const char *data, const char *const *args)
+{
+	struct managesieve_client *client = (struct managesieve_client *)_client;
+	string_t *str;
+
+	i_assert(!client->destroyed ||
+		reply == SASL_SERVER_REPLY_CLIENT_ERROR ||
+		reply == SASL_SERVER_REPLY_MASTER_FAILED);
+
+	client->skip_line = TRUE;
+
+	switch (reply) {
+	case SASL_SERVER_REPLY_SUCCESS:
+		timeout_remove(&client->to_auth_waiting);
+		if (args != NULL) {
+			if (client_handle_args(client, args, TRUE))
+				break;
+		}
+
+		client_destroy(client, "Login");
+		break;
+	case SASL_SERVER_REPLY_AUTH_FAILED:
+	case SASL_SERVER_REPLY_CLIENT_ERROR:
+		timeout_remove(&client->to_auth_waiting);
+		if (args != NULL) {
+			if (client_handle_args(client, args, FALSE))
+				break;
+		}
+
+		client_send_no(client, data != NULL ? data : AUTH_FAILED_MSG);
+
+		managesieve_parser_reset(client->parser);
+
+		if (!client->destroyed) 
+			client_auth_failed(client);
+		break;
+	case SASL_SERVER_REPLY_MASTER_FAILED:
+		if (data == NULL)
+			client_destroy_internal_failure(client);
+		else {
+			client_send_no(client, data);
+			client_destroy(client, data);
+		}
+		break;
+	case SASL_SERVER_REPLY_CONTINUE:
+		t_push();
+		str = t_str_new(256);
+		managesieve_quote_append_string(str, data, TRUE);
+		str_append(str, "\r\n");
+				
+		/* don't check return value here. it gets tricky if we try
+		   to call client_destroy() in here. */
+		(void)o_stream_send(client->output, str_c(str), str_len(str));
+		t_pop();
+
+		managesieve_parser_reset(client->parser);
+
+		i_assert(client->io == NULL);
+        client->io = io_add(client->common.fd, IO_READ,
+                    client_auth_input, client);
+        client_auth_input(client);
+		
+		return;
+	}
+
+	client_unref(client);
+}
+
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args)
+{
+	const char *mech_name, *init_resp = NULL;
+
+	/* one mandatory argument: authentication mechanism name */
+	if (args[0].type != MANAGESIEVE_ARG_STRING)
+		return -1;
+	if (args[1].type != MANAGESIEVE_ARG_EOL) {
+		/* optional SASL initial response */
+		if (args[1].type != MANAGESIEVE_ARG_STRING ||
+		    args[2].type != MANAGESIEVE_ARG_EOL)
+			return -1;
+		init_resp = MANAGESIEVE_ARG_STR(&args[1]);
+	}
+
+	mech_name = MANAGESIEVE_ARG_STR(&args[0]);
+	if (*mech_name == '\0') 
+		return -1;
+
+	/* FIXME: This refuses the ANONYMOUS mechanism. 
+	 *   This can be removed once anonymous login is implemented according to the 
+	 *   draft RFC. - Stephan
+	 */
+	if ( strncasecmp(mech_name, "ANONYMOUS", 9) == 0 ) {
+		client_send_no(client, "ANONYMOUS mechanism is not implemented.");		
+		return 0;
+	}
+
+    client_ref(client);
+    sasl_server_auth_begin(&client->common, MANAGESIEVE_SERVICE_NAME, mech_name,
+                   init_resp, sasl_callback);
+    if (!client->common.authenticating)
+        return 1;
+
+    /* don't handle input until we get the initial auth reply */
+    if (client->io != NULL)
+        io_remove(&client->io);
+    client_set_auth_waiting(client);
+
+	managesieve_parser_reset(client->parser);
+
+	return 0;
+}
+
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client-authenticate.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client-authenticate.h
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client-authenticate.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client-authenticate.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef __CLIENT_AUTHENTICATE_H
+#define __CLIENT_AUTHENTICATE_H
+
+const char *client_authenticate_get_capabilities(bool secured);
+
+int cmd_login(struct managesieve_client *client, struct managesieve_arg *args);
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client.c	2008-02-13 08:01:10.000000000 -0700
@@ -0,0 +1,681 @@
+/* Copyright (c) 2006-2008 Dovecot Sieve authors, see the included AUTHORS file */
+
+#include "common.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "process-title.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "strescape.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+#include "sieve.h"
+
+#include "client.h"
+#include "client-authenticate.h"
+#include "auth-client.h"
+#include "ssl-proxy.h"
+#include "managesieve-proxy.h"
+
+#include <stdlib.h>
+
+/* max. size of one parameter in line, or max reply length in SASL
+   authentication */
+#define MAX_INBUF_SIZE 4096
+
+/* max. size of output buffer. if it gets full, the client is disconnected.
+   SASL authentication gives the largest output. */
+#define MAX_OUTBUF_SIZE 4096
+
+/* maximum length for IMAP command line. */
+#define MAX_MANAGESIEVE_LINE 8192
+
+/* Disconnect client after idling this many milliseconds */
+#define CLIENT_LOGIN_IDLE_TIMEOUT_MSECS (3*60*1000)
+
+/* Disconnect client when it sends too many bad commands */
+#define CLIENT_MAX_BAD_COMMANDS 10
+
+/* When max. number of simultaneous connections is reached, few of the
+   oldest connections are disconnected. Since we have to go through all of the
+   clients, it's faster if we disconnect multiple clients. */
+#define CLIENT_DESTROY_OLDEST_COUNT 16
+
+/* If we've been waiting auth server to respond for over this many milliseconds,
+   send a "waiting" message. */
+#define AUTH_WAITING_TIMEOUT_MSECS (30*1000)
+
+#if CLIENT_LOGIN_IDLE_TIMEOUT_MSECS >= AUTH_REQUEST_TIMEOUT*1000
+#  error client idle timeout must be smaller than authentication timeout
+#endif
+
+const char *login_protocol = "MANAGESIEVE";
+const char *capability_string = CAPABILITY_STRING;
+
+const char *managesieve_implementation_string;
+
+static void client_set_title(struct managesieve_client *client)
+{
+	const char *addr;
+
+	if (!verbose_proctitle || !process_per_connection)
+		return;
+
+	addr = net_ip2addr(&client->common.ip);
+	if (addr == NULL)
+		addr = "??";
+
+	process_title_set(t_strdup_printf(client->common.tls ?
+					  "[%s TLS]" : "[%s]", addr));
+}
+
+static void client_open_streams(struct managesieve_client *client, int fd)
+{
+	client->input = i_stream_create_fd(fd, MAX_INBUF_SIZE, FALSE);
+	client->output = o_stream_create_fd(fd, MAX_OUTBUF_SIZE, FALSE);
+	client->parser = managesieve_parser_create(client->input, client->output,
+					    MAX_MANAGESIEVE_LINE);
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+bool client_skip_line(struct managesieve_client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			i_stream_skip(client->input, i+1);
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static void client_send_capabilities(struct managesieve_client *client)
+{
+	const char *auths;
+	const char *sievecap, *sieveimpl;
+
+	sievecap = sieve_get_capabilities();
+	if (sievecap == NULL)
+	  	sievecap = "";
+
+	t_push();
+	sievecap = t_strconcat("\"SIEVE\" \"", sievecap, "\"", NULL);
+	sieveimpl = t_strconcat("\"IMPLEMENTATION\" \"",
+    managesieve_implementation_string, "\"", NULL);
+
+	auths = client_authenticate_get_capabilities(client->common.secured);
+
+	/* We assume no MANAGESIEVE-string incompatible values are produced here */
+	client_send_line(client, sieveimpl);
+	client_send_line(client, t_strconcat("\"SASL\" \"", auths, "\"", NULL) );
+	client_send_line(client, sievecap);
+
+	if (ssl_initialized && !client->common.tls)
+		client_send_line(client, "\"STARTTLS\"" );
+
+	t_pop();
+}
+
+static int cmd_capability(struct managesieve_client *client)
+{
+	client_send_capabilities(client);
+	client_send_ok(client, "Capability completed.");
+	return TRUE;
+}
+
+static void client_start_tls(struct managesieve_client *client)
+{
+	int fd_ssl;
+
+    client_ref(client);
+    connection_queue_add(1);
+    if (!client_unref(client) || client->destroyed)
+        return;
+
+	fd_ssl = ssl_proxy_new(client->common.fd, &client->common.ip,
+			       &client->common.proxy);
+	if (fd_ssl == -1) {
+		client_send_bye(client, "TLS initialization failed.");
+		client_destroy(client, "Disconnected: TLS initialization failed.");
+		return;
+	}
+
+	client->common.tls = TRUE;
+	client->common.secured = TRUE;
+	client_set_title(client);
+
+	client->common.fd = fd_ssl;
+	i_stream_unref(&client->input);
+	o_stream_unref(&client->output);
+	managesieve_parser_destroy(&client->parser);
+
+	/* CRLF is lost from buffer when streams are reopened. */
+	client->skip_line = FALSE;
+
+	client_open_streams(client, fd_ssl);
+	client->io = io_add(client->common.fd, IO_READ, client_input, client);
+}
+
+static int client_output_starttls(void *context)
+{
+	struct managesieve_client *client = context;
+	int ret;
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, "Disconnected");
+		return 1;
+	}
+
+	if (ret > 0) {
+		o_stream_unset_flush_callback(client->output);
+		client_start_tls(client);
+	}
+	return 1;
+}
+
+static int cmd_starttls(struct managesieve_client *client)
+{
+	if (client->common.tls) {
+		client_send_no(client, "TLS is already active.");
+		return 1;
+	}
+
+	if (!ssl_initialized) {
+		client_send_no(client, "TLS support isn't enabled.");
+		return 1;
+	}
+
+	/* remove input handler, SSL proxy gives us a new fd. we also have to
+	   remove it in case we have to wait for buffer to be flushed */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	client_send_ok(client, "Begin TLS negotiation now.");
+
+	/* uncork the old fd */
+	o_stream_uncork(client->output);
+
+	if (o_stream_flush(client->output) <= 0) {
+		/* the buffer has to be flushed */
+		o_stream_set_flush_pending(client->output, TRUE);
+		o_stream_set_flush_callback(client->output,
+					    client_output_starttls, client);
+	} else {
+		client_start_tls(client);
+	}
+
+    /* Cork the stream to send the capability data as a single tcp frame
+     *   Some naive clients break if we don't.
+     */
+    o_stream_cork(client->output);
+
+	client_send_capabilities(client);
+	client_send_ok(client, "TLS negotiation successful.");
+
+    o_stream_uncork(client->output);
+
+	return 1;
+}
+
+static int cmd_logout(struct managesieve_client *client)
+{
+	client_send_ok(client, "Logout completed.");
+	if (client->common.auth_tried_disabled_plaintext) {
+		client_destroy(client, "Aborted login "
+			"(tried to use disabled plaintext authentication)");
+	} else {
+		client_destroy(client, t_strdup_printf(
+			"Aborted login (%u authentication attempts)",
+			client->common.auth_attempts));
+	}
+	return 1;
+}
+
+static int client_command_execute(struct managesieve_client *client, const char *cmd,
+				  struct managesieve_arg *args)
+{
+	cmd = t_str_ucase(cmd);
+	if (strcmp(cmd, "AUTHENTICATE") == 0)
+		return cmd_authenticate(client, args);
+	if (strcmp(cmd, "CAPABILITY") == 0)
+		return cmd_capability(client);
+	if (strcmp(cmd, "STARTTLS") == 0)
+		return cmd_starttls(client);
+	if (strcmp(cmd, "LOGOUT") == 0)
+		return cmd_logout(client);
+
+	return -1;
+}
+
+static bool client_handle_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	int ret;
+	bool fatal;
+
+	i_assert(!client->common.authenticating);
+
+	if (client->cmd_finished) {
+		/* clear the previous command from memory. don't do this
+		   immediately after handling command since we need the
+		   cmd_tag to stay some time after authentication commands. */
+		client->cmd_name = NULL;
+		managesieve_parser_reset(client->parser);
+
+		/* remove \r\n */
+		if (client->skip_line) {
+			if (!client_skip_line(client))
+				return FALSE;
+			client->skip_line = FALSE;
+		}
+
+		client->cmd_finished = FALSE;
+	}
+
+	if (client->cmd_name == NULL) {
+		client->cmd_name = managesieve_parser_read_word(client->parser);
+		if (client->cmd_name == NULL)
+			return FALSE; /* need more data */
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_send_bye(client, msg);
+			client_destroy(client, t_strconcat("Disconnected: ",
+				msg, NULL));
+			return FALSE;
+		}
+
+		client_send_no(client, msg);
+		client->cmd_finished = TRUE;
+		client->skip_line = TRUE;
+		return TRUE;
+	case -2:
+		/* not enough data */
+		return FALSE;
+	}
+	client->skip_line = TRUE;
+
+	ret = client_command_execute(client, client->cmd_name, args);
+
+	client->cmd_finished = TRUE;
+	if (ret < 0) {
+		if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+			client_send_bye(client,	
+				"Too many invalid MANAGESIEVE commands.");
+			client_destroy(client, "Disconnected: "
+				"Too many invalid commands.");
+			return FALSE;
+		}  
+		client_send_no(client,
+			"Error in MANAGESIEVE command received by server.");
+	}
+
+	return ret != 0;
+}
+
+bool client_read(struct managesieve_client *client)
+{
+	switch (i_stream_read(client->input)) {
+	case -2:
+		/* buffer full */
+		client_send_bye(client, "Input buffer full, aborting");
+		client_destroy(client, "Disconnected: Input buffer full");
+		return FALSE;
+	case -1:
+		/* disconnected */
+		client_destroy(client, "Disconnected");
+		return FALSE;
+	default:
+		/* something was read */
+		return TRUE;
+	}
+}
+
+void client_input(struct managesieve_client *client)
+{
+	timeout_reset(client->to_idle_disconnect);
+
+	if (!client_read(client))
+		return;
+
+	client_ref(client);
+
+	if (!auth_client_is_connected(auth_client)) {
+		/* we're not yet connected to auth process -
+		   don't allow any commands */
+		/* FIXME: Can't do this with managesieve. Any other ways?
+		client_send_ok(client, AUTH_WAITING_MSG);
+		*/
+        if (client->to_auth_waiting != NULL)
+            timeout_remove(&client->to_auth_waiting);
+
+		client->input_blocked = TRUE;
+	} else {
+		o_stream_cork(client->output);
+		while (client_handle_input(client)) ;
+		o_stream_uncork(client->output);
+	}
+
+	client_unref(client);
+}
+
+void client_destroy_oldest(void)
+{
+	struct client *client;
+	struct managesieve_client *destroy_buf[CLIENT_DESTROY_OLDEST_COUNT];
+	int i, destroy_count;
+
+	/* find the oldest clients and put them to destroy-buffer */
+	memset(destroy_buf, 0, sizeof(destroy_buf));
+
+ 	destroy_count = max_connections > CLIENT_DESTROY_OLDEST_COUNT*2 ?
+        CLIENT_DESTROY_OLDEST_COUNT : I_MIN(max_connections/2, 1);
+	for (client = clients; client != NULL; client = client->next) {
+        struct managesieve_client *msieve_client = 
+			(struct managesieve_client *) client;
+
+        for (i = 0; i < destroy_count; i++) {
+            if (destroy_buf[i] == NULL ||
+                destroy_buf[i]->created > msieve_client->created) {
+                /* @UNSAFE */
+                memmove(destroy_buf+i+1, destroy_buf+i,
+                    sizeof(destroy_buf) -
+                    (i+1) * sizeof(struct managesieve_client *));
+                destroy_buf[i] = msieve_client;
+                break;
+            }
+        }
+    }
+
+    /* then kill them */
+    for (i = 0; i < destroy_count; i++) {
+        if (destroy_buf[i] == NULL)
+            break;
+
+        client_destroy(destroy_buf[i],
+                   "Disconnected: Connection queue full");
+    }
+}
+
+static void client_send_greeting(struct managesieve_client *client)
+{
+	/* Cork the stream to send the capability data as a single tcp frame
+     *   Some naive clients break if we don't.
+     */
+    o_stream_cork(client->output);
+
+  	/* Send initial capabilities */   
+  	client_send_capabilities(client);
+	client_send_ok(client, greeting);
+	client->greeting_sent = TRUE;
+
+    o_stream_uncork(client->output);
+}
+
+static void client_idle_disconnect_timeout(struct managesieve_client *client)
+{
+	/* FIXME: is this protocol compliant? */
+	client_send_bye(client, "Disconnected for inactivity.");
+	client_destroy(client, "Disconnected: Inactivity");
+}
+
+static void client_auth_waiting_timeout(struct managesieve_client *client)
+{
+	/*client_send_line(client, AUTH_WAITING_MSG);*/
+	timeout_remove(&client->to_auth_waiting);
+}
+
+void client_set_auth_waiting(struct managesieve_client *client)
+{
+	i_assert(client->to_auth_waiting == NULL);
+	client->to_auth_waiting =
+		timeout_add(AUTH_WAITING_TIMEOUT_MSECS,
+			client_auth_waiting_timeout, client);
+}
+
+struct client *client_create(int fd, bool ssl, const struct ip_addr *local_ip,
+			     const struct ip_addr *ip)
+{
+	struct managesieve_client *client;
+
+	i_assert(fd != -1);
+
+	connection_queue_add(1);
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd, TRUE);
+
+	client = i_new(struct managesieve_client, 1);
+	client->created = ioloop_time;
+	client->refcount = 1;
+	client->common.tls = ssl;
+	client->common.secured = ssl || net_ip_compare(ip, local_ip);
+
+	client->common.local_ip = *local_ip;
+	client->common.ip = *ip;
+	client->common.fd = fd;
+
+	client_open_streams(client, fd);
+	client->io = io_add(fd, IO_READ, client_input, client);
+
+	client_link(&client->common);
+
+	main_ref();
+
+	if (!greeting_capability || auth_client_is_connected(auth_client))
+		client_send_greeting(client);
+	else
+		client_set_auth_waiting(client);
+	client_set_title(client);
+
+	client->to_idle_disconnect =
+		timeout_add(CLIENT_LOGIN_IDLE_TIMEOUT_MSECS,
+			client_idle_disconnect_timeout, client);
+	return &client->common;
+}
+
+void client_destroy(struct managesieve_client *client, const char *reason)
+{
+	if (client->destroyed)
+		return;
+	client->destroyed = TRUE;
+
+	if (reason != NULL)
+		client_syslog(&client->common, reason);
+
+	client_unlink(&client->common);
+
+	if (client->input != NULL)
+		i_stream_close(client->input);
+	if (client->output != NULL)
+		o_stream_close(client->output);
+
+	if (client->common.master_tag != 0)
+        master_request_abort(&client->common);
+
+    if (client->common.auth_request != NULL) {
+        i_assert(client->common.authenticating);
+        sasl_server_auth_client_error(&client->common, NULL);
+    } else {
+        i_assert(!client->common.authenticating);
+    }
+
+	if (client->io != NULL)
+		io_remove(&client->io);
+	if (client->to_idle_disconnect != NULL)
+		timeout_remove(&client->to_idle_disconnect);
+	if (client->to_auth_waiting != NULL)
+		timeout_remove(&client->to_auth_waiting);
+
+	if (client->common.fd != -1) {
+		net_disconnect(client->common.fd);
+		client->common.fd = -1;
+	}
+
+	if (client->proxy_password != NULL) {
+        safe_memset(client->proxy_password, 0,
+                strlen(client->proxy_password));
+        i_free(client->proxy_password);
+        client->proxy_password = NULL;
+    }
+
+    i_free(client->proxy_user);
+    client->proxy_user = NULL;
+
+    if (client->proxy != NULL) {
+        login_proxy_free(client->proxy);
+        client->proxy = NULL;
+    }
+
+    if (client->common.proxy != NULL) {
+        ssl_proxy_free(client->common.proxy);
+        client->common.proxy = NULL;
+    }
+
+    client_unref(client);
+
+    main_listen_start();
+    main_unref();
+}
+
+void client_destroy_internal_failure(struct managesieve_client *client)
+{
+	client_send_byeresp(client, "TRYLATER", "Internal login failure. "
+		"Refer to server log for more information.");
+	client_destroy(client, "Internal login failure");
+}
+
+void client_ref(struct managesieve_client *client)
+{
+	client->refcount++;
+}
+
+bool client_unref(struct managesieve_client *client)
+{
+	i_assert(client->refcount > 0);
+	if (--client->refcount > 0)
+		return TRUE;
+
+	i_assert(client->destroyed);
+
+	managesieve_parser_destroy(&client->parser);
+
+	if (client->input != NULL)
+		i_stream_unref(&client->input);
+	if (client->output != NULL)
+		o_stream_unref(&client->output);
+
+	i_free(client->common.virtual_user);
+	i_free(client->common.auth_mech_name);
+	i_free(client);
+
+	return FALSE;
+}
+
+void client_send_line(struct managesieve_client *client, const char *line)
+{
+	struct const_iovec iov[2];
+	ssize_t ret;
+
+	iov[0].iov_base = line;
+	iov[0].iov_len = strlen(line);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	ret = o_stream_sendv(client->output, iov, 2);
+	if (ret < 0 || (size_t)ret != iov[0].iov_len + iov[1].iov_len) {
+		/* either disconnection or buffer full. in either case we
+		   want this connection destroyed. however destroying it here
+		   might break things if client is still tried to be accessed
+		   without being referenced.. */
+		i_stream_close(client->input);
+	}
+}
+
+void _client_send_response(struct managesieve_client *client, 
+	const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL )
+	{
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL )	
+	{
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void clients_notify_auth_connected(void)
+{
+	struct client *client;
+
+	for (client = clients; client != NULL; client = client->next) {
+        struct managesieve_client *msieve_client = 
+			(struct managesieve_client *)client;
+
+		if (msieve_client->to_auth_waiting != NULL)
+			timeout_remove(&msieve_client->to_auth_waiting);
+		if (!msieve_client->greeting_sent)
+			client_send_greeting(msieve_client);
+		if (msieve_client->input_blocked) {
+			msieve_client->input_blocked = FALSE;
+			client_input(msieve_client);
+		}
+	}
+}
+
+void clients_destroy_all(void)
+{
+	struct client *client;
+
+	for (client = clients; client != NULL; client = client->next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *)client;
+
+		client_destroy(msieve_client, "Disconnected: Shutting down");
+	}
+}
+
+void clients_init(void)
+{
+	const char *str;
+
+	/* Specific MANAGESIEVE settings */
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+    	str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	sieve_init("");
+}
+
+void clients_deinit(void)
+{
+	sieve_deinit();
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client.h
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/client.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/client.h	2008-01-06 10:17:22.000000000 -0700
@@ -0,0 +1,72 @@
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "network.h"
+#include "master.h"
+#include "client-common.h"
+
+/* FIXME: Duplicate, also defined in src/managesieve */
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING PACKAGE
+
+/* maximum length for MANAGESIEVE command line. */
+#define MAX_MANAGESIEVE_LINE 8192
+
+struct managesieve_client {
+	struct client common;
+
+	time_t created;
+	int refcount;
+
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+	struct managesieve_parser *parser;
+	struct timeout *to_idle_disconnect, *to_auth_waiting;
+
+	struct login_proxy *proxy;
+	char *proxy_user, *proxy_password;
+
+	unsigned int bad_counter;
+
+	const char *cmd_name;
+
+	unsigned int cmd_finished:1;
+ 	unsigned int proxy_login_sent:1;
+	unsigned int skip_line:1;
+	unsigned int input_blocked:1;
+	unsigned int destroyed:1;
+	unsigned int greeting_sent:1;
+	unsigned int proxy_greeting_recvd:1;  
+};
+
+void client_destroy(struct managesieve_client *client, const char *reason);
+void client_destroy_internal_failure(struct managesieve_client *client);
+
+void client_send_line(struct managesieve_client *client, const char *line);
+
+bool client_read(struct managesieve_client *client);
+bool client_skip_line(struct managesieve_client *client);
+void client_input(struct managesieve_client *client);
+
+void client_ref(struct managesieve_client *client);
+bool client_unref(struct managesieve_client *client);
+
+void client_set_auth_waiting(struct managesieve_client *client);
+
+void _client_send_response(struct managesieve_client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+	_client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  _client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  _client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  _client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  _client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(client, resp_code, msg) \
+  _client_send_response(client, "BYE", resp_code, msg)
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/Makefile.am dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/Makefile.am
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/Makefile.am	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,38 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve-login
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/login-common \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_login_LDADD = \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	../lib-managesieve/libmanagesieve.a \
+	../lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a \
+	$(SSL_LIBS)
+
+managesieve_login_SOURCES = \
+	client.c \
+	client-authenticate.c \
+	managesieve-proxy.c
+
+noinst_HEADERS = \
+	client.h \
+	client-authenticate.h \
+	managesieve-proxy.h
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/Makefile.in dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/Makefile.in
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/Makefile.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/Makefile.in	2008-05-04 08:28:52.000000000 -0600
@@ -0,0 +1,520 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+pkglibexec_PROGRAMS = managesieve-login$(EXEEXT)
+subdir = src/managesieve-login
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(pkglibexecdir)"
+pkglibexecPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(pkglibexec_PROGRAMS)
+am_managesieve_login_OBJECTS = client.$(OBJEXT) \
+	client-authenticate.$(OBJEXT) managesieve-proxy.$(OBJEXT)
+managesieve_login_OBJECTS = $(am_managesieve_login_OBJECTS)
+am__DEPENDENCIES_1 =
+managesieve_login_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	../lib-managesieve/libmanagesieve.a \
+	../lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a $(am__DEPENDENCIES_1)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(managesieve_login_SOURCES)
+DIST_SOURCES = $(managesieve_login_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+HAVE_DOVECOT_LIBS_FALSE = @HAVE_DOVECOT_LIBS_FALSE@
+HAVE_DOVECOT_LIBS_TRUE = @HAVE_DOVECOT_LIBS_TRUE@
+HAVE_OLD_SIEVE_PLUGIN_FALSE = @HAVE_OLD_SIEVE_PLUGIN_FALSE@
+HAVE_OLD_SIEVE_PLUGIN_TRUE = @HAVE_OLD_SIEVE_PLUGIN_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+MODULE_LIBS = @MODULE_LIBS@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+pkglibexecdir = $(libexecdir)/dovecot
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/login-common \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_login_LDADD = \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	../lib-managesieve/libmanagesieve.a \
+	../lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a \
+	$(SSL_LIBS)
+
+managesieve_login_SOURCES = \
+	client.c \
+	client-authenticate.c \
+	managesieve-proxy.c
+
+noinst_HEADERS = \
+	client.h \
+	client-authenticate.h \
+	managesieve-proxy.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/managesieve-login/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/managesieve-login/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pkglibexecPROGRAMS: $(pkglibexec_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkglibexecdir)" || $(mkdir_p) "$(DESTDIR)$(pkglibexecdir)"
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(pkglibexecPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) --mode=install $(pkglibexecPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(pkglibexecdir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-pkglibexecPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pkglibexecdir)/$$f"; \
+	done
+
+clean-pkglibexecPROGRAMS:
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+managesieve-login$(EXEEXT): $(managesieve_login_OBJECTS) $(managesieve_login_DEPENDENCIES) 
+	@rm -f managesieve-login$(EXEEXT)
+	$(LINK) $(managesieve_login_LDFLAGS) $(managesieve_login_OBJECTS) $(managesieve_login_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client-authenticate.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-proxy.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(pkglibexecdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pkglibexecPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-pkglibexecPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-pkglibexecPROGRAMS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pkglibexecPROGRAMS ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-pkglibexecPROGRAMS install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-pkglibexecPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c	2008-02-13 08:05:11.000000000 -0700
@@ -0,0 +1,296 @@
+/* Copyright (C) 2004 Timo Sirainen */
+
+#include <string.h>
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "safe-memset.h"
+#include "buffer.h"
+#include "base64.h"
+#include "client.h"
+#include "managesieve-quote.h"
+#include "managesieve-proxy.h"
+#include "managesieve-parser.h"
+
+static int proxy_input_line(struct managesieve_client *client,
+			    struct ostream *output, const char *line)
+{
+	string_t *str;
+	const char *msg;
+
+	i_assert(!client->destroyed);
+
+	if (!client->proxy_login_sent) {
+		string_t *plain_login, *base64;
+		struct istream *input;
+		struct managesieve_parser *parser;
+ 		struct managesieve_arg *args;
+		int ret;
+		bool fatal = FALSE, greeting_recvd = FALSE;
+
+		/* Server will send greeting which is actually a capability 
+		 * response. Output from a faulty server should not be accepted,
+		 * so the response is parsed and verified.
+		 */
+
+		/* Build an input stream for the managesieve parser 
+		 *  FIXME: It would be nice if the line-wise parsing could be
+		 *    substituded by something similar to the command line interpreter.
+		 *    However, the current login_proxy structure does not make streams
+		 *    known until inside proxy_input handler.
+		 */
+		line = t_strconcat(line, "\r\n", NULL);
+		input = i_stream_create_from_data(line, strlen(line));
+		parser = managesieve_parser_create(input, NULL, MAX_MANAGESIEVE_LINE);
+		managesieve_parser_reset(parser);
+
+	    /* Parse input 
+		 *  FIXME: Theoretically the OK response could include a 
+		 *   response code which could be rejected by the parser. 
+		 */ 
+		(void)i_stream_read(input);
+		ret = managesieve_parser_read_args(parser, 2, 0, &args);
+		
+		if ( ret >= 1 ) {
+			if ( args[0].type == MANAGESIEVE_ARG_ATOM &&
+        		strncasecmp(MANAGESIEVE_ARG_STR(&(args[0])), "OK", 2) == 0 ) {
+
+				/* Received OK response; greeting is finished */
+				greeting_recvd = TRUE;
+
+      		} else if ( args[0].type == MANAGESIEVE_ARG_STRING ) {
+        		if ( strncasecmp(MANAGESIEVE_ARG_STR(&(args[0])), "SASL", 4) == 0 ) {
+					/* Check whether the server supports the SASL mechanism 
+		    		 * we are going to use (currently only PLAIN supported). 
+					 */
+					if ( ret == 2 && args[1].type == MANAGESIEVE_ARG_STRING ) {
+						char *p = MANAGESIEVE_ARG_STR(&(args[1]));
+						int mech_found = FALSE;
+								
+						while ( p != NULL ) {
+							if ( strncasecmp(p, "PLAIN", 5) == 0 ) {
+								mech_found = TRUE;
+								break;
+              				}
+
+							p = strchr(p, ' ');
+							if ( p != NULL ) p++;
+						}	 
+
+						if ( !mech_found ) {
+							client_syslog(&client->common, "proxy: "
+			          			"Server does not support required PLAIN SASL mechanism.");
+
+							fatal = TRUE;
+						} 	
+					}
+				} 	
+			} else {
+				/* Do not accept faulty server */
+        		client_syslog(&client->common, t_strdup_printf("proxy: "
+          			"Remote returned with invalid capability/greeting line: %s",
+          			str_sanitize(line,160)));
+
+				fatal = TRUE;
+			}
+
+    	} else if ( ret == -2 ) {
+			/* Parser needs more data (not possible on mem stream) */
+			i_unreached();
+
+    	} else if ( ret < 0 ) {
+			const char *error_str = managesieve_parser_get_error(parser, &fatal);
+			error_str = (error_str != NULL ? error_str : "unknown (bug)" );
+	
+			/* Do not accept faulty server */
+			client_syslog(&client->common, t_strdup_printf("proxy: "
+				"Protocol parse error(%d) in capability/greeting line: %s (line='%s')",
+				ret, error_str, line));
+	
+			fatal = TRUE;
+		}
+
+		/* Cleanup parser */
+    	managesieve_parser_destroy(&parser);
+	    i_stream_destroy(&input);
+
+		/* Time to exit if greeting was not accepted */
+		if ( fatal ) {			
+			client_destroy_internal_failure(client);
+	
+			return -1;
+		}
+
+		/* Wait until greeting is received completely */
+		if ( !greeting_recvd ) return 0;
+
+		/* Send AUTHENTICATE "PLAIN" command 
+    	 *  FIXME: Currently there seems to be no SASL client implementation,
+		 *    so only implement the trivial PLAIN method 
+		 *    - Stephan
+	     */
+		t_push();
+	
+		/*   Base64-encode the credentials 
+		 * 	   [authorization ID \0 authentication ID \0 pass]
+	     */
+		plain_login = buffer_create_dynamic(pool_datastack_create(), 64);
+		buffer_append_c(plain_login, '\0');
+		buffer_append(plain_login, client->proxy_user, strlen(client->proxy_user));
+	  	buffer_append_c(plain_login, '\0');
+		buffer_append(plain_login, client->proxy_password, strlen(client->proxy_password));
+
+		base64 = buffer_create_dynamic(pool_datastack_create(),
+			MAX_BASE64_ENCODED_SIZE(plain_login->used));
+		base64_encode(plain_login->data, plain_login->used, base64);
+
+		/*   Send command */
+		str = t_str_new(128);
+		str_append(str, "AUTHENTICATE \"PLAIN\" ");
+		managesieve_quote_append_string(str, str_c(base64),  FALSE);
+		str_append(str, "\r\n");
+		(void)o_stream_send(output, str_data(str), str_len(str));
+		
+		/*   Cleanup */
+		t_pop();
+
+		/* Cleanup sensitive data */
+		safe_memset(client->proxy_password, 0,
+			   strlen(client->proxy_password));
+		i_free(client->proxy_password);
+		client->proxy_password = NULL;
+		client->proxy_login_sent = TRUE;
+
+		return 0;
+
+	} else { 
+		if (strncasecmp(line, "OK ", 3) == 0) {
+			/* Login successful. Send this line to client. */
+			o_stream_cork(client->output);
+			(void)o_stream_send_str(client->output, line);
+			(void)o_stream_send(client->output, "\r\n", 2);
+			o_stream_uncork(client->output);
+
+			msg = t_strdup_printf("proxy(%s): started proxying to %s:%u",
+				      client->common.virtual_user,
+				      login_proxy_get_host(client->proxy),
+				      login_proxy_get_port(client->proxy));
+
+			(void)client_skip_line(client);
+			login_proxy_detach(client->proxy, client->input,
+				   client->output);
+
+			client->proxy = NULL;
+			client->input = NULL;
+			client->output = NULL;
+			client->common.fd = -1;
+			client_destroy(client, msg);
+
+		} else {
+			/* Login failed. Send our own failure reply so client can't
+		  	 * figure out if user exists or not just by looking at the
+			 * reply string.
+			 */
+			client_send_no(client, AUTH_FAILED_MSG);
+
+			/* allow client input again */
+			i_assert(client->io == NULL);
+			client->io = io_add(client->common.fd, IO_READ,
+				    client_input, client);
+
+			login_proxy_free(client->proxy);
+			client->proxy = NULL;
+
+			i_free(client->proxy_user);
+			client->proxy_user = NULL;
+		}
+
+		return -1;
+	}
+
+	i_unreached();
+	return -1;
+}
+
+static void proxy_input(struct istream *input, struct ostream *output,
+			void *context)
+{
+	struct managesieve_client *client = context;
+	const char *line;
+
+	if (input == NULL) {
+		if (client->io != NULL) {
+			/* remote authentication failed, we're just
+			   freeing the proxy */
+			return;
+		}
+
+		if (client->destroyed) {
+			/* we came here from client_destroy() */
+			return;
+		}
+
+		/* failed for some reason, probably server disconnected */
+		client_send_byeresp(client, "TRYLATER", "Temporary login failure.");
+		client_destroy(client, NULL);
+		return;
+	}
+
+	i_assert(!client->destroyed);
+
+	switch (i_stream_read(input)) {
+	case -2:
+		/* buffer full */
+		client_syslog(&client->common, "proxy: Remote input buffer full");
+		client_destroy_internal_failure(client);
+		return;
+	case -1:
+		/* disconnected */
+		client_destroy(client, "Proxy: Remote disconnected");
+		return;
+	}
+
+	while ((line = i_stream_next_line(input)) != NULL) {
+		if (proxy_input_line(client, output, line) < 0)
+			break;
+	}
+}
+
+int managesieve_proxy_new(struct managesieve_client *client, const char *host,
+		   unsigned int port, const char *user, const char *password)
+{
+	i_assert(user != NULL);
+	i_assert(!client->destroyed);
+
+	if (password == NULL) {
+		client_syslog(&client->common, "proxy: password not given");
+		return -1;
+	}
+
+	i_assert(client->refcount > 1);
+	connection_queue_add(1);
+
+	if (client->destroyed) {
+		/* connection_queue_add() decided that we were the oldest
+		   connection and killed us. */
+		return -1;
+	}
+
+	client->proxy = login_proxy_new(&client->common, host, port,
+					proxy_input, client);
+	if (client->proxy == NULL)
+		return -1;
+
+	client->proxy_login_sent = FALSE;
+	client->proxy_user = i_strdup(user);
+	client->proxy_password = i_strdup(password);
+
+	/* disable input until authentication is finished */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	return 0;
+}
diff -urN dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h
--- dovecot-1.1.1/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h	2008-01-04 06:33:43.000000000 -0700
@@ -0,0 +1,9 @@
+#ifndef __MANAGESIEVE_PROXY_H
+#define __MANAGESIEVE_PROXY_H
+
+#include "login-proxy.h"
+
+int managesieve_proxy_new(struct managesieve_client *client, const char *host,
+		   unsigned int port, const char *user, const char *password);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-managesieve/stamp.h.in dovecot-1.1.1-managesieve/dovecot-managesieve/stamp.h.in
--- dovecot-1.1.1/dovecot-managesieve/stamp.h.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/stamp.h.in	2008-06-23 23:18:23.000000000 -0600
@@ -0,0 +1 @@
+ 
\ No newline at end of file
diff -urN dovecot-1.1.1/dovecot-managesieve/TODO dovecot-1.1.1-managesieve/dovecot-managesieve/TODO
--- dovecot-1.1.1/dovecot-managesieve/TODO	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-managesieve/dovecot-managesieve/TODO	2008-02-13 06:06:51.000000000 -0700
@@ -0,0 +1,20 @@
+TODO
+------------
+
+* Enforce protocol syntax better with some of the commands. Some 
+  commands still allow spurious extra arguments
+  --> Full protocol syntax conformance review. 
+* Implement proper support for anonymous login.
+* Implement listing of NOTIFY capability as specified in the latest versions
+  of the MANAGESIEVE draft.
+* Implement the HAVESPACE command properly. Currently it always says ok.
+  Maybe this should be linked to the mail quota system that is currently 
+  developed. 
+* Create proper process interface to dovecot for generic non-mail protocols 
+  (Timo).
+* Resolve exessive code duplication
+* Make the sieve storage a base class with (possibly) various 
+  implementations, just like mail-storage. Currently not very useful. 
+
+* Thorough testing...
+
