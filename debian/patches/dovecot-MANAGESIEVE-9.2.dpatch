#! /bin/sh /usr/share/dpatch/dpatch-run
## dovecot-MANAGESIEVE-9.2.dpatch
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: MANAGESIEVE patch v9.1
## DP: Origin: http://sinas.rename-it.nl/~sirius/
## DP: Author: Marco Nenciarini <mnencia@debian.org>

@DPATCH@

Updated v9.2 patch to dovecot-1.0.12

diff -r 923786016963 README.managesieve
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/README.managesieve	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,326 @@
+
+Dovecot-MANAGESIEVE patch v9.2 for dovecot-1.0
+
+Compile
+-------
+
+After applying this patch the usual ./configure, make, make install sequence 
+is not enough. First the automake/autoconf structure needs to be rebuilt to 
+include the managesieve sources in the compilation process. 
+
+When you downloaded using Mercurial you have script called autogen.sh in your
+source tree. And you should proceed as specified on:
+
+http://wiki.dovecot.org/CompilingSource
+
+Otherwise execute:
+
+aclocal
+autoreconf -i
+automake 
+
+FIXME: 
+  This needs checking. I usually do this once with every new dovecot 
+  release and after some tinkering it suddenly works. 
+
+  Usually when I continue coding on this project my automake or autoconf is 
+  out of date. This causes very interesting errors. So, make sure you use the 
+  same version as Timo is using, which is usually the latest version in your 
+  distro. 
+
+After this you can continue the usual build process
+(http://wiki.dovecot.org/CompilingSource):
+
+./configure
+make
+sudo make install 
+ 
+Configuration
+-------------
+
+Along with all other binaries dovecot uses, the managesieve and 
+managesieve-login binaries are installed during 'make install'. The only 
+thing you need to do to activate the managesieve support in dovecot is to 
+add 'managesieve' to the 'protocols = ' configuration line in your 
+dovecot.conf. The managesieve daemon will listen on port 2000 by default.
+
+As the implementation of the managesieve daemon is largely based on the 
+original imap implementation, it is very similar in terms of configuration.
+In addition to these config options, the managesieve daemon accepts a few 
+more (see example below).
+
+Scripts are stored at the location specified by the 'sieve_storage' config
+setting. The active sieve script is managed as a symbolic link pointing to 
+the active script in the sieve storage direcotory. The location of this 
+symlink can be specified with the 'sieve' config setting. Make sure this 
+setting is identical to what deliver is using for the sieve plugin. The 
+default location is '~/.dovecot.sieve'.   
+
+Note that the current version of the managesieve daemon places the script 
+storage directory in the mail folder as specified by the mail_location 
+parameter if no sieve_storage is specified. Actually, it is placed in the 
+CONTROL= directory of mail_location if specified, otherwise the 'sieve' 
+directory is placed in the root of the mail location. 
+
+In a mail or mail control directory, scripts are always stored in a ./sieve
+subdirectory. Note that for some mail storage types (e.g. mbox) this script 
+directory is listed as a mail folder, so be sure to put the sieve scripts 
+somewhere else if you can.
+
+A storage location specified by sieve_storage is always generated 
+automatically if it does not exist (as far as the system permits the user to
+do so, no root privileges are used). This is similar to the behavior of the
+mail daemons. Note that when mail_location is used to specify the script
+storage location, only the ./sieve subdirectory is generated automatically. 
+
+Configuration example:
+
+# Refer to dovecot-example.conf for a full example with comments, but don't
+# forget to add managesieve to the protocols setting if you use it. 
+
+# Start imap, pop3 and managesieve services
+protocols = imap pop3 managesieve
+
+protocol managesieve {
+  # Specify an alternative address:port the daemon must listen on 
+  # (default: *:2000)
+  #listen = localhost:2000
+
+  sieve=~/.dovecot.sieve
+  sieve_storage=~/sieve  
+}
+
+Proxying
+--------
+
+Like Dovecot's imapd, the ManageSieve login daemon supports proxying to multiple
+backend servers. Although the underlying code is copied from the imapd sources
+for the most part, it has some ManageSieve-specifics that have not seen much
+testing.
+
+The proxy configuration wike page for POP3 and IMAP should apply to ManageSieve
+as well:
+
+http://wiki.dovecot.org/PasswordDatabase/ExtraFields/Proxy
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about
+this patch. You can post to the list without subscribing, the mail then waits
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
+
+Known Issues
+------------
+
+* Although this ManageSieve server should comply with the draft specification of
+  the ManageSieve protocol, quite a few clients don't. This is particularly true
+  for the TLS support. However, now that Cyrus' Timsieved has changed its
+  behavior towards protocol compliance, all those clients will follow
+  eventually.
+
+  Clients known to have TLS issues:
+    - Thunderbird Sieve add-on (author is working on it)
+    - KMail + kio_sieve
+
+  Unfortunately, there is no reliable way to provide a workaround for this
+  problem. We will have to wait for the authors of these clients to make the
+  proper adjustments.
+* Other client issues:
+  - SquirrelMail/AvelSieve:
+    For some users the avelsieve client stores scripts but fails to retrieve
+    them later. This problem is somehow hard to reproduce at my end. Someone
+    suggested that it might be TLS-related.
+* The current implementation of the daemon does not have quota enforcement as
+  recommended in the specification. So keep in mind that malicious users could  
+  fill your filesystem with loads of spurious scriptfiles.
+* The ANONYMOUS authentication mechanism is currently not supported and
+  explicitly denied.
+
+Design
+------------
+
+The overall design of the daemon is entirely borrowed from the existing
+imap daemon. I have tried to apply the dovecot framework and programming
+paradigms as much as possible. This patch adds the following directories
+to the source directory:
+
+lib-managesieve: parser and quote functions (bound to disappear)
+lib-sievestorage: defines a storage for the sieve scripts (a bit crude)
+managesieve-login: the initial login daemon (derived from src/imap-login)
+managesieve: the actual managesieve daemon (derived form src/imap)
+lib-sieve: yet another copy of the cmu sieve library :/
+
+Currently the managesieve daemon simply plugs in the dovecot-master as any
+other mail protocol (imap,pop3). Since managesieve is not actually a mail
+protocol, this is probably not a good design practice. However, i designed
+this patch to be most uninvasive to the existing sources. I think Timo 
+knows best how to implement this link properly.
+
+The daemon currently implements all existing MANAGESIEVE commands except the 
+HAVESPACE command which always says 'ok'. It also implements the required
+support for UTF-8 strings. 
+
+Changelog
+---------
+
+* v9.2
+- Fixed bug in tmp file generation for sieve-storage: errors other than EEXIST
+  would cause the daemon to sleep() loop indefinitely.
++ Improved log lines to be more recognizable as being generated from
+  managesieve.
++ Added short proxy configuration explanation to the README.managesieve file
++ Added 'Known Issues' section to the README.managesieve file
++ Fixed assert bug in sieve-storage occuring when save is canceled.
+
+* v9.1
++ Updated patch to apply cleanly on dovecot-1.0.10
+
+* V9
++ Definitively fixed the segfault mentioned in V8. It proved to be 
+  very time-constrained and thus hard to reproduce. The error turned out
+  to be related to the input handling of the login daemon during 
+  authentication. 
++ Checked for changes in the imap daemon that weren't propagated to the 
+  managesieve implementation due to code duplication.
++ Fixed a bug in the autodetection of the sieve storage location.
++ Fixed bug in the sieve storage that failed to refresh the symlink if
+  the storage was moved. 
++ Improved error handing in the sieve-storage implementation in various 
+  places. 
++ Fixed the situation in which the active script link is located in the 
+  sieve storage. 
++ Added managesieve configuration to dovecot-example.conf and made the example
+  in this file more concise. 
+
+* V8
++ Fixed a few incompatibilities with 1.0.7 version. For instance, the "Logged
+  in" message is now sent by the -login process and not by the managesieve 
+  daemon anymore. This caused a segfault every once in a while. 
++ Probably fixed the settings problem reported by Steffen Kaiser regarding 
+  login_dir. 'dovecot -n' now reports correct results, but testing will show
+  whether the whole problem is solved.
++ The managesieve daemon now accepts the sieve_storage and sieve configuration
+  settings, so it is now possible to explicitly configure the location of the
+  sieve storage and the active script respectively. The daemon still falls back
+  to using the mail_location (MAIL) settings if nothing else is specified. 
++ The cyrus timsieved does not use the + character in string literals and many
+  clients have adopted to this behaviour. The latest managesieve (08) advises to
+  accept a missing + from clients. The server should not send any + characters 
+  as well. This behavior is now implemented on the server. 
++ Cleaned up sieve-storage.c: split up the sieve_storage_create function in 
+  various sub-functions for obtaining the various paths and directories.
++ Forced manual intervention if rescueing a non-symlink file at the active script
+  path fails somehow. Previously, this presented the admin with a log message 
+  that it had just eaten the script, which is not very nice. 
++ Restructured the README.managesieve file and added some more explanation with
+  regard to the configuration of the daemon.
+
+* V7 
+- Robin Breathe indicated that the regex capability was missing in the server's
+  SIEVE listing. It turns out I forgot to make arrangements for setting 
+  ENABLE_REGEX in the cmu libsieve sources, so the regex extension was not
+  compiled in. I copied the configure.in section regarding ENABLE_REGEX from 
+  dovecot-sieve-1.0.2 and that fixed the problem.
+
+* V6
+- Corked the client output stream while producing the capability greeting and on 
+  other some other occasions as well. Some naive client implementations expect to 
+  receive this as a single tcp frame and it is a good practice to do so anyway.
+  Using this change the Thunderbird sieve extension (v0.1.1) seemed to work. However,
+  scripts larger than a tcp frame still caused failures. All these issues are fixed
+  in the latest version of the sieve add-on (currently v0.1.4). 
+- Cleaned up the new proxy source. My editor made the indentation a complete mess
+  in terms of TABs vs spaces. 
+- Added TRYLATER response codes to BYE and NO messages where appropriate.  
+- Recopied the libsieve library into this patch to incorporate any changes that were
+  made (only sieve-cmu.c still needs to be compared to the old cmu-sieve.c). This 
+  also solves the __attribute__((unused)) GCC dependencies. These were fixed long
+  ago by Timo....  the code duplication beast strikes again. 
+- Removed spurious return value from void function in 
+  src/lib-sieve/sieve-implementation.c as reported by Robin Breathe. GCC fails to
+  report these issues. The function involved is currently not used and serves only
+  as an example on how dovecot could support multiple sieve backends... 
+
+* V5 
+- Applied patch by Uldis Pakuls to fix master_dump_settings bug
+- Added some compilation/installation info to this README
+- Moved README to source tree root as README.managesieve
+- Fixed minor error handling bug in sieve_storage.c with respect to a missing
+  root directory.
+- Now sieve capabilities are reported as they are specified by the implementing
+  library and not in forced upper case. The sieve RFC now explicitly states
+  that sieve capability identifiers are case-sensitive. This broke compatibility
+  with SquirrelMail/Avelsieve. 
+- Disabled ANONYMOUS login entirely until proper support is implemented. V4
+  claimed to do so as well, but in fact it only stopped announcing it.
+- Implemented managesieve-proxy. It is not so much a clean copy of imap-proxy,
+  since the managesieve greeting is much more complex and requires parsing. 
+  Configuration is identical to imap-proxy. This seems to be a little under-
+  documented however (http://wiki.dovecot.org/PasswordDatabase/ExtraFields).  
+
+* V4
+- Added managesieve_implementation_string setting to the managesieve 
+  configuration. This can be used to customize the default "IMPLEMENTATION" 
+  capability response.
+- Denied ANONYMOUS login until proper support is implemented
+- Fixed problem with authenticate command regarding continued responses. In
+  V3 only initial response would work. Problem was caused by rc2 -> rc28 
+  upgrade. One of the clear reasons why code duplication is a very bad idea.
+- Fixed readlink bug as indicated by Timo: return value of readlink can also
+  be -1.
+- Fixed bug in the regular file rescue code, as introduced in the previous 
+  version. Used stat instead of lstat. This caused the symlink to be rescued 
+  subsequently in the next activation, thus still overwriting the initially 
+  rescued script.
+
+* V3
+- Updated source to compile with dovecot 1.0.rc27 
+- Daemon now uses the same location for .dovecot.sieve as dovecot-lda
+  This is typically ~/.dovecot.sieve
+- If .dovecot.sieve is a regular file, it is now moved into the script storage as
+  dovecot.orig.sieve, preventing deletion of (important) active scripts 
+  upon upgrade.
+- Changed error handling to yield a BYE message when the managesieve 
+  daemon exits unexpectedly (upon login) before any commands are entered. 
+  Horde-ingo would wait indefinitely for a response. 
+
+* V2
+- Fixed the bug (missing CRLF) in the authenticate command
+- Modified the sieve storage library making the interface much less crude.
+- The scripts put on the server using the putscript command are now 
+  checked before they are accepted.
+- The reported SIEVE capability is now directly read from the sieve 
+  implementation (in this case cmu), listing much more than "FILEINTO 
+  VACATION".
+- Imported instance of libsieve source into this patch for implementation
+  of script checking and capability listing. THIS NEEDS TO BE CHANGED! 
+- Fixed some minor bugs in the putscript command
+
+TODO
+------------
+
+* Upgrade to dovecot-1.1 branch. 
+* Enforce protocol syntax better with some of the commands. Some 
+  commands still allow spurious extra arguments
+  --> Full protocol syntax conformance review. 
+* Implement proper support for anonymous login.
+* Implement listing of NOTIFY capability as specified in the latest versions
+  of the MANAGESIEVE draft.
+* Implement the HAVESPACE command properly. Currently it always says ok.
+  Maybe this should be linked to the mail quota system that is currently 
+  developed. 
+* Create proper process interface for generic non-mail protocols (Timo).
+* Resolve exessive code duplication
+* Uploaded scripts are syntax checked, but this patch includes another 
+  cmu-sieve source tree to implement this. This needs to be put in some
+  unified location in de dovecot(-sieve) tree. This will probably have to
+  wait until dovecot v2.0
+* Make the sieve storage a base class with (possibly) various 
+  implementations, just like mail-storage. Currently not very useful. 
+
+* Thorough testing...
+
diff -r 923786016963 configure.in
--- a/configure.in	Wed Mar 05 09:12:44 2008 +0200
+++ b/configure.in	Wed Mar 05 10:10:39 2008 +0100
@@ -9,6 +9,8 @@ AC_ISC_POSIX
 AC_ISC_POSIX
 AC_PROG_CC
 AC_PROG_CPP
+AM_PROG_LEX
+AC_PROG_YACC
 AC_HEADER_STDC
 AC_C_INLINE
 AC_PROG_LIBTOOL
@@ -287,6 +289,16 @@ AC_ARG_WITH(pop3d,
 	fi,
 	want_pop3d=yes)
 AM_CONDITIONAL(BUILD_POP3D, test "$want_pop3d" = "yes")
+
+AC_ARG_WITH(managesieve,
+[  --with-managesieve      Build MANAGESIEVE server (default)],
+  if test x$withval = xno; then
+    want_managesieve=no
+  else
+    want_managesieve=yes
+  fi,
+  want_managesieve=yes)
+AM_CONDITIONAL(BUILD_MANAGESIEVE, test "$want_managesieve" = "yes")
 
 AC_ARG_WITH(deliver,
 [  --with-deliver          Build mail delivery agent (default)],
@@ -1812,6 +1824,11 @@ capability="IMAP4rev1 SASL-IR SORT THREA
 capability="IMAP4rev1 SASL-IR SORT THREAD=REFERENCES MULTIAPPEND UNSELECT LITERAL+ IDLE CHILDREN NAMESPACE LOGIN-REFERRALS"
 AC_DEFINE_UNQUOTED(CAPABILITY_STRING, "$capability", IMAP capabilities)
 
+dnl * Regexp library check, from Cyrus IMAP
+AC_SEARCH_LIBS(regcomp, rx regex, [
+  CFLAGS="$CFLAGS -DENABLE_REGEX"
+  AC_CHECK_HEADER(rxposix.h, CFLAGS="$CFLAGS -DHAVE_RX")])
+
 CFLAGS="$CFLAGS $EXTRA_CFLAGS"
 
 AC_CONFIG_HEADERS([config.h])
@@ -1828,8 +1845,13 @@ src/lib-imap/Makefile
 src/lib-imap/Makefile
 src/lib-index/Makefile
 src/lib-mail/Makefile
+src/lib-managesieve/Makefile
 src/lib-ntlm/Makefile
 src/lib-settings/Makefile
+src/lib-sievestorage/Makefile
+src/lib-sieve/Makefile
+src/lib-sieve/cmu/Makefile
+src/lib-sieve/cmu/libsieve/Makefile
 src/lib-storage/Makefile
 src/lib-storage/index/Makefile
 src/lib-storage/index/maildir/Makefile
@@ -1843,6 +1865,8 @@ src/imap/Makefile
 src/imap/Makefile
 src/imap-login/Makefile
 src/login-common/Makefile
+src/managesieve/Makefile
+src/managesieve-login/Makefile
 src/master/Makefile
 src/pop3/Makefile
 src/pop3-login/Makefile
diff -r 923786016963 dovecot-example.conf
--- a/dovecot-example.conf	Wed Mar 05 09:12:44 2008 +0200
+++ b/dovecot-example.conf	Wed Mar 05 10:10:39 2008 +0100
@@ -18,7 +18,7 @@
 # Base directory where to store runtime data.
 #base_dir = /var/run/dovecot/
 
-# Protocols we want to be serving: imap imaps pop3 pop3s
+# Protocols we want to be serving: imap imaps pop3 pop3s managesieve
 # If you only want to use dovecot-auth, you can set this to "none".
 #protocols = imap imaps
 
@@ -28,8 +28,8 @@
 # interfaces depending on the operating system.
 #
 # If you want to specify ports for each service, you will need to configure
-# these settings inside the protocol imap/pop3 { ... } section, so you can
-# specify different ports for IMAP/POP3. For example:
+# these settings inside the protocol imap/pop3/managesieve { ... } section, 
+# so you can specify different ports for IMAP/POP3/MANAGESIEVE. For example:
 #   protocol imap {
 #     listen = *:10143
 #     ssl_listen = *:10943
@@ -37,6 +37,10 @@
 #   }
 #   protocol pop3 {
 #     listen = *:10100
+#     ..
+#   }
+#   protocol managesieve {
+#     listen = *:12000
 #     ..
 #   }
 #listen = *
@@ -646,6 +650,48 @@ protocol pop3 {
   #     missing. This option simply sends it if it's missing.
   # The list is space-separated.
   #pop3_client_workarounds = 
+}
+
+##
+## MANAGESIEVE specific settings
+##
+
+protocol managesieve {
+  # Login executable location.
+  #login_executable = /usr/libexec/dovecot/managesieve-login
+
+  # MANAGESIEVE executable location. See IMAP's mail_executable above for 
+  # examples how this could be changed.
+  #mail_executable = /usr/libexec/dovecot/managesieve
+
+  # Maximum MANAGESIEVE command line length in bytes. This setting is 
+  # directly borrowed from IMAP. But, since long command lines are very
+  # unlikely with MANAGESIEVE, changing this will not be very useful.  
+  #managesieve_max_line_length = 65536
+
+  # Specifies the location of the symlink pointing to the active script in
+  # the sieve storage directory. This must match the SIEVE setting used by
+  # deliver (refer to http://wiki.dovecot.org/LDA/Sieve#location for more
+  # info). Variable substitution with % is recognized.
+  sieve=~/.dovecot.sieve
+
+  # This specifies the path to the directory where the uploaded scripts must
+  # be stored. In terms of '%' variable substitution it is identical to
+  # dovecot's mail_location setting used by the mail protocol daemons.
+  sieve_storage=~/sieve
+
+  # If, for some inobvious reason, the sieve_storage remains unset, the 
+  # managesieve daemon uses the specification of the mail_location to find out 
+  # where to store the sieve files (see explaination in README.managesieve). 
+  # The example below, when uncommented, overrides any global mail_location 
+  # specification and stores all the scripts in '~/mail/sieve' if sieve_storage 
+  # is unset. However, you should always use the sieve_storage setting.
+  # mail_location = mbox:~/mail
+
+  # To fool managesieve clients that are focused on timesieved you can
+  # specify the IMPLEMENTATION capability that the dovecot reports to clients 
+  # (default: dovecot).
+  #managesieve_implementation_string = Cyrus timsieved v2.2.13
 }
 
 ##
diff -r 923786016963 src/Makefile.am
--- a/src/Makefile.am	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/Makefile.am	Wed Mar 05 10:10:39 2008 +0100
@@ -4,6 +4,10 @@ endif
 
 if BUILD_DELIVER
 DELIVER = deliver
+endif
+
+if BUILD_MANAGESIEVE
+MANAGESIEVE = lib-managesieve lib-sievestorage lib-sieve managesieve managesieve-login 
 endif
 
 SUBDIRS = \
@@ -26,5 +30,6 @@ SUBDIRS = \
 	imap \
 	$(POP3D) \
 	$(DELIVER) \
+	$(MANAGESIEVE) \
 	util \
 	plugins
diff -r 923786016963 src/lib-managesieve/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-managesieve/Makefile.am	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,14 @@
+noinst_LIBRARIES = libmanagesieve.a
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib \
+	-I$(top_srcdir)/src/lib-charset \
+	-I$(top_srcdir)/src/lib-mail
+
+libmanagesieve_a_SOURCES = \
+	managesieve-quote.c \
+	managesieve-parser.c 
+
+noinst_HEADERS = \
+	managesieve-quote.h \
+	managesieve-parser.h 
diff -r 923786016963 src/lib-managesieve/managesieve-parser.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-managesieve/managesieve-parser.c	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,672 @@
+#include "lib.h"
+#include "istream.h"
+#include "ostream.h"
+#include "strescape.h"
+#include "managesieve-parser.h"
+
+#define is_linebreak(c) \
+	((c) == '\r' || (c) == '\n')
+
+#define LIST_ALLOC_SIZE 7
+
+enum arg_parse_type {
+	ARG_PARSE_NONE = 0,
+	ARG_PARSE_ATOM,
+	ARG_PARSE_STRING,
+	ARG_PARSE_LITERAL,
+	ARG_PARSE_LITERAL_DATA
+};
+
+struct managesieve_parser {
+	/* permanent */
+	pool_t pool;
+	struct istream *input;
+	struct ostream *output;
+	size_t max_line_size;
+	enum managesieve_parser_flags flags;
+
+	/* reset by managesieve_parser_reset(): */
+	size_t line_size;
+	struct managesieve_arg_list *root_list;
+	struct managesieve_arg_list *cur_list;
+
+	enum arg_parse_type cur_type;
+	size_t cur_pos; /* parser position in input buffer */
+
+	int str_first_escape; /* ARG_PARSE_STRING: index to first '\' */
+	uoff_t literal_size; /* ARG_PARSE_LITERAL: string size */
+
+	const char *error;
+
+	unsigned int literal_skip_crlf:1;
+	unsigned int literal_nonsync:1;
+	unsigned int eol:1;
+	unsigned int fatal_error:1;
+};
+
+/* @UNSAFE */
+#define LIST_REALLOC(parser, old_list, new_size) \
+	p_realloc((parser)->pool, old_list, \
+		  sizeof(struct managesieve_arg_list) + \
+		  (old_list == NULL ? 0 : \
+		   sizeof(struct managesieve_arg_list) * (old_list)->alloc), \
+		  sizeof(struct managesieve_arg_list) * (new_size))
+
+static void managesieve_args_realloc(struct managesieve_parser *parser, size_t size)
+{
+	parser->cur_list = LIST_REALLOC(parser, parser->cur_list, size);
+	parser->cur_list->alloc = size;
+
+  parser->root_list = parser->cur_list;
+}
+
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size)
+{
+	struct managesieve_parser *parser;
+
+	parser = i_new(struct managesieve_parser, 1);
+        parser->pool = pool_alloconly_create("MANAGESIEVE parser", 8192);
+	parser->input = input;
+	parser->output = output;
+	parser->max_line_size = max_line_size;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+	return parser;
+}
+
+void managesieve_parser_destroy(struct managesieve_parser **parser)
+{
+	pool_unref((*parser)->pool);
+	i_free(*parser);
+	*parser = NULL;
+}
+
+void managesieve_parser_reset(struct managesieve_parser *parser)
+{
+	p_clear(parser->pool);
+
+	parser->line_size = 0;
+
+	parser->root_list = NULL;
+	parser->cur_list = NULL;
+
+	parser->cur_type = ARG_PARSE_NONE;
+	parser->cur_pos = 0;
+
+	parser->str_first_escape = 0;
+	parser->literal_size = 0;
+
+	parser->error = NULL;
+
+	parser->literal_skip_crlf = FALSE;
+	parser->eol = FALSE;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+}
+
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal)
+{
+	*fatal = parser->fatal_error;
+	return parser->error;
+}
+
+/* skip over everything parsed so far, plus the following whitespace */
+static int managesieve_parser_skip_to_next(struct managesieve_parser *parser,
+				    const unsigned char **data,
+				    size_t *data_size)
+{
+	size_t i;
+
+	for (i = parser->cur_pos; i < *data_size; i++) {
+		if ((*data)[i] != ' ')
+			break;
+	}
+
+	parser->line_size += i;
+	i_stream_skip(parser->input, i);
+	parser->cur_pos = 0;
+
+	*data += i;
+	*data_size -= i;
+	return *data_size > 0;
+}
+
+static struct managesieve_arg *managesieve_arg_create(struct managesieve_parser *parser)
+{
+	struct managesieve_arg *arg;
+
+	i_assert(parser->cur_list != NULL);
+
+	/* @UNSAFE */
+	if (parser->cur_list->size == parser->cur_list->alloc)
+		managesieve_args_realloc(parser, parser->cur_list->alloc * 2);
+
+	arg = &parser->cur_list->args[parser->cur_list->size];
+	parser->cur_list->size++;
+
+	return arg;
+}
+
+static void managesieve_parser_save_arg(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t size)
+{
+	struct managesieve_arg *arg;
+
+	arg = managesieve_arg_create(parser);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		/* simply save the string */
+		arg->type = MANAGESIEVE_ARG_ATOM;
+		arg->_data.str = p_strndup(parser->pool, data, size);
+		break;
+	case ARG_PARSE_STRING:
+		/* data is quoted and may contain escapes. */
+		i_assert(size > 0);
+
+		arg->type = MANAGESIEVE_ARG_STRING;
+		arg->_data.str = p_strndup(parser->pool, data+1, size-1);
+
+		/* remove the escapes */
+		if (parser->str_first_escape >= 0 &&
+		    (parser->flags & MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE) == 0) {
+			/* -1 because we skipped the '"' prefix */
+			str_unescape(arg->_data.str +
+				     parser->str_first_escape-1);
+		}
+		break;
+	case ARG_PARSE_LITERAL_DATA:
+		if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) != 0) {
+			/* save literal size */
+			arg->type = MANAGESIEVE_ARG_LITERAL_SIZE;
+			arg->_data.literal_size = parser->literal_size;
+		} else if ((parser->flags &
+			    MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE) != 0) {
+			arg->type = MANAGESIEVE_ARG_LITERAL;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		} else {
+			arg->type = MANAGESIEVE_ARG_STRING;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		}
+		break;
+	default:
+		i_unreached();
+	}
+
+	parser->cur_type = ARG_PARSE_NONE;
+}
+
+static int is_valid_atom_char(struct managesieve_parser *parser, char chr)
+{
+	if (IS_ATOM_SPECIAL((unsigned char)chr)) {
+		parser->error = "Invalid characters in atom";
+		return FALSE;
+	} else if ((chr & 0x80) != 0) {
+		parser->error = "8bit data in atom";
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static int managesieve_parser_read_atom(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t data_size)
+{
+	size_t i;
+
+	/* read until we've found space, CR or LF. */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == ')' ||
+			 is_linebreak(data[i])) {
+			managesieve_parser_save_arg(parser, data, i);
+			break;
+		} else if (!is_valid_atom_char(parser, data[i]))
+			return FALSE;
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_read_string(struct managesieve_parser *parser,
+				   const unsigned char *data, size_t data_size)
+{
+	size_t i;
+	int utf8_len;
+
+	/* QUOTED-CHAR        = SAFE-UTF8-CHAR / "\" QUOTED-SPECIALS
+	 * quoted             = <"> *QUOTED-CHAR <">
+	 *                    ;; limited to 1024 octets between the <">s
+	 */
+
+	/* read until we've found non-escaped ", CR or LF */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '"') {
+			managesieve_parser_save_arg(parser, data, i);
+
+			i++; /* skip the trailing '"' too */
+			break;
+		}
+
+		if (data[i] == '\\') {
+			if (i+1 == data_size) {
+				/* known data ends with '\' - leave it to
+				   next time as well if it happens to be \" */
+				break;
+			}
+
+			/* save the first escaped char */
+			if (parser->str_first_escape < 0)
+				parser->str_first_escape = i;
+
+			/* skip the escaped char */
+			i++;
+
+			if ( !IS_QUOTED_SPECIAL(data[i]) ) {
+				parser->error = "Escaped quoted-string character is not a QUOTED-SPECIAL.";
+				return FALSE;
+			}
+
+			continue;
+		}
+
+		/* Enforce valid UTF-8
+		 */
+		if ( (utf8_len = UTF8_LEN(data[i])) == 0 ) {
+			parser->error = "String contains invalid character.";
+			return FALSE;
+		}
+		
+		if ( utf8_len > 1 ) {
+			bool overlong = FALSE;
+
+			if ( (i+utf8_len-1) >= data_size ) {
+				/* Known data ends in the middle of a UTF-8 character;
+				 * leave it to next time.
+				 */
+				break;
+			}
+
+			/* Check for overlong UTF-8 sequences */
+			switch (utf8_len) {
+			case 2:
+				if (!(data[i] & 0x1E)) overlong = TRUE;
+				break;
+			case 3:	
+				if (!(data[i] & 0x0F) && !(data[i+1] & 0x20)) overlong = TRUE;
+				break;
+			case 4:
+				if (!(data[i] & 0x07) && !(data[i+1] & 0x30)) overlong = TRUE;				
+				break;
+			case 5:
+				if (!(data[i] & 0x03) && !(data[i+1] & 0x38)) overlong = TRUE;
+				break;				
+			case 6:
+				if (!(data[i] & 0x01) && !(data[i+1] & 0x3C)) overlong = TRUE;
+				break;				
+			default:
+				i_unreached();
+			} 
+
+			if ( overlong ) {
+				parser->error = "String contains invalid/overlong UTF-8 character.";
+				return FALSE;
+			}
+
+			i++;
+			utf8_len--;
+	
+			/* Parse the series of UTF8_1 characters */
+			for (; utf8_len > 0; utf8_len--, i++ ) {  
+				if (!IS_UTF8_1(data[i])) {
+					parser->error = "String contains invalid UTF-8 character.";
+			    return FALSE;
+				}
+			}
+		}
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_literal_end(struct managesieve_parser *parser)
+{
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		if (parser->line_size >= parser->max_line_size ||
+		    parser->literal_size >
+		    	parser->max_line_size - parser->line_size) {
+			/* too long string, abort. */
+			parser->error = "Literal size too large";
+			parser->fatal_error = TRUE;
+			return FALSE;
+		}
+	}
+
+	parser->cur_type = ARG_PARSE_LITERAL_DATA;
+	parser->literal_skip_crlf = TRUE;
+
+	parser->cur_pos = 0;
+	return TRUE;
+}
+
+static int managesieve_parser_read_literal(struct managesieve_parser *parser,
+				    const unsigned char *data,
+				    size_t data_size)
+{
+	size_t i, prev_size;
+
+	/* expecting digits + "}" */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '}') {
+			parser->line_size += i+1;
+			i_stream_skip(parser->input, i+1);
+
+			return managesieve_parser_literal_end(parser);
+		}
+
+		if (parser->literal_nonsync) {
+			parser->error = "Expecting '}' after '+'";
+			return FALSE;
+		}
+
+		if (data[i] == '+') {
+			parser->literal_nonsync = TRUE;
+			continue;
+		}
+
+		if (data[i] < '0' || data[i] > '9') {
+			parser->error = "Invalid literal size";
+			return FALSE;
+		}
+
+		prev_size = parser->literal_size;
+		parser->literal_size = parser->literal_size*10 + (data[i]-'0');
+
+		if (parser->literal_size < prev_size) {
+			/* wrapped around, abort. */
+			parser->error = "Literal size too large";
+			return FALSE;
+		}
+	}
+
+	parser->cur_pos = i;
+	return FALSE;
+}
+
+static int managesieve_parser_read_literal_data(struct managesieve_parser *parser,
+					 const unsigned char *data,
+					 size_t data_size)
+{
+	if (parser->literal_skip_crlf) {
+
+		/* skip \r\n or \n, anything else gives an error */
+		if (data_size == 0)
+			return FALSE;
+
+		if (*data == '\r') {
+			parser->line_size++;
+			data++; data_size--;
+			i_stream_skip(parser->input, 1);
+
+			if (data_size == 0)
+				return FALSE;
+		}
+
+		if (*data != '\n') {
+			parser->error = "Missing LF after literal size";
+			return FALSE;
+		}
+
+		parser->line_size++;
+		data++; data_size--;
+		i_stream_skip(parser->input, 1);
+
+		parser->literal_skip_crlf = FALSE;
+
+		i_assert(parser->cur_pos == 0);
+	}
+
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		/* now we just wait until we've read enough data */
+		if (data_size < parser->literal_size) {
+			return FALSE;
+		} else {
+			managesieve_parser_save_arg(parser, data,
+					     (size_t)parser->literal_size);
+			parser->cur_pos = (size_t)parser->literal_size;
+			return TRUE;
+		}
+	} else {
+		/* we want to save only literal size, not the literal itself. */
+		parser->eol = TRUE;
+		managesieve_parser_save_arg(parser, NULL, 0);
+		return TRUE;
+	}
+}
+
+/* Returns TRUE if argument was fully processed. Also returns TRUE if
+   an argument inside a list was processed. */
+static int managesieve_parser_read_arg(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+	if (data_size == 0)
+		return FALSE;
+
+	while (parser->cur_type == ARG_PARSE_NONE) {
+		/* we haven't started parsing yet */
+		if (!managesieve_parser_skip_to_next(parser, &data, &data_size))
+			return FALSE;
+		i_assert(parser->cur_pos == 0);
+
+		switch (data[0]) {
+		case '\r':
+		case '\n':
+			/* unexpected end of line */
+			parser->eol = TRUE;
+			return FALSE;
+		case '"':
+			parser->cur_type = ARG_PARSE_STRING;
+			parser->str_first_escape = -1;
+			break;
+		case '{':
+			parser->cur_type = ARG_PARSE_LITERAL;
+			parser->literal_size = 0;
+			parser->literal_nonsync = FALSE;
+			break;
+		default:
+			if (!is_valid_atom_char(parser, data[0]))
+				return FALSE;
+			parser->cur_type = ARG_PARSE_ATOM;
+			break;
+		}
+
+		parser->cur_pos++;
+	}
+
+	i_assert(data_size > 0);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		if (!managesieve_parser_read_atom(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_STRING:
+		if (!managesieve_parser_read_string(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_LITERAL:
+		if (!managesieve_parser_read_literal(parser, data, data_size))
+			return FALSE;
+
+		/* pass through to parsing data. since input->skip was
+		   modified, we need to get the data start position again. */
+		data = i_stream_get_data(parser->input, &data_size);
+
+		/* fall through */
+	case ARG_PARSE_LITERAL_DATA:
+		if (!managesieve_parser_read_literal_data(parser, data, data_size))
+			return FALSE;
+		break;
+	default:
+		i_unreached();
+	}
+
+	i_assert(parser->cur_type == ARG_PARSE_NONE);
+	return TRUE;
+}
+
+/* ARG_PARSE_NONE checks that last argument isn't only partially parsed. */
+#define IS_UNFINISHED(parser) \
+        ((parser)->cur_type != ARG_PARSE_NONE || \
+	 (parser)->cur_list != parser->root_list)
+
+static int finish_line(struct managesieve_parser *parser, unsigned int count,
+		       struct managesieve_arg **args)
+{
+	parser->line_size += parser->cur_pos;
+	i_stream_skip(parser->input, parser->cur_pos);
+	parser->cur_pos = 0;
+
+	if (count >= parser->root_list->alloc) {
+		/* unused arguments must be NIL-filled. */
+		parser->root_list =
+			LIST_REALLOC(parser, parser->root_list, count+1);
+		parser->root_list->alloc = count+1;
+	}
+
+	parser->root_list->args[parser->root_list->size].type = MANAGESIEVE_ARG_EOL;
+
+	*args = parser->root_list->args;
+	return parser->root_list->size;
+}
+
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args)
+{
+	parser->flags = flags;
+
+	while (!parser->eol && (count == 0 || parser->root_list->size < count ||
+				IS_UNFINISHED(parser))) {
+		if (!managesieve_parser_read_arg(parser))
+			break;
+
+		if (parser->line_size > parser->max_line_size) {
+			parser->error = "MANAGESIEVE command line too large";
+			break;
+		}
+	}
+
+	if (parser->error != NULL) {
+		/* error, abort */
+		parser->line_size += parser->cur_pos;
+		i_stream_skip(parser->input, parser->cur_pos);
+		parser->cur_pos = 0;
+		*args = NULL;
+		return -1;
+	} else if ((!IS_UNFINISHED(parser) && count > 0 &&
+		    parser->root_list->size >= count) || parser->eol) {
+		/* all arguments read / end of line. */
+                return finish_line(parser, count, args);
+	} else {
+		/* need more data */
+		*args = NULL;
+		return -2;
+	}
+}
+
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args)
+{
+	const unsigned char *data;
+	size_t data_size;
+	int ret;
+
+	ret = managesieve_parser_read_args(parser, count, flags, args);
+	if (ret == -2) {
+		/* we should have noticed end of everything except atom */
+		if (parser->cur_type == ARG_PARSE_ATOM) {
+			data = i_stream_get_data(parser->input, &data_size);
+			managesieve_parser_save_arg(parser, data, data_size);
+		}
+	}
+	return finish_line(parser, count, args);
+}
+
+const char *managesieve_parser_read_word(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == '\r' || data[i] == '\n')
+			break;
+	}
+
+	if (i < data_size) {
+		data_size = i + (data[i] == ' ' ? 1 : 0);
+		parser->line_size += data_size;
+		i_stream_skip(parser->input, data_size);
+		return p_strndup(parser->pool, data, i);
+	} else {
+		return NULL;
+	}
+}
+
+const char *managesieve_arg_string(struct managesieve_arg *arg)
+{
+	if (arg->type == MANAGESIEVE_ARG_STRING) 
+		return arg->_data.str;
+
+	return NULL;
+}
+
+int managesieve_arg_number
+	(struct managesieve_arg *arg, uoff_t *number)
+{
+	int i = 0;
+	const char *data;
+
+	*number = 0;
+
+	if (arg->type == MANAGESIEVE_ARG_ATOM) {
+		data = arg->_data.str;
+		while (data[i] != '\0') {
+			if (data[i] < '0' || data[i] > '9')
+				return -1;
+	
+			*number = (*number)*10 + (data[i] -'0');
+			i++;
+		}
+    
+		return 1;
+	}
+
+	return -1;
+}
+
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as string", arg->type);
+	return NULL;
+}
+
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as literal size", arg->type);
+	return 0;
+}
+
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as list", arg->type);
+	return NULL;
+}
diff -r 923786016963 src/lib-managesieve/managesieve-parser.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-managesieve/managesieve-parser.h	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,189 @@
+#ifndef __MANAGESIEVE_PARSER_H
+#define __MANAGESIEVE_PARSER_H
+
+/*
+ * QUOTED-SPECIALS    = <"> / "\"
+ */
+#define IS_QUOTED_SPECIAL(c) \
+	((c) == '"' || (c) == '\\')
+
+/* 
+ * ATOM-SPECIALS      = "(" / ")" / "{" / SP / CTL / QUOTED-SPECIALS
+ */
+#define IS_ATOM_SPECIAL(c) \
+	((c) == '(' || (c) == ')' || (c) == '{' || \
+	 (c) <= 32 || (c) == 0x7f || \
+	 IS_QUOTED_SPECIAL(c)) 
+
+/* 
+ * CHAR               = %x01-7F
+ */
+#define IS_CHAR(c) \
+	(((c) & 0x80) == 0)
+
+/* 
+ * TEXT-CHAR          = %x01-09 / %x0B-0C / %x0E-7F
+ *                       ;; any CHAR except CR and LF
+ */
+#define IS_TEXT_CHAR(c) \
+	(IS_CHAR(c) && (c) != '\r' && (c) != '\n')
+
+/*
+ * SAFE-CHAR          = %x01-09 / %x0B-0C / %x0E-21 /
+ *                      %x23-5B / %x5D-7F
+ *                      ;; any TEXT-CHAR except QUOTED-SPECIALS
+ */
+#define IS_SAFE_CHAR(c) \
+	(IS_TEXT_CHAR(c) && !IS_QUOTED_SPECIAL(c))
+
+/* UTF8-1             = %x80-BF
+ */
+#define IS_UTF8_1(c) \
+	(((c) & 0xC0) == 0x80)
+
+/* UTF8-2             = %xC0-DF UTF8-1
+ */
+#define IS_UTF8_2S(c) \
+  (((c) & 0xE0) == 0xC0)
+
+/* UTF8-3             = %xE0-EF 2UTF8-1
+ */
+#define IS_UTF8_3S(c) \
+  (((c) & 0xF0) == 0xE0)
+
+/* UTF8-4             = %xF0-F7 3UTF8-1
+ */
+#define IS_UTF8_4S(c) \
+  (((c) & 0xF8) == 0xF0)
+
+/* UTF8-5             = %xF8-FB 4UTF8-1
+ */
+#define IS_UTF8_5S(c) \
+  (((c) & 0xFC) == 0xF8)
+
+/* UTF8-6             = %xFC-FD 5UTF8-1
+ */
+#define IS_UTF8_6S(c) \
+  (((c) & 0xFE) == 0xFC)
+
+/* SAFE-UTF8-CHAR     = SAFE-CHAR / UTF8-2 / UTF8-3 / UTF8-4 /
+ *                      UTF8-5 / UTF8-6
+ */
+#define UTF8_LEN(c) \
+  ( IS_SAFE_CHAR(c) ? 1 : \
+    IS_UTF8_2S(c) ? 2 : \
+    IS_UTF8_3S(c) ? 3 : \
+    IS_UTF8_4S(c) ? 4 : \
+    IS_UTF8_5S(c) ? 5 : \
+    IS_UTF8_6S(c) ? 6 : 0 )
+
+enum managesieve_parser_flags {
+	/* Set this flag if you wish to read only size of literal argument
+	   and not convert literal into string. Useful when you need to deal
+	   with large literal sizes. The literal must be the last read
+	   parameter. */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE	= 0x01,
+	/* Don't remove '\' chars from string arguments */
+	MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE	= 0x02,
+	/* Return literals as MANAGESIEVE_ARG_LITERAL instead of MANAGESIEVE_ARG_STRING */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE	= 0x04
+};
+
+enum managesieve_arg_type {
+	MANAGESIEVE_ARG_ATOM = 0,
+	MANAGESIEVE_ARG_STRING,
+
+	/* literals are returned as MANAGESIEVE_ARG_STRING by default */
+	MANAGESIEVE_ARG_LITERAL,
+	MANAGESIEVE_ARG_LITERAL_SIZE,
+
+	MANAGESIEVE_ARG_EOL /* end of argument list */
+};
+
+struct managesieve_parser;
+
+struct managesieve_arg {
+	enum managesieve_arg_type type;
+
+	union {
+		char *str;
+		uoff_t literal_size;
+	} _data;
+};
+
+#define MANAGESIEVE_ARG_STR(arg) \
+	((arg)->type == MANAGESIEVE_ARG_STRING || \
+   (arg)->type == MANAGESIEVE_ARG_ATOM || \
+	 (arg)->type == MANAGESIEVE_ARG_LITERAL ? \
+	 (arg)->_data.str : _managesieve_arg_str_error(arg))
+
+#define MANAGESIEVE_ARG_LITERAL_SIZE(arg) \
+	(((arg)->type == MANAGESIEVE_ARG_LITERAL_SIZE) ? \
+	 (arg)->_data.literal_size : _managesieve_arg_literal_size_error(arg))
+
+struct managesieve_arg_list {
+	size_t size, alloc;
+	struct managesieve_arg args[1]; /* variable size */
+};
+
+
+/* Create new MANAGESIEVE argument parser. output is used for sending command
+   continuation requests for literals.
+
+   max_line_size can be used to approximately limit the maximum amount of
+   memory that gets allocated when parsing a line. Input buffer size limits
+   the maximum size of each parsed token.
+
+   Usually the largest lines are large only because they have a one huge
+   message set token, so you'll probably want to keep input buffer size the
+   same as max_line_size. That means the maximum memory usage is around
+   2 * max_line_size. */
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size);
+void managesieve_parser_destroy(struct managesieve_parser **parser);
+
+/* Reset the parser to initial state. */
+void managesieve_parser_reset(struct managesieve_parser *parser);
+
+/* Return the last error in parser. fatal is set to TRUE if there's no way to
+   continue parsing, currently only if too large non-sync literal size was
+   given. */
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal);
+
+/* Read a number of arguments. This function doesn't call i_stream_read(), you
+   need to do that. Returns number of arguments read (may be less than count
+   in case of EOL), -2 if more data is needed or -1 if error occurred.
+
+   count-sized array of arguments are stored into args when return value is
+   0 or larger. If all arguments weren't read, they're set to NIL. count
+   can be set to 0 to read all arguments in the line. Last element in
+   args is always of type MANAGESIEVE_ARG_EOL. */
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args);
+
+/* just like managesieve_parser_read_args(), but assume \n at end of data in
+   input stream. */
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args);
+
+/* Read one word - used for reading tag and command name.
+   Returns NULL if more data is needed. */
+const char *managesieve_parser_read_word(struct managesieve_parser *parser);
+
+/* Returns the managesieve argument as string. If it is no string this returns NULL */
+const char *managesieve_arg_string(struct managesieve_arg *arg);
+
+/* Returns 1 if the argument is a number. If it is no number this returns -1.
+ * The number itself is stored in *number.
+ */
+int managesieve_arg_number
+  (struct managesieve_arg *arg, uoff_t *number);
+
+/* Error functions */
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg);
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg);
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg);
+
+#endif
diff -r 923786016963 src/lib-managesieve/managesieve-quote.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-managesieve/managesieve-quote.c	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,176 @@
+#include "lib.h"
+#include "str.h"
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+/* Turn the value string into a valid MANAGESIEVE string or literal, no matter 
+ * what. QUOTED-SPECIALS are escaped, but any invalid (UTF-8) character
+ * is simply removed. Linebreak characters are not considered invalid, but
+ * they do force the generation of a string literal.
+ */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp)
+{
+	size_t i, extra = 0;
+	bool 
+		last_lwsp = TRUE, 
+		literal = FALSE, 
+		modify = FALSE,
+		escape = FALSE;
+	int utf8_len;
+
+ 	if (value == NULL) {
+		str_append(str, "\"\"");
+		return;
+	}
+
+	if (value_len == (size_t)-1)
+		value_len = strlen((const char *) value);
+
+	for (i = 0; i < value_len; i++) {
+		switch (value[i]) {
+		case ' ':
+		case '\t':
+			if (last_lwsp && compress_lwsp) {
+				modify = TRUE;
+				extra++;
+			}
+			last_lwsp = TRUE;
+			break;
+		case '"':
+		case '\\':
+			escape = TRUE;
+			last_lwsp = FALSE;
+			break;
+		case 13:
+		case 10:
+			literal = TRUE;
+			last_lwsp = TRUE;
+			break;
+		default:
+			/* Enforce valid UTF-8
+			 */
+			if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) {
+				modify = TRUE;
+				extra++;
+				break;
+			}
+
+			if ( utf8_len > 1 ) {
+				int c = utf8_len - 1;
+
+		 		if ( (i+utf8_len-1) >= value_len ) {
+				  	/* Value ends in the middle of a UTF-8 character;
+					 * Kill the partial UTF-8 character
+					 */
+				  	extra += i + utf8_len - value_len;
+					modify = TRUE;
+					break;        	
+				}
+
+				/* Parse the series of UTF8_1 characters */
+				for (i++; c > 0; c--, i++ ) {
+					if (!IS_UTF8_1(value[i])) {
+						extra += utf8_len - c;
+						modify = TRUE;
+						break;
+					}
+				}
+			}
+   			
+			last_lwsp = FALSE;
+		}
+	}
+
+	if (!literal) {
+		/* no linebreak chars, return as (escaped) "string" */
+		str_append_c(str, '"');
+	} else {
+		/* return as literal */
+		str_printfa(str, "{%"PRIuSIZE_T"}\r\n", value_len - extra);
+	}
+
+	if (!modify && (literal || !escape))
+		str_append_n(str, value, value_len);
+	else {
+		last_lwsp = TRUE;
+		for (i = 0; i < value_len; i++) {
+			switch (value[i]) {
+			case '"':
+			case '\\':
+				last_lwsp = FALSE;
+				if (!literal) 
+					str_append_c(str, '\\');
+				str_append_c(str, value[i]);
+				break;
+			case ' ':
+			case '\t':
+				if (!last_lwsp || !compress_lwsp)
+					str_append_c(str, ' ');
+				last_lwsp = TRUE;
+				break;
+			case 13:
+			case 10:
+				last_lwsp = TRUE;
+				str_append_c(str, value[i]);
+				break;
+			default:
+	  			/* Enforce valid UTF-8
+				 */
+				if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) 
+					break;
+      
+				if ( utf8_len > 1 ) {
+					int c = utf8_len - 1;
+					int j;
+
+					if ( (i+utf8_len-1) >= value_len ) {
+						/* Value ends in the middle of a UTF-8 character;
+						 * Kill the partial character
+						 */
+					 	i = value_len;
+						break;
+					}
+
+					/* Parse the series of UTF8_1 characters */
+					for (j = i+1; c > 0; c--, j++ ) {
+						if (!IS_UTF8_1(value[j])) {
+							/* Skip until after this erroneous character */
+							i = j;
+							break;
+						}
+					}
+
+					/* Append the UTF-8 character. Last octet is done later */
+					c = utf8_len - 1;
+					for (; c > 0; c--, i++ ) 
+						str_append_c(str, value[i]);
+				}
+     
+				last_lwsp = FALSE;
+				str_append_c(str, value[i]);
+				break;
+			}
+		}
+	}
+
+	if (!literal)
+		str_append_c(str, '"');
+}
+
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len)
+{
+	string_t *str;
+	char *ret;
+
+	if (value == NULL)
+		return "\"\"";
+
+	t_push();
+	str = t_str_new(value_len + MAX_INT_STRLEN + 5);
+	managesieve_quote_append(str, value, value_len, TRUE);
+	ret = p_strndup(pool, str_data(str), str_len(str));
+	t_pop();
+
+	return ret;
+}
diff -r 923786016963 src/lib-managesieve/managesieve-quote.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-managesieve/managesieve-quote.h	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,17 @@
+#ifndef __IMAP_QUOTE_H
+#define __IMAP_QUOTE_H
+
+/* Return value suitable for sending to client, either as quoted-string or
+   literal. Note that this also converts TABs into spaces, multiple spaces
+   into single space and NULs to #128. */
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len);
+
+/* Append to existing string. */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp);
+
+#define managesieve_quote_append_string(str, value, compress_lwsp) \
+	managesieve_quote_append(str, (const unsigned char *)(value), \
+			  (size_t)-1, compress_lwsp)
+
+#endif
diff -r 923786016963 src/lib-sieve/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/Makefile.am	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,20 @@
+noinst_LTLIBRARIES = libsieve.la
+
+SUBDIRS = cmu
+
+INCLUDES = \
+	-I$(top_srcdir)/src/lib \
+	-I$(top_srcdir)/src/lib-storage \
+	-I$(top_srcdir)/src/lib-mail \
+	-I$(top_srcdir)/src/lib-sievestorage
+
+# FIXME: Make this configurable
+libsieve_la_LIBADD = \
+	cmu/libsieve_cmu.la
+
+libsieve_la_SOURCES = \
+	sieve-implementation.c 
+
+noinst_HEADERS = \
+	sieve-implementation.h \
+	sieve-implementation-private.h
diff -r 923786016963 src/lib-sieve/cmu/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/Makefile.am	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,24 @@
+noinst_LTLIBRARIES = libsieve_cmu.la
+
+SUBDIRS = libsieve
+
+INCLUDES = \
+	-I$(top_srcdir)/src/lib \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(top_srcdir)/src/lib-mail \
+	-I$(top_srcdir)/src/lib-storage \
+	-I$(top_srcdir)/src/deliver
+
+libsieve_cmu_la_LIBADD = libsieve/libsieve.la
+
+libsieve_cmu_la_SOURCES = \
+	cmu-sieve.c \
+	imparse.c \
+	map.c 
+	
+noinst_HEADERS = \
+    imparse.h \
+    libconfig.h \
+    map.h \
+    xmalloc.h
diff -r 923786016963 src/lib-sieve/cmu/cmu-sieve.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/cmu-sieve.c	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,498 @@
+
+/* Copyright (C) 2005-2006 Timo Sirainen */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "array.h"
+#include "hostpid.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "write-full.h"
+#include "libsieve/sieve_interface.h"
+#include "sieve-script.h"
+#include "sieve-implementation-private.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+extern struct sieve_implementation cmu_sieve;
+
+struct et_list *_et_list = NULL;
+
+/* data per script */
+typedef struct script_data {
+	string_t *errors;
+	int	num_errors;
+} script_data_t;
+
+typedef struct {
+	const char *id;
+	void *context;
+} sieve_msgdata_t;
+
+/* gets the header "head" from msg. */
+static int getheader(void *v, const char *phead, const char ***body)
+{
+	sieve_msgdata_t *m = v;
+
+	if (phead==NULL) return SIEVE_FAIL;
+	*body = (const char **)sieve_runenv_get_mail_headers(m->context, phead);
+
+	if (*body) {
+		return SIEVE_OK;
+	} else {
+		return SIEVE_FAIL;
+	}
+}
+
+static int getsize(void *mc, int *size)
+{
+	sieve_msgdata_t *md = mc;
+	uoff_t psize;
+
+	psize = sieve_runenv_get_mail_size(md->context);
+	if (psize == (uoff_t)-1)
+		return SIEVE_FAIL;
+
+	*size = psize;
+	return SIEVE_OK;
+}
+
+static int getenvelope(void *mc, const char *field, const char ***contents)
+{
+	array_t ARRAY_DEFINE(values, const char *);
+	sieve_msgdata_t *m = (sieve_msgdata_t *) mc;
+	const char *data;
+
+	// FIXME: Should prob. not put this on the default pool
+	ARRAY_CREATE(&values, default_pool, const char *, 1);
+
+	if (!sieve_runenv_get_envelope(m->context, field, &values) ) {
+		*contents = NULL;
+		return SIEVE_FAIL;
+	}
+
+	data = NULL;
+	array_append(&values, &data, 1);
+
+	*contents = array_count(&values) == 1 ? NULL :
+	  array_get_modifyable(&values, NULL);
+
+	return *contents != NULL ? SIEVE_OK : SIEVE_FAIL;
+}
+
+static int sieve_redirect(void *ac, 
+			  void *ic __attr_unused__, 
+			  void *sc __attr_unused__, void *mc, const char **errmsg)
+{
+	sieve_redirect_context_t *rc = (sieve_redirect_context_t *) ac;
+	sieve_msgdata_t *m = mc;
+	const char *dupeid;
+	int res;
+
+	/* if we have a msgid, we can track our redirects */
+	dupeid = m->id == NULL ? NULL : t_strdup_printf("%s-%s", m->id, rc->addr);
+	if (dupeid != NULL) {
+		/* ok, let's see if we've redirected this message before */
+		if (sieve_runenv_is_duplicate(m->context, dupeid, strlen(dupeid))) {
+			/*duplicate_log(m->id, sd->username, "redirect");*/
+			i_info("discarded duplicate forward (%s -> %s)",
+				str_sanitize(m->id, 80), str_sanitize(rc->addr, 80));
+			return SIEVE_OK;
+		}
+	}
+
+	if ((res = sieve_runenv_send_forward(m->context, rc->addr)) == 0) {
+		/* mark this message as redirected */
+		i_info("forwarded id %s to <%s>",
+			m->id == NULL ? "" : str_sanitize(m->id, 80),
+			str_sanitize(rc->addr, 80));
+		
+		if (dupeid != NULL) {
+			sieve_runenv_mark_duplicate(m->context,dupeid, strlen(dupeid), 
+				DUPLICATE_DEFAULT_KEEP);
+		}
+		return SIEVE_OK;
+	} 
+
+	*errmsg = "Error sending mail";
+	return SIEVE_FAIL;
+}
+
+static int sieve_discard(void *ac __attr_unused__, 
+			 void *ic __attr_unused__, 
+			 void *sc __attr_unused__, void *mc,
+			 const char **errmsg __attr_unused__)
+{
+	sieve_msgdata_t *md = mc;
+
+	/* ok, we won't file it, but log it */
+	i_info("discarded id %s", md->id == NULL ? "" : str_sanitize(md->id, 80));
+	return SIEVE_OK;
+}
+
+static int sieve_reject(void *ac, 
+			void *ic __attr_unused__, 
+			void *sc __attr_unused__, 
+			void *mc, const char **errmsg)
+{
+	sieve_reject_context_t *rc = (sieve_reject_context_t *) ac;
+	sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+	int res;
+
+	if ((res = sieve_runenv_send_rejection(md->context, rc->msg)) == 0) {
+		i_info("rejected id %s",
+			md->id == NULL ? "" : str_sanitize(md->id, 80));
+		return SIEVE_OK;
+	} else {
+		*errmsg = "Error sending mail";
+		return SIEVE_FAIL;
+  }
+  return SIEVE_FAIL;
+}
+
+static int sieve_fileinto(void *ac, 
+			  void *ic __attr_unused__,
+			  void *sc __attr_unused__, 
+			  void *mc,
+			  const char **errmsg __attr_unused__)
+{
+	sieve_fileinto_context_t *fc = (sieve_fileinto_context_t *) ac;
+	sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+
+	if (sieve_runenv_mail_save
+	    (md->context, fc->mailbox, fc->imapflags->flag, 
+	     fc->imapflags->nflags) < 0)
+		return SIEVE_FAIL;
+
+	i_info("saved mail to %s", fc->mailbox);
+	return SIEVE_OK;
+}
+
+static int sieve_keep(void *ac, 
+	void *ic __attr_unused__,
+	void *sc __attr_unused__, 
+	void *mc, const char **errmsg __attr_unused__)
+{
+	sieve_keep_context_t *kc = (sieve_keep_context_t *) ac;
+	sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+
+	if (sieve_runenv_mail_save
+	    (md->context, NULL, kc->imapflags->flag, 
+	     kc->imapflags->nflags) < 0)
+		return SIEVE_FAIL;
+
+	return SIEVE_OK;
+}
+
+static int sieve_notify(void *ac __attr_unused__,
+			void *interp_context __attr_unused__,
+			void *script_context __attr_unused__,
+			void *mc __attr_unused__,
+			const char **errmsg __attr_unused__)
+{
+	return SIEVE_FAIL;
+}
+
+static int autorespond(void *ac, 
+		       void *ic __attr_unused__,
+		       void *sc __attr_unused__,
+		       void *mc,
+		       const char **errmsg __attr_unused__)
+{
+	sieve_autorespond_context_t *arc = (sieve_autorespond_context_t *) ac;
+	sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+	int ret;
+
+	/* ok, let's see if we've responded before */
+	ret = sieve_runenv_is_duplicate(md->context, arc->hash, arc->len) ?
+	  SIEVE_DONE : SIEVE_OK;
+
+	if (ret == SIEVE_OK) {
+		sieve_runenv_mark_duplicate(md->context, arc->hash, arc->len, 
+					    arc->days * (24 * 60 * 60));
+	}
+
+	return ret;
+}
+
+static int send_response(void *ac, 
+	void *ic __attr_unused__, 
+	void *sc __attr_unused__, 
+	void *mc,
+	const char **errmsg)
+{
+	sieve_send_response_context_t *src = (sieve_send_response_context_t *) ac;
+	sieve_msgdata_t *md = mc;
+	const char *outmsgid;
+
+	if (sieve_runenv_send_message
+	    (md->context, src->fromaddr, src->addr, 
+	     src->subj, src->mime, src->msg, &outmsgid) == 0) {
+		sieve_runenv_mark_duplicate
+		  (md->context, outmsgid, strlen(outmsgid),	DUPLICATE_DEFAULT_KEEP);
+		return SIEVE_OK;
+	} else {
+		*errmsg = "Error sending mail";
+		return SIEVE_FAIL;
+	}
+}
+
+/* vacation support */
+sieve_vacation_t vacation = {
+    1,				/* min response */
+    31,				/* max response */
+    &autorespond,		/* autorespond() */
+    &send_response		/* send_response() */
+};
+
+/* imapflags support */
+static char *markflags[] = { "\\flagged" };
+static sieve_imapflags_t mark = { markflags, 1 };
+
+static int sieve_parse_error_handler(int lineno, const char *msg, 
+				     void *ic __attr_unused__,
+				     void *sc)
+{
+	script_data_t *sd = (script_data_t *) sc;
+
+	if (sd->errors == NULL) 
+		sd->errors = str_new(default_pool, 1024);
+
+	if (sd->num_errors == 1) 
+		str_append(sd->errors, "\r\n");
+    
+	str_printfa(sd->errors, "line %d: %s", lineno, msg);
+
+	if (sd->num_errors >= 1) 
+		str_append(sd->errors, "\r\n");
+
+	sd->num_errors++;
+	return SIEVE_OK;
+}
+
+static int sieve_execute_error_handler(const char *msg, 
+				       void *ic __attr_unused__,
+				       void *sc __attr_unused__,
+				       void *mc __attr_unused__)
+{
+ 	i_info("sieve runtime error: %s", msg);
+	return SIEVE_OK;
+}
+ 
+static sieve_interp_t *setup_sieve(void)
+{
+	sieve_interp_t *interp = NULL;
+	int res;
+
+	res = sieve_interp_alloc(&interp, NULL);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_interp_alloc() returns %d\n", res);
+
+	res = sieve_register_redirect(interp, &sieve_redirect);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_redirect() returns %d\n", res);
+	res = sieve_register_discard(interp, &sieve_discard);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_discard() returns %d\n", res);
+	res = sieve_register_reject(interp, &sieve_reject);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_reject() returns %d\n", res);
+	res = sieve_register_fileinto(interp, &sieve_fileinto);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_fileinto() returns %d\n", res);
+	res = sieve_register_keep(interp, &sieve_keep);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_keep() returns %d\n", res);
+	res = sieve_register_imapflags(interp, &mark);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_imapflags() returns %d\n", res);
+	res = sieve_register_notify(interp, &sieve_notify);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_notify() returns %d\n", res);
+	res = sieve_register_size(interp, &getsize);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_size() returns %d\n", res);
+	res = sieve_register_header(interp, &getheader);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_header() returns %d\n", res);
+	
+	res = sieve_register_envelope(interp, &getenvelope);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_envelope() returns %d\n", res);
+	res = sieve_register_vacation(interp, &vacation);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_vacation() returns %d\n", res);
+	res = sieve_register_parse_error(interp, &sieve_parse_error_handler);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_parse_error() returns %d\n", res);
+	res = sieve_register_execute_error(interp,  &sieve_execute_error_handler);
+	if (res != SIEVE_OK)
+		i_fatal("sieve_register_execute_error() returns %d\n", res);
+
+	return interp;
+}
+
+static int
+_cmu_sieve_compile(sieve_interp_t *interp, script_data_t *sdata,
+		     const char *script_path, const char *compiled_path)
+{
+	struct stat st, st2;
+	sieve_script_t *script;
+	bytecode_info_t *bc;
+	const char *temp_path;
+	FILE *f;
+	int fd, ret;
+
+	if (stat(script_path, &st) < 0) {
+		if (errno == ENOENT)
+			return 0;
+		i_error("stat(%s) failed: %m", script_path);
+		return -1;
+	}
+	if (compiled_path != NULL) {
+		if (stat(compiled_path, &st2) < 0) {
+			if (errno != ENOENT) {
+				i_error("stat(%s) failed: %m", script_path);
+				return -1;
+			}
+		} else {
+			if (st.st_mtime < st2.st_mtime)
+				return 1;
+		}
+	}
+
+	/* need to compile */
+	f = fopen(script_path, "r");
+	if (f == NULL) {
+		i_error("fopen(%s) failed: %m", script_path);
+		return -1;
+	}
+
+	ret = sieve_script_parse(interp, f, sdata, &script);
+	if (ret != SIEVE_OK) {
+		if (sdata->errors == NULL)
+		  	sieve_set_error("parse error %d", ret);
+		else
+		  	sieve_set_error("%s", str_c(sdata->errors));
+		
+		return -1;
+	}
+
+	if (compiled_path != NULL) {
+		if (sieve_generate_bytecode(&bc, script) < 0) {
+			i_error("sieve_generate_bytecode() failed");
+			return -1;
+		}
+
+		/* write to temp file */
+		temp_path = t_strconcat(compiled_path, ".tmp", NULL);
+		fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+		if(fd == -1) {
+			i_error("open(%s) failed: %m", temp_path);
+			return -1;
+		}
+
+		if (sieve_emit_bytecode(fd, bc) < 0) {
+			i_error("sieve_emit_bytecode() failed");
+			return -1;
+		}
+
+		if (close(fd) < 0)
+			i_error("close() failed: %m");
+
+		/* and finally replace the script */
+		if (rename(temp_path, compiled_path) < 0) {
+			i_error("rename(%s, %s) failed: %m", temp_path, compiled_path);
+			return -1;
+		}
+	}
+
+	return 1;
+}
+
+static int cmu_sieve_compile
+	(struct sieve_script *script, bool verify_only __attr_unused__)
+{
+	const char *script_path;
+	sieve_interp_t *interp;
+	script_data_t sdata;
+	int ret;
+	
+	script_path = sieve_script_filename(script);
+	
+	if (script_path == NULL)
+		return -1;
+	
+	interp = setup_sieve();
+	
+	memset(&sdata, 0, sizeof(sdata));
+	
+	ret = _cmu_sieve_compile(interp, &sdata, script_path, NULL);
+	
+	/* Let's not assume that an error string is created only when an error
+	 * occurs...better safe than sorry
+	 */
+	if (sdata.errors != NULL)
+		str_free(&sdata.errors);
+
+	return ret;
+}
+
+static int cmu_sieve_run
+	(struct sieve_script *script, void *context)
+{
+	const char *script_path;
+	sieve_interp_t *interp;
+	sieve_bytecode_t *bytecode;
+	script_data_t sdata;
+	sieve_msgdata_t mdata;
+	const char *compiled_path, *path;
+	int ret;
+
+	script_path = sieve_script_filename(script);
+
+	if (script_path == NULL)
+		return -1;
+
+	interp = setup_sieve();
+
+	memset(&sdata, 0, sizeof(sdata));
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = _cmu_sieve_compile(interp, &sdata, script_path, compiled_path);
+
+	if (sdata.errors != NULL) {
+		path = t_strconcat(script_path, ".err", NULL);
+		//dovecot_sieve_write_error_file(&sdata, path);
+		str_free(&sdata.errors);
+	}
+	if (ret <= 0)
+		return ret;
+
+	memset(&mdata, 0, sizeof(mdata));
+	mdata.context = context;
+	mdata.id = sieve_runenv_get_mail_first_header(context, "Message-ID");
+
+	if ((ret = sieve_script_load(compiled_path, &bytecode)) != SIEVE_OK) {
+		i_error("sieve_script_load(%s) failed: %d", compiled_path, ret);
+		return -1;
+	}
+
+	if (sieve_execute_bytecode(bytecode, interp,
+				   &sdata, &mdata) != SIEVE_OK)
+		return -1;
+
+	return 1;
+}
+
+struct sieve_implementation cmu_sieve = {
+	MEMBER(name) "cmu",
+	{	cmu_sieve_compile,
+		cmu_sieve_run,
+		sieve_listextensions
+	}	
+};
+
diff -r 923786016963 src/lib-sieve/cmu/imparse.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/imparse.c	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+#include "imparse.h"
+
+int imparse_isatom(const char *s)
+{
+    int len = 0;
+
+    if (!*s) return 0;
+    for (; *s; s++) {
+	len++;
+	if (*s & 0x80 || *s < 0x1f || *s == 0x7f ||
+	    *s == ' ' || *s == '{' || *s == '(' || *s == ')' ||
+	    *s == '\"' || *s == '%' || *s == '*' || *s == '\\') return 0;
+    }
+    if (len >= 1024) return 0;
+    return 1;
+}
diff -r 923786016963 src/lib-sieve/cmu/imparse.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/imparse.h	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,6 @@
+#ifndef __IMPARSE_H
+#define __IMPARSE_H
+
+extern int imparse_isatom (const char *s);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libconfig.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libconfig.h	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,8 @@
+#ifndef __LIBCONFIG_H
+#define __LIBCONFIG_H
+
+#define IMAPOPT_RFC3028_STRICT 1
+
+#define config_getswitch(n) 1
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/AUTHORS
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/AUTHORS	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,9 @@
+$Id$
+
+Larry Greenfield <leg+sieve@andrew.cmu.edu> wrote the first pass.
+
+Alexy Melnikov <alexey.melnikov@isode.com> submitted some bug fixes and 
+improvements.
+
+Ken Murchison <ken@oceana.com> took the ball, added more extensions
+than existed in the known world, and overall improved the code mightily.
diff -r 923786016963 src/lib-sieve/cmu/libsieve/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/Makefile.am	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,76 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+noinst_LTLIBRARIES = libsieve.la
+
+AM_YFLAGS = -d -p $*
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir) \
+	-I$(top_srcdir)/src/lib \
+	-I../
+
+addr-lex.c: addr-lex.l
+	$(LEX) -t -Paddr addr-lex.l > addr-lex.c
+
+sieve-lex.c: sieve-lex.l
+	$(LEX) -t sieve-lex.l > sieve-lex.c
+
+libsieve_la_SOURCES = \
+	addr.y \
+	sieve.y \
+	addr-lex.l \
+	sieve-lex.l \
+	bc_dump.c \
+	bc_emit.c \
+	bc_eval.c \
+	bc_generate.c \
+	comparator.c \
+	interp.c \
+	message.c \
+	parseaddr.c \
+	script.c \
+	sieve_err.c \
+	tree.c
+
+noinst_HEADERS = \
+	addr.h \
+	bytecode.h \
+	comparator.h \
+	interp.h \
+	message.h \
+	parseaddr.h \
+	script.h \
+	sieve.h \
+	sieve_err.h \
+	sieve_interface.h \
+	tree.h
+
+pkglibexec_PROGRAMS = sievec sieved
+
+sievec_SOURCES = \
+	sievec.c \
+	../map.c \
+	../imparse.c
+
+sieved_SOURCES = \
+	sieved.c \
+	../map.c
+
+sievec_LDADD = \
+	libsieve.la \
+	$(top_srcdir)/src/lib/liblib.a
+
+sieved_LDADD = \
+	libsieve.la \
+	$(top_srcdir)/src/lib/liblib.a
+
+notbuilt_sources =
+
+EXTRA_DIST = \
+	addr-lex.l \
+	sieve-lex.l \
+	AUTHORS \
+	COPYING \
+	NEWS \
+	README \
+	$(notbuilt_sources)
diff -r 923786016963 src/lib-sieve/cmu/libsieve/NEWS
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/NEWS	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,84 @@
+$Id$
+
+CMU Sieve 2.1
+-------------
+
+- Compliant with RFC 3028.  As a result, fileinto and redirect only
+  accept a single string and NOT a string-list.
+
+- Compliant with draft-martin-sieve-notify-01.  As a result, notify
+  actions will need to be updated to the new syntax.
+
+CMU Sieve 2.0
+-------------
+
+- Compliant with draft-showalter-sieve-11.txt and 
+  draft-showalter-sieve-vacation-03.txt.
+
+- Added support for the regex, imapflags, notify and subaddress extensions.
+  See README for references.
+
+- Verifies email addresses in redirect and vacation actions are syntactically
+  correct (compliant with RFC822).
+
+- Run-time error reporting.
+
+- Changed callback interface to use callback contexts instead of individual
+  parameters.  Also added an error string buffer for run-time error reporting.
+
+- Vacation will not reply to any message containing an "auto-submitted"
+  header containing anything other than "no".
+
+CMU Sieve 1.4
+-------------
+
+Now included with imapd distribution (hell, why not?).
+
+Error returning and recovering:
+	added error recovering to the parser (but not much!)
+	added error messages to the parser
+
+Working on error returning and error recovering.
+	run-time errors
+	detect some errors in lexer?
+
+Working on even better parsing:
+	verify addresses could be addresses
+	verify mailboxes could be mailboxes
+	verify outgoing headers can be headers
+
+CMU Sieve 1.3
+-------------
+
+Changed for integration with cyrus deliver.
+
+CMU Sieve 1.2
+-------------
+
+Added additional callbacks (ok, so I want to make my integration with deliver
+easier) and envelope and vacation support.
+
+Made it compile without libcyrus.
+It should compile without libcyrus, but then it does not implement the
+"address" test.	 That's just too much work to do when I have a neato
+library to do it for me.
+
+Todo:
+- regex matching
+
+CMU Sieve 1.1
+-------------
+
+- Updated to draft-showalter-sieve-07bis.txt
+
+- Simple API (see sieve_interface.h; currently mostly undocumented)
+
+- Implements all of the optional features except "envelope"
+
+- Maintains "if it parses, it probably runs" behavior. (Goal: minimize
+  run-time errors.)
+
+CMU Sieve 1.0
+-------------
+
+- prototype implementation
diff -r 923786016963 src/lib-sieve/cmu/libsieve/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/README	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,59 @@
+$Id$
+
+CMU Sieve 2.1
+-------------
+
+This code is typically distributed as part of Cyrus imapd 1.6 and higher.
+This code will be configured and compiled from the cyrus-imapd directory.
+
+Notes on implementation
+-----------------------
+
+This is an implementation of a simple Sieve API.  This API is
+well-suited for incorporating in other programs, but is not
+extensible.  (If there is interest, we may implement an extensible API
+in the future.)
+
+If you wish to compile Sieve without compiling all of imapd, you'll
+have to create a Makefile for it.  I recommend you use Makefile.in as
+a guide.
+
+It should compile without libcyrus, but then it does not implement the
+"address" test.	 That's just too much work to do when I have a neato
+library to do it for me.
+
+There's a simple "test" application included, which is not built by
+default (type "make test" to build it).  It expects:
+
+test <message> <script>
+
+And prints out the actions taken or errors encountered.  (This
+implementation will attempt all the actions or no actions.)
+
+Questions and comments to:
+Derrick Brashear (shadow+sieve@andrew.cmu.edu)
+
+References:
+
+[SIEVE] Showalter, T., "Sieve: A Mail Filtering Language",
+RFC 3028, January, 2001.
+
+[VACATION] Showalter, T., "Sieve: Vacation Extension",
+draft-showalter-sieve-vacation-04.txt, August, 2000.
+
+[IMAPFLAGS] Melnikov, A., "Sieve -- IMAP flag extension",
+draft-melnikov-sieve-imapflags-03.txt, July, 2000.
+
+[NOTIFY] Martin, T., Segmuller, W.,
+"Sieve -- An extension for providing instant notifications",
+draft-martin-sieve-notify-01.txt, June, 2001.
+
+[REGEX] Murchison, K., "Sieve: Regular Expression Extension",
+draft-murchison-sieve-regex-04.txt, August, 2001.
+
+[RELATIONAL] Segmuller, W., "Sieve Extension: Relational Tests",
+RFC 3431, December 2002.
+
+[SUBADDR] Murchison, K., "Sieve Email Filtering -- Subaddress Extension",
+RFC 3598, September 2003.
+
diff -r 923786016963 src/lib-sieve/cmu/libsieve/addr-lex.l
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/addr-lex.l	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,91 @@
+%{
+/*
+ * addr-lex.l -- RFC 822 address lexer
+ * Ken Murchison
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include "addr.h"
+#include <string.h>
+
+#undef YY_INPUT
+#define YY_INPUT(b, r, ms) (r = addrinput(b, ms))
+
+int addrinput(char *buf, int max_size);
+void addrerror(const char *);
+
+static int ncom;	/* number of open comments */
+%}
+
+%option noyywrap
+%option nounput
+%option prefix="addr"
+
+%x QSTRING DOMAINLIT COMMENT
+
+%%
+
+\"				{ BEGIN QSTRING; return yytext[0]; }
+\[				{ BEGIN DOMAINLIT; return yytext[0]; }
+\(				{ ncom = 1; BEGIN COMMENT; }
+\)				{ addrerror("address parse error, "
+					  "unexpected `')'' "
+					  "(unbalanced comment)");
+				  yyterminate(); }
+
+[^\(\)<>@,;:\\".\[\] \n\r]+	return ATOM;
+
+[\t \n\r]+			/* ignore whitespace */
+.				return yytext[0];
+
+<QSTRING>([^\n\r"\\]|\\.)*	return QTEXT;
+<QSTRING>\"			{ BEGIN INITIAL; return yytext[0]; }
+
+<DOMAINLIT>([^\[\]\n\r\\]|\\.)*	return DTEXT;
+<DOMAINLIT>\]			{ BEGIN INITIAL; return yytext[0]; }
+
+<COMMENT>([^\(\)\n\0\\]|\\.)*	/* ignore comments */
+<COMMENT>\(			ncom++;
+<COMMENT>\)			{ ncom--; if (ncom == 0) BEGIN INITIAL; }
+<COMMENT><<EOF>>		{ addrerror("address parse error, "
+					  "expecting `')'' "
+					  "(unterminated comment)");
+				  yyterminate(); }
+
+%%
+
+/* take input from address string provided by sieve parser */
+int addrinput(char *buf, int max_size)
+{
+    extern char *addrptr;	/* current position in address string */
+    size_t n;			/* number of characters to read from string */
+
+    n = (int)strlen(addrptr) < max_size ? (int)strlen(addrptr) : max_size;
+    if (n > 0) {
+	memcpy(buf, addrptr, n);
+	addrptr += n;
+    }
+    return n;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/addr.y
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/addr.y	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,91 @@
+%{
+/*
+ * addr.y -- RFC 822 address parser
+ * Ken Murchison
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "addr.h"
+#include "script.h"
+#include "xmalloc.h"
+    
+int addrerror(char *msg);
+extern int yylex(void);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+%}
+
+%token ATOM QTEXT DTEXT
+
+%%
+sieve_address: addrspec			/* simple address */
+	| phrase '<' addrspec '>'	/* name & addr-spec */
+	;
+
+addrspec: localpart '@' domain		/* global-address */
+	;
+
+localpart: word				/* uninterpreted, case-preserved */
+	| word '.' localpart
+	;
+
+domain: subdomain
+	| subdomain '.' domain
+	;
+
+subdomain: domainref
+	| domainlit
+	;
+
+domainref: ATOM				/* symbolic reference */
+	;
+
+domainlit: '[' DTEXT ']'
+	;
+
+phrase: word
+	| word phrase
+	;
+
+word: ATOM
+	| qstring
+	;
+
+qstring: '"' QTEXT '"'
+	;
+
+%%
+
+/* copy address error message into buffer provided by sieve parser */
+int addrerror(char *s)
+{
+    extern char addrerr[ADDRERR_SIZE];
+    
+    strlcpy(addrerr, s, sizeof(addrerr));
+    return 0;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/bc_dump.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/bc_dump.c	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,304 @@
+/* bc_generate.c -- sieve bytecode- almost flattened bytecode
+ * Rob Siemborski
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+ 
+#include "sieve_interface.h"
+#include "bytecode.h"
+
+ 
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+#if DUMPCODE
+
+/*this would work a lot better if we actually could tell how many levels deep in if statements we were.  currently it doesn't know*/
+
+static void print_spaces(int n)
+{
+    int temp_n=0;
+    while(temp_n++ < (n))
+	putchar(' ');
+}
+
+
+/* Dump a stringlist.  Return the last address used by the list */
+static int dump_sl(bytecode_info_t *d, int ip, int level) 
+{
+    int numstr = d->data[ip].listlen;
+    int i;
+    
+    for(i=0; i<numstr; i++) {
+	print_spaces(level*4);
+	printf(" {%d}",d->data[++ip].len);
+	printf("%s\n",d->data[++ip].str);
+    }
+    
+    return ip;
+}
+
+static int dump_test(bytecode_info_t *d, int ip, int level);
+
+/* Dump a testlist.  Return the last address used by the list */
+static int dump_tl(bytecode_info_t *d, int ip, int level) 
+{
+    int numtest = d->data[ip].listlen;
+    int i;
+    
+    for(i=0; i<numtest; i++) {
+	print_spaces(level*4);
+	printf(" (until %d)\n", d->data[++ip].jump);
+	ip = dump_test(d, ++ip, level);
+    }
+    
+    return ip;
+}
+
+/* Dump a test, return the last address used by the test */
+static int dump_test(bytecode_info_t *d, int ip, int level ) {
+
+    print_spaces(level*4);
+    switch(d->data[ip].op) {
+    case BC_TRUE:
+	printf("%d: TRUE\n",ip);
+	break;
+
+    case BC_FALSE:
+	printf("%d: FALSE\n",ip);
+	break;
+
+    case BC_NOT:
+	printf("%d: NOT TEST(\n",ip++);
+	/*   printf("  (until %d)\n", d->data[ip++].jump);*/
+	ip = dump_test(d,ip, level);
+	print_spaces(level*4);
+	printf("    )\n");
+	break;
+
+    case BC_SIZE:
+	printf("%d: SIZE TAG(%d) NUM(%d)\n",ip,
+	       d->data[ip+1].value, d->data[ip+2].value);
+	ip+=2;
+	break;
+
+    case BC_EXISTS:
+	printf("%d: EXISTS\n",ip++);
+	ip = dump_sl(d,ip,level);
+	break;
+
+    case BC_ALLOF:
+	printf("%d: ALLOF (\n",ip++);
+	ip = dump_tl(d,ip,level);
+	print_spaces(level*4);
+	printf(")\n");
+	break;
+
+    case BC_ANYOF:
+	printf("%d: ANYOF (\n",ip++);
+	ip = dump_tl(d,ip, level);
+	  print_spaces(level*4);
+	printf(")\n");
+	break;
+	    
+    case BC_HEADER:
+	printf("%d: HEADER (\n",ip++);
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d  RELATION:%d  COMP:%d HEADERS:\n", 
+		   d->data[ip].value, d->data[ip+1].value,d->data[ip+2].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d HEADERS:\n",d->data[ip].value, d->data[ip+2].value);
+	}
+	ip+=3;
+	ip = dump_sl(d,ip,level);
+	ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+	
+    case BC_ADDRESS:
+    case BC_ENVELOPE:
+	printf("%d: %s (\n",ip++,
+	       d->data[ip].op == BC_ADDRESS ? "ADDRESS" : "ENVELOPE");
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d RELATION: %d COMP: %d TYPE: %d HEADERS:\n", 
+		   d->data[ip].value, d->data[ip+1].value, d->data[ip+2].value, d->data[ip+3].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d TYPE:%d HEADERS:\n",
+		   d->data[ip].value,d->data[ip+1].value,d->data[ip+3].value);
+	}
+	ip+=4;
+	ip = dump_sl(d,ip,level); ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+
+    default:
+	printf("%d: TEST(%d)\n",ip,d->data[ip].op);
+	break;
+    }
+
+    return ip;
+}
+
+void dump(bytecode_info_t *d, int level) 
+{
+    int i;
+    printf("Dumping almost flattened bytecode\n\n");
+    
+    if(!d) return;
+    
+    for(i=0; i<d->scriptend; i++) {
+	print_spaces(level*4);
+	switch(d->data[i].op) {
+	case B_REJECT:
+	    printf("%d: REJECT {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+	case B_IF:
+	    if (d->data[i+3].jump== -1)
+	    {
+		printf("%d: IF THEN(%d) POST(%d) TEST(\n",i,
+		       d->data[i+1].jump,d->data[i+2].jump);
+	    }
+	    else
+	    {
+		printf("%d: IF THEN(%d) ELSE(%d) POST(%d) TEST(\n",i,
+		       d->data[i+1].jump,d->data[i+2].jump,
+		       d->data[i+3].jump);
+	    }
+	    i = dump_test(d,i+4, level+1);
+	    printf(")\n");
+	    break;
+
+	case B_STOP:
+	    printf("%d: STOP\n",i);
+	    break;
+
+	case B_DISCARD:
+	    printf("%d: DISCARD\n",i);
+	    break;
+	    
+	case B_KEEP:
+	    printf("%d: KEEP\n",i);
+	    break;
+
+	case B_MARK:
+	    printf("%d: MARK\n",i);
+	    break;
+
+	case B_UNMARK:
+	    printf("%d: UNMARK\n",i);
+	    break;
+
+	case B_FILEINTO:
+	    printf("%d: FILEINTO {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+
+	case B_REDIRECT:
+	    printf("%d: REDIRECT {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+
+	case B_SETFLAG:
+	    printf("%d: SETFLAG\n",i);
+	    i=dump_sl(d,++i, level);
+	    break;
+
+	case B_ADDFLAG:
+	    printf("%d: ADDFLAG\n",i);
+	    i=dump_sl(d,++i,level);
+	    break;
+
+	case B_REMOVEFLAG:
+	    printf("%d: REMOVEFLAG\n",i);
+	    i=dump_sl(d,++i,level);
+	    break;
+
+	case B_DENOTIFY:
+	    printf("%d: DENOTIFY priority %d,comp %d %d  %s\n", 
+		   i,
+		   d->data[i+1].value,
+		   d->data[i+2].value,
+		   d->data[i+3].value,
+		   (d->data[i+4].len == -1 ? "[nil]" : d->data[i+5].str));
+	    i+=5;
+	    break;
+
+	case B_NOTIFY: 
+	    printf("%d: NOTIFY\n   METHOD(%s),\n   ID(%s),\n   OPTIONS",
+		   i,
+		   d->data[i+2].str,
+		   (d->data[i+3].len == -1 ? "[nil]" : d->data[i+4].str));
+	    i+=5;
+	    i=dump_sl(d,i,level);
+	    printf("   PRIORITY(%d),\n   MESSAGE({%d}%s)\n", 
+		   d->data[i+1].value, d->data[i+2].len,d->data[i+3].str);
+	    i+=3;
+	    break;
+
+	case B_VACATION:
+	    printf("%d:VACATION\n",i);
+	    i++;
+	    i=dump_sl(d,i,level);
+	    printf("SUBJ({%d}%s) MESG({%d}%s)\n DAYS(%d) MIME(%d)\n", 
+		   d->data[i+1].len, (d->data[i+1].len == -1 ? "[nil]" : d->data[i+2].str),
+		   d->data[i+3].len, (d->data[i+3].len == -1 ? "[nil]" : d->data[i+4].str),
+		   d->data[i+5].value, d->data[i+6].value);
+	    i+=6;
+	
+	    break;
+	case B_JUMP:
+	    printf("%d: JUMP HUH?  this shouldn't be here>?!",i);
+	    break;
+	case B_NULL:
+	    printf("%d: NULL\n",i);
+	    break;
+	default:
+	    printf("%d: %d\n",i,d->data[i].op);
+	    break;
+	}
+    }
+    printf("full len is: %d\n", d->scriptend);
+}
+#endif
+
diff -r 923786016963 src/lib-sieve/cmu/libsieve/bc_emit.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/bc_emit.c	Wed Mar 05 10:10:39 2008 +0100
@@ -0,0 +1,672 @@
+/* bc_emit.c -- sieve bytecode - pass 2 of the compiler
+ * Rob Siemborski
+ * Jen Smith
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xmalloc.h"
+#include "sieve_interface.h"
+
+ 
+#include "bytecode.h"
+
+#include <sys/types.h>
+#include <unistd.h>
+
+
+#if DUMPCODE
+void dump(bytecode_info_t *d);
+#endif
+
+static inline int write_int (int fd, int x)
+{
+    int y=htonl(x);
+    return (write(fd, &y, sizeof(int)));
+}
+ 
+    
+
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode  */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+/* Pad null bytes onto the end of the string we just wrote */
+/* returns -1 on failure or number of bytes written on success */
+static int align_string(int fd, int string_len) 
+{
+    /* Keep in mind that we always want to pad a string with *at least*
+     * one zero, that's why sometimes we have to pad with 4 */
+    int needed = sizeof(int) - (string_len % sizeof(int));
+    if (needed>= 0 && needed <=4)
+    {
+    	if(write(fd, "\0\0\0\0", needed) == -1) return -1;
+    }
+    return needed;
+}
+
+/*all functions keep codep up to date as they use it.
+  the amount that has been written to the file is maintained by the
+  filelen variable in bc_action_emit
+  the other bc_xxx_emit funtions keep track of how much they (and any functions they call) have written and return this value
+*/
+
+
+/* Write out a stringlist to a given file descriptor.
+ * return # of bytes written on success and -1 on error */
+
+/* stringlist: <# listitems>
+               <pos of listend (bytes)>
+               <string:(size)(aligned string)>
+*/
+static int bc_stringlist_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int len = bc->data[(*codep)++].len;
+    int i;
+    int ret;
+    int wrote = 2*sizeof(int);
+    int begin,end;
+
+    /* Write out number of items in the list */
+    if (write_int(fd, len)== -1) return -1 ;
+    
+    /* skip one spot end of list position*/
+    begin=lseek(fd,0,SEEK_CUR);
+    lseek(fd,sizeof(int),SEEK_CUR);
+    
+    /* Loop through all the items of the list, writing out length and string
+     * in sequence */
+    for(i=0; i < len; i++)
+    {
+	int datalen = bc->data[(*codep)++].len;
+	
+	if(write_int(fd, datalen) == -1) return -1;
+	wrote += sizeof(int);
+	
+	if(write(fd, bc->data[(*codep)++].str, datalen) == -1) return -1;
+	wrote += datalen;
+	
+	ret = align_string(fd,datalen);
+	if(ret == -1) return -1;
+	
+	wrote+=ret;
+    }
+    end=lseek(fd,0,SEEK_CUR);
+ 
+    /* go back and write end of list position */
+    lseek(fd,begin,SEEK_SET);
+    if(write_int(fd, end) == -1) return -1;
+
+    /* return to the end */
+    lseek(fd,end,SEEK_SET);
+    return wrote;
+}
+
+static int bc_test_emit(int fd, int *codep, bytecode_info_t *bc);
+
+/* Write out a testlist to a given file descriptor.
+ * return # of bytes written on success and -1 on error */
+static int bc_testlist_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int len = bc->data[(*codep)++].len;
+    int i;
+    int ret;
+    int begin, end;
+    int wrote = 2*sizeof(int);
+        
+    /* Write out number of items in the list */
+    if(write_int(fd, len)== -1) return -1;
+
+    /* skip one spot for end of list position*/
+    begin = lseek(fd, 0, SEEK_CUR);
+    lseek(fd, sizeof(int), SEEK_CUR);
+      
+    /* Loop through all the items of the list, writing out each
+     * test as we reach it in sequence. */
+    for(i=0; i < len; i++) {
+	int nextcodep = bc->data[(*codep)++].jump;
+	
+	ret = bc_test_emit(fd, codep, bc);
+	if(ret < 0 ) return -1;
+	
+	wrote+=ret;
+	*codep = nextcodep;
+    }
+    end = lseek(fd, 0, SEEK_CUR);
+
+    /* go back and write the end of list position */
+    lseek(fd,begin,SEEK_SET);
+    if(write_int(fd, end) == -1) return -1;
+
+    /*return to the end */
+    lseek(fd,end,SEEK_SET);
+
+    return wrote;
+}
+
+/* emit the bytecode for a test.  returns -1 on failure or size of
+ * emitted bytecode on success */
+static int bc_test_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int wrote=0;/* Relative offset to account for interleaved strings */
+    
+    
+    int ret; /* Temporary Return Value Variable */
+    
+    /* Output this opcode */
+    if(write_int(fd, bc->data[(*codep)].op) == -1)
+	return -1;
+    wrote += sizeof(int);
+    
+    switch(bc->data[(*codep)++].op) {
+    case BC_TRUE:
+    case BC_FALSE:
+	/* No parameter opcodes */
+	break;
+	
+    case BC_NOT:
+    {
+	/* Single parameter: another test */
+	ret = bc_test_emit(fd, codep, bc);
+	if(ret < 0)
+	    return -1;
+	else
+	    wrote+=ret;
+	break;
+    }
+    
+    case BC_ALLOF:
+    case BC_ANYOF:
+	/*where we jump to?*/
+	/* Just drop a testlist */
+	ret = bc_testlist_emit(fd, codep, bc);
+	if(ret < 0)
+	    return -1;
+	else
+	    wrote+=ret;
+	break;
+	
+    case BC_SIZE:
+	/* Drop tag and number */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	if(write_int(fd, bc->data[(*codep)+1].value) == -1)
+	    return -1;
+	
+	wrote += 2 * sizeof(int);
+	(*codep) += 2;
+	break;
+	
+    case BC_EXISTS:
+    {
+	int ret;
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote += ret;
+	break;
+    }
+    
+    case BC_HEADER:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;    
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/* Now drop headers */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    case BC_ADDRESS:
+    case BC_ENVELOPE:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop address part*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/* Now drop headers */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    default:
+	/* Unknown testcode? */
+	return -1;
+    }
+    return wrote;
+}
+
+/* emit the bytecode to a file descriptor given a flattened parse tree
+ * returns -1 on failure, size of emitted bytecode on success.
+ *
+ * this takes care of everything except the comparisons */
+static int bc_action_emit(int fd, int codep, int stopcodep,
+			  bytecode_info_t *bc, int filelen) 
+{
+    int len; /* Temporary Length Variable */
+    int ret; /* Temporary Return Value Variable */
+    int start_filelen = filelen;
+    int i;
+    
+    /*debugging variable to check filelen*/
+    /*int location;*/
+    
+    /*syslog(LOG_DEBUG, "entered bc_action_emit with filelen: %d", filelen);*/
+    
+    /* All non-string data MUST be sizeof(int)
+       byte alligned so the end of each string may require a pad */
+    /*
+     * Note that for purposes of jumps you must multiply codep by sizeof(int)
+     */
+    while(codep < stopcodep) {
+	/* Output this opcode */
+	if(write_int(fd, bc->data[codep].op) == -1)
+	    return -1; 
+	
+	filelen+=sizeof(int);
+	
+	switch(bc->data[codep++].op) {
+
+	case B_IF:
+	{
+	    /* IF
+	     *  test
+	     *  jump (false condition)
+	     *  then
+	     * (if there is an else) jump(finish) 
+	     * (if there is an else) else
+	     */
+
+	    int testEndLoc=-1;
+	    int testdist, thendist, elsedist;
+	    int c;
+	    
+	    int jumpFalseLoc=-1;/*this is the location that is being reserved
+				  for the first jump command
+				  we jump to the false condition of the test*/
+	    
+	    int jumpEndLoc=-1; /* this is the location that is being reserved
+				  for the optional jump command
+				  it jumps over the else statement to the end*/
+	    int jumpto=-1;
+	    int jumpop= B_JUMP;
+
+	    /*leave space to store the location of end of the test*/
+	    ret = lseek(fd, sizeof(int), SEEK_CUR);
+	    if(ret == -1) return ret;
+	    
+	    testEndLoc=filelen;
+	    filelen+=sizeof(int);
+	    
+	    /* spew the test */
+
+	    c=codep+3;
+	    testdist = bc_test_emit(fd, &c, bc);
+	    if(testdist == -1)return -1;
+	    filelen +=testdist;
+	    
+            /*store the location for hte end of the test
+	     *this is important for short circuiting of allof/anyof*/
+	    jumpto=filelen/4;
+	    if(lseek(fd, testEndLoc, SEEK_SET) == -1)
+		return -1;
+	    if(write_int(fd,jumpto) == -1)
+		return -1;
+
+	    if(lseek(fd,filelen,SEEK_SET) == -1)
+		return -1;
+
+	    /* leave space for jump */
+	    if(write_int(fd, jumpop) == -1)
+		return -1;
+	    ret = lseek(fd, sizeof(int), SEEK_CUR);
+	    if(ret == -1)
+		return ret;
+	    jumpFalseLoc=filelen+sizeof(int);
+	    
+	    filelen +=2*sizeof(int); /*jumpop + jump*/
+	    
+	    /* spew the then code */ 
+	    thendist = bc_action_emit(fd, bc->data[codep].value,
+				      bc->data[codep+1].value, bc,
+				      filelen);
+	 
+	    filelen+=thendist;
+	  	    
+	    /* there is an else case */
+	    if(bc->data[codep+2].value != -1)
+	    {
+		/* leave space for jump */
+		if(write_int(fd, jumpop) == -1)
+		    return -1;
+		ret = lseek(fd, sizeof(int), SEEK_CUR);
+		if(ret == -1)
+		    return ret;
+
+		jumpEndLoc=filelen+sizeof(int);
+		filelen+=2*sizeof(int);/*jumpop + jump*/
+	    }
+	  
+	    /*put previous jump to the end of the then code,
+	     *or the end of the jump if there is an else case */
+	    jumpto=filelen/4;
+	    if(lseek(fd, jumpFalseLoc, SEEK_SET) == -1)
+		return -1;
+	    if(write_int(fd,jumpto) == -1)
+		return -1;
+	    if(lseek(fd,filelen,SEEK_SET) == -1)
+		return -1;
+	    
+	    /* there is an else case */
+	    if(bc->data[codep+2].value != -1) {
+		/* spew the else code */
+		elsedist = bc_action_emit(fd, bc->data[codep+1].value,
+					 bc->data[codep+2].value, bc,
+					 filelen);
+	
+		filelen+=elsedist;
+		
+		/*put jump to the end of the else code*/
+	        jumpto=filelen/4;
+		if(lseek(fd, jumpEndLoc, SEEK_SET) == -1)
+		    return -1;
+		if(write_int(fd,jumpto) == -1)
+		    return -1;
+		if(lseek(fd,filelen,SEEK_SET) == -1)
+		    return -1;
+		
+		codep = bc->data[codep+2].value;
+	    } else {
+		codep = bc->data[codep+1].value;
+	    }
+	    
+	    break;
+	}
+	
+	case B_REJECT:
+	case B_FILEINTO:
+	case B_REDIRECT:
+	    /*just a string*/
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+
+	    filelen+=sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1)
+		return -1;
+
+	    filelen += len + ret;
+	    
+	    break; 
+
+	case B_SETFLAG:
+	case B_ADDFLAG:
+	case B_REMOVEFLAG:
+	    /* Dump just a stringlist */
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0)
+		return -1;
+	    filelen += ret;
+	    break;
+	    
+	case B_NOTIFY:
+	    /* method string, id string, options string list,
+	       priotity, Message String */
+	    /*method and id*/
+	    for(i=0; i<2; i++) {
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		if(len == -1)
+		{
+                    /* this will probably only happen for the id */
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{	
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1)
+			return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    /*options */
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0)
+		return -1;
+	    filelen+=ret;
+	    
+	    /*priority*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+	    
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1) return -1;
+	    
+ 	    filelen += len + ret;
+	    break;
+
+		
+	case B_DENOTIFY:
+	    /* priority num,comptype  num,relat num, comp string*/ 
+
+	    /* priority*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* comptype */
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* relational*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* comp string*/
+	    
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    
+	    if(len == -1)
+	    {
+		/* this is a nil string */
+		/* skip the null pointer and make up for it 
+		 * by adjusting the offset */
+		codep++;
+	    }
+	    else
+	    {
+		if(write(fd,bc->data[codep++].str,len) == -1)
+		    return -1;
+		
+		ret = align_string(fd, len);
+		if(ret == -1) return -1;
+		
+		filelen += len + ret;
+	    }
+	    	    break;
+	case B_VACATION:
+	    /* Address list, Subject String, Message String,
+	       Days (word), Mime (word) */
+	   
+	        /*new code-this might be broken*/
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0) return -1;
+	    filelen += ret;
+	    /*end of new code*/
+
+	    for(i=0; i<2; i++) {/*writing strings*/
+
+		/*write length of string*/
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		    
+		if(len == -1)
+		{
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{
+		    /*write string*/
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1) return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    /* Days*/
+	    if(write_int(fd,bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+            /*Mime */
+	    if(write_int(fd,bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+	    
+	    break;
+	case B_NULL:
+	case B_STOP:
+	case B_DISCARD:
+	case B_KEEP:
+	case B_MARK:
+	case B_UNMARK:
+	    /* No Parameters! */
+	    break;
+
+	default:
+	    /* Unknown opcode? */
+	    return -1;
+	}
+    }
+    return filelen - start_filelen;
+}
+
+/* spew the bytecode to disk */
+int sieve_emit_bytecode(int fd, bytecode_info_t *bc)  
+{
+    /* First output version number (4 bytes) */
+    int data = BYTECODE_VERSION;
+
+    /*this is a string, so it is happy*/
+    if(write(fd, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN) == -1)
+	return -1;
+
+    if(write_int(fd, data) == -1) return -1;
+
+#if DUMPCODE
+    dump(bc);
+#endif
+
+    /*the sizeof(int) is to account for the version # at the begining*/
+    return bc_action_emit(fd, 0, bc->scriptend, bc, sizeof(int) + BYTECODE_MAGIC_LEN);
+}
+
diff -r 923786016963 src/lib-sieve/cmu/libsieve/bc_eval.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/bc_eval.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,1146 @@
+/* bc_eval.c - evaluate the bytecode
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "message.h"
+
+#include "bytecode.h"
+
+#include "xmalloc.h"
+
+#include <string.h>
+#include <ctype.h>
+
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************EXECUTING BYTECODE******************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+
+/* Given a bytecode_input_t at the beginning of a string (the len block),
+ * return the string, the length, and the bytecode index of the NEXT
+ * item */
+int unwrap_string(bytecode_input_t *bc, int pos, const char **str, int *len)
+{
+    int local_len = ntohl(bc[pos].value);
+
+    pos++;
+    
+    if(local_len == -1) {
+	/* -1 length indicates NULL */
+	*str = NULL;
+    } else {
+	/* This cast is ugly, but necessary */
+	*str = (const char *)&bc[pos].str;
+	
+	/* Compute the next index */
+	pos += ((ROUNDUP(local_len+1))/sizeof(bytecode_input_t));
+    }
+    
+    if(len) *len = local_len;
+    
+    return pos;
+}
+
+
+/* this is used by notify to pass the options list to do_notify
+ * do_notify needs null-terminated (char *)[],
+ *  we have a stringlist, the beginning of which is pointed at by pos */
+static const char ** bc_makeArray(bytecode_input_t *bc, int *pos)
+{
+    int i;
+    const char** array;
+    int len = ntohl(bc[*pos].value);
+
+    (*pos)+=2; /* Skip # Values and Total Byte Length */
+  
+    array=(const char **)xmalloc((len+1) * sizeof(char *));
+
+    for (i=0; i<len; i++) {
+	*pos = unwrap_string(bc, *pos, &(array[i]), NULL);
+    }
+
+    array[i] = NULL;
+  
+    return array;
+}
+
+/* Compile a regular expression for use during parsing */
+static regex_t * bc_compile_regex(const char *s, int ctag,
+				  char *errmsg, size_t errsiz)
+{
+    int ret;
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+    
+    if ( (ret=regcomp(reg, s, ctag)) != 0)
+    {
+	(void) regerror(ret, reg, errmsg, errsiz);
+	free(reg);
+	return NULL;
+    }
+    return reg;
+}
+
+/* Determine if addr is a system address */
+static int sysaddr(const char *addr)
+{
+    if (!strncasecmp(addr, "MAILER-DAEMON", 13))
+	return 1;
+
+    if (!strncasecmp(addr, "LISTSERV", 8))
+	return 1;
+
+    if (!strncasecmp(addr, "majordomo", 9))
+	return 1;
+
+    if (strstr(addr, "-request"))
+	return 1;
+
+    if (!strncmp(addr, "owner-", 6))
+	return 1;
+
+    return 0;
+}
+
+/* look for myaddr and myaddrs in the body of a header - return the match */
+static char* look_for_me(char *myaddr, int numaddresses,
+			       bytecode_input_t *bc, int i, const char **body)
+{
+    char *found = NULL;
+    int l;
+    int curra,x ;
+
+    /* loop through each TO header */
+    for (l = 0; body[l] != NULL && !found; l++) {
+	void *data = NULL, *marker = NULL;
+	char *addr;
+	
+	parse_address(body[l], &data, &marker);
+
+	/* loop through each address in the header */
+	while (!found &&
+	       ((addr = get_address(ADDRESS_ALL,&data, &marker, 1))!= NULL)) {
+
+	    if (!strcasecmp(addr, myaddr)) {
+		found = xstrdup(myaddr);
+		break;
+	    }
+
+	    curra=i;
+
+	    for(x=0; x<numaddresses; x++)
+	    {
+		void *altdata = NULL, *altmarker = NULL;
+		char *altaddr;
+		const char *str;
+
+		curra = unwrap_string(bc, curra, &str, NULL);
+		
+		/* is this address one of my addresses? */
+      		parse_address(str, &altdata, &altmarker);
+
+		altaddr = get_address(ADDRESS_ALL, &altdata, &altmarker, 1);
+
+		if (!strcasecmp(addr,altaddr)) {
+		    found=xstrdup(str);
+		    break;
+		}
+
+		free_address(&altdata, &altmarker);
+	    }
+
+	}
+	free_address(&data, &marker);
+    }
+
+    return found;
+}
+ 
+/* Determine if we should respond to a vacation message */
+static int shouldRespond(void * m, sieve_interp_t *interp,
+			 int numaddresses, bytecode_input_t* bc,
+			 int i, char **from, char **to)
+{
+    const char **body;
+    char buf[128];
+    char *myaddr = NULL;
+    int l = SIEVE_OK;
+    void *data = NULL, *marker = NULL;
+    char *tmp;
+    int curra, x;
+    char *found=NULL;
+    char *reply_to=NULL;
+  
+    /* is there an Auto-Submitted keyword other than "no"? */
+    strcpy(buf, "auto-submitted");
+    if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	/* we don't deal with comments, etc. here */
+	/* skip leading white-space */
+	while (*body[0] && isspace((int) *body[0])) body[0]++;
+	if (strcasecmp(body[0], "no")) l = SIEVE_DONE;
+    }
+
+    /* is there a Precedence keyword of "junk | bulk | list"? */
+    strcpy(buf, "precedence");
+    if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	/* we don't deal with comments, etc. here */
+	/* skip leading white-space */
+	while (*body[0] && isspace((int) *body[0])) body[0]++;
+	if (!strcasecmp(body[0], "junk") ||
+	    !strcasecmp(body[0], "bulk") ||
+	    !strcasecmp(body[0], "list"))
+	    l = SIEVE_DONE;
+    }
+
+    /* Note: the domain-part of all addresses are canonicalized */
+    /* grab my address from the envelope */
+    if (l == SIEVE_OK) {
+	strcpy(buf, "to");
+	l = interp->getenvelope(m, buf, &body);
+	
+	if (body[0]) {  
+	    parse_address(body[0], &data, &marker);
+	    tmp = get_address(ADDRESS_ALL, &data, &marker, 1);
+	    myaddr = (tmp != NULL) ? xstrdup(tmp) : NULL;
+	    free_address(&data, &marker);
+	}  
+    }  
+  
+    if (l == SIEVE_OK) {
+	strcpy(buf, "from");
+	l = interp->getenvelope(m, buf, &body);
+    }
+    if (l == SIEVE_OK && body[0]) {
+	/* we have to parse this address & decide whether we
+	   want to respond to it */
+	parse_address(body[0], &data, &marker);
+	tmp = get_address(ADDRESS_ALL, &data, &marker, 1);
+	reply_to = (tmp != NULL) ? xstrdup(tmp) : NULL;
+	free_address(&data, &marker);
+
+	/* first, is there a reply-to address? */
+	if (reply_to == NULL) {
+	    l = SIEVE_DONE;
+	}
+    
+	/* first, is it from me? */
+	if (l == SIEVE_OK && !strcmp(myaddr, reply_to)) {
+	    l = SIEVE_DONE;
+	}
+   
+	/* ok, is it any of the other addresses i've
+	   specified? */
+	if (l == SIEVE_OK)
+	{
+	    curra=i;
+	    for(x=0; x<numaddresses; x++) {
+		const char *address;
+
+		curra = unwrap_string(bc, curra, &address, NULL);
+		
+		if (!strcmp(address, reply_to))
+		    l=SIEVE_DONE;
+	    }
+	}
+   
+	/* ok, is it a system address? */
+	if (l == SIEVE_OK && sysaddr(reply_to)) {
+	    l = SIEVE_DONE;
+	}
+    }
+    if (l == SIEVE_OK) {
+	/* ok, we're willing to respond to the sender.
+	   but is this message to me?  that is, is my address
+	   in the TO, CC or BCC fields? */
+	if (strcpy(buf, "to"), 
+	    interp->getheader(m, buf, &body) == SIEVE_OK)
+	    found = look_for_me(myaddr, numaddresses ,bc, i, body);
+	if (!found && (strcpy(buf, "cc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found && (strcpy(buf, "bcc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found)
+	    l = SIEVE_DONE;
+    }
+    /* ok, ok, if we got here maybe we should reply */
+    if (myaddr) free(myaddr);
+    *from=found;
+    *to=reply_to;
+    return l;
+}
+
+/* Evaluate a bytecode test */
+static int eval_bc_test(sieve_interp_t *interp, void* m,
+			bytecode_input_t * bc, int * ip)
+{
+    int res=0; 
+    int i=*ip;
+    int x,y,z;/* loop variable */
+    int list_len; /* for allof/anyof/exists */
+    int list_end; /* for allof/anyof/exists */
+    int address=0;/*to differentiate between address and envelope*/
+    comparator_t * comp=NULL;
+    void * comprock=NULL;
+    int op= ntohl(bc[i].op);
+    
+    switch(op)
+    {
+    case BC_FALSE:
+	res=0; i++; break;
+
+    case BC_TRUE:
+	res=1; i++; break;
+
+    case BC_NOT:/*2*/
+	i+=1;
+	res = eval_bc_test(interp,m, bc, &i);
+	if(res >= 0) res = !res; /* Only invert in non-error case */
+	break;
+
+    case BC_EXISTS:/*3*/
+    {
+	int headersi=i+1;
+	const char** val;
+	int currh;
+
+	res=1;
+
+	list_len=ntohl(bc[headersi].len);
+	list_end=ntohl(bc[headersi+1].value)/4;
+
+	currh=headersi+2;
+
+	for(x=0; x<list_len && res; x++)
+	{
+	    const char *str;
+
+	    currh = unwrap_string(bc, currh, &str, NULL);
+	    
+	    if(interp->getheader(m,str, &val) != SIEVE_OK)
+		res = 0;
+	}
+
+	i=list_end; /* adjust for short-circuit */
+	break;
+    }
+    case BC_SIZE:/*4*/
+    {
+	int s;
+	int sizevar=ntohl(bc[i+1].value);
+	int x=ntohl(bc[i+2].value);
+	
+	if (interp->getsize(m, &s) != SIEVE_OK)
+	    break;
+	
+	if (sizevar ==B_OVER) {
+	    /* over */
+	    res= s > x;
+	} else {
+            /* under */
+	    res= s < x;
+	}
+	i+=3;
+	break;
+    }
+    case BC_ANYOF:/*5*/
+	res = 0;
+	list_len=ntohl(bc[i+1].len);
+	list_end=ntohl(bc[i+2].len)/4;
+	i+=3;
+
+	/* need to process all of them, to ensure our instruction pointer stays
+	 * in the right place */
+	for (x=0; x<list_len && !res; x++) { 
+	    int tmp;
+	    tmp = eval_bc_test(interp,m,bc,&i);
+	    if(tmp < 0) {
+		res = tmp;
+		break;
+	    }
+	    res = res || tmp;
+	}
+
+	i = list_end; /* handle short-circuting */
+
+	break; 
+    case BC_ALLOF:/*6*/ 
+        res = 1;     
+	list_len=ntohl(bc[i+1].len);
+	list_end=ntohl(bc[i+2].len)/4;
+	i+=3;
+
+	/* return 1 unless you find one that isn't true, then return 0 */
+	for (x=0; x<list_len && res; x++) {
+	    int tmp;
+	    tmp = eval_bc_test(interp,m,bc,&i);
+	    if(tmp < 0) {
+		res = tmp;
+		break;
+	    }
+	    res = res && tmp; 
+	}
+
+	i = list_end; /* handle short-circuiting */
+	
+	break;
+    case BC_ADDRESS:/*7*/
+	address=1;
+	/* fall through */
+    case BC_ENVELOPE:/*8*/
+    {
+	const char ** val;
+	void * data=NULL;
+	void * marker=NULL;
+	char * addr;
+	int addrpart=ADDRESS_ALL;/* XXX correct default behavior?*/
+
+ 	int headersi=i+5;/* the i value for the begining of the headers */
+	int datai=(ntohl(bc[headersi+1].value)/4);
+
+	int numheaders=ntohl(bc[headersi].len);
+	int numdata=ntohl(bc[datai].len);
+
+	int currh, currd; /* current header, current data */
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int apart=ntohl(bc[i+4].value);
+	int count=0;
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, as regexps are tested at compile */
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB;
+	    }
+	}
+
+	/*find the correct comparator fcn*/
+	comp = lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+	
+	/*find the part of the address that we want*/
+	switch(apart)
+	{
+	case B_ALL:
+	    addrpart = ADDRESS_ALL; break;
+	case B_LOCALPART:
+	    addrpart = ADDRESS_LOCALPART; break;
+	case B_DOMAIN:
+	    addrpart = ADDRESS_DOMAIN; break;
+	case B_USER:
+	    addrpart = ADDRESS_USER; break;
+	case B_DETAIL:
+	    addrpart = ADDRESS_DETAIL; break;
+	default:
+	    /* this shouldn't happen with correcct bytecode */
+	    res = SIEVE_RUN_ERROR;
+	}
+
+	if(res == SIEVE_RUN_ERROR) break;
+
+	/*loop through all the headers*/
+	currh=headersi+2;
+#if VERBOSE
+	printf("about to process %d headers\n", numheaders);
+#endif
+	for (x=0; x<numheaders && !res; x++)
+	{
+	    const char *this_header;
+
+	    currh = unwrap_string(bc, currh, &this_header, NULL);
+	    
+	    /* Try the next string if we don't have this one */
+	    if(address) {
+		/* Header */
+		if(interp->getheader(m, this_header, &val) != SIEVE_OK)
+		    continue;
+#if VERBOSE
+                printf(" [%d] header %s is %s\n", x, this_header, val[0]);
+#endif
+	    } else {
+		/* Envelope */
+		if(interp->getenvelope(m, this_header, &val) != SIEVE_OK)
+		    continue;
+	    }
+	
+	    /*header exists, now to test it*/
+	    /*search through all the headers that match*/
+	    
+	    for (y=0; val[y]!=NULL && !res; y++) {
+		
+#if VERBOSE
+		printf("about to parse %s\n", val[y]);
+#endif
+		    
+		if (parse_address(val[y], &data, &marker)!=SIEVE_OK) 
+		    return 0;
+		    
+		while (!res &&
+		       (addr = get_address(addrpart, &data, &marker, 0))) {
+#if VERBOSE
+		    printf("working addr %s\n", (addr ? addr : "[nil]"));
+#endif
+			
+		    if (match == B_COUNT) {
+			count++;
+		    } else {
+			/*search through all the data*/ 
+			currd=datai+2;
+			for (z=0; z<numdata && !res; z++)
+			{
+			    const char *data_val;
+			    
+			    currd = unwrap_string(bc, currd, &data_val, NULL);
+
+			    if (isReg) {
+				reg = bc_compile_regex(data_val, ctag,
+						       errbuf, sizeof(errbuf));
+				if (!reg) {
+				    /* Oops */
+				    res=-1;
+				    goto alldone;
+				}
+
+				res |= comp(val[y], (const char *)reg,
+					    comprock);
+				free(reg);
+			    } else {
+#if VERBOSE
+				printf("%s compared to %s(from script)\n",
+				       addr, data_val);
+#endif 
+				res |= comp(addr, data_val, comprock);
+			    }
+			} /* For each data */
+		    }
+		} /* For each address */
+
+		free_address(&data, &marker);
+	    }/* For each message header */
+	    
+#if VERBOSE
+	    printf("end of loop, res is %d, x is %d (%d)\n", res, x, numheaders);
+#endif	    
+	} /* For each script header */
+     
+	if  (match == B_COUNT)
+	{
+	    sprintf(scount, "%u", count);
+	    /* search through all the data */ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    {
+		const char *data_val;
+		
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+
+		res |= comp(scount, data_val, comprock);
+	    }
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    case BC_HEADER:/*9*/
+    {
+	const char** val;
+
+	int headersi=i+4;/*the i value for the begining of hte headers*/
+	int datai=(ntohl(bc[headersi+1].value)/4);
+
+	int numheaders=ntohl(bc[headersi].len);
+	int numdata=ntohl(bc[datai].len);
+
+	int currh, currd; /*current header, current data*/
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int count=0;	
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, regexps tested at compile */ 
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag= REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag= REG_EXTENDED | REG_NOSUB;
+	    }
+     
+	}
+	
+	/*find the correct comparator fcn*/
+	comp=lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+
+	/*search through all the flags for the header*/
+	currh=headersi+2;
+	for(x=0; x<numheaders && !res; x++)
+	{
+	    const char *this_header;
+	    
+	    currh = unwrap_string(bc, currh, &this_header, NULL);
+	   
+	    if(interp->getheader(m, this_header, &val) != SIEVE_OK) {
+		continue; /*this header does not exist, search the next*/ 
+	    }
+#if VERBOSE
+	    printf ("val %s %s %s\n", val[0], val[1], val[2]);
+#endif
+	    
+	    /* search through all the headers that match */
+	    
+	    for (y=0; val[y]!=NULL && !res; y++)
+	    {
+		if  (match == B_COUNT) {
+		    count++;
+		} else {
+		    /*search through all the data*/ 
+		    currd=datai+2;
+		    for (z=0; z<numdata && !res; z++)
+		    {
+			const char *data_val;
+			
+			currd = unwrap_string(bc, currd, &data_val, NULL);
+			
+			if (isReg) {
+			    reg= bc_compile_regex(data_val, ctag, errbuf,
+						  sizeof(errbuf));
+			    if (!reg)
+			    {
+				/* Oops */
+				res=-1;
+				goto alldone;
+			    }
+			    
+			    res |= comp(val[y], (const char *)reg,
+					comprock);
+			    free(reg);
+			} else {
+			    res |= comp(val[y], data_val, comprock);
+			}
+		    }
+		}
+	    }
+	}
+	
+	if  (match == B_COUNT )
+	{
+	    sprintf(scount, "%u", count);
+	    /*search through all the data*/ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    { 	
+		const char *data_val;
+			
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+#if VERBOSE
+		printf("%d, %s \n", count, data_val);
+#endif
+		res |= comp(scount, data_val, comprock);
+	    }
+	      
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    default:
+#if VERBOSE
+	printf("WERT, can't evaluate if statement. %d is not a valid command",
+	       op);
+#endif     
+	return SIEVE_RUN_ERROR;
+    }
+    
+  
+ alldone:
+    
+    *ip=i;
+    return res;
+}
+
+/* The entrypoint for bytecode evaluation */
+int sieve_eval_bc(sieve_interp_t *i, const void *bc_in, unsigned int bc_len,
+		  void *m, sieve_imapflags_t * imapflags,
+		  action_list_t *actions,
+		  notify_list_t *notify_list,
+		  const char **errmsg)
+{
+    const char *data;
+    int ip = 0, ip_max = (bc_len/sizeof(bytecode_input_t));
+    int res=0;
+    int op;
+    int version;
+    
+    bytecode_input_t *bc = (bytecode_input_t *)bc_in;
+    
+    /* Check that we
+     * a) have bytecode
+     * b) it is atleast long enough for the magic number, the version
+     *    and one opcode */
+    if(!bc) return SIEVE_FAIL;
+    if(bc_len < (BYTECODE_MAGIC_LEN + 2*sizeof(bytecode_input_t)))
+       return SIEVE_FAIL;
+
+    if(memcmp(bc, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	*errmsg = "Not a bytecode file";
+	return SIEVE_FAIL;
+    }
+
+    ip = BYTECODE_MAGIC_LEN / sizeof(bytecode_input_t);
+
+    version= ntohl(bc[ip].op);
+
+    /* this is because there was a time where integers were not network byte
+       order.  all the scripts written then would have version 0x01 written
+       in host byte order.*/
+
+     if(version == (int)ntohl(1)) {
+	if(errmsg) {
+	    *errmsg =
+		"Incorrect Bytecode Version, please recompile (use sievec)";
+	    
+	}
+	return SIEVE_FAIL;
+    }
+    
+    if( version != BYTECODE_VERSION) {
+	if(errmsg) {
+	    *errmsg =
+		"Incorrect Bytecode Version, please recompile (use sievec)";
+	}
+	return SIEVE_FAIL;
+    }
+
+#if VERBOSE
+    printf("version number %d\n",version); 
+#endif
+
+    for(ip++; ip<ip_max; ) { 
+	op=ntohl(bc[ip].op);
+	switch(op) {
+	case B_STOP:/*0*/
+	    res=1;
+	    break;
+
+	case B_KEEP:/*1*/
+	    res = do_keep(actions, imapflags);
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Keep can not be used with Reject";
+	    ip++;
+	    break;
+
+	case B_DISCARD:/*2*/
+	    res=do_discard(actions);
+	    ip++;
+	    break;
+
+	case B_REJECT:/*3*/
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+	    
+	    res = do_reject(actions, data);
+	
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Reject can not be used with any other action";  
+
+	    break;
+
+	case B_FILEINTO:/*4*/
+	{
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+
+	    res = do_fileinto(actions, data, imapflags);
+
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Fileinto can not be used with Reject";
+
+	    break;
+	}
+
+	case B_REDIRECT:/*5*/
+	{
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+
+	    res = do_redirect(actions, data);
+
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Redirect can not be used with Reject";
+
+	    break;
+	}
+
+	case B_IF:/*6*/
+	{
+	    int testend=ntohl(bc[ip+1].value);
+	    int result;
+	   
+	    ip+=2;
+	    result=eval_bc_test(i, m, bc, &ip);
+	    
+	    if (result<0) {
+		*errmsg = "Invalid test";
+		return SIEVE_FAIL;
+	    } else if (result) {
+	    	/*skip over jump instruction*/
+		testend+=2;
+	    }
+	    ip=testend;
+	    
+	    break;
+	}
+
+	case B_MARK:/*8*/
+	    res = do_mark(actions);
+	    ip++;
+	    break;
+
+	case B_UNMARK:/*9*/
+	    res = do_unmark(actions);
+	    ip++;
+	    break;
+
+	case B_ADDFLAG:/*10*/ 
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    for (x=0; x<list_len; x++) {
+		ip = unwrap_string(bc, ip, &data, NULL);
+		
+		res = do_addflag(actions, data);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "addflag can not be used with Reject";
+	    } 
+	    break;
+	}
+
+	case B_SETFLAG:
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    ip = unwrap_string(bc, ip, &data, NULL);
+
+	    res = do_setflag(actions, data);
+
+	    if (res == SIEVE_RUN_ERROR) {
+		*errmsg = "setflag can not be used with Reject";
+	    } else {
+		for (x=1; x<list_len; x++) {
+		    ip = unwrap_string(bc, ip, &data, NULL);
+
+		    res = do_addflag(actions, data);
+
+		    if (res == SIEVE_RUN_ERROR)
+			*errmsg = "setflag can not be used with Reject";
+		} 
+	    }
+	    
+	    break;
+	}
+
+	case B_REMOVEFLAG:
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    for (x=0; x<list_len; x++) {
+		ip = unwrap_string(bc, ip, &data, NULL);
+
+		res = do_removeflag(actions, data);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "removeflag can not be used with Reject";
+	    } 
+	    break;
+	}
+
+	case B_NOTIFY:
+	{
+	    const char * id;
+	    const char * method;
+	    const char **options = NULL;
+	    const char *priority = NULL;
+	    const char * message;
+	    int pri;
+	    
+	    ip++;
+
+	    /* method */
+	    ip = unwrap_string(bc, ip, &method, NULL);
+
+	    /* id */
+	    ip = unwrap_string(bc, ip, &id, NULL);
+
+	    /*options*/
+	    options=bc_makeArray(bc, &ip); 
+
+	    /* priority */
+	    pri=ntohl(bc[ip].value);
+	    ip++;
+	    
+	    switch (pri)
+	    {
+	    case B_LOW:
+		priority="low";
+	    case B_NORMAL:
+		priority="normal";
+		break;
+	    case B_HIGH: 
+		priority="high";
+		break; 
+	    case B_ANY:
+		priority="any";
+		break;
+	    default:
+		res=SIEVE_RUN_ERROR;
+	    }
+
+	    /* message */
+	    ip = unwrap_string(bc, ip, &message, NULL);
+	  
+	    res = do_notify(notify_list, id, method, options,
+			    priority, message);
+
+	    break;
+	}
+	case B_DENOTIFY:
+	{
+         /*
+	  * i really have no idea what the count matchtype should do here.
+	  * the sanest thing would be to use 1.
+	  * however that would require passing on the match type to do_notify.
+	  *  -jsmith2
+	  */
+
+	    comparator_t *comp = NULL;
+	    
+	    const char *pattern;
+	    regex_t *reg;
+	    
+	    const char *priority = NULL;
+	    void *comprock = NULL;
+	    
+	    int comparator;
+	    int pri;
+	    
+	    ip++;
+	    pri=ntohl(bc[ip].value);
+	    ip++;
+	    
+	    switch (pri)
+	    {
+	    case B_LOW:
+		priority="low";		
+	    case B_NORMAL:
+		priority="normal";
+		break;
+	    case B_HIGH: 
+		priority="high";
+		break; 
+	    case B_ANY:
+		priority="any";
+		break;
+	    default:
+		res=SIEVE_RUN_ERROR;
+	    }
+
+	    if(res == SIEVE_RUN_ERROR)
+		break;
+	   
+	    comparator =ntohl( bc[ip].value);
+	    ip++;
+	    
+	    if (comparator == B_ANY)
+	    { 
+		ip++;/* skip placeholder this has no comparator function */
+		comp=NULL;
+	    } else {
+		int x= ntohl(bc[ip].value);
+		ip++;
+		
+		comp=lookup_comp(B_ASCIICASEMAP,comparator,
+				 x, &comprock);
+	    }
+	    
+	    ip = unwrap_string(bc, ip, &pattern, NULL);
+	  
+	    if (comparator == B_REGEX)
+	    {	
+		char errmsg[1024]; /* Basically unused */
+		
+		reg=bc_compile_regex(pattern,
+				     REG_EXTENDED | REG_NOSUB | REG_ICASE,
+				     errmsg, sizeof(errmsg));
+		if (!reg) {
+		    res = SIEVE_RUN_ERROR;
+		} else {
+		    res = do_denotify(notify_list, comp, reg,
+				      comprock, priority);
+		    free(reg);
+		}
+	    } else {
+		res = do_denotify(notify_list, comp, pattern,
+				  comprock, priority);
+	    }
+	    
+	    break;
+	}
+	case B_VACATION:
+	{
+	    int respond;
+	    char *fromaddr = NULL; /* relative to message we send */
+	    char *toaddr = NULL; /* relative to message we send */
+	    const char *message = NULL;
+	    char buf[128];
+	    char subject[1024];
+	    int x;
+	    
+	    ip++;
+
+	    x=ntohl( bc[ip].len);
+	    
+	    respond=shouldRespond(m, i, x, bc, ip+2,
+				  &fromaddr, &toaddr);
+	    
+	    ip=(ntohl(bc[ip+1].value)/4);	
+	    if (respond==SIEVE_OK)
+	    {	 
+		ip = unwrap_string(bc, ip, &data, NULL);
+		
+		if (!data) 
+		{
+		    /* we have to generate a subject */
+		    const char **s;	    
+		    strlcpy(buf, "subject", sizeof(buf));
+		    if (i->getheader(m, buf, &s) != SIEVE_OK ||
+			s[0] == NULL) {
+			strlcpy(subject, "Automated reply", sizeof(subject));
+		    } else {
+			/* s[0] contains the original subject */
+			const char *origsubj = s[0];
+
+			while (!strncasecmp(origsubj, "Re: ", 4)) 
+			    origsubj += 4;
+
+			snprintf(subject, sizeof(subject), "Re: %s", origsubj);
+		    }
+		} else {
+		    /* user specified subject */
+		    strlcpy(subject, data, sizeof(subject));
+		}
+		
+		ip = unwrap_string(bc, ip, &message, NULL);
+
+		res = do_vacation(actions, toaddr, fromaddr,
+				  xstrdup(subject), message,
+				  ntohl(bc[ip].value), ntohl(bc[ip+1].value));
+
+		ip+=2;		
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "Vacation can not be used with Reject or Vacation";
+	    } else if (respond == SIEVE_DONE) {
+                /* skip subject and message */
+
+		ip = unwrap_string(bc, ip, &data, NULL);
+		ip = unwrap_string(bc, ip, &data, NULL);
+
+		ip+=2;/*skip days and mime flag*/
+	    } else {
+		res = SIEVE_RUN_ERROR; /* something is bad */ 
+	    }
+
+	    break;
+	}
+	case B_NULL:/*15*/
+	    ip++;
+	    break;
+
+	case B_JUMP:/*16*/
+	    ip= ntohl(bc[ip+1].jump);
+	    break;
+	    
+	default:
+	    if(errmsg) *errmsg = "Invalid sieve bytecode";
+	    return SIEVE_FAIL;
+	}
+      
+	if (res) /* we've either encountered an error or a stop */
+	    break;
+    }
+    return res;      
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/bc_generate.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/bc_generate.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,708 @@
+/* bc_generate.c -- sieve bytecode- almost flattened bytecode
+ * Rob Siemborski
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xmalloc.h"
+#include "sieve_interface.h"
+
+#include "script.h"
+#include "tree.h"
+#include "sieve.h"
+
+#include "bytecode.h"
+
+#include <assert.h>
+#include <string.h>
+
+
+
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+static int bc_test_generate(int codep, bytecode_info_t *retval, test_t *t);
+
+/* returns false if the request can't be satisfied, true if it can. */
+
+static int atleast(bytecode_info_t *arr, size_t len) 
+{
+    if(arr->reallen < len) {
+	/* too small; double if that's big enough, otherwise increase to the
+	   requested size. */
+	arr->reallen = (len > arr->reallen * 2 ? len : arr->reallen * 2);
+	arr->data = xrealloc(arr->data, arr->reallen*sizeof(bytecode_t));
+	if(!arr->data) 
+	{ /* out of memory? */
+	    return 0;
+	}
+    }
+    
+    return 1;
+}
+
+/*
+ * functions of the form bc_XXX_generate have the following properties:
+ * on success they return an int that corresponds to the next empty location
+ * for code, and on failure they return -1.
+ *
+ *  they will take a  bytecode_info_t as a parameter and modify it by
+ *  making it larger and adding more bytecommands in the pass 1 form
+ */
+
+/* given a location and a string list, compile it into almost-flat form.
+ * <list len> <string len><string ptr><string len><string ptr> etc... */
+static int bc_stringlist_generate(int codep, bytecode_info_t *retval,
+				  stringlist_t *sl) 
+{
+    int len_codep = codep;
+    int strcount = 0;
+    stringlist_t *cur;
+    
+    codep++;
+
+    /* Bounds check the string list length */
+    if(!atleast(retval,codep+1)) 
+	return -1;
+
+    for(cur=sl; cur; cur=cur->next) 
+    {
+	strcount++;
+	assert((cur->s)!=NULL);
+	
+	/* Bounds check for each string before we allocate it */
+	if(!atleast(retval,codep+2)) 
+	    return -1;
+
+	retval->data[codep++].len = strlen(cur->s);
+	retval->data[codep++].str = cur->s;
+    }
+    
+    retval->data[len_codep].listlen = strcount;
+    return codep;
+}
+
+
+/* write a list of tests into almost-flat form, starting at codep.
+ * returns the next code location, -1 on error. */
+
+/* <list len> <next test ptr> <test ...> <next test ptr> <test ...> ... */
+static int bc_testlist_generate(int codep, bytecode_info_t *retval, 
+				testlist_t *tl) 
+{
+    int len_codep = codep;
+    int testcount = 0;
+    testlist_t *cur;
+    
+    codep++;
+
+    /* Bounds check the test list length */
+    if(!atleast(retval,codep+1)) 
+	return -1;
+       
+    for(cur=tl; cur; cur=cur->next) {
+	int oldcodep = codep;
+
+	/* Make room for tail marker */
+	if(!atleast(retval,codep+1)) 
+	    return -1;
+
+	testcount++;
+	codep = bc_test_generate(codep+1, retval, cur->t);
+
+	retval->data[oldcodep].jump = codep;
+    }
+
+    retval->data[len_codep].listlen = testcount;
+        
+    return codep;
+}
+/* output a relation into almost-flat form at codep.
+ * returns new codep on success, -1 on failure. */
+static int bc_relation_generate(int codep, bytecode_info_t *retval, int relat)
+{
+    if (!atleast(retval, codep + 1)) return -1;
+    switch (relat)
+    {
+    case GT:
+	retval->data[codep++].value= B_GT;
+	break;
+    case GE:
+	retval->data[codep++].value= B_GE;
+	break; 
+    case LT:
+	retval->data[codep++].value= B_LT;
+	break;
+    case LE:
+	retval->data[codep++].value= B_LE;
+	break;
+    case EQ:
+	retval->data[codep++].value= B_EQ;
+	break;
+    case NE:
+	retval->data[codep++].value= B_NE;
+	break;
+    default:
+	/* comparator has no relational field */
+	retval->data[codep++].value=  -1;
+	break;
+    }
+    return codep;
+}
+/* writes a single comparator into almost-flat form starting at codep.
+ * will always write out 3 words
+ * returns the next code location or -1 on error. */
+static int bc_comparator_generate(int codep, bytecode_info_t *retval,
+                                  int comptag, int relat,
+                                  const char *comparator)
+{
+    assert(retval != NULL);
+
+    /* comptag */
+    if (!atleast(retval, codep + 1)) return -1;
+
+    switch (comptag) {
+    case IS:
+        retval->data[codep++].value = B_IS;
+        break;
+    case CONTAINS:
+        retval->data[codep++].value = B_CONTAINS;
+        break;
+    case MATCHES:
+        retval->data[codep++].value = B_MATCHES;
+        break;
+#ifdef ENABLE_REGEX
+    case REGEX:
+        retval->data[codep++].value = B_REGEX;
+        break;
+#endif
+    case COUNT:
+        retval->data[codep++].value = B_COUNT;
+        break;
+    case VALUE:
+        retval->data[codep++].value = B_VALUE;
+        break;
+
+    default:
+        return -1;
+    }
+  
+    /*relation*/
+    codep = bc_relation_generate(codep, retval, relat);
+  
+    /* comparator (value specified with :comparator) */
+    if (!atleast(retval, codep + 1)) return -1;
+  
+    /* xxx perhaps extend comparator.h to have
+       lookup_comp return an index, and then
+       lookup_by_index return the actual comparator?
+       
+       we can then eliminate the comptag above, too. */
+    
+    if (!strcmp (comparator, "i;octet"))
+        retval->data[codep++].value = B_OCTET;
+    else if (!strcmp (comparator, "i;ascii-casemap"))
+        retval->data[codep++].value = B_ASCIICASEMAP;
+    else if (!strcmp (comparator, "i;ascii-numeric"))
+        retval->data[codep++].value = B_ASCIINUMERIC;
+
+    return codep;
+}
+
+
+
+/* writes a single test into almost-flat form starting at codep.
+ * returns the next code location or -1 on error. */
+static int bc_test_generate(int codep, bytecode_info_t *retval, test_t *t)
+{
+    if(!retval) return -1;
+    switch(t->type) {
+    case STRUE: /* BC_TRUE */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_TRUE;
+	break;
+    case SFALSE:/* BC_FALSE */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_FALSE;
+	break;
+    case NOT: /* BC_NOT {subtest : test} */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_NOT;
+	codep = bc_test_generate(codep, retval, t->u.t);
+	if (codep == -1) return -1;
+	break;
+    case SIZE: /* BC_SIZE (B_OVER | B_UNDER) {size : int} */
+	if(!atleast(retval,codep+3)) return -1;
+	retval->data[codep++].op = BC_SIZE;
+	retval->data[codep++].value = (t->u.sz.t == OVER
+				       ? B_OVER : B_UNDER);
+	retval->data[codep++].value = t->u.sz.n;
+	break;
+    case EXISTS:/* BC_EXISTS { headers : string list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_EXISTS;
+	codep= bc_stringlist_generate(codep, retval, t->u.sl);
+	break;
+    case ANYOF:/* BC_ANYOF { tests : test list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_ANYOF;
+	codep=bc_testlist_generate(codep, retval, t->u.tl);
+	if (codep == -1) return -1;
+	break;
+    case ALLOF: /* BC_ALLOF { tests : test list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_ALLOF;
+	codep= bc_testlist_generate(codep, retval, t->u.tl);
+	if (codep == -1) return -1;
+	break;
+    case HEADER:
+	/* BC_HEADER { c: comparator } { headers : string list }
+	   { patterns : string list } 
+	*/
+      
+	if(!atleast(retval,codep + 1)) return -1;
+	retval->data[codep++].op = BC_HEADER;
+      
+	/* comparator */
+	codep = bc_comparator_generate(codep, retval,
+				       t->u.h.comptag,
+				       t->u.h.relation,
+				       t->u.h.comparator);
+	if (codep == -1) return -1;
+      
+	/* headers */
+	codep = bc_stringlist_generate(codep, retval, t->u.h.sl);
+	if (codep == -1) return -1;
+      
+	/* pattern */
+	codep = bc_stringlist_generate(codep, retval, t->u.h.pl);
+	if (codep == -1) return -1;
+	break;
+    case ADDRESS:
+    case ENVELOPE:
+	/* (BC_ADDRESS | BC_ENVELOPE) {c : comparator} 
+	   (B_ALL | B_LOCALPART | ...) { header : string list }
+	   { pattern : string list } */
+      
+	if(!atleast(retval,codep+1)) return -1;
+      
+	retval->data[codep++].op = (t->type == ADDRESS)
+	    ? BC_ADDRESS : BC_ENVELOPE;
+            
+	codep = bc_comparator_generate(codep, retval,t->u.ae.comptag,
+				       t->u.ae.relation, 
+				       t->u.ae.comparator);
+	if (codep == -1) return -1;
+
+	if(!atleast(retval,codep+1)) return -1;
+
+	/*address part*/
+	switch(t->u.ae.addrpart) {
+	case ALL:
+	    retval->data[codep++].value = B_ALL;
+	    break;
+	case LOCALPART:
+	    retval->data[codep++].value = B_LOCALPART;
+	    break;
+	case DOMAIN:
+	    retval->data[codep++].value = B_DOMAIN;
+	    break;
+	case USER:
+	    retval->data[codep++].value = B_USER;
+	    break;
+	case DETAIL:
+	    retval->data[codep++].value = B_DETAIL;
+	    break;
+	default:
+	    return -1;
+	}
+
+	/*headers*/
+	codep = bc_stringlist_generate(codep, retval, t->u.ae.sl);
+	if (codep == -1) return -1;
+
+	/*patterns*/
+	codep = bc_stringlist_generate(codep, retval, t->u.ae.pl);
+	if (codep == -1) return -1;
+     
+	break;
+    default:
+	return -1;
+      
+    }
+    return codep;
+}
+
+
+/* generate a not-quite-flattened bytecode */
+/* returns address of next instruction or -1 on error*/
+/* needs current instruction, buffer for the code, and a current parse tree */
+/* sieve is cool because everything is immediate! */
+static int bc_action_generate(int codep, bytecode_info_t *retval,
+			      commandlist_t *c) 
+{
+    int jumploc,baseloc;
+
+    if(!retval) return -1;
+    if (c==NULL)
+    {
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = B_NULL;
+    }
+    else
+    {
+	do {
+	    switch(c->type) {
+	    case STOP:
+		/* STOP (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_STOP;
+		break;
+	    case DISCARD:
+		/* DISCARD (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_DISCARD;
+		break;
+	    case KEEP:
+		/* KEEP (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_KEEP;
+		break;
+	    case MARK:
+		/* MARK (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_MARK;
+		break;
+	    case UNMARK:
+		/* UNMARK (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_UNMARK;
+		break;
+	    case DENOTIFY:
+		/* DENOTIFY  */
+		if(!atleast(retval,codep+6)) return -1;
+		retval->data[codep++].op = B_DENOTIFY;
+		switch(c->u.d.priority) {
+		case LOW:
+		    retval->data[codep++].value = B_LOW;
+		    break;
+		case NORMAL:
+		    retval->data[codep++].value = B_NORMAL;
+		    break;
+		case HIGH:
+		    retval->data[codep++].value = B_HIGH;
+		    break;
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break;
+		default:
+		    return -1;
+		}
+		switch(c->u.d.comptag) {
+		case IS:
+		    retval->data[codep++].value = B_IS;
+		    break;
+		case CONTAINS:
+		    retval->data[codep++].value = B_CONTAINS;
+		    break;
+		case MATCHES:
+		    retval->data[codep++].value = B_MATCHES;
+		    break;
+#ifdef ENABLE_REGEX
+		case REGEX:
+		    retval->data[codep++].value = B_REGEX;
+		    break;
+#endif
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break; 
+		default:
+		    return -1;
+		}
+		codep = bc_relation_generate(codep, retval, c->u.d.relation);
+	
+		if(c->u.d.pattern)
+		{
+		    retval->data[codep++].len = strlen(c->u.d.pattern);
+		    retval->data[codep++].str = c->u.d.pattern;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		break;
+	    case REJCT:
+		/* REJECT (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_REJECT;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case FILEINTO:
+		/* FILEINTO (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_FILEINTO;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case REDIRECT:
+		/* REDIRECT (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_REDIRECT;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case ADDFLAG:
+		/* ADDFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_ADDFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case SETFLAG:
+		/* SETFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_SETFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case REMOVEFLAG:
+		/* REMOVEFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_REMOVEFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case NOTIFY:
+		/* NOTIFY 
+		   (STRING: len + dataptr)
+		   (STRING: len + dataptr)
+		   stringlist
+		   (STRING: len + dataptr)
+		   (STRING: len + dataptr)
+		   method/id /options list/priority/message 
+		*/
+			
+		if(!atleast(retval,codep+5)) return -1;
+		retval->data[codep++].op = B_NOTIFY;
+		
+		retval->data[codep++].len = strlen(c->u.n.method);
+		retval->data[codep++].str = c->u.n.method;
+				
+		if (c->u.n.id)
+		{
+		    retval->data[codep++].len = strlen(c->u.n.id);
+		    retval->data[codep++].str = c->u.n.id;
+		}
+		else
+		{
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+		
+		codep = bc_stringlist_generate(codep,retval,c->u.n.options);
+		if(codep == -1) return -1;
+
+		if(!atleast(retval,codep+3)) return -1;
+
+		switch(c->u.n.priority) {
+		case LOW:
+		    retval->data[codep++].value = B_LOW;
+		    break;
+		case NORMAL:
+		    retval->data[codep++].value = B_NORMAL;
+		    break;
+		case HIGH:
+		    retval->data[codep++].value = B_HIGH;
+		    break;
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break;
+		default:
+		    return -1;
+		}
+		
+		retval->data[codep++].len = strlen(c->u.n.message);
+		retval->data[codep++].str = c->u.n.message;
+		break;
+	    case VACATION:
+		/* VACATION
+		   STRINGLIST addresses
+		   STRING subject (if len is -1, then subject was NULL)
+		   STRING message (again, len == -1 means subject was NULL)
+		   VALUE days
+		   VALUE mime
+		*/
+
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_VACATION;
+	    
+		codep = bc_stringlist_generate(codep,retval,c->u.v.addresses);
+		if (codep == -1) return -1;
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.subject) {
+		    retval->data[codep++].len = strlen(c->u.v.subject);
+		    retval->data[codep++].str = c->u.v.subject;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.message) {
+		    retval->data[codep++].len = strlen(c->u.v.message);
+		    retval->data[codep++].str = c->u.v.message;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		retval->data[codep++].value = c->u.v.days;
+		retval->data[codep++].value = c->u.v.mime;
+	    
+
+		if(codep == -1) return -1;
+		break;
+	    case IF:
+	    {
+		int jumpVal; 	    
+		/* IF
+		   (int: begin then block)
+		   (int: end then block/begin else block)
+		   (int:end else block) (-1 if no else block)
+		   (test)
+		   (then block)
+		   (else block)(optional)
+		*/
+		baseloc = codep;
+	    
+		/* Allocate operator + jump table offsets */
+		if(!atleast(retval,codep+4)) return -1;
+		
+		jumploc = codep+4;
+		retval->data[codep++].op = B_IF;
+		    
+		/* begining of then  code */
+		jumpVal= bc_test_generate(jumploc,retval,c->u.i.t);
+		if(jumpVal == -1) 
+		    return -1;
+		else {
+		    retval->data[codep].jump = jumpVal;
+		    codep++;
+		}
+	    
+		/* find then code and offset to else code,
+		 * we want to write this code starting at the offset we
+		 * just found */
+	
+		jumpVal= bc_action_generate(jumpVal,retval, c->u.i.do_then);
+		if(jumpVal == -1) 
+		    return -1;
+		else 
+		    retval->data[codep].jump = jumpVal;
+		
+		codep++;
+		/* write else code if its there*/
+		if(c->u.i.do_else) {
+	
+		    jumpVal= bc_action_generate(jumpVal,retval, c->u.i.do_else);
+		    if(jumpVal == -1) 
+		    {
+			return -1;
+		    } else 
+		    {
+			retval->data[codep].jump = jumpVal;
+		    }
+		    
+		    /* Update code pointer to end of else code */
+		    codep = retval->data[codep].jump;
+		} else {
+		    /*there is no else block, so its -1*/
+		    retval->data[codep].jump = -1;
+		    /* Update code pointer to end of then code */
+		    codep = retval->data[codep-1].jump;
+		}
+	    
+		break;
+	    }
+	    default:
+		/* no such action known */
+		return -1;
+	    }
+	  
+	    /* generate from next command */
+	    c = c->next;
+	} while(c);
+    }
+    /*scriptend may be updated before the end, but it will be updated at the end, which is what matters.*/
+    retval->scriptend=codep;
+    return codep;
+   
+}
+
+
+
+/* Entry point to the bytecode emitter module */	
+int sieve_generate_bytecode(bytecode_info_t **retval, sieve_script_t *s) 
+{
+    commandlist_t *c;
+
+    if(!retval) return -1;
+    if(!s) return -1;
+    c = s->cmds;
+    /* if c is NULL, it is handled in bc_action_generate and a script
+       with only BC_NULL is returned
+    */
+
+    
+    *retval = xmalloc(sizeof(bytecode_info_t));
+    if(!(*retval)) return -1;
+
+    memset(*retval, 0, sizeof(bytecode_info_t));
+
+    return bc_action_generate(0, *retval, c);
+}
+
+
+void sieve_free_bytecode(bytecode_info_t **p) 
+{
+    if(!p || !*p) return;
+    if((*p)->data) free((*p)->data);
+    free(*p);
+    *p = NULL;
+}
+ 
diff -r 923786016963 src/lib-sieve/cmu/libsieve/bytecode.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/bytecode.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,193 @@
+/* bytecode.h -- bytecode definition
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+#ifndef SIEVE_BYTECODE_H
+#define SIEVE_BYTECODE_H
+
+
+/* for debugging*/
+#define DUMPCODE 0
+#define VERBOSE 0
+
+/*for finding correctly aligned bytes on strings*/
+/* bump to the next multiple of 4 bytes */
+#define ROUNDUP(num) (((num) + 3) & 0xFFFFFFFC)
+
+
+/* yes, lots of these are superfluous, it's for clarity */
+typedef union 
+{
+    int op; /* OPTYPE */
+    int value;
+
+    int jump;
+
+    int listlen;
+
+    /* store strings (need 2 consecutive bytecodes) */
+    int len;
+    char *str;
+} bytecode_t;
+
+/* For sanity during input on 64-bit platforms.
+ * str should only be accessed as (char *)&str, but given the use of
+ * unwrap_string, this should be OK */
+typedef union 
+{
+    int op; /* OPTYPE */
+    int value;
+
+    int jump;
+
+    int listlen;
+
+    /* store strings (need 2 consecutive bytecodes) */
+    int len;
+    int str;
+} bytecode_input_t;
+
+
+   /*version 0x01 scripts were written in host byte order.
+   we don't want to use this version number again and cause a mess
+   this isn't a huge concern, since this is version ntohl(1), or 16777216*/
+#define BYTECODE_VERSION 0x03
+#define BYTECODE_MAGIC "CyrSBytecode"
+#define BYTECODE_MAGIC_LEN 12 /* Should be multiple of 4 */
+
+/* IMPORTANT: To maintain forward compatibility of bytecode, please only add
+ * new instructions to the end of these enums.  (The reason these values
+ * are all duplicated here is to avoid silliness if this caveat is forgotten
+ * about in the other tables.) */
+enum bytecode {
+    B_STOP,
+
+    B_KEEP,
+    B_DISCARD,
+    B_REJECT,/* require reject*/
+    B_FILEINTO,/*require fileinto*/
+    B_REDIRECT,
+
+    B_IF,
+  
+    B_MARK,/* require imapflags */
+    B_UNMARK,/* require imapflags */
+
+    B_ADDFLAG,/* require imapflags */
+    B_SETFLAG,/* require imapflags */
+    B_REMOVEFLAG,/* require imapflags */
+
+    B_NOTIFY,/* require notify */
+    B_DENOTIFY,/* require notify */
+
+    B_VACATION,/* require vacation*/
+    B_NULL,
+    B_JUMP
+};
+
+enum bytecode_comps {
+    BC_FALSE,
+    BC_TRUE,
+    BC_NOT,
+    BC_EXISTS,
+    BC_SIZE,
+    BC_ANYOF,
+    BC_ALLOF,
+    BC_ADDRESS,
+    BC_ENVELOPE,  /* require envelope*/
+    BC_HEADER    
+};
+
+/* currently one enum so as to help determine where values are being misused.
+ * we have left placeholders incase we need to add more later to the middle */
+enum bytecode_tags {
+    /* Sizes */
+    B_OVER,
+    B_UNDER,
+
+    B_SIZE_PLACEHOLDER_1,
+    B_SIZE_PLACEHOLDER_2,
+     
+    /* sizes, pt 2 */
+    B_GT, /* require relational*/
+    B_GE,  /* require relational*/
+    B_LT,  /* require relational*/
+    B_LE,  /* require relational*/
+    B_EQ,  /* require relational*/
+    B_NE,  /* require relational*/
+ 
+    B_RELATIONAL_PLACEHOLDER_1,
+    B_RELATIONAL_PLACEHOLDER_2,
+   
+    /* priorities */
+    B_LOW,
+    B_NORMAL,
+    B_HIGH,
+    B_ANY,
+
+    B_PRIORITY_PLACEHOLDER_1,
+    B_PRIORITY_PLACEHOLDER_2,
+    B_PRIORITY_PLACEHOLDER_3,
+    B_PRIORITY_PLACEHOLDER_4,
+    
+    /* Address Part Tags */
+    B_ALL,
+    B_LOCALPART,
+    B_DOMAIN,
+    B_USER,  /* require subaddress */
+    B_DETAIL, /* require subaddress */
+    
+    B_ADDRESS_PLACEHOLDER_1,
+    B_ADDRESS_PLACEHOLDER_2,
+    B_ADDRESS_PLACEHOLDER_3,
+    B_ADDRESS_PLACEHOLDER_4,
+
+    /* Comparators */
+    B_ASCIICASEMAP,
+    B_OCTET,
+    B_ASCIINUMERIC, /* require comparator-i;ascii-numeric */
+    
+    B_COMPARATOR_PLACEHOLDER_1,
+    B_COMPARATOR_PLACEHOLDER_2,
+    B_COMPARATOR_PLACEHOLDER_3,
+    B_COMPARATOR_PLACEHOLDER_4,
+ 
+    /* match types */
+    B_IS,
+    B_CONTAINS,
+    B_MATCHES,
+    B_REGEX,/* require regex*/
+    B_COUNT,/* require relational*/
+    B_VALUE,/* require relational*/
+
+    B_MATCH_PLACEHOLDER_1,
+    B_MATCH_PLACEHOLDER_2,
+    B_MATCH_PLACEHOLDER_3,
+    B_MATCH_PLACEHOLDER_4
+  
+};
+
+int unwrap_string(bytecode_input_t *bc, int pos, const char **str, int *len);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/comparator.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/comparator.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,448 @@
+/* comparator.c -- comparator functions
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "xmalloc.h"
+#include "comparator.h"
+#include "tree.h"
+#include "sieve.h"
+#include "bytecode.h"
+
+/*!!! uses B_CONTAINS not CONTAINS, etc, only works with bytecode*/
+
+extern int strcasecmp(const char *, const char *);
+
+typedef int (*compare_t)(const void *, const void *);
+
+/* --- relational comparators --- */
+
+/* these are generic wrappers in which 'rock' is the compare function */
+
+static int rel_eq(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) == 0);
+}
+
+static int rel_ne(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) != 0);
+}
+
+static int rel_gt(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) > 0);
+}
+
+static int rel_ge(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) >= 0);
+}
+
+static int rel_lt(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) < 0);
+}
+
+static int rel_le(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) <= 0);
+}
+
+/* --- i;octet comparators --- */
+
+/* just compare the two; these should be NULL terminated */
+static int octet_cmp(const char *text, const char *pat)
+{
+    size_t sl;
+    int r;
+
+    sl = strlen(text) < strlen(pat) ? strlen(text) : strlen(pat);
+
+    r = memcmp(text, pat, sl);
+
+    if (r == 0)
+	return (strlen(text) - strlen(pat));
+    else 
+	return r;
+}
+
+/* we implement boyer-moore for hell of it, since this is probably
+ not very useful for sieve */
+#if 0
+int boyer_moore(char *text, char *pat)
+{
+    int i, j; /* indexes */
+    int M = strlen(pat); /* length of pattern */
+    int N = strlen(text); /* length of text */
+    int skip[256]; /* table of how much to skip, based on each character */
+
+    /* initialize skip table */
+    for (i = 0; i < 256; i++)
+	skip[i] = M;
+    for (i = 0; i < M; i++)
+	skip[(int) pat[i]] = M-i-1;
+    
+    /* look for pat in text */
+    i = j = M-1;
+    do {
+	if (pat[j] == text[i]) {
+	    i--;
+	    j--;
+	} else {
+	    if (M-j > skip[(int) text[i]]) {
+		i = i + M - j;
+	    } else {
+		i = i + skip[(int) text[i]];
+	    }
+	    j = M-1;
+	}
+    } while (!((j < 0) || (i >= N)));
+    /* i+1 is the position of the match if i < N */
+    return (i < N) ? 1 : 0;
+}
+#endif
+
+/* we do a brute force attack */
+static int octet_contains(const char *text, const char *pat, 
+                          void *rock __attr_unused__)
+{
+    return (strstr(text, pat) != NULL);
+}
+
+static int octet_matches_(const char *text, const char *pat, int casemap)
+{
+    const char *p;
+    const char *t;
+    char c;
+
+    t = text;
+    p = pat;
+    for (;;) {
+	if (*p == '\0') {
+	    /* ran out of pattern */
+	    return (*t == '\0');
+	}
+	c = *p++;
+	switch (c) {
+	case '?':
+	    if (*t == '\0') {
+		return 0;
+	    }
+	    t++;
+	    break;
+	case '*':
+	    while (*p == '*' || *p == '?') {
+		if (*p == '?') {
+		    /* eat the character now */
+		    if (*t == '\0') {
+			return 0;
+		    }
+		    t++;
+		}
+		/* coalesce into a single wildcard */
+		p++;
+	    }
+	    if (*p == '\0') {
+		/* wildcard at end of string, any remaining text is ok */
+		return 1;
+	    }
+
+	    while (*t != '\0') {
+		/* recurse */
+		if (octet_matches_(t, p, casemap)) return 1;
+		t++;
+	    }
+	case '\\':
+	    p++;
+	    /* falls through */
+	default:
+	    if (casemap && (toupper(c) == toupper(*t))) {
+		t++;
+	    } else if (!casemap && (c == *t)) {
+		t++;
+	    } else {
+		/* literal char doesn't match */
+		return 0;
+	    }
+	}
+    }
+    /* never reaches */
+    abort();
+}
+
+static int octet_matches(const char *text, const char *pat, 
+                         void *rock __attr_unused__)
+{
+    return octet_matches_(text, pat, 0);
+}
+
+
+#ifdef ENABLE_REGEX
+static int octet_regex(const char *text, const char *pat, 
+                       void *rock __attr_unused__)
+{
+    return (!regexec((regex_t *) pat, text, 0, NULL, 0));
+}
+#endif
+
+
+/* --- i;ascii-casemap comparators --- */
+
+
+/* use strcasecmp() as the compare function */
+
+/* sheer brute force */
+static int ascii_casemap_contains(const char *text, const char *pat,
+				  void *rock __attr_unused__)
+{
+    int N = strlen(text);
+    int M = strlen(pat);
+    int i, j;
+
+    i = 0, j = 0;
+    while ((j < M) && (i < N)) {
+              if (toupper(text[i]) == toupper(pat[j])) {
+	  	  i++; j++;
+	} else {
+	    i = i - j + 1;
+	    j = 0;
+	}
+    }    
+
+    return (j == M); /* we found a match! */
+}
+
+static int ascii_casemap_matches(const char *text, const char *pat, 
+                                 void *rock __attr_unused__)
+{
+    return octet_matches_(text, pat, 1);
+}
+
+/* i;ascii-numeric; only supports relational tests
+ *
+ *  A \ B    number   not-num 
+ *  number   A ? B    B > A 
+ *  not-num  A > B    A == B
+ */
+
+ /* From RFC 2244:
+  *
+  * The i;ascii-numeric comparator interprets strings as decimal
+  * positive integers represented as US-ASCII digits.  All values
+  * which do not begin with a US-ASCII digit are considered equal
+  * with an ordinal value higher than all non-NIL single-valued
+  * attributes.  Otherwise, all US-ASCII digits (octet values
+  * 0x30 to 0x39) are interpreted starting from the beginning of
+  * the string to the first non-digit or the end of the string.
+  */
+
+static int ascii_numeric_cmp(const char *text, const char *pat)
+{
+    unsigned text_digit_len;
+    unsigned pat_digit_len;
+
+    if (isdigit((int) *pat)) {
+	if (isdigit((int) *text)) {
+	    /* Count how many digits each string has */
+	    for (text_digit_len = 0;
+		 isdigit((int) text[text_digit_len]);
+		 text_digit_len++);
+	    for (pat_digit_len = 0;
+		 isdigit((int) pat[pat_digit_len]);
+		 pat_digit_len++);
+
+	    if (text_digit_len < pat_digit_len) {
+		/* Pad "text" with leading 0s */
+		while (pat_digit_len > text_digit_len) {
+		    /* "text" can only be less or equal to "pat" */
+		    if ('0' < *pat) {
+			return (-1); 
+		    }
+		    pat++;
+		    pat_digit_len--;
+		}
+	    } else if (text_digit_len > pat_digit_len) {
+		/* Pad "pad" with leading 0s */
+		while (text_digit_len > pat_digit_len) {
+		    /* "pad" can only be greater or equal to "text" */
+		    if (*text > '0') {
+			return 1;
+		    }
+		    text++;
+		    text_digit_len--;
+		}
+	    }
+
+	    /* CLAIM: If we here, we have two non-empty digital suffixes
+	       of equal length */
+	    while (text_digit_len > 0) {
+		if (*text < *pat) {
+			return -1;
+		} else if (*text > *pat) {
+			return 1;
+		}
+		/* Characters are equal, carry on */
+		text++;
+		pat++;
+		text_digit_len--;
+	    }
+
+	    return (0);
+	} else {
+	    return 1;
+	}
+    } else if (isdigit((int) *text)) {
+	return -1;
+    } else {
+	return 0; /* both not digits */
+    }
+}
+
+static comparator_t *lookup_rel(int relation)
+{
+    comparator_t *ret;
+
+    ret = NULL;
+    switch (relation)
+      {
+      case B_EQ:
+	ret = &rel_eq;
+	break;
+      case B_NE:
+	ret = &rel_ne; 
+	break;
+      case B_GT: 
+	ret = &rel_gt; 
+	break;
+      case B_GE:
+         ret = &rel_ge; 
+	 break;
+      case B_LT:
+	ret = &rel_lt; 
+	break;
+      case B_LE:
+	ret = &rel_le; 
+      }
+
+    return ret;
+}
+
+comparator_t *lookup_comp(int comp, int mode, int relation,
+			  void **comprock)
+{
+    comparator_t *ret;
+
+    ret = NULL;
+    *comprock = NULL;
+#if VERBOSE
+    printf("comp%d mode%d relat%d     \n", comp, mode, relation); 
+#endif
+    switch (comp)
+      {
+      case B_OCTET:    
+ 	switch (mode) {
+	  case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &octet_cmp;
+	    break;
+	  case B_CONTAINS:
+	    ret = &octet_contains;
+	    break;
+	  case B_MATCHES:
+	    ret = &octet_matches;
+	    break;
+#ifdef ENABLE_REGEX
+	  case B_REGEX:
+	    ret = &octet_regex;
+	    break;
+#endif
+	  case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &octet_cmp;
+	    break;
+	}
+	break; /*end of octet */
+      case B_ASCIICASEMAP:
+     	switch (mode) {
+	case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &strcasecmp;
+	    break;
+	case B_CONTAINS:
+	    ret = &ascii_casemap_contains;
+	    break;
+	case B_MATCHES:
+	    ret = &ascii_casemap_matches;
+	    break;
+#ifdef ENABLE_REGEX
+	case B_REGEX:
+	    /* the ascii-casemap destinction is made during
+	       the compilation of the regex in verify_regex() */
+	    ret = &octet_regex;
+	    break;
+#endif
+	case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = &strcasecmp;
+	    break;
+	}
+	break;/*end of ascii casemap */
+      case B_ASCIINUMERIC:
+	switch (mode) {
+	case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &ascii_numeric_cmp;
+	    break;
+	case B_COUNT:
+	case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &ascii_numeric_cmp;
+	    break;
+	}
+	break;
+      }
+    return ret;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/comparator.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/comparator.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,48 @@
+/* comparator.h
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef COMPARATOR_H
+#define COMPARATOR_H
+
+#ifdef ENABLE_REGEX
+#ifdef HAVE_RX
+#include <rxposix.h>
+#else
+#include <sys/types.h>
+#include <regex.h>
+#endif
+#endif
+
+/* compares pat to text; returns 1 if it's true, 0 otherwise 
+   first arg is text, second arg is pat, third arg is rock */
+typedef int comparator_t(const char *, const char *, void *);
+
+/* returns a pointer to a comparator function given it's name */
+comparator_t *lookup_comp(int comp, int mode,
+			  int relation, void **rock);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/interp.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/interp.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,203 @@
+/* interp.c -- sieve script interpretor builder
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "xmalloc.h"
+
+#include "sieve_interface.h"
+#include "interp.h"
+
+/* build a sieve interpretor */
+int sieve_interp_alloc(sieve_interp_t **interp, void *interp_context)
+{
+    sieve_interp_t *i;
+    static int initonce;
+
+    if (!initonce) {
+	initialize_siev_error_table();
+	initonce = 1;
+    }
+
+    *interp = NULL;
+    i = (sieve_interp_t *) xmalloc(sizeof(sieve_interp_t));
+    if (i == NULL) {
+	return SIEVE_NOMEM;
+    }
+
+    i->redirect = i->discard = i->reject = i->fileinto = i->keep = NULL;
+    i->getsize = NULL;
+    i->getheader = NULL;
+    i->getenvelope = NULL;
+    i->vacation = NULL;
+    i->notify = NULL;
+
+    i->markflags = NULL;
+
+    i->interp_context = interp_context;
+    i->err = NULL;
+
+    *interp = i;
+    return SIEVE_OK;
+}
+
+static const char *sieve_extensions = "fileinto reject envelope vacation"
+                                      " imapflags notify subaddress relational"
+                                      " comparator-i;ascii-numeric"
+#ifdef ENABLE_REGEX
+" regex";
+#else
+"";
+#endif /* ENABLE_REGEX */
+
+const char *sieve_listextensions(void)
+{
+    return sieve_extensions;
+}
+
+int sieve_interp_free(sieve_interp_t **interp)
+{
+    free(*interp);
+    
+    return SIEVE_OK;
+}
+
+/* add the callbacks */
+int sieve_register_redirect(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->redirect = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_discard(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->discard = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_reject(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->reject = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_fileinto(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->fileinto = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_keep(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->keep = f;
+ 
+    return SIEVE_OK;
+}
+
+static char *default_markflags[] = { "\\flagged" };
+static sieve_imapflags_t default_mark = { default_markflags, 1 };
+
+int sieve_register_imapflags(sieve_interp_t *interp, sieve_imapflags_t *mark)
+{
+    interp->markflags =
+	(mark && mark->flag && mark->nflags) ? mark : &default_mark;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_notify(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->notify = f;
+ 
+    return SIEVE_OK;
+}
+
+/* add the callbacks for messages. again, undefined if used after
+   sieve_script_parse */
+int sieve_register_size(sieve_interp_t *interp, sieve_get_size *f)
+{
+    interp->getsize = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_header(sieve_interp_t *interp, sieve_get_header *f)
+{
+    interp->getheader = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_envelope(sieve_interp_t *interp, sieve_get_envelope *f)
+{
+    interp->getenvelope = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_vacation(sieve_interp_t *interp, sieve_vacation_t *v)
+{
+    if (!interp->getenvelope) {
+	return SIEVE_NOT_FINALIZED; /* we need envelope for vacation! */
+    }
+
+    if (v->min_response == 0) v->min_response = 3;
+    if (v->max_response == 0) v->max_response = 90;
+    if (v->min_response < 0 || v->max_response < 7 || !v->autorespond
+	|| !v->send_response) {
+	return SIEVE_FAIL;
+    }
+
+    interp->vacation = v;
+    return SIEVE_OK;
+}
+
+int sieve_register_parse_error(sieve_interp_t *interp, sieve_parse_error *f)
+{
+    interp->err = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_execute_error(sieve_interp_t *interp, sieve_execute_error *f)
+{
+    interp->execute_err = f;
+    return SIEVE_OK;
+}
+
+int interp_verify(sieve_interp_t *i)
+{
+    if (i->redirect && i->keep && i->getsize && i->getheader) {
+	return SIEVE_OK;
+    } else {
+	return SIEVE_NOT_FINALIZED;
+    }
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/interp.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/interp.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,56 @@
+/* interp.h -- interpretor definition
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+#ifndef SIEVE_INTERP_H
+#define SIEVE_INTERP_H
+
+#include "sieve_interface.h"
+
+struct sieve_interp {
+    /* standard callbacks for actions */
+    sieve_callback *redirect, *discard, *reject, *fileinto, *keep;
+    sieve_callback *notify;
+    sieve_vacation_t *vacation;
+
+    sieve_get_size *getsize;
+    sieve_get_header *getheader;
+    sieve_get_envelope *getenvelope;
+
+    sieve_parse_error *err;
+
+    /* site-specific imapflags for mark/unmark */
+    sieve_imapflags_t *markflags;
+
+    sieve_execute_error *execute_err;
+
+    /* context to pass along */
+    void *interp_context;
+};
+
+int interp_verify(sieve_interp_t *interp);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/message.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/message.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,580 @@
+/* message.c -- message parsing functions
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "message.h"
+#include "parseaddr.h"
+#include "xmalloc.h"
+
+/* reject message m with message msg
+ *
+ * incompatible with: fileinto, redirect
+ */
+int do_reject(action_list_t *a, const char *msg)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_FILEINTO ||
+	    a->a == ACTION_KEEP ||
+	    a->a == ACTION_REDIRECT ||
+	    a->a == ACTION_REJECT ||
+	    a->a == ACTION_VACATION ||
+	    a->a == ACTION_SETFLAG ||
+	    a->a == ACTION_ADDFLAG ||
+	    a->a == ACTION_REMOVEFLAG ||
+	    a->a == ACTION_MARK ||
+	    a->a == ACTION_UNMARK
+	    )
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REJECT;
+    a->u.rej.msg = msg;
+    b->next = a;
+    a->next =  NULL;
+    return 0;
+}
+
+/* fileinto message m into mailbox 
+ *
+ * incompatible with: reject
+ */
+int do_fileinto(action_list_t *a, const char *mbox,
+		sieve_imapflags_t *imapflags)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_FILEINTO;
+    a->u.fil.mailbox = mbox;
+    a->u.fil.imapflags = imapflags;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* redirect message m to to addr
+ *
+ * incompatible with: reject
+ */
+int do_redirect(action_list_t *a, const char *addr)
+{
+    action_list_t *b = NULL;
+
+    /* xxx we should validate addr */
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REDIRECT;
+    a->u.red.addr = addr;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* keep message
+ *
+ * incompatible with: reject
+ */
+int do_keep(action_list_t *a, sieve_imapflags_t *imapflags)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	if (a->a == ACTION_KEEP) /* don't bother doing it twice */
+	    return 0;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_KEEP;
+    a->u.keep.imapflags = imapflags;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* discard message m
+ *
+ * incompatible with: nothing---it doesn't cancel any actions
+ */
+int do_discard(action_list_t *a)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_DISCARD) /* don't bother doing twice */
+	    return 0;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_DISCARD;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+int do_vacation(action_list_t *a, char *addr, char *fromaddr,
+		char *subj, const char *msg, int days,
+		int mime)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT ||
+	    a->a == ACTION_VACATION) /* vacation can't be used twice */
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_VACATION;
+    a->u.vac.send.addr = addr;
+    a->u.vac.send.fromaddr = fromaddr;
+    a->u.vac.send.subj = subj;	/* user specified subject */
+    a->u.vac.send.msg = msg;
+    a->u.vac.send.mime = mime;
+    a->u.vac.autoresp.days = days;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* setflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_setflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_SETFLAG;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* addflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_addflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_ADDFLAG;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* removeflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_removeflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REMOVEFLAG;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+
+/* mark message m
+ *
+ * incompatible with: reject
+ */
+int do_mark(action_list_t *a)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_MARK;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+
+/* unmark message m
+ *
+ * incompatible with: reject
+ */
+int do_unmark(action_list_t *a)
+{
+
+    action_list_t *b = NULL;
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_UNMARK;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* notify
+ *
+ * incompatible with: none
+ */
+int do_notify(notify_list_t *a, const char *id,
+	      const char *method, const char **options,
+	      const char *priority, const char *message)
+{
+    notify_list_t *b = NULL;
+
+    /* find the end of the notify list */
+    while (a != NULL) {
+	b = a;
+	a = a->next;
+    }
+
+    /* add to the notify list */
+    a = (notify_list_t *) xmalloc(sizeof(notify_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+
+    b->next = a;
+    a->isactive = 1;
+    a->id = id;
+    a->method = method;
+    a->options = options;
+    a->priority = priority;
+    a->message = message;
+    a->next = NULL;
+    return 0;
+}
+
+/* denotify
+ *
+ * incomaptible with: none
+ */
+int do_denotify(notify_list_t *n, comparator_t *comp, const void *pat,
+		void *comprock, const char *priority)
+{
+    while (n != NULL) {
+	if (n->isactive && 
+	    (!priority || !strcasecmp(n->priority, priority)) &&
+	    (!comp || (n->id && comp(n->id, pat, comprock)))) {
+	    n->isactive = 0;
+	}
+	n = n->next;
+    }
+
+    return 0;
+}
+
+
+
+/* given a header, extract an address out of it.  if marker points to NULL,
+   extract the first address.  otherwise, it's an index into the header to
+   say where to start extracting */
+struct addr_marker {
+    struct address *where;
+    char *freeme;
+};
+
+int parse_address(const char *header, void **data, void **marker)
+{
+    struct addr_marker *am = (struct addr_marker *) *marker;
+
+    parseaddr_list(header, (struct address **) data);
+    am = (void *) xmalloc(sizeof(struct addr_marker));
+    am->where = *data;
+    am->freeme = NULL;
+    *marker = am;
+    return SIEVE_OK;
+}
+
+char *get_address(address_part_t addrpart,
+		  void **data __attr_unused__,
+		  void **marker,
+		  int canon_domain)
+{
+    char *ret = NULL;
+    struct address *a;
+    struct addr_marker *am = *marker;
+
+    a = am->where;
+    if (am->freeme) {
+	free(am->freeme);
+	am->freeme = NULL;
+    }
+
+    if (a == NULL) {
+	ret = NULL;
+    } else {
+	if (canon_domain && a->domain)
+	    lcase(a->domain);
+
+	switch (addrpart) { 
+	case ADDRESS_ALL:
+#define U_DOMAIN "unspecified-domain"
+#define U_USER "unknown-user"
+	    if (a->mailbox || a->domain) {
+		char *m = a->mailbox ? a->mailbox : U_USER;
+		char *d = a->domain ? a->domain : U_DOMAIN;
+		am->freeme = (char *) xmalloc(strlen(m) + strlen(d) + 2);
+
+		sprintf(am->freeme, "%s@%s", m, d);
+		ret = am->freeme;
+	    } else {
+		ret = NULL;
+	    }
+	    break;
+
+	case ADDRESS_LOCALPART:
+	    ret = a->mailbox;
+	    break;
+	    
+	case ADDRESS_DOMAIN:
+	    ret = a->domain;
+	    break;
+
+	case ADDRESS_USER:
+	    if (a->mailbox) {
+		char *p = strchr(a->mailbox, '+');
+		int len = p ? p - a->mailbox : (int)strlen(a->mailbox);
+
+		am->freeme = (char *) xmalloc(len + 1);
+		strncpy(am->freeme, a->mailbox, len);
+		am->freeme[len] = '\0';
+		ret = am->freeme;
+	    } else {
+		ret = NULL;
+	    }
+	    break;
+
+	case ADDRESS_DETAIL:
+	    if (a->mailbox)
+	    {	    
+		char *p = strchr(a->mailbox, '+');
+		ret = (p ? p + 1 : NULL);
+	    }
+	    else
+	    {
+		ret = NULL;
+	    }
+	    break;
+	}
+	a = a->next;
+	am->where = a;
+    }
+    *marker = am;
+    return ret;
+}
+
+int free_address(void **data, void **marker)
+{
+    struct addr_marker *am = (struct addr_marker *) *marker;
+
+    if (*data)
+	parseaddr_free((struct address *) *data);
+    *data = NULL;
+    if (am->freeme) free(am->freeme);
+    free(am);
+    *marker = NULL;
+    return SIEVE_OK;
+}
+
+notify_list_t *new_notify_list(void)    
+{
+    notify_list_t *ret = xmalloc(sizeof(notify_list_t));
+
+    if (ret != NULL) {
+	ret->isactive = 0;
+	ret->id       = NULL;
+	ret->method   = NULL;
+	ret->options  = NULL;
+	ret->priority = NULL;
+	ret->message  = NULL;
+	ret->next     = NULL;
+    }
+    return ret;
+}
+
+void free_notify_list(notify_list_t *n)
+{
+    while (n) {
+	notify_list_t *b = n->next;
+	free(n->options); /* strings live in bytecode, only free the array */
+	free(n);
+	n = b;
+    }
+}
+
+action_list_t *new_action_list(void)
+{
+    action_list_t *ret = xmalloc(sizeof(action_list_t));
+
+    if (ret != NULL) {
+	ret->a = ACTION_NONE;
+	ret->param = NULL;
+	ret->next = NULL;
+    }
+    return ret;
+}
+
+void free_action_list(action_list_t *a)
+{
+    while (a) {
+	action_list_t *b = a->next;
+
+	if(a->a == ACTION_VACATION) {
+	    if(a->u.vac.send.subj) free(a->u.vac.send.subj);
+	    if(a->u.vac.send.addr) free(a->u.vac.send.addr);
+	    if(a->u.vac.send.fromaddr) free(a->u.vac.send.fromaddr);
+	}
+
+	free(a);
+	a = b;
+    }
+}
+
diff -r 923786016963 src/lib-sieve/cmu/libsieve/message.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/message.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,140 @@
+/* message.h
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef MESSAGE_H
+#define MESSAGE_H
+
+#include "sieve_interface.h"	/* for action contexts */
+#include "tree.h"		/* for stringlist_t */
+
+typedef struct Action action_list_t;
+
+typedef enum {
+    ACTION_NULL = -1,
+    ACTION_NONE = 0,
+    ACTION_REJECT,
+    ACTION_FILEINTO,
+    ACTION_KEEP,
+    ACTION_REDIRECT,
+    ACTION_DISCARD,
+    ACTION_VACATION,
+    ACTION_SETFLAG,
+    ACTION_ADDFLAG,
+    ACTION_REMOVEFLAG,
+    ACTION_MARK,
+    ACTION_UNMARK,
+    ACTION_NOTIFY,
+    ACTION_DENOTIFY
+} action_t;
+
+/* information */
+action_list_t *new_action_list(void);
+void free_action_list(action_list_t *actions);
+
+/* invariant: always have a dummy element when free_action_list, param
+   and vac_subj are freed.  none of the others are automatically freed.
+
+   the do_action() functions should copy param */
+struct Action {
+    action_t a;
+    union {
+	sieve_reject_context_t rej;
+	sieve_fileinto_context_t fil;
+	sieve_keep_context_t keep;
+	sieve_redirect_context_t red;
+	struct {
+	    /* addr, fromaddr, subj - freed! */
+	    sieve_send_response_context_t send;
+	    sieve_autorespond_context_t autoresp;
+	} vac;
+	struct {
+	    const char *flag;
+	} fla;
+    } u;
+    char *param;		/* freed! */
+    struct Action *next;
+    char *vac_subj;		/* freed! */
+    char *vac_msg;
+    int vac_days;
+};
+
+typedef struct notify_list_s {
+    int isactive;
+    const char *id;
+    const char *method;
+    const char **options;
+    const char *priority;
+    const char *message;
+    struct notify_list_s *next;
+} notify_list_t;
+
+/* header parsing */
+typedef enum {
+    ADDRESS_ALL,
+    ADDRESS_LOCALPART,
+    ADDRESS_DOMAIN,
+    ADDRESS_USER,
+    ADDRESS_DETAIL
+} address_part_t;
+
+int parse_address(const char *header, void **data, void **marker);
+char *get_address(address_part_t addrpart, void **data, void **marker,
+		  int canon_domain);
+int free_address(void **data, void **marker);
+notify_list_t *new_notify_list(void);
+void free_notify_list(notify_list_t *n);
+
+/* actions; return negative on failure.
+ * these don't actually perform the actions, they just add it to the
+ * action list */
+int do_reject(action_list_t *m, const char *msg);
+int do_fileinto(action_list_t *m, const char *mbox,
+		sieve_imapflags_t *imapflags);
+int do_redirect(action_list_t *m, const char *addr);
+int do_keep(action_list_t *m, sieve_imapflags_t *imapflags);
+int do_discard(action_list_t *m);
+int do_vacation(action_list_t *m, char *addr, char *fromaddr,
+		char *subj, const char *msg, int days, int mime);
+int do_setflag(action_list_t *m, const char *flag);
+int do_addflag(action_list_t *m, const char *flag);
+int do_removeflag(action_list_t *m, const char *flag);
+int do_mark(action_list_t *m);
+int do_unmark(action_list_t *m);
+int do_notify(notify_list_t *n, const char *id,
+	      const char *method, const char **options,
+	      const char *priority, const char *message);
+int do_denotify(notify_list_t *n, comparator_t *comp, const void *pat,
+		void *comprock, const char *priority);
+
+/* execute some bytecode */
+int sieve_eval_bc(sieve_interp_t *i, const void *bc_in, unsigned int bc_len,
+		  void *m, sieve_imapflags_t * imapflags,
+		  action_list_t *actions,
+		  notify_list_t *notify_list,
+		  const char **errmsg);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/parseaddr.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/parseaddr.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,370 @@
+/* parseaddr.c -- RFC 822 address parser
+ * $Id$
+ *
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "parseaddr.h"
+
+#define xmalloc malloc
+#define xstrdup strdup
+
+static char parseaddr_unspecified_domain[] = "unspecified-domain";
+
+static void parseaddr_append (struct address ***addrpp, char *name,
+				char *route, char *mailbox, char *domain,
+				char **freemep);
+static int parseaddr_phrase (char **inp, char **phrasep, char *specials);
+static int parseaddr_domain (char **inp, char **domainp, char **commmentp);
+static int parseaddr_route (char **inp, char **routep);
+
+/*
+ * Parse an address list in 's', appending address structures to
+ * the list pointed to by 'addrp'.
+ */
+void
+parseaddr_list(str, addrp)
+const char *str;
+struct address **addrp;
+{
+    char *s;
+    int ingroup = 0;
+    char *freeme;
+    int tok = ' ';
+    char *phrase, *route, *mailbox, *domain, *comment;
+
+    /* Skip down to the tail */
+    while (*addrp) {
+	addrp = &(*addrp)->next;
+    }
+
+    s = freeme = xstrdup(str);
+
+    while (tok) {
+	tok = parseaddr_phrase(&s, &phrase, ingroup ? ",@<;" : ",@<:");
+	switch (tok) {
+	case ',':
+	case '\0':
+	case ';':
+	    if (*phrase) {
+		parseaddr_append(&addrp, 0, 0, phrase, "", &freeme);
+	    }
+	    if (tok == ';') {
+		parseaddr_append(&addrp, 0, 0, 0, 0, &freeme);
+		ingroup = 0;
+	    }
+	    continue;
+
+	case ':':
+	    parseaddr_append(&addrp, 0, 0, phrase, 0, &freeme);
+	    ingroup++;
+	    continue;
+
+	case '@':
+	    tok = parseaddr_domain(&s, &domain, &comment);
+	    parseaddr_append(&addrp, comment, 0, phrase, domain, &freeme);
+	    continue;
+
+	case '<':
+	    tok = parseaddr_phrase(&s, &mailbox, "@>");
+	    if (tok == '@') {
+		route = 0;
+		if (!*mailbox) {
+		    *--s = '@';
+		    tok = parseaddr_route(&s, &route);
+		    if (tok != ':') {
+			parseaddr_append(&addrp, phrase, route, "", "", &freeme);
+			while (tok && tok != '>') tok = *s++;
+			continue;
+		    }
+		    tok = parseaddr_phrase(&s, &mailbox, "@>");
+		    if (tok != '@') {
+			parseaddr_append(&addrp, phrase, route, mailbox, "",
+					 &freeme);
+			continue;
+		    }
+		}
+		tok = parseaddr_domain(&s, &domain, 0);
+		parseaddr_append(&addrp, phrase, route, mailbox, domain,
+				 &freeme);
+		while (tok && tok != '>') tok = *s++;
+		continue; /* effectively auto-inserts a comma */
+	    }
+	    else {
+		parseaddr_append(&addrp, phrase, 0, mailbox, "", &freeme);
+	    }
+	}
+    }
+    if (ingroup) parseaddr_append(&addrp, 0, 0, 0, 0, &freeme);
+
+    if (freeme) free(freeme);
+}
+
+/*
+ * Free the address list 'addr'
+ */
+void
+parseaddr_free(addr)
+struct address *addr;
+{
+    struct address *next;
+
+    while (addr) {
+	if (addr->freeme) free(addr->freeme);
+	next = addr->next;
+	free((char *)addr);
+	addr = next;
+    }
+}
+
+/*
+ * Helper function to append a new address structure to and address list.
+ */
+static void
+parseaddr_append(addrpp, name, route, mailbox, domain, freemep)
+struct address ***addrpp;
+char *name;
+char *route;
+char *mailbox;
+char *domain;
+char **freemep;
+{
+    struct address *newaddr;
+
+    newaddr = (struct address *)xmalloc(sizeof(struct address));
+    if (name && *name) {
+	newaddr->name = name;
+    }
+    else {
+	newaddr->name = 0;
+    }
+
+    if (route && *route) {
+	newaddr->route = route;
+    }
+    else {
+	newaddr->route = 0;
+    }
+
+    newaddr->mailbox = mailbox;
+
+    if (domain && !*domain) {
+	domain = parseaddr_unspecified_domain;
+    }
+    newaddr->domain = domain;
+
+    newaddr->next = 0;
+    newaddr->freeme = *freemep;
+    *freemep = 0;
+
+    **addrpp = newaddr;
+    *addrpp = &newaddr->next;
+}
+
+/* Macro to skip white space and rfc822 comments */
+
+#define SKIPWHITESPACE(s) \
+{ \
+    int _c, _comment = 0; \
+ \
+    while ((_c = *(s))) { \
+	if (_c == '(') { \
+	    _comment = 1; \
+	    (s)++; \
+	    while ((_comment && (_c = *(s)))) { \
+		(s)++; \
+		if (_c == '\\' && *(s)) (s)++; \
+		else if (_c == '(') _comment++; \
+		else if (_c == ')') _comment--; \
+	    } \
+	    (s)--; \
+	} \
+	else if (!isspace(_c)) break; \
+	(s)++; \
+    } \
+}
+
+/*
+ * Parse an RFC 822 "phrase", stopping at 'specials'
+ */
+static int parseaddr_phrase(inp, phrasep, specials)
+char **inp;
+char **phrasep;
+char *specials;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+
+    SKIPWHITESPACE(src);
+
+    *phrasep = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (c == '\"') {
+	    while ((c = *src)) {
+		src++;
+		if (c == '\"') break;
+		if (c == '\\') {
+		    if (!(c = *src)) break;
+		    src++;
+		}
+		*dst++ = c;
+	    }
+	}
+	else if (isspace(c) || c == '(') {
+	    src--;
+	    SKIPWHITESPACE(src);
+	    *dst++ = ' ';
+	}
+	else if (!c || strchr(specials, c)) {
+	    if (dst > *phrasep && dst[-1] == ' ') dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+	else {
+	    *dst++ = c;
+	}
+    }
+}
+
+/*
+ * Parse a domain.  If 'commentp' is non-nil, parses any trailing comment
+ */
+static int parseaddr_domain(inp, domainp, commentp)
+char **inp;
+char **domainp;
+char **commentp;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+    char *cdst;
+    int comment;
+
+    if (commentp) *commentp = 0;
+    SKIPWHITESPACE(src);
+
+    *domainp = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (isalnum(c) || c == '-' || c == '[' || c == ']' || c == ':') {
+	    *dst++ = c;
+	    if (commentp) *commentp = 0;
+	}
+	else if (c == '.') {
+	    if (dst > *domainp && dst[-1] != '.') *dst++ = c;
+	    if (commentp) *commentp = 0;
+	}
+	else if (c == '(') {
+	    if (commentp) {
+		*commentp = cdst = src;
+		comment = 1;
+		while (comment && (c = *src)) {
+		    src++;
+		    if (c == '(') comment++;
+		    else if (c == ')') comment--;
+		    else if (c == '\\' && (c = *src)) src++;
+
+		    if (comment) *cdst++ = c;
+		}
+		*cdst = '\0';
+	    }
+	    else {
+		src--;
+		SKIPWHITESPACE(src);
+	    }
+	}
+	else if (!isspace(c)) {
+	    if (dst > *domainp && dst[-1] == '.') dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+    }
+}
+	
+/*
+ * Parse a source route (at-domain-list)
+ */
+static int parseaddr_route(inp, routep)
+char **inp;
+char **routep;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+
+    SKIPWHITESPACE(src);
+
+    *routep = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (isalnum(c) || c == '-' || c == '[' || c == ']' ||
+	    c == ',' || c == '@') {
+	    *dst++ = c;
+	}
+	else if (c == '.') {
+	    if (dst > *routep && dst[-1] != '.') *dst++ = c;
+	}
+	else if (isspace(c) || c == '(') {
+	    src--;
+	    SKIPWHITESPACE(src);
+	}
+	else {
+	    while (dst > *routep &&
+		   (dst[-1] == '.' || dst[-1] == ',' || dst[-1] == '@')) dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+    }
+}
+
diff -r 923786016963 src/lib-sieve/cmu/libsieve/parseaddr.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/parseaddr.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,69 @@
+/* parseaddr.h -- RFC 822 address parser
+ $Id$
+ 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+
+#ifndef INCLUDED_PARSEADDR_H
+#define INCLUDED_PARSEADDR_H
+
+#ifndef P
+#ifdef __STDC__
+#define P(x) x
+#else
+#define P(x) ()
+#endif
+#endif
+
+struct address {
+    char *name;
+    char *route;
+    char *mailbox;
+    char *domain;
+    struct address *next;
+    char *freeme;		/* If non-nil, free */
+};
+
+extern void parseaddr_list P((const char *s, struct address **addrp));
+extern void parseaddr_free P((struct address *addr));
+
+
+#endif /* INCLUDED_PARSEADDR_H */
diff -r 923786016963 src/lib-sieve/cmu/libsieve/script.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/script.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,814 @@
+/* script.c -- sieve script functions
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <assert.h>
+
+#include "xmalloc.h"
+
+#include "md5.h"
+#include "sieve_interface.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+#include "map.h"
+#include "sieve.h"
+#include "message.h"
+#include "bytecode.h"
+
+/* does this interpretor support this requirement? */
+int script_require(sieve_script_t *s, char *req)
+{
+    if (!strcmp("fileinto", req)) {
+	if (s->interp.fileinto) {
+	    s->support.fileinto = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("reject", req)) {
+	if (s->interp.reject) {
+	    s->support.reject = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("envelope", req)) {
+	if (s->interp.getenvelope) {
+	    s->support.envelope = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("vacation", req)) {
+	if (s->interp.vacation) {
+	    s->support.vacation = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("imapflags", req)) {
+	if (s->interp.markflags->flag) {
+	    s->support.imapflags = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("notify",req)) {
+	if (s->interp.notify) {
+	    s->support.notify = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+#ifdef ENABLE_REGEX
+    } else if (!strcmp("regex", req)) {
+	s->support.regex = 1;
+	return 1;
+#endif
+    } else if (!strcmp("subaddress", req)) {
+	s->support.subaddress = 1;
+	return 1;
+    } else if (!strcmp("relational", req)) {
+	s->support.relational = 1;
+	return 1;
+    } else if (!strcmp("comparator-i;octet", req)) {
+	return 1;
+    } else if (!strcmp("comparator-i;ascii-casemap", req)) {
+	return 1;
+    } else if (!strcmp("comparator-i;ascii-numeric", req)) {
+	s->support.i_ascii_numeric = 1;
+	return 1;
+    }
+    return 0;
+}
+
+/* given an interpretor and a script, produce an executable script */
+int sieve_script_parse(sieve_interp_t *interp, FILE *script,
+		       void *script_context, sieve_script_t **ret)
+{
+    sieve_script_t *s;
+    int res = SIEVE_OK;
+    extern int yylineno;
+
+    res = interp_verify(interp);
+    if (res != SIEVE_OK) {
+	return res;
+    }
+
+    s = (sieve_script_t *) xmalloc(sizeof(sieve_script_t));
+    s->interp = *interp;
+    s->script_context = script_context;
+    /* clear all support bits */
+    memset(&s->support, 0, sizeof(struct sieve_support));
+
+    s->err = 0;
+
+    yylineno = 1;		/* reset line number */
+    s->cmds = sieve_parse(s, script);
+    if (s->err > 0) {
+	if (s->cmds) {
+	    free_tree(s->cmds);
+	}
+	s->cmds = NULL;
+	res = SIEVE_PARSE_ERROR;
+    }
+
+    *ret = s;
+    return res;
+}
+
+static void free_imapflags(sieve_imapflags_t *imapflags)
+{
+    while (imapflags->nflags)
+	free(imapflags->flag[--imapflags->nflags]);
+    free(imapflags->flag);
+    
+    imapflags->flag = NULL;
+}
+  
+int sieve_script_free(sieve_script_t **s)
+{
+    if (*s) {
+	if ((*s)->cmds) {
+	    free_tree((*s)->cmds);
+	}
+	free(*s);
+    }
+
+    return SIEVE_OK;
+}
+ 
+#define GROW_AMOUNT 100
+
+static void add_header(sieve_interp_t *i, int isenv, char *header, 
+		       void *message_context, char **out, 
+		       int *outlen, int *outalloc)
+{
+    const char **h;
+    int addlen;
+    /* get header value */
+    if (isenv)
+	i->getenvelope(message_context, header, &h);	
+    else
+	i->getheader(message_context, header, &h);	
+
+    if (!h || !h[0])
+	return;
+
+    addlen = strlen(h[0]) + 1;
+
+    /* realloc if necessary */
+    if ( (*outlen) + addlen >= *outalloc)
+    {
+	*outalloc = (*outlen) + addlen + GROW_AMOUNT;
+	*out = xrealloc(*out, *outalloc);
+    }
+
+    /* add header value */
+    strcat(*out,h[0]);
+
+    *outlen += addlen;
+}
+
+static int fillin_headers(sieve_interp_t *i, const char *msg, 
+			  void *message_context, char **out, int *outlen)
+{
+    int allocsize = GROW_AMOUNT;
+    const char *c;
+    int n;
+
+    *out = xmalloc(GROW_AMOUNT);
+    *outlen = 0;
+    (*out)[0]='\0';
+
+    if (msg == NULL) return SIEVE_OK;
+
+    /* construct the message */
+    c = msg;
+    while (*c) {
+	/* expand variables */
+	if (!strncasecmp(c, "$from$", 6)) {
+	    add_header(i, 0 ,"From", message_context, out, outlen, &allocsize);
+	    c += 6;
+	}
+	else if (!strncasecmp(c, "$env-from$", 10)) {
+	    add_header(i, 1, "From", message_context, out, outlen, &allocsize);
+	    c += 10;
+	}
+	else if (!strncasecmp(c, "$subject$", 9)) {
+	    add_header(i, 0, "Subject", message_context, out, outlen, &allocsize);
+	    c += 9;
+	}
+	/* XXX need to do $text$ variables */
+	else {
+	    /* find length of plaintext up to next potential variable */
+	    n = strcspn(c+1, "$") + 1; /* skip opening '$' */
+	    /* realloc if necessary */
+	    if ( (*outlen) + n+1 >= allocsize) {
+		allocsize = (*outlen) + n+1 + GROW_AMOUNT;
+		*out = xrealloc(*out, allocsize);
+	    }
+	    /* copy the plaintext */
+	    strncat(*out, c, n);
+	    (*out)[*outlen+n]='\0';
+	    (*outlen) += n;
+	    c += n;
+	}
+    }
+
+    return SIEVE_OK;
+}
+
+static int sieve_addflag(sieve_imapflags_t *imapflags, const char *flag)
+{
+    int n;
+    /* search for flag already in list */
+    for (n = 0; n < imapflags->nflags; n++) {
+	if (!strcmp(imapflags->flag[n], flag))
+	    break;
+    }
+ 
+    /* add flag to list, iff not in list */
+    if (n == imapflags->nflags) {
+	imapflags->nflags++;
+	imapflags->flag =
+	    (char **) xrealloc((char *)imapflags->flag,
+			       imapflags->nflags*sizeof(char *));
+	imapflags->flag[imapflags->nflags-1] = xstrdup(flag);
+    }
+ 
+    return SIEVE_OK;
+}
+
+static int sieve_removeflag(sieve_imapflags_t *imapflags, const char *flag)
+{
+    int n;
+    /* search for flag already in list */
+    for (n = 0; n < imapflags->nflags; n++) {
+      if (!strcmp(imapflags->flag[n], flag))
+	break;
+    }
+    
+     /* remove flag from list, iff in list */
+    if (n < imapflags->nflags) 
+      {
+	free(imapflags->flag[n]);
+	imapflags->nflags--;
+	
+	for (; n < imapflags->nflags; n++)
+	  imapflags->flag[n] = imapflags->flag[n+1];
+	
+	if (imapflags->nflags)
+	  {imapflags->flag =
+	     (char **) xrealloc((char *)imapflags->flag,
+				imapflags->nflags*sizeof(char *));}
+	else
+	  {free(imapflags->flag);
+	  imapflags->flag=NULL;}
+      }
+    
+    return SIEVE_OK;
+}
+
+static int send_notify_callback(sieve_interp_t *interp, void *message_context, 
+				void * script_context, notify_list_t *notify, 
+				char *actions_string, const char **errmsg)
+{
+    sieve_notify_context_t nc;
+    char *out_msg, *build_msg;
+    int out_msglen;    
+    int ret;
+
+    assert(notify->isactive);
+
+    if (!notify->method || !notify->options ||
+	!notify->priority || !notify->message) {
+	return SIEVE_RUN_ERROR;
+    }
+
+    nc.method = notify->method;
+    nc.options = notify->options ? notify->options : NULL;
+    nc.priority = notify->priority;
+
+    fillin_headers(interp, notify->message, message_context, 
+		   &out_msg, &out_msglen);
+
+    build_msg = xmalloc(out_msglen + strlen(actions_string) + 30);
+
+    strcpy(build_msg, out_msg);
+    strcat(build_msg, "\n\n");
+    strcat(build_msg, actions_string);
+
+    nc.message = build_msg;
+
+    free(out_msg);
+
+    ret = interp->notify(&nc,
+			 interp->interp_context,
+			 script_context,
+			 message_context,
+			 errmsg);    
+
+    free(build_msg);
+
+    return ret;
+}
+
+static char *action_to_string(action_t action)
+{
+    switch(action)
+	{
+	case ACTION_REJECT: return "Reject";
+	case ACTION_FILEINTO: return "Fileinto";
+	case ACTION_KEEP: return "Keep";
+	case ACTION_REDIRECT: return "Redirect";
+	case ACTION_DISCARD: return "Discard";
+	case ACTION_VACATION: return "Vacation";
+	case ACTION_SETFLAG: return "Setflag";
+	case ACTION_ADDFLAG: return "Addflag";
+	case ACTION_REMOVEFLAG: return "Removeflag";
+	case ACTION_MARK: return "Mark";
+	case ACTION_UNMARK: return "Unmark";
+	case ACTION_NOTIFY: return "Notify";
+	case ACTION_DENOTIFY: return "Denotify";
+	default: return "Unknown";
+	}
+
+    return "Error!";
+}
+
+static char *sieve_errstr(int code)
+{
+    switch (code)
+	{
+	case SIEVE_FAIL: return "Generic Error";
+	case SIEVE_NOT_FINALIZED: return "Sieve not finalized";
+	case SIEVE_PARSE_ERROR: return "Parse error";
+	case SIEVE_RUN_ERROR: return "Run error";
+	case SIEVE_INTERNAL_ERROR: return "Internal Error";
+	case SIEVE_NOMEM: return "No memory";
+	default: return "Unknown error";
+	}
+
+    return "Error!";
+}
+
+#define HASHSIZE 16
+
+static int makehash(unsigned char hash[HASHSIZE],
+		    const char *s1, const char *s2)
+{
+    struct md5_context ctx;
+
+    md5_init(&ctx);
+    md5_update(&ctx, s1, strlen(s1));
+    md5_update(&ctx, s2, strlen(s2));
+    md5_final(&ctx, hash);
+
+    return SIEVE_OK;
+}
+
+
+/******************************bytecode functions*****************************
+ *****************************************************************************/
+
+/* Load a compiled script */
+int sieve_script_load(const char *fname, sieve_bytecode_t **ret) 
+{
+    struct stat sbuf;
+    sieve_bytecode_t *r;
+    int fd;
+   
+    if (!fname || !ret) return SIEVE_FAIL;
+    
+    fd = open(fname, O_RDONLY);
+    if (fd == -1) {
+	if (errno != ENOENT)
+	    i_error("IOERROR: can not open sieve script %s: %m", fname);
+	return SIEVE_FAIL;
+    }
+
+    if (fstat(fd, &sbuf) == -1) {
+	i_error("IOERROR: fstating sieve script %s: %m", fname);
+	close(fd);
+	return SIEVE_FAIL;
+    }
+
+    r = (sieve_bytecode_t *) xzmalloc(sizeof(sieve_bytecode_t));
+
+    r->fd = fd;
+    
+    map_refresh(fd, 1, &r->data, &r->len, sbuf.st_size, fname, "sievescript");
+
+    if ((r->len < (BYTECODE_MAGIC_LEN + 2*sizeof(bytecode_input_t))) ||
+	memcmp(r->data, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	i_error("IOERROR: not a sieve bytecode file %s", fname);
+	sieve_script_unload(&r);
+	return SIEVE_FAIL;
+    }
+
+    *ret = r;
+    return SIEVE_OK;
+}
+
+
+
+int sieve_script_unload(sieve_bytecode_t **s) 
+{
+    if(s && *s) {
+	map_free(&((*s)->data), &((*s)->len));
+	close((*s)->fd);
+	free(*s);
+	*s = NULL;
+    } 
+    /*i added this else, i'm not sure why, but this function always returned SIEVE_FAIL*/
+    else
+      return SIEVE_FAIL;
+    return SIEVE_OK;
+}
+
+
+#define ACTIONS_STRING_LEN 4096
+
+static int do_sieve_error(int ret,
+			  sieve_interp_t *interp,
+			  void *script_context,
+			  void *message_context,
+			  sieve_imapflags_t * imapflags,
+			  action_list_t *actions,
+			  notify_list_t *notify_list,
+			  /* notify_action_t *notify_action,*/
+			  int lastaction,
+			  int implicit_keep,
+			  char *actions_string,
+			  const char *errmsg
+			  ) 
+{
+   if (ret != SIEVE_OK) {
+	if (lastaction == -1) /* we never executed an action */
+	    snprintf(actions_string+strlen(actions_string),
+		     ACTIONS_STRING_LEN-strlen(actions_string),
+		     "script execution failed: %s\n",
+		     errmsg ? errmsg : sieve_errstr(ret));
+	else
+	    snprintf(actions_string+strlen(actions_string),
+		     ACTIONS_STRING_LEN-strlen(actions_string),
+		     "%s action failed: %s\n",
+		     action_to_string(lastaction),
+		     errmsg ? errmsg : sieve_errstr(ret));
+    }
+ 
+   
+    /* Process notify actions */
+    if (interp->notify && notify_list) 
+      {
+	notify_list_t *n = notify_list;
+	int notify_ret = SIEVE_OK;
+	
+	while (n != NULL) 
+	  {
+	    if (n->isactive) 
+	      {
+	      lastaction = ACTION_NOTIFY;
+	       notify_ret = send_notify_callback(interp, message_context, 
+						script_context,n,
+						actions_string, &errmsg);
+	      ret |= notify_ret;
+	      }
+	    n = n->next;
+	  }
+	
+	if (notify_list) free_notify_list(notify_list);
+	notify_list = NULL;	/* don't try any notifications again */
+	
+	
+	if (notify_ret != SIEVE_OK) 
+	  return do_sieve_error(ret, interp, script_context, message_context,
+				imapflags, actions, notify_list, lastaction,
+				implicit_keep, actions_string, errmsg);
+      
+      }
+    
+    if ((ret != SIEVE_OK) && interp->err) {
+	char buf[1024];
+	if (lastaction == -1) /* we never executed an action */
+	    sprintf(buf, "%s", errmsg ? errmsg : sieve_errstr(ret));
+	else
+	    sprintf(buf, "%s: %s", action_to_string(lastaction),
+		    errmsg ? errmsg : sieve_errstr(ret));
+ 
+	ret |= interp->execute_err(buf, interp->interp_context,
+				   script_context, message_context);
+    }
+
+    if (implicit_keep) {
+	sieve_keep_context_t keep_context;
+	int keep_ret;
+	keep_context.imapflags = imapflags;
+ 
+	lastaction = ACTION_KEEP;
+	keep_ret = interp->keep(&keep_context, interp->interp_context,
+				script_context, message_context, &errmsg);
+	ret |= keep_ret;
+        if (keep_ret == SIEVE_OK)
+            snprintf(actions_string+strlen(actions_string),
+		     sizeof(actions_string)-strlen(actions_string),
+		     "Kept\n");
+	else {
+	    implicit_keep = 0;	/* don't try an implicit keep again */
+	    return do_sieve_error(ret, interp, script_context, message_context,
+				  imapflags, actions, notify_list, lastaction,
+				  implicit_keep, actions_string, errmsg);
+	}
+    }
+
+    if (actions)
+	free_action_list(actions);
+
+    return ret;
+}
+
+
+static int do_action_list(sieve_interp_t *interp,
+			  void *script_context,
+			  void *message_context,
+			  sieve_imapflags_t *imapflags,
+			  action_list_t *actions,
+			  notify_list_t *notify_list,
+			  /* notify_action_t *notify_action,*/
+			  char *actions_string,
+			  const char *errmsg) 
+{
+    action_list_t *a;
+    action_t lastaction = -1;
+    int ret = 0;
+    int implicit_keep = 0;
+    
+    strcpy(actions_string,"Action(s) taken:\n");
+  
+    /* now perform actions attached to m */
+    a = actions;
+    implicit_keep = 1;
+    while (a != NULL) {
+	lastaction = a->a;
+	errmsg = NULL;
+	switch (a->a) {
+	case ACTION_REJECT:
+	    implicit_keep = 0;
+	    if (!interp->reject)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->reject(&a->u.rej,
+				 interp->interp_context,
+				 script_context,
+				 message_context,
+				 &errmsg);
+	    
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string), 
+			 "Rejected with: %s\n", a->u.rej.msg);
+
+	    break;
+	case ACTION_FILEINTO:
+	    implicit_keep = 0;
+	    if (!interp->fileinto)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->fileinto(&a->u.fil,
+				   interp->interp_context,
+				   script_context,
+				   message_context,
+				   &errmsg);
+
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Filed into: %s\n",a->u.fil.mailbox);
+	    break;
+	case ACTION_KEEP:
+	    implicit_keep = 0;
+	    if (!interp->keep)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->keep(&a->u.keep,
+			       interp->interp_context,
+			       script_context,
+			       message_context,
+			       &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Kept\n");
+	    break;
+	case ACTION_REDIRECT:
+	    implicit_keep = 0;
+	    if (!interp->redirect)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->redirect(&a->u.red,
+				   interp->interp_context,
+				   script_context,
+				   message_context,
+				   &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Redirected to %s\n", a->u.red.addr);
+	    break;
+	case ACTION_DISCARD:
+	    implicit_keep = 0;
+	    if (interp->discard) /* discard is optional */
+		ret = interp->discard(NULL, interp->interp_context,
+				      script_context,
+				      message_context,
+				      &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Discarded\n");
+	    break;
+
+	case ACTION_VACATION:
+	    {
+		unsigned char hash[HASHSIZE];
+
+		if (!interp->vacation)
+		    return SIEVE_INTERNAL_ERROR;
+
+		/* first, let's figure out if we should respond to this */
+		ret = makehash(hash, a->u.vac.send.addr,
+			       a->u.vac.send.msg);
+
+		if (ret == SIEVE_OK) {
+		    a->u.vac.autoresp.hash = hash;
+		    a->u.vac.autoresp.len = HASHSIZE;
+		    ret = interp->vacation->autorespond(&a->u.vac.autoresp,
+							interp->interp_context,
+							script_context,
+							message_context,
+							&errmsg);
+		}
+		if (ret == SIEVE_OK) {
+		    /* send the response */
+		    ret = interp->vacation->send_response(&a->u.vac.send,
+							  interp->interp_context,
+							  script_context, 
+							  message_context,
+							  &errmsg);
+
+		    if (ret == SIEVE_OK)
+			snprintf(actions_string+strlen(actions_string),
+				 sizeof(actions_string)-strlen(actions_string),
+				 "Sent vacation reply\n");
+
+		} else if (ret == SIEVE_DONE) {
+		    snprintf(actions_string+strlen(actions_string),
+			     sizeof(actions_string)-strlen(actions_string),
+			     "Vacation reply suppressed\n");
+
+		    ret = SIEVE_OK;
+		}
+	    
+		break;
+	    }
+
+ 
+	case ACTION_SETFLAG:
+	    free_imapflags(imapflags);
+	    ret = sieve_addflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_ADDFLAG:
+	    ret = sieve_addflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_REMOVEFLAG:
+	    ret = sieve_removeflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_MARK:
+	    {
+		int n = interp->markflags->nflags;
+
+		ret = SIEVE_OK;
+		while (n && ret == SIEVE_OK) {
+		    ret = sieve_addflag(imapflags,
+					interp->markflags->flag[--n]);
+		}
+		break;
+	    }
+	case ACTION_UNMARK:
+	  {
+	   
+		int n = interp->markflags->nflags;
+		ret = SIEVE_OK;
+		while (n && ret == SIEVE_OK) {
+		    ret = sieve_removeflag(imapflags,
+					   interp->markflags->flag[--n]);
+		}
+		break;
+	    }
+
+	case ACTION_NONE:
+	    break;
+
+	default:
+	    ret = SIEVE_INTERNAL_ERROR;
+	    break;
+	}
+	a = a->next;
+
+	if (ret != SIEVE_OK) {
+	    /* uh oh! better bail! */
+	    break;
+	}
+    }
+
+    return do_sieve_error(ret, interp, script_context, message_context, 
+			  imapflags, actions, notify_list, lastaction, 
+			  implicit_keep, actions_string, errmsg);
+}
+
+
+int sieve_execute_bytecode(sieve_bytecode_t *bc, sieve_interp_t *interp,
+			   void *script_context, void *message_context) 
+{
+    action_list_t *actions = NULL;
+    notify_list_t *notify_list = NULL;
+    /*   notify_action_t *notify_action;*/
+    action_t lastaction = -1;
+    int ret;
+    char actions_string[ACTIONS_STRING_LEN] = "";
+    const char *errmsg = NULL;
+    sieve_imapflags_t imapflags;
+    
+    if (!interp) return SIEVE_FAIL;
+
+    imapflags.flag = NULL; 
+    imapflags.nflags = 0;
+    
+    if (interp->notify)
+    {
+	notify_list = new_notify_list();
+	if (notify_list == NULL)
+	    {
+		ret = SIEVE_NOMEM;
+		return do_sieve_error(ret, interp, script_context,
+				      message_context, &imapflags,
+				      actions, notify_list, lastaction, 0,
+				      actions_string, errmsg);
+	    }
+    }
+
+    actions = new_action_list();
+    if (actions == NULL) 
+    {
+	ret = SIEVE_NOMEM;
+	return do_sieve_error(ret, interp, script_context,
+			      message_context, &imapflags,
+			      actions, notify_list, lastaction, 0,
+			      actions_string, errmsg);
+    }
+    
+    if (sieve_eval_bc(interp, bc->data, bc->len, message_context, 
+		      &imapflags, actions, notify_list, &errmsg) < 0)
+    {
+	ret = SIEVE_RUN_ERROR;
+	return do_sieve_error(ret, interp, script_context,
+			      message_context, &imapflags,
+			      actions, notify_list, lastaction, 0,
+			      actions_string, errmsg);
+    }
+    
+    return do_action_list(interp, script_context, message_context, 
+			  &imapflags, actions, notify_list, actions_string,
+			  errmsg);
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/script.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/script.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,74 @@
+/* script.h -- script definition
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef SIEVE_SCRIPT_H
+#define SIEVE_SCRIPT_H
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "tree.h"
+
+#define ADDRERR_SIZE 500
+
+struct sieve_script {
+    sieve_interp_t interp;
+
+    /* was a "require" done for these? */
+    struct sieve_support {
+	int fileinto       : 1;
+	int reject         : 1;
+	int envelope       : 1;
+	int vacation       : 1;
+	int imapflags      : 1;
+	int notify         : 1;
+	int regex          : 1;
+	int subaddress     : 1;
+	int relational     : 1;
+	int i_ascii_numeric: 1;
+    } support;
+
+    void *script_context;
+    commandlist_t *cmds;
+
+    int err;
+};
+
+struct sieve_bytecode
+{
+    sieve_interp_t *interp;
+    void *script_context;
+
+    const char *data;
+    unsigned long len;
+    int fd;
+};
+
+/* generated by the yacc script */
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f);
+int script_require(sieve_script_t *s, char *req);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sieve-lex.l
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sieve-lex.l	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,162 @@
+%{
+/* sieve.l -- sieve lexer
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h> /* for strdup */
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+#define yylval sievelval
+#define yylex sievelex
+#define yyerror sieveerror
+
+static int tonum(char *c);
+static char *chkstr(char *);
+static char *mlbuf;
+static int mlbufsz, mlcur;
+extern int yyerror(char *);
+%}
+
+%option yylineno
+%option noyywrap
+%option nounput
+
+ws		[ \t]+
+ident		[a-zA-Z_][a-zA-Z_0-9]*
+CRLF		(\r\n|\r|\n)
+
+%state MULTILINE
+%state QSTRING
+
+%%
+<MULTILINE>^\.{CRLF}	{ BEGIN INITIAL; 
+                          if (mlbuf) mlbuf[mlcur] = '\0';
+                          yylval.sval = chkstr(mlbuf); return STRING; }
+<MULTILINE>^\.\.  { /* dot stuffing! we want one . */ yyless(1); }
+<MULTILINE>(.|\n) { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+<MULTILINE><<EOF>> { yyerror("unexpected end of file in string"); 
+		     yyterminate(); }
+<QSTRING>\"        { BEGIN INITIAL;
+                     if (mlbuf) mlbuf[mlcur] = '\0';
+		     yylval.sval = chkstr(mlbuf); return STRING; }
+<QSTRING>\\.      { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[1]; }
+<QSTRING>(.|\n)   { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+<INITIAL>text:{ws}?(#.*)?{CRLF}	{ BEGIN MULTILINE;
+			  mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+<INITIAL>\"        { BEGIN QSTRING;
+                    mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+<INITIAL>[0-9]+[KMG]?	{ yylval.nval = tonum(yytext); return NUMBER; }
+<INITIAL>if		return IF;
+<INITIAL>elsif		return ELSIF;
+<INITIAL>else		return ELSE;
+<INITIAL>anyof		return ANYOF;
+<INITIAL>allof		return ALLOF;
+<INITIAL>exists		return EXISTS;
+<INITIAL>false		return SFALSE;
+<INITIAL>true		return STRUE;
+<INITIAL>address	return ADDRESS;
+<INITIAL>envelope	return ENVELOPE;
+<INITIAL>header		return HEADER;
+<INITIAL>not		return NOT;
+<INITIAL>size		return SIZE;
+<INITIAL>reject		return REJCT;
+<INITIAL>fileinto	return FILEINTO;
+<INITIAL>redirect	return REDIRECT;
+<INITIAL>keep		return KEEP;
+<INITIAL>require	return REQUIRE;
+<INITIAL>stop		return STOP;
+<INITIAL>discard	return DISCARD;
+<INITIAL>setflag	return SETFLAG;
+<INITIAL>addflag	return ADDFLAG;
+<INITIAL>removeflag	return REMOVEFLAG;
+<INITIAL>mark		return MARK;
+<INITIAL>unmark		return UNMARK;
+<INITIAL>notify		return NOTIFY;
+<INITIAL>denotify	return DENOTIFY;
+<INITIAL>:id		return ID;
+<INITIAL>:method	return METHOD;
+<INITIAL>:options	return OPTIONS;
+<INITIAL>:low		return LOW;
+<INITIAL>:normal	return NORMAL;
+<INITIAL>:high		return HIGH;
+<INITIAL>:message	return MESSAGE;
+<INITIAL>vacation	return VACATION;
+<INITIAL>:days		return DAYS;
+<INITIAL>:addresses	return ADDRESSES;
+<INITIAL>:subject	return SUBJECT;
+<INITIAL>:mime		return MIME;
+<INITIAL>:comparator	return COMPARATOR;
+<INITIAL>:is		return IS;
+<INITIAL>:contains	return CONTAINS;
+<INITIAL>:matches	return MATCHES;
+<INITIAL>:regex		return REGEX;
+<INITIAL>:count		return COUNT;
+<INITIAL>:value		return VALUE;
+<INITIAL>:over		return OVER;
+<INITIAL>:under		return UNDER;
+<INITIAL>:all		return ALL;
+<INITIAL>:localpart	return LOCALPART;
+<INITIAL>:domain	return DOMAIN;
+<INITIAL>:user		return USER;
+<INITIAL>:detail	return DETAIL;
+<INITIAL>[ \t\n\r] ;	/* ignore whitespace */
+<INITIAL>#.* ;		/* ignore hash comments */
+<INITIAL>"/*"([^\*]|\*[^\/])*\*?"*/" ;	/* ignore bracket comments */
+.			return yytext[0];
+
+%%
+/*  */
+static int tonum(char *c)
+{
+  int val = atoi(c);
+  switch (c[strlen(c)-1]) {
+  case 'K': val *= (1 << 10); break;
+  case 'M': val *= (1 << 20); break;
+  case 'G': val *= (1 << 30); break;
+  default: break;
+  }
+  return val;
+}
+
+/* convert NULL strings to "" */
+static char *chkstr(char *str)
+{
+    if (!str) return xstrdup("");
+    else return str;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sieve.y
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sieve.y	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,1090 @@
+%{
+/* sieve.y -- sieve parser
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include "xmalloc.h"
+#include "comparator.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+
+#include "imparse.h"
+#include "libconfig.h"
+
+    /* definitions */
+    extern int addrparse(void);
+
+struct vtags {
+    int days;
+    stringlist_t *addresses;
+    char *subject;
+    int mime;
+};
+
+struct htags {
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct aetags {
+    int addrtag;
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct ntags {
+    char *method;
+    char *id;
+    stringlist_t *options;
+    int priority;
+    char *message;
+};
+
+struct dtags {
+    int comptag;
+    int relation;
+    void *pattern;
+    int priority;
+};
+
+static commandlist_t *ret;
+static sieve_script_t *parse_script;
+static int check_reqs(stringlist_t *sl);
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl);
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl);
+static commandlist_t *build_vacation(int t, struct vtags *h, char *s);
+static commandlist_t *build_notify(int t, struct ntags *n);
+static commandlist_t *build_denotify(int t, struct dtags *n);
+static struct aetags *new_aetags(void);
+static struct aetags *canon_aetags(struct aetags *ae);
+static void free_aetags(struct aetags *ae);
+static struct htags *new_htags(void);
+static struct htags *canon_htags(struct htags *h);
+static void free_htags(struct htags *h);
+static struct vtags *new_vtags(void);
+static struct vtags *canon_vtags(struct vtags *v);
+static void free_vtags(struct vtags *v);
+static struct ntags *new_ntags(void);
+static struct ntags *canon_ntags(struct ntags *n);
+static void free_ntags(struct ntags *n);
+static struct dtags *new_dtags(void);
+static struct dtags *canon_dtags(struct dtags *d);
+static void free_dtags(struct dtags *d);
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *));
+static int verify_mailbox(char *s);
+static int verify_address(char *s);
+static int verify_header(char *s);
+static int verify_addrheader(char *s);
+static int verify_envelope(char *s);
+static int verify_flag(char *s);
+static int verify_relat(char *s);
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags);
+static int verify_regexs(stringlist_t *sl, char *comp);
+#endif
+static int verify_utf8(char *s);
+
+int yyerror(char *msg);
+extern int yylex(void);
+extern void yyrestart(FILE *f);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+%}
+
+%union {
+    int nval;
+    char *sval;
+    stringlist_t *sl;
+    test_t *test;
+    testlist_t *testl;
+    commandlist_t *cl;
+    struct vtags *vtag;
+    struct aetags *aetag;
+    struct htags *htag;
+    struct ntags *ntag;
+    struct dtags *dtag;
+}
+
+%token <nval> NUMBER
+%token <sval> STRING
+%token IF ELSIF ELSE
+%token REJCT FILEINTO REDIRECT KEEP STOP DISCARD VACATION REQUIRE
+%token SETFLAG ADDFLAG REMOVEFLAG MARK UNMARK
+%token NOTIFY DENOTIFY
+%token ANYOF ALLOF EXISTS SFALSE STRUE HEADER NOT SIZE ADDRESS ENVELOPE
+%token COMPARATOR IS CONTAINS MATCHES REGEX COUNT VALUE OVER UNDER
+%token GT GE LT LE EQ NE
+%token ALL LOCALPART DOMAIN USER DETAIL
+%token DAYS ADDRESSES SUBJECT MIME
+%token METHOD ID OPTIONS LOW NORMAL HIGH ANY MESSAGE
+
+%type <cl> commands command action elsif block
+%type <sl> stringlist strings
+%type <test> test
+%type <nval> comptag relcomp sizetag addrparttag addrorenv
+%type <testl> testlist tests
+%type <htag> htags
+%type <aetag> aetags
+%type <vtag> vtags
+%type <ntag> ntags
+%type <dtag> dtags
+%type <nval> priority
+
+%%
+
+start: reqs			{ ret = NULL; }
+	| reqs commands		{ ret = $2; }
+	;
+
+reqs: /* empty */
+	| require reqs
+	;
+
+require: REQUIRE stringlist ';'	{ if (!check_reqs($2)) {
+                                    yyerror("Unsupported features in require line");
+				    YYERROR; 
+                                  } }
+	;
+
+commands: command		{ $$ = $1; }
+	| command commands	{ $1->next = $2; $$ = $1; }
+	;
+
+command: action ';'		{ $$ = $1; }
+	| IF test block elsif   { $$ = new_if($2, $3, $4); }
+	| error ';'		{ $$ = new_command(STOP); }
+	;
+
+elsif: /* empty */               { $$ = NULL; }
+	| ELSIF test block elsif { $$ = new_if($2, $3, $4); }
+	| ELSE block             { $$ = $2; }
+	;
+
+action: REJCT STRING             { if (!parse_script->support.reject) {
+				     yyerror("reject require missing");
+				     YYERROR;
+				   }
+				   if (!verify_utf8($2)) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+				   $$ = new_command(REJCT);
+				   $$->u.str = $2; }
+	| FILEINTO STRING	 { if (!parse_script->support.fileinto) {
+				     yyerror("fileinto require missing");
+	                             YYERROR;
+                                   }
+				   if (!verify_mailbox($2)) {
+				     YYERROR; /* vm should call yyerror() */
+				   }
+	                           $$ = new_command(FILEINTO);
+				   $$->u.str = $2; }
+	| REDIRECT STRING         { $$ = new_command(REDIRECT);
+				   if (!verify_address($2)) {
+				     YYERROR; /* va should call yyerror() */
+				   }
+				   $$->u.str = $2; }
+	| KEEP			 { $$ = new_command(KEEP); }
+	| STOP			 { $$ = new_command(STOP); }
+	| DISCARD		 { $$ = new_command(DISCARD); }
+	| VACATION vtags STRING  { if (!parse_script->support.vacation) {
+				     yyerror("vacation require missing");
+				     YYERROR;
+				   }
+				   if (($2->mime == -1) && !verify_utf8($3)) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+  				   $$ = build_vacation(VACATION,
+					    canon_vtags($2), $3); }
+        | SETFLAG stringlist     { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                   }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(SETFLAG);
+                                  $$->u.sl = $2; }
+         | ADDFLAG stringlist     { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(ADDFLAG);
+                                  $$->u.sl = $2; }
+         | REMOVEFLAG stringlist  { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(REMOVEFLAG);
+                                  $$->u.sl = $2; }
+         | MARK                   { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  $$ = new_command(MARK); }
+         | UNMARK                 { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  $$ = new_command(UNMARK); }
+
+         | NOTIFY ntags           { if (!parse_script->support.notify) {
+				       yyerror("notify require missing");
+				       $$ = new_command(NOTIFY); 
+				       YYERROR;
+	 			    } else {
+				      $$ = build_notify(NOTIFY,
+				             canon_ntags($2));
+				    } }
+         | DENOTIFY dtags         { if (!parse_script->support.notify) {
+                                       yyerror("notify require missing");
+				       $$ = new_command(DENOTIFY);
+				       YYERROR;
+				    } else {
+					$$ = build_denotify(DENOTIFY, canon_dtags($2));
+					if ($$ == NULL) { 
+			yyerror("unable to find a compatible comparator");
+			YYERROR; } } }
+	;
+
+ntags: /* empty */		 { $$ = new_ntags(); }
+	| ntags ID STRING	 { if ($$->id != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { $$->id = $3; } }
+	| ntags METHOD STRING	 { if ($$->method != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { $$->method = $3; } }
+	| ntags OPTIONS stringlist { if ($$->options != NULL) { 
+					yyerror("duplicate :options"); YYERROR; }
+				     else { $$->options = $3; } }
+        | ntags priority	 { if ($$->priority != -1) { 
+                                 yyerror("duplicate :priority"); YYERROR; }
+                                   else { $$->priority = $2; } }
+	| ntags MESSAGE STRING	 { if ($$->message != NULL) { 
+					yyerror("duplicate :message"); YYERROR; }
+				   else { $$->message = $3; } }
+	;
+
+dtags: /* empty */		 { $$ = new_dtags(); }
+	| dtags priority	 { if ($$->priority != -1) { 
+				yyerror("duplicate priority level"); YYERROR; }
+				   else { $$->priority = $2; } }
+	| dtags comptag STRING 	 { if ($$->comptag != -1)
+	                             { 
+					 yyerror("duplicate comparator type tag"); YYERROR;
+				     }
+	                           $$->comptag = $2;
+#ifdef ENABLE_REGEX
+				   if ($$->comptag == REGEX)
+				   {
+				       int cflags = REG_EXTENDED |
+					   REG_NOSUB | REG_ICASE;
+				       if (!verify_regex($3, cflags)) { YYERROR; }
+				   }
+#endif
+				   $$->pattern = $3;
+	                          }
+	| dtags relcomp STRING  { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	;
+
+priority: LOW                   { $$ = LOW; }
+        | NORMAL                { $$ = NORMAL; }
+        | HIGH                  { $$ = HIGH; }
+        ;
+
+vtags: /* empty */		 { $$ = new_vtags(); }
+	| vtags DAYS NUMBER	 { if ($$->days != -1) { 
+					yyerror("duplicate :days"); YYERROR; }
+				   else { $$->days = $3; } }
+	| vtags ADDRESSES stringlist { if ($$->addresses != NULL) { 
+					yyerror("duplicate :addresses"); 
+					YYERROR;
+				       } else if (!verify_stringlist($3,
+							verify_address)) {
+					  YYERROR;
+				       } else {
+					 $$->addresses = $3; } }
+	| vtags SUBJECT STRING	 { if ($$->subject != NULL) { 
+					yyerror("duplicate :subject"); 
+					YYERROR;
+				   } else if (!verify_utf8($3)) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { $$->subject = $3; } }
+	| vtags MIME		 { if ($$->mime != -1) { 
+					yyerror("duplicate :mime"); 
+					YYERROR; }
+				   else { $$->mime = MIME; } }
+	;
+
+stringlist: '[' strings ']'      { $$ = $2; }
+	| STRING		 { $$ = new_sl($1, NULL); }
+	;
+
+strings: STRING			 { $$ = new_sl($1, NULL); }
+	| STRING ',' strings	 { $$ = new_sl($1, $3); }
+	;
+
+block: '{' commands '}'		 { $$ = $2; }
+	| '{' '}'		 { $$ = NULL; }
+	;
+
+test:     ANYOF testlist	 { $$ = new_test(ANYOF); $$->u.tl = $2; }
+        | ALLOF testlist	 { $$ = new_test(ALLOF); $$->u.tl = $2; }
+        | EXISTS stringlist      { $$ = new_test(EXISTS); $$->u.sl = $2; }
+        | SFALSE		 { $$ = new_test(SFALSE); }
+	| STRUE			 { $$ = new_test(STRUE); }
+	| HEADER htags stringlist stringlist
+				 {
+				     if (!verify_stringlist($3, verify_header)) {
+					 YYERROR; /* vh should call yyerror() */
+				     }
+				     if (!verify_stringlist($4, verify_utf8)) {
+					 YYERROR; /* vu should call yyerror() */
+				     }
+				     
+				     $2 = canon_htags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!(verify_regexs($4, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_header(HEADER, $2, $3, $4);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+
+        | addrorenv aetags stringlist stringlist
+				 { 
+				     if (($1 == ADDRESS) &&
+					 !verify_stringlist($3, verify_addrheader))
+					 { YYERROR; }
+				     else if (($1 == ENVELOPE) &&
+					      !verify_stringlist($3, verify_envelope))
+					 { YYERROR; }
+				     $2 = canon_aetags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!( verify_regexs($4, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_address($1, $2, $3, $4);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+	| NOT test		 { $$ = new_test(NOT); $$->u.t = $2; }
+	| SIZE sizetag NUMBER    { $$ = new_test(SIZE); $$->u.sz.t = $2;
+		                   $$->u.sz.n = $3; }
+	| error			 { $$ = NULL; }
+	;
+
+addrorenv: ADDRESS		 { $$ = ADDRESS; }
+	| ENVELOPE		 {if (!parse_script->support.envelope)
+	                              {yyerror("envelope require missing"); YYERROR;}
+	                          else{$$ = ENVELOPE; }
+	                         }
+
+	;
+
+aetags: /* empty */              { $$ = new_aetags(); }
+        | aetags addrparttag	 { $$ = $1;
+				   if ($$->addrtag != -1) { 
+			yyerror("duplicate or conflicting address part tag");
+			YYERROR; }
+				   else { $$->addrtag = $2; } }
+	| aetags comptag         { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| aetags relcomp STRING{ $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+        | aetags COMPARATOR STRING { $$ = $1;
+	if ($$->comparator != NULL) { 
+			yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) {
+			yyerror("comparator-i;ascii-numeric require missing");
+			YYERROR; }
+				   else { $$->comparator = $3; } }
+	;
+
+htags: /* empty */		 { $$ = new_htags(); }
+	| htags comptag		 { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| htags relcomp STRING { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	| htags COMPARATOR STRING { $$ = $1;
+				   if ($$->comparator != NULL) { 
+			 yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) { 
+			 yyerror("comparator-i;ascii-numeric require missing");  YYERROR; }
+				   else { 
+				     $$->comparator = $3; } }
+        ;
+
+
+addrparttag: ALL                 { $$ = ALL; }
+	| LOCALPART		 { $$ = LOCALPART; }
+	| DOMAIN                 { $$ = DOMAIN; }
+	| USER                   { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   $$ = USER; }  
+	| DETAIL                { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   $$ = DETAIL; }
+	;
+comptag: IS			 { $$ = IS; }
+	| CONTAINS		 { $$ = CONTAINS; }
+	| MATCHES		 { $$ = MATCHES; }
+	| REGEX			 { if (!parse_script->support.regex) {
+				     yyerror("regex require missing");
+				     YYERROR;
+				   }
+				   $$ = REGEX; }
+	;
+
+relcomp: COUNT			 { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   $$ = COUNT; }
+	| VALUE			 { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   $$ = VALUE; }
+	;
+
+
+sizetag: OVER			 { $$ = OVER; }
+	| UNDER			 { $$ = UNDER; }
+	;
+
+testlist: '(' tests ')'		 { $$ = $2; }
+	;
+
+tests: test                      { $$ = new_testlist($1, NULL); }
+	| test ',' tests         { $$ = new_testlist($1, $3); }
+	;
+
+%%
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f)
+{
+    commandlist_t *t;
+
+    parse_script = script;
+    yyrestart(f);
+    if (yyparse()) {
+	t = NULL;
+    } else {
+	t = ret;
+    }
+    ret = NULL;
+    return t;
+}
+
+int yyerror(char *msg)
+{
+    extern int yylineno;
+    int ret;
+
+    parse_script->err++;
+    if (parse_script->interp.err) {
+	ret = parse_script->interp.err(yylineno, msg, 
+				       parse_script->interp.interp_context,
+				       parse_script->script_context);
+    }
+
+    return 0;
+}
+
+static int check_reqs(stringlist_t *sl)
+{
+    int i = 1;
+    stringlist_t *s;
+    
+    while (sl != NULL) {
+	s = sl;
+	sl = sl->next;
+
+	i &= script_require(parse_script, s->s);
+
+	if (s->s) free(s->s);
+	free(s);
+    }
+    return i;
+}
+
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be either ADDRESS or ENVELOPE */
+
+    assert((t == ADDRESS) || (t == ENVELOPE));
+
+    if (ret) {
+	ret->u.ae.comptag = ae->comptag;
+	ret->u.ae.relation=ae->relation;
+	ret->u.ae.comparator=strdup(ae->comparator);
+	ret->u.ae.sl = sl;
+	ret->u.ae.pl = pl;
+	ret->u.ae.addrpart = ae->addrtag;
+	free_aetags(ae);
+
+    }
+    return ret;
+}
+
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be HEADER */
+
+    assert(t == HEADER);
+
+    if (ret) {
+	ret->u.h.comptag = h->comptag;
+	ret->u.h.relation=h->relation;
+	ret->u.h.comparator=strdup(h->comparator);
+	ret->u.h.sl = sl;
+	ret->u.h.pl = pl;
+	free_htags(h);
+    }
+    return ret;
+}
+
+static commandlist_t *build_vacation(int t, struct vtags *v, char *reason)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == VACATION);
+
+    if (ret) {
+	ret->u.v.subject = v->subject; v->subject = NULL;
+	ret->u.v.days = v->days;
+	ret->u.v.mime = v->mime;
+	ret->u.v.addresses = v->addresses; v->addresses = NULL;
+	free_vtags(v);
+	ret->u.v.message = reason;
+    }
+    return ret;
+}
+
+static commandlist_t *build_notify(int t, struct ntags *n)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == NOTIFY);
+       if (ret) {
+	ret->u.n.method = n->method; n->method = NULL;
+	ret->u.n.id = n->id; n->id = NULL;
+	ret->u.n.options = n->options; n->options = NULL;
+	ret->u.n.priority = n->priority;
+	ret->u.n.message = n->message; n->message = NULL;
+	free_ntags(n);
+    }
+    return ret;
+}
+
+static commandlist_t *build_denotify(int t, struct dtags *d)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == DENOTIFY);
+
+    if (ret) {
+	ret->u.d.comptag = d->comptag;
+	ret->u.d.relation=d->relation;
+	ret->u.d.pattern = d->pattern; d->pattern = NULL;
+	ret->u.d.priority = d->priority;
+	free_dtags(d);
+    }
+    return ret;
+}
+
+static struct aetags *new_aetags(void)
+{
+    struct aetags *r = (struct aetags *) xmalloc(sizeof(struct aetags));
+
+    r->addrtag = r->comptag = r->relation=-1;
+    r->comparator=NULL;
+
+    return r;
+}
+
+static struct aetags *canon_aetags(struct aetags *ae)
+{
+    if (ae->addrtag == -1) { ae->addrtag = ALL; }
+    if (ae->comparator == NULL) {
+        ae->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (ae->comptag == -1) { ae->comptag = IS; }
+    return ae;
+}
+
+static void free_aetags(struct aetags *ae)
+{
+    free(ae->comparator);
+     free(ae);
+}
+
+static struct htags *new_htags(void)
+{
+    struct htags *r = (struct htags *) xmalloc(sizeof(struct htags));
+
+    r->comptag = r->relation= -1;
+    
+    r->comparator = NULL;
+
+    return r;
+}
+
+static struct htags *canon_htags(struct htags *h)
+{
+    if (h->comparator == NULL) {
+	h->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (h->comptag == -1) { h->comptag = IS; }
+    return h;
+}
+
+static void free_htags(struct htags *h)
+{
+    free(h->comparator);
+    free(h);
+}
+
+static struct vtags *new_vtags(void)
+{
+    struct vtags *r = (struct vtags *) xmalloc(sizeof(struct vtags));
+
+    r->days = -1;
+    r->addresses = NULL;
+    r->subject = NULL;
+    r->mime = -1;
+
+    return r;
+}
+
+static struct vtags *canon_vtags(struct vtags *v)
+{
+    assert(parse_script->interp.vacation != NULL);
+
+    if (v->days == -1) { v->days = 7; }
+    if (v->days < parse_script->interp.vacation->min_response) 
+       { v->days = parse_script->interp.vacation->min_response; }
+    if (v->days > parse_script->interp.vacation->max_response)
+       { v->days = parse_script->interp.vacation->max_response; }
+    if (v->mime == -1) { v->mime = 0; }
+
+    return v;
+}
+
+static void free_vtags(struct vtags *v)
+{
+    if (v->addresses) { free_sl(v->addresses); }
+    if (v->subject) { free(v->subject); }
+    free(v);
+}
+
+static struct ntags *new_ntags(void)
+{
+    struct ntags *r = (struct ntags *) xmalloc(sizeof(struct ntags));
+
+    r->method = NULL;
+    r->id = NULL;
+    r->options = NULL;
+    r->priority = -1;
+    r->message = NULL;
+
+    return r;
+}
+
+static struct ntags *canon_ntags(struct ntags *n)
+{
+    if (n->priority == -1) { n->priority = NORMAL; }
+    if (n->message == NULL) { n->message = strdup("$from$: $subject$"); }
+    if (n->method == NULL) { n->method = strdup("default"); }
+    return n;
+}
+static struct dtags *canon_dtags(struct dtags *d)
+{
+    if (d->priority == -1) { d->priority = ANY; }
+    if (d->comptag == -1) { d->comptag = ANY; }
+       return d;
+}
+
+static void free_ntags(struct ntags *n)
+{
+    if (n->method) { free(n->method); }
+    if (n->id) { free(n->id); }
+    if (n->options) { free_sl(n->options); }
+    if (n->message) { free(n->message); }
+    free(n);
+}
+
+static struct dtags *new_dtags(void)
+{
+    struct dtags *r = (struct dtags *) xmalloc(sizeof(struct dtags));
+
+    r->comptag = r->priority= r->relation = -1;
+    r->pattern  = NULL;
+
+    return r;
+}
+
+static void free_dtags(struct dtags *d)
+{
+    if (d->pattern) free(d->pattern);
+    free(d);
+}
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *))
+{
+    for (; sl != NULL && verify(sl->s); sl = sl->next) ;
+    return (sl == NULL);
+}
+
+char *addrptr;		/* pointer to address string for address lexer */
+char addrerr[500];	/* buffer for address parser error messages */
+
+static int verify_address(char *s)
+{
+    char errbuf[500];
+
+    addrptr = s;
+    addrerr[0] = '\0';	/* paranoia */
+    if (addrparse()) {
+	snprintf(errbuf, sizeof(errbuf), "address '%s': %s", s, addrerr);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+
+static int verify_mailbox(char *s)
+{
+    if (!verify_utf8(s)) return 0;
+
+    /* xxx if not a mailbox, call yyerror */
+    return 1;
+}
+
+static int verify_header(char *hdr)
+{
+    char *h = hdr;
+    char errbuf[100];
+
+    while (*h) {
+	/* field-name      =       1*ftext
+	   ftext           =       %d33-57 / %d59-126         
+	   ; Any character except
+	   ;  controls, SP, and
+	   ;  ":". */
+	if (!((*h >= 33 && *h <= 57) || (*h >= 59 && *h <= 126))) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "header '%s': not a valid header", hdr);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	h++;
+    }
+    return 1;
+}
+ 
+static int verify_addrheader(char *hdr)
+{
+    const char **h, *hdrs[] = {
+	"from", "sender", "reply-to",	/* RFC2822 originator fields */
+	"to", "cc", "bcc",		/* RFC2822 destination fields */
+	"resent-from", "resent-sender",	/* RFC2822 resent fields */
+	"resent-to", "resent-cc", "resent-bcc",
+	"return-path",			/* RFC2822 trace fields */
+	"disposition-notification-to",	/* RFC2298 MDN request fields */
+	"delivered-to",			/* non-standard (loop detection) */
+	"approved",			/* RFC1036 moderator/control fields */
+	NULL
+    };
+    char errbuf[100];
+
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT))
+	return verify_header(hdr);
+
+    for (lcase(hdr), h = hdrs; *h; h++) {
+	if (!strcmp(*h, hdr)) return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "header '%s': not a valid header for an address test", hdr);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_envelope(char *env)
+{
+    char errbuf[100];
+
+    lcase(env);
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT) ||
+	!strcmp(env, "from") || !strcmp(env, "to") || !strcmp(env, "auth")) {
+	return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "env-part '%s': not a valid part for an envelope test", env);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_relat(char *r)
+{/* this really should have been a token to begin with.*/
+    char errbuf[100];
+	lcase(r);
+	if (!strcmp(r, "gt")) {return GT;}
+	else if (!strcmp(r, "ge")) {return GE;}
+	else if (!strcmp(r, "lt")) {return LT;}
+	else if (!strcmp(r, "le")) {return LE;}
+	else if (!strcmp(r, "ne")) {return NE;}
+	else if (!strcmp(r, "eq")) {return EQ;}
+	else{
+	  sprintf(errbuf, "flag '%s': not a valid relational operation", r);
+	  yyerror(errbuf);
+	  return -1;
+	}
+	
+}
+
+
+
+
+static int verify_flag(char *f)
+{
+    char errbuf[100];
+ 
+    if (f[0] == '\\') {
+	lcase(f);
+	if (strcmp(f, "\\seen") && strcmp(f, "\\answered") &&
+	    strcmp(f, "\\flagged") && strcmp(f, "\\draft") &&
+	    strcmp(f, "\\deleted")) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "flag '%s': not a system flag", f);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	return 1;
+    }
+    if (!imparse_isatom(f)) {
+	snprintf(errbuf, sizeof(errbuf), "flag '%s': not a valid keyword", f);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+ 
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags)
+{
+    int ret;
+    char errbuf[100];
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+
+     if ((ret = regcomp(reg, s, cflags)) != 0) {
+	(void) regerror(ret, reg, errbuf, sizeof(errbuf));
+	yyerror(errbuf);
+	free(reg);
+	return 0;
+	}
+    free(reg);
+    return 1;
+}
+
+static int verify_regexs(stringlist_t *sl, char *comp)
+{
+    stringlist_t *sl2;
+    int cflags = REG_EXTENDED | REG_NOSUB;
+ 
+
+    if (!strcmp(comp, "i;ascii-casemap")) {
+	cflags |= REG_ICASE;
+    }
+
+    for (sl2 = sl; sl2 != NULL; sl2 = sl2->next) {
+	if ((verify_regex(sl2->s, cflags)) == 0) {
+	    break;
+	}
+    }
+    if (sl2 == NULL) {
+	return 1;
+    }
+    return 0;
+}
+#endif
+
+/*
+ * Valid UTF-8 check (from RFC 2640 Annex B.1)
+ *
+ * The following routine checks if a byte sequence is valid UTF-8. This
+ * is done by checking for the proper tagging of the first and following
+ * bytes to make sure they conform to the UTF-8 format. It then checks
+ * to assure that the data part of the UTF-8 sequence conforms to the
+ * proper range allowed by the encoding. Note: This routine will not
+ * detect characters that have not been assigned and therefore do not
+ * exist.
+ */
+static int verify_utf8(char *s)
+{
+    const unsigned char *buf = (const unsigned char *)s;
+    const unsigned char *endbuf = buf + strlen(s);
+    unsigned char byte2mask = 0x00, c;
+    int trailing = 0;  /* trailing (continuation) bytes to follow */
+
+    while (buf != endbuf) {
+	c = *buf++;
+	if (trailing) {
+	    if ((c & 0xC0) == 0x80) {		/* Does trailing byte
+						   follow UTF-8 format? */
+		if (byte2mask) {		/* Need to check 2nd byte
+						   for proper range? */
+		    if (c & byte2mask)		/* Are appropriate bits set? */
+			byte2mask = 0x00;
+		    else
+			break;
+		}
+		trailing--;
+	    }
+	    else
+		break;
+	}
+	else {
+	    if ((c & 0x80) == 0x00)		/* valid 1 byte UTF-8 */
+		continue;
+	    else if ((c & 0xE0) == 0xC0)	/* valid 2 byte UTF-8 */
+		if (c & 0x1E) {			/* Is UTF-8 byte
+						   in proper range? */
+		    trailing = 1;
+		}
+		else
+		    break;
+	    else if ((c & 0xF0) == 0xE0) {	/* valid 3 byte UTF-8 */
+		if (!(c & 0x0F)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x20;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 2;
+	    }
+	    else if ((c & 0xF8) == 0xF0) {	/* valid 4 byte UTF-8 */
+		if (!(c & 0x07)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x30;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 3;
+	    }
+	    else if ((c & 0xFC) == 0xF8) {	/* valid 5 byte UTF-8 */
+		if (!(c & 0x03)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x38;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 4;
+	    }
+	    else if ((c & 0xFE) == 0xFC) {	/* valid 6 byte UTF-8 */
+		if (!(c & 0x01)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x3C;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 5;
+	    }
+	    else
+		break;
+	}
+    }
+
+    if ((buf != endbuf) || trailing) {
+	char errbuf[100];
+
+	snprintf(errbuf, sizeof(errbuf),
+		 "string '%s': not valid utf8", s);
+	yyerror(errbuf);
+	return 0;
+    }
+
+    return 1;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sieve_err.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sieve_err.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,60 @@
+/*
+ * sieve_err.c:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <stdlib.h>
+
+static const char * const text[] = {
+	   "Generic Sieve error",
+	   "Sieve interpretor not finalized",
+	   "Parse error in Sieve script",
+	   "Run-time error during Sieve execution",
+	   "Internal error in Sieve subsystem",
+	   "Memory exhausted in Sieve subsystem",
+	   "Sieve action already taken",
+    0
+};
+
+struct error_table {
+    char const * const * msgs;
+    long base;
+    int n_msgs;
+};
+struct et_list {
+    struct et_list *next;
+    const struct error_table * table;
+};
+extern struct et_list *_et_list;
+
+const struct error_table et_siev_error_table = { text, -1237848064L, 7 };
+
+static struct et_list link = { 0, 0 };
+
+void initialize_siev_error_table(void);
+
+void initialize_siev_error_table(void) {
+    if (!link.table) {
+        link.next = _et_list;
+        link.table = &et_siev_error_table;
+        _et_list = &link;
+    }
+}
+
+/* For Heimdal compatibility */
+void initialize_siev_error_table_r(struct et_list **list);
+
+void initialize_siev_error_table_r(struct et_list **list)
+{
+    struct et_list *et, **end;
+
+    for (end = list, et = *list; et; end = &et->next, et = et->next)
+        if (et->table->msgs == text)
+            return;
+    et = malloc(sizeof(struct et_list));
+    if (et == 0)
+        return;
+    et->table = &et_siev_error_table;
+    et->next = 0;
+    *end = et;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sieve_err.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sieve_err.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,24 @@
+/*
+ * sieve_err.h:
+ * This file used to be automatically generated from sieve_er.et.
+ */
+struct et_list;
+
+#define SIEVE_FAIL                               (-1237848064L)
+#define SIEVE_NOT_FINALIZED                      (-1237848063L)
+#define SIEVE_PARSE_ERROR                        (-1237848062L)
+#define SIEVE_RUN_ERROR                          (-1237848061L)
+#define SIEVE_INTERNAL_ERROR                     (-1237848060L)
+#define SIEVE_NOMEM                              (-1237848059L)
+#define SIEVE_DONE                               (-1237848058L)
+extern const struct error_table et_siev_error_table;
+extern void initialize_siev_error_table(void);
+
+/* For compatibility with Heimdal */
+extern void initialize_siev_error_table_r(struct et_list **list);
+
+#define ERROR_TABLE_BASE_siev (-1237848064L)
+
+/* for compatibility with older versions... */
+#define init_siev_err_tbl initialize_siev_error_table
+#define siev_err_base ERROR_TABLE_BASE_siev
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sieve_interface.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sieve_interface.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,172 @@
+/* sieve_interface.h -- interface for deliver
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef SIEVE_H
+#define SIEVE_H
+
+#include <stdio.h>
+
+#define SIEVE_VERSION "CMU Sieve 2.2"
+
+/* error codes */
+#define SIEVE_OK (0)
+
+#include "sieve_err.h"
+
+/* external sieve types */
+typedef struct sieve_interp sieve_interp_t;
+typedef struct sieve_script sieve_script_t;
+typedef struct sieve_bytecode sieve_bytecode_t;
+typedef struct bytecode_info bytecode_info_t;
+
+typedef int sieve_callback(void *action_context, void *interp_context, 
+			   void *script_context,
+			   void *message_context, const char **errmsg);
+typedef int sieve_get_size(void *message_context, int *size);
+typedef int sieve_get_header(void *message_context, 
+			     const char *header,
+			     const char ***contents);
+typedef int sieve_get_envelope(void *message_context, 
+			       const char *field,
+			       const char ***contents);
+
+typedef struct sieve_vacation {
+    int min_response;		/* 0 -> defaults to 3 */
+    int max_response;		/* 0 -> defaults to 90 */
+
+    /* given a hash, say whether we've already responded to it in the last
+       days days.  return SIEVE_OK if we SHOULD autorespond (have not already)
+       or SIEVE_DONE if we SHOULD NOT. */
+    sieve_callback *autorespond;
+
+    /* mail the response */
+    sieve_callback *send_response;
+} sieve_vacation_t;
+
+typedef struct sieve_imapflags {
+    char **flag;		/* NULL -> defaults to \flagged */
+    int nflags;
+} sieve_imapflags_t;
+
+typedef struct sieve_redirect_context {
+    const char *addr;
+} sieve_redirect_context_t;
+
+typedef struct sieve_reject_context {
+    const char *msg;
+} sieve_reject_context_t;
+
+typedef struct sieve_fileinto_context {
+    const char *mailbox;
+    sieve_imapflags_t *imapflags;
+} sieve_fileinto_context_t;
+
+typedef struct sieve_keep_context {
+    sieve_imapflags_t *imapflags;
+} sieve_keep_context_t;
+
+typedef struct sieve_notify_context {
+    const char *method;
+    const char **options;
+    const char *priority;
+    const char *message;
+} sieve_notify_context_t;
+
+typedef struct sieve_autorespond_context {
+    unsigned char *hash;
+    int len;
+    int days;
+} sieve_autorespond_context_t;
+
+typedef struct sieve_send_response_context {
+    char *addr;
+    char *fromaddr;
+    const char *msg;
+    char *subj;
+    int mime;
+} sieve_send_response_context_t;
+
+/* build a sieve interpretor */
+int sieve_interp_alloc(sieve_interp_t **interp, void *interp_context);
+int sieve_interp_free(sieve_interp_t **interp);
+
+/* add the callbacks for actions. undefined behavior results if these
+   are called after sieve_script_parse is called! */
+int sieve_register_redirect(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_discard(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_reject(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_fileinto(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_keep(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_vacation(sieve_interp_t *interp, sieve_vacation_t *v);
+int sieve_register_imapflags(sieve_interp_t *interp, sieve_imapflags_t *mark);
+int sieve_register_notify(sieve_interp_t *interp, sieve_callback *f);
+
+/* add the callbacks for messages. again, undefined if used after
+   sieve_script_parse */
+int sieve_register_size(sieve_interp_t *interp, sieve_get_size *f);
+int sieve_register_header(sieve_interp_t *interp, sieve_get_header *f);
+int sieve_register_envelope(sieve_interp_t *interp, sieve_get_envelope *f);
+
+typedef int sieve_parse_error(int lineno, const char *msg, 
+			      void *interp_context,
+			      void *script_context);
+int sieve_register_parse_error(sieve_interp_t *interp, sieve_parse_error *f);
+
+typedef int sieve_execute_error(const char *msg, void *interp_context,
+				void *script_context, void *message_context);
+int sieve_register_execute_error(sieve_interp_t *interp, 
+				 sieve_execute_error *f);
+ 
+/* given an interpretor and a script, produce an executable script */
+int sieve_script_parse(sieve_interp_t *interp, FILE *script,
+		       void *script_context, sieve_script_t **ret);
+
+/* given a bytecode file descriptor, setup the sieve_bytecode_t */
+int sieve_script_load(const char *fname, sieve_bytecode_t **ret);
+
+/* Unload a sieve_bytecode_t */
+int sieve_script_unload(sieve_bytecode_t **s);
+
+/* Free a sieve_script_t */
+int sieve_script_free(sieve_script_t **s);
+
+/* execute bytecode on a message */
+int sieve_execute_bytecode(sieve_bytecode_t *script, sieve_interp_t *interp,
+			   void *script_context, void *message_context);
+
+/* Get space separated list of extensions supported by the implementation */
+const char *sieve_listextensions(void);
+
+/* Create a bytecode structure given a parsed commandlist */
+int sieve_generate_bytecode(bytecode_info_t **retval, sieve_script_t *s);
+
+/* Emit bytecode to a file descriptor */
+int sieve_emit_bytecode(int fd, bytecode_info_t *bc);
+
+/* Free a bytecode_info_t */
+void sieve_free_bytecode(bytecode_info_t **p);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sievec.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sievec.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,273 @@
+/* sievec.c -- compile a sieve script to bytecode manually
+ * Rob Siemborski
+ * $Id$
+ */
+/*
+ * Copyright (c) 1999-2000 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sieve_interface.h"
+
+#include "libconfig.h"
+#include "xmalloc.h"
+
+#include "script.h"
+#include <string.h> 
+#include <stdlib.h>
+#include <sys/file.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+struct et_list *_et_list = NULL;
+
+int is_script_parsable(FILE *stream, char **errstr, sieve_script_t **ret);
+
+#define TIMSIEVE_FAIL -1
+#define TIMSIEVE_OK 0
+
+int main(int argc, char **argv) 
+{
+    FILE *instream;
+    char *err = NULL;
+    sieve_script_t *s;
+    bytecode_info_t *bc;
+    int c, fd, usage_error = 0;
+
+    while ((c = getopt(argc, argv, "C:")) != EOF)
+	switch (c) {
+	default:
+	    usage_error = 1;
+	    break;
+	}
+
+    if (usage_error || (argc - optind) < 2) {
+	printf("Syntax: %s <filename> <outputfile>\n",
+	       argv[0]);
+	exit(1);
+    }
+
+    instream = fopen(argv[optind++],"r");
+    if(instream == NULL) {
+	printf("Unable to open %s for reading\n", argv[1]);
+	exit(1);
+    }
+    
+    if(is_script_parsable(instream, &err, &s) == TIMSIEVE_FAIL) {
+	if(err) {
+	    printf("Unable to parse script: %s\n", err);
+	} else {
+	    printf("Unable to parse script.\n");
+	}
+	 
+	exit(1);
+    }
+    
+    /* Now, generate the bytecode */
+    if(sieve_generate_bytecode(&bc, s) == -1) {
+	printf("bytecode generate failed\n");
+	exit(1);
+    }
+
+    /* Now, open the new file */
+    fd = open(argv[optind], O_CREAT | O_TRUNC | O_WRONLY, 0644);
+    if(fd < 0) {
+	printf("couldn't open bytecode output file\n");
+	exit(1);
+    }  
+
+    /* Now, emit the bytecode */
+    if(sieve_emit_bytecode(fd, bc) == -1) {
+	printf("bytecode emit failed\n");
+	exit(1);
+    }
+
+    close(fd);
+    
+    return 0;
+}
+
+/* to make larry's stupid functions happy :) */ 
+static void foo(void)
+{
+    i_fatal("stub function called");
+}
+sieve_vacation_t vacation = {
+    0,				/* min response */
+    0,				/* max response */
+    (sieve_callback *) &foo,	/* autorespond() */
+    (sieve_callback *) &foo	/* send_response() */
+};
+
+static int sieve_notify(void *ac __attr_unused__, 
+			void *interp_context __attr_unused__, 
+			void *script_context __attr_unused__,
+			void *message_context __attr_unused__,
+			const char **errmsg __attr_unused__)
+{
+    i_fatal("stub function called");
+    return SIEVE_FAIL;
+}
+
+static int mysieve_error(int lineno, const char *msg,
+			 void *i __attr_unused__, void *s)
+{
+    char buf[1024];
+    char **errstr = (char **) s;
+
+    snprintf(buf, 80, "line %d: %s\r\n", lineno, msg);
+    *errstr = xrealloc(*errstr, strlen(*errstr) + strlen(buf) + 30);
+    i_info("%s", buf);
+    strcat(*errstr, buf);
+
+    return SIEVE_OK;
+}
+
+/* end the boilerplate */
+
+/* returns TRUE or FALSE */
+int is_script_parsable(FILE *stream, char **errstr, sieve_script_t **ret)
+{
+    sieve_interp_t *i;
+    sieve_script_t *s;
+    int res;
+  
+    res = sieve_interp_alloc(&i, NULL);
+    if (res != SIEVE_OK) {
+	i_error("sieve_interp_alloc() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_redirect(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_redirect() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_discard(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_discard() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_reject(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_reject() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_fileinto(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_fileinto() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_keep(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_keep() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_imapflags(i, NULL);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_imapflags() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_size(i, (sieve_get_size *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_size() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_header(i, (sieve_get_header *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_header() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_envelope(i, (sieve_get_envelope *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_envelope() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_vacation(i, &vacation);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_vacation() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_notify(i, &sieve_notify);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_notify() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_parse_error(i, &mysieve_error);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_parse_error() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    rewind(stream);
+
+    *errstr = (char *) xmalloc(20 * sizeof(char));
+    strcpy(*errstr, "script errors:\r\n");
+
+    res = sieve_script_parse(i, stream, errstr, &s);
+
+    if (res == SIEVE_OK) {
+	if(ret) {
+	    *ret = s;
+	} else {
+	    sieve_script_free(&s);
+	}
+	free(*errstr);
+	*errstr = NULL;
+    }
+
+    /* free interpreter */
+    sieve_interp_free(&i);
+
+    return (res == SIEVE_OK) ? TIMSIEVE_OK : TIMSIEVE_FAIL;
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/sieved.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/sieved.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,437 @@
+/* dump.c -- bytecode decompiler
+ * Jen Smith
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+
+
+#include "sieve_interface.h"
+
+#include "bytecode.h"
+#include "script.h"
+
+#include "xmalloc.h"
+#include <sys/types.h> 
+#include <sys/stat.h>
+#include <fcntl.h> 
+#include <unistd.h> 
+#include <netinet/in.h>
+
+#include <string.h>
+
+#include "map.h"
+
+static void dump2(bytecode_input_t *d, int len);
+static int dump2_test(bytecode_input_t * d, int i);
+
+static int load(int fd, bytecode_input_t ** d)
+{  
+    const char * data=NULL;
+    struct stat sbuf;
+    unsigned long len=0;
+    
+    if (fstat(fd, &sbuf) == -1) {
+	printf("IOERROR: fstating sieve script: %m");
+	return SIEVE_FAIL;
+    }
+    
+    /*this reads in data and length from file*/
+    map_refresh(fd, 1, &(data), &len, sbuf.st_size,
+		"sievescript", "");
+    *d=(bytecode_input_t *)data;
+    
+    printf("\n");
+    
+    return (len/sizeof(int));
+}
+
+
+int main(int argc, char * argv[])
+{
+    bytecode_input_t * bc;
+    int script_fd;
+    
+    unsigned long len;
+    
+    if (argc!=2) {
+	 fprintf(stderr, "usage:\n %s script\n", argv[0]);
+	 exit(1);
+    }
+
+    /*get script*/
+    script_fd = open(argv[1], O_RDONLY);
+    if (script_fd == -1) 
+    {
+	printf("can not open script '%s'\n", argv[1]);
+	exit(1);
+    }
+    
+    lib_init();
+    len=load(script_fd,&bc);
+    close(script_fd);
+    
+    if (bc) {
+	dump2(bc, len );
+	exit(0);
+    } else {
+	exit(1);
+    }
+}
+
+static int write_list(int list_len, int i, bytecode_input_t * d)
+{
+    int x;
+    i++;
+    for (x=0; x<list_len; x++)
+    {
+	const char *data;
+	int len;
+	
+	i = unwrap_string(d, i, &data, &len);
+	
+	printf("{%d}%s\n", len, data);
+    }
+    return i;
+}
+
+static int printComparison(bytecode_input_t *d ,int i)
+{
+    printf("Comparison: ");
+    switch(ntohl(d[i].value))
+    {
+    case B_IS: printf("Is"); break;
+    case B_CONTAINS:printf("Contains"); break;
+    case B_MATCHES: printf("Matches"); break;
+    case B_REGEX: printf("Regex"); break;
+    case B_COUNT:
+	printf("Count");
+	
+	switch(ntohl(d[i+1].value))
+	{
+	case B_GT: printf(" greater than "); break;   
+	case B_GE: printf(" greater than or equal "); break;
+	case B_LT: printf(" less than "); break;
+	case B_LE: printf(" less than or equal "); break;
+	case B_NE: printf(" not equal "); break;
+	case B_EQ: printf(" equal "); break;
+	}
+
+	break;
+    case B_VALUE:
+	printf("Value");
+	
+	switch(ntohl(d[i+1].value))
+	{
+	case B_GT: printf(" greater than "); break;   
+	case B_GE: printf(" greater than or equal ");break;
+	case B_LT: printf(" less than ");    break;
+	case B_LE: printf(" less than or equal ");break;
+	case B_NE: printf(" not equal ");    break;
+	case B_EQ: printf(" equal ");break;
+	}
+	
+	break;
+    default:
+	exit(1);
+    }
+
+    switch (ntohl(d[i+2].value))
+    {
+    case B_ASCIICASEMAP: printf("   (ascii-casemap) "); break;
+    case B_OCTET: printf("    (octet) "); break;
+    case B_ASCIINUMERIC:  printf("   (ascii-numeric) "); break;
+    default: exit(1);
+    }
+    
+    printf("\n");
+    return i+3;
+}
+
+
+static int dump2_test(bytecode_input_t * d, int i)
+{
+    int l,x;
+    switch(ntohl(d[i].value)) {
+    case BC_FALSE:
+	printf("false");
+	i++;
+	break;
+    case BC_TRUE:
+	printf("true");
+	i++;
+	break;
+    case BC_NOT:/*2*/
+	/* XXX 
+	   there is a value being skipped in the second pass...
+	   no idea what it does, but it isn't carried to here...
+	   see bytecodee.c */
+	printf(" not(");
+	i=dump2_test(d, i+1);
+	printf(")\n");
+	break;
+    case BC_EXISTS:
+	printf("exists");
+	i=write_list(ntohl(d[i+1].len), i+2, d);
+	break;
+    case BC_SIZE:
+	printf("size");
+	if (ntohl(d[i+1].value)==B_OVER) {
+	    /* over */
+	    printf("over %d", ntohl(d[i+2].value));
+	} else {
+	    /* under */
+	    printf("under %d", ntohl(d[i+2].value));
+	}
+	i+=3;
+	break;
+    case BC_ANYOF:/*5*/
+	printf("any of \n(");
+	l=ntohl(d[i+1].len);
+	i+=3;
+	
+	for (x=0; x<l; x++)
+	{
+	    i=dump2_test(d,i);
+	    if((x+1)<l)
+		printf(" OR ");
+	}
+	
+	printf(")\n");	 
+	break;
+    case BC_ALLOF:/*6*/
+	printf("all of \n(");
+	l=ntohl(d[i+1].len);
+	i+=3;
+	
+	for (x=0; x<l; x++)
+	{
+	    i=dump2_test(d,i);
+	    if((x+1)<l)
+		printf(" AND ");
+	}
+	
+	printf(")\n");
+	break;
+    case BC_ADDRESS:/*7*/
+	printf("Address (");
+	i=printComparison(d, i+1);
+	printf("               type: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_ALL: printf("all"); break;
+	case B_LOCALPART:printf("localpart"); break;
+	case B_DOMAIN:printf("domain"); break;
+	case B_USER:printf("user"); break;
+	case B_DETAIL:printf("detail"); break;
+	}
+	printf("              Headers:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_ENVELOPE:/*8*/
+	printf("Envelope (");
+	i=printComparison(d, i+1);
+	printf("                type: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_ALL: printf("all"); break;
+	case B_LOCALPART:printf("localpart"); break;
+	case B_DOMAIN:printf("domain"); break;
+	case B_USER:printf("user"); break;
+	case B_DETAIL:printf("detail"); break;
+	}
+	printf("              Headers:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_HEADER:/*9*/
+	printf("Header [");
+	i= printComparison(d, i+1);
+	printf("              Headers: ");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data: ");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    default:
+	printf("WERT %d ", ntohl(d[i].value));
+    }   
+    return i;
+}
+
+static void dump2(bytecode_input_t *d, int bc_len)
+{
+    int i;
+    const char *data;
+    int len;
+    
+    if(memcmp(d, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	printf("not a bytecode file [magic number test failed]\n");
+	return;
+    }
+
+    i = BYTECODE_MAGIC_LEN / sizeof(bytecode_input_t);
+
+    printf("Sievecode version %d\n", ntohl(d[i].op));
+    if(!d) return;
+    
+    for(i++; i<bc_len;) 
+    {
+	switch(ntohl(d[i].op)) {
+	    
+	case B_STOP:/*0*/
+	    printf("%d: STOP\n",i);
+	    i++;
+	    break;
+	    
+	case B_KEEP:/*1*/
+	    printf("%d: KEEP\n",i);
+	    i++;
+	    break;
+	    
+	case B_DISCARD:/*2*/
+	    printf("%d: DISCARD\n",i);
+	    i++;
+	    break;
+	    
+	case B_REJECT:/*3*/
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf("%d: REJECT {%d}%s\n", i, len, data);
+	    break;
+
+	case B_FILEINTO: /*4*/
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf("%d: FILEINTO {%d}%s\n",i, len, data);
+	    break;
+
+	case B_REDIRECT: /*5*/
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf("%d: REDIRECT {%d}%s\n",i,len,data);
+	    break;
+	     
+	case B_IF:/*6*/
+	    printf("%d: IF (ends at %d)",i, ntohl(d[i+1].value));
+
+            /* there is no short circuiting involved here*/
+	    i = dump2_test(d,i+2);
+	    printf("\n");
+
+	    break;
+
+	case B_MARK:/*7*/
+	    printf("%d: MARK\n",i);
+	    i++;
+	    break;
+
+	case B_UNMARK:/*8*/
+	    printf("%d: UNMARK\n",i);
+	    i++;
+	    break;
+
+	case B_ADDFLAG: /*9*/
+	    printf("%d: ADDFLAG  {%d}\n",i,ntohl(d[i+1].len));
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+	    break;
+
+	case B_SETFLAG: /*10*/
+	    printf("%d: SETFLAG  {%d}\n",i,ntohl(d[i+1].len));
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+	    break;
+	    
+	case B_REMOVEFLAG: /*11*/
+	    printf("%d: REMOVEFLAG  {%d}\n",i,ntohl(d[i+1].len));
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+	    break;
+	    
+	case B_DENOTIFY:/*12*/
+	    printf("%d: DENOTIFY\n",i);
+	    i++; 
+	    printf("            PRIORITY(%d) Comparison type %d (relat %d)\n",
+		   ntohl(d[i].value), ntohl(d[i+1].value), ntohl(d[i+2].value));
+	    i+=3;
+
+	    i = unwrap_string(d, i+1, &data, &len);
+	    
+	    printf("           ({%d}%s)\n", len, (!data ? "[nil]" : data));
+	    break;
+	    
+	case B_NOTIFY: /*13*/
+	    i = unwrap_string(d, i+1, &data, &len);
+
+	    printf("%d: NOTIFY METHOD({%d}%s)\n",i,len,data);
+
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("            ID({%d}%s) OPTIONS ", len,
+		   (!data ? "[nil]" : data));
+
+	    i=write_list(ntohl(d[i].len),i+1,d);
+	    
+	    printf("            PRIORITY(%d)\n", ntohl(d[i].value));
+      	    i++;
+		  
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("            MESSAGE({%d}%s)\n", len, data);
+
+	    break;
+
+	case B_VACATION:/*14*/
+	    printf("%d: VACATION\n",i);
+	    /*add address list here!*/
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+
+	    i = unwrap_string(d, i, &data, &len);
+	  
+	    printf("%d SUBJ({%d}%s) \n",i, len, (!data ? "[nil]" : data));
+	    
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("%d MESG({%d}%s) \n", i, len, (!data ? "[nil]" : data));
+
+	    printf("DAYS(%d) MIME(%d)\n", ntohl(d[i].value), ntohl(d[i+1].value));
+	    i+=2;
+
+	    break;
+	case B_NULL:/*15*/
+	    printf("%d:NULL\n",i);
+	    i++;
+	    break;
+	case B_JUMP:/*16*/
+	    printf("%d:JUMP %d\n",i, ntohl(d[i+1].jump));
+	    i+=2;
+	    break;		  
+	default:
+	    printf("%d: %d (NOT AN OP)\n",i,ntohl(d[i].op));
+	    exit(1);
+	}
+    }
+    printf("full len is: %d\n", bc_len);
+}
+
+
diff -r 923786016963 src/lib-sieve/cmu/libsieve/tree.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/tree.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,224 @@
+/* tree.c -- abstract syntax tree handling
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+stringlist_t *new_sl(char *s, stringlist_t *n)
+{
+    stringlist_t *p = (stringlist_t *) xmalloc(sizeof(stringlist_t));
+    p->s = s;
+    p->next = n;
+    return p;
+}
+
+
+tag_t *new_tag(int type, char *s)
+{
+    tag_t *p = (tag_t *) xmalloc(sizeof(tag_t));
+    p->type = type;
+    p->arg = s;
+    return p;
+}
+
+taglist_t *new_taglist(tag_t *t, taglist_t *n)
+{
+    taglist_t *p = (taglist_t *) xmalloc(sizeof(taglist_t));
+    p->t = t;
+    p->next = n;
+    return p;
+}
+
+test_t *new_test(int type) 
+{
+    test_t *p = (test_t *) xmalloc(sizeof(test_t));
+    p->type = type;
+    return p;
+}
+
+testlist_t *new_testlist(test_t *t, testlist_t *n)
+{
+    testlist_t *p = (testlist_t *) xmalloc(sizeof(testlist_t));
+    p->t = t;
+    p->next = n;
+    return p;
+}
+
+commandlist_t *new_command(int type)
+{
+    commandlist_t *p = (commandlist_t *) xmalloc(sizeof(commandlist_t));
+    p->type = type;
+    p->next = NULL;
+    return p;
+}
+
+commandlist_t *new_if(test_t *t, commandlist_t *y, commandlist_t *n)
+{
+    commandlist_t *p = (commandlist_t *) xmalloc(sizeof(commandlist_t));
+    p->type = IF;
+    p->u.i.t = t;
+    p->u.i.do_then = y;
+    p->u.i.do_else = n;
+    p->next = NULL;
+    return p;
+}
+
+void free_sl(stringlist_t *sl) 
+{
+    stringlist_t *sl2;
+    
+    while (sl != NULL) {
+	sl2 = sl->next;
+
+	if (sl->s) free(sl->s);
+
+	free(sl);
+	sl = sl2;
+    }
+}
+
+
+void free_test(test_t *t);
+
+static void free_tl(testlist_t *tl)
+{
+    testlist_t *tl2;
+
+    while (tl) {
+	tl2 = tl->next;
+
+	if (tl->t) free_test(tl->t);
+
+	free(tl);
+	tl = tl2;
+    }
+}
+
+void free_test(test_t *t)
+{
+    if (t == NULL) return;
+
+    switch (t->type) {
+    case ANYOF:
+    case ALLOF:
+	free_tl(t->u.tl);
+	break;
+
+    case EXISTS:
+	free_sl(t->u.sl);
+	break;
+
+    case SIZE:
+    case SFALSE:
+    case STRUE:
+	break;
+
+    case HEADER:
+	free_sl(t->u.h.sl);
+	free_sl(t->u.h.pl);
+	
+	break;
+
+    case ADDRESS:
+	free_sl(t->u.ae.sl);
+	free_sl(t->u.ae.pl);
+	break;
+
+    case NOT:
+	free_test(t->u.t);
+	break;
+    }
+
+    free(t);
+}
+
+void free_tree(commandlist_t *cl)
+{
+    commandlist_t *cl2;
+
+    while (cl != NULL) {
+	cl2 = cl->next;
+	switch (cl->type) {
+	case IF:
+	    free_test(cl->u.i.t);
+	    free_tree(cl->u.i.do_then);
+	    free_tree(cl->u.i.do_else);
+	    break;
+
+	case FILEINTO:
+	case REDIRECT:
+	case REJCT:
+	    if (cl->u.str) free(cl->u.str);
+	    break;
+
+	case VACATION:
+	    if (cl->u.v.subject) free(cl->u.v.subject);
+	    if (cl->u.v.addresses) free_sl(cl->u.v.addresses);
+	    if (cl->u.v.message) free(cl->u.v.message);
+	    break;
+	    
+	case SETFLAG:
+	case ADDFLAG:
+	case REMOVEFLAG:
+	    free_sl(cl->u.sl);
+	    break;
+
+	case KEEP:
+	case STOP:
+	case DISCARD:
+	    break;
+
+	case NOTIFY:
+	    if (cl->u.n.method) free(cl->u.n.method);
+	    if (cl->u.n.id) free(cl->u.n.id);
+	    if (cl->u.n.options) free_sl(cl->u.n.options);
+	    if (cl->u.n.message) free(cl->u.n.message);
+	    break;
+
+	case DENOTIFY:
+	    if (cl->u.d.pattern) {
+#ifdef ENABLE_REGEX
+		if (cl->u.d.comptag == REGEX) {
+		    regfree((regex_t *) cl->u.d.pattern);
+		}
+#endif
+		free(cl->u.d.pattern);
+	    }
+	    break;
+	}
+
+	free(cl);
+	cl = cl2;
+    }
+}
diff -r 923786016963 src/lib-sieve/cmu/libsieve/tree.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/libsieve/tree.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,139 @@
+/* tree.h -- abstract syntax tree
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef TREE_H
+#define TREE_H
+
+#include "comparator.h"
+
+/* abstract syntax tree for sieve */
+typedef struct Stringlist stringlist_t;
+typedef struct Commandlist commandlist_t;
+typedef struct Test test_t;
+typedef struct Testlist testlist_t;
+typedef struct Tag tag_t;
+typedef struct Taglist taglist_t;
+
+struct Stringlist {
+    char *s;
+    stringlist_t *next;
+};
+
+ 
+struct Tag {
+    int type;
+    char *arg;
+};
+
+struct Taglist {
+    tag_t *t;
+    taglist_t *next;
+};
+
+struct Test {
+    int type;
+    union {
+	testlist_t *tl; /* anyof, allof */
+	stringlist_t *sl; /* exists */
+	struct { /* it's a header test */
+	    int comptag;
+	    char * comparator;
+	    int relation;
+	    void *comprock;
+	    stringlist_t *sl;
+	    stringlist_t *pl;
+	} h;
+	struct { /* it's an address or envelope test */
+	    int comptag;
+	    char * comparator;
+	    int relation; 
+	    void *comprock;
+	    stringlist_t *sl;
+	    stringlist_t *pl;
+            int addrpart;
+	} ae; 
+	test_t *t; /* not */
+	struct { /* size */
+	    int t; /* tag */
+	    int n; /* param */
+	} sz;
+    } u;
+};
+
+struct Testlist {
+    test_t *t;
+    testlist_t *next;
+};
+
+struct Commandlist {
+    int type;
+    union {
+        char *str;
+	stringlist_t *sl; /* the parameters */
+	struct { /* it's an if statement */
+	    test_t *t;
+	    commandlist_t *do_then;
+	    commandlist_t *do_else;
+	} i;
+	struct { /* it's a vacation action */
+	    char *subject;
+	    int days;
+	    stringlist_t *addresses;
+	    char *message;
+	    int mime;
+	} v;
+	struct { /* it's a notify action */
+	    char *method;
+	    char *id;
+	    stringlist_t *options;
+	    int priority;
+	    char *message;
+	} n;
+	struct { /* it's a denotify action */
+	    int comptag;
+	    int relation;
+	    void *comprock;
+	    void *pattern;
+	    int priority;
+	} d;
+    } u;
+    struct Commandlist *next;
+};
+
+stringlist_t *new_sl(char *s, stringlist_t *n);
+tag_t *new_tag(int type, char *s);
+taglist_t *new_taglist(tag_t *t, taglist_t *n);
+test_t *new_test(int type);
+testlist_t *new_testlist(test_t *t, testlist_t *n);
+commandlist_t *new_command(int type);
+commandlist_t *new_if(test_t *t, commandlist_t *y, commandlist_t *n);
+
+void free_sl(stringlist_t *sl);
+void free_test(test_t *t);
+void free_tree(commandlist_t *cl);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/map.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/map.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,55 @@
+#include "lib.h"
+#include "map.h"
+
+#include <unistd.h>
+
+static ssize_t read_full_n(int fd, void *data, size_t size)
+{
+	ssize_t ret, all_ret = 0;
+
+	while (size > 0) {
+		ret = read(fd, data, size);
+		if (ret <= 0)
+			return ret;
+
+		data = PTR_OFFSET(data, ret);
+		all_ret += ret;
+		size -= ret;
+	}
+
+	return all_ret;
+}
+
+void map_refresh(int fd, int onceonly __attr_unused__, const char **base,
+		 unsigned long *len, unsigned long newlen,
+		 const char *name, const char *mboxname __attr_unused__)
+{
+	ssize_t ret;
+	void *p;
+
+	if (newlen == 0) {
+		/* the file is a broken zero-byte file */
+		*len = 0;
+		return;
+	}
+
+	*base = p = i_malloc(newlen);
+	*len = newlen;
+
+	ret = read_full_n(fd, p, newlen);
+	if (ret < 0) {
+		i_error("read_full_n(%s) failed: %m", name);
+		ret = 0;
+	}
+
+	*len = ret;
+}
+
+void map_free(const char **base, unsigned long *len __attr_unused__)
+{
+	char *x = (char *) *base;
+
+	i_free(x);
+	*base = NULL;
+}
+
diff -r 923786016963 src/lib-sieve/cmu/map.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/map.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,10 @@
+#ifndef __MAP_H
+#define __MAP_H
+
+extern void map_refresh(int fd, int onceonly, const char **base,
+			unsigned long *len, unsigned long newlen,
+			const char *name, const char *mboxname);
+
+extern void map_free(const char **base, unsigned long *len);
+
+#endif
diff -r 923786016963 src/lib-sieve/cmu/xmalloc.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/cmu/xmalloc.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,26 @@
+#ifndef __XMALLOC_H
+#define __XMALLOC_H
+
+#include <stdlib.h>
+#include <string.h>
+
+#define xmalloc(n) malloc(n)
+#define xrealloc(n, m) realloc(n, m)
+#define xzmalloc(n) calloc(n, 1)
+#define xstrdup(s) strdup(s)
+
+/* missing headers.. */
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <regex.h>
+#include <fcntl.h>
+
+/* dovecot kludges */
+#include "lib.h"
+
+/* we don't have strlcpy, but strocpy is the same except for return value */
+#define strlcpy strocpy
+
+#define lcase str_lcase
+
+#endif
diff -r 923786016963 src/lib-sieve/sieve-implementation-private.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/sieve-implementation-private.h	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,62 @@
+#ifndef __SIEVE_IMPLEMENTATION_PRIVATE_H
+#define	__SIEVE_IMPLEMENTATION_PRIVATE_H
+
+#include "lib.h"
+#include "mail-storage.h"
+
+struct sieve_script;
+
+#define DUPLICATE_DEFAULT_KEEP (3600 * 24)
+
+struct sieve_implementation_vfuncs {
+	int (*compile) 
+		(struct sieve_script *script, bool verify_only);
+	int (*run) 
+		(struct sieve_script *script, void *context);
+	const char *(*get_capabilities) ();
+};
+
+struct sieve_implementation {
+	const char *name;
+	struct sieve_implementation_vfuncs v;
+};
+
+/* Error management */
+void sieve_clear_error(void);
+void sieve_set_error(const char *fmt, ...);
+void sieve_set_internal_error(void);
+void sieve_set_critical(const char *fmt, ...);
+
+void sieve_implementation_register(struct sieve_implementation *sieveimpl);
+
+void sieve_implementation_unregister(struct sieve_implementation *sieveimpl);
+
+void sieve_register_implementations(void);
+
+const char *const *sieve_runenv_get_mail_headers
+	(void *context, const char *field);
+const char *sieve_runenv_get_mail_first_header
+	(void *context, const char *field);
+uoff_t sieve_runenv_get_mail_size
+	(void *context);
+int sieve_runenv_get_envelope
+  (void *context, const char *field, array_t *contents);
+
+int sieve_runenv_is_duplicate
+	(void *context, const void *id, size_t id_size);
+void sieve_runenv_mark_duplicate
+  (void *context, const void *id, size_t id_size, time_t interval);
+
+int sieve_runenv_send_message
+  (void *context, const char *from, const char *to, const char *subject,
+   bool mime, const char *msg, const char **outmsgid);
+int sieve_runenv_send_rejection
+  (void *context, const char *reason);
+int sieve_runenv_send_forward
+	(void *context, const char *forwardto);
+int sieve_runenv_mail_save
+  (void *context, const char *mailbox, char **flags, unsigned int nflags);
+
+#include "sieve-implementation.h"
+
+#endif
diff -r 923786016963 src/lib-sieve/sieve-implementation.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/sieve-implementation.c	Wed Mar 05 10:10:40 2008 +0100
@@ -0,0 +1,235 @@
+#include "lib.h"
+#include "array.h"
+#include "ioloop.h"
+#include "sieve-implementation-private.h"
+#include "sieve-implementation.h"
+
+#include <time.h>
+
+/* Message to show to users when critical error occurs */
+#define CRITICAL_MSG \
+  "Internal error occurred. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+static array_t ARRAY_DEFINE(implementations, struct sieve_implementation *);
+
+static struct sieve_implementation *cursieveimpl = NULL;
+static struct sieve_runtime_environment *runenv = NULL;
+static char *sieve_error;
+
+void sieve_deinit(void)
+{
+	if (array_is_created(&implementations))
+		array_free(&implementations);
+}
+
+void sieve_implementation_register(struct sieve_implementation *sieveimpl)
+{
+	/* append it after the list, so the autodetection order is correct */
+	array_append(&implementations, &sieveimpl, 1);
+}
+
+void sieve_implementation_unregister(struct sieve_implementation *sieveimpl)
+{
+	struct sieve_implementation *const *impls;
+	unsigned int i, count;
+
+	impls = array_get(&implementations, &count);
+	for (i = 0; i < count; i++) {
+	 	if (impls[i] == sieveimpl) {
+			array_delete(&implementations, i, 1);
+			break;
+		}
+	}
+}
+
+/* FIXME: Make this function dependent on ./configure
+ */
+extern struct sieve_implementation cmu_sieve;
+void sieve_register_implementations()
+{
+	sieve_implementation_register(&cmu_sieve);
+}
+
+void sieve_set_runtime_environment(struct sieve_runtime_environment *env) 
+{
+	runenv = env;
+}
+
+void sieve_init(void)
+{
+	ARRAY_CREATE(&implementations, default_pool, struct sieve_implementation *, 8);
+	
+	sieve_register_implementations();
+}
+
+/* Sets the active implementation */
+int sieve_set_implementation(const char *name)
+{
+	struct sieve_implementation *const *impls;
+	unsigned int i, count;
+
+	i_assert(name != NULL);
+
+	impls = array_get(&implementations, &count);
+	for (i = 0; i < count; i++) {
+		if (strcasecmp(impls[i]->name, name) == 0) {
+			cursieveimpl = impls[i];
+			return 0;
+		}
+	}
+
+	return -1;
+}			
+
+void sieve_clear_error(void)
+{
+	i_free(sieve_error);
+	sieve_error = NULL;
+}
+
+void sieve_set_error(const char *fmt, ...)
+{
+	va_list va;
+
+	sieve_clear_error();
+
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		sieve_error = i_strdup_vprintf(fmt, va);
+		va_end(va);
+	}
+}
+
+void sieve_set_internal_error(void)
+{
+	struct tm *tm;
+	char str[256];
+	
+	tm = localtime(&ioloop_time);
+	
+	i_free(sieve_error);
+	sieve_error =
+	  strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+	  i_strdup(str) : i_strdup(CRITICAL_MSG);
+}
+
+void sieve_set_critical(const char *fmt, ...)
+{
+  	va_list va;
+  
+	sieve_clear_error();
+	if (fmt != NULL) {
+	  	va_start(va, fmt);
+		i_error("%s", t_strdup_vprintf(fmt, va));
+		va_end(va);
+		
+		/* critical errors may contain sensitive data, so let user
+		   see only "Internal error" with a timestamp to make it
+		   easier to look from log files the actual error message. */
+		sieve_set_internal_error();
+	}
+}
+
+const char *sieve_get_last_error(void)
+{
+  	/* We get here only in error situations, so we have to return some
+	   error. If storage->error is NULL, it means we forgot to set it at
+	   some point.. */
+  	return sieve_error != NULL ? sieve_error : "Unknown error";
+}
+
+int sieve_compile(struct sieve_script *script, bool verify_only) 
+{
+  	i_assert(cursieveimpl != NULL);
+	return cursieveimpl->v.compile(script, verify_only);
+}
+
+int sieve_run(struct sieve_script *script, void *context)
+{
+  	i_assert(cursieveimpl != NULL);
+	return cursieveimpl->v.run(script, context);
+}
+
+const char *sieve_get_capabilities(void)
+{
+  	i_assert(cursieveimpl != NULL);
+	return cursieveimpl->v.get_capabilities();
+}
+
+/* Runtime environment */
+
+const char *const *sieve_runenv_get_mail_headers
+  (void *context, const char *field)
+{
+	i_assert(runenv != NULL);
+	return runenv->get_mail_headers(context, field);
+}
+
+const char *sieve_runenv_get_mail_first_header(void *context, const char *field)
+{
+	const char *const *list = sieve_runenv_get_mail_headers(context, field);
+	return list == NULL ? NULL : list[0];
+}
+
+uoff_t sieve_runenv_get_mail_size
+  (void *context)
+{
+  	i_assert(runenv != NULL);
+	return runenv->get_mail_size(context);
+}
+
+int sieve_runenv_is_duplicate
+  (void *context, const void *id, size_t id_size)
+{
+  	i_assert(runenv != NULL);
+	return runenv->is_duplicate(context, id, id_size);
+}
+
+void sieve_runenv_mark_duplicate
+  (void *context, const void *id, size_t id_size, time_t interval)
+{
+  	i_assert(runenv != NULL);
+	runenv->mark_duplicate(context, id, id_size, interval);
+}
+
+int sieve_runenv_send_message
+  (void *context, const char *from, const char *to, const char *subject,
+   bool mime, const char *msg, const char **outmsgid)
+{
+	i_assert(runenv != NULL);
+
+	return runenv->send_message
+	  (context, from, to, subject, mime, msg, outmsgid);
+}
+
+int sieve_runenv_get_envelope
+	(void *context, const char *field, array_t *contents)
+{
+  	i_assert(runenv != NULL);
+
+	return runenv->get_envelope(context, field, contents);
+}
+
+int sieve_runenv_send_rejection
+	(void *context, const char *reason)
+{
+  	i_assert(runenv != NULL);
+
+	return runenv->send_rejection(context, reason);
+}
+
+int sieve_runenv_send_forward(void *context, const char *forwardto)
+{
+  	i_assert(runenv != NULL);
+
+	return runenv->send_forward(context, forwardto);
+}
+
+int sieve_runenv_mail_save
+  (void *context, const char *mailbox, char **flags, unsigned int nflags)
+{
+  	i_assert(runenv != NULL);
+
+	return runenv->mail_save(context, mailbox, flags, nflags);
+}
diff -r 923786016963 src/lib-sieve/sieve-implementation.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sieve/sieve-implementation.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,46 @@
+#ifndef __SIEVE_IMPLEMENTATION_H
+#define __SIEVE_IMPLEMENTATION_H
+
+struct sieve_script;
+
+struct sieve_runtime_environment {
+	const char *const *(*get_mail_headers)
+		(void *context, const char *field);
+	uoff_t (*get_mail_size)
+		(void *context);
+	int (*get_envelope)
+		(void *context, const char *field, array_t *contents);
+
+	int (*is_duplicate)
+		(void *context, const void *id, size_t id_size);
+	void (*mark_duplicate)
+		(void *context, const void *id, size_t id_size, time_t interval);
+
+	int (*send_message)
+		(void *context, const char *from, const char *to, const char *subject,
+		bool mime, const char *msg, const char **outmsgid);
+	int (*send_rejection)
+		(void *context, const char *reason);
+	int (*send_forward)
+		(void *context, const char *forwardto);
+	int (*mail_save)
+		(void *context, const char *mailbox, char **flags, unsigned int nflags);
+};
+
+void sieve_init(void);
+void sieve_deinit(void);
+
+int sieve_set_implementation(const char *name);
+
+void sieve_set_runtime_environment(struct sieve_runtime_environment *env);
+
+const char *sieve_get_last_error(void);
+
+int sieve_compile(struct sieve_script *script, bool verify_only);
+
+int sieve_run(struct sieve_script *script, void *context);
+
+const char *sieve_get_capabilities(void);
+
+#endif
+
diff -r 923786016963 src/lib-sievestorage/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/Makefile.am	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,19 @@
+noinst_LIBRARIES = libsievestorage.a
+
+INCLUDES = \
+	-I$(top_srcdir)/src/lib \
+	-I$(top_srcdir)/src/lib-mail \
+  -I$(dovecotsievedir)/src/libsieve
+
+libsievestorage_a_SOURCES = \
+	sieve-save.c \
+	sieve-script.c \
+	sieve-list.c \
+	sieve-storage.c 
+
+noinst_HEADERS = \
+	sieve-save.h \
+	sieve-script.h \
+	sieve-list.h \
+	sieve-storage.h \
+	sieve-storage-private.h 
diff -r 923786016963 src/lib-sievestorage/sieve-list.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-list.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,116 @@
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage-private.h"
+#include "sieve-script.h"
+#include "sieve-list.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context {
+	pool_t pool;
+	struct sieve_storage *storage;
+
+	const char *active;
+	const char *dir;
+	DIR *dirp;
+
+	unsigned int seen_active:1; // Just present for assertions
+};
+
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage)
+{	
+	struct sieve_list_context *ctx;
+	const char *active;
+	pool_t pool;
+	DIR *dirp;
+
+	/* Open the directory */
+	if ( (dirp = opendir(storage->dir)) == NULL ) {
+		sieve_storage_set_critical(storage, "opendir(%s) failed: %m",
+					   storage->dir);
+		return NULL;
+	}
+
+	t_push();
+
+	/* Get the name of the active script */
+	if ( (active = sieve_storage_get_active_scriptname(storage)) 
+		== NULL ) {
+		t_pop();
+		return NULL;
+	}
+
+	pool = pool_alloconly_create("sieve_list_context", 4096);
+	ctx = p_new(pool, struct sieve_list_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->dirp = dirp;
+	ctx->active = p_strdup(pool, active);
+	ctx->seen_active = FALSE;
+
+	t_pop();
+
+	return ctx;
+}
+
+const char *sieve_storage_list_next
+	(struct sieve_list_context *ctx, bool *active)
+{
+	const struct sieve_storage *storage = ctx->storage;
+	struct dirent *dp;
+	const char *scriptname;
+
+	*active = FALSE;
+
+	for (;;) {
+		if ( (dp = readdir(ctx->dirp)) == NULL )
+			return NULL;
+
+		scriptname = sieve_storage_file_get_scriptname
+			(storage, dp->d_name);	
+		
+		if (scriptname != NULL ) {
+			/* Don't list our active sieve script link if the link 
+			 * resides in the script dir (generally a bad idea).
+			 */
+			if ( *(storage->link_path) == '\0' && 
+				strcmp(storage->active_fname, dp->d_name) == 0 )
+				continue;
+		
+			break;
+		}
+	}
+
+	if ( ctx->active != NULL && 
+		strcmp(scriptname, ctx->active) == 0 ) {
+		*active = TRUE;
+		ctx->active = NULL;
+	}
+
+	return scriptname;
+}
+
+int sieve_storage_list_deinit(struct sieve_list_context **ctx)
+{
+	if (closedir((*ctx)->dirp) < 0) {
+		sieve_storage_set_critical((*ctx)->storage, "closedir(%s) failed: %m",
+					   (*ctx)->storage->dir);
+
+		pool_unref((*ctx)->pool);
+		*ctx = NULL;
+		return -1;
+	}
+
+	pool_unref((*ctx)->pool);
+	*ctx = NULL;
+	return 1;
+}
+
+
+	
+    
diff -r 923786016963 src/lib-sievestorage/sieve-list.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-list.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,30 @@
+#ifndef __SIEVE_LIST_H
+#define __SIEVE_LIST_H
+
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage.h"
+#include "sieve-list.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context;
+
+/* Create a context for listing the scripts in the storage */
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage);
+
+/* Get the next script in the storage. */
+const char *sieve_storage_list_next(struct sieve_list_context *ctx, bool *active);
+
+/* Destroy the listing context */
+int sieve_storage_list_deinit(struct sieve_list_context **ctx);
+
+#endif
+
+
+	
+    
diff -r 923786016963 src/lib-sievestorage/sieve-save.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-save.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,322 @@
+#include "lib.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "array.h"
+#include "buffer.h"
+#include "ostream.h"
+#include "ostream-crlf.h"
+#include "str.h"
+#include "sieve-storage-private.h"
+#include "sieve-save.h"
+#include "sieve-script.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <utime.h>
+#include <sys/stat.h>
+
+struct sieve_save_context {
+	pool_t pool;
+
+	struct sieve_storage *storage;
+	const char *scriptname;
+	struct sieve_script *scriptobject;
+
+	struct istream *input;
+	struct ostream *output;
+	int fd;
+	const char *tmp_path;
+
+	unsigned int failed:1;
+	unsigned int moving:1;
+	unsigned int finished:1;
+};
+
+static const char *sieve_generate_tmp_filename(const char *scriptname, const struct timeval *tv)
+{
+	static unsigned int create_count = 0;
+	static time_t first_stamp = 0;
+
+	if (first_stamp == 0 || first_stamp == ioloop_time) {
+	  	/* it's possible that within last second another process had
+		   the same PID as us. Use usecs to make sure we don't create
+		   duplicate base name. */
+		first_stamp = ioloop_time;
+		return t_strdup_printf
+		  ("%s-%s.P%sQ%uM%s.%s",
+		   scriptname,
+		   dec2str(tv->tv_sec), my_pid,
+		   create_count++,
+		   dec2str(tv->tv_usec), my_hostname);
+	} else {
+		/* Don't bother with usecs. Saves a bit space :) */
+		return t_strdup_printf
+		  ("%s-%s.P%sQ%u.%s",
+		   scriptname,
+		   dec2str(tv->tv_sec), my_pid,
+		   create_count++, my_hostname);
+	}
+}
+
+static int sieve_create_tmp
+(struct sieve_storage *storage, const char *scriptname, const char **fpath_r)
+{
+ 	const char *path, *tmp_fname;
+	struct stat st;
+	struct timeval *tv, tv_now;
+	pool_t pool;
+	int fd;
+
+	tv = &ioloop_timeval;
+	pool = pool_alloconly_create("script_tmp", 4096);
+	for (;;) {
+		p_clear(pool);
+		tmp_fname = sieve_generate_tmp_filename(scriptname, tv);
+
+		path = p_strconcat(pool, storage->dir, "/tmp/", tmp_fname, ".sieve", NULL);
+		if ( stat(path, &st) < 0 ) {
+			if ( errno == ENOENT) {
+				/* NICE! doesn't exist */
+				fd = open(path, O_WRONLY | O_CREAT | O_EXCL, 0600);
+		  
+				/* Something went wrong */
+				if (fd != -1 || errno != EEXIST)
+			  		break;
+			} else {
+				sieve_storage_set_critical(storage,
+                	"stat(%s) failed: %m", path);
+				return -1;
+			}
+		}
+
+		/* Wait and try again - very unlikely */
+		sleep(2);
+		tv = &tv_now;
+		if (gettimeofday(&tv_now, NULL) < 0)
+			i_fatal("gettimeofday(): %m");
+	}
+	
+	*fpath_r = t_strdup(path);
+	if (fd == -1) {
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error(storage,
+				"Not enough disk space");
+		} else {
+			sieve_storage_set_critical(storage,
+				"open(%s) failed: %m", path);
+        }
+    } 
+
+	pool_unref(pool);
+	return fd;
+}
+
+static int sieve_script_move(struct sieve_save_context *ctx,
+  const char *dst)
+{
+	int failed;
+
+	t_push();
+
+	/* Using rename() to ensure existing files are replaced
+	 * without conflicts with other processes using the same
+	 * file. The kernel wont fully delete the original until
+	 * all processes have closed the file.
+	 */
+	if (rename(ctx->tmp_path, dst) == 0)
+		failed = FALSE;
+	else {
+		failed = TRUE;
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error
+			  (ctx->storage, "Not enough disk space");
+		} else {
+			sieve_storage_set_critical
+			  (ctx->storage, "link(%s, %s) failed: %m", ctx->tmp_path, dst);
+		}
+	}
+
+	/* Always destroy temp file */
+	(void)unlink(ctx->tmp_path);
+
+	t_pop();
+	return !failed;
+}
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input)
+{
+	struct sieve_save_context *ctx;
+	pool_t pool;
+	struct ostream *output;
+	const char *path;
+
+	/* Prevent overwriting the active script link when it resides in the 
+	 * sieve storage directory.
+	 */
+	if ( *(storage->link_path) == '\0' ) {
+		const char *svext;
+		size_t namelen;
+
+		svext = strrchr(storage->active_fname, '.');
+		namelen = svext - storage->active_fname;
+		if ( svext != NULL && strncmp(svext+1, "sieve", 5) == 0 &&
+			strlen(scriptname) == namelen && 
+			strncmp(scriptname, storage->active_fname, namelen) == 0 ) 
+		{
+			sieve_storage_set_error(
+				storage, "Script name '%s' is reserved for internal use.", 
+				scriptname); 
+			return NULL;
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_save_context", 4096);
+	ctx = p_new(pool, struct sieve_save_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->scriptname = scriptname;
+	ctx->scriptobject = NULL;
+
+	t_push();
+
+	ctx->fd = sieve_create_tmp(storage, scriptname, &path);
+	if (ctx->fd == -1) {
+		ctx->failed = TRUE;
+		t_pop();
+		pool_unref(pool);
+		return NULL;
+	}
+
+	ctx->input = input;
+
+	output = o_stream_create_file(ctx->fd, system_pool, 0, FALSE);
+	/*ctx->output = (storage->flags & SIEVE_STORAGE_FLAG_SAVE_CRLF) != 0 ?
+		o_stream_create_crlf(default_pool, output) :
+		o_stream_create_lf(default_pool, output);
+	o_stream_unref(&output);*/
+	ctx->output = output;
+
+	ctx->tmp_path = p_strdup(pool, path);
+	ctx->failed = FALSE;
+
+	t_pop();	
+	return ctx;
+}
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx)
+{
+	if (o_stream_send_istream(ctx->output, ctx->input) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+		return -1;
+	}
+	return 0;
+}
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx)
+{
+	int output_errno;
+
+	ctx->finished = TRUE;
+	if (ctx->failed && ctx->fd == -1) {
+		/* tmp file creation failed */
+		return -1;
+	}
+
+	t_push();
+	output_errno = ctx->output->stream_errno;
+	o_stream_destroy(&ctx->output);
+
+	if (fsync(ctx->fd) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+					  "fsync(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+	}
+	if (close(ctx->fd) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+					  "close(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+	}
+	ctx->fd = -1;
+
+	if (ctx->failed) {
+		/* delete the tmp file */
+		if (unlink(ctx->tmp_path) < 0 && errno != ENOENT) 
+			i_warning("Unlink(%s) failed: %m", ctx->tmp_path);
+
+		errno = output_errno;
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error(ctx->storage,
+					       "Not enough disk space");
+		} else if (errno != 0) {
+			sieve_storage_set_critical(ctx->storage,
+				"write(%s) failed: %m", ctx->tmp_path);
+		}
+
+		t_pop();
+		return -1;
+	}
+	t_pop();
+
+	return 0;
+}
+
+static void sieve_storage_save_destroy(struct sieve_save_context *ctx)
+{
+	if (ctx->scriptobject != NULL)
+		sieve_script_unref(&(ctx->scriptobject));
+
+	pool_unref(ctx->pool);
+}
+
+struct sieve_script *sieve_storage_save_get_tempscript
+	(struct sieve_save_context *ctx)
+{
+	if (ctx->failed) 
+		return NULL;
+
+	ctx->scriptobject = sieve_script_init_from_file(ctx->storage, ctx->scriptname,
+  	ctx->tmp_path, NULL);	
+
+	return ctx->scriptobject;
+}
+
+int sieve_storage_save_commit(struct sieve_save_context *ctx)
+{
+	const char *dest_path;
+	bool failed = FALSE;
+
+	i_assert(ctx->output == NULL);
+	i_assert(ctx->finished);
+
+	t_push();
+
+	dest_path = t_strconcat(ctx->storage->dir, "/", ctx->scriptname, ".sieve", NULL);
+
+	failed = !sieve_script_move(ctx, dest_path);
+	
+	t_pop();
+
+	sieve_storage_save_destroy(ctx);
+
+	return !failed;
+}
+
+void sieve_storage_save_abort(struct sieve_save_context *ctx)
+{
+	ctx->failed = TRUE;
+
+	if (!ctx->finished) 
+		(void)sieve_storage_save_finish(ctx);
+	else
+		(void)unlink(ctx->tmp_path);
+
+	i_assert(ctx->output == NULL);
+
+	sieve_storage_save_destroy(ctx);
+}
diff -r 923786016963 src/lib-sievestorage/sieve-save.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-save.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,24 @@
+#ifndef __SIEVE_SAVE_H
+#define __SIEVE_SAVE_H
+
+#include "sieve-storage.h"
+
+struct sieve_save_context;
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input);
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx);
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx);
+
+struct sieve_script *sieve_storage_save_get_tempscript
+  (struct sieve_save_context *ctx);
+
+void sieve_storage_save_abort(struct sieve_save_context *ctx);
+
+int sieve_storage_save_commit(struct sieve_save_context *ctx);
+
+#endif
+
diff -r 923786016963 src/lib-sievestorage/sieve-script.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-script.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,634 @@
+#include "lib.h"
+#include "mempool.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "file-copy.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-private.h"
+#include "sieve-script.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+#include <fcntl.h>
+
+struct sieve_script *sieve_script_init_from_file
+  (struct sieve_storage *storage, const char *scriptname, 
+	const char *filename, bool *exists)
+{
+ 	int ret;
+	struct stat st;
+	pool_t pool;
+	struct sieve_script *script = NULL;	
+
+	/* Prevent initializing the active script link as a script when it
+     * resides in the sieve storage directory.
+	 */
+	if ( *(storage->link_path) == '\0' ) {
+		const char *fname;
+
+		fname = strrchr(filename, '/');
+		if ( fname == NULL )
+			fname = filename;
+		else
+			fname++;
+
+		if ( strcmp(fname, storage->active_fname) == 0 ) {
+			if ( exists != NULL )
+				*exists = FALSE;
+			return NULL;
+		}
+	}
+
+	/* Perform existance check if required */
+	if (exists != NULL) {
+		if (*exists) {
+			*exists = FALSE;
+			ret = stat(filename, &st);
+			
+			if ( ret < 0 ) {
+			  	if ( errno == ENOENT ) {
+				  	return NULL;
+				}
+
+				sieve_storage_set_critical
+				  (storage,	 
+					"Performing stat() on sieve file '%s' failed: %m", filename);
+				return NULL;
+			}
+
+			if ( !S_ISREG(st.st_mode) ) {
+			  	sieve_storage_set_critical
+				  (storage, "Sieve file '%s' is not a regular file.", filename);
+				return NULL;
+			}
+	
+			/* Script found */
+			*exists = TRUE;
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_script", 4096);	
+	script = p_new(pool, struct sieve_script, 1);
+	script->pool = pool;
+	script->refcount = 1;
+	script->name = p_strdup(pool, scriptname);
+	script->storage = storage;
+	script->size = st.st_size;
+
+	script->filename = p_strdup(pool, filename);
+	script->istream = NULL;	
+
+	return script;
+}
+
+struct sieve_script *sieve_script_init
+	(struct sieve_storage *storage, const char *scriptname, bool *exists)
+{	
+	struct sieve_script *script;
+	const char *filename;
+
+	t_push();
+
+	filename = t_strconcat
+	  ( storage->dir, "/", scriptname, ".sieve", NULL );
+
+	script = sieve_script_init_from_file(storage, scriptname, filename, exists);
+
+	t_pop();
+
+	return script;
+}
+
+void sieve_script_ref(struct sieve_script *script)
+{
+	script->refcount++;
+}
+
+void sieve_script_unref(struct sieve_script **script)
+{
+  	i_assert((*script)->refcount > 0);
+	
+	if (--(*script)->refcount != 0)
+	  	return;
+
+	if ((*script)->istream != NULL ) 
+	  	i_stream_unref(&(*script)->istream);
+
+	pool_unref((*script)->pool);
+	
+	*script = NULL;
+}
+
+const char *sieve_script_name(struct sieve_script *script)
+{
+	return script->name;
+}
+
+/* sieve_script_filename(): 
+ * Returns the filename of the script. If the implemented storage
+ * does not actually store scripts as a file a copy must be put
+ * somewhere in /tmp or so. Don't use this function if you can
+ * also work with a stream.
+ */
+const char *sieve_script_filename(struct sieve_script *script)
+{
+ 	return script->filename;
+}
+
+static int
+sieve_storage_open_fd(struct sieve_storage *storage, const char *path, int *fd)
+{
+	*fd = open(path, O_RDONLY);
+	if (*fd != -1)
+		return 1;
+	if (errno == ENOENT)
+		return 0;
+
+	sieve_storage_set_critical(storage,
+				   "open(%s) failed: %m", path);
+	return -1;
+}
+
+int sieve_script_get_size(struct sieve_script *script, uoff_t *size)
+{
+	int ret = 0;
+
+	*size = 0;
+
+	if (script->size == 0) {
+		struct stat st;
+
+		ret = stat(script->filename, &st);
+
+		if ( ret < 0 ) {
+			if ( errno == ENOENT ) {
+				return 0;
+			}
+			
+			sieve_storage_set_critical
+			  (script->storage,
+			   "Performing stat() on sieve file '%s' failed: %m", script->filename);
+			
+			return -1;
+		}
+
+		script->size = st.st_size;
+	} 
+	
+	*size = script->size;
+	
+	return 1;
+}
+
+struct istream *
+sieve_script_open(struct sieve_script *script, bool *deleted_r)
+{
+	const struct stat *statbuf;
+	int ret = 0, fd = -1;
+
+	if ( deleted_r != NULL )
+		*deleted_r = FALSE;
+
+	if (script->istream == NULL) {
+		if ( (ret=sieve_storage_open_fd
+		    (script->storage, script->filename, &fd)) < 0) 
+			return NULL;
+
+		if (ret == 0) {
+			if ( deleted_r != NULL )
+				*deleted_r = TRUE;
+			return NULL;
+		}
+
+		script->istream = 
+		  i_stream_create_file(fd, default_pool,
+				       SIEVE_READ_BLOCK_SIZE, TRUE);
+
+		if ( script->istream != NULL ) {
+			statbuf = i_stream_stat(script->istream, 0);
+			script->size = statbuf->st_size;
+		}	
+	}
+
+	return script->istream;
+}
+
+const char *sieve_storage_file_get_scriptname
+	(const struct sieve_storage *storage __attr_unused__, const char *filename)
+{
+	const char *ext;
+
+	ext = strrchr(filename, '.');
+
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 ) 
+		return NULL;
+	
+	return t_strdup_until(filename, ext);
+}
+
+static const char *sieve_storage_read_active_link
+	(struct sieve_storage *storage, bool *not_link)
+{
+  char linkbuf[PATH_MAX];
+  int ret;
+
+	if ( not_link != NULL )
+		*not_link = FALSE;
+
+	ret = readlink(storage->active_path, linkbuf, sizeof(linkbuf));
+
+	if ( ret < 0 ) {
+		if (errno == EINVAL) {
+			/* Our symlink is no symlink. Report 'no active script'.
+			 * Activating a script will automatically resolve this, so
+			 * there is no need to panic on this one.
+			 */
+			i_warning
+			  ("Active sieve script symlink %s is no symlink.",
+			   storage->active_path);
+			if ( not_link != NULL )
+				*not_link = TRUE;
+			return "";
+		}
+
+		if (errno != ENOENT ) {
+			/* We do need to panic otherwise */
+			sieve_storage_set_critical
+			  (storage,
+			  	"Performing readlink() on active sieve symlink '%s' failed: %m", 
+					storage->active_path);
+			return NULL;
+		}
+
+		return "";
+	}
+
+	/* ret is now assured to be valid, i.e. > 0 */
+	return t_strndup(linkbuf, ret);
+}
+
+static const char *sieve_storage_parse_link
+	(struct sieve_storage *storage, const char *link)
+{
+	const char *fname, *scriptname, *scriptpath;
+
+	/* Split link into path and filename */
+	fname = strrchr(link, '/');
+	if ( fname != NULL ) {
+		scriptpath = t_strdup_until(link, fname+1);
+		fname++;
+	} else {
+		scriptpath = "";
+		fname = link;
+	}
+
+	/* Check the script name */
+	scriptname = sieve_storage_file_get_scriptname(storage, fname);
+
+	/* Warn if link is deemed to be invalid */
+	if ( scriptname == NULL ) {
+		i_warning
+			("Active sieve script symlink %s is broken: "
+				"invalid scriptname (points to %s).",
+				storage->active_path, link);
+		return NULL;
+	}
+
+	/* Check whether the path is any good */
+	if ( strcmp(scriptpath, storage->link_path) != 0 &&
+		strcmp(scriptpath, storage->dir) != 0 ) {
+		i_warning
+			("Active sieve script symlink %s is broken: "
+				"invalid/unknown path to storage (points to %s).",
+				storage->active_path, link);
+		return NULL; 
+	}
+
+	return scriptname;
+}
+
+const char *sieve_storage_get_active_scriptname
+	(struct sieve_storage *storage)
+{
+	const char *link, *scriptname;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, NULL);
+
+	if ( link == NULL || *link == '\0' ) 
+		return link;
+
+	/* Parse the link */
+	scriptname = sieve_storage_parse_link(storage, link);
+
+	if (scriptname == NULL) {
+		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 * Activation should fix this situation.
+		 */
+		return "";
+	}
+
+	return scriptname;
+}
+
+struct sieve_script *
+  sieve_storage_get_active_script(struct sieve_storage *storage, bool *no_active)
+{
+	bool exists, no_link;
+	struct sieve_script *script;
+	const char *scriptname, *link;
+
+	*no_active = FALSE;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, &no_link);
+	
+	if ( link == NULL )
+		/* Error */
+		return NULL;
+
+	if ( *link == '\0' )
+	{
+		if (no_link) {
+			/* Try to open the active_path as a regular file */
+			return sieve_script_init_from_file
+				(storage, ".dovecot", storage->active_path, NULL);
+		}
+
+		*no_active = TRUE;
+		return NULL;
+	}
+
+	/* Parse the link */
+	scriptname = sieve_storage_parse_link(storage, link);
+
+	if (scriptname == NULL) {
+  		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 */
+		*no_active = TRUE;
+		return NULL;
+	}
+	
+	exists = TRUE;
+	script = sieve_script_init(storage, scriptname, &exists);	
+
+	if ( !exists ) {
+		i_warning
+		  ("Active sieve script symlink %s "
+		   "points to non-existent script (points to %s).",
+		   storage->active_path, link);
+	}
+	
+	*no_active = !exists;
+	return script;
+}
+
+int sieve_script_is_active(struct sieve_script *script)
+{
+	const char *aname;
+
+	t_push();
+	
+	aname = sieve_storage_get_active_scriptname(script->storage);
+	
+	if (aname == NULL) {
+		/* Critical error */
+		t_pop();
+		return -1;
+	}
+
+ 	/* Is the requested script active? */
+	if ( strcmp(script->name, aname) == 0 ) {
+		t_pop();
+		return 1;
+	}
+
+	t_pop();
+	return 0;
+}
+
+int sieve_script_delete(struct sieve_script **script) 
+{
+	struct sieve_storage *storage = (*script)->storage;
+	int ret = 0;
+
+
+	/* Is the requested script active? */
+	if ( sieve_script_is_active(*script) ) {
+		sieve_storage_set_error(storage, "Cannot delete the active sieve script.");
+		ret = -1;
+	} else {
+		ret = unlink((*script)->filename);
+
+		if ( ret < 0 ) {
+			if ( errno == ENOENT ) 
+				sieve_storage_set_error(storage, "Sieve script does not exist.");
+			else
+				sieve_storage_set_critical(
+					storage, "Performing unlink() failed on sieve file '%s': %m", 
+					(*script)->filename);
+		}	
+	}
+
+	/* Always deinitialize the script object */
+	sieve_script_unref(script);
+
+	return ret;	
+}
+
+static bool sieve_storage_rescue_regular_file(struct sieve_storage *storage)
+{
+	struct stat st;
+	
+	/* Stat the file */
+	if ( lstat(storage->active_path, &st) != 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_critical(storage, 
+				"Failed to stat active sieve script symlink (%s): %m.", 
+				storage->active_path); 
+			return FALSE;	
+		} 
+		return TRUE;
+	}
+
+  	if ( S_ISLNK( st.st_mode ) ) {
+		if ( getenv("DEBUG") != NULL )
+	    	i_info( "sieve-storage: nothing to rescue %s.", storage->active_path);
+    	return TRUE; /* Nothing to rescue */
+  	}
+
+	/* Only regular files can be rescued */
+	if ( S_ISREG( st.st_mode ) ) {
+		const char *dstpath;
+
+ 		t_push();
+
+		dstpath = t_strconcat
+			( storage->dir, "/dovecot.orig.sieve", NULL );
+		if ( file_copy(storage->active_path, dstpath, 1) < 1 ) {
+			sieve_storage_set_critical(storage, 
+				"Active sieve script file '%s' is a regular file and copying it to the "
+				"script storage as '%s' failed. This needs to be fixed manually.",
+				storage->active_path, dstpath);
+			t_pop();
+			return FALSE;	
+		} else {
+			i_info("Moved active sieve script file '%s' to script storage as '%s'.",
+				storage->active_path, dstpath); 
+			t_pop();
+			return TRUE;
+    	}
+		t_pop();
+  	}
+
+	sieve_storage_set_critical( storage,
+		"Active sieve script file '%s' is no symlink nor a regular file. "
+		"This needs to be fixed manually.", storage->active_path );
+	return FALSE;	
+}
+
+int sieve_storage_deactivate(struct sieve_storage *storage)
+{
+	int ret;
+
+	if ( !sieve_storage_rescue_regular_file(storage) ) 
+		return -1;
+
+	/* Delete the symlink, so no script is active */
+	ret = unlink(storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_error(storage, "sieve_storage_deactivate(): "
+				"error on unlink(%s): %m", storage->active_path);
+			return -1;
+		} else 
+		  return 0;
+	} 
+
+	return 1;
+}
+
+int
+sieve_script_activate(struct sieve_script *script)
+{
+	struct stat st;
+	const char *active_path_new, *script_path;
+	struct timeval *tv, tv_now;
+	const char *aname;
+	int activated = 0;
+	int ret;
+
+	t_push();	
+
+	/* Find out whether there is an active script, but recreate
+	 * the symlink either way. This way, any possible error in the symlink
+	 * resolves automatically. This step is only necessary to provide a
+	 * proper return value indicating whether the script was already active.
+	 */
+	aname = sieve_storage_get_active_scriptname(script->storage);
+
+	/* Is the requested script already active? */
+	if ( aname == NULL || strcmp(script->name, aname) != 0 ) 
+		activated = 1; 
+
+	/* Check the scriptfile we are trying to activate */
+	if ( lstat(script->filename, &st) != 0 ) {
+		sieve_storage_set_critical(script->storage, 
+		  "Stat on sieve script %s failed, but it is to be activated: %m.", script->name);
+		t_pop();
+		return -1;
+	}
+
+	/* Rescue a possible .dovecot.sieve regular file remaining from old 
+	 * installations.
+	 */
+	if ( !sieve_storage_rescue_regular_file(script->storage) ) {
+		/* Rescue failed, manual intervention is necessary */
+		t_pop();
+		return -1;
+	}
+
+	/* Just try to create the symlink first */
+	script_path = t_strconcat
+	  ( script->storage->link_path, script->name, ".sieve", NULL );
+		
+ 	ret = symlink(script_path, script->storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno == EEXIST ) {
+			/* The symlink already exists, try to replace it */
+			tv = &ioloop_timeval;
+
+			for (;;) {	
+				/* First the new symlink is created with a different filename */
+				active_path_new = t_strdup_printf
+					("%s-new.%s.P%sM%s.%s.sieve",
+						script->storage->active_path,
+						dec2str(tv->tv_sec), my_pid,
+						dec2str(tv->tv_usec), my_hostname);
+
+				ret = symlink(script_path, active_path_new);
+		
+				if ( ret < 0 ) {
+					/* If link exists we try again later */
+					if ( errno == EEXIST ) {
+						/* Wait and try again - very unlikely */
+						sleep(2);
+						tv = &tv_now;
+						if (gettimeofday(&tv_now, NULL) < 0)
+							i_fatal("gettimeofday(): %m");
+						continue;
+					}
+
+					/* Other error, critical */
+					sieve_storage_set_critical
+					  (script->storage, 
+					   "Creating symlink() %s to %s failed: %m", 
+					   active_path_new, script_path);
+					t_pop();
+					return -1;
+				}
+	
+				/* Link created */
+				break;
+			}
+
+			/* Replace the existing link and thus activating the new script */
+			ret = rename(active_path_new, script->storage->active_path);
+
+			if ( ret < 0 ) {
+				/* Failed; created symlink must be deleted */
+				(void)unlink(active_path_new);
+				sieve_storage_set_critical
+				  (script->storage,
+				   "Performing rename() %s to %s failed: %m", 
+				   active_path_new, script->storage->active_path);
+				t_pop();
+				return -1;
+			}	
+		} else {
+			/* Other error, critical */
+			sieve_storage_set_critical
+				(script->storage,
+					"Creating symlink() %s to %s failed: %m",
+					script->storage->active_path, script_path);
+			t_pop();
+			return -1;
+		}
+	}
+
+	t_pop();
+	return activated;
+}
+
+
+
diff -r 923786016963 src/lib-sievestorage/sieve-script.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-script.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,49 @@
+#ifndef __SIEVE_FILE_H
+#define __SIEVE_FILE_H
+
+#include "sieve-storage.h"
+
+struct sieve_script;
+
+struct sieve_script *sieve_script_init
+  (struct sieve_storage *storage, const char *scriptname, bool *exists);
+
+void sieve_script_ref(struct sieve_script *script);
+
+void sieve_script_unref(struct sieve_script **script);
+
+const char *sieve_script_name(struct sieve_script *script);
+
+/* sieve_script_filename():
+ * Returns the filename of the script. If the implemented storage
+ * does not actually store scripts as a file it must temporarily be saved
+ * somewhere in /tmp or so. Don't use this function if you can
+ * also work with a stream. (currently not an issue)
+ */
+const char *sieve_script_filename(struct sieve_script *script);
+
+int sieve_script_get_size(struct sieve_script *script, uoff_t *size);
+
+struct istream *
+sieve_script_open(struct sieve_script *script, bool *deleted_r);
+
+const char *sieve_storage_file_get_scriptname
+  (const struct sieve_storage *storage, const char *filename);
+
+const char *
+  sieve_storage_get_active_scriptname(struct sieve_storage *storage);
+
+struct sieve_script *
+  sieve_storage_get_active_script(struct sieve_storage *storage, bool *no_active);
+
+int sieve_script_is_active(struct sieve_script *script);
+
+int sieve_script_delete(struct sieve_script **script);
+
+int sieve_storage_deactivate(struct sieve_storage *storage);
+
+int
+sieve_script_activate(struct sieve_script *script);
+
+#endif
+
diff -r 923786016963 src/lib-sievestorage/sieve-storage-private.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-storage-private.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,47 @@
+#ifndef __SIEVE_STORAGE_PRIVATE_H
+#define __SIEVE_STORAGE_PRIVATE_H
+
+#include "sieve-storage.h"
+
+enum sieve_storage_flags {
+	/* Print debugging information while initializing the storage */
+	SIEVE_STORAGE_FLAG_DEBUG     = 0x01,
+	/* Use CRLF linefeeds when saving mails. */
+	SIEVE_STORAGE_FLAG_SAVE_CRLF   = 0x02,
+};
+
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+/* All methods returning int return either TRUE or FALSE. */
+struct sieve_storage {
+	pool_t pool;
+	char *name;
+	char *dir;
+
+	/* Private */	
+	char *active_path;
+	char *active_fname;
+	char *link_path;
+	char *error;
+	char *user; /* name of user accessing the storage */
+
+	enum sieve_storage_flags flags;
+};
+
+struct sieve_script {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_storage *storage;
+	const char *name;
+	struct istream *istream;
+	const char *filename;
+	uoff_t size;
+};
+
+struct sieve_script *sieve_script_init_from_file
+	(struct sieve_storage *storage, const char *scriptname,
+	const char *filename, bool *exists);
+
+#endif
+
diff -r 923786016963 src/lib-sievestorage/sieve-storage.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-storage.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,402 @@
+#include "lib.h"
+#include "home-expand.h"
+#include "ioloop.h"
+#include "mkdir-parents.h"
+#include "sieve-storage-private.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define CREATE_MODE 0770 /* umask() should limit it more */
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+static const char *sieve_get_active_script_path(void)
+{
+  const char *script_path, *home;
+
+  home = getenv("HOME");
+
+  /* userdb may specify Sieve path */
+  script_path = getenv("SIEVE");
+  if (script_path != NULL) {
+	if (*script_path == '\0') {
+		/* disabled */
+		return NULL;
+	}
+
+    if ( *script_path != '/' && *script_path != '~') {
+      /* relative path. change to absolute. */
+      script_path = t_strconcat(getenv("HOME"), "/",  
+        script_path, NULL);
+    }
+  } else {
+    if (home == NULL) {
+      /* we must have a home directory */
+      i_error("sieve-storage: userdb(%s) didn't return a home directory or "
+        "sieve script location, can't find it",
+        getenv("USER"));
+      return NULL;
+    }
+
+    script_path = SIEVE_SCRIPT_PATH;
+  }
+
+  /* No need to check for existance here */
+
+  return script_path;
+}
+
+/* Obtain the directory for script storage from the mail location
+ */
+static const char *sieve_storage_get_dir_from_mail(const char *data)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	struct stat st;
+	size_t len;
+	const char *root_dir, *dir, *p, *d;
+
+	root_dir = dir = d = NULL;
+
+	if (debug)
+		i_info("sieve-storage: using mail-data: %s", data);
+
+	/* check if we're in the form of mailformat:data
+	   (eg. maildir:Maildir) */
+	p = data;
+	while (i_isalnum(*p)) p++;
+	
+	if (*p == ':') {
+		d = p+1;
+	} else {
+		d = data;
+	}
+
+	if (d == NULL || *d == '\0') {
+		/* Ok, this is bad. Check whether we might be chrooted, bail out otherwise */
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0)
+			root_dir = "/";
+		else {
+			i_error("sieve-storage: sieve storage directory not given "
+				"and mail root provides no alternative.");
+            return NULL;
+		}
+	} else {
+		/* <scriptdir> */
+		p = strchr(d, ':');
+		if (p == NULL)
+			/* No additional parameters */
+			root_dir = d;
+		else {
+			dir = t_strdup_until(d, p);
+ 
+			do {
+				p++;
+				/* Use control dir as script dir if specified */
+				if (strncmp(p, "CONTROL=", 8) == 0)
+					root_dir = t_strcut(p+8, ':');
+				p = strchr(p, ':');
+			} while (p != NULL);
+			
+			if ( root_dir == NULL || *root_dir == '\0' )
+				root_dir = dir;
+		}
+	}
+
+	/* Not found */
+	if ( root_dir == NULL || *root_dir == '\0' ) {
+		if (debug)
+            i_info("sieve-storage: couldn't find root dir from mail-data.");
+        return NULL;
+    }
+
+	/* Strip trailing '/' */
+    len = strlen(root_dir);
+    if (root_dir[len-1] == '/')
+        root_dir = t_strndup(root_dir, len-1);
+
+	/* Superior mail directory must exist; it is never auto-created by the 
+	 * sieve-storage.
+ 	 */
+	if (stat(root_dir, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			i_error("sieve-storage: stat(%s) failed: %m", root_dir);
+			return NULL;
+		} else {
+			i_error("sieve-storage: root directory specified by "
+				"mail data does not exist: %s", root_dir);
+			return NULL;
+		}
+	} 
+
+	/* Never store scripts directly in the root of the mail or mail:CONTROl directory.
+	 */
+	root_dir = t_strconcat( root_dir, "/sieve", NULL );
+
+	return root_dir;
+}
+
+static const char *sieve_storage_get_relative_link_path
+	(const char *active_path, const char *storage_dir) 
+{
+	const char *link_path, *p;
+	size_t pathlen;
+	
+	/* Determine to what extent the sieve storage and active script 
+	 * paths match up. This enables the managed symlink to be short and the 
+	 * sieve storages can be moved around without trouble (if the active 
+	 * script path is common to the script storage).
+	 */		
+	p = strrchr(active_path, '/');
+	if ( p == NULL ) {
+		link_path = storage_dir;
+	} else { 
+		pathlen = p - active_path;
+
+		if ( strncmp( active_path, storage_dir, pathlen ) == 0 &&
+			(storage_dir[pathlen] == '/' || storage_dir[pathlen] == '\0') ) 
+		{
+			if ( storage_dir[pathlen] == '\0' ) 
+				link_path = ""; 
+			else 
+				link_path = storage_dir + pathlen + 1;
+		} else 
+			link_path = storage_dir;
+	}
+
+	/* Add trailing '/' when link path is not empty 
+	 */
+	pathlen = strlen(link_path);
+    if ( pathlen != 0 && link_path[pathlen-1] != '/')
+        return t_strconcat(link_path, "/", NULL);
+
+	return t_strdup(link_path);
+}
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user)
+{
+	struct sieve_storage *storage;
+	const char *storage_dir;
+
+	t_push();
+
+	storage_dir = sieve_storage_get_dir_from_mail(data);
+	if (storage_dir == NULL) {
+		if (getenv("DEBUG") != NULL)
+			i_info("sieve-storage: failed to obtain storage directory from mail-data.");
+		t_pop();
+		return NULL;
+	} 
+
+	storage = sieve_storage_create(storage_dir, user);
+
+	t_pop();
+
+	return storage;
+}
+
+struct sieve_storage *sieve_storage_create(const char *data, const char *user)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	pool_t pool;
+	struct sieve_storage *storage;
+	const char *home, *tmp_dir, *link_path, *path;
+	const char *active_path, *active_fname, *storage_dir;
+
+	t_push();
+
+	/* Find out where the active script is stored (e.g. ~/.dovecot.sieve) */
+
+	active_path = sieve_get_active_script_path();
+	if (active_path == NULL) {
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+
+	/* Get the filename for the active script link */
+	active_fname = strrchr(active_path, '/');
+	if ( active_fname == NULL ) 
+		active_fname = active_path;
+	else
+		active_fname++;
+
+	if ( *active_fname == '\0' ) {	
+		/* Link cannot be just a path */
+		i_error("sieve-storage: Path to active symlink must include "
+			"the link's filename. Path is: %s", active_path);
+
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+
+	/* Find out where to put the script storage */
+
+	storage_dir = NULL;
+
+	if ( data == NULL || *data == '\0' ) {
+		/* We'll need to figure out the storage location ourself.
+		 *
+         * It's $HOME/sieve or /sieve when (presumed to be) chrooted.  
+		 */
+		home = getenv("HOME");
+        if ( home != NULL && *home != '\0' ) {
+			size_t len;
+
+            if (access(home, R_OK|W_OK|X_OK) == 0) {
+                if (debug) {
+                    i_info("sieve-storage: root exists (%s)",
+                           home);
+                }
+
+				/* Check for trailing '/' */
+    			len = strlen(home);
+    			if (home[len-1] == '/')
+            		path = t_strconcat(home, "sieve", NULL);
+				else
+            		path = t_strconcat(home, "/sieve", NULL);
+			
+                storage_dir = path;
+            } else {
+                if (debug) {
+                    i_info("sieve-storage: access(%s, rwx): "
+                           "failed: %m", home);
+                }
+            }
+		} else {
+			if (debug)
+                i_info("maildir: HOME not set");
+        }
+
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0) {
+            storage_dir = "/sieve";
+			if (debug)
+				i_info("sieve-storage: /sieve exists, assuming chroot");
+        }
+	} else {
+		storage_dir = data;
+	}
+
+	if (storage_dir == NULL || *storage_dir == '\0') {
+        if (debug)
+            i_info("sieve-storage: couldn't find storage dir");
+        return NULL;
+    }
+
+	if (debug)
+ 		i_info("sieve-storage: using sieve script storage directory: %s", storage_dir);    
+
+	/* Expand home directoties in path */
+	storage_dir = home_expand(storage_dir);
+	active_path = home_expand(active_path);
+
+	/* Ensure sieve local directory structure exists (full autocreate):
+	 *  This currently currently only consists of a ./tmp direcory
+	 */
+	tmp_dir = t_strconcat( storage_dir, "/tmp", NULL );	
+	if (mkdir_parents(tmp_dir, CREATE_MODE) < 0 && errno != EEXIST) {
+		i_error("sieve-storage: mkdir_parents(%s, CREATE_MODE) failed: %m", tmp_dir);
+		t_pop();
+		return NULL;
+	}
+
+	/* Create storage object */
+	pool = pool_alloconly_create("sieve-storage", 512+256);
+    storage = p_new(pool, struct sieve_storage, 1);	
+	storage->pool = pool;
+	storage->dir = p_strdup(pool, storage_dir);
+	storage->user = p_strdup(pool, user);
+	storage->active_path = p_strdup(pool, active_path);
+	storage->active_fname = p_strdup(pool, active_fname);
+
+	/* Get the path to be prefixed to the script name in the symlink pointing 
+	 * to the active script.
+	 */
+	link_path = sieve_storage_get_relative_link_path
+		(storage->active_path, storage->dir);
+	if (debug)
+		i_info("sieve-storage: relative path to sieve storage in active link: %s", link_path);
+
+	storage->link_path = p_strdup(pool, link_path);
+
+	t_pop();
+	return storage;
+}
+
+void sieve_storage_free(struct sieve_storage *storage)
+{
+	pool_unref(storage->pool);
+}
+
+void sieve_storage_clear_error(struct sieve_storage *storage)
+{
+	i_free(storage->error);
+	storage->error = NULL;
+}
+
+void sieve_storage_set_error(struct sieve_storage *storage, const char *fmt, ...)
+{
+	va_list va;
+
+	sieve_storage_clear_error(storage);
+
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		storage->error = i_strdup_vprintf(fmt, va);
+		va_end(va);
+	}
+}
+
+void sieve_storage_set_internal_error(struct sieve_storage *storage)
+{
+	struct tm *tm;
+	char str[256];
+
+	tm = localtime(&ioloop_time);
+
+	i_free(storage->error);
+	storage->error =
+	  strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+	  i_strdup(str) : i_strdup(CRITICAL_MSG);
+}
+
+void sieve_storage_set_critical(struct sieve_storage *storage,
+             const char *fmt, ...)
+{
+	va_list va;
+	
+	sieve_storage_clear_error(storage);
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		i_error("sieve-storage: %s", t_strdup_vprintf(fmt, va));
+		va_end(va);
+		
+		/* critical errors may contain sensitive data, so let user
+		   see only "Internal error" with a timestamp to make it
+		   easier to look from log files the actual error message. */
+		sieve_storage_set_internal_error(storage);
+	}
+}
+
+const char *sieve_storage_get_last_error(struct sieve_storage *storage)
+{
+  /* We get here only in error situations, so we have to return some
+     error. If storage->error is NULL, it means we forgot to set it at
+     some point.. */
+  return storage->error != NULL ? storage->error : "Unknown error";
+}
+
+
diff -r 923786016963 src/lib-sievestorage/sieve-storage.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/lib-sievestorage/sieve-storage.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,19 @@
+#ifndef __SIEVE_STORAGE_H
+#define __SIEVE_STORAGE_H
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user);
+struct sieve_storage *sieve_storage_create(const char *data, const char *user);
+void sieve_storage_free(struct sieve_storage *storage);
+
+/* Set error message in storage. Critical errors are logged with i_error(),
+   but user sees only "internal error" message. */
+void sieve_storage_clear_error(struct sieve_storage *storage);
+void sieve_storage_set_error(struct sieve_storage *storage,
+          const char *fmt, ...) __attr_format__(2, 3);
+void sieve_storage_set_critical(struct sieve_storage *storage,
+             const char *fmt, ...) __attr_format__(2, 3);
+void sieve_storage_set_internal_error(struct sieve_storage *storage);
+
+const char *sieve_storage_get_last_error(struct sieve_storage *storage);
+
+#endif
diff -r 923786016963 src/managesieve-login/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/Makefile.am	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,29 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve-login
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib \
+	-I$(top_srcdir)/src/lib-auth \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(top_srcdir)/src/login-common \
+	-I$(top_srcdir)/src/lib-sieve 
+
+managesieve_login_LDADD = \
+	../login-common/liblogin-common.a \
+	../lib-managesieve/libmanagesieve.a \
+	../lib-sieve/libsieve.la \
+	../lib-sievestorage/libsievestorage.a \
+	../lib-auth/libauth.a \
+	../lib/liblib.a \
+	$(SSL_LIBS)
+
+managesieve_login_SOURCES = \
+	client.c \
+	client-authenticate.c \
+	managesieve-proxy.c
+
+noinst_HEADERS = \
+	client.h \
+	client-authenticate.h \
+	managesieve-proxy.h
diff -r 923786016963 src/managesieve-login/client-authenticate.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/client-authenticate.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,330 @@
+#include "common.h"
+#include "base64.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include <unistd.h>
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+#include "auth-client.h"
+#include "client.h"
+#include "client-authenticate.h"
+#include "managesieve-proxy.h"
+
+#include <stdlib.h>
+
+/* FIXME: The use of the ANONYMOUS mechanism is currently denied 
+ */
+static bool _sasl_mechanism_acceptable
+	(const struct auth_mech_desc *mech, bool secured) {
+
+	/* a) transport is secured
+	   b) auth mechanism isn't plaintext
+       c) we allow insecure authentication
+	 */
+
+	if ((mech->flags & MECH_SEC_PRIVATE) == 0 &&
+		(mech->flags & MECH_SEC_ANONYMOUS) == 0 &&
+ 		(secured || !disable_plaintext_auth ||
+		(mech->flags & MECH_SEC_PLAINTEXT) == 0)) {
+    		return 1;     
+	}  
+
+	return 0;
+}
+
+const char *client_authenticate_get_capabilities(bool secured)
+{
+	const struct auth_mech_desc *mech;
+	unsigned int i, count;
+	string_t *str;
+
+	str = t_str_new(128);
+	mech = auth_client_get_available_mechs(auth_client, &count);
+
+	if ( count > 0 ) {
+		if ( _sasl_mechanism_acceptable(&(mech[0]), secured) ) {
+			str_append(str, mech[0].name);
+		}
+     
+		for (i = 1; i < count; i++) {
+			if ( _sasl_mechanism_acceptable(&(mech[i]), secured) ) {
+				str_append_c(str, ' ');
+				str_append(str, mech[i].name);
+			}
+		}
+	}
+
+	return str_c(str);
+}
+
+static void client_auth_input(void *context)
+{
+	struct managesieve_client *client = context;
+	struct managesieve_arg *args;
+	const char *msg;
+	char *line;
+	bool fatal;
+
+	if (client->destroyed)
+		return;
+
+	if (!client_read(client))
+		return;
+
+	if (client->skip_line) {
+		if (i_stream_next_line(client->input) == NULL)
+			return;
+
+		client->skip_line = FALSE;
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 1, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			/* FIXME: What to do? */
+		}
+	  
+		sasl_server_auth_client_error(&client->common, msg);
+		return;
+	case -2:
+		/* not enough data */
+		return;
+	}
+
+	if (args[0].type != MANAGESIEVE_ARG_STRING) {
+		sasl_server_auth_client_error(&client->common, "Invalid response string.");
+		return;
+	}
+
+	line = MANAGESIEVE_ARG_STR(&args[0]);
+
+	/* Disable input for now */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+    auth_client_request_continue(client->common.auth_request, line);
+
+	/* clear sensitive data */
+	safe_memset(line, 0, strlen(line));
+}
+
+static bool client_handle_args(struct managesieve_client *client,
+			       const char *const *args, bool success)
+{
+	const char *reason = NULL, *host = NULL, *destuser = NULL, *pass = NULL;
+	string_t *resp_code;
+	unsigned int port = 2000;
+	bool proxy = FALSE, temp = FALSE, nologin = !success;
+
+	for (; *args != NULL; args++) {
+		if (strcmp(*args, "nologin") == 0)
+			nologin = TRUE;
+		else if (strcmp(*args, "proxy") == 0)
+			proxy = TRUE;
+		else if (strcmp(*args, "temp") == 0)
+			temp = TRUE;
+		else if (strncmp(*args, "reason=", 7) == 0)
+			reason = *args + 7;
+		else if (strncmp(*args, "host=", 5) == 0)
+			host = *args + 5;
+		else if (strncmp(*args, "port=", 5) == 0)
+			port = atoi(*args + 5);
+		else if (strncmp(*args, "destuser=", 9) == 0)
+			destuser = *args + 9;
+		else if (strncmp(*args, "pass=", 5) == 0)
+			pass = *args + 5;
+	}
+
+	if (destuser == NULL)
+		destuser = client->common.virtual_user;
+
+  	if (proxy) {
+		/* we want to proxy the connection to another server.
+		don't do this unless authentication succeeded. with
+		master user proxying we can get FAIL with proxy still set.
+
+		proxy host=.. [port=..] [destuser=..] pass=.. */
+
+		if (!success)
+			return FALSE;
+		if (managesieve_proxy_new(client, host, port, destuser, pass) < 0)
+			client_destroy_internal_failure(client);
+		return TRUE;
+	}
+
+	if (host != NULL) {
+		/* MANAGESIEVE referral
+
+		   [nologin] referral host=.. [port=..] [destuser=..]
+		   [reason=..]
+
+		   NO (REFERRAL sieve://user;AUTH=mech@host:port/) Can't login.
+		   OK (...) Logged in, but you should use this server instead.
+		   .. [REFERRAL ..] (Reason from auth server)
+		*/
+		resp_code = t_str_new(128);
+		str_printfa(resp_code, "REFERRAL sieve://%s;AUTH=%s@%s",
+			    destuser, client->common.auth_mech_name, host);
+		if (port != 2000)
+			str_printfa(resp_code, ":%u", port);
+
+		if (reason == NULL) {
+			if (nologin)
+				reason = "Try this server instead.";
+			else 
+				reason = "Logged in, but you should use "
+					"this server instead.";
+		}
+
+		if (!nologin) {
+			client_send_okresp(client, str_c(resp_code), reason);
+			client_destroy(client, "Login with referral");
+			return TRUE;
+		}
+		client_send_noresp(client, str_c(resp_code), reason);
+	} else if (nologin) {
+		/* Authentication went ok, but for some reason user isn't
+		   allowed to log in. Shouldn't probably happen. */
+		if (reason != NULL)
+			client_send_no(client, reason);
+		else if (temp)
+			client_send_no(client, AUTH_TEMP_FAILED_MSG);		
+		else
+			client_send_no(client, AUTH_FAILED_MSG);
+	} else {
+		/* normal login/failure */
+		return FALSE;
+	}
+
+	i_assert(nologin);
+
+	managesieve_parser_reset(client->parser);
+
+	if (!client->destroyed) {
+		/* get back to normal client input. */
+		if (client->io != NULL)
+			io_remove(&client->io);
+		client->io = io_add(client->common.fd, IO_READ,
+			client_input, client);
+	}
+
+	return TRUE;
+}
+
+static void sasl_callback(struct client *_client, enum sasl_server_reply reply,
+			  const char *data, const char *const *args)
+{
+	struct managesieve_client *client = (struct managesieve_client *)_client;
+	string_t *str;
+
+	i_assert(!client->destroyed ||
+		reply == SASL_SERVER_REPLY_CLIENT_ERROR ||
+		reply == SASL_SERVER_REPLY_MASTER_FAILED);
+
+	client->skip_line = TRUE;
+
+	switch (reply) {
+	case SASL_SERVER_REPLY_SUCCESS:
+		if (args != NULL) {
+			if (client_handle_args(client, args, TRUE))
+				break;
+		}
+
+		client_destroy(client, "Login");
+		break;
+	case SASL_SERVER_REPLY_AUTH_FAILED:
+	case SASL_SERVER_REPLY_CLIENT_ERROR:
+		if (args != NULL) {
+			if (client_handle_args(client, args, FALSE))
+				break;
+		}
+
+		client_send_no(client, data != NULL ? data : AUTH_FAILED_MSG);
+
+		managesieve_parser_reset(client->parser);
+
+		if (!client->destroyed) {					
+			/* get back to normal client input. */
+			if (client->io != NULL)
+				io_remove(&client->io);
+			client->io = io_add(client->common.fd, IO_READ,
+				    	client_input, client);
+		}
+		break;
+	case SASL_SERVER_REPLY_MASTER_FAILED:
+		client_destroy_internal_failure(client);
+		break;
+	case SASL_SERVER_REPLY_CONTINUE:
+		t_push();
+		str = t_str_new(256);
+		managesieve_quote_append_string(str, data, TRUE);
+		str_append(str, "\r\n");
+				
+		/* don't check return value here. it gets tricky if we try
+		   to call client_destroy() in here. */
+		(void)o_stream_send(client->output, str_c(str), str_len(str));
+		t_pop();
+
+		i_assert(client->io == NULL);
+        client->io = io_add(client->common.fd, IO_READ,
+                    client_auth_input, client);
+        client_auth_input(client);
+		
+		return;
+	}
+
+	client_unref(client);
+}
+
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args)
+{
+	const char *mech_name, *init_resp = NULL;
+
+	/* one mandatory argument: authentication mechanism name */
+	if (args[0].type != MANAGESIEVE_ARG_STRING)
+		return -1;
+	if (args[1].type != MANAGESIEVE_ARG_EOL) {
+		/* optional SASL initial response */
+		if (args[1].type != MANAGESIEVE_ARG_STRING ||
+		    args[2].type != MANAGESIEVE_ARG_EOL)
+			return -1;
+		init_resp = MANAGESIEVE_ARG_STR(&args[1]);
+	}
+
+	mech_name = MANAGESIEVE_ARG_STR(&args[0]);
+	if (*mech_name == '\0') 
+		return -1;
+
+	/* FIXME: This refuses the ANONYMOUS mechanism. 
+	 *   This can be removed once anonymous login is implemented according to the 
+	 *   draft RFC. - Stephan
+	 */
+	if ( strncasecmp(mech_name, "ANONYMOUS", 9) == 0 ) {
+		client_send_no(client, "ANONYMOUS mechanism is not implemented.");		
+		return 0;
+	}
+
+	client_ref(client);
+	sasl_server_auth_begin(&client->common, "MANAGESIEVE", mech_name,
+			       init_resp, sasl_callback);
+	if (!client->common.authenticating)
+		return 1;
+
+	managesieve_parser_reset(client->parser);
+
+	/* don't handle input until we get the initial auth reply */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	return 0;
+}
+
diff -r 923786016963 src/managesieve-login/client-authenticate.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/client-authenticate.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,9 @@
+#ifndef __CLIENT_AUTHENTICATE_H
+#define __CLIENT_AUTHENTICATE_H
+
+const char *client_authenticate_get_capabilities(bool secured);
+
+int cmd_login(struct managesieve_client *client, struct managesieve_arg *args);
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args);
+
+#endif
diff -r 923786016963 src/managesieve-login/client.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/client.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,680 @@
+#include "common.h"
+#include "buffer.h"
+#include "hash.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "process-title.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "strescape.h"
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+#include "sieve-implementation.h"
+
+#include "client.h"
+#include "client-authenticate.h"
+#include "auth-client.h"
+#include "ssl-proxy.h"
+#include "managesieve-proxy.h"
+
+#include <stdlib.h>
+
+/* max. size of one parameter in line, or max reply length in SASL
+   authentication */
+#define MAX_INBUF_SIZE 4096
+
+/* max. size of output buffer. if it gets full, the client is disconnected.
+   SASL authentication gives the largest output. */
+#define MAX_OUTBUF_SIZE 4096
+
+/* Disconnect client after idling this many seconds */
+#define CLIENT_LOGIN_IDLE_TIMEOUT 60
+
+/* Disconnect client when it sends too many bad commands */
+#define CLIENT_MAX_BAD_COMMANDS 10
+
+/* When max. number of simultaneous connections is reached, few of the
+   oldest connections are disconnected. Since we have to go through the whole
+   client hash, it's faster if we disconnect multiple clients. */
+#define CLIENT_DESTROY_OLDEST_COUNT 16
+
+#if CLIENT_LOGIN_IDLE_TIMEOUT >= AUTH_REQUEST_TIMEOUT
+#  error client idle timeout must be smaller than authentication timeout
+#endif
+
+const char *login_protocol = "MANAGESIEVE";
+const char *capability_string = CAPABILITY_STRING;
+
+const char *managesieve_implementation_string;
+
+static struct hash_table *clients;
+static struct timeout *to_idle;
+
+static void client_set_title(struct managesieve_client *client)
+{
+	const char *addr;
+
+	if (!verbose_proctitle || !process_per_connection)
+		return;
+
+	addr = net_ip2addr(&client->common.ip);
+	if (addr == NULL)
+		addr = "??";
+
+	process_title_set(t_strdup_printf(client->common.tls ?
+					  "[%s TLS]" : "[%s]", addr));
+}
+
+static void client_open_streams(struct managesieve_client *client, int fd)
+{
+	client->input = i_stream_create_file(fd, default_pool,
+					     MAX_INBUF_SIZE, FALSE);
+	client->output = o_stream_create_file(fd, default_pool, MAX_OUTBUF_SIZE,
+					      FALSE);
+	client->parser = managesieve_parser_create(client->input, client->output,
+					    MAX_MANAGESIEVE_LINE);
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+bool client_skip_line(struct managesieve_client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			i_stream_skip(client->input, i+1);
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static void client_send_capabilities(struct managesieve_client *client)
+{
+	const char *auths;
+	const char *sievecap, *sieveimpl;
+
+	sievecap = sieve_get_capabilities();
+	if (sievecap == NULL)
+	  	sievecap = "";
+
+	t_push();
+	sievecap = t_strconcat("\"SIEVE\" \"", sievecap, "\"", NULL);
+	sieveimpl = t_strconcat("\"IMPLEMENTATION\" \"",
+    managesieve_implementation_string, "\"", NULL);
+
+	auths = client_authenticate_get_capabilities(client->common.secured);
+
+	/* We assume no MANAGESIEVE-string incompatible values are produced here */
+	client_send_line(client, sieveimpl);
+	client_send_line(client, t_strconcat("\"SASL\" \"", auths, "\"", NULL) );
+	client_send_line(client, sievecap);
+
+	if (ssl_initialized && !client->common.tls)
+		client_send_line(client, "\"STARTTLS\"" );
+
+	t_pop();
+}
+
+static int cmd_capability(struct managesieve_client *client)
+{
+	client_send_capabilities(client);
+	client_send_ok(client, "Capability completed.");
+	return TRUE;
+}
+
+static void client_start_tls(struct managesieve_client *client)
+{
+	int fd_ssl;
+
+    client_ref(client);
+    connection_queue_add(1);
+    if (!client_unref(client) || client->destroyed)
+        return;
+
+	fd_ssl = ssl_proxy_new(client->common.fd, &client->common.ip,
+			       &client->common.proxy);
+	if (fd_ssl == -1) {
+		client_send_bye(client, "TLS initialization failed.");
+		client_destroy(client, "TLS initialization failed.");
+		return;
+	}
+
+	client->common.tls = TRUE;
+	client->common.secured = TRUE;
+	client_set_title(client);
+
+	client->common.fd = fd_ssl;
+	i_stream_unref(&client->input);
+	o_stream_unref(&client->output);
+	managesieve_parser_destroy(&client->parser);
+
+	/* CRLF is lost from buffer when streams are reopened. */
+	client->skip_line = FALSE;
+
+	client_open_streams(client, fd_ssl);
+	client->io = io_add(client->common.fd, IO_READ, client_input, client);
+}
+
+static int client_output_starttls(void *context)
+{
+	struct managesieve_client *client = context;
+	int ret;
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, "Disconnected");
+		return 1;
+	}
+
+	if (ret > 0) {
+		o_stream_set_flush_callback(client->output, NULL, NULL);
+		client_start_tls(client);
+	}
+	return 1;
+}
+
+static int cmd_starttls(struct managesieve_client *client)
+{
+	if (client->common.tls) {
+		client_send_no(client, "TLS is already active.");
+		return 1;
+	}
+
+	if (!ssl_initialized) {
+		client_send_no(client, "TLS support isn't enabled.");
+		return 1;
+	}
+
+	/* remove input handler, SSL proxy gives us a new fd. we also have to
+	   remove it in case we have to wait for buffer to be flushed */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	client_send_ok(client, "Begin TLS negotiation now.");
+
+	/* uncork the old fd */
+	o_stream_uncork(client->output);
+
+	if (o_stream_flush(client->output) <= 0) {
+		/* the buffer has to be flushed */
+		o_stream_set_flush_pending(client->output, TRUE);
+		o_stream_set_flush_callback(client->output,
+					    client_output_starttls, client);
+	} else {
+		client_start_tls(client);
+	}
+
+    /* Cork the stream to send the capability data as a single tcp frame
+     *   Some naive clients break if we don't.
+     */
+    o_stream_cork(client->output);
+
+	client_send_capabilities(client);
+	client_send_ok(client, "TLS negotiation successful.");
+
+    o_stream_uncork(client->output);
+
+	return 1;
+}
+
+static int cmd_logout(struct managesieve_client *client)
+{
+	client_send_ok(client, "Logout completed.");
+	client_destroy(client, "Aborted login (logout command)");
+	return 1;
+}
+
+static int client_command_execute(struct managesieve_client *client, const char *cmd,
+				  struct managesieve_arg *args)
+{
+	cmd = t_str_ucase(cmd);
+	if (strcmp(cmd, "AUTHENTICATE") == 0)
+		return cmd_authenticate(client, args);
+	if (strcmp(cmd, "CAPABILITY") == 0)
+		return cmd_capability(client);
+	if (strcmp(cmd, "STARTTLS") == 0)
+		return cmd_starttls(client);
+	if (strcmp(cmd, "LOGOUT") == 0)
+		return cmd_logout(client);
+
+	return -1;
+}
+
+static bool client_handle_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	int ret;
+	bool fatal;
+
+	i_assert(!client->common.authenticating);
+
+	if (client->cmd_finished) {
+		/* clear the previous command from memory. don't do this
+		   immediately after handling command since we need the
+		   cmd_tag to stay some time after authentication commands. */
+		client->cmd_name = NULL;
+		managesieve_parser_reset(client->parser);
+
+		/* remove \r\n */
+		if (client->skip_line) {
+			if (!client_skip_line(client))
+				return FALSE;
+			client->skip_line = FALSE;
+		}
+
+		client->cmd_finished = FALSE;
+	}
+
+	if (client->cmd_name == NULL) {
+		client->cmd_name = managesieve_parser_read_word(client->parser);
+		if (client->cmd_name == NULL)
+			return FALSE; /* need more data */
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_send_bye(client, msg);
+			client_destroy(client, t_strconcat("Disconnected: ",
+							   msg, NULL));
+			return FALSE;
+		}
+
+		client_send_no(client, msg);
+		client->cmd_finished = TRUE;
+		client->skip_line = TRUE;
+		return TRUE;
+	case -2:
+		/* not enough data */
+		return FALSE;
+	}
+	client->skip_line = TRUE;
+
+	ret = client_command_execute(client, client->cmd_name, args);
+
+	client->cmd_finished = TRUE;
+	if (ret < 0) {
+		if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+			client_send_bye(client,	
+				"Too many invalid MANAGESIEVE commands.");
+			client_destroy(client, "Disconnected: "
+				"Too many invalid commands.");
+			return FALSE;
+		}  
+		client_send_no(client,
+			"Error in MANAGESIEVE command received by server.");
+	}
+
+	return ret != 0;
+}
+
+bool client_read(struct managesieve_client *client)
+{
+	switch (i_stream_read(client->input)) {
+	case -2:
+		/* buffer full */
+		client_send_bye(client, "Input buffer full, aborting");
+		client_destroy(client, "Disconnected: Input buffer full");
+		return FALSE;
+	case -1:
+		/* disconnected */
+		client_destroy(client, "Disconnected");
+		return FALSE;
+	default:
+		/* something was read */
+		return TRUE;
+	}
+}
+
+void client_input(void *context)
+{
+	struct managesieve_client *client = context;
+
+	client->last_input = ioloop_time;
+
+	if (!client_read(client))
+		return;
+
+	client_ref(client);
+
+	if (!auth_client_is_connected(auth_client)) {
+		/* we're not yet connected to auth process -
+		   don't allow any commands */
+		/* FIXME: Can't do this with managesieve. Any other ways?
+		client_send_ok(client,
+		"Waiting for authentication process to respond.");
+		*/
+		client->input_blocked = TRUE;
+	} else {
+		o_stream_cork(client->output);
+		while (client_handle_input(client)) ;
+		o_stream_uncork(client->output);
+	}
+
+	client_unref(client);
+}
+
+void client_destroy_oldest(void)
+{
+	struct hash_iterate_context *iter;
+	void *key, *value;
+	struct managesieve_client *destroy_buf[CLIENT_DESTROY_OLDEST_COUNT];
+	int i, destroy_count;
+
+	/* find the oldest clients and put them to destroy-buffer */
+	memset(destroy_buf, 0, sizeof(destroy_buf));
+
+ 	destroy_count = max_connections > CLIENT_DESTROY_OLDEST_COUNT*2 ?
+        CLIENT_DESTROY_OLDEST_COUNT : I_MIN(max_connections/2, 1);
+    iter = hash_iterate_init(clients);
+    while (hash_iterate(iter, &key, &value)) {
+        struct managesieve_client *client = key;
+
+        for (i = 0; i < destroy_count; i++) {
+            if (destroy_buf[i] == NULL ||
+                destroy_buf[i]->created > client->created) {
+                /* @UNSAFE */
+                memmove(destroy_buf+i+1, destroy_buf+i,
+                    sizeof(destroy_buf) -
+                    (i+1) * sizeof(struct managesieve_client *));
+                destroy_buf[i] = client;
+                break;
+            }
+        }
+    }
+    hash_iterate_deinit(iter);
+
+    /* then kill them */
+    for (i = 0; i < destroy_count; i++) {
+        if (destroy_buf[i] == NULL)
+            break;
+
+        client_destroy(destroy_buf[i],
+                   "Disconnected: Connection queue full");
+    }
+}
+
+static void client_send_greeting(struct managesieve_client *client)
+{
+	/* Cork the stream to send the capability data as a single tcp frame
+     *   Some naive clients break if we don't.
+     */
+    o_stream_cork(client->output);
+
+  	/* Send initial capabilities */   
+  	client_send_capabilities(client);
+	client_send_ok(client, greeting);
+	client->greeting_sent = TRUE;
+
+    o_stream_uncork(client->output);
+}
+
+struct client *client_create(int fd, bool ssl, const struct ip_addr *local_ip,
+			     const struct ip_addr *ip)
+{
+  struct managesieve_client *client;
+
+  i_assert(fd != -1);
+
+  connection_queue_add(1);
+
+  /* always use nonblocking I/O */
+  net_set_nonblock(fd, TRUE);
+
+  client = i_new(struct managesieve_client, 1);
+  client->created = ioloop_time;
+  client->refcount = 1;
+  client->common.tls = ssl;
+  client->common.secured = ssl || net_ip_compare(ip, local_ip);
+
+  client->common.local_ip = *local_ip;
+  client->common.ip = *ip;
+  client->common.fd = fd;
+
+  client_open_streams(client, fd);
+  client->io = io_add(fd, IO_READ, client_input, client);
+
+  client->last_input = ioloop_time;
+  hash_insert(clients, client, client);
+
+  main_ref();
+
+  if (!greeting_capability || auth_client_is_connected(auth_client))
+                client_send_greeting(client);
+  client_set_title(client);
+
+  return &client->common;
+}
+
+void client_destroy(struct managesieve_client *client, const char *reason)
+{
+	if (client->destroyed)
+		return;
+	client->destroyed = TRUE;
+
+	if (reason != NULL)
+		client_syslog(&client->common, reason);
+
+	hash_remove(clients, client);
+
+	if (client->input != NULL)
+		i_stream_close(client->input);
+	if (client->output != NULL)
+		o_stream_close(client->output);
+
+	if (client->common.master_tag != 0)
+        master_request_abort(&client->common);
+
+    if (client->common.auth_request != NULL) {
+        i_assert(client->common.authenticating);
+        sasl_server_auth_client_error(&client->common, NULL);
+    } else {
+        i_assert(!client->common.authenticating);
+    }
+
+	if (client->io != NULL)
+		io_remove(&client->io);
+   
+	if (client->common.fd != -1) {
+		net_disconnect(client->common.fd);
+		client->common.fd = -1;
+	}
+
+	if (client->proxy_password != NULL) {
+        safe_memset(client->proxy_password, 0,
+                strlen(client->proxy_password));
+        i_free(client->proxy_password);
+        client->proxy_password = NULL;
+    }
+
+    i_free(client->proxy_user);
+    client->proxy_user = NULL;
+
+    if (client->proxy != NULL) {
+        login_proxy_free(client->proxy);
+        client->proxy = NULL;
+    }
+
+    if (client->common.proxy != NULL) {
+        ssl_proxy_free(client->common.proxy);
+        client->common.proxy = NULL;
+    }
+
+    client_unref(client);
+
+    main_listen_start();
+    main_unref();
+}
+
+void client_destroy_internal_failure(struct managesieve_client *client)
+{
+	client_send_byeresp(client, "TRYLATER", "Internal login failure. "
+		"Refer to server log for more information.");
+	client_destroy(client, "Internal login failure");
+}
+
+void client_ref(struct managesieve_client *client)
+{
+	client->refcount++;
+}
+
+bool client_unref(struct managesieve_client *client)
+{
+	i_assert(client->refcount > 0);
+	if (--client->refcount > 0)
+		return TRUE;
+
+	i_assert(client->destroyed);
+
+	managesieve_parser_destroy(&client->parser);
+
+	if (client->input != NULL)
+		i_stream_unref(&client->input);
+	if (client->output != NULL)
+		o_stream_unref(&client->output);
+
+	i_free(client->common.virtual_user);
+	i_free(client->common.auth_mech_name);
+	i_free(client);
+
+	return FALSE;
+}
+
+void client_send_line(struct managesieve_client *client, const char *line)
+{
+	struct const_iovec iov[2];
+	ssize_t ret;
+
+	iov[0].iov_base = line;
+	iov[0].iov_len = strlen(line);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	ret = o_stream_sendv(client->output, iov, 2);
+	if (ret < 0 || (size_t)ret != iov[0].iov_len + iov[1].iov_len) {
+		/* either disconnection or buffer full. in either case we
+		   want this connection destroyed. however destroying it here
+		   might break things if client is still tried to be accessed
+		   without being referenced.. */
+		i_stream_close(client->input);
+	}
+}
+
+void _client_send_response(struct managesieve_client *client, 
+	const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL )
+	{
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL )	
+	{
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+static void client_check_idle(struct managesieve_client *client)
+{
+	if (ioloop_time - client->last_input >= CLIENT_LOGIN_IDLE_TIMEOUT) {
+		client_send_bye(client, "Disconnected for inactivity.");
+		client_destroy(client, "Disconnected: Inactivity");
+	}
+}
+
+static void idle_timeout(void *context __attr_unused__)
+{
+	struct hash_iterate_context *iter;
+	void *key, *value;
+
+	iter = hash_iterate_init(clients);
+	while (hash_iterate(iter, &key, &value)) {
+		struct managesieve_client *client = key;
+
+		client_check_idle(client);
+	}
+	hash_iterate_deinit(iter);
+}
+
+unsigned int clients_get_count(void)
+{
+	return hash_size(clients);
+}
+
+void clients_notify_auth_connected(void)
+{
+	struct hash_iterate_context *iter;
+	void *key, *value;
+
+	iter = hash_iterate_init(clients);
+	while (hash_iterate(iter, &key, &value)) {
+		struct managesieve_client *client = key;
+
+		if (!client->greeting_sent)
+			client_send_greeting(client);
+		if (client->input_blocked) {
+			client->input_blocked = FALSE;
+			client_input(client);
+		}
+	}
+	hash_iterate_deinit(iter);
+}
+
+void clients_destroy_all(void)
+{
+	struct hash_iterate_context *iter;
+	void *key, *value;
+
+	iter = hash_iterate_init(clients);
+	while (hash_iterate(iter, &key, &value)) {
+		struct managesieve_client *client = key;
+
+		client_destroy(client,  "Disconnected: Shutting down");
+	}
+	hash_iterate_deinit(iter);
+}
+
+void clients_init(void)
+{
+	const char *str;
+
+	clients = hash_create(default_pool, default_pool, 128, NULL, NULL);
+	to_idle = timeout_add(1000, idle_timeout, NULL);
+
+	/* Specific MANAGESIEVE settings */
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+    	str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	sieve_init();
+	sieve_set_implementation("cmu");
+}
+
+void clients_deinit(void)
+{
+	clients_destroy_all();
+	hash_destroy(clients);
+
+	timeout_remove(&to_idle);
+	sieve_deinit();
+}
diff -r 923786016963 src/managesieve-login/client.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/client.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,72 @@
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "network.h"
+#include "master.h"
+#include "client-common.h"
+
+/* FIXME: Duplicate, also defined in src/managesieve */
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING PACKAGE
+
+/* maximum length for MANAGESIEVE command line. */
+#define MAX_MANAGESIEVE_LINE 8192
+
+struct managesieve_client {
+	struct client common;
+
+	time_t created;
+	int refcount;
+
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+	struct managesieve_parser *parser;
+
+	struct login_proxy *proxy;
+	char *proxy_user, *proxy_password;
+
+	time_t last_input;
+	unsigned int bad_counter;
+
+	const char *cmd_name;
+
+	unsigned int cmd_finished:1;
+	unsigned int skip_line:1;
+	unsigned int input_blocked:1;
+	unsigned int destroyed:1;
+	unsigned int greeting_sent:1;
+
+	/* Maybe these should be combined in some enum state variable */
+	unsigned int proxy_greeting_recvd:1;  
+ 	unsigned int proxy_login_sent:1;
+};
+
+void client_destroy(struct managesieve_client *client, const char *reason);
+void client_destroy_internal_failure(struct managesieve_client *client);
+
+void client_send_line(struct managesieve_client *client, const char *line);
+
+bool client_read(struct managesieve_client *client);
+bool client_skip_line(struct managesieve_client *client);
+void client_input(void *context);
+
+void client_ref(struct managesieve_client *client);
+bool client_unref(struct managesieve_client *client);
+
+void _client_send_response(struct managesieve_client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+	_client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  _client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  _client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  _client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  _client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(client, resp_code, msg) \
+  _client_send_response(client, "BYE", resp_code, msg)
+#endif
diff -r 923786016963 src/managesieve-login/managesieve-proxy.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/managesieve-proxy.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,299 @@
+/* Copyright (C) 2004 Timo Sirainen */
+
+#include <string.h>
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "safe-memset.h"
+#include "buffer.h"
+#include "base64.h"
+#include "client.h"
+#include "managesieve-quote.h"
+#include "managesieve-proxy.h"
+#include "managesieve-parser.h"
+
+static int proxy_input_line(struct managesieve_client *client,
+			    struct ostream *output, const char *line)
+{
+	string_t *str;
+	const char *msg;
+
+	i_assert(!client->destroyed);
+
+	if (!client->proxy_login_sent) {
+		string_t *plain_login, *base64;
+		struct istream *input;
+		struct managesieve_parser *parser;
+ 		struct managesieve_arg *args;
+		int ret;
+		bool fatal = FALSE, greeting_recvd = FALSE;
+
+		/* Server will send greeting which is actually a capability 
+		 * response. Output from a faulty server should not be accepted,
+		 * so the response is parsed and verified.
+		 */
+
+		/* Build an input stream for the managesieve parser 
+		 *  FIXME: It would be nice if the line-wise parsing could be
+		 *    substituded by something similar to the command line interpreter.
+		 *    However, the current login_proxy structure does not make streams
+		 *    known until inside proxi_input handler.
+		 */
+		line = t_strconcat(line, "\r\n", NULL);
+		input = i_stream_create_from_data(pool_datastack_create(), line,
+			strlen(line));
+		parser = managesieve_parser_create(input, NULL, MAX_MANAGESIEVE_LINE);
+		managesieve_parser_reset(parser);
+
+	    /* Parse input 
+		 *  FIXME: Theoretically the OK response could include a 
+		 *   response code which could be rejected by the parser. 
+		 */ 
+		(void)i_stream_read(input);
+		ret = managesieve_parser_read_args(parser, 2, 0, &args);
+		
+		if ( ret >= 1 ) {
+			if ( args[0].type == MANAGESIEVE_ARG_ATOM &&
+        		strncasecmp(MANAGESIEVE_ARG_STR(&(args[0])), "OK", 2) == 0 ) {
+
+				/* Received OK response; greeting is finished */
+				greeting_recvd = TRUE;
+
+      		} else if ( args[0].type == MANAGESIEVE_ARG_STRING ) {
+        		if ( strncasecmp(MANAGESIEVE_ARG_STR(&(args[0])), "SASL", 4) == 0 ) {
+					/* Check whether the server supports the SASL mechanism 
+		    		 * we are going to use (currently only PLAIN supported). 
+					 */
+					if ( ret == 2 && args[1].type == MANAGESIEVE_ARG_STRING ) {
+						char *p = MANAGESIEVE_ARG_STR(&(args[1]));
+						int mech_found = FALSE;
+								
+						while ( p != NULL ) {
+							if ( strncasecmp(p, "PLAIN", 5) == 0 ) {
+								mech_found = TRUE;
+								break;
+              				}
+
+							p = strchr(p, ' ');
+							if ( p != NULL ) p++;
+						}	 
+
+						if ( !mech_found ) {
+							i_error("managesieve-proxy(%s): "
+			          			"Server does not support required PLAIN SASL mechanism.",
+							client->common.virtual_user);
+
+							fatal = TRUE;
+						} 	
+					}
+				} 	
+			} else {
+				/* Do not accept faulty server */
+        		i_error("managesieve-proxy(%s): "
+          			"Remote returned with invalid capability/greeting line: %s",
+          			client->common.virtual_user, line);
+
+				fatal = TRUE;
+			}
+
+    	} else if ( ret == -2 ) {
+			/* Parser needs more data (not possible on mem stream) */
+			i_unreached();
+
+    	} else if ( ret < 0 ) {
+			const char *error_str = managesieve_parser_get_error(parser, &fatal);
+			error_str = (error_str != NULL ? error_str : "unknown (bug)" );
+	
+			/* Do not accept faulty server */
+			i_error("managesieve-proxy(%s): "
+			"Protocol parse error(%d) in capability/greeting line: %s (line='%s')",
+			client->common.virtual_user, ret, error_str, line);
+	
+			fatal = TRUE;
+		}
+
+		/* Cleanup parser */
+    	managesieve_parser_destroy(&parser);
+	    i_stream_destroy(&input);
+
+		/* Time to exit if greeting was not accepted */
+		if ( fatal ) {			
+			client_destroy_internal_failure(client);
+	
+			return -1;
+		}
+
+		/* Wait until greeting is received completely */
+		if ( !greeting_recvd ) return 0;
+
+		/* Send AUTHENTICATE "PLAIN" command 
+    	 *  FIXME: Currently there seems to be no SASL client implementation,
+		 *    so only implement the trivial PLAIN method 
+		 *    - Stephan
+	     */
+		t_push();
+	
+		/*   Base64-encode the credentials 
+		 * 	   [authorization ID \0 authentication ID \0 pass]
+	     */
+		plain_login = buffer_create_dynamic(pool_datastack_create(), 64);
+		buffer_append_c(plain_login, '\0');
+		buffer_append(plain_login, client->proxy_user, strlen(client->proxy_user));
+	  	buffer_append_c(plain_login, '\0');
+		buffer_append(plain_login, client->proxy_password, strlen(client->proxy_password));
+
+		base64 = buffer_create_dynamic(pool_datastack_create(),
+		MAX_BASE64_ENCODED_SIZE(plain_login->used));
+		base64_encode(plain_login->data, plain_login->used, base64);
+
+		/*   Send command */
+		str = t_str_new(128);
+		str_append(str, "AUTHENTICATE \"PLAIN\" ");
+		managesieve_quote_append_string(str, str_c(base64),  FALSE);
+		str_append(str, "\r\n");
+		(void)o_stream_send(output, str_data(str), str_len(str));
+		
+		/*   Cleanup */
+		t_pop();
+
+		/* Cleanup sensitive data */
+		safe_memset(client->proxy_password, 0,
+			   strlen(client->proxy_password));
+		i_free(client->proxy_password);
+		client->proxy_password = NULL;
+		client->proxy_login_sent = TRUE;
+
+		return 0;
+
+	} else { 
+		if (strncasecmp(line, "OK ", 3) == 0) {
+			/* Login successful. Send this line to client. */
+			o_stream_cork(client->output);
+			(void)o_stream_send_str(client->output, line);
+			(void)o_stream_send(client->output, "\r\n", 2);
+			o_stream_uncork(client->output);
+
+			msg = t_strdup_printf("managesieve-proxy(%s): started proxying to %s:%u",
+				      client->common.virtual_user,
+				      login_proxy_get_host(client->proxy),
+				      login_proxy_get_port(client->proxy));
+
+			(void)client_skip_line(client);
+			login_proxy_detach(client->proxy, client->input,
+				   client->output);
+
+			client->proxy = NULL;
+			client->input = NULL;
+			client->output = NULL;
+			client->common.fd = -1;
+			client_destroy(client, msg);
+
+		} else {
+			/* Login failed. Send our own failure reply so client can't
+		  	 * figure out if user exists or not just by looking at the
+			 * reply string.
+			 */
+			client_send_no(client, AUTH_FAILED_MSG);
+
+			/* allow client input again */
+			i_assert(client->io == NULL);
+			client->io = io_add(client->common.fd, IO_READ,
+				    client_input, client);
+
+			login_proxy_free(client->proxy);
+			client->proxy = NULL;
+
+			i_free(client->proxy_user);
+			client->proxy_user = NULL;
+		}
+
+		return -1;
+	}
+
+	i_unreached();
+	return -1;
+}
+
+static void proxy_input(struct istream *input, struct ostream *output,
+			void *context)
+{
+	struct managesieve_client *client = context;
+	const char *line;
+
+	if (input == NULL) {
+		if (client->io != NULL) {
+			/* remote authentication failed, we're just
+			   freeing the proxy */
+			return;
+		}
+
+		if (client->destroyed) {
+			/* we came here from client_destroy() */
+			return;
+		}
+
+		/* failed for some reason, probably server disconnected */
+		client_send_byeresp(client, "TRYLATER", "Temporary login failure.");
+		client_destroy(client, NULL);
+		return;
+	}
+
+	i_assert(!client->destroyed);
+
+	switch (i_stream_read(input)) {
+	case -2:
+		/* buffer full */
+		i_error("managesieve-proxy(%s): Remote input buffer full",
+			client->common.virtual_user);
+		client_destroy_internal_failure(client);
+		return;
+	case -1:
+		/* disconnected */
+		client_destroy(client, "Proxy: Remote disconnected");
+		return;
+	}
+
+	while ((line = i_stream_next_line(input)) != NULL) {
+		if (proxy_input_line(client, output, line) < 0)
+			break;
+	}
+}
+
+int managesieve_proxy_new(struct managesieve_client *client, const char *host,
+		   unsigned int port, const char *user, const char *password)
+{
+	i_assert(user != NULL);
+	i_assert(!client->destroyed);
+
+	if (password == NULL) {
+		i_error("proxy(%s): password not given",
+			client->common.virtual_user);
+		return -1;
+	}
+
+	i_assert(client->refcount > 1);
+	connection_queue_add(1);
+
+	if (client->destroyed) {
+		/* connection_queue_add() decided that we were the oldest
+		   connection and killed us. */
+		return -1;
+	}
+
+	client->proxy = login_proxy_new(&client->common, host, port,
+					proxy_input, client);
+	if (client->proxy == NULL)
+		return -1;
+
+	client->proxy_login_sent = FALSE;
+	client->proxy_user = i_strdup(user);
+	client->proxy_password = i_strdup(password);
+
+	/* disable input until authentication is finished */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	return 0;
+}
diff -r 923786016963 src/managesieve-login/managesieve-proxy.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve-login/managesieve-proxy.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,9 @@
+#ifndef __MANAGESIEVE_PROXY_H
+#define __MANAGESIEVE_PROXY_H
+
+#include "login-proxy.h"
+
+int managesieve_proxy_new(struct managesieve_client *client, const char *host,
+		   unsigned int port, const char *user, const char *password);
+
+#endif
diff -r 923786016963 src/managesieve/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/Makefile.am	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,56 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib \
+	-I$(top_srcdir)/src/lib-dict \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-DMODULEDIR=\""$(moduledir)"\" \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(top_srcdir)/src/lib-sieve
+
+managesieve_LDFLAGS = -export-dynamic
+
+# get some functions included which only plugins use. liblib should probably
+# be a shared library so this wouldn't be needed..
+unused_objects = \
+	../lib/mountpoint.o 
+
+libs = \
+	../lib-managesieve/libmanagesieve.a \
+  ../lib-sievestorage/libsievestorage.a \
+	../lib-sieve/libsieve.la \
+	../lib-dict/libdict.a \
+	../lib-charset/libcharset.a \
+	../lib/liblib.a \
+	$(unused_objects) 
+
+managesieve_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS) 
+
+managesieve_DEPENDENCIES = $(libs)
+
+cmds = \
+	cmd-capability.c \
+	cmd-logout.c \
+	cmd-putscript.c \
+	cmd-getscript.c \
+	cmd-setactive.c \
+	cmd-deletescript.c \
+	cmd-listscripts.c \
+	cmd-havespace.c 
+
+managesieve_SOURCES = \
+	$(cmds) \
+	client.c \
+	commands.c \
+	main.c 
+
+noinst_HEADERS = \
+	client.h \
+	commands.h \
+	common.h 
diff -r 923786016963 src/managesieve/client.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/client.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,541 @@
+#include "common.h"
+#include "str.h"
+#include "ioloop.h"
+#include "network.h"
+#include "istream.h"
+#include "ostream.h"
+#include "commands.h"
+
+#include "managesieve-quote.h"
+#include "sieve-storage.h"
+#include "sieve-implementation.h"
+
+#include "client.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+static struct client *my_client; /* we don't need more than one currently */
+static struct timeout *to_idle;
+
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage)
+{
+	struct client *client;
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd_in, TRUE);
+	net_set_nonblock(fd_out, TRUE);
+
+	client = i_new(struct client, 1);
+	client->fd_in = fd_in;
+	client->fd_out = fd_out;
+	client->input = i_stream_create_file(fd_in, default_pool,
+					     managesieve_max_line_length, FALSE);
+	client->output = o_stream_create_file(fd_out, default_pool,
+					      (size_t)-1, FALSE);
+
+	o_stream_set_flush_callback(client->output, _client_output, client);
+
+	client->io = io_add(fd_in, IO_READ, _client_input, client);
+	client->parser = managesieve_parser_create(client->input, client->output,
+					    managesieve_max_line_length);
+	client->last_input = ioloop_time;
+
+	client->cmd.pool = pool_alloconly_create("command pool", 8192);
+	client->cmd.client = client;
+
+	client->storage = storage;
+
+	i_assert(my_client == NULL);
+	my_client = client;
+
+	if (hook_client_created != NULL)
+		hook_client_created(&client);
+	return client;
+}
+
+static const char *client_get_disconnect_reason(struct client *client)
+{
+	errno = client->input->stream_errno != 0 ?
+		client->input->stream_errno :
+		client->output->stream_errno;
+	return errno == 0 || errno == EPIPE ? "Connection closed" :
+		t_strdup_printf("Connection closed: %m");
+}
+
+void client_destroy(struct client *client, const char *reason)
+{
+	int ret;
+
+ 	i_assert(!client->handling_input);
+	i_assert(!client->destroyed);
+	client->destroyed = TRUE;
+
+	if (!client->disconnected) {
+		client->disconnected = TRUE;
+		if (reason == NULL)
+			reason = client_get_disconnect_reason(client);
+		i_info("%s", reason);
+	}
+
+	if (client->command_pending) {
+		/* try to deinitialize the command */
+		i_assert(client->cmd.func != NULL);
+		i_stream_close(client->input);
+		o_stream_close(client->output);
+		client->input_pending = FALSE;
+
+		ret = client->cmd.func(&client->cmd);
+		i_assert(ret);
+	}
+
+	managesieve_parser_destroy(&client->parser);
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	i_stream_destroy(&client->input);
+	o_stream_destroy(&client->output);
+
+	if (close(client->fd_in) < 0)
+		i_error("close(client in) failed: %m");
+	if (client->fd_in != client->fd_out) {
+		if (close(client->fd_out) < 0)
+			i_error("close(client out) failed: %m");
+	}
+
+	pool_unref(client->cmd.pool);
+	i_free(client);
+
+	/* quit the program */
+	my_client = NULL;
+	io_loop_stop(ioloop);
+}
+
+void client_disconnect(struct client *client, const char *reason)
+{
+	i_assert(reason != NULL);
+
+	if (client->disconnected)
+		return;
+
+	i_info("Disconnected: %s", reason);
+	client->disconnected = TRUE;
+	(void)o_stream_flush(client->output);
+
+	i_stream_close(client->input);
+	o_stream_close(client->output);
+}
+
+void client_disconnect_with_error(struct client *client, const char *msg)
+{
+	client_send_bye(client, msg);
+	client_disconnect(client, msg);
+}
+
+int client_send_line(struct client *client, const char *data) 
+{
+	struct const_iovec iov[2];
+
+	if (client->output->closed)
+		return -1;
+
+	iov[0].iov_base = data;
+	iov[0].iov_len = strlen(data);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	if (o_stream_sendv(client->output, iov, 2) < 0)
+		return -1;
+	client->last_output = ioloop_time;
+
+	if (o_stream_get_buffer_used_size(client->output) >=
+	    CLIENT_OUTPUT_OPTIMAL_SIZE) {
+		/* buffer full, try flushing */
+		return o_stream_flush(client->output);
+	}
+	return 1;
+}
+
+void client_send_response(struct client *client,
+  const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+	
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL ) {
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL ) {
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void client_send_command_error(struct client_command_context *cmd,
+			       const char *msg)
+{
+	struct client *client = cmd->client;
+	const char *error, *cmd_name;
+	bool fatal;
+
+	if (msg == NULL) {
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_disconnect_with_error(client, msg);
+			return;
+		}
+	}
+
+	if (cmd->name == NULL)
+		error = t_strconcat
+			("Error in MANAGESIEVE command: ", msg, NULL);
+	else {
+		cmd_name = t_str_ucase(cmd->name);
+		error = t_strconcat
+			("Error in MANAGESIEVE command ", cmd_name, ": ", msg, NULL);
+	}
+
+	client_send_no(client, error);
+
+	if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+		client_disconnect_with_error(client,
+			"Too many invalid MANAGESIEVE commands.");
+	}
+
+	/* client_read_args() failures rely on this being set, so that the
+	   command processing is stopped even while command function returns
+	   FALSE. */
+	cmd->param_error = TRUE;
+}
+
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage)
+{
+  const char *error;
+
+  error = sieve_storage_get_last_error(storage);
+
+  client_send_no(client, error);
+}
+
+void client_send_sieve_error(struct client *client)
+{
+  const char *error;
+
+  error = sieve_get_last_error();
+
+  client_send_no(client, error);
+}
+
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args)
+{
+	int ret;
+
+	i_assert(count <= INT_MAX);
+
+	ret = managesieve_parser_read_args(cmd->client->parser, count, flags, args);
+	if (ret >= (int)count) {
+		/* all parameters read successfully */
+		return TRUE;
+	} else if (ret == -2) {
+		/* need more data */
+		return FALSE;
+	} else {
+		/* error, or missing arguments */
+		client_send_command_error(cmd, ret < 0 ? NULL :
+					  "Missing arguments");
+		return FALSE;
+	}
+}
+
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...)
+{
+	struct managesieve_arg *managesieve_args;
+	va_list va;
+	const char *str;
+	unsigned int i;
+
+	if (!client_read_args(cmd, count, 0, &managesieve_args))
+		return FALSE;
+
+	va_start(va, count);
+	for (i = 0; i < count; i++) {
+		const char **ret = va_arg(va, const char **);
+
+		if (managesieve_args[i].type == MANAGESIEVE_ARG_EOL) {
+			client_send_command_error(cmd, "Missing arguments.");
+			break;
+		}
+
+		str = managesieve_arg_string(&managesieve_args[i]);
+		if (str == NULL) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			break;
+		}
+
+		if (ret != NULL)
+			*ret = str;
+	}
+	va_end(va);
+
+	return i == count;
+}
+
+void _client_reset_command(struct client *client)
+{
+	pool_t pool;
+	size_t size;
+
+	/* reset input idle time because command output might have taken a
+	   long time and we don't want to disconnect client immediately then */
+	client->last_input = ioloop_time;
+
+	client->command_pending = FALSE;
+    if (client->io == NULL && !client->disconnected) {
+        i_assert(i_stream_get_fd(client->input) >= 0);
+        client->io = io_add(i_stream_get_fd(client->input),
+                    IO_READ, _client_input, client);
+    }
+    o_stream_set_flush_callback(client->output, _client_output, client);
+
+	pool = client->cmd.pool;
+	memset(&client->cmd, 0, sizeof(client->cmd));
+
+	p_clear(pool);
+	client->cmd.pool = pool;
+	client->cmd.client = client;
+
+	managesieve_parser_reset(client->parser);
+
+	/* if there's unread data in buffer, remember that there's input
+	   pending and we should get around to calling client_input() soon.
+	   This is mostly for APPEND/IDLE. */
+	(void)i_stream_get_data(client->input, &size);
+	if (size > 0 && !client->destroyed)
+		client->input_pending = TRUE;
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+static bool client_skip_line(struct client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			client->input_skip_line = FALSE;
+			i++;
+			break;
+		}
+	}
+
+	i_stream_skip(client->input, i);
+	return !client->input_skip_line;
+}
+
+static bool client_handle_input(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	if (cmd->func != NULL) {
+		/* command is being executed - continue it */
+		if (cmd->func(cmd) || cmd->param_error) {
+			/* command execution was finished */
+			if (!cmd->param_error)
+				client->bad_counter = 0;
+			_client_reset_command(client);
+			return TRUE;
+		}
+
+		/* unfinished */
+        if (client->command_pending)
+            o_stream_set_flush_pending(client->output, TRUE);
+		return FALSE;
+	}
+
+	if (client->input_skip_line) {
+		/* we're just waiting for new line.. */
+		if (!client_skip_line(client))
+			return FALSE;
+
+		/* got the newline */
+		_client_reset_command(client);
+
+		/* pass through to parse next command */
+	}
+
+	if (cmd->name == NULL) {
+		cmd->name = managesieve_parser_read_word(client->parser);
+		if (cmd->name == NULL)
+			return FALSE; /* need more data */
+		cmd->name = p_strdup(cmd->pool, cmd->name);
+	}
+
+	if (cmd->name == '\0') {
+		/* command not given - cmd_func is already NULL. */
+	} else {
+		/* find the command function */
+		cmd->func = command_find(cmd->name);
+	}
+
+	client->input_skip_line = TRUE;
+	if (cmd->func == NULL) {
+		/* unknown command */
+		client_send_command_error(cmd, "Unknown command.");
+		_client_reset_command(client);
+	} else {
+		i_assert(!client->disconnected);
+
+		client_handle_input(cmd);
+	}
+
+	return TRUE;
+}
+
+void _client_input(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+
+	if (client->command_pending) {
+		/* already processing one command. wait. */
+		io_remove(&client->io);
+		return;
+	}
+
+	client->input_pending = FALSE;
+	client->last_input = ioloop_time;
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		client_destroy(client, NULL);
+		return;
+	case -2:
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		_client_reset_command(client);
+		break;
+	}
+
+	client->handling_input = TRUE;
+	o_stream_cork(client->output);
+	do {
+		t_push();
+		ret = client_handle_input(cmd);
+		t_pop();
+	} while (ret && !client->disconnected);
+    o_stream_uncork(client->output);
+    client->handling_input = FALSE;
+
+	if (client->command_pending)
+		client->input_pending = TRUE;
+
+	if (client->output->closed)
+		client_destroy(client, NULL);
+}
+
+int _client_output(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+	bool finished;
+
+	client->last_output = ioloop_time;
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, NULL);
+		return 1;
+	}
+
+	if (!client->command_pending)
+		return 1;
+
+	/* continue processing command */
+	o_stream_cork(client->output);
+	client->output_pending = TRUE;
+	finished = cmd->func(cmd) || cmd->param_error;
+
+	/* a bit kludgy check. normally we would want to get back to this
+	   output handler, but IDLE is a special case which has command
+	   pending but without necessarily anything to write. */
+	if (!finished && client->output_pending)
+		o_stream_set_flush_pending(client->output, TRUE);
+
+	o_stream_uncork(client->output);
+
+	if (finished) {
+		/* command execution was finished */
+		client->bad_counter = 0;
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			_client_input(client);
+	}
+	return ret;
+}
+
+static void idle_timeout(void *context __attr_unused__)
+{
+	time_t idle_time, last_change;
+
+	if (my_client == NULL)
+		return;
+
+	/* We mostly want to check last_input here, but if there is a very long
+	   running command (like copying thousands of messages), we don't want
+	   to disconnect the client just after the command was finished.
+	   But any output that IDLE has sent should be ignored. */
+	last_change = I_MAX(my_client->last_input, my_client->last_output);
+	idle_time = ioloop_time - last_change;
+
+	if (my_client->command_pending &&
+		o_stream_get_buffer_used_size(my_client->output) > 0 &&
+		idle_time >= CLIENT_OUTPUT_TIMEOUT) {
+        /* client isn't reading our output */
+		client_destroy(my_client, "Disconnected for inactivity "
+                   "in reading our output");
+	} else if (idle_time >= CLIENT_IDLE_TIMEOUT) {
+		/* client isn't sending us anything */
+		if (!my_client->command_pending) {
+			client_send_bye(my_client,
+				"Disconnected for inactivity.");
+		}
+		client_destroy(my_client, "Disconnected for inactivity");
+	}
+}
+
+void clients_init(void)
+{
+	my_client = NULL;
+	to_idle = timeout_add(10000, idle_timeout, NULL);
+}
+
+void clients_deinit(void)
+{
+	if (my_client != NULL) {
+		client_send_bye(my_client, "Server shutting down.");
+		client_destroy(my_client, "Server shutting down");
+	}
+
+	timeout_remove(&to_idle);
+}
+
diff -r 923786016963 src/managesieve/client.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/client.h	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,103 @@
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "commands.h"
+
+struct client;
+struct sieve_storage;
+struct managesieve_parser;
+struct managesieve_arg;
+
+struct client_command_context {
+	struct client *client;
+
+	pool_t pool;
+	const char *name;
+
+	command_func_t *func;
+	void *context;
+
+	unsigned int param_error:1;
+};
+
+struct client {
+	int fd_in, fd_out;
+	struct sieve_storage *storage;
+
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+
+	time_t last_input, last_output;
+	unsigned int bad_counter;
+
+	struct managesieve_parser *parser;
+	struct client_command_context cmd;
+
+	unsigned int disconnected:1;
+	unsigned int destroyed:1;
+	unsigned int command_pending:1;
+	unsigned int input_pending:1;
+	unsigned int output_pending:1;
+	unsigned int handling_input:1;
+	unsigned int rawlog:1;
+	unsigned int input_skip_line:1; /* skip all the data until we've
+					   found a new line */
+};
+
+/* Create new client with specified input/output handles. socket specifies
+   if the handle is a socket. */
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage);
+void client_destroy(struct client *client, const char *reason);
+
+/* Disconnect client connection */
+void client_disconnect(struct client *client, const char *reason);
+void client_disconnect_with_error(struct client *client, const char *msg);
+
+/* Send a line of data to client. Returns 1 if ok, 0 if buffer is getting full,
+   -1 if error */
+int client_send_line(struct client *client, const char *data);
+
+void client_send_response(struct client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+  client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(cmd, resp_code, msg) \
+  client_send_response(client, "BYE", resp_code, msg)
+
+/* Send BAD command error to client. msg can be NULL. */
+void client_send_command_error(struct client_command_context *cmd,
+			       const char *msg);
+
+/* Send storage or sieve related errors to the client */
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage);
+void client_send_sieve_error(struct client *client);
+
+/* Read a number of arguments. Returns TRUE if everything was read or
+   FALSE if either needs more data or error occurred. */
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args);
+/* Reads a number of string arguments. ... is a list of pointers where to
+   store the arguments. */
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...);
+
+void clients_init(void);
+void clients_deinit(void);
+
+void _client_reset_command(struct client *client);
+void _client_input(void *context);
+int _client_output(void *context);
+
+#endif
diff -r 923786016963 src/managesieve/cmd-capability.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-capability.c	Wed Mar 05 10:10:41 2008 +0100
@@ -0,0 +1,30 @@
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "ostream.h"
+#include "sieve-implementation.h"
+
+bool cmd_capability(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	const char *sievecap, *sieveimpl;
+
+	sievecap = sieve_get_capabilities();
+	if (sievecap == NULL)
+		sievecap = "";
+
+	t_push();		
+	sievecap = t_strconcat("\"SIEVE\" \"", sievecap, "\"", NULL);
+  	sieveimpl = t_strconcat("\"IMPLEMENTATION\" \"", 
+    managesieve_implementation_string, "\"", NULL);
+
+	client_send_line(client, sieveimpl);
+	client_send_line(client, sievecap);
+	client_send_line(client, "OK \"Capability completed.\"");
+	t_pop();
+
+	return TRUE;
+
+}
+
diff -r 923786016963 src/managesieve/cmd-deletescript.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-deletescript.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,40 @@
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-script.h"
+
+bool cmd_deletescript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+
+	/* <scrip name>*/
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	exists = TRUE;
+	script = sieve_script_init(storage, scriptname, &exists);
+
+	if (script == NULL) {
+		if (!exists) 
+			client_send_no(client, "Script does not exist.");
+		else 
+			client_send_storage_error(client, storage);
+
+		return TRUE;
+	}
+
+	if (sieve_script_delete(&script) < 0)
+		client_send_storage_error(client, storage);
+	else
+		client_send_ok(client, "Deletescript completed.");
+
+	/* Script object is deleted no matter what in 
+	 * sieve_script_delete()
+	 */
+
+	return TRUE;
+}
diff -r 923786016963 src/managesieve/cmd-getscript.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-getscript.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,122 @@
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+#include "istream.h"
+#include "sieve-script.h"
+
+struct cmd_getscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;	
+	uoff_t scriptsize;
+
+	struct sieve_script *script;
+	struct istream *scriptstream;
+	bool failed;
+	bool exists;
+};
+
+static bool cmd_getscript_finish(struct cmd_getscript_context *ctx)
+{
+  struct client *client = ctx->client;
+
+	if (ctx->script != NULL)
+		sieve_script_unref(&ctx->script);
+
+	if (ctx->failed) {
+		if (client->output->closed) {
+			client_disconnect(client, "Disconnected");
+			return TRUE;
+		}
+
+		if (!ctx->exists) {
+			client_send_no(client, "Script does not exist.");
+			return TRUE;
+		}
+		
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	client_send_line(client, "");
+	client_send_ok(client, "Getscript completed.");
+	return TRUE;
+}
+
+static bool cmd_getscript_continue(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx = cmd->context;
+
+	if (o_stream_send_istream(client->output, ctx->scriptstream) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", sieve_script_name(ctx->script));
+		ctx->failed = TRUE;    
+	}
+
+	/* FIXME: Check whether there is a bug in the io_stream_sendfile function
+	 * as the eof indicator of the input stream is never set. The stream_sendfile
+	 * function does not use read functions of the inputstream and therefore
+	 * the eof indicator will not be updated. Workaround: check v_offset == size 
+	 * as well.
+	 */
+	if (ctx->scriptstream->eof || ctx->scriptstream->closed ||
+		ctx->scriptstream->v_offset == ctx->scriptsize ) {
+		if (client->output->closed || ctx->scriptstream->v_offset < ctx->scriptsize) 
+			ctx->failed = TRUE;
+	} else if (!ctx->failed) 
+		/* unfinished */
+		return FALSE;
+
+	return cmd_getscript_finish(ctx);
+}
+
+bool cmd_getscript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx;
+	const char *scriptname;
+	int ret;
+	bool deleted_r;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	ctx = p_new(cmd->pool, struct cmd_getscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->failed = FALSE;
+	
+	ctx->exists = TRUE;
+	ctx->script = sieve_script_init(client->storage, scriptname, &ctx->exists);
+
+	if (ctx->script == NULL) {
+		ctx->failed = TRUE;
+		return cmd_getscript_finish(ctx);
+	}
+			
+	ctx->scriptstream = sieve_script_open(ctx->script, &deleted_r);
+
+	if ( ctx->scriptstream == NULL ) {
+		ctx->failed = TRUE;
+		ctx->exists = !deleted_r;
+		return cmd_getscript_finish(ctx);
+	}
+
+	ctx->scriptsize = 0;
+	if ( (ret=sieve_script_get_size(ctx->script, &ctx->scriptsize)) <= 0 ) {
+		ctx->failed = TRUE;
+		ctx->exists = (ret < 0);
+		return cmd_getscript_finish(ctx);
+	}
+
+	client_send_line(client, t_strdup_printf("{%"PRIuUOFF_T"}", ctx->scriptsize));
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_getscript_continue;
+	cmd->context = ctx;
+
+	return cmd_getscript_continue(cmd);
+}
diff -r 923786016963 src/managesieve/cmd-havespace.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-havespace.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,38 @@
+#include "common.h"
+#include "commands.h"
+
+bool cmd_havespace(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct managesieve_arg *args;
+	const char *scriptname;
+	uoff_t size;
+	int ret;
+
+	/* <scriptname> <size> */
+	if (!(ret=client_read_args(cmd, 2, 0, &args)))
+	  return FALSE;
+
+	if ( ret > 2 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( (scriptname = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid string for scriptname.");
+		return TRUE;
+	}
+
+	if ( managesieve_arg_number(&args[1], &size) < 0 ) {
+		client_send_no(client, "Invalid scriptsize argument.");
+		return TRUE;
+	}
+
+	if ( size == 0 ) {
+		client_send_no(client, "Cannot upload empty script.");
+		return TRUE;
+	}
+
+	client_send_ok(client, "Putscript would succeed.");
+	return TRUE;
+}
diff -r 923786016963 src/managesieve/cmd-listscripts.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-listscripts.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,46 @@
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "sieve-storage.h"
+#include "sieve-list.h"
+#include "managesieve-quote.h"
+
+bool cmd_listscripts(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct sieve_list_context *ctx;
+	const char *scriptname;
+	bool active;
+	string_t *str;
+
+	if ( (ctx = sieve_storage_list_init(client->storage))
+		== NULL ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	/* FIXME: This will be quite slow for large script lists. Implement
+	 * some buffering to fix this. Wont truely be an issue with managesieve
+	 * though.
+	 */
+	while ((scriptname = sieve_storage_list_next(ctx, &active)) != NULL) {
+		t_push();
+		str = t_str_new(128);
+	  
+		managesieve_quote_append_string(str, scriptname, FALSE);
+		
+		if ( active ) 
+		  str_append(str, " ACTIVE");
+		
+		client_send_line(client, str_c(str));
+		t_pop();
+	}
+  
+	if ( sieve_storage_list_deinit(&ctx) < 0 ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+	
+	client_send_ok(client, "Listscripts completed.");
+	return TRUE;
+}
diff -r 923786016963 src/managesieve/cmd-logout.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-logout.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,12 @@
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+
+bool cmd_logout(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	client_send_line(client, "OK \"Logout completed.\"");
+	client_disconnect(client, "Logged out");
+	return TRUE;
+}
diff -r 923786016963 src/managesieve/cmd-putscript.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-putscript.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,355 @@
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "commands.h"
+#include "managesieve-parser.h"
+#include "sieve-storage.h"
+#include "sieve-save.h"
+#include "sieve-implementation.h"
+
+#include <sys/time.h>
+
+struct cmd_putscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;
+
+	struct istream *input;
+
+	const char *scriptname;
+	uoff_t script_size;	
+
+	struct managesieve_parser *save_parser;
+	struct sieve_save_context *save_ctx;
+};
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx);
+static bool cmd_putscript_continue_script(struct client_command_context *cmd);
+
+static void client_input(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+
+	client->last_input = ioloop_time;
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		cmd_putscript_finish(cmd->context);
+		/* Reset command so that client_destroy() doesn't try to call
+		   cmd_putscript_continue_script() anymore. */
+		_client_reset_command(client);
+		client_destroy(client, "Disconnected in putscript");
+		return;
+	case -2:
+		cmd_putscript_finish(cmd->context);
+		if (client->command_pending) {
+			/* message data, this is handled internally by
+			   mailbox_save_continue() */
+			break;
+		}
+
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		_client_reset_command(client);
+		return;
+	}
+
+	if (cmd->func(cmd)) {
+		/* command execution was finished. Note that if cmd_sync()
+		   didn't finish, we didn't get here but the input handler
+		   has already been moved. So don't do anything important
+		   here..
+
+		   reset command once again to reset cmd_sync()'s changes. */
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			_client_input(client);
+	}
+}
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx)
+{
+	io_remove(&ctx->client->io);
+
+	managesieve_parser_destroy(&ctx->save_parser);
+
+	if (ctx->input != NULL)
+		i_stream_unref(&ctx->input);
+
+	if (ctx->save_ctx != NULL)
+	{
+		ctx->client->input_skip_line = TRUE;
+		sieve_storage_save_abort(ctx->save_ctx);
+	}
+
+	ctx->client->bad_counter = 0;
+	o_stream_set_flush_callback(ctx->client->output,
+				    _client_output, ctx->client);
+}
+
+static bool cmd_putscript_continue_cancel(struct client_command_context *cmd)
+{
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+
+	(void)i_stream_read(ctx->input);
+	(void)i_stream_get_data(ctx->input, &size);
+	i_stream_skip(ctx->input, size);
+
+	if (ctx->input->v_offset == ctx->script_size ||
+	    cmd->client->input->closed) {
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool cmd_putscript_cancel(struct cmd_putscript_context *ctx, bool nonsync)
+{
+	ctx->client->input_skip_line = TRUE;
+
+	if (!nonsync) {
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* we have to read the nonsynced literal so we don't treat the message
+	   data as commands. */
+	ctx->input = i_stream_create_limit(default_pool, ctx->client->input,
+					   ctx->client->input->v_offset,
+					   ctx->script_size);
+
+	ctx->client->command_pending = TRUE;
+	ctx->cmd->func = cmd_putscript_continue_cancel;
+	ctx->cmd->context = ctx;
+	return cmd_putscript_continue_cancel(ctx->cmd);
+}
+
+static bool cmd_putscript_finish_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	struct sieve_script *script;
+	int ret;
+	
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+	
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+          MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+
+	if (ret == -1) {
+		if (ctx->storage != NULL)
+			client_send_command_error(cmd, NULL);
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args[0].type == MANAGESIEVE_ARG_EOL) {
+		/* last message */
+	  /* eat away the trailing CRLF */
+		client->input_skip_line = TRUE;
+
+		script = sieve_storage_save_get_tempscript
+	  	(ctx->save_ctx);
+
+		if ( script == NULL || (sieve_compile(script, TRUE) < 0)) {
+			client_send_sieve_error(client);
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		} else {
+			ret = sieve_storage_save_commit(ctx->save_ctx);
+			if (ret < 0) {
+				client_send_storage_error(client, ctx->storage);
+				cmd_putscript_finish(ctx);
+				return TRUE;
+			} else 
+				ctx->save_ctx = NULL;
+		}
+	  
+		cmd_putscript_finish(ctx);
+		client_send_ok(client, "Putscript completed.");
+		
+		return TRUE;
+	}
+
+	client_send_command_error(cmd, "Too many command arguments.");
+	cmd_putscript_finish(ctx);
+	return TRUE;
+}
+
+static bool cmd_putscript_continue_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	bool nonsync = FALSE;
+	int ret;
+
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+				    MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1) {
+		cmd_putscript_finish(ctx);
+		client_send_command_error(cmd, "Invalid arguments.");
+		client->input_skip_line = TRUE;
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args->type != MANAGESIEVE_ARG_STRING) {
+		/* Validate the script argument */
+	  	if (args->type != MANAGESIEVE_ARG_LITERAL_SIZE ) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			return cmd_putscript_cancel(ctx, FALSE);
+		}
+
+		ctx->script_size = MANAGESIEVE_ARG_LITERAL_SIZE(args);
+		nonsync = TRUE;
+	} else {
+	  	/* FIXME */
+		client_send_no(client, "This MANAGESIEVE implementation currently does not allow "
+			       "quoted strings to be used for script contents.");
+		return cmd_putscript_cancel(ctx, FALSE);		
+	}
+
+	if (ctx->script_size == 0) {
+		/* no message data, abort */
+		client_send_no(client, "PUTSCRIPT aborted (no message data).");
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* save the script */
+	ctx->input = i_stream_create_limit(default_pool, client->input,
+					   client->input->v_offset,
+					   ctx->script_size);
+	ctx->save_ctx = sieve_storage_save_init(ctx->storage, ctx->scriptname, ctx->input);
+
+	if ( ctx->save_ctx == NULL ) {
+		/* save initialization failed */
+		client_send_storage_error(client, ctx->storage);
+		return cmd_putscript_cancel(ctx, nonsync);
+	}
+
+	/* after literal comes CRLF, if we fail make sure we eat it away */
+	client->input_skip_line = TRUE;
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_putscript_continue_script;
+	return cmd_putscript_continue_script(cmd);
+}
+
+static bool cmd_putscript_continue_script(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+	bool failed;
+
+	if (ctx->save_ctx != NULL) {
+		if (sieve_storage_save_continue(ctx->save_ctx) < 0) {
+			/* we still have to finish reading the script
+			   from client */
+			sieve_storage_save_abort(ctx->save_ctx);
+			ctx->save_ctx = NULL;
+		}
+	}
+
+	if (ctx->save_ctx == NULL) {
+		(void)i_stream_read(ctx->input);
+		(void)i_stream_get_data(ctx->input, &size);
+		i_stream_skip(ctx->input, size);
+	}
+
+	if (ctx->input->eof || client->input->closed) {
+		/* finished */
+		bool all_written = ctx->input->v_offset == ctx->script_size;
+
+		i_stream_unref(&ctx->input);
+		ctx->input = NULL;
+
+		if (ctx->save_ctx == NULL) {
+			/* failed above */
+			client_send_storage_error(client, ctx->storage);
+			failed = TRUE;
+		} else if (!all_written) {
+			/* client disconnected before it finished sending the
+			   whole message. */
+			failed = TRUE;
+			sieve_storage_save_abort(ctx->save_ctx);
+		} else if (sieve_storage_save_finish(ctx->save_ctx) < 0) {
+			failed = TRUE;
+			client_send_storage_error(client, ctx->storage);
+		} else {
+			failed = client->input->closed;
+		}
+
+		if (failed) {
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		}
+
+		/* prepare for next message */
+		client->command_pending = FALSE;
+		managesieve_parser_reset(ctx->save_parser);
+		cmd->func = cmd_putscript_finish_parsing;
+		return cmd_putscript_finish_parsing(cmd);
+	}
+
+	return FALSE;
+}
+
+bool cmd_putscript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx;
+	const char *scriptname;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname) || 
+		*scriptname == '\0')
+		return FALSE;
+
+	ctx = p_new(cmd->pool, struct cmd_putscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->scriptname = scriptname;
+
+	io_remove(&client->io);
+	client->io = io_add(i_stream_get_fd(client->input), IO_READ,
+			    client_input, client);
+	/* putscript is special because we're only waiting on client input, not
+	   client output, so disable the standard output handler until we're
+	   finished */
+	o_stream_set_flush_callback(client->output, NULL, NULL);
+
+	ctx->save_parser = managesieve_parser_create(client->input, client->output,
+					      managesieve_max_line_length);
+
+	cmd->func = cmd_putscript_continue_parsing;
+	cmd->context = ctx;
+	return cmd_putscript_continue_parsing(cmd);
+}
diff -r 923786016963 src/managesieve/cmd-setactive.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/cmd-setactive.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,53 @@
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-script.h"
+
+bool cmd_setactive(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+	int ret;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	if ( *scriptname != '\0' ) {
+		exists = TRUE;
+		script = sieve_script_init(storage, scriptname, &exists);
+
+		if (script == NULL) {
+			if (!exists)
+				client_send_no(client, "Script does not exist.");
+			else
+				client_send_storage_error(client, storage);
+
+			return TRUE;
+		}
+	
+		ret = sieve_script_activate(script);
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ? 
+				"Setactive completed." :
+				"Script is already active.");
+
+		sieve_script_unref(&script);
+	} else {
+		ret = sieve_storage_deactivate(storage);
+		
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ?
+ 				"Active script is now deactivated." :
+				"No scripts currently active.");	
+	}
+
+	return TRUE;
+}
diff -r 923786016963 src/managesieve/commands.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/commands.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,112 @@
+#include "common.h"
+#include "array.h"
+#include "commands.h"
+
+#include <stdlib.h>
+
+/* Might want to combine this somewhere in a commands-common.c 
+ * to avoid duplicate code 
+ */
+
+const struct command managesieve_commands[] = {
+	{ "CAPABILITY", cmd_capability },
+	{ "LOGOUT", cmd_logout },
+	{ "PUTSCRIPT", cmd_putscript },
+	{ "GETSCRIPT", cmd_getscript },
+	{ "SETACTIVE", cmd_setactive },
+	{ "DELETESCRIPT", cmd_deletescript },
+	{ "LISTSCRIPTS", cmd_listscripts },
+	{ "HAVESPACE", cmd_havespace }
+};
+
+#define MANAGESIEVE_COMMANDS_COUNT \
+	(sizeof(managesieve_commands) / sizeof(managesieve_commands[0]))
+
+static array_t ARRAY_DEFINE(commands, struct command);
+static bool commands_unsorted;
+
+void command_register(const char *name, command_func_t *func)
+{
+	struct command cmd;
+
+	cmd.name = name;
+	cmd.func = func;
+	array_append(&commands, &cmd, 1);
+
+	commands_unsorted = TRUE;
+}
+
+void command_unregister(const char *name)
+{
+	const struct command *cmd;
+	unsigned int i, count;
+
+	cmd = array_get(&commands, &count);
+	for (i = 0; i < count; i++) {
+		if (strcasecmp(cmd[i].name, name) == 0) {
+			array_delete(&commands, i, 1);
+			return;
+		}
+	}
+
+	i_error("Trying to unregister unknown command '%s'", name);
+}
+
+void command_register_array(const struct command *cmdarr, unsigned int count)
+{
+	commands_unsorted = TRUE;
+	array_append(&commands, cmdarr, count);
+}
+
+void command_unregister_array(const struct command *cmdarr, unsigned int count)
+{
+	while (count > 0) {
+		command_unregister(cmdarr->name);
+		count--; cmdarr++;
+	}
+}
+
+static int command_cmp(const void *p1, const void *p2)
+{
+	const struct command *c1 = p1, *c2 = p2;
+
+	return strcasecmp(c1->name, c2->name);
+}
+
+static int command_bsearch(const void *name, const void *cmd_p)
+{
+	const struct command *cmd = cmd_p;
+
+	return strcasecmp(name, cmd->name);
+}
+
+command_func_t *command_find(const char *name)
+{
+	const struct command *cmd;
+	void *base;
+	unsigned int count;
+
+	base = array_get_modifyable(&commands, &count);
+	if (commands_unsorted) {
+		qsort(base, count, sizeof(struct command), command_cmp);
+			    commands_unsorted = FALSE;
+	}
+
+    cmd = bsearch(name, base, count, sizeof(struct command),
+		     command_bsearch);
+	return cmd == NULL ? NULL : cmd->func;
+}
+
+void commands_init(void)
+{
+  	ARRAY_CREATE(&commands, system_pool, struct command, 64);
+    commands_unsorted = FALSE;
+
+	command_register_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+}
+
+void commands_deinit(void)
+{
+	command_unregister_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+	array_free(&commands);
+}
diff -r 923786016963 src/managesieve/commands.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/commands.h	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,45 @@
+#ifndef __COMMANDS_H
+#define __COMMANDS_H
+
+struct client_command_context;
+
+#include "managesieve-parser.h"
+
+typedef bool command_func_t(struct client_command_context *cmd);
+
+struct command {
+	const char *name;
+	command_func_t *func;
+};
+
+/* Register command. Given name parameter must be permanently stored until
+   command is unregistered. */
+void command_register(const char *name, command_func_t *func);
+void command_unregister(const char *name);
+
+/* Register array of commands. */
+void command_register_array(const struct command *cmdarr, unsigned int count);
+void command_unregister_array(const struct command *cmdarr, unsigned int count);
+
+command_func_t *command_find(const char *name);
+
+void commands_init(void);
+void commands_deinit(void);
+
+/* MANAGESIEVE commands: */
+
+/* Non-Authenticated State */
+bool cmd_logout(struct client_command_context *cmd);
+
+bool cmd_capability(struct client_command_context *cmd);
+
+/* Authenticated State */
+bool cmd_putscript(struct client_command_context *cmd);
+bool cmd_getscript(struct client_command_context *cmd);
+bool cmd_setactive(struct client_command_context *cmd);
+bool cmd_deletescript(struct client_command_context *cmd);
+bool cmd_listscripts(struct client_command_context *cmd);
+bool cmd_havespace(struct client_command_context *cmd);
+
+
+#endif
diff -r 923786016963 src/managesieve/common.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/common.h	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,38 @@
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#include "lib.h"
+#include "client.h"
+
+/* Disconnect client after idling this many seconds */
+#define CLIENT_IDLE_TIMEOUT (60*30)
+
+/* If we can't send anything to client for this long, disconnect the client */
+#define CLIENT_OUTPUT_TIMEOUT (5*60)
+
+/* Stop buffering more data into output stream after this many bytes */
+#define CLIENT_OUTPUT_OPTIMAL_SIZE 2048
+
+/* Disconnect client when it sends too many bad commands in a row */
+#define CLIENT_MAX_BAD_COMMANDS 20
+
+/* RFC-2683 recommends at least 8000 bytes. Some clients however don't
+   break large message sets to multiple commands, so we're pretty liberal
+   by default. */
+#define DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH 65536
+
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING PACKAGE
+
+enum client_workarounds {
+  WORKAROUND_DELAY_NONE    = 0x00,
+};
+
+extern struct ioloop *ioloop;
+extern unsigned int managesieve_max_line_length;
+extern const char *managesieve_implementation_string;
+extern enum client_workarounds client_workarounds;
+
+//extern void (*hook_mail_storage_created)(struct sieve_storage *storage);
+extern void (*hook_client_created)(struct client **client);
+
+#endif
diff -r 923786016963 src/managesieve/main.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/managesieve/main.c	Wed Mar 05 10:10:42 2008 +0100
@@ -0,0 +1,292 @@
+#include "common.h"
+#include "ioloop.h"
+#include "network.h"
+#include "ostream.h"
+#include "str.h"
+#include "lib-signals.h"
+#include "restrict-access.h"
+#include "fd-close-on-exec.h"
+#include "process-title.h"
+#include "randgen.h"
+#include "module-dir.h"
+#include "dict-client.h"
+#include "commands.h"
+#include "sieve-storage.h"
+#include "sieve-implementation.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+
+#define IS_STANDALONE() \
+        (getenv("LOGGED_IN") == NULL)
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+struct client_workaround_list {
+	const char *name;
+	enum client_workarounds num;
+};
+
+struct client_workaround_list client_workaround_list[] = {
+	{ NULL, 0 }
+};
+
+struct ioloop *ioloop;
+unsigned int managesieve_max_line_length;
+const char *managesieve_implementation_string;
+enum client_workarounds client_workarounds = 0;
+static struct io *log_io = NULL;
+
+static char log_prefix[128]; /* syslog() needs this to be permanent */
+
+//void (*hook_mail_storage_created)(struct mail_storage *storage) = NULL;
+void (*hook_client_created)(struct client **client) = NULL;
+
+static void sig_die(int signo, void *context __attr_unused__)
+{
+	/* warn about being killed because of some signal, except SIGINT (^C)
+	   which is too common at least while testing :) */
+	if (signo != SIGINT)
+		i_warning("Killed with signal %d", signo);
+	io_loop_stop(ioloop);
+}
+
+static void log_error_callback(void *context __attr_unused__)
+{
+	io_loop_stop(ioloop);
+}
+
+static void parse_workarounds(void)
+{
+	struct client_workaround_list *list;
+	const char *env, *const *str;
+
+	env = getenv("MANAGESIEVE_CLIENT_WORKAROUNDS");
+	if (env == NULL)
+		return;
+
+	for (str = t_strsplit_spaces(env, " ,"); *str != NULL; str++) {
+		list = client_workaround_list;
+		for (; list->name != NULL; list++) {
+			if (strcasecmp(*str, list->name) == 0) {
+				client_workarounds |= list->num;
+				break;
+			}
+		}
+		if (list->name == NULL)
+			i_fatal("Unknown client workaround: %s", *str);
+	}
+}
+
+static void open_logfile(void)
+{
+	const char *user;
+
+	if (getenv("LOG_TO_MASTER") != NULL) {
+		i_set_failure_internal();
+		return;
+	}
+
+ 	if (getenv("LOG_PREFIX") != NULL)
+		strocpy(log_prefix, getenv("LOG_PREFIX"), sizeof(log_prefix));
+	else {
+		user = getenv("USER");
+		if (user == NULL) {
+			if (IS_STANDALONE())
+				user = getlogin();
+			if (user == NULL)
+				user = "??";
+		}
+		if (strlen(user) >= sizeof(log_prefix)-6) {	
+			/* quite a long user name, cut it */
+ 			user = t_strndup(user, sizeof(log_prefix)-6-2);
+			user = t_strconcat(user, "..", NULL);
+		}
+		i_snprintf(log_prefix, sizeof(log_prefix), "imap(%s): ", user);
+	}
+
+	if (getenv("USE_SYSLOG") != NULL) {
+		const char *env = getenv("SYSLOG_FACILITY");
+		i_set_failure_syslog(log_prefix, LOG_NDELAY,
+				     env == NULL ? LOG_MAIL : atoi(env));
+	} else {
+		/* log to file or stderr */
+		i_set_failure_file(getenv("LOGFILE"), log_prefix);
+	}
+
+	if (getenv("INFOLOGFILE") != NULL)
+		i_set_info_file(getenv("INFOLOGFILE"));
+
+	i_set_failure_timestamp_format(getenv("LOGSTAMP"));
+}
+
+static void drop_privileges(void)
+{
+	const char *version;
+
+	version = getenv("DOVECOT_VERSION");
+	if (version != NULL && strcmp(version, PACKAGE_VERSION) != 0) {
+		i_fatal("Dovecot version mismatch: "
+			"Master is v%s, managesieve is v"PACKAGE_VERSION" "
+			"(if you don't care, set version_ignore=yes)", version);
+	}
+
+	/* Log file or syslog opening probably requires roots */
+	open_logfile();
+
+	/* Most likely needed. Have to open /dev/urandom before possible
+	   chrooting. */
+	random_init();
+
+    restrict_access_by_env(!IS_STANDALONE());
+}
+
+static void internal_error()
+{
+  struct tm *tm;
+  char str[256];
+
+  tm = localtime(&ioloop_time);
+
+  printf("BYE \"%s\"\n",
+    strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+    i_strdup(str) : i_strdup(CRITICAL_MSG));
+}
+
+static void main_init(void)
+{
+	struct sieve_storage *storage;
+	struct client *client;
+	const char *user, *str, *sieve_storage, *mail;
+
+	lib_signals_init();
+        lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+        lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+        lib_signals_ignore(SIGPIPE);
+        lib_signals_set_handler(SIGALRM, FALSE, NULL, NULL);
+
+	user = getenv("USER");
+	if (user == NULL) {
+		if (IS_STANDALONE())
+			user = getlogin();
+		if (user == NULL) {
+			internal_error();
+			i_fatal("USER environment missing");
+		}
+	}
+
+	if (getenv("DEBUG") != NULL) {
+		const char *home;
+
+        home = getenv("HOME");
+        i_info("Effective uid=%s, gid=%s, home=%s",
+               dec2str(geteuid()), dec2str(getegid()),
+               home != NULL ? home : "(none)");
+	}
+	
+	if (getenv("STDERR_CLOSE_SHUTDOWN") != NULL) {
+		/* If master dies, the log fd gets closed and we'll quit */
+		log_io = io_add(STDERR_FILENO, IO_ERROR,
+				log_error_callback, NULL);
+	}
+
+	sieve_init();
+	sieve_set_implementation("cmu");
+
+	dict_client_register();
+	clients_init();
+	commands_init();
+
+	/* Settings */
+	str = getenv("MANAGESIEVE_MAX_LINE_LENGTH");
+	managesieve_max_line_length = str != NULL ?
+		(unsigned int)strtoul(str, NULL, 10) :
+		DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH;
+
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+    str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	mail = getenv("MAIL"); 
+	sieve_storage = getenv("SIEVE_STORAGE");
+	if ( (sieve_storage == NULL || *sieve_storage == '\0') && 
+		!(mail == NULL || *mail == '\0') ) { 
+		storage = sieve_storage_create_from_mail(mail, user);
+	} else 
+		storage = sieve_storage_create(sieve_storage, user);
+
+	if (storage == NULL) { 
+    	internal_error();
+
+		/* failed */
+		if (sieve_storage != NULL && *sieve_storage != '\0')   
+			i_fatal("Failed to create sieve storage with data: %s", sieve_storage);
+		else if (mail != NULL && *mail != '\0')   
+			i_fatal("Failed to create sieve storage with mail-data: %s", mail);
+		else {
+			const char *home;
+	    
+			home = getenv("HOME");
+			if (home == NULL) home = "not set";
+	    
+			i_fatal("SIEVE_STORAGE and MAIL environment missing and "
+				"autodetection failed (home %s)", home);
+		}
+	}
+	
+	parse_workarounds();
+
+	client = client_create(0, 1, storage);
+	
+	client_send_ok(client, "Logged in.");
+}
+
+static void main_deinit(void)
+{
+	if (log_io != NULL)
+		io_remove(&log_io);
+	clients_deinit();
+
+	commands_deinit();
+	dict_client_unregister();
+	sieve_deinit();
+	random_deinit();
+
+	lib_signals_deinit();
+	closelog();
+}
+
+int main(int argc __attr_unused__, char *argv[], char *envp[])
+{
+#ifdef DEBUG
+	if (getenv("LOGGED_IN") != NULL && getenv("GDB") == NULL)
+		fd_debug_verify_leaks(3, 1024);
+#endif
+	if (IS_STANDALONE() && getuid() == 0 &&
+	    net_getpeername(1, NULL, NULL) == 0) {
+		printf("NO \"managesieve binary must not be started from "
+		       "inetd, use managesieve-login instead.\"\n");
+		return 1;
+	}
+
+	/* NOTE: we start rooted, so keep the code minimal until
+	   restrict_access_by_env() is called */
+	lib_init();
+	drop_privileges();
+
+	process_title_init(argv, envp);
+	ioloop = io_loop_create(system_pool);
+
+	main_init();
+	io_loop_run(ioloop);
+	main_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+
+	return 0;
+}
diff -r 923786016963 src/master/common.h
--- a/src/master/common.h	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/common.h	Wed Mar 05 10:10:42 2008 +0100
@@ -17,6 +17,7 @@ enum process_type {
 	PROCESS_TYPE_SSL_PARAM,
 	PROCESS_TYPE_DICT,
 
+	PROCESS_TYPE_MANAGESIEVE,
 	PROCESS_TYPE_MAX
 };
 
diff -r 923786016963 src/master/login-process.c
--- a/src/master/login-process.c	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/login-process.c	Wed Mar 05 10:10:42 2008 +0100
@@ -67,8 +67,20 @@ static void login_group_create(struct se
 	group = i_new(struct login_group, 1);
 	group->refcount = 1;
 	group->set = set;
-	group->process_type = set->protocol == MAIL_PROTOCOL_IMAP ?
-		PROCESS_TYPE_IMAP : PROCESS_TYPE_POP3;
+
+	switch ( set->protocol ) {
+		case MAIL_PROTOCOL_IMAP:
+			group->process_type = PROCESS_TYPE_IMAP;
+			break;
+		case MAIL_PROTOCOL_POP3:
+			group->process_type = PROCESS_TYPE_POP3;
+			break;
+		case MAIL_PROTOCOL_MANAGESIEVE:
+			group->process_type = PROCESS_TYPE_MANAGESIEVE;
+			break;
+		default:
+			i_unreached();
+	}
 
 	group->next = login_groups;
 	login_groups = group;
@@ -222,6 +234,8 @@ static void login_process_groups_create(
 			login_group_create(server->imap);
 		if (server->pop3 != NULL)
 			login_group_create(server->pop3);
+		if (server->managesieve != NULL)
+			login_group_create(server->managesieve);
 	}
 }
 
@@ -283,6 +297,8 @@ static bool login_process_read_group(str
 			protocol = MAIL_PROTOCOL_IMAP;
 		else if (strcmp(proto, "pop3") == 0)
 			protocol = MAIL_PROTOCOL_POP3;
+		else if (strcmp(proto, "managesieve") == 0)
+			protocol = MAIL_PROTOCOL_MANAGESIEVE;
 		else {
 			i_error("login: Unknown protocol '%s'", proto);
 			return FALSE;
@@ -580,6 +596,9 @@ static void login_process_init_env(struc
 				    *set->imap_capability != '\0' ?
 				    set->imap_capability :
 				    set->imap_generated_capability, NULL));
+	} else if (group->process_type == PROCESS_TYPE_MANAGESIEVE) {
+		env_put(t_strconcat("MANAGESIEVE_IMPLEMENTATION_STRING=",
+			set->managesieve_implementation_string, NULL));
 	}
 }
 
diff -r 923786016963 src/master/mail-process.c
--- a/src/master/mail-process.c	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/mail-process.c	Wed Mar 05 10:10:42 2008 +0100
@@ -231,6 +231,25 @@ mail_process_set_environment(struct sett
 			    set->pop3_client_workarounds, NULL));
 	env_put(t_strconcat("POP3_LOGOUT_FORMAT=",
 			    set->pop3_logout_format, NULL));
+
+	env_put(t_strdup_printf("MANAGESIEVE_MAX_LINE_LENGTH=%u",
+				set->managesieve_max_line_length));
+	env_put(t_strconcat("MANAGESIEVE_IMPLEMENTATION_STRING=",
+        set->managesieve_implementation_string, NULL));
+
+	/* Set sieve environment 
+	 *   FIXME: Currently just uses the expand_mail_env function to 
+	 *   substitute variables and home dir. Technically, that function
+	 *   is not meant for the sieve implementation.  
+	 */
+	if ( set->sieve_storage != NULL ) {
+		env_put(t_strconcat("SIEVE_STORAGE=",
+        	expand_mail_env(set->sieve_storage, var_expand_table), NULL));
+	}
+	if (set->sieve != NULL) {
+		env_put(t_strconcat("SIEVE=",
+			expand_mail_env(set->sieve, var_expand_table), NULL));
+	}
 
 	if (set->mail_save_crlf)
 		env_put("MAIL_SAVE_CRLF=1");
@@ -348,6 +367,8 @@ void mail_process_exec(const char *proto
 			set = server->imap;
 		else if (strcmp(protocol, "pop3") == 0)
 			set = server->pop3;
+		else if (strcmp(protocol, "managesieve") == 0)
+			set = server->managesieve;
 		else
 			i_fatal("Unknown protocol: '%s'", protocol);
 		executable = set->mail_executable;
diff -r 923786016963 src/master/main.c
--- a/src/master/main.c	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/main.c	Wed Mar 05 10:10:42 2008 +0100
@@ -33,7 +33,8 @@ const char *process_names[PROCESS_TYPE_M
 	"imap",
 	"pop3",
 	"ssl-build-param",
-	"dict"
+	"dict",
+	 "managesieve"
 };
 
 static const char *configfile = SYSCONFDIR "/" PACKAGE ".conf";
@@ -241,6 +242,7 @@ static void sigchld_handler(int signo __
 			break;
 		case PROCESS_TYPE_IMAP:
 		case PROCESS_TYPE_POP3:
+		case PROCESS_TYPE_MANAGESIEVE:
 			mail_process_destroyed(pid);
 			break;
 		case PROCESS_TYPE_SSL_PARAM:
@@ -354,6 +356,10 @@ static void check_conflicts(const struct
 			check_conflicts_set(server->pop3, ip, port,
 					    "pop3", proto);
 		}
+		if (server->managesieve != NULL) {
+			check_conflicts_set(server->managesieve, ip, port,
+					    "managesieve", proto);
+		}
 	}
 }
 
@@ -364,13 +370,31 @@ static void listen_protocols(struct sett
 	unsigned int port;
 	int *fd, i;
 
-	set->listen_port = set->protocol == MAIL_PROTOCOL_IMAP ? 143 : 110;
+	switch (set->protocol) {
+	case MAIL_PROTOCOL_IMAP:
+		set->listen_port = 143;
 #ifdef HAVE_SSL
-	set->ssl_listen_port = set->protocol == MAIL_PROTOCOL_IMAP ? 993 : 995;
+		set->ssl_listen_port = 993;
 #else
-	set->ssl_listen_port = 0;
-#endif
-
+		set->ssl_listen_port = 0;
+#endif
+		break;
+	case MAIL_PROTOCOL_POP3:
+		set->listen_port = 110;
+#ifdef HAVE_SSL
+		set->ssl_listen_port = 995;
+#else
+		set->ssl_listen_port = 0;
+#endif
+		break;
+	case MAIL_PROTOCOL_MANAGESIEVE:
+		set->listen_port = 2000;
+		set->ssl_listen_port = 0;
+		break;
+	default:
+		i_unreached();
+	}
+ 
 	/* resolve */
 	resolve_ip("listen", set->listen, &set->listen_ip, &set->listen_port);
 	if (!set->ssl_disable) {
@@ -413,6 +437,12 @@ static void listen_protocols(struct sett
 				port = set->ssl_listen_port;
 				ip = &set->ssl_listen_ip;
 			}
+		} else if (strcasecmp(*proto, "managesieve") == 0) {
+			if (set->protocol == MAIL_PROTOCOL_MANAGESIEVE) {
+				fd = &set->listen_fd;
+				port = set->listen_port;
+				ip = &set->listen_ip;
+			}
 		} else {
 			i_fatal("Unknown protocol %s", *proto);
 		}
@@ -466,12 +496,14 @@ static void listen_fds_open(bool retry)
 static void listen_fds_open(bool retry)
 {
 	struct server_settings *server;
-
+  
 	for (server = settings_root; server != NULL; server = server->next) {
 		if (server->imap != NULL)
 			listen_protocols(server->imap, retry);
 		if (server->pop3 != NULL)
 			listen_protocols(server->pop3, retry);
+		if (server->managesieve != NULL)
+			listen_protocols(server->managesieve, retry);
 	}
 }
 
@@ -494,6 +526,11 @@ static void listen_fds_close(struct serv
 			    close(server->pop3->ssl_listen_fd) < 0)
 				i_error("close(pop3.ssl_listen_fd) failed: %m");
 		}
+		if (server->managesieve != NULL) {
+			if (server->managesieve->listen_fd != null_fd &&
+			    close(server->managesieve->listen_fd) < 0)
+				i_error("close(managesieve.listen_fd) failed: %m");
+		}
 	}
 }
 
@@ -516,6 +553,8 @@ static bool have_stderr(struct server_se
 		if (server->imap != NULL && have_stderr_set(server->imap))
 			return TRUE;
 		if (server->pop3 != NULL && have_stderr_set(server->pop3))
+			return TRUE;
+		if (server->managesieve != NULL && have_stderr_set(server->managesieve))
 			return TRUE;
 
 		server = server->next;
diff -r 923786016963 src/master/master-settings-defs.c
--- a/src/master/master-settings-defs.c	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/master-settings-defs.c	Wed Mar 05 10:10:42 2008 +0100
@@ -115,5 +115,13 @@ static struct setting_def setting_defs[]
 	DEF(SET_STR, pop3_client_workarounds),
 	DEF(SET_STR, pop3_logout_format),
 
+  	/* managesieve */
+  	DEF(SET_INT, managesieve_max_line_length),
+  	DEF(SET_STR, managesieve_implementation_string),
+
+	/* sieve */
+  	DEF(SET_STR, sieve_storage),
+  	DEF(SET_STR, sieve),
+
 	{ 0, NULL, 0 }
 };
diff -r 923786016963 src/master/master-settings.c
--- a/src/master/master-settings.c	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/master-settings.c	Wed Mar 05 10:10:42 2008 +0100
@@ -269,6 +269,14 @@ struct settings default_settings = {
 	MEMBER(pop3_client_workarounds) "",
 	MEMBER(pop3_logout_format) "top=%t/%p, retr=%r/%b, del=%d/%m, size=%s",
 
+	/* managesieve */
+	MEMBER(managesieve_max_line_length) 65536,
+	MEMBER(managesieve_implementation_string) PACKAGE,
+
+	/* sieve */
+	MEMBER(sieve_storage) "",
+	MEMBER(sieve) NULL,
+
 	/* .. */
 	MEMBER(listen_fd) -1,
 	MEMBER(ssl_listen_fd) -1
@@ -425,6 +433,8 @@ static bool auth_settings_verify(struct 
 			auth->parent->pop3->ssl_verify_client_cert = TRUE;
 		if (auth->parent->imap != NULL)
 			auth->parent->imap->ssl_verify_client_cert = TRUE;
+		if (auth->parent->managesieve != NULL)
+			auth->parent->managesieve->ssl_verify_client_cert = TRUE;
 	}
 
 	for (s = auth->sockets; s != NULL; s = s->next) {
@@ -475,8 +485,11 @@ static bool settings_is_active(struct se
 	if (set->protocol == MAIL_PROTOCOL_IMAP) {
 		if (strstr(set->protocols, "imap") == NULL)
 			return FALSE;
+	} else if (set->protocol == MAIL_PROTOCOL_POP3) {
+		if (strstr(set->protocols, "pop3") == NULL)
+			return FALSE;
 	} else {
-		if (strstr(set->protocols, "pop3") == NULL)
+		if (strstr(set->protocols, "managesieve") == NULL)
 			return FALSE;
 	}
 
@@ -1081,7 +1094,7 @@ static const char *parse_setting(const c
 
 	if (strcmp(key, "login") == 0) {
 		i_warning("Ignoring deprecated 'login' section handling. "
-			  "Use protocol imap/pop3 { .. } instead. "
+			  "Use protocol imap/pop3/managesieve { .. } instead. "
 			  "Some settings may have been read incorrectly.");
 		return NULL;
 	}
@@ -1104,6 +1117,15 @@ static const char *parse_setting(const c
 			error = parse_setting_from_defs(settings_pool,
 							setting_defs,
 							ctx->server->pop3,
+							key, value);
+		}
+
+		if (error == NULL &&
+		    (ctx->protocol == MAIL_PROTOCOL_ANY ||
+		     ctx->protocol == MAIL_PROTOCOL_MANAGESIEVE)) {
+			error = parse_setting_from_defs(settings_pool,
+							setting_defs,
+							ctx->server->managesieve,
 							key, value);
 		}
 
@@ -1165,6 +1187,13 @@ static const char *parse_setting(const c
 			array_append(&ctx->server->pop3->plugin_envs,
 				     &value, 1);
 		}
+		if (ctx->protocol == MAIL_PROTOCOL_ANY ||
+		    ctx->protocol == MAIL_PROTOCOL_MANAGESIEVE) {
+			array_append(&ctx->server->managesieve->plugin_envs, &key, 1);
+			array_append(&ctx->server->managesieve->plugin_envs,
+				     &value, 1);
+		}
+
 		return NULL;
 	}
 
@@ -1174,7 +1203,8 @@ static struct server_settings *
 static struct server_settings *
 create_new_server(const char *name,
 		  struct settings *imap_defaults,
-		  struct settings *pop3_defaults)
+		  struct settings *pop3_defaults,
+		  struct settings *managesieve_defaults)
 {
 	struct server_settings *server;
 
@@ -1182,16 +1212,20 @@ create_new_server(const char *name,
 	server->name = p_strdup(settings_pool, name);
 	server->imap = p_new(settings_pool, struct settings, 1);
 	server->pop3 = p_new(settings_pool, struct settings, 1);
+	server->managesieve = p_new(settings_pool, struct settings, 1);
 	server->auth_defaults = default_auth_settings;
 
 	*server->imap = *imap_defaults;
 	*server->pop3 = *pop3_defaults;
+	*server->managesieve = *managesieve_defaults;
 
 	ARRAY_CREATE(&server->dicts, settings_pool, const char *, 4);
 	ARRAY_CREATE(&server->imap->plugin_envs, settings_pool,
 		     const char *, 8);
 	ARRAY_CREATE(&server->pop3->plugin_envs, settings_pool,
 		     const char *, 8);
+	ARRAY_CREATE(&server->managesieve->plugin_envs, settings_pool,
+		     const char *, 8);
 
 	server->imap->server = server;
 	server->imap->protocol = MAIL_PROTOCOL_IMAP;
@@ -1205,6 +1239,12 @@ create_new_server(const char *name,
 	server->pop3->mail_executable = PKG_LIBEXECDIR"/pop3";
 	server->pop3->mail_plugin_dir = MODULEDIR"/pop3";
 
+	server->managesieve->server = server;
+	server->managesieve->protocol = MAIL_PROTOCOL_MANAGESIEVE;
+	server->managesieve->login_executable = PKG_LIBEXECDIR"/managesieve-login";
+	server->managesieve->mail_executable = PKG_LIBEXECDIR"/managesieve";
+	server->managesieve->mail_plugin_dir = MODULEDIR"/managesieve";
+  
 	return server;
 }
 
@@ -1248,8 +1288,8 @@ static bool parse_section(const char *ty
 
 		ctx->type = SETTINGS_TYPE_SERVER;
 		ctx->server = create_new_server(name, ctx->server->imap,
-						ctx->server->pop3);
-                server = ctx->root;
+						ctx->server->pop3, ctx->server->managesieve);
+		server = ctx->root;
 		while (server->next != NULL)
 			server = server->next;
 		server->next = ctx->server;
@@ -1270,6 +1310,8 @@ static bool parse_section(const char *ty
 			ctx->protocol = MAIL_PROTOCOL_POP3;
 		else if (strcmp(name, "lda") == 0)
 			ctx->protocol = MAIL_PROTOCOL_LDA;
+		else if (strcmp(name, "managesieve") == 0)
+			ctx->protocol = MAIL_PROTOCOL_MANAGESIEVE;
 		else {
 			*errormsg = "Unknown protocol name";
 			return FALSE;
@@ -1380,7 +1422,7 @@ bool master_settings_read(const char *pa
 	ctx.protocol = MAIL_PROTOCOL_ANY;
 	ctx.server = ctx.root =
 		create_new_server("default",
-				  &default_settings, &default_settings);
+				  &default_settings, &default_settings, &default_settings);
 	ctx.auth = &ctx.server->auth_defaults;
 
 	if (!settings_read(path, NULL, parse_setting, parse_section, &ctx))
@@ -1397,7 +1439,9 @@ bool master_settings_read(const char *pa
 
 	if (!nochecks && !nofixes) {
 		ctx.root->defaults = settings_is_active(ctx.root->imap) ?
-			ctx.root->imap : ctx.root->pop3;
+			ctx.root->imap : 
+			(settings_is_active(ctx.root->pop3) ? 
+				ctx.root->pop3 : ctx.root->managesieve);
 
 		path = t_strconcat(ctx.root->defaults->base_dir,
 				   "/master.pid", NULL);
@@ -1407,7 +1451,8 @@ bool master_settings_read(const char *pa
 	prev = NULL;
 	for (server = ctx.root; server != NULL; server = server->next) {
 		if ((*server->imap->protocols == '\0' ||
-		     *server->pop3->protocols == '\0') && !nochecks) {
+		     *server->pop3->protocols == '\0' ||
+		     *server->managesieve->protocols == '\0') && !nochecks) {
 			i_error("No protocols given in configuration file");
 			return FALSE;
 		}
@@ -1437,6 +1482,15 @@ bool master_settings_read(const char *pa
 				server->defaults = server->pop3;
 		}
 
+		if (!settings_is_active(server->managesieve) && !nochecks)
+			server->managesieve = NULL;
+		else {
+			if (!settings_fix(server->managesieve, nochecks, nofixes))
+				return FALSE;
+			if (server->defaults == NULL)
+				server->defaults = server->managesieve;
+		}
+
 		if (server->defaults == NULL) {
 			if (prev == NULL)
 				ctx.root = server->next;
@@ -1653,8 +1707,8 @@ static void dict_settings_dump(const str
 
 void master_settings_dump(struct server_settings *set, bool nondefaults)
 {
-	const void *sets[4];
-	const char *set_names[4];
+	const void *sets[5];
+	const char *set_names[5];
 	unsigned int count;
 
 	sets[0] = &default_settings;
@@ -1673,6 +1727,11 @@ void master_settings_dump(struct server_
 		sets[count] = set->pop3;
 		set_names[count] = "pop3";
 		count++;
+	}	
+	if (set->managesieve != NULL) {
+		sets[count] = set->managesieve;
+		set_names[count] = "managesieve";
+		count++;
 	}
 	settings_dump(setting_defs, sets, set_names, count, nondefaults, 0);
 	namespace_settings_dump(set->namespaces, nondefaults);
diff -r 923786016963 src/master/master-settings.h
--- a/src/master/master-settings.h	Wed Mar 05 09:12:44 2008 +0200
+++ b/src/master/master-settings.h	Wed Mar 05 10:10:42 2008 +0100
@@ -4,10 +4,11 @@
 #include "network.h"
 
 enum mail_protocol {
-        MAIL_PROTOCOL_ANY,
-        MAIL_PROTOCOL_IMAP,
+	MAIL_PROTOCOL_ANY,
+	MAIL_PROTOCOL_IMAP,
 	MAIL_PROTOCOL_POP3,
-	MAIL_PROTOCOL_LDA
+	MAIL_PROTOCOL_LDA,
+	MAIL_PROTOCOL_MANAGESIEVE
 };
 
 struct settings {
@@ -123,6 +124,14 @@ struct settings {
 	const char *pop3_client_workarounds;
 	const char *pop3_logout_format;
 
+	/* managesieve */
+	unsigned int managesieve_max_line_length;
+	const char *managesieve_implementation_string;
+
+	/* sieve */
+	const char *sieve_storage;
+	const char *sieve;
+
 	/* .. */
 	int listen_fd, ssl_listen_fd;
 
@@ -231,9 +240,10 @@ struct server_settings {
 	struct settings *defaults;
 	struct settings *imap;
 	struct settings *pop3;
+	struct settings *managesieve;
 	struct auth_settings *auths;
 	struct auth_settings auth_defaults;
-        struct namespace_settings *namespaces;
+	struct namespace_settings *namespaces;
 
 	array_t ARRAY_DEFINE(dicts, const char *);
 
