Author: Stephan Bosch <stephan@rename-it.nl>
Description: Adds support for SIEVE in Dovecot LDA (deliver)
Origin: http://www.rename-it.nl/dovecot/1.2/dovecot-1.2-sieve-0.1.14.tar.gz
Last-Update: 2009-12-20

Index: b/sieve/AUTHORS
===================================================================
--- /dev/null
+++ b/sieve/AUTHORS
@@ -0,0 +1,13 @@
+Stephan Bosch <stephan@rename-it.nl>
+
+This plugin is partly based on the original cmusieve plugin for the Dovecot
+secure IMAP server. It is based only on code relating to interfacing the CMU
+Sieve implementation to Dovecot, meaning that no CMU code is incorporated in
+this implementation.
+
+Both the cmusieve plugin and the Dovecot IMAP server are primarily written by:
+
+Timo Sirainen <tss@iki.fi>
+
+View the AUTHORS files in the Dovecot and Dovecot-Sieve distributions for other
+contributors.
Index: b/sieve/COPYING
===================================================================
--- /dev/null
+++ b/sieve/COPYING
@@ -0,0 +1,4 @@
+See AUTHORS file for list of copyright holders.
+
+Everything is licenced under LGPLv2.1 (see COPYING.LGPL) unless otherwise
+mentioned at the beginning of the file.
Index: b/sieve/COPYING.LGPL
===================================================================
--- /dev/null
+++ b/sieve/COPYING.LGPL
@@ -0,0 +1,510 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
Index: b/sieve/ChangeLog
===================================================================
--- /dev/null
+++ b/sieve/ChangeLog
@@ -0,0 +1,8566 @@
+2009-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Updated documentation from wiki.
+	[216f58aae5c1] [tip]
+
+2009-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[57683578c7f0]
+
+	* TODO, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool/sieve-
+	tool.h, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/sieve-settings.h, src/lib-sieve/sieve-types.h, src/plugins
+	/lda-sieve/lda-sieve-plugin.c, src/testsuite/testsuite.c:
+	Made homedir aquisition a callback.
+	[e36fa65f19e6]
+
+	* src/lib-sieve/sieve-settings.c:
+	A warning is now produced when parsing invalid integer settings.
+	[f81856d00b5f]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-limits.c, src/lib-sieve/sieve-
+	limits.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	settings.c, src/lib-sieve/sieve-settings.h, src/lib-sieve/sieve.c:
+	Made limits on the number of redirects and the number of actions in
+	general configurable.
+	[5cad1afbbf0f]
+
+2009-11-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed homedir expansion bug in the include extension.
+	[433b52431a4a]
+
+2009-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	script.c, src/lib-sieve/sieve-script.h:
+	Made sure that scripts are only recompiled when the script file - or
+	the symlink pointing to it - is strictly newer.
+	[e0f0d4f2d186]
+
+2009-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/date/tst-date.c:
+	Fixed comment errors in date extension.
+	[c6c879061b5d]
+
+2009-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[ea3df87350e3]
+
+2009-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/Makefile.am, src/plugins/lda-sieve/lda-sieve-
+	plugin.c:
+	LDA Sieve plugin: convert mailbox from mutf7 to utf8 because the
+	Sieve lib uses utf8 internally.
+	[5d5dc0b41601]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Subaddress extension: now also accepts recipient_delimiter setting
+	as an alias for sieve_subaddress_sep setting.
+	[d2964561e2f7]
+
+2009-11-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-types.h, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made LDA Sieve plugin recognize the deliver_log_format setting.
+	[2e4679323759]
+
+2009-10-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed bug in result printing (untroduced in large rework).
+	[8d108f33cb81]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed bug in the extensions configuration (untroduced in large
+	rework).
+	[ea829f739506]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-actions.h:
+	Fixed logging of mailbox names. It logged the converted mUTF7
+	version in stead of the original UTF8.
+	[b7bce5bf173e]
+
+	* src/lib-sieve/sieve-interpreter.c:
+	Fixed small coded indentation problems.
+	[cb7f4d6f17e3]
+
+	* src/testsuite/testsuite-script.c:
+	Fixed missing include.
+	[61198844f2ca]
+
+	* src/lib-sieve/sieve.c:
+	Fixed minor memory leak in the multiscript support.
+	[a9f960424591]
+
+	* src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool/sieve-tool.h,
+	src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	common.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools
+	/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c, src/testsuite/Makefile.am,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite-settings.c, src/testsuite/testsuite-
+	settings.h, src/testsuite/testsuite.c:
+	Properly implemented settings retrieval API.
+	[97d03abe7842]
+
+2009-10-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool/sieve-tool.h,
+	src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/cmd-stop.c, src/lib-sieve/cmp-i-ascii-
+	casemap.c, src/lib-sieve/cmp-i-octet.c, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/mcht-
+	contains.c, src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c,
+	src/lib-sieve/plugins/Makefile.am, src/lib-sieve/plugins/body/ext-
+	body-common.c, src/lib-sieve/plugins/body/ext-body-common.h, src
+	/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/date/ext-date-common.c, src/lib-sieve/plugins/date
+	/ext-date-common.h, src/lib-sieve/plugins/date/ext-date.c, src/lib-
+	sieve/plugins/date/tst-date.c, src/lib-sieve/plugins/enotify/cmd-
+	notify.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/plugins/enotify/tst-notify-
+	method-capability.c, src/lib-sieve/plugins/enotify/tst-valid-notify-
+	method.c, src/lib-sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/ext-environment-common.h, src/lib-
+	sieve/plugins/environment/ext-environment.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h, src/lib-
+	sieve/plugins/environment/tst-environment.c, src/lib-
+	sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/ext-imapflags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-
+	sieve/plugins/include/cmd-global.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/mailbox
+	/ext-mailbox-common.h, src/lib-sieve/plugins/mailbox/ext-mailbox.c,
+	src/lib-sieve/plugins/mailbox/tag-mailbox-create.c, src/lib-
+	sieve/plugins/mailbox/tst-mailboxexists.c, src/lib-
+	sieve/plugins/notify/cmd-denotify.c, src/lib-sieve/plugins/notify
+	/cmd-notify.c, src/lib-sieve/plugins/notify/ext-notify-common.c, src
+	/lib-sieve/plugins/notify/ext-notify-common.h, src/lib-
+	sieve/plugins/notify/ext-notify.c, src/lib-sieve/plugins/regex/ext-
+	regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.h, src/lib-sieve/plugins/variables/ext-variables-dump.c, src
+	/lib-sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary-dumper.c, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-dumper.h, src
+	/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-dump.h, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	script-private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve
+	/tst-size.c, src/lib-sieve/tst-truefalse.c, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-tools/debug/cmd-debug-print.c, src
+	/sieve-tools/debug/ext-debug-common.h, src/sieve-tools/debug/ext-
+	debug.c, src/sieve-tools/debug/sieve-ext-debug.h, src/sieve-tools
+	/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c, src/testsuite/cmd-test-
+	binary.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-
+	mailbox.c, src/testsuite/cmd-test-message.c, src/testsuite/cmd-test-
+	result-print.c, src/testsuite/cmd-test-result-reset.c, src/testsuite
+	/cmd-test-set.c, src/testsuite/cmd-test.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/testsuite-arguments.c, src/testsuite
+	/testsuite-arguments.h, src/testsuite/testsuite-binary.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-script.c, src/testsuite/testsuite-substitutions.c,
+	src/testsuite/testsuite-substitutions.h, src/testsuite/testsuite.c,
+	src/testsuite/tst-test-error.c, src/testsuite/tst-test-
+	multiscript.c, src/testsuite/tst-test-result-execute.c,
+	src/testsuite/tst-test-result.c, src/testsuite/tst-test-script-
+	compile.c, src/testsuite/tst-test-script-run.c,
+	tests/compile/errors/typos.sieve,
+	tests/extensions/environment/basic.svtest,
+	tests/extensions/imap4flags/multiscript.svtest:
+	Major rework of extension handling, making sure that no global state
+	is maintained.
+
+	- No global state is changed by the engine. This makes sure multiple
+	engines can be run for different users in the same process.
+	- Separated object types in a definition and an instance
+	- Object instances refer to their extension instance
+	- Extension IDs are only used in the low-level functionality.
+	- Cleaned up the extension API in many ways
+	[2fff498ef8c7]
+
+2009-10-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/rfc2822.c, src
+	/lib-sieve/rfc2822.h, tests/extensions/vacation/utf-8.svtest:
+	Message headers produced from user-supplied data are now
+	RFC2047-encoded if necessary for outgoing messages.
+	[b05a7a7a42a1]
+
+2009-10-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c, src/lib-
+	sieve/plugins/notify/ext-notify-common.c, src/lib-
+	sieve/plugins/notify/ext-notify-common.h,
+	tests/deprecated/notify/mailto.svtest:
+	Notify (deprecated): added support for the $text$ substitution.
+	[9e236339157a]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Fixed indentation problems in obsolete notify extension.
+	[54f8f8b086a6]
+
+2009-10-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.13 for changeset 653063341d13
+	[9b93e30391b8]
+
+	* NEWS, configure.in:
+	Released v0.1.13 for Dovecot v1.2.6.
+	[653063341d13] [0.1.13]
+
+2009-10-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Cleaned up TODO file.
+	[8e9ab4d0b950]
+
+	* src/testsuite/cmd-test-message.c, src/testsuite/testsuite-script.c,
+	tests/extensions/imap4flags/multiscript.svtest,
+	tests/extensions/imap4flags/multiscript/fileinto.sieve,
+	tests/extensions/imap4flags/multiscript/setflag.sieve:
+	Testsuite: added multiscript flag tests for the imap4flags
+	extension.
+	[a47f73f6fd1a]
+
+2009-10-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, TODO, src/testsuite/Makefile.am, src/testsuite/ext-
+	testsuite.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-script.c, src/testsuite/testsuite-script.h, src/testsuite
+	/tst-test-multiscript.c,
+	tests/extensions/imap4flags/multiscript.svtest,
+	tests/extensions/imap4flags/multiscript/group-spam.sieve,
+	tests/extensions/imap4flags/multiscript/sent-store.sieve,
+	tests/extensions/imap4flags/multiscript/spam.sieve:
+	Test suite: added multiscript support and added some new tests with
+	the new feature.
+	[17b7e6a3f9d2]
+
+	* TODO:
+	Updated TODO.
+	[167067298b83]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[8e62192930fa]
+
+	* TODO:
+	Updated TODO.
+	[a95b3f1a1b17]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed race condition occuring when multiple instances are saving the
+	same binary (patch by Timo Sirainen).
+	[5f4a4cec09ed]
+
+2009-10-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* tests/extensions/body/content.svtest:
+	Test suite: added tests for not yet working body extension features.
+	[0203e975c933]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body extension: minor code cleanups.
+	[91c2a1fbb23b]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body extension: fixed minor comment error.
+	[fb1bf5953318]
+
+	* tests/extensions/body/basic.svtest,
+	tests/extensions/body/content.svtest:
+	Test suite: restructured tests for body extension.
+	[89e6777f08b1]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body extension: made parsing of content-type header more robust.
+	[321f10d25942]
+
+	* Makefile.am, tests/extensions/body/content.svtest:
+	Test suite: added tests for basic use of :content with body test.
+	[5e27c18fac11]
+
+2009-10-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added TODO item.
+	[9648de97a955]
+
+	* Makefile.am, src/lib-sieve/plugins/body/ext-body-common.c, src/lib-
+	sieve/plugins/body/ext-body-common.h, src/lib-sieve/plugins/body
+	/tst-body.c, tests/extensions/body/basic.svtest,
+	tests/extensions/body/raw.svtest:
+	Body extension: implemented proper handling of the :raw transform.
+	[a820e53138b8]
+
+2009-10-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/sieve-lexer.c,
+	tests/compile/warnings.svtest, tests/compile/warnings/eof.sieve:
+	Made compiler more lenient towars missing CRLF at the end of the
+	script in a hash comment.
+	[3c3984419921]
+
+2009-09-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added TODO item.
+	[12418b8950e4]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body extension: don't give SKIP_BODY_BLOCK flag to message parser,
+	we want the body! (patch by Timo Sirainen).
+	[967df8a53cb4]
+
+	* src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Fixed handling of implicit side effects for multiscript execution.
+	[f3642d9934cf]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed bug in multiscript support; subsequent keep actions were not
+	always merged correctly.
+	[b62291ff5faf]
+
+	* src/sieve-tools/sieve-test.c:
+	Fixed segfault bug in the sieve-test tool.
+	[28ac4fa836b9]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed segfault bug triggered by merging side effects in duplicate
+	actions.
+	[c26e7c2300b4]
+
+2009-08-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: don't try stat the user's personal script if it is not
+	specified (NULL).
+	[a8c962e603be]
+
+	* src/lib-sieve/plugins/mailbox/Makefile.am, src/lib-
+	sieve/plugins/mailbox/cmd-mailboxexists.c, src/lib-
+	sieve/plugins/mailbox/tst-mailboxexists.c:
+	Mailbox extension: mailboxexists source file had wrong name; it is a
+	test and not a command.
+	[926d9b18a5d8]
+
+2009-08-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.h:
+	Enotify: removed spurious extern declaration of notify_extension.
+	[23cd32095b3e]
+
+	* src/lib-sieve/plugins/notify/ext-enotify.c:
+	Notify (deprecated): removed spurious source file.
+	[e09bf0d67b9a]
+
+	* .hgtags:
+	Added tag 0.1.12 for changeset 41f236697f9b
+	[8010f1eb66b3]
+
+	* configure.in:
+	Released v0.1.12 for Dovecot v1.2.4.
+	[41f236697f9b] [0.1.12]
+
+	* src/testsuite/testsuite-common.c, src/testsuite/testsuite-script.c:
+	Fixed compile warnings in test suite.
+	[9b59c9424269]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[645e77f279de]
+
+2009-08-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[0fe00772366f]
+
+	* Makefile.am, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c, tests/extensions/include/execute.svtest,
+	tests/extensions/include/execute/actions-fileinto.sieve,
+	tests/extensions/include/execute/included/actions-fileinto1.sieve,
+	tests/extensions/include/execute/included/actions-fileinto2.sieve,
+	tests/extensions/include/execute/included/actions-fileinto3.sieve:
+	Testsuite: added action execution test for the include extension
+	with stored binaries.
+	[e94731815d2d]
+
+	* src/lib-sieve/sieve-script.c:
+	Made sure script can be compared to NULL.
+	[cf5487f0c81a]
+
+	* Makefile.am, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	binary.c, src/testsuite/ext-testsuite.c, src/testsuite/testsuite-
+	binary.c, src/testsuite/testsuite-binary.h, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h, src/testsuite/testsuite-
+	script.c, src/testsuite/testsuite-script.h,
+	tests/compile/examples.svtest, tests/execute/examples.svtest:
+	Testsuite: added support for testing binaries stored on disk.
+	[79d330457a69]
+
+	* src/lib-sieve/sieve-error.c:
+	Fixed bug in error reporting when binary-related script object is
+	not set.
+	[48b7ad7a35ab]
+
+2009-08-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[74e061124cf3]
+
+	* README:
+	Updated documentation.
+	[329e2e31c14f]
+
+	* Makefile.am, tests/extensions/date/basic.svtest,
+	tests/extensions/date/date-parts.svtest,
+	tests/extensions/date/zones.svtest:
+	Testsuite: added tests for the new date extension.
+	[4e9e557052ff]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/date/ext-date.c, src/lib-sieve/sieve-
+	extensions.c:
+	Date extension: now included in default compile.
+	[8dfb24ac1e4c]
+
+	* src/lib-sieve/plugins/date/tst-date.c:
+	Date extension: accidentally committed debug printf.
+	[c296d6bea23e]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/tst-date.c:
+	Date extension: fixed problems in time zone handling.
+	[870d6b440c38]
+
+	* src/testsuite/testsuite-message.c:
+	Testsuite: added some debug code.\n
+	[f04fc584ca85]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: fixed bug in julian date calculation.
+	[addaeebef178]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/tst-date.c:
+	Date extension: fixed a few bugs related to date part extraction.
+	[3010ae60056c]
+
+	* src/lib-sieve/plugins/date/tst-date.c:
+	Date extension: fixed errorhandling of gmtime() call.
+	[acf485c1e359]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/tst-date.c:
+	Date extension: completed implementation.
+	[77fe808ea758]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: all simple integer date parts are fixed-length
+	strings.
+	[0410db763a44]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c, src/lib-
+	sieve/plugins/date/ext-date-common.h, src/lib-sieve/plugins/date
+	/tst-date.c:
+	Date extension: implemented time zone handling.
+	[9cd4612b1680]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: implemented iso8601 date part.
+	[236fb0006d9c]
+
+	* src/lib-sieve/plugins/date/ext-date-common.c:
+	Date extension: implemented a few more date parts.
+	[9d81ee954315]
+
+2009-08-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Fixed distribution of unfinished features.
+	[03cb0e6d4a35]
+
+2009-08-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/date/Makefile.am, src/lib-sieve/plugins/date
+	/ext-date-common.c, src/lib-sieve/plugins/date/ext-date-common.h,
+	src/lib-sieve/plugins/date/ext-date.c, src/lib-sieve/plugins/date
+	/tst-date.c:
+	Date extension: built infrastructure for date part testing.
+	[c679aa4cb12c]
+
+2009-08-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.11 for changeset 82c5b529b002
+	[45be092f98c7]
+
+	* configure.in:
+	Released v0.1.11 for Dovecot v1.2.3.
+	[82c5b529b002] [0.1.11]
+
+	* NEWS, doc/man/sieve-filter.1:
+	Updated NEWS file for next release.
+	[715bb2f65e82]
+
+2009-08-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[0af8fa38807e]
+
+	* Makefile.am, doc/man/sieve-filter.1:
+	Sieve-filter: created man-page a design for the command line
+	options.
+	[e357bd4f02e8]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: compare execution result to SIEVE_EXEC_OK and not to zero.
+	[3b956913d5bc]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: fixed return type of execution function.
+	[824048b8571c]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c:
+	Fixed erroneous comment in binary implementation.
+	[77d19dfcd085]
+
+2009-08-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Fixed typo in TODO file.
+	[d9da9d373bca]
+
+2009-08-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[113dd62b0111]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/date/Makefile.am,
+	src/lib-sieve/plugins/date/ext-date-common.h, src/lib-
+	sieve/plugins/date/ext-date.c, src/lib-sieve/plugins/date/tst-
+	date.c, src/lib-sieve/sieve-extensions.c:
+	Built skeleton implementation for the date extension (RFC 5260).
+	[ccdc02029e0f]
+
+	* src/lib-sieve/plugins/body/tst-body.c:
+	Body: fixed erroneous return code for invalid optional operand.
+	[2c44457561c9]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.c:
+	Be explicit about signedness of data in binary code representation.
+	Some architectures, like ARM, differ in this respect.
+	[bbb2e488172f]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-sieve/plugins/mailbox
+	/ext-mailbox.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	code.h:
+	Side-effect argumennt registrations were not using the
+	SIEVE_OPT_SIDE_EFFECT constant.
+	[0478be666511]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-common.h:
+	Removed direct stdint.h includes to prevent portability issues.
+	[6090ba0d6f03]
+
+2009-08-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a317da703765]
+
+	* TODO:
+	Reprioritized and reformatted TODO file.
+	[05117882b72a]
+
+	* src/lib-sieve/sieve.c:
+	Fixed segfault bug in the handling of script open failures.
+	[b33127dc5d1b]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c:
+	Include: further adjusted log and user messages.
+	[86a000cf54d4]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	LDA-Sieve plugin: fixed copy-paste mixup between sieve_after and
+	sieve_before. If only a sieve_after script was active, nothing would
+	have been executed. Patch by Mike Abbott.
+	[1c0543e52ed5]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: fixed bug in /home/stephan substitution in sieve_dir path.
+	[ab82a70d9907]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: improved error messages for include failures.
+	[205b0ec811ee]
+
+	* src/lib-sieve/plugins/include/cmd-include.c:
+	Include: removed variables-related FIXME and substituted a permanent
+	error message.
+	[069263b9f3e5]
+
+2009-08-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.10 for changeset 8ae9b01db362
+	[16bb88837266]
+
+	* NEWS, configure.in:
+	Released v0.1.10 for Dovecot v1.2.2.
+	[8ae9b01db362] [0.1.10]
+
+	* src/testsuite/Makefile.am:
+	Forgot to add header in Makefile.am for testsuite.
+	[7db3f5e8b7dd]
+
+	* src/lib-sieve/plugins/mailbox/Makefile.am:
+	Fixed automake bug in new maibox extension sources.
+	[56e86c8e7419]
+
+2009-08-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Added dependency notice to the NEWS file.
+	[85caab9894a0]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a5e590c49e86]
+
+	* Makefile.am:
+	Testsuite: made valgrind report all allocated blocks that remain at
+	program end.
+	[d206080c122b]
+
+	* src/testsuite/testsuite-common.c:
+	Testsuite: properly deallocated test name string buffer upon close.
+	[2b592e23b02f]
+
+	* src/lib-sieve/sieve-match.c:
+	Fixed memory leak in matching code caused by earlier fix.
+	[314cacead8aa]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	tools/sieved.c:
+	Made proper API for loading a binary directly.
+	[f52049f1196d]
+
+	* tests/extensions/imap4flags/flagstore.svtest:
+	Testsuite: added an important test for the imap4flags extension.
+	[baf3540e80fb]
+
+	* Makefile.am, TODO, tests/extensions/imap4flags/flagstore.svtest:
+	Imap4flags: added flag storage tests using mailbox loopback.
+	[cfec3730793e]
+
+	* src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c,
+	tests/extensions/imap4flags/basic.svtest:
+	Imap4flags: now reads initial flags and keywords from supplied mail.
+	Upon delivery this is empty, which still matches the specification.
+	[bde86aa3a552]
+
+	* src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added access methods for message data en script environment to
+	result object.
+	[ba533745f5e9]
+
+	* Makefile.am, TODO, src/testsuite/cmd-test-message.c, src/testsuite
+	/testsuite-mailstore.c, tests/execute/mailstore.svtest,
+	tests/extensions/mailbox/execute.svtest:
+	Testsuite: added support for testing delivered messages by looping
+	these back as the evaluated message. Added tests for the fileinto
+	command.
+	[f4f4a6c5cba9]
+
+2009-08-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated README.
+	[2bd355dabcfb]
+
+	* TODO, src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c, src/lib-
+	sieve/plugins/mailbox/ext-mailbox.c:
+	Updated TODO and added a FIXME to the mailbox extension (no ACL
+	support yet, but required by RFC).
+	[15fadac299a3]
+
+	* Makefile.am, tests/extensions/mailbox/execute.svtest:
+	Testsuite: added tests for the mailbox extension.
+	[0691a3804073]
+
+	* src/lib-sieve/plugins/mailbox/cmd-mailboxexists.c, src/lib-
+	sieve/plugins/mailbox/ext-mailbox.c:
+	Mailbox extension: finished implementation.
+	[7b772c4fa332]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Small code cleanup in the lexer code.
+	[57307603b757]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1:
+	Updated man pages.
+	[963fe9ea3eb1]
+
+2009-07-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-script.c:
+	Fixed bug in the derivation of the binary path from the script path.
+	A bare filename would yield a path relative to root.
+	[5d4eb8918bf8]
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-mailbox.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-mailstore.c, src/testsuite/testsuite-
+	mailstore.h, src/testsuite/testsuite-message.c, src/testsuite
+	/testsuite-message.h, src/testsuite/testsuite.c,
+	tests/execute/actions.svtest,
+	tests/extensions/imap4flags/execute.svtest:
+	Testsuite: added support for testing mailbox operations.
+	[c71d7e59d532]
+
+	* autogen.sh, configure.in:
+	Use foreign automake option so it doesn't complain about missing
+	ChangeLog.
+	[f33c8245ef95]
+
+2009-07-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: documented source code a little better.
+	[3c9a22c28156]
+
+	* src/lib-sieve/plugins/mailbox/tag-mailbox-create.c:
+	Mailbox extension: fixed compiler warning.
+	[cc49d7080a14]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/body/tst-body.c,
+	src/lib-sieve/plugins/enotify/tst-notify-method-capability.c, src
+	/lib-sieve/plugins/environment/tst-environment.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/mcht-count.c, src
+	/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	match.c, src/lib-sieve/sieve-match.h, src/lib-sieve/tst-address.c,
+	src/lib-sieve/tst-header.c, src/testsuite/tst-test-error.c,
+	src/testsuite/tst-test-result.c:
+	Made sieve_match_context use a proper pool in stead of the
+	datastack.
+	[f316a10179f3]
+
+2009-07-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added TODO item.
+	[8f2945e2714b]
+
+	* src/lib-sieve/plugins/include/ext-include.c:
+	Include: fixed assertion fail caused by missing initialization (bug
+	surfaces only for stored binaries).
+	[d989537882d0]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: include error message for failed :global include.
+	[449d8ecb0f34]
+
+2009-07-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: removed unnecessary MAILBOX_TRANSACTION_FLAG_REFRESH
+	flag for mailbox_transaction_begin().
+	[6ef0cdffb66c]
+
+	* TODO:
+	Reprioritized TODO.
+	[6dcaf8d54055]
+
+	* src/lib-sieve/plugins/mailbox/tag-mailbox-create.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Mailbox extension: implemented the :create tagged argument for the
+	fileinto command.
+	[b1920ece04e3]
+
+2009-07-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h:
+	Sieve-filter: added support for setting flags on message in the
+	source folder.
+	[28badfffdc1c]
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: corrected and optimized mail filter loop.
+	[2980d32fb5ef]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed broken wiki reference in error message.
+	[5c20969f1a50]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/mailbox/Makefile.am, src/lib-sieve/plugins/mailbox
+	/cmd-mailboxexists.c, src/lib-sieve/plugins/mailbox/ext-mailbox-
+	common.h, src/lib-sieve/plugins/mailbox/ext-mailbox.c, src/lib-
+	sieve/plugins/mailbox/tag-mailbox-create.c, src/lib-sieve/sieve-
+	extensions.c:
+	Implemented skeleton of the mailbox extension.
+	[ffa5cd58c284]
+
+	* src/lib-sieve/plugins/Makefile.am, src/lib-sieve/plugins/notify/cmd-
+	denotify.c:
+	Notify (deprecated): fixed compiler warnings.
+	[8716323f82c4]
+
+2009-07-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h, src
+	/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented alternative discard actions.
+	[db78e485cbb2]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h, src
+	/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented expunging filtered messages in the source
+	folder (move).
+	[1ea614e1a1a6]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-tools/sieve-filter.c, src/sieve-tools
+	/sieve-test.c:
+	Added means to get keep status from sieve execution through main
+	Sieve library API.
+	[78c065beba2d]
+
+	* src/sieve-tools/sieve-filter.c:
+	Minor changes to the sieve-filter tool.
+	[a922ed52ddd6]
+
+2009-07-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Restructured store action implementation to properly handle an
+	attempt to store (keep) a message in the folder it originates from.
+	[32f6d1c48ad4]
+
+	* src/lib-sieve/plugins/notify/Makefile.am, src/lib-
+	sieve/plugins/notify/cmd-denotify.c, src/lib-sieve/plugins/notify
+	/cmd-notify.c, src/lib-sieve/plugins/notify/ext-notify-common.c, src
+	/lib-sieve/plugins/notify/ext-notify-common.h, src/lib-
+	sieve/plugins/notify/ext-notify.c:
+	Notify (deprecated): implemented skeleton of the denotify command.
+	[d6efcfec8bb6]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fallback to INBOX when storing into a namespace prefix used wrong
+	storage.
+	[a6a435654c31]
+
+	* .hgtags:
+	Merged concurrent changes.
+	[3b5ee8772a28]
+
+	* .hgtags:
+	Added tag 0.1.9 for changeset fc4b67c99918
+	[2c64466c64c5]
+
+	* NEWS, configure.in:
+	Released v0.1.9 for Dovecot v1.2.1.
+	[fc4b67c99918] [0.1.9]
+
+	* src/sieve-tools/sieve-filter.c:
+	Separated source and destination mail store for sieve-filter tool.
+	[0369e2058441]
+
+2009-07-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.9 for changeset 247163f96a5c
+	[ca542d793623]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[247163f96a5c]
+
+	* src/lib-sieve/sieve-actions.c:
+	Showed wrong folder name upon INBOX fallback.
+	[26d14a354b0a]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed more code indent problems.
+	[8ddc79659a82]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed some code indent problems.
+	[b9e1ef848f38]
+
+	* src/lib-sieve/sieve-actions.c:
+	Made attempt to store in a namespace prefix fall back into INBOX.
+	[28280cfcdc80]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed logging of folder namespace prefix in store action.
+	[52226d811da6]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed potential segfault argument parameter validation.
+	[b4eb3a3f1088]
+
+2009-07-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/testsuite/testsuite.c, tests/execute/smtp.svtest,
+	tests/extensions/enotify/mailto.svtest,
+	tests/extensions/reject/smtp.svtest,
+	tests/extensions/vacation/smtp.svtest:
+	Testsuite: added tests on the envelope of outgoing messages produced
+	by redirect, enotify:mailto, reject and vacation.
+	[dd9b380fec73]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/enotify/cmd-notify.c, src
+	/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/notify/cmd-notify.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address.c, src/lib-sieve/sieve-address.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-log.c, src/testsuite
+	/testsuite-message.c, src/testsuite/testsuite-message.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-smtp.c, src/testsuite/testsuite.c:
+	Major rework of envelope address handling: a normalized version of
+	the envelope addresses is maintained in the message context and
+	message context is now also available during action execution.
+	[9ce037c114ae]
+
+2009-07-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/notify/cmd-notify.c, src/lib-sieve/sieve-address.c,
+	src/sieve-tools/sieve-test.c, src/testsuite/testsuite-smtp.c:
+	Fixed segfault bug: made sure return_path is never used without
+	checking for NULL first.
+	[673b13801182]
+
+	* src/sieve-tools/Makefile.am:
+	Removed the sieve-filter tool from the default build. Need to
+	specify --with-unfinished-features to get this tool built.
+	[6c76e13aa608]
+
+2009-07-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/sieve-extensions.c:
+	Added compilation support for ereject extension. It is unfinished
+	right now and performs exactly the same action as reject.
+	[7643e9831866]
+
+	* configure.in, dsieve-config.h.in:
+	Fixed bugs in the autoconf structure regarding enabling/disabling
+	unfinished features.
+	[bd0b4c044a85]
+
+	* doc/rfc/draft-ietf-sieve-refuse-reject-07.txt, doc/rfc/reject-
+	ereject.rfc5429.txt:
+	Downloaded RFC for reject and ereject extensions.
+	[15f749935cef]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src/lib-
+	sieve/sieve-script.c:
+	Improved file manipulation error messages regarding EACCES error.
+	[2a5955af450f]
+
+2009-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* tests/extensions/subaddress/basic.svtest:
+	Testsuite: added tests for envelope/address test behavior with non-
+	existant subaddress :detail part.
+	[d8d6a44fef3d]
+
+	* src/lib-sieve/ext-envelope.c:
+	Envelope: fixed bug in application of address parts; failure to
+	obtain the part would cause inappropriate match success (bug
+	reported by Ron Lee)
+	[d80b2a61c716]
+
+	* src/lib-sieve/tst-address.c:
+	Added additional headers to the list of allowed headers for the
+	address test.
+	[bbc9fcf1a3fb]
+
+2009-07-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/notify/ext-notify.c:
+	Notify (deprecated): added FIXME notice with missing compatibility
+	features.
+	[aed9f105338c]
+
+	* Makefile.am, tests/deprecated/notify/basic.svtest,
+	tests/deprecated/notify/errors.svtest,
+	tests/deprecated/notify/errors/options.sieve,
+	tests/deprecated/notify/execute.svtest,
+	tests/deprecated/notify/execute/duplicates.sieve,
+	tests/deprecated/notify/mailto.svtest:
+	Testsuite: added tests for deprecated notify extension.
+	[7fcca5c65067]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: added support for specifying the available extensions at
+	the commandline.
+	[e492865ee76a]
+
+	* tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/from-mailto.sieve:
+	Testsuite: Notify: added test with empty :from argument for notify
+	command.
+	[74b471ab0a90]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): fixed segfault bug in the :options argument
+	validation.
+	[038b478613a9]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): added runtime check for recipient limit.
+	[1cb03f029e03]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): added runtime check for duplicate recipients.
+	[fa74bf0f35fb]
+
+	* src/lib-sieve/plugins/notify/cmd-notify.c:
+	Notify (deprecated): added support for substitutions in the
+	notification message.
+	[d54d06eee248]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/ext-notify.c, src/lib-sieve/plugins/notify/Makefile.am, src/lib-
+	sieve/plugins/notify/cmd-denotify.c, src/lib-sieve/plugins/notify
+	/cmd-notify.c, src/lib-sieve/plugins/notify/ext-enotify.c, src/lib-
+	sieve/plugins/notify/ext-notify-common.h, src/lib-
+	sieve/plugins/notify/ext-notify-limits.h, src/lib-
+	sieve/plugins/notify/ext-notify.c:
+	Made deprecated notify extension implementation compatible with
+	cmusieve, except for the denotify command.
+	[68be002473f5]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed validator extension validation. It validated the first non-
+	require command before validating the extensions, which produced
+	useless error messages.
+	[ee92d0b9f7b9]
+
+	* src/lib-sieve/cmd-discard.c:
+	Made discard action log a message to avoid confusion about
+	disappearing messages.
+	[f654353b8c13]
+
+2009-07-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/Makefile.am:
+	Forgot to remove old explicit storage library dependency (patch by
+	Arkadiusz Miskiewicz).
+	[31dab511011e]
+
+	* src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Inappropriately ignored return value from fwrite in outgoing message
+	construction.
+	[83f23dfd5b68]
+
+2009-07-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.8 for changeset fa7741359396
+	[78b12c497934]
+
+	* NEWS, configure.in:
+	Released v0.1.8 for Dovecot v1.2.1.
+	[fa7741359396] [0.1.8]
+
+2009-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/deprecated/draft-martin-sieve-notify-01.txt,
+	doc/rfc/deprecated/draft-melnikov-sieve-imapflags-03.txt:
+	Added draft RFCs for deprecated Sieve extensions imapflags and
+	notify (as implemented by cmusieve).
+	[0a2a9e6f9478]
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c:
+	Replaced remainng occurences of t_push() .. t_pop() with T_BEGIN {
+	.. } T_END equivalents.
+	[2bd522f7276b]
+
+2009-07-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/enotify
+	/ext-enotify-common.h, src/lib-sieve/plugins/enotify/ext-notify.c,
+	src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-extensions.c:
+	Added partial support for the depricated notify extension.
+	[d44acd7f4d09]
+
+	* src/lib-sieve/plugins/imap4flags/ext-imapflags.c, src/lib-sieve
+	/sieve-extensions.c:
+	Apparently, deprecated is spelled with an 'e'.
+	[c9379480f820]
+
+2009-07-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-ast.c:
+	Fixed AIX compile problem provisionally.
+	[bd106aa05040]
+
+2009-07-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.7 for changeset 5f22f0468112
+	[e86a81f4bf28]
+
+	* README, configure.in:
+	Released v0.1.7 for Dovecot v1.2.0.
+	[5f22f0468112] [0.1.7]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[6b600005be7e]
+
+	* TODO:
+	Updated TODO.
+	[e45e47df32bf]
+
+2009-07-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgignore:
+	Added item to .hgignore.
+	[964951d1c9fd]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1, src/sieve-
+	tools/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c:
+	Improved consistency of sieve tool documentation.
+	[1b4b951a6c0a]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Enhanced extensions configuration, allowing to specify the enabled
+	extensions relatively to the default.
+	[91cc9f2a2404]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: forgot to initialize script execution status.
+	[c4af2d059871]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: fixed logging for execution of default main script
+	(went to STDERR).
+	[70098e07fa3b]
+
+2009-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[2a0e9ce87006]
+
+2009-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Added support for CRLF line breaks in strbuf error handler
+	(ManageSieve fix).
+	[763f2cff0cae]
+
+2009-06-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.6 for changeset 6856b1027de8
+	[20d4b1c19c92]
+
+	* .hgtags:
+	Added tag 0.1.5 for changeset 61b52e4618e3
+	[6856b1027de8] [0.1.6]
+
+2009-06-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.1.6 for Dovecot v1.2.rc5.
+	[47f83cfcc68e]
+
+	* NEWS:
+	Updated NEWS file for new release.
+	[e9db961974b1]
+
+2009-06-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed potential problems wil NUL characters in body parts.
+	[908f479dd046]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed assert failure caused by ugly code and a change in
+	dovecot.
+	[c9780425e011]
+
+2009-05-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed part of the assert fail problems (Dovecot change).
+	[a14922487fd3]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Adjusted to changes in Dovecot regarding opening a raw stream.
+	[bcd66e758199]
+
+	* src/sieve-tools/Makefile.am:
+	Removed duplicate library dependencies.
+	[bdb7ac7fcbec]
+
+2009-05-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed compiler warning.
+	[4c5c04dd182a]
+
+2009-05-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Made default of sieve_dir setting match the ManageSieve
+	implementation.
+	[334612126bb7]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed indent problems.
+	[f949723e32ef]
+
+2009-04-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, configure.in:
+	Released v0.1.5 for Dovecot v1.2.rc3.
+	[61b52e4618e3] [0.1.5]
+
+	* src/lib-sieve/sieve-binary.c:
+	Increased binary version number.
+	[6f3609b58136]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h, tests/compile/errors.svtest,
+	tests/compile/errors/require.sieve:
+	Improved error message for unknown Sieve extension to account for
+	core commands included as an extension.
+	[c3736fb49332]
+
+2009-04-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed bug in the Sieve plugin's return value that caused omission of
+	delivery when no Sieve scripts are present. Bug spotted by Matthijs
+	Kooijman.
+	[4c858f06b15f]
+
+2009-04-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/environment/ext-environment-common.c:
+	Environment: fixed compiler warning.
+	[afc482d21847]
+
+	* NEWS:
+	Updated NEWS file for upcoming v1.2 release.
+	[f4230bed0845]
+
+	* tests/extensions/environment/rfc.svtest:
+	Testsuite: forgot to add new testcase file.
+	[26e1e01da8bb]
+
+2009-04-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/plugins/environment/ext-environment-
+	common.c, src/lib-sieve/plugins/environment/tst-environment.c:
+	Environment: fixed segfault and fixed some rfc deviations.
+	[831a0a96ea5b]
+
+	* src/lib-sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h,
+	src/testsuite/testsuite.c,
+	tests/extensions/environment/basic.svtest:
+	Environment: activated host environment item.
+	[01b2712fd398]
+
+	* Makefile.am, TODO, configure.in, doc/rfc/environment.rfc5183.txt,
+	src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/environment/Makefile.am, src/lib-
+	sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/ext-environment-common.h, src/lib-
+	sieve/plugins/environment/ext-environment.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h, src/lib-
+	sieve/plugins/environment/tst-environment.c, src/lib-sieve/sieve-
+	extensions.c, tests/extensions/environment/basic.svtest:
+	Implemented core support for the environment extension.
+	[9d6ceadb490a]
+
+2009-04-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, tests/extensions/include/included-global/rfc-
+	ex1-spam_tests.sieve, tests/extensions/include/included/rfc-
+	ex1-always_allow.sieve, tests/extensions/include/included/rfc-
+	ex1-mailing_lists.sieve, tests/extensions/include/included/rfc-
+	ex1-spam_tests.sieve, tests/extensions/include/included/rfc-
+	ex2-spam_filter_script.sieve,
+	tests/extensions/include/included/twice-1.sieve,
+	tests/extensions/include/included/twice-2.sieve,
+	tests/extensions/include/rfc-ex1-default.sieve,
+	tests/extensions/include/rfc-ex2-default.sieve,
+	tests/extensions/include/rfc.svtest,
+	tests/extensions/include/twice.svtest:
+	Include: added various tests to the testsuite.
+	[ac4fc49c6be1]
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in binary save of global variable scope.
+	[593fe13ac0c9]
+
+2009-04-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, README, TODO, src/lib-sieve/plugins/include/cmd-
+	include.c, src/lib-sieve/plugins/include/ext-include-common.c, src
+	/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c,
+	tests/extensions/include/included/once-2.sieve,
+	tests/extensions/include/included/once-3.sieve,
+	tests/extensions/include/included/once-4.sieve,
+	tests/extensions/include/once.svtest:
+	Include: implemented :once modifier for the include command.
+	[d6e436b78853]
+
+	* src/testsuite/cmd-test.c:
+	Testsuite: fixed minor result passing problem in test code
+	generation.
+	[4c416bcfd49c]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: improved runtime script handling.
+	[2fd8feba11dd]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: added runtime check for circular include.
+	[b21eb653f1dd]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed a few small indent problems.
+	[e948085b5b67]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-sieve/sieve-
+	binary-dumper.c, tests/extensions/include/included/once-1.sieve,
+	tests/extensions/include/included/once-2.sieve,
+	tests/extensions/include/once.svtest:
+	Include: added skeleton :once modifier.
+	[08f3b665caee]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: fixed bug in sub-sub include.
+	[f333ecabb7d4]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed warnings in revised plugin code.
+	[a92742e9a7c1]
+
+	* doc/man/sieve-test.1:
+	Minor update to the sieve-test manpage
+	[e400b5a9e182]
+
+	* README, src/lib-sieve/plugins/include/ext-include.c:
+	Include: updated implementation status.
+	[3717f4f237d9]
+
+	* doc/rfc/draft-daboo-sieve-include-05.txt, doc/rfc/draft-ietf-sieve-
+	include-01.txt:
+	Replaced include specification with latest draft.
+	[d8f0bdecc0e8]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-global.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/import-runtime.sieve,
+	tests/extensions/include/errors/variables-inactive.sieve,
+	tests/extensions/include/errors/variables.sieve,
+	tests/extensions/include/included/variables-included1.sieve,
+	tests/extensions/include/included/variables-included2.sieve,
+	tests/extensions/include/included/variables-included3.sieve,
+	tests/extensions/include/variables.svtest:
+	Include: replaced import/export commands with global command as
+	specified in latest draft. Import/export are now DEPRICATED.
+	[6fff255fe757]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve
+	/sieve-address-parts.c, tests/address.svtest,
+	tests/extensions/subaddress/basic.svtest:
+	Definitively fixed handling group specifications in mailbox lists of
+	address headers.
+	[914c3c1f5f8c]
+
+	* doc/man/sieve-test.1:
+	Fixed minor typo in sieve-test man page.
+	[b3ad017662d1]
+
+	* TODO:
+	Updated TODO.
+	[e89b270850c6]
+
+	* src/lib-sieve/sieve-error-private.h, src/lib-sieve/sieve-error.c,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-script.c, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools/sieve-
+	test.c:
+	Major rework of the multiscript support for better error handling.
+	[6dcfb15cf051]
+
+2009-04-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Improved plugin debug message.
+	[24847d4c5ef8]
+
+2009-04-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed problem of unexecuted before/after global scripts when user
+	script is missing.
+	[4d2503564c59]
+
+2009-04-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c:
+	Adjusted to signal handler API changes in Dovecot.
+	[b7e376b7fb07]
+
+2009-04-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve
+	/sieve-address-parts.c:
+	Fixed segfault bug caused by undisclosed-recipients:; when fed to
+	the subaddress extension.
+	[ec78123ec073]
+
+2009-03-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.4 for changeset b7eb19f14fa7
+	[38ef3a309167]
+
+	* NEWS, configure.in:
+	Released v0.1.4 for Dovecot v1.2.beta3.
+	[b7eb19f14fa7] [0.1.4]
+
+2009-03-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sieve-test.1:
+	Documented vnd.dovecot.debug in the sieve-test man page.
+	[3e4cc10a3d89]
+
+	* NEWS:
+	Updated NEWS file.
+	[9daef35779e6]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/sieve-
+	tools/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c:
+	Improved error handling and added debug extension to all applicable
+	Sieve tools.
+	[ae2f39427f14]
+
+2009-03-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Created replaceable error handler for system errors.
+	[539cfb9b9507]
+
+	* TODO, configure.in, src/sieve-tools/Makefile.am, src/sieve-
+	tools/debug/Makefile.am, src/sieve-tools/debug/cmd-debug-print.c,
+	src/sieve-tools/debug/ext-debug-common.h, src/sieve-tools/debug/ext-
+	debug.c, src/sieve-tools/debug/sieve-ext-debug.h, src/sieve-tools
+	/sieve-test.c:
+	Added Dovecot-specific debug extension to the sieve-test tool.
+	[a74dc7f32b71]
+
+	* TODO, src/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented basic filtering.
+	[8862c90bc395]
+
+2009-03-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/Makefile.am, src/testsuite/Makefile.am:
+	Removed unnecessary linker flags that break Solaris compilation.
+	[45c04b2fe529]
+
+2009-02-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/regex/ext-regex-common.h, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-address-parts.h, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h:
+	Fixed MAC OSX compile problems: forgot extern modifier at various
+	places.
+	[ab9a06342d33]
+
+2009-02-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed issue with opening relative paths as a mail file.
+	[4d642db0b754]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed tmp file name for raw storage used for sieve tools.
+	[54a07ebb8e1f]
+
+2009-02-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[7d45c1fdf9c1]
+
+	* doc/rfc/collation.rfc4790.txt, doc/rfc/i-ascii-numeric.rfc2244.txt:
+	Removed inappropriate ACAP rfc for i;ascii-numeric comparator and
+	substituted rfc4790 in stead.
+	[cebc91cd58e1]
+
+2009-02-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: developed listing messages in a folder a little
+	further.
+	[e7dd36461c67]
+
+	* .hgignore, src/sieve-tools/Makefile.am, src/sieve-tools/sieve-
+	filter.c:
+	Started work on sieve-filter tool.
+	[85230557972e]
+
+2009-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	validator.c, src/testsuite/cmd-test-message.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-smtp.c, src/testsuite/testsuite-smtp.h,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added a few final important tests for the enotify
+	extension.
+	[75b6dac1df2a]
+
+2009-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.3 for changeset 8bdff47ab3f0
+	[977e30fa18c2]
+
+	* configure.in:
+	Released v0.1.3 for Dovecot v1.2.beta1.
+	[8bdff47ab3f0] [0.1.3]
+
+2009-02-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added items to the TODO list.
+	[1c401bb66e52]
+
+	* doc/man/sievec.1:
+	Minor changes to the sievec man page.
+	[c8c404ceeb47]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-script.h:
+	Saved binary now has at most the same permissions as the script file
+	itself.
+	[3bdd01261818]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-extensions.c:
+	Fixed bug the code generation of extensions.
+	[3eb2562e40e8]
+
+	* doc/man/sieved.1, src/sieve-tools/sieved.c:
+	Added -x parameter to sieved tool.
+	[c98dafdf1f49]
+
+2009-02-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed small bug in the extension validation.
+	[15dd897287d2]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Imapflags: marked as depricated and disabled by default.
+	[95a9bb61d7ca]
+
+	* src/lib-sieve/sieve-validator.c:
+	Properly implemented verification of loaded extensions after last
+	require command is validated.
+	[cbb12efa1f1b]
+
+	* tests/extensions/variables/match.svtest:
+	Testsuite: added small test for ?* match values.
+	[2d132b56398a]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a57d7b6d95a8]
+
+2009-02-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, tests/extensions/vacation/message.svtest,
+	tests/extensions/vacation/references.svtest:
+	Testsuite: added message tests for the vacation extension.
+	[7a074a0ff5c0]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	result-reset.c, src/testsuite/ext-testsuite.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-result.h, src/testsuite/tst-test-script-run.c,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added support for resetting the result.
+	[42b3ec181e64]
+
+	* tests/extensions/enotify/mailto.svtest:
+	Testsuite: added tests for enotify with multiple recipients.
+	[c84f556f3115]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/include/cmd-import.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-
+	size.c, src/testsuite/Makefile.am, src/testsuite/cmd-test-message.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-message.c, src/testsuite/testsuite-
+	message.h, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-result.c, src/testsuite/testsuite-smtp.c, src/testsuite
+	/testsuite-smtp.h, src/testsuite/tst-test-result-execute.c,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added support for looping back outgoing SMTP messages
+	back into the test.
+	[3f857d8c403e]
+
+2009-02-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src
+	/lib-sieve/sieve-address.c, src/lib-sieve/sieve-address.h:
+	Defined very basic function for address comparison.
+	[e4283ec36db2]
+
+	* src/lib-sieve/sieve-actions.c:
+	Adjusted store action to API changes in Dovecot.
+	[d2ed402f1a5f]
+
+2009-02-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	address.c, tests/extensions/vacation/execute/action.sieve:
+	Vacation: made addresses comparison case-insensitive.
+	[b315fde89b8a]
+
+2009-02-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[cea5c68baa2e]
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c,
+	tests/extensions/imap4flags/execute/imapflags.sieve:
+	Imap4flags: fixed dumping of \flagged flag in flags side effect.
+	[a1ad7bbd3ef7]
+
+	* Makefile.am, src/lib-sieve/plugins/imap4flags/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/ext-imapflags.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-validator.c,
+	src/testsuite/testsuite.c,
+	tests/extensions/imap4flags/errors.svtest,
+	tests/extensions/imap4flags/errors/imapflags.sieve,
+	tests/extensions/imap4flags/execute/imapflags.sieve:
+	Imap4flags: added support for obsolete imapflags extension for
+	backwards compatibility with CMUSieve.
+	[4e58445b4f87]
+
+2009-02-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h:
+	Validator: added support for checking loaded extensions.
+	[ab9545a27bbf]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h:
+	Added facilities for requiring extensions and making extensions
+	mutually exclusive.
+	[37fc919d3450]
+
+	* Makefile.am, tests/extensions/imap4flags/basic.svtest,
+	tests/extensions/imap4flags/execute.svtest,
+	tests/extensions/imap4flags/execute/flags-side-effect.sieve,
+	tests/extensions/imap4flags/hasflag.svtest,
+	tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/imapflags/execute/flags-side-effect.sieve,
+	tests/extensions/imapflags/hasflag.svtest:
+	Imap4flags: gave testsuite directory proper name.
+	[f0299c1886fe]
+
+	* src/lib-sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-sieve/sieve-
+	extensions.c:
+	Imap4flags: properly named extension objects.
+	[581df7c170d1]
+
+	* src/lib-sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c:
+	Imap4flags: properly named functions.
+	[debaa7e5a036]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/cmd-flag.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c:
+	Imap4flags: properly named extension directory and source files.
+	[c8d2f78230f9]
+
+2009-02-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Fixed README: now mentions the naming differences of the imap4flags
+	and enotify extensions compared to the old CMU Sieve plugin.
+	[f33ee1af3bdb]
+
+2009-02-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c:
+	Fixed compile warning caused by missing include.
+	[c0a84cf64bbd]
+
+2009-02-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-12.txt, doc/rfc/draft-ietf-sieve-
+	notify-mailto-10.txt, doc/rfc/notify-mailto.rfc5436.txt,
+	doc/rfc/notify.rfc5435.txt, src/lib-sieve/plugins/enotify/ext-
+	enotify.c, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Installed RFC documents for notify extension and corresponding
+	mailto method.
+	[b11bd3479721]
+
+	* src/lib-sieve/mcht-matches.c, tests/match-types/matches.svtest:
+	Cleaned up :matches match-type code.
+	[ca2edcc58fba]
+
+	* src/lib-sieve/mcht-matches.c, tests/match-types/matches.svtest:
+	Fixed bug in the :matches match type.
+	[88cc4bf1c396]
+
+2009-01-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added important TODO item.
+	[42e154b8792e]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/rfc2822.c:
+	Changed SMTP message generation back to CRLF, because the Sieve
+	engine uses CRLF internally.
+	[082216ad12d6]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code.c:
+	Fixed use of data stack by binary dumping code.
+	[258e357cfbf7]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: fixed segfault bug occuring when regex is freed.
+	[6ed559a5f677]
+
+	* src/testsuite/tst-test-script-compile.c:
+	Testsuite: fixed warning.
+	[abc7331b2124]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-validator.c:
+	Increased various initial pool sizes.
+	[cdb4b96e70a8]
+
+2009-01-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Increased initial size of binary's lazy_file pool.
+	[7caaa891d5f4]
+
+	* src/lib-sieve/rfc2822.c:
+	Fixed error in the SMTP message composition that caused mixing of
+	CRLF and LF in redirected messages.
+	[2ae233b6f5ad]
+
+2009-01-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[a8e587b0409e]
+
+	* NEWS:
+	Updated NEWS file.
+	[b93c8d7802a3]
+
+	* README:
+	Updated README file.
+	[171133900f9b]
+
+	* NEWS:
+	Prepared NEWS file for next release.
+	[42ef7e546072]
+
+	* INSTALL:
+	Updated documentation.
+	[32812e4f4722]
+
+	* Makefile.am, tests/extensions/regex/match-values.svtest:
+	Testsuite: added simple tests for the match values produced by the
+	:regex match.
+	[7a91f98d0be1]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: fixed bug in the match value indexes.
+	[de6db6757418]
+
+2009-01-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-degener-sieve-multiscript-00.txt:
+	Added multiscript draft to the doc/rfc directory.
+	[fa223cfeaa35]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-message.c,
+	src/testsuite/testsuite-smtp.c, src/testsuite/testsuite-smtp.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-script-run.c:
+	Testsuite: added storage of outgoing SMTP messages.
+	[3fd7e83720fb]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-message.c,
+	src/testsuite/testsuite-message.h, src/testsuite/testsuite-
+	objects.c, src/testsuite/testsuite.c:
+	Testsuite: exported message handling to separate module.
+	[b15cfe188d87]
+
+2009-01-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h:
+	Enotify: cleaned up method API.
+	[466e57aedb29]
+
+	* tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/hasflag.svtest:
+	Testsuite: improved testsuite with respect to testing of setflag,
+	addflag and removeflag commands.
+	[18b4ee74fc9c]
+
+	* TODO, src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-flag.c, src/lib-sieve/plugins/imapflags
+	/cmd-removeflag.c, src/lib-sieve/plugins/imapflags/cmd-setflag.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h:
+	Imap4flags: merged setflag, addflag and removeflag implementations.
+	[38189d0d5785]
+
+	* INSTALL, src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Added sieve_subaddress_sep setting.
+	[fac1579a1164]
+
+2009-01-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address.c, tests/compile/errors.svtest,
+	tests/compile/errors/out-address.sieve:
+	Fixed bug in the outgoing mail address verification.
+	[60b3f236c3bc]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/duplicates.sieve:
+	Enotify/Mailto: prevented single recipient from receiving multiple
+	notifications on the same message.
+	[38b1269f8e10]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed segfault bugs in the error handling.
+	[31804bc166e3]
+
+2009-01-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Small project status update to the README.
+	[31fb740ce85c]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/duplicates.sieve:
+	Enotify: added API for detecting and killing duplicate notification
+	recipients.
+	[975614b641aa]
+
+	* TODO, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Multiscript: implemented sorting of script files in script
+	directories for Sieve plugin.
+	[c13464cb4fe3]
+
+	* INSTALL, README, TODO, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Updated documentation.
+	[17a66023e259]
+
+	* TODO:
+	Reprioritized TODO.
+	[bcbae5e0e63d]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Got array_get_pool() integrated into Dovecot.
+	[3929bef582c0]
+
+	* README, TODO:
+	Updated documentation.
+	[aec958653b9f]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed segfault in lda sieve plugin.
+	[902ee7cc9588]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify/Mailto: fixed bug in the generation of the SMTP envelope
+	sender.
+	[e124dfa5388c]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: fixed various indent mishaps in ntfy-mailto.c.
+	[f958c97ec9dc]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-tools/sieve-test.c:
+	Multiscript: added untested multiscript support to the lda sieve
+	plugin.
+	[2777abb69dd0]
+
+2009-01-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Added a few accessors to the binary object for convenience.
+	[374039e9194e]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed warning.
+	[15bc0d5d27a5]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed result handling.
+	[8d63ff17d7e8]
+
+	* TODO:
+	Removed remaining references to sieve-exec.
+	[1eca558676df]
+
+2009-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sievec.1, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-
+	tool/sieve-tool.h, src/lib-sieve/sieve-script-private.h, src/lib-
+	sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c:
+	Extended sievec command to allow compiling an entire directory.
+	[a56dfe862df4]
+
+2009-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sieved.1:
+	Minor revisions to the sieved man page.
+	[df54062cbf77]
+
+	* doc/man/sievec.1, src/sieve-tools/sievec.c:
+	Made outfile argument of the sievec command optional.
+	[b7ae0b1d7399]
+
+	* README:
+	Updated README.
+	[7cb784bf0c4c]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1, src/lib-
+	sieve/cmd-discard.c, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve.c, src/sieve-tools/Makefile.am,
+	src/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c:
+	Merged sieve-exec tool into sieve-test.
+	[030d37107e10]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c:
+	Fixed various result error messages.
+	[02697b1b4311]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed a theoretical security hole occuring when directory is opened
+	as a Sieve binary.
+	[d2a7caa5566f]
+
+2009-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/sieve-tools/sieve-test.c:
+	Updated TODO.
+	[2c64b5e5db89]
+
+	* src/lib-sieve/sieve-result.c, src/sieve-tools/sieve-test.c:
+	Multiscript: fixed small bug in result printing.
+	[0a5938f5e88c]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	tools/sieve-test.c:
+	Multiscript: improved handling of the keep action.
+	[5d251b577e56]
+
+	* TODO:
+	Updated TODO.
+	[511e2770304c]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-tools/sieve-test.c:
+	Multiscript: implemented execution of multiple scripts for the
+	sieve-test command.
+	[d20619f44dc0]
+
+2009-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Multiscript: implemented API.
+	[50f5d81b9507]
+
+	* doc/man/sieve-test.1, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src
+	/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c,
+	src/testsuite/testsuite-result.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c:
+	Multiscript: various changes to the interpreter to facilitate
+	multiscript support.
+	[1e54353fd486]
+
+2009-01-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Multiscript: added keep status evaluation to result object.
+	[70b008a20600]
+
+	* src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool/mail-raw.h, src
+	/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool/sieve-tool.h, src
+	/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-
+	keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c,
+	src/lib-sieve/cmd-stop.c, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/ext-encoded-character.c, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/mcht-contains.c, src/lib-sieve
+	/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/ext-body-common.h,
+	src/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body
+	/tst-body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-
+	cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify-limits.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/plugins/enotify/sieve-ext-enotify.h,
+	src/lib-sieve/plugins/enotify/tst-notify-method-capability.c, src
+	/lib-sieve/plugins/enotify/tst-valid-notify-method.c, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/cmd-return.c, src/lib-sieve/plugins/include/ext-include-binary.c,
+	src/lib-sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-limits.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h,
+	src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.h, src/lib-sieve/plugins/variables/ext-variables-dump.c, src
+	/lib-sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-limits.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/rfc2822.c, src
+	/lib-sieve/rfc2822.h, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-address-parts.h, src/lib-sieve/sieve-address.c, src/lib-sieve
+	/sieve-address.h, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	binary-dumper.h, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-config.h, src/lib-sieve/sieve-dump.h, src/lib-sieve/sieve-
+	error-private.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	lexer.h, src/lib-sieve/sieve-limits.c, src/lib-sieve/sieve-limits.h,
+	src/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-
+	types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h,
+	src/lib-sieve/sieve-message.c, src/lib-sieve/sieve-message.h, src
+	/lib-sieve/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-
+	sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	script-private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve
+	/tst-size.c, src/lib-sieve/tst-truefalse.c, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-sieve-plugin.h, src
+	/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c, src/testsuite/cmd-test-
+	fail.c, src/testsuite/cmd-test-result-print.c, src/testsuite/cmd-
+	test-set.c, src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-arguments.c, src/testsuite/testsuite-
+	arguments.h, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-log.c, src/testsuite
+	/testsuite-log.h, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-objects.h, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-result.h, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite-script.h, src/testsuite/testsuite-
+	substitutions.c, src/testsuite/testsuite-substitutions.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-error.c,
+	src/testsuite/tst-test-result-execute.c, src/testsuite/tst-test-
+	result.c, src/testsuite/tst-test-script-compile.c, src/testsuite
+	/tst-test-script-run.c:
+	Updated copyright messages to 2009.
+	[9e7bde020990]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve.c, src/testsuite
+	/testsuite-result.c, tests/multiscript/conflicts.svtest,
+	tests/multiscript/fileinto-frop.sieve, tests/multiscript/keep.sieve:
+	Testsuite: extended multiscript testing.
+	[fd189b1545ce]
+
+	* Makefile.am, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/testsuite/Makefile.am,
+	src/testsuite/cmd-test-result-print.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-log.c, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-result.h, src/testsuite/tst-test-result-execute.c,
+	src/testsuite/tst-test-script-compile.c, src/testsuite/tst-test-
+	script-run.c, tests/multiscript/basic.svtest,
+	tests/multiscript/conflicts.svtest, tests/multiscript/fileinto-
+	inbox.sieve, tests/multiscript/notify.sieve,
+	tests/multiscript/reject-1.sieve, tests/multiscript/reject-2.sieve,
+	tests/multiscript/vacation.sieve:
+	Testsuite: added multiscript tests and required support.
+	[55a8d5467bb7]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c:
+	Enotify: removed conflicting action flag.
+	[507b4e15de60]
+
+	* src/testsuite/testsuite-log.c, src/testsuite/testsuite-log.h,
+	src/testsuite/testsuite-script.c, src/testsuite/testsuite-script.h:
+	Testsuite: forgot to add new files.
+	[706e67f38fe1]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-result.c, src/testsuite/tst-test-error.c,
+	tests/extensions/enotify/basic.svtest:
+	Testsuite: split off script and error handler implementations into
+	separate modules.
+	[934cd4598d45]
+
+2009-01-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c:
+	Fixed warning caused by previous changes.
+	[b1878ff375d3]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-result.c:
+	Multiscript: resolved inter-script action conflict situations.
+	[cf3dacb0427f]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	result.c:
+	Cleaned up action interface.
+	[9aa51ae533c0]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/testsuite/tst-test-result.c, tests/execute/actions.svtest,
+	tests/extensions/vacation/execute.svtest:
+	Multiscript: adjusted result object for sequential execution.
+	[091473d12b22]
+
+2008-12-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[61bdad87a347]
+
+2008-12-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-result.c, src/testsuite/testsuite-
+	result.c, tests/execute/actions.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/vacation/execute.svtest:
+	Testsuite: added basic result execution tests for various
+	extensions.
+	[a3db8c51ef35]
+
+	* src/lib-sieve/sieve-result.h, src/testsuite/Makefile.am,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-result.h, src/testsuite/tst-test-result-
+	execute.c, tests/extensions/enotify/execute.svtest:
+	Testsuite: added support for executing results.
+	[7b6167bd595c]
+
+	* src/testsuite/tst-test-compile.c, src/testsuite/tst-test-execute.c,
+	src/testsuite/tst-test-script-compile.c, src/testsuite/tst-test-
+	script-run.c:
+	Testsuite: forgot committing rename in previous commit.
+	[f8e21027c484]
+
+	* src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/tst-test-result.c, tests/compile/compile.svtest,
+	tests/compile/errors.svtest, tests/compile/examples.svtest,
+	tests/execute/actions.svtest, tests/execute/errors.svtest,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/execute.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/regex/errors.svtest,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/relational/errors.svtest,
+	tests/extensions/vacation/errors.svtest,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/variables/errors.svtest, tests/testsuite.svtest:
+	Testsuite: renamed script compile and run commands to be more
+	intuitive.
+	[f52cf8c2e033]
+
+	* src/lib-sieve/sieve-code.c, src/testsuite/Makefile.am, src/testsuite
+	/ext-testsuite.c, src/testsuite/testsuite-arguments.c, src/testsuite
+	/testsuite-arguments.h, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-substitutions.c, src/testsuite/testsuite-
+	substitutions.h, tests/testsuite.svtest:
+	Testsuite: started implementing support for testsuite-specific
+	string substitutions.
+	[93c9cf02290f]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-
+	commands.c, src/lib-sieve/sieve-commands.h:
+	Exported variable string argument into the Sieve engine itself as
+	'catenated string' (for similar use in other extensions like the
+	testsuite).
+	[0b0b3ab3967f]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h:
+	Exported variable string operand into the Sieve engine itself as
+	'catenated string' (for similar use in other extensions like the
+	testsuite).
+	[75d44b76a63e]
+
+	* TODO:
+	Updated TODO.
+	[4da90917e551]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: forgot to add 'from' header to list of reserved
+	headers.
+	[504ba37c919c]
+
+	* TODO:
+	Updated TODO list.
+	[da6447787785]
+
+	* Makefile.am, TODO, configure.in, dsieve-config.h.in, src/lib-
+	sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src/lib-sieve
+	/sieve-extensions.c:
+	Enotify: added enotify extension to default compile.
+	[1a69b463d9ad]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: enforced limits on number of recipients and
+	headers.
+	[78fdf4f59ff2]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/uri-mailto.sieve:
+	Enotify: mailto: finished URI parsing.
+	[30a272720d99]
+
+2008-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: fixed various bugs introduced by previous
+	enthousiastic commit.
+	[bfc6b485e5bc]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: added check for duplicates of unique headers in the
+	mailto URI.
+	[92b60e522c1e]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: previous change did not distinguish Cc recipients.
+	[4eded3dc6a8a]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: added check for duplicate recipients within URI.
+	[453e9f5ab425]
+
+	* TODO:
+	Updated TODO.
+	[6b666e5ef348]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.c:
+	Enotify: added FIXME.
+	[ee257412d8ba]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: added runtime support for options and performed some minor
+	cleanups.
+	[08b6a2984d57]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/options.sieve:
+	Enotify: added parsing support for the :options argument.
+	[e7c9fab2e100]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed semantic bug in extension handling.
+	[e806506c8e7c]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed segfault bug in extension handling.
+	[f7666442e384]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/enotify/ntfy-
+	mailto.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h:
+	Moved new_message_id function to sieve-message.c where it is more
+	appropriate.
+	[acf8bc97e74c]
+
+	* README, src/lib-sieve/plugins/enotify/ext-enotify.c:
+	Updated documentation.
+	[b577aab39b21]
+
+2008-12-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[7de9c6687512]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/enotify/ext-enotify-
+	common.c, src/lib-sieve/plugins/enotify/ext-enotify-common.h, src
+	/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/enotify/tst-notify-method-capability.c,
+	tests/extensions/enotify/notify_method_capability.svtest,
+	tests/extensions/enotify/valid-notify-method.svtest,
+	tests/extensions/enotify/valid_notify_method.svtest:
+	Enotify: implemented notify_method_capability test.
+	[33c97930469f]
+
+	* TODO, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/tst-valid-notify-method.c, tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/uri-mailto.sieve,
+	tests/extensions/enotify/errors/uri.sieve,
+	tests/extensions/enotify/errors/url-mailto.sieve,
+	tests/extensions/enotify/errors/url.sieve, tests/extensions/enotify
+	/valid-notify-method.svtest:
+	Enotify: implemented the valid_notify_method test.
+	[c504a425e11d]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	binary-dumper.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-message.c, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-validator.c, src/testsuite/ext-
+	testsuite.c:
+	Simplified handling of extension ids.
+	[91a1ac721a68]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/regex
+	/ext-regex-common.c, src/lib-sieve/plugins/relational/ext-
+	relational-common.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-objects.c, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-objects.h:
+	Renamed extension object registry.
+	[0d7c3b514b9d]
+
+2008-12-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[6e22db2771a9]
+
+	* TODO, doc/man/sieve-test.1, doc/man/sievec.1, src/lib-sieve-tool
+	/sieve-tool.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools/sieve-
+	test.c, src/sieve-tools/sievec.c:
+	Implemented support for configuring the available extensions.
+	[fb0ba83175f5]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: changed location of X-Sieve header.
+	[0760764e19ce]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: last change used wrong address.
+	[481a04fbfa9c]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: properly implemented use of :from address argument.
+	[51b40d48e6ea]
+
+	* src/lib-sieve/sieve-address.c:
+	Fixed accidental paste in sieve-address.c.
+	[baab6e581455]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/url-mailto.sieve:
+	Enotify: added recipient verification and implemented proper To and
+	Cc header composition.
+	[05b5b209c013]
+
+	* tests/extensions/enotify/errors/from-mailto.sieve:
+	Enotify: forgot to add new file to the test suite.
+	[41cef5314a94]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/errors.svtest:
+	Enotify: implemented verification of the :from address.
+	[52ec54e6d86a]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: made log struct name shorter.
+	[595a03fe94c5]
+
+	* src/lib-sieve/rfc2822.c:
+	Fixed compiler warning about signed char.
+	[e8f9a89974cd]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: corrected mailto URI error messages.
+	[3e4bb8701786]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: cleaned up URI error handling.
+	[543b25d99edf]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h:
+	Enotify: shielded most of the method API from compiler internals.
+	[996e60017ae1]
+
+2008-12-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: added owner email to auto-submitted header.
+	[c2568b13b4c5]
+
+2008-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[4b85554381de]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Small cosmetic changes to lexer sources.
+	[304d0952005f]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: excluded body 'header' in URI from the header field
+	body verification.
+	[675dcf5550b8]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Enotify: mailto: implemented verification of (unstructured) header
+	field bodies and improved URI syntax checking.
+	[6993557e1579]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-exists.c:
+	Substituted mail_get_headers for mail_get_headers_utf8 for those
+	occasions where utf8 is of no concern.
+	[33ff0356a8d0]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/copy/ext-copy.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-result.c:
+	Improved result execution and prevented failure on store action on
+	dry run (with no specified namespace).
+	[85fbe163f73e]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: avoided sending notifications on auto-submitted messages.
+	[03ba5acfb863]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	validator.c:
+	Adapted to changes in the Dovecot API.
+	[e290c9a5b8d1]
+
+2008-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Merged concurrent changes.
+	[7c970d2e18c4]
+
+2008-12-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: added filtering of reserved headers.
+	[2dc8040cc0ca]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: changed notify message to match the latest draft
+	specification better (not yet compliant).
+	[78088c8352ee]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: now using new message composition functions.
+	[5105e03885bd]
+
+	* src/sieve-tools/sieve-exec.c:
+	Fixed message typo in sieve-exec tool.
+	[8aeef1355af5]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/rfc2822.c:
+	Reject: now using new message composition functions.
+	[2c8c7d6c51e0]
+
+	* configure.in:
+	Change to configure.in caused compile error.
+	[0285d0ef1b5a]
+
+	* configure.in:
+	Fixed bug in configure script that emitted Dovecot version in config
+	header in stead of Sieve version.
+	[33b8e83d57d0]
+
+	* src/lib-sieve/cmd-redirect.c:
+	Added X-Sieve header to redirected messages.
+	[073514b8b521]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: now using new message composition functions.
+	[46f1c431076a]
+
+	* src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Created basic internet mail message composition functionality.
+	[f6ae429a7256]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/rfc2822.c,
+	src/lib-sieve/rfc2822.h, tests/extensions/vacation/references.sieve,
+	tests/extensions/vacation/references.svtest:
+	Vacation: added support for properly updating references header.
+	[12399f096262]
+
+2008-12-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: implemented basic notify mailto: execution.
+	[71a3f5b90533]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: implemented construction and printing of action object.
+	[ae144360043a]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: implemented runtime part.
+	[84c05cf58119]
+
+2008-12-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: restructured mailto url parsing to use arrays for the
+	results.
+	[e02c5e441ca2]
+
+	* Makefile.am, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/url-mailto.sieve,
+	tests/extensions/enotify/errors/url.sieve:
+	Enotify: added verification of header field names in mailto url.
+	[9972da3b72b5]
+
+2008-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO: listed what remains to be done for the enotify
+	extension and its mailto method.
+	[b502f54d24ea]
+
+	* doc/rfc/draft-ietf-sieve-notify-mailto-09.txt, doc/rfc/draft-ietf-
+	sieve-notify-mailto-10.txt:
+	Updated enotify:mailto draft RFC.
+	[a9992d1abeb1]
+
+2008-12-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-reject.c:
+	Reject: improved message rejection log message.
+	[2758742b1a0f]
+
+2008-12-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h, src/lib-
+	sieve/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, tests/compile/warnings/invalid-headers.sieve:
+	Compiler now warns about syntactically invalid header field names.
+	[67f94b204982]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-commands.h, src/lib-sieve/tst-truefalse.c:
+	Exported true and false commands to separate file.
+	[fae455ed3f25]
+
+2008-11-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed bug in improved capability string composition.
+	[6f2f1b51ce19]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-limits.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: further developed URI parsing.
+	[e0f21b538123]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/rfc2822.c, src/lib-
+	sieve/rfc2822.h:
+	Added support for header verification.
+	[5661acb85286]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/basic.svtest:
+	Enotify: implemented coarse mailto URI parsing.
+	[f7fba9671c6b]
+
+	* doc/rfc/draft-duerst-mailto-bis-05.txt:
+	Added new draft-bis version of mailto RFC to doc/rfc.
+	[cbecc1c67646]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Activated unload handler for extensions.
+	[478f0bcdb6ff]
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/enotify
+	/ext-enotify-common.c, src/lib-sieve/plugins/enotify/ext-enotify-
+	common.h, src/lib-sieve/plugins/enotify/ext-enotify-limits.h, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/execute.svtest:
+	Enotify: implemented uri scheme verification.
+	[0572076ad26f]
+
+2008-11-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/plugins/imapflags/ext-
+	imapflags.c, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Added unload method to extension object.
+	[27b8f617ddd9]
+
+2008-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Reprioritized TODO.
+	[cbe0a7182be8]
+
+2008-11-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.2 for changeset f01fe5f1e816
+	[ec695f863a30]
+
+	* .hgtags:
+	Added tag 0.1.1 for changeset e534276ecf10
+	[f01fe5f1e816] [0.1.2]
+
+	* NEWS, configure.in:
+	Released v0.1.2 for Dovecot v1.2.alpha4.
+	[3f1ca3de6312]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: improved log message for discarded vacation response.
+	[346b7c072b0a]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed bug in the handling of context during result execution, which
+	resulted in broken redirect action.
+	[28e3144b79d1]
+
+2008-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.1.1 for Dovecot v1.2.alpha4.
+	[e534276ecf10] [0.1.1]
+
+2008-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[4dfeda80d78d]
+
+2008-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	address.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Added registry for extension capabilities like the available notify
+	methods and adjusted the enotify extension accordingly.
+	[007bb75439a8]
+
+2008-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/i-ascii-numeric.rfc2244.txt, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/rfc2244.txt:
+	Forgot to move RFC 2244 to proper place in doc/rfc.
+	[9605841f6f27]
+
+	* Makefile.am, doc/rfc/uri.rfc3986.txt, src/lib-sieve/plugins/enotify
+	/vmodf-encodeurl.c, tests/extensions/enotify/encodeurl.svtest:
+	Enotify: implemented :encodeurl variables modifier.
+	[68bae1330f0c]
+
+	* TODO:
+	Added TODO item.
+	[2ab9a8390108]
+
+	* src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool/sieve-tool.c, src
+	/lib-sieve/sieve-actions.c, src/sieve-tools/sieve-exec.c, src/sieve-
+	tools/sieve-test.c, src/testsuite/testsuite.c:
+	Adapted to changes in the mailbox_open() API.
+	[def28c3fc40c]
+
+2008-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Merged concurrent changes.
+	[0cdeefe057f7]
+
+	* doc/rfc/mailto.rfc2368.txt, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/cmd-notify.c, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c:
+	Enotify: copied action implementation from old plugin.
+	[f4a1cf59f9ce]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.c:
+	Fixed error handling of actions that send mail.
+	[eb88535b1b04]
+
+2008-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-mailto-09.txt:
+	Added notify mailto draft.
+	[c32f0e1a2ab1]
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/vmodf-encodeurl.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.c, src/lib-sieve/plugins/variables/ext-variables-common.h,
+	src/lib-sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h,
+	tests/extensions/enotify/execute.svtest:
+	Enotify: finished skeleton by addin empty :encodeurl implementation.
+	[1468452b4a29]
+
+	* Makefile.am, tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/draft-rfc-ex1.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex2.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex3.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex5.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex6.sieve:
+	Testsuite: added draft RFC examples as execution tests.
+	[45464b463539]
+
+2008-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, configure.in, src/lib-sieve/plugins/include/ext-
+	include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	common.c, src/lib-sieve/plugins/include/ext-include.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Enabled (optional) support for Valgrind in the testsuite and fixed a
+	few intricate bugs in the process.
+	[0d0571b7b81c]
+
+2008-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c:
+	Changed acquisition of usernames in sieve command line tools.
+	[4fcbcffe14c3]
+
+	* tests/header.svtest:
+	Testsuite: added test for header folding.
+	[bca59633ce16]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed bug in mail_raw implementation: mail_namespaces_deinit() must
+	not be called explicitly for v1.2.
+	[d9a73ee95b2c]
+
+2008-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Previous change did not compile.
+	[80aa797d9521]
+
+	* src/lib-sieve/sieve-actions.c:
+	Matched changes in Dovecot to properly handle/ignore the new mailbox
+	ACL support.
+	[0e7868a06c20]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Merged concurrent changes.
+	[d999e9b1f138]
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Fixed small indentation error.
+	[dbef1b96761a]
+
+2008-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-script.c:
+	Fixed bug in handling of non-existent scripts.
+	[bb9602e98abb]
+
+	* NEWS:
+	Prepared NEWS file for next release.
+	[ce33eb8c29d3]
+
+	* INSTALL, README:
+	Slightly improved documentation.
+	[e957f2fc38ef]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in import/export commands.
+	[49b0d4a70dab]
+
+2008-11-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-validator.c:
+	Imap4flags: fixed bug in the handling of the internal variable.
+
+	Previously the final value of internal variable was for every store
+	action that didn't specify a :flags argument explicitly. This
+	results in out-of order assignment/removal of flags, e.g. also the
+	flags assigned keep actions that were executed before the
+	addflag/setflag command were modified.
+	[94ad1f1aa91b]
+
+	* TODO:
+	Updated TODO.
+	[56ddfa9b2d3b]
+
+	* README:
+	Removed man page issue from README file.
+	[b9a138e1a781]
+
+	* README:
+	Updated README.
+	[f4a59b2c82b2]
+
+	* Makefile.am, doc/man/sieve-test.1:
+	Created man page for the sieve-test command.
+	[f4c64a82078b]
+
+2008-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, doc/man/sieved.1:
+	Created man page for the sieved command.
+	[837bc0ccab02]
+
+	* Makefile.am:
+	Enabled installation of man pages.
+	[6439050d232d]
+
+	* src/lib-sieve/Makefile.am:
+	Forgot to add new sieve-config.h to the distribution.
+	[9fa6336ed90c]
+
+	* doc/man/sievec.1:
+	Created (currently uninstalled) man page for the sievec command.
+	[95478625a6ce]
+
+	* Makefile.am:
+	Testsuite: fail with informative error if compiled against dovecot
+	headers only.
+	[4510184ed680]
+
+	* configure.in, src/Makefile.am:
+	Re-enabled support for compiling against Dovecot headers.
+	[36e00217bdd2]
+
+2008-11-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/tst-notify-method-capability.c:
+	Enotify: added skeleton implementation of notify_method_capability
+	test.
+	[89259cdff750]
+
+2008-11-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/tst-valid-notify-method.c, tests/extensions/enotify/basic.svtest:
+	Enotify: added skeleton implementation of valid_notify_method test.
+	[c9a597e248ab]
+
+2008-11-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, tests/extensions/enotify/basic.svtest:
+	Enotify: implemented skeleton for the notify command.
+	[a004b31bcc08]
+
+2008-11-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-extensions.c:
+	ENotify: activated empty implementation.
+	[63e099d7edf7]
+
+	* .hgignore, configure.in, dsieve-config.h.in, src/lib-
+	sieve/Makefile.am, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-config.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve.h:
+	Started using autoconf output.
+	[c5ff061ac5f4]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/sieve-actions.h:
+	Added UTF-8 to modified UTF-7 folder name conversion for
+	compatibility with IMAP.
+	[fc0395d50d04]
+
+	* .hgignore, src/sieve-tools/sieve-exec, src/sieve-tools/sieve-test,
+	src/sieve-tools/sievec, src/sieve-tools/sieved:
+	Accidentally added binaries for sieve tools.
+	[99b09b8a310a]
+
+2008-11-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-12.txt, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/cmd-notify.c, src/lib-sieve/plugins/enotify/ext-enotify-common.h,
+	src/lib-sieve/plugins/enotify/ext-enotify.c:
+	Enotify: built skeleton for the notify command.
+	[482517b70a32]
+
+	* README, TODO, configure.in, src/Makefile.am, src/lib-sieve-
+	tool/Makefile.am, src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool
+	/mail-raw.h, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool
+	/sieve-tool.h, src/lib-util/Makefile.am, src/lib-util/mail-raw.c,
+	src/lib-util/mail-raw.h, src/sieve-bin/Makefile.am, src/sieve-bin
+	/bin-common.c, src/sieve-bin/bin-common.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/sieve-bin/sievec.c, src
+	/sieve-bin/sieved.c, src/sieve-tools/Makefile.am, src/sieve-tools
+	/sieve-exec, src/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-
+	test, src/sieve-tools/sieve-test.c, src/sieve-tools/sievec, src
+	/sieve-tools/sievec.c, src/sieve-tools/sieved, src/sieve-
+	tools/sieved.c, src/testsuite/Makefile.am,
+	src/testsuite/testsuite.c:
+	Removed code duplication between testsuite and commandline tools.
+	Also restructured source code of the tools.
+	[bf8ca24d25ef]
+
+2008-10-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/namespaces.c, src/sieve-
+	bin/namespaces.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c, src/testsuite/Makefile.am, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite.c:
+	Removed now obsolete namespaces.c/h from testsuite and commandline
+	tools.
+	[937eb9e8e043]
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/namespaces.c,
+	src/testsuite/Makefile.am, src/testsuite/namespaces.c:
+	Enabled all available mail storage types (those compiled in Dovecot)
+	for the commandline tools and the testsuite.
+	[3d96a883bda0]
+
+	* configure.in, src/Makefile.am, src/lib-util/Makefile.am, src/lib-
+	util/mail-raw.c, src/lib-util/mail-raw.h, src/sieve-bin/Makefile.am,
+	src/sieve-bin/bin-common.c, src/sieve-bin/mail-raw.c, src/sieve-bin
+	/mail-raw.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/testsuite/Makefile.am, src/testsuite/mail-raw.c, src/testsuite
+	/mail-raw.h, src/testsuite/testsuite-common.c:
+	Merged mail-raw implementations of sieve commandline tools and the
+	testsuite, thus removing duplicate code.
+	[7e82c26a38bd]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/bin-common.c:
+	Made lda plugin properly refer to the main script as 'main script'
+	and not the basename of the sieve file (which is of no interest to
+	the user for the main script).
+	[bc09d2616c36]
+
+	* src/lib-sieve/sieve-script.c, src/plugins/lda-sieve/lda-sieve-
+	plugin.c:
+	Improved logging of failed script load.
+	[32c0b5cc77af]
+
+2008-10-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Now using folder name as specified by user in log messages in stead
+	of internal representation.
+	[5d6f65468c6d]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Added mail_debug messages to plugin to find problems in the sieve
+	path specification more easily.
+	[91a3f25c3df5]
+
+	* TODO:
+	Added TODO item.
+	[747107b816dc]
+
+	* src/sieve-bin/sievec.c:
+	Command sievec -d always wrote to std out.
+	[e92ec8bbd16a]
+
+	* src/sieve-bin/bin-common.c, src/testsuite/testsuite.c:
+	Fixed missing mask argument in two open calls (bug found by Sergey
+	Ivanov).
+	[8dcba4f38a67]
+
+2008-10-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in, src/lib-sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/ext-enotify.c:
+	Started development of enotify extension.
+	[85d6ef932c4f]
+
+2008-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.0 for changeset 065c12acdcc0
+	[b7d9c5e026b6]
+
+	* TODO, configure.in:
+	Released v0.1.0 for Dovecot v1.2.alpha3.
+	[065c12acdcc0] [0.1.0]
+
+	* AUTHORS, NEWS, README:
+	Minor revisions to the package documentation.
+	[9e487fec9dce]
+
+2008-10-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-types.h:
+	Fixed warning caused by mixup between mail_storage and
+	sieve_storage.
+	[aa3e90f621b1]
+
+	* src/lib-sieve/sieve-actions.c:
+	Improved execution of store action.
+	[2877fa93580c]
+
+2008-10-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Properly set storage_r in plugin function to prevent double errors.
+	[a679d84dff88]
+
+2008-10-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-result.c:
+	Prevented transaction context from becoming NULL in execution of
+	store action.
+	[2402b1499813]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed context handling bug in the result execution.
+	[a88276bff812]
+
+2008-10-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c, tests/compile/errors.svtest,
+	tests/compile/errors/typos.sieve:
+	Clarified errors occurring when colon is missing.
+	[3366b70ef4e3]
+
+	* src/lib-sieve/sieve-validator.c, tests/compile/errors.svtest:
+	Corrected error message.
+	[84dfe8d5a47a]
+
+	* README, src/lib-sieve/sieve-validator.c,
+	tests/compile/errors.svtest:
+	Clarified error messages for missing semicolon.
+	[b78529976e65]
+
+	* Makefile.am, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/body/body.sieve, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/Makefile.am, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/cmp-i-ascii-numeric.sieve, src/lib-
+	sieve/plugins/copy/Makefile.am, src/lib-
+	sieve/plugins/copy/copy.sieve, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-implicit.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/lib-sieve/plugins/vacation
+	/vacation-errors.sieve, src/lib-
+	sieve/plugins/vacation/vacation.sieve, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/variables-errors.sieve, src/lib-sieve/plugins/variables/variables-
+	match.sieve, src/lib-sieve/plugins/variables/variables-nspace.sieve,
+	src/lib-sieve/plugins/variables/variables-regex.sieve, src/lib-
+	sieve/plugins/variables/variables.sieve, src/testsuite/Makefile.am:
+	Repaired 'make dist' tarball output.
+	[28b57e7024b7]
+
+	* INSTALL, README, configure.in:
+	Revised README.
+	[dd3cdd379693]
+
+	* TODO, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-result.c, src/testsuite/testsuite-result.h,
+	src/testsuite/tst-test-error.c, src/testsuite/tst-test-result.c,
+	tests/execute/actions.svtest, tests/execute/actions/fileinto.sieve,
+	tests/execute/actions/redirect.sieve,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/vacation/execute/action.sieve:
+	Testsuite: added support for basic result checking.
+	[ff43885270f0]
+
+	* TODO, doc/rfc/RFC Controversy.txt, doc/rfc/RFC-questions.txt:
+	Reported RFC questions to the ietf-mta-filters mailinglist.
+	[c878efb32b9d]
+
+	* TODO, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/sieve-comparators.c,
+	tests/compile/errors.svtest, tests/compile/errors/unsupported.sieve:
+	Added explicit messages and tests for unsupported use of variables.
+	[6d1c5ca0d75c]
+
+2008-10-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[56dc772ca475]
+
+	* TODO, src/lib-sieve/plugins/variables/ext-variables-dump.c:
+	Fixed TODO: made sure main scope used in variables dumping is
+	unreferenced when code dumper is freed.
+	[58f57ad4f723]
+
+	* TODO:
+	Tested replacing cmusieve with sieve.
+	[3a82ec3361db]
+
+	* src/lib-sieve/sieve-binary.c:
+	Function t_str_new_const got moved to its proper place in Dovecot.
+	[7f5fc7f2e8cc]
+
+2008-10-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-
+	dumper.h:
+	Added extension support to code dumper.
+	[59f5b7074e34]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-parser.c:
+	Removed/solved minor TODOs.
+	[f16ab5f94f51]
+
+	* TODO:
+	Merged concurrent changes.
+	[d061ae363863]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables-dump.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h:
+	Variables/Include: added support for dumping variables declared in
+	extension scopes.
+	[d514f5e3a5f4]
+
+2008-10-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/sieve-error.c:
+	Fixed amd64 logging segfault; turns out using same va_args in
+	multiple vprintf calls is not possible.
+	[139edcdd3820]
+
+2008-10-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Added support for mailbox autocreate and autosubscribe.
+	[79da56ccfdc5]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve
+	/sieve-types.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite.c:
+	Made plugin use tried_default_save indicator to prevent duplicate
+	error messages.
+	[f0a7278c5645]
+
+2008-10-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[0896583c34c1]
+
+2008-09-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-code-dumper.h:
+	Variables: added identifier dump support for main scope.
+	[87841459a7ee]
+
+2008-09-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code-dumper.h:
+	Variables: added dumptime context.
+	[7cd99ac6219f]
+
+2008-09-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[f61d20c07954]
+
+2008-09-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Started NEWS file.
+	[32f5a1ed47c6]
+
+	* DESIGN, Makefile.am, doc/devel/DESIGN:
+	Moved design description to doc/devel directory.
+	[1673630bb79d]
+
+	* README, examples/elvey.sieve, examples/jerry.sieve,
+	examples/mjohnson.sieve, examples/mklose.sieve,
+	examples/relational.rfc5231.sieve, examples/rfc3028.sieve,
+	examples/sanjay.sieve, examples/sieve_examples.sieve,
+	examples/subaddress.rfc5233.sieve, examples/vacation.sieve,
+	examples/vivil.sieve, sieve/examples/elvey.sieve,
+	sieve/examples/jerry.sieve, sieve/examples/mjohnson.sieve,
+	sieve/examples/mklose.sieve,
+	sieve/examples/relational.rfc5231.sieve,
+	sieve/examples/rfc3028.sieve, sieve/examples/sanjay.sieve,
+	sieve/examples/sieve_examples.sieve,
+	sieve/examples/subaddress.rfc5233.sieve,
+	sieve/examples/vacation.sieve, sieve/examples/vivil.sieve,
+	sieve/tests/actions.sieve, sieve/tests/address-part.sieve,
+	sieve/tests/basic.sieve, sieve/tests/comparator.sieve, sieve/tests
+	/encoded-character.sieve, sieve/tests/envelope.sieve,
+	sieve/tests/extensions.sieve, sieve/tests/if.sieve, sieve/tests
+	/match-type.sieve, sieve/tests/matches.sieve,
+	sieve/tests/stop.sieve, sieve/tests/vacation.sieve,
+	tests/compile/examples.svtest:
+	Restructured Sieve example scripts.
+	[a1962f923e34]
+
+	* Makefile.am, sieve/tests/fileinto.sieve, sieve/tests/redirect.sieve,
+	tests/execute/actions.svtest, tests/execute/actions/fileinto.sieve,
+	tests/execute/actions/redirect.sieve,
+	tests/extensions/reject/execute.svtest:
+	Testsuite: added execution tests for core actions (to find
+	segfaults).
+	[a1dd8113e9d3]
+
+	* Makefile.am, sieve/tests/reject.sieve,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/reject/execute/basic.sieve:
+	Testsuite: added trivial reject action execution test.
+	[f319f06ede13]
+
+2008-09-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/address-errors.sieve, sieve/errors/address-part-
+	errors.sieve, sieve/errors/encoded-character.sieve, sieve/errors
+	/envelope-errors.sieve, sieve/errors/header-errors.sieve,
+	sieve/errors/if-errors.sieve, sieve/errors/interesting.sieve,
+	sieve/errors/keep-errors.sieve, sieve/errors/out-address-
+	errors.sieve, sieve/errors/parse-errors.sieve, sieve/errors/require-
+	errors.sieve, sieve/errors/size-errors.sieve, sieve/errors/stop-
+	errors.sieve, sieve/errors/tag-errors.sieve,
+	tests/compile/errors.svtest, tests/compile/errors/out-address.sieve,
+	tests/compile/errors/tag.sieve:
+	Testsuite: added final existing error tests.
+	[08769a713018]
+
+	* README:
+	Improved README to be more readable.
+	[e6c4a1fdfb42]
+
+2008-09-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c:
+	Removed useless PTR_OFFSET from logfile error handler
+	implementation.
+	[6f8a49489e5e]
+
+	* TODO:
+	Added pre-release TODO item.
+	[4b4ef898598d]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src
+	/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-size.c, src/testsuite
+	/testsuite-objects.c:
+	Improved argument error reporting.
+	[ad5905fa16bc]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h:
+	Restructured error reporting in validator and code generator.
+	[d54dfe15ad5f]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-
+	size.c, src/testsuite/tst-test-error.c:
+	Fixed new ia64 warnings.
+	[191eabe91f70]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed new ia64 warnings in sieve-code.
+	[bc8e86291ec7]
+
+	* src/lib-sieve/sieve-code.h:
+	Fixed new ia64 warnings in sieve-code.
+	[f655f4d28eb2]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed ia64 warnings in sieve-code.
+	[4f2b18823f75]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c:
+	Variables: fixed ia64 compiler warnings.
+	[04859d48e9f6]
+
+	* src/lib-sieve/sieve-error.c:
+	Forgot to handle return value of o_stream_send in logfile error
+	hander implementation.
+	[50f6194d644e]
+
+	* src/lib-sieve/sieve-error.c:
+	Forgot O_TRUNC in logfile error handler's second logfile open()
+	call.
+	[9f7e64968d61]
+
+	* src/lib-sieve/plugins/include/cmd-import.c:
+	Include: improved trace verbosity for import command.
+	[6618ab99e32a]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/variables/ext-variables-common.c,
+	src/lib-sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c:
+	Hopefully resolved various type cast warnings surfacing on ia_64 and
+	not on i386.
+	[0e9312deb8ea]
+
+	* tests/address.svtest:
+	Testsuite: added address test case for specific strange situation.
+	[5bc7b863ba0b]
+
+	* src/lib-sieve/plugins/relational/mcht-count.c:
+	Relational: fixed portability issue in count match type (warning).
+	[910812bf8e80]
+
+2008-09-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[11408405fac3]
+
+	* TODO, src/lib-sieve/sieve-error.c:
+	Devised simple log rotation to prevent per-user sieve processing
+	logs to grow indefinitely.
+	[9d42eeb8ce8f]
+
+2008-09-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[a589169c1870]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-modifiers.c, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/tst-string.c,
+	src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src/testsuite
+	/cmd-test-fail.c, src/testsuite/cmd-test-set.c, src/testsuite/cmd-
+	test.c, src/testsuite/testsuite-objects.c, src/testsuite/tst-test-
+	compile.c, src/testsuite/tst-test-error.c:
+	Improved byte code dumping to be more readable.
+	[758155f2aab1]
+
+	* TODO:
+	Updated TODO file.
+	[b9341f8c801e]
+
+2008-09-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README, TODO:
+	Updated documentation.
+	[6628c1731333]
+
+	* TODO:
+	Removed redundant security issue listed in TODO.
+	[05599a5b010b]
+
+	* Makefile.am, TODO, src/lib-sieve/mcht-is.c, src/lib-sieve/sieve-
+	address-parts.c, tests/address.svtest:
+	Resolved handling of invalid addresses in headers for the most part.
+	[0f3e2d8877e4]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: made sure broken/malicious binary cannot allocate
+	variable storage of arbitrary size.
+	[1ce135869da6]
+
+	* src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c:
+	Variables: added coding of variable scope.
+	[511ac1c1864e]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Added support for per-script extension intialization.
+	[8ce3c35e05d7]
+
+2008-09-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Reduced the severity of the warning indicating the experimental
+	nature of this implementation.
+	[ceea4bd93458]
+
+	* TODO:
+	Updated TODO.
+	[a200a842fd4c]
+
+2008-08-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code-dumper.c:
+	Minor cosmetic change to code dumping.
+	[75828a2293e0]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve.c, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite.c:
+	Added the concept of a script code header to list the extensions
+	actually used by a script (was using all extensions listed in the
+	binary).
+	[7be9b0d97e5f]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-ast.c, src/lib-
+	sieve/sieve-ast.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c:
+	Revised implementation of the require command.
+	[40c588255ef4]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/vacation/execute/no-handle.sieve:
+	Vacation: properly implemented handling of variables vs. handle
+	generation.
+	[93fb21f7bc6b]
+
+	* tests/extensions/imapflags/execute.svtest,
+	tests/extensions/imapflags/execute/flags-side-effect.sieve:
+	Forgot to add niet testsuite files.
+	[aae56b7f1a47]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Added support for runtime detection of variable strings.
+	[6e1f1dcabba9]
+
+	* TODO:
+	Updated TODO.
+	[7741fd1718b8]
+
+	* Makefile.am, TODO, src/lib-sieve/cmd-keep.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/tag-
+	flags.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-result.c:
+	Imapflags: properly implemented handling of duplicate store actions
+	with different :flags.
+	[3ac7e031ebd0]
+
+2008-08-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c:
+	Fixed assertion triggered at the end when redirect was executed
+	before.
+	[3ac9261ad66f]
+
+	* src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-bin
+	/sieve-exec.c, src/sieve-bin/sieve-test.c:
+	Incorporated changes in deliver into the mail-raw implementation of
+	the sieve tools.
+	[938996ab0023]
+
+2008-08-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c:
+	Imapflags: Added FIXME.
+	[fd1281ef5eef]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	result.c, src/lib-sieve/sieve-result.h, tests/execute/errors.svtest,
+	tests/execute/errors/actions-limit.sieve, tests/execute/errors
+	/redirect-limit.sieve:
+	Implemented policy limit on the maximum number of redirect actions
+	in a result.
+	[c8524a9a370f]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-limits.c, src/lib-
+	sieve/sieve-limits.h, src/lib-sieve/sieve-result.c,
+	tests/execute/errors.svtest, tests/execute/errors/actions-
+	limit.sieve:
+	Implemented limit on the number of actions active simultaneously.
+	[a62a86f489d0]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/include/errors/action-conflicts.sieve,
+	tests/extensions/include/errors/included/action-fileinto.sieve,
+	tests/extensions/include/errors/included/action-reject.sieve,
+	tests/extensions/include/errors/runtime.sieve:
+	Include: fixed a stupid bug triggered when variables are not used.
+	[48079cfe53f7]
+
+	* tests/extensions/include/errors.svtest:
+	Testsuite: activated runtime tests for the include extension.
+	[73aa79ec006a]
+
+	* Makefile.am, tests/extensions/vacation/errors.svtest,
+	tests/extensions/vacation/errors/conflict-reject.sieve:
+	Testsuite: added runtime error tests for vacation extension.
+	[d32c37e395ce]
+
+	* Makefile.am, tests/execute/errors.svtest, tests/execute/errors
+	/action-conflicts.sieve, tests/execute/errors/conflict-reject-
+	fileinto.sieve, tests/execute/errors/conflict-reject-keep.sieve,
+	tests/execute/errors/conflict-reject-redirect.sieve:
+	Testsuite: added simple runtime action conflict tests.
+	[6bef60271972]
+
+	* doc/rfc/draft-ietf-sieve-refuse-reject-07.txt:
+	Installed refuse-reject draft RFC in doc/rfc directory.
+	[c608ef17a086]
+
+2008-08-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/action-conflicts.sieve, sieve/errors/action-
+	duplicates.sieve, src/lib-sieve/sieve-interpreter.c,
+	src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-execute.c,
+	tests/execute/errors/action-conflicts.sieve, tests/execute/errors
+	/action-duplicates.sieve:
+	Testsuite: added support for testing runtime errors.
+	[e2a304290b53]
+
+	* TODO, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve
+	/sieve-ast.c, src/lib-sieve/sieve-ast.h:
+	Vacation: discovered and partially fixed various RFC-related issues.
+	[97e0e14d9557]
+
+	* doc/rfc/vacation.rfc5230.txt, src/lib-sieve/plugins/vacation/draft-
+	ietf-sieve-vacation-07.txt, src/lib-sieve/plugins/vacation/ext-
+	vacation.c:
+	Installed new RFC for vacation extension in doc/rfc directory.
+	[df13b70a2cb1]
+
+	* TODO:
+	Updated TODO.
+	[a256cbead058]
+
+	* TODO, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-set.c,
+	src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/mail-raw.c, src/testsuite/mail-raw.h,
+	src/testsuite/namespaces.c, src/testsuite/namespaces.h,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h, src/testsuite/testsuite.c, src/testsuite/tst-test-
+	compile.c, src/testsuite/tst-test-error.c:
+	Finished code cleanup for now.
+	[a458a0b55c11]
+
+	* src/sieve-bin/bin-common.c, src/sieve-bin/bin-common.h, src/sieve-
+	bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-
+	bin/namespaces.c, src/sieve-bin/namespaces.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/sieve-bin/sievec.c, src
+	/sieve-bin/sieved.c:
+	Cleaned up Sieve tools.
+	[ae09a094452c]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.h:
+	Cleaned up LDA Sieve plugin.
+	[ed1ca951fd92]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-limits.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c:
+	Cleaned up variables extension.
+	[5a4e4e269892]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: removed useless duplicate_mark call.
+	[569aaef1dd00]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c:
+	Cleaned up vacation extension.
+	[8df7a1bc6564]
+
+2008-08-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, sieve/examples/subaddress.rfc5233.sieve, tests/address-
+	parts/subaddress.svtest, tests/compile/examples.svtest,
+	tests/extensions/subaddress/basic.svtest,
+	tests/extensions/subaddress/rfc.svtest:
+	Testsuite: extended tests for the subaddress extension.
+	[7f440b626914]
+
+2008-08-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/subaddress.rfc5233.txt, src/lib-
+	sieve/plugins/subaddress/rfc3598.txt:
+	Installed new subaddress RFC in doc/rfc directory.
+	[5cb09b134086]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Cleaned up subaddress extension.
+	[ec5e1f9fda78]
+
+	* Makefile.am, sieve/examples/relational.rfc5231.sieve, tests/compile
+	/compile-examples.svtest, tests/compile/examples.svtest,
+	tests/extensions/relational/basic.svtest,
+	tests/extensions/relational/errors.svtest,
+	tests/extensions/relational/errors/validation.sieve,
+	tests/extensions/relational/rfc.svtest, tests/match-
+	types/relational.svtest:
+	Testsuite: restructured and extended tests for the relational
+	extension.
+	[17ee47e6d698]
+
+	* doc/rfc/relational.rfc5231.txt, src/lib-
+	sieve/plugins/relational/rfc3431.txt:
+	Installed new relational RFC in doc/rfc directory.
+	[6a1838d879d9]
+
+	* src/lib-sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c:
+	Cleaned up relational extension.
+	[8fa1cca640b9]
+
+	* src/lib-sieve/plugins/regex/ext-regex-common.c, src/lib-
+	sieve/plugins/regex/ext-regex-common.h, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/regex/mcht-regex.c:
+	Cleaned up regex extension.
+	[930e79a89723]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/cmd-return.c, src/lib-sieve/plugins/include/ext-include-binary.c,
+	src/lib-sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-limits.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c:
+	Cleaned up include extension.
+	[4f58be7cfde3]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c:
+	Cleaned up imapflags extension.
+	[1dc6e9c11f50]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c:
+	Cleaned up copy extension.
+	[1ae3233e93c0]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c:
+	Cleaned up comparator-i;ascii-numeric.
+	[3bc2c679843b]
+
+2008-08-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* tests/extensions/body/match-values.svtest:
+	Forgot to add test file.
+	[31efedcb72a6]
+
+	* Makefile.am:
+	Testsuite: added test for the behavior of the body test with match
+	values.
+	[76c69d75e5bd]
+
+	* src/lib-sieve/plugins/body/ext-body-common.h, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/sieve-match-types.c:
+	Body: now disables match value processing during body test
+	evaluation as required by RFC.
+	[43ed6da2c07d]
+
+	* src/lib-sieve/mcht-contains.c, src/lib-sieve/mcht-is.c, src/lib-
+	sieve/mcht-matches.c, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve-script-private.h, src/lib-sieve
+	/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-sieve/sieve-
+	types.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Finished code cleanup of the sieve library itself.
+	[7041828c5bf4]
+
+	* src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-dump.h, src/lib-
+	sieve/sieve-error-private.h, src/lib-sieve/sieve-error.c, src/lib-
+	sieve/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-limits.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h:
+	Broad code cleanup.
+	[ce2750c32d73]
+
+	* src/lib-sieve/cmd-stop.c:
+	Forgot to add new file for stop command.
+	[85e220b27364]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-if.c, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-
+	size.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-set.c,
+	src/testsuite/cmd-test.c, src/testsuite/tst-test-compile.c,
+	src/testsuite/tst-test-error.c:
+	Cleaned up commands implementation.
+	[b91b56692665]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Cleaned up sieve-code.
+	[bbee4bf32b63]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-binary-
+	dumper.h:
+	Cleaned up sieve-binary-dumper.
+	[08a3dc06bce3]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Cleaned up sieve-binary.
+	[22672ecf40c3]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h:
+	Cleaned up sieve-ast.
+	[00363cd89a2a]
+
+	* src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-address.h:
+	Cleaned up sieve-address.
+	[cb7d1b1feb8d]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Cleaned up actions implementation.
+	[af5589339bd3]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-comparators.c:
+	Cleaned up address part and comparator implementation.
+	[dfc2d1398889]
+
+	* sieve/errors/match-type-errors.sieve, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/variables/tst-string.c, src
+	/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-match-types.c,
+	src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-header.c, src/testsuite/tst-test-error.c,
+	tests/compile/errors.svtest, tests/compile/errors/match-type.sieve:
+	Cleaned up match type implementation.
+	[945375c5c915]
+
+	* TODO, src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: improvements and bugfixes.
+	[a6cf1195a291]
+
+	* Makefile.am, src/lib-sieve/plugins/regex/regex-errors.sieve,
+	tests/extensions/regex/basic.svtest,
+	tests/extensions/regex/errors.svtest,
+	tests/extensions/regex/errors/compile.sieve, tests/match-
+	types/regex.svtest:
+	Testsuite: restructured regex tests.
+	[8e7c02d55cf3]
+
+	* Makefile.am, doc/rfc/draft-murchison-sieve-regex-07.txt, src/lib-
+	sieve/plugins/regex/draft-murchison-sieve-regex-07.txt, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/sieve-match-types.c,
+	tests/extensions/variables/regex.svtest, tests/match-
+	types/regex.svtest:
+	Regex: fixed a few minor bugs.
+	[560db263607a]
+
+2008-08-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-
+	bin/namespaces.c, src/sieve-bin/namespaces.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/testsuite/mail-raw.c,
+	src/testsuite/mail-raw.h, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Compile fix for changes in Dovecot.
+	[aa1a94658613]
+
+2008-08-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/include/errors/runtime.sieve:
+	Include: implemented runtime checking of export/import.
+	[cbd74d26eff4]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include-variables.c, src
+	/lib-sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-validator.c,
+	tests/extensions/include/variables.svtest:
+	Include: transformed import and export to actual code operations for
+	runtime checking.
+	[d8002c76aabb]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: added functionality to obtain variable identifier from
+	storage using linked scope.
+	[504a89d17b2d]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h:
+	Variables: invalid variable indexes now trigger interpretation to
+	fail with EXEC_BIN_CORRUPT.
+	[7a03042a70ea]
+
+2008-08-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c:
+	Include: variable indexes are now verified to the global variable
+	scope, meaning that a corrupt binary cannot allocate arbitrary
+	global variables anymore.
+	[d8b16b132509]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Removed obsoleted runtime_load() extension event.
+	[6f0b6cbd33c6]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-match-types.c:
+	Added run() event to the interpreter_extension object.
+	[878c2ad37f27]
+
+	* TODO:
+	Cleaned up TODO file.
+	[8ca8af945cec]
+
+	* TODO, doc/rfc/RFC Controversy.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags-common.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	limits.h, src/lib-sieve/plugins/variables/ext-variables-name.c, src
+	/lib-sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/limits.sieve:
+	Variables: implemented limits on number of variables in a scope, the
+	length of variable names, size of variable values and the number of
+	accesible match values.
+	[f23512858a52]
+
+	* TODO, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/regex/mcht-
+	regex.c, src/lib-sieve/sieve-limits.h, src/lib-sieve/sieve-match-
+	types.c:
+	Limited number of accepted match values
+	[31520dab90b8]
+
+	* src/lib-sieve/plugins/include/ext-include-limits.h:
+	Include: forgot to add new file to the repository.
+	[32e7a10e0c4e]
+
+	* TODO:
+	Merged concurrent changes.
+	[9a691e80df72]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: limited the number of included scripts.
+	[f01020cfcebb]
+
+	* src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/bin-common.c:
+	LDA-Plugin: prevented plugin from polluting the logfiles when the
+	script does not exist.
+	[5d70ae722bca]
+
+2008-08-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/generic.sieve:
+	Include: used wrong messaging function in previous commit.
+	[177bf38926ca]
+
+	* src/lib-sieve/plugins/include/cmd-include.c:
+	Include: prohibited use of '/' in scriptnames.
+	[88105cf833da]
+
+2008-08-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, tests/extensions/body/basic.svtest:
+	Body: discovered various issues (listed in disabled tests).
+	[66543e00dfba]
+
+	* src/lib-sieve/sieve-message.c, src/lib-sieve/sieve-message.h,
+	src/testsuite/cmd-test-set.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-objects.c,
+	src/testsuite/testsuite-objects.h,
+	tests/extensions/body/basic.svtest:
+	Body: added test regarding empty bodies and fixed testsuite to flush
+	the message context when the message is changed.
+	[c6c5a7eb8e6e]
+
+	* src/lib-sieve/plugins/body/tst-body.c,
+	tests/extensions/body/basic.svtest:
+	Body: fixed default comparator and added testsuite test to prevent
+	this in the future.
+	[83bd74561800]
+
+	* Makefile.am, src/lib-sieve/plugins/body/ext-body-common.c, src/lib-
+	sieve/plugins/body/tst-body.c, tests/extensions/body/basic.svtest:
+	Body: fixed bug in the :raw transform, added much comment to the
+	body extraction code and added a first simple test to the testsuite.
+	[3153995e2bc7]
+
+	* src/lib-sieve/sieve-lexer.c, src/testsuite/mail-raw.c:
+	Made the lexer conform to the new Sieve RFC.
+	[0fae7796f624]
+
+	* doc/rfc/body.rfc5173.txt, src/lib-sieve/plugins/body/draft-ietf-
+	sieve-body-07.txt, src/lib-sieve/plugins/body/ext-body.c:
+	Installed RFC for the body extension in the doc/rfc directory.
+	[42dc34bb2dc2]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/imapflags/ext-imapflags-
+	common.c, src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/relational/ext-
+	relational-common.c, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h, src/lib-sieve/tst-address.c:
+	Made sure error messages do not print large erroneous values.
+	[ea459c2b87c0]
+
+	* TODO, src/lib-sieve/sieve-parser.c, tests/compile/errors.svtest,
+	tests/compile/errors/parser.sieve:
+	Limited the depth of the AST and added tests to verify that it is
+	resolved gracefully.
+	[aa4d3069f079]
+
+2008-08-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-limits.h, src/lib-sieve/sieve-parser.c,
+	tests/compile/errors.svtest, tests/compile/errors/parser.sieve:
+	Limited number of command arguments.
+	[9a2fc3c9675d]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Made lexer use the (i_*) ctype.h functions.
+	[51d06f8b3339]
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-limits.h,
+	tests/compile/errors.svtest, tests/compile/errors/lexer.sieve:
+	Limited the length of identifiers.
+	[aaca552f0561]
+
+	* TODO, src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/sieve-address.c, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-limits.h,
+	src/lib-sieve/sieve-parser.c, tests/compile/errors.svtest,
+	tests/compile/errors/lexer.sieve:
+	Enforced limits on string length and handled the finite nature of
+	integers for number parsing and the construction of the AST.
+	[317c332b2623]
+
+2008-08-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in global variables referencing the main script.
+	[b1c1779b1d4b]
+
+2008-08-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h,
+	tests/extensions/include/variables.svtest:
+	Include: symbol table for global variables now also includes
+	locations for the first import/export of each known variable.
+	[ba3785f991b9]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: included scripts are now referenced by an include_id in
+	stead of the binary block id.
+	[b67c51062eba]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-validator.c:
+	Forgot to implement free() event for validator and interpreter
+	extensions.
+	[e1f834c53a3d]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve
+	/sieve-binary-dumper.h, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-generator.c, src/testsuite/ext-testsuite.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/import-runtime.sieve,
+	tests/extensions/include/errors/variables.sieve:
+	Include: added symbol table to the binary for global variables.
+	[d9518ecfeb23]
+
+	* README, TODO:
+	Updated documentation.
+	[54897b07b2da]
+
+2008-08-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Minor TODO file revisions.
+	[472b4c6dde9e]
+
+	* Makefile.am, tests/match-types/regex.svtest:
+	Testsuite: added match values test for the :regex match
+	[35384a182b33]
+
+	* TODO, src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/regex/mcht-regex.c, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h,
+	tests/extensions/variables/match.svtest, tests/match-
+	types/matches.svtest:
+	Fixed replacing match values only when a test succeeds.
+	[dd371558d0fb]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Upgraded validator and interpreter extension support to provide
+	destruction notifications.
+	[0ec7042e1ce5]
+
+2008-08-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Include: found one issue.
+	[37f5ac342261]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/circular-1.sieve,
+	tests/extensions/include/errors/circular-2.sieve,
+	tests/extensions/include/errors/circular-3.sieve,
+	tests/extensions/include/errors/included/circular-one.sieve,
+	tests/extensions/include/errors/included/circular-three-2.sieve,
+	tests/extensions/include/errors/included/circular-three-3.sieve,
+	tests/extensions/include/errors/included/circular-three.sieve,
+	tests/extensions/include/errors/included/circular-two-2.sieve,
+	tests/extensions/include/errors/included/circular-two.sieve,
+	tests/extensions/include/included/variables-included1.sieve,
+	tests/extensions/include/included/variables-included2.sieve,
+	tests/extensions/include/included/variables-included3.sieve,
+	tests/extensions/include/variables-included1.sieve,
+	tests/extensions/include/variables-included2.sieve,
+	tests/extensions/include/variables-included3.sieve:
+	Testsuite: added circular include tests.
+	[bfa2fb869c31]
+
+	* doc/rfc/draft-daboo-sieve-include-05.txt, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/draft-daboo-sieve-include-05.txt, src/lib-sieve/plugins/include
+	/include-error.sieve, src/lib-sieve/plugins/include/include-
+	variables.sieve, src/lib-sieve/plugins/include/include-
+	variables1.sieve, src/lib-sieve/plugins/include/include-
+	variables2.sieve, src/lib-sieve/plugins/include/include-
+	variables3.sieve, src/lib-sieve/plugins/include/include.sieve, src
+	/lib-sieve/plugins/include/included1.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/generic.sieve:
+	Include: cleaned up source directory.
+	[525f4e7bd2ce]
+
+	* Makefile.am, src/lib-sieve/plugins/include/include-variables-
+	error.sieve, src/lib-sieve/plugins/include/include-variables-
+	error2.sieve, tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/variables-inactive.sieve,
+	tests/extensions/include/errors/variables.sieve:
+	Testsuite: added compile error tests for the include extension.
+	[7efaba3fb362]
+
+	* src/lib-sieve/plugins/copy/rfc3894.txt:
+	Copy: forgot to remove RFC from old location.
+	[4cd77c6931ad]
+
+	* doc/rfc/copy.rfc3894.txt:
+	Copy: moved RFC to doc/rfc directory.
+	[04dd13d1e194]
+
+	* doc/rfc/imap4flags.rfc5232.txt, src/lib-sieve/plugins/imapflags
+	/draft-ietf-sieve-imapflags-05.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c:
+	Imapflags: updated specification to RFC 5232.
+	[f1f8c50c2d7e]
+
+	* TODO:
+	Imapflags: found one new issue.
+	[9f896bff4250]
+
+	* Makefile.am, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-generator.c, tests/extensions/imapflags/hasflag.svtest,
+	tests/extensions/imapflags/rfc.svtest:
+	Imapflags: accidentally omitted support for multiple variables in
+	the hasflag test.
+	[b6602e8dd433]
+
+	* TODO, tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/set.sieve,
+	tests/extensions/variables/string.svtest:
+	Testsuite: added new tests for the variables extension.
+	[ff3d19af6da3]
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-validator.c,
+	tests/compile/trivial.sieve,
+	tests/extensions/variables/errors.svtest:
+	Fixed various case-sensitivily-related issues.
+	[8d140a08e7d8]
+
+	* Makefile.am, src/lib-sieve/plugins/variables/ext-variables-
+	arguments.c, tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/namespace.sieve,
+	tests/extensions/variables/errors/set.sieve:
+	Variables: fixed various error handling issues.
+	[eb93d4e65fce]
+
+	* src/lib-sieve/sieve-address.c:
+	Fixed a warning.
+	[5e651fda205f]
+
+2008-08-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/ext-variables.c:
+	Fixed 'make dist' to produce a working tarball.
+	[39a595dbbde4]
+
+	* src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, tests/match-
+	types/contains.svtest, tests/match-types/is.svtest, tests/match-
+	types/matches.svtest, tests/match-types/relational.svtest:
+	Testsuite: added test regarding matching the empty string and fixed
+	an issue in the i;ascii-numeric comparator.
+	[4817eca9348a]
+
+	* Makefile.am, TODO, src/lib-sieve/mcht-contains.c, src/lib-sieve
+	/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/plugins/relational
+	/mcht-count.c, src/lib-sieve/plugins/relational/mcht-value.c, src
+	/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	match-types.h, src/lib-sieve/sieve-match.c,
+	tests/extensions/variables/string.svtest:
+	Variables: fixed :count issue for the string test.
+	[fc0444f14dd1]
+
+	* TODO, tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/modifiers.svtest,
+	tests/extensions/variables/string.svtest:
+	Testsuite: added more tests for the variables extension and found
+	one issue.
+	[cd218e005c1e]
+
+	* Makefile.am, src/lib-sieve/ext-envelope.c, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/match.svtest,
+	tests/extensions/variables/modifiers.svtest, tests/match-
+	types/contains.svtest:
+	Testsuite: added RFC compliance tests for the variables extension
+	and fixed use of wrong default comparator.
+	[2246d563ad2d]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-validator.c, tests/extensions/variables/quoting.svtest:
+	Fixed bug in the order of default argument processing. Variable
+	strings were evaluated befor constant strings, which is wrong.
+	[6fa43c9bac62]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address.c,
+	tests/extensions/envelope.svtest:
+	Envelope: added more test and fixed source route parsing.
+	[568d3af73d04]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address.c,
+	tests/extensions/envelope.svtest:
+	Envelope: fixed one bug in the path parsing (printfs active).
+	[fbae4e8724ad]
+
+2008-07-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, doc/rfc/RFC Controversy.txt, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h, src/lib-sieve
+	/sieve-common.h, tests/extensions/envelope.svtest,
+	tests/testsuite.svtest:
+	Envelope: working towards proper RFC compliance of forward/return-
+	path parsing.
+	[0d6138082c33]
+
+2008-07-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed RFC compliance issue regarding failing validation
+	on unknown namespaces.
+	[336904483e84]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed bug in variables substitution (RFC example failed
+	during testing).
+	[ccbfb44d427c]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed very significant bug in the variable scope
+	implementation.
+	[225f7cfd99c0]
+
+	* src/lib-sieve/sieve-binary.h:
+	Removed superfluous include.
+	[29e9b491cadf]
+
+	* tests/extensions/variables/basic.svtest:
+	Testsuite: cleaned up basic varibles test case.
+	[b8ac459bccec]
+
+	* Makefile.am, configure.in, src/testsuite/Makefile.am,
+	src/testsuite/tests/address-parts/subaddress.svtest,
+	src/testsuite/tests/comparators/core.svtest,
+	src/testsuite/tests/compile/compile-examples.svtest,
+	src/testsuite/tests/compile/compile.svtest,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address-part.sieve,
+	src/testsuite/tests/compile/errors/address.sieve,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/compile/errors/envelope.sieve,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/compile/errors/if.sieve,
+	src/testsuite/tests/compile/errors/keep.sieve,
+	src/testsuite/tests/compile/errors/require.sieve,
+	src/testsuite/tests/compile/errors/size.sieve,
+	src/testsuite/tests/compile/errors/stop.sieve,
+	src/testsuite/tests/compile/redirect.sieve,
+	src/testsuite/tests/compile/trivial.sieve, src/testsuite/tests
+	/control-structures.svtest, src/testsuite/tests/exists.svtest,
+	src/testsuite/tests/extensions/encoded-character.svtest,
+	src/testsuite/tests/extensions/envelope.svtest,
+	src/testsuite/tests/extensions/imapflags/basic.svtest,
+	src/testsuite/tests/extensions/imapflags/rfc.svtest,
+	src/testsuite/tests/extensions/include/variables-included1.sieve,
+	src/testsuite/tests/extensions/include/variables-included2.sieve,
+	src/testsuite/tests/extensions/include/variables-included3.sieve,
+	src/testsuite/tests/extensions/include/variables.svtest,
+	src/testsuite/tests/extensions/variables/basic.svtest,
+	src/testsuite/tests/extensions/variables/match.svtest,
+	src/testsuite/tests/header.svtest, src/testsuite/tests/lexer.svtest,
+	src/testsuite/tests/match-types/contains.svtest, src/testsuite/tests
+	/match-types/is.svtest, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/tests/match-
+	types/relational.svtest, src/testsuite/tests/testsuite.svtest, tests
+	/address-parts/subaddress.svtest, tests/comparators/core.svtest,
+	tests/compile/compile-examples.svtest, tests/compile/compile.svtest,
+	tests/compile/errors.svtest, tests/compile/errors/address-
+	part.sieve, tests/compile/errors/address.sieve, tests/compile/errors
+	/encoded-character.sieve, tests/compile/errors/envelope.sieve,
+	tests/compile/errors/header.sieve, tests/compile/errors/if.sieve,
+	tests/compile/errors/keep.sieve, tests/compile/errors/require.sieve,
+	tests/compile/errors/size.sieve, tests/compile/errors/stop.sieve,
+	tests/compile/redirect.sieve, tests/compile/trivial.sieve, tests
+	/control-structures.svtest, tests/exists.svtest, tests/extensions
+	/encoded-character.svtest, tests/extensions/envelope.svtest,
+	tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/rfc.svtest, tests/extensions/include
+	/variables-included1.sieve, tests/extensions/include/variables-
+	included2.sieve, tests/extensions/include/variables-included3.sieve,
+	tests/extensions/include/variables.svtest,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/match.svtest, tests/header.svtest,
+	tests/lexer.svtest, tests/match-types/contains.svtest, tests/match-
+	types/is.svtest, tests/match-types/matches.svtest, tests/match-
+	types/relational.svtest, tests/testsuite.svtest:
+	Testsuite: moved tests directory to the root of the package.
+	[bbd0d8bab632]
+
+	* doc/rfc/variables.rfc5229.txt, src/lib-
+	sieve/plugins/variables/rfc5229.txt:
+	Installed variables rfc in the doc/rfc directory.
+	[785a600fb225]
+
+	* TODO, src/lib-sieve/ext-encoded-character.c,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/extensions/encoded-character.svtest:
+	Encoded-character: resolved error reporting issue, added some syntax
+	error tests and fixed some parsing bugs in the process.
+	[9dd5079adbbe]
+
+	* TODO, src/lib-sieve/ext-encoded-character.c,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address-part.sieve,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/compile/errors/envelope.sieve,
+	src/testsuite/tests/compile/errors/keep.sieve,
+	src/testsuite/tests/compile/errors/size.sieve,
+	src/testsuite/tests/compile/errors/stop.sieve, src/testsuite/tests
+	/control-structures.svtest:
+	Testsuite: added compile error testcases and discovered one new
+	issue.
+	[1bf8cc2f7f10]
+
+	* TODO:
+	Reprioritized TODO file.
+	[1342d7920181]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: resolved issues in the scope implementation.
+	[a3bcc26814b1]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Added proper extension support to AST object.
+	[031f0a483697]
+
+2008-07-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-
+	sieve/sieve-validator.c, src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address.sieve,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/compile/errors/if.sieve,
+	src/testsuite/tests/compile/errors/require.sieve, src/testsuite
+	/testsuite-common.c:
+	Testsuite: added a few more compile error test cases.
+	[658fa458abd4]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/testsuite/Makefile.am,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/errors.svtest, src/testsuite/tests/header-
+	errors.sieve, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite.c, src/testsuite/tst-
+	test-compile.c, src/testsuite/tst-test-error.c:
+	Testsuite: completed support for error validation and added one test
+	case.
+	[b7ae709ef86e]
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/errors.svtest, src/testsuite/tests/header-
+	errors.sieve, src/testsuite/testsuite-common.h, src/testsuite/tst-
+	test-compile.c, src/testsuite/tst-test-error.c:
+	Testsuite: started support for error validation.
+	[bef773d65f77]
+
+	* TODO, src/testsuite/Makefile.am, src/testsuite/tests/match-
+	types/contains.svtest, src/testsuite/tests/match-types/is.svtest:
+	Testsuite: marginally improved match-type tests.
+	[444696f0d147]
+
+	* src/testsuite/Makefile.am:
+	Added variables testcase to the testsuite.
+	[2030448d3cd4]
+
+	* src/lib-sieve/mcht-matches.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h,
+	src/testsuite/tests/extensions/variables/match.svtest,
+	src/testsuite/tests/lexer.svtest, src/testsuite/tests/match-
+	types/matches.svtest:
+	Fixed bugs in the :matches match type.
+	[6305d80a9f22]
+
+	* src/lib-sieve/ext-encoded-character.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/encoded-character.svtest:
+	Encoded-character: fixed a few bugs to properly match the examples
+	provided in the RFC.
+	[a320882164ec]
+
+2008-07-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/tst-header.c:
+	Added stripping of right white space from header content.
+	[9a21206c0260]
+
+	* TODO:
+	Updated TODO
+	[8ec5db20d93b]
+
+	* src/testsuite/tests/extensions/envelope.svtest:
+	Envelope: forgot to add new test case.
+	[ce3a837f69f0]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/testsuite/Makefile.am:
+	Envelope: <> return path now always matches as the empty string,
+	regardless of the specified address part.
+	[270b07d72782]
+
+	* TODO:
+	Minor TODO file change.
+	[9ba44410e26e]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/tst-address.c:
+	Forgot to adjust comment.
+	[3560a09d215a]
+
+	* doc/rfc/RFC Controversy.txt:
+	Updated documentation.
+	[20da4decbf18]
+
+	* TODO, doc/rfc/RFC Controversy.txt, sieve/errors/envelope-
+	errors.sieve, sieve/examples/elvey.sieve, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h,
+	src/lib-sieve/tst-address.c:
+	Envelope: added compile-time envelope-part verification.
+	[9a5d8cd44c16]
+
+	* doc/rfc/RFC Controversy.txt:
+	Added RFC controversy file to log all matters that require
+	clarification from RFC editors.
+	[eaa9516bda0a]
+
+	* TODO:
+	Restricted allowable headers for the address test.
+	[b7212151acde]
+
+	* TODO, sieve/errors/address-errors.sieve, src/lib-sieve/tst-
+	address.c, src/testsuite/tests/extensions/imapflags/rfc.svtest:
+	Imapflags: forgot to add testcase file.
+	[afe2b84e7719]
+
+	* src/lib-sieve/sieve-match.c:
+	Disallowed extraction of key elements from key strings for match
+	types for with that would not make sense.
+	[ba9fe4253d74]
+
+	* TODO, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src
+	/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Imapflags: resolved problem of hasflags encountering duplicate flags
+	in flag lists contained in a variable.
+	[df6023e12048]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/lib-sieve/mcht-contains.c,
+	src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/tst-
+	hasflag.c, src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-match-
+	types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c,
+	src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Imapflags: resolved string representation issue in hasflag.
+	[9261c0d19ce3]
+
+	* TODO, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-match.c,
+	src/lib-sieve/sieve-match.h, src/lib-sieve/tst-header.c,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Resolved code duplication among commands that use comparators and
+	match-types and found problems in the imapflags extension in the
+	process.
+	[662b8d662c89]
+
+2008-07-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	LDA-Sieve plugin: forgot to save the new binary when encountered a
+	corrupt one.
+	[d42d299f470b]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Improved the handling corrupt binaries further for the action
+	commands.
+	[fd1d663f3b2c]
+
+2008-07-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/Makefile.am, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/mcht-contains.c, src/lib-sieve/mcht-is.c, src/lib-sieve
+	/mcht-matches.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.h, src/lib-sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-
+	match-types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-
+	match.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c,
+	src/sieve-bin/sieve-test.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/control-structures.svtest, src/testsuite/tests
+	/match-types/relational.svtest, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Significantly improved handling of old/corrupt binaries and revised
+	matching implementation in the process.
+	[07f6bc2fe04b]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c:
+	Fixed extremely stupid bug in the i;ascii-numeric comparator.
+	[f7df94b061ec]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-interpreter.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c:
+	Implemented graceful handling of corrupt binaries by the sieve lda
+	plugin.
+	[c300bab057a2]
+
+	* configure.in:
+	Properly configured package name.
+	[dfe8a1ecad3c]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	types.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src/sieve-bin
+	/sieve-exec.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-
+	test-set.c, src/testsuite/cmd-test.c, src/testsuite/tst-test-
+	compile.c:
+	Working towards improving the handling of currupt binaries: defined
+	multiple exit codes for execution functions and defined trace macro
+	for reporting binary corruptions.
+	[10c30a4bd44a]
+
+	* TODO, src/testsuite/tests/extensions/include/variables-
+	included1.sieve, src/testsuite/tests/extensions/include/variables-
+	included2.sieve, src/testsuite/tests/extensions/include/variables-
+	included3.sieve,
+	src/testsuite/tests/extensions/include/variables.svtest:
+	Testsuite: forgot to add test cases for include extension.
+	[e3542907a783]
+
+	* TODO, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-sieve
+	/sieve-script.c, src/lib-sieve/sieve-script.h,
+	src/testsuite/Makefile.am, src/testsuite/testsuite.c:
+	Fixed code emission for extension-defined variables and removed
+	hardcoded paths from include extension.
+	[c3dfcab426ca]
+
+	* TODO:
+	Added future TODO item.
+	[defad0db1bb4]
+
+	* TODO, src/lib-sieve/sieve-interpreter.h:
+	Updated TODO and removed spurious FIXME.
+	[477722eeaf09]
+
+	* README, src/testsuite/ext-testsuite.c:
+	Updated documentation.
+	[89e50989541a]
+
+	* .hgignore, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/tests/compile/compile-
+	examples.svtest, src/testsuite/tests/compile/compile.svtest,
+	src/testsuite/tests/compile/redirect.sieve,
+	src/testsuite/tests/compile/trivial.sieve, src/testsuite/testsuite-
+	common.h, src/testsuite/tst-test-compile.c:
+	Testsuite: added test_compile command to test compilation of
+	scripts.
+	[e6846fc1dc11]
+
+2008-07-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, sieve/errors/out-address-errors.sieve, src/lib-sieve/sieve-
+	address.c, src/lib-sieve/sieve-binary.c:
+	Revised Sieve address validation functionality.
+	[10abb0055a23]
+
+	* README, TODO, configure.in, src/lib-sieve/sieve-binary.c:
+	Started using new str_new_const() function.
+	[3fc4deedc23b]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/imapflags
+	/cmd-addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c,
+	src/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	result.c, src/lib-sieve/sieve-result.h:
+	Imapflags: improved handling of invalid flags.
+	[4d45ccdd880b]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	validator.c:
+	Significantly improved pool allocation by checking --enable-debug
+	warnings from dovecot.
+	[4a5f60764e5f]
+
+	* src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-validator.c:
+	Removed all legacy use of array_create().
+	[f4bb043dc649]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Lexer: fixed repetitive string alloation problem.
+	[14dd750dfeb8]
+
+2008-07-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed bug introduced by previous change.
+	[e4db63d3e106]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/variables/cmd-
+	set.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-common.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-match-types.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-objects.c:
+	Reworked operand and operation binary coding functions.
+	[a8f9c4a6c502]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.h, src/lib-sieve/plugins/variables/ext-variables-
+	operands.c, src/lib-sieve/plugins/variables/sieve-ext-variables.h,
+	src/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	address-parts.h, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src
+	/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve
+	/tst-size.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-
+	set.c, src/testsuite/cmd-test.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Fully substituted the use of extension ids with the use of the
+	extension object itself.
+	[0da758d61cad]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-validator.c, src/testsuite/ext-testsuite.c:
+	Made initially assigned extension id available directly from the
+	const extension object itself.
+	[3e237d753a2a]
+
+	* TODO, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Reworked previous change into three elegant macros.
+	[416c6954b998]
+
+2008-07-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-script.c, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made utility functions for neatly handing system errors, warnings
+	and notices.
+	[8a116201d954]
+
+	* src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c,
+	src/testsuite/tests/control-structures.svtest:
+	Testsuite: added tests for use of allof/anyof with a single test and
+	optimized code generation.
+	[971a8a94e8ab]
+
+	* TODO, src/testsuite/tests/header.svtest, src/testsuite/tests/match-
+	types/contains.svtest:
+	Testsuite: added test case for the header test and found one issue.
+	[447d40a17ea0]
+
+	* src/lib-sieve/sieve-lexer.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/lexer.svtest:
+	Testsuite: added lexer string scan comparison test and fixed lexer
+	bug in the process.
+	[1bab36c85b54]
+
+2008-07-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/testsuite/tests/control-structures.svtest:
+	Testsuite: added some control structure tests involving nesting.
+	[46a2df6cafe4]
+
+	* TODO, src/lib-sieve/tst-exists.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/exists.svtest, src/testsuite/testsuite-
+	objects.c:
+	Testsuite: added tests for 'exists' test and fixed a semantic error
+	in the 'exists' test.
+	[ce5660cb5dbf]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address-
+	parts.c, src/testsuite/tests/testsuite.svtest, src/testsuite
+	/testsuite-objects.c:
+	Testsuite: tested handling of teststuite envelope environment and
+	fixed bugs in the envelope test in the process.
+	[ff0f9c67a106]
+
+	* src/testsuite/Makefile.am, src/testsuite/tests/address-
+	parts/subaddress.svtest, src/testsuite/testsuite-common.c:
+	Testsuite: added test case for subadress extension.
+	[21061d5f3422]
+
+	* Makefile.am, TODO, configure.in, src/Makefile.am,
+	src/testsuite/Makefile.am, src/testsuite/tests/testsuite.svtest,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	Coupled testsuite to 'make test'.
+	[36ab72963cd1]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/cmd-if.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-encoded-character.c,
+	src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c:
+	Cleaned up test and core extension implementations.
+	[5df6769ad854]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c:
+	Cleaned up command implementations.
+	[837769563332]
+
+	* src/lib-sieve/sieve-script-private.h, src/lib-sieve/sieve-script.c:
+	Fixed handling of script files that are in fact symbolic links.
+	[fd9003533d28]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed bug in binary created without a corresponding script object.
+	[9560bfd8e2e5]
+
+	* TODO, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src
+	/lib-sieve/sieve-error.h, src/lib-sieve/sieve-script.c:
+	Reversed stat() and open() on two occasions to make retrieved stat
+	information guaranteed to be valid for the opened file and added
+	error handling for various close() system calls.
+	[b04c29c4ac90]
+
+	* TODO:
+	Updated TODO list.
+	[bab521877ded]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c:
+	Removed various unnecessary includes of <ctype.h> and replaced yey
+	another toupper() with its i_* equivalent.
+	[2e1963c29390]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/variables/ext-variables-name.c:
+	Removed direct use of isdigit, isalpha and isalnum and replaced
+	these with their dovecot i_* equivalents to prevent problems on some
+	systems.
+	[732c5001ccb5]
+
+	* TODO:
+	Updated TODO.
+	[47c0a9d219b6]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.h, src/lib-sieve/plugins/variables/ext-variables.c, src
+	/lib-sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/variables-match.sieve,
+	src/testsuite/tests/extensions/variables/basic.svtest:
+	Variables: made set modifiers descendants of the sieve object too.
+	[6c31299662d8]
+
+2008-07-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-objects.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Testsuite: made testsuite objects a descendant from sieve objects.
+	[12a346d25711]
+
+	* TODO, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h:
+	Removed remaining code duplication among comparators, match types
+	and address parts.
+	[1654a241fa56]
+
+	* TODO:
+	Updated TODO list.
+	[8292d75ce253]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.h,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-
+	sieve/sieve-comparators.h, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/sieve-objects.c, src/lib-sieve/sieve-objects.h:
+	Made side effects sieve objects too.
+	[81b6c6a65f86]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/mcht-contains.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/regex/ext-regex-common.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational-common.c, src/lib-sieve/plugins/relational/mcht-
+	count.c, src/lib-sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h, src/lib-sieve/sieve-objects.c, src/lib-
+	sieve/sieve-objects.h:
+	Introduced the concept of a sieve object to merge the coding of
+	comparators, match types, address parts and other objects that might
+	need to be represented in byte code (removes lots of code
+	duplication).
+	[344eaae8693c]
+
+2008-07-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/cmp-i-octet.c, src/lib-sieve/mcht-contains.c,
+	src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-sieve/plugins/regex/ext-
+	regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Revised extension support for match-types.
+	[a6bf1b1c8a2b]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-comparators.h:
+	Cleaned up comparator implementation.
+	[8976941d215c]
+
+	* TODO, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/testsuite/tests/comparators/core.svtest:
+	Revised extension support for comparators.
+	[29676b9e16c2]
+
+2008-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-comparators.c:
+	Fixed stupid bug in the match-type context validation.
+	[e67e5024a970]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-lexer.c,
+	src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve-script-private.h, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-types.h, src/lib-sieve/sieve.h:
+	Made error reporting cleaner by avoiding the scriptname of the main
+	script and indicating that the printed numbers are in fact source
+	code lines.
+	[2c5ae7a67d28]
+
+	* src/lib-sieve/sieve-validator.h:
+	Fixed warnings caused by remaining spurious inline definitions in
+	sieve-validator.h
+	[bfc24ba04381]
+
+2008-07-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-
+	sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c:
+	Code cleanup: parser, lexer, lda-plugin and main interface.
+	[d5ca488d55b7]
+
+	* TODO:
+	Updated TODO.
+	[c44e8d20b130]
+
+2008-07-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL:
+	Update INSTALL file.
+	[c0acf033f79d]
+
+	* README, TODO:
+	Updated documentation.
+	[3f2415b96676]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h:
+	Made runtime errors for action conflicts more user-friendly by
+	adding sourcecode line numbers.
+	[5dfc5676bd6f]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/tst-body.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/tst-
+	string.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-generator.c, src
+	/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c, src/testsuite/cmd-
+	test-fail.c, src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/testsuite-objects.c:
+	Cleaned up generator code and added emission of source line
+	positions for all actions.
+	[d60e232af73e]
+
+2008-07-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, sieve/tests/stop.sieve, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-parser.c:
+	Resolved various small issues.
+	[dd844326cd20]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin
+	/sieve-test.c, src/testsuite/testsuite.c:
+	Removed last significant printf()s from library code.
+	[663bb4cf98d8]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-encoded-character.c, src/lib-sieve/plugins/copy/ext-
+	copy.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h, src/lib-sieve
+	/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-
+	result.c:
+	Added address normalization to prevent redirect action duplicates.
+	[41e894bd5adb]
+
+	* src/lib-sieve/sieve-actions.c:
+	Made "INBOX" folder name case-insensitive.
+	[ad20dac29faf]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-reject.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/imapflags/imapflags-implicit.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-common.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/sieve-test.c,
+	src/testsuite/testsuite.c:
+	Built result print functions thus removing various printf()s.
+	[ab0569f04717]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve
+	/sieve-result.c, src/sieve-bin/sieve-exec.c:
+	Removed various printf()s.
+	[8b83101ed51a]
+
+	* README, TODO, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-result.c:
+	Implemented support for side-effects to implicit keep and finished
+	the imapflags extension.
+	[c0b959cfdf01]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Previous change in extension interface for implicit side effect
+	support broke include extension.
+	[4cb32478d80d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body-common.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/plugins/variables/ext-variables.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-common.h, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-message.c,
+	src/lib-sieve/sieve-message.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h:
+	Added support for implicit side effects and adjusted imapflags
+	extension accordingly.
+	[f55d47d1daee]
+
+2008-07-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Imapflags: flags are stored for explicit actions.
+	[9fa69efd67d1]
+
+2008-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c:
+	Imapflags: cleaned up some debug messages and fixed triggered
+	assertion.
+	[ebdd1e5333ca]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c:
+	Forgot a few trace macros.
+	[4f32214d959c]
+
+	* TODO:
+	Updated TODO list.
+	[9d16b8207a91]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed typos in some error messages.
+	[584e2516320d]
+
+	* sieve/errors/out-address-errors.sieve, src/lib-sieve/Makefile.am,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	address.h, src/lib-sieve/sieve-validator-address.c, src/lib-sieve
+	/sieve-validator.h:
+	Improved address validation significantly.
+	[3d2a4f000814]
+
+	* src/testsuite/tests/control-structures.svtest, src/testsuite/tests
+	/match-types/contains.svtest:
+	Added two simple test cases.
+	[8354f6045c96]
+
+	* src/lib-sieve/sieve-commands.c:
+	Forgot trace macro for the stop command.
+	[2affc8a239aa]
+
+	* TODO:
+	Removed llist TODO item, turns out to be less mergeable than
+	initially thought.
+	[e324d382f62b]
+
+2008-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/tests/match-types/matches.svtest:
+	Testsuite: extended :matches tests.
+	[3cc1f848aa72]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c,
+	src/lib-sieve/tst-size.c, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Introduced trace macro for runtime tracing and improved testsuite
+	implementation.
+	[d4206ad35724]
+
+	* src/lib-sieve/mcht-matches.c, src/testsuite/mail-raw.c,
+	src/testsuite/tests/match-types/matches.svtest:
+	Testsuite: fixed CRLF bug in reading a script-specified mail
+	message.
+	[65bedbabab62]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/tst-header.c, src/testsuite/tests/match-types/matches.svtest:
+	Fixed bugs in :matches implementation.
+	[ded9f063bb3b]
+
+2008-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-generator.c, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/tests/testsuite.sieve,
+	src/testsuite/tests/testsuite.svtest:
+	Added testcase to the testsuite.
+	[901e88d94ef2]
+
+	* README, src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables.c:
+	Updated documentation.
+	[fe8d65b77b9d]
+
+	* TODO:
+	Updated TODO.
+	[e591cfdaaab9]
+
+	* TODO, src/lib-sieve/sieve-error-private.h, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-parser.c,
+	src/lib-sieve/sieve-validator.c, src/plugins/lda-sieve/lda-sieve-
+	plugin.c, src/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c,
+	src/sieve-bin/sieve-test.c, src/testsuite/testsuite.c:
+	Added support for limits on the maximum number of errors collected
+	during compilation.
+	[16066e307609]
+
+	* README, TODO:
+	Updated documentation.
+	[4282b0a65c30]
+
+	* sieve/errors/out-address-errors.sieve, src/lib-sieve/Makefile.am,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-validator-address.c, src/lib-sieve
+	/sieve-validator.h:
+	Added compile-time address validation.
+	[d977d476923d]
+
+	* doc/rfc/imail.rfc2822.txt:
+	Added IMAIL rfc.
+	[252d826d42e3]
+
+	* doc/rfc/draft-ietf-sieve-3028bis-13.txt, doc/rfc/rfc3028.txt,
+	doc/rfc/rfc3629.txt, doc/rfc/sieve.rfc5228.txt,
+	doc/rfc/utf-8.rfc3629.txt:
+	Updated doc/rfc directory.
+	[c045f8d8aaf8]
+
+	* README, TODO:
+	Updated documentation.
+	[85aee022d63b]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/plugins/imapflags/tag-
+	flags.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-extensions-private.h:
+	Imapflags: finished for implicit flag attachment to fileinto and
+	keep commands.
+	[b9d8f9649bde]
+
+2008-06-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/copy/ext-
+	copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src
+	/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-size.c, src/testsuite/testsuite-
+	objects.c:
+	Added the concept of persistent tags and implemented imapflags
+	extension for bare keep and fileinto commands (intermittent commit,
+	not working properly yet).
+	[b941171d7557]
+
+2008-06-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Imapflags: added execution support for variables.
+	[3115627a9c60]
+
+	* src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/ext-variables-
+	operands.h, src/lib-sieve/plugins/variables/sieve-ext-variables.h,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Imapflags: added validation and code support for variables.
+	[eebce2c24704]
+
+2008-06-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/vacation/vacation.sieve, src/lib-sieve
+	/sieve-validator.c:
+	Fixed bug in duplicate argument detection.
+	[9a8045ad9897]
+
+	* src/lib-sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c:
+	Vacation: exported command implementation to separate file.
+	[c0d69bd47692]
+
+	* src/lib-sieve/sieve-binary.c, src/sieve-bin/sieved.c:
+	Fixed bug in sieved.
+	[0cf9a6ab85d6]
+
+	* INSTALL, README, configure.in, src/sieve-bin/Makefile.am:
+	Minor compile and documentation changes.
+	[5d55a9fb061d]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made lda sieve plugin save and load binaries.
+	[98a4a28d48d3]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-generator.c,
+	src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-lexer.c, src
+	/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve-result.h, src/lib-sieve/sieve-script.c, src/lib-sieve
+	/sieve-script.h, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/sieve-bin/sievec.c, src/testsuite/cmd-test.c, src/testsuite
+	/testsuite-common.c:
+	Resolved all outstanding warnings.
+	[61acd01fe9df]
+
+	* DESIGN, INSTALL, Makefile.am, README, TODO, src/lib-
+	sieve/Makefile.am, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/Makefile.am, src/lib-
+	sieve/plugins/copy/Makefile.am, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/ext-imapflags-common.c, src/lib-sieve/plugins/include/Makefile.am,
+	src/lib-sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am:
+	Updated documentation and fixed 'make dist'.
+	[65c7b117ff36]
+
+2008-05-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h,
+	src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h:
+	Testsuite: added test_fail command.
+	[063d37ff4c79]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/tst-allof.c, src/lib-sieve
+	/tst-anyof.c, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	set.c, src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.h, src/testsuite/testsuite-objects.c:
+	Testsuite: added 'test' command to group sieve statements into a
+	test.
+	[3cc05036846c]
+
+2008-05-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/cmd-test-set.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h, src/testsuite/testsuite-
+	objects.c, src/testsuite/testsuite-objects.h:
+	Testsuite: added support for test object members.
+	[62f783ff9f22]
+
+2008-05-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-set.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Testsuite: exported testsuit object interface to separate files.
+	[e26637dce509]
+
+	* src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-extensions-
+	private.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	message.c, src/testsuite/cmd-test-set.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/tests/testsuite.sieve, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-common.h:
+	Testsuite: implemented testsuite object interface.
+	[3e39d288a27f]
+
+2008-05-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/vacation/vacation-errors.sieve:
+	vacation: added TODO regarding duplicate tagged arguments to the
+	vacation command.
+	[62ced79fac8a]
+
+	* .hgignore, src/testsuite/testsuite:
+	testsuite: removed spurious binary from repository.
+	[058401bf5f8a]
+
+	* configure.in, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	message.c, src/testsuite/mail-raw.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	Testsuite: setting message content works.
+	[93b3a300c389]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-extensions-private.h, src/lib-sieve
+	/sieve-extensions.c, src/testsuite/cmd-test-message.c, src/testsuite
+	/ext-testsuite.c, src/testsuite/testsuite,
+	src/testsuite/testsuite.c:
+	Fixed execution of initial testsuite implementation.
+	[c1455741740d]
+
+2008-05-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	binary-dumper.c, src/lib-sieve/sieve-binary-dumper.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-match-types.c,
+	src/testsuite/testsuite:
+	Properly implemented dumping a binary including a list of required
+	extensions and support for extension-specific output.
+	[49041cf55a5c]
+
+2008-05-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgignore, src/Makefile.am, src/lib-sieve/Makefile.am, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/body/ext-body.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/imapflags.sieve,
+	src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-binary-
+	dumper.c, src/lib-sieve/sieve-binary-dumper.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code-dumper.h, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-common.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-dump.h, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/tst-header.c, src/testsuite/Makefile.am, src/testsuite
+	/cmd-test-message.c, src/testsuite/ext-testsuite.c, src/testsuite
+	/mail-raw.c, src/testsuite/mail-raw.h, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/tests/testsuite.sieve,
+	src/testsuite/testsuite, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	RECOVERED FROM INCONSISTENCY: developed testsuite and binary dumping
+	and fixed various small issues.
+	[5173404351c7]
+
+2008-04-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[e80c85bfd227]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/include-variables.sieve, src/lib-
+	sieve/plugins/include/include-variables1.sieve, src/lib-
+	sieve/plugins/include/include-variables2.sieve, src/lib-
+	sieve/plugins/include/include-variables3.sieve, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	operands.c, src/lib-sieve/plugins/variables/ext-variables.c, src
+	/lib-sieve/plugins/variables/sieve-ext-variables.h:
+	Include: merged import and export commands into a single
+	implementation and implemented global variable storage.
+	[2071bd319715]
+
+	* README, src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Variables: exported new operand definitions to separate file.
+	[1515291be1fe]
+
+2008-04-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Variables: exported new argument definitions to separate file.
+	[889cea0db5b6]
+
+	* src/lib-sieve/plugins/include/cmd-export.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/include/ext-include-variables.h:
+	Include: implemented global variable scope.
+	[5cce69ab4eb4]
+
+2008-04-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/sieve-bin/sieve-test.c:
+	Added -c option to sieve-test to force compile.
+	[5c2eeabbafbe]
+
+2008-03-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Updated documentation.
+	[157a94a31c54]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-binary.h,
+	src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/include-variables1.sieve, src/lib-
+	sieve/plugins/include/include-variables2.sieve:
+	Include: moved variables support to separate file.
+	[9a997c6e97d0]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	binary.h, src/lib-sieve/plugins/include/ext-include-common.c, src
+	/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c:
+	Include: moved implementation of binary extension to separate file.
+	[29877e0201ea]
+
+	* src/lib-sieve/plugins/include/cmd-export.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include-variables-error2.sieve, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Include: added AST context and now export context detectects export
+	of imported variables.
+	[7e2750e9e64b]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/include-error.sieve, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Include: moved script existance validation back to validation stage.
+	[f179c5640bed]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/include-variables-
+	error.sieve, src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Include: made import and export commands check whether the variables
+	extension is active.
+	[b1e85659979f]
+
+2008-03-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/include
+	/include-variables.sieve, src/lib-sieve/plugins/include/include-
+	variables1.sieve, src/lib-sieve/plugins/include/include-
+	variables2.sieve, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-script.c:
+	Include: added skeleton import and export commands.
+	[c3f48302b86a]
+
+	* README:
+	Updated TODO.
+	[404001bc4009]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/variables-regex.sieve, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h:
+	Regex: added match values support.
+	[5dfb64a0f93b]
+
+	* src/lib-sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c:
+	Relational: split match-type implementation into separate file.
+	[c3887aa30660]
+
+	* src/lib-sieve/plugins/regex/Makefile.am, src/lib-sieve/plugins/regex
+	/ext-regex-common.h, src/lib-sieve/plugins/regex/ext-regex.c, src
+	/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: split match type implementation into separate file.
+	[6de0ef9ce851]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/mcht-contains.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/body/ext-body-common.c, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-match-types.h:
+	Exported match type implementations to separate files.
+	[9c87314c8c6e]
+
+2008-03-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c:
+	Finished :matches function for now, but it can still be improved and
+	it needs more testing.
+	[dce3ebd372de]
+
+2008-03-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Revised :matches function, but did finish.
+	[361d7952dcc3]
+
+2008-03-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c:
+	Variables: fixed bug in match value indexing.
+	[eb6b7af13024]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/body/tst-body.c,
+	src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables-match.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c:
+	Variables: First work towards match value support.
+	[39ae5f637374]
+
+2008-02-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/variables/ext-variables.c:
+	Updated documentation.
+	[b01fae741c62]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/variables-errors.sieve:
+	Variables: added variable name parsing to the set command and added
+	error handling.
+	[636f16de84ad]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/variables-nspace.sieve:
+	Variables: exported namespace+variable parsing to separate file.
+	[1eb6468cbb57]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c:
+	Variables: exported namespace+variable parsing to separate function.
+	[324762d634a0]
+
+	* README:
+	Updated documentation.
+	[2d7d8b3882d6]
+
+2008-02-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.c:
+	Variables: added parsing support for namespaces.
+	[be3b8bac2c3b]
+
+	* src/lib-sieve/plugins/variables/tst-string.c:
+	Variables: fixed string test.
+	[6b07d2c2aecf]
+
+2008-02-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Expand ~ to home in sieve path.
+	[5a26dbbd6b04]
+
+2008-02-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed indent in sieve-banary.c
+	[b3ad65e8017e]
+
+	* src/lib-sieve/sieve-script.c:
+	Simplified needlessly complex assignment.
+	[71baeea1b4c2]
+
+	* README:
+	Added TODO item.
+	[5e891151c11d]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-
+	comparators.c:
+	Avoid direct to_lower() invocations; replaced by i_tolower().
+	[4a4da0b36b73]
+
+	* README:
+	Updated documentation.
+	[23fddcb3bff4]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-match-types.c:
+	Changed various p_new(pool_datastack_create(),) invocations to
+	t_new()
+	[4a350bcb98fb]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Envelope: changed p_array_init(,pool_datastack_create(),) into
+	t_array_init(,)
+	[d2659865968c]
+
+	* README:
+	Updated documentation.
+	[8854635f2819]
+
+2008-02-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-code.c:
+	Variables: fixed bug in string-list containing variables.
+	[bda964bee9f5]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-
+	commands.c:
+	Fixed bugs in string substitution support and the regex extension.
+	[2c93a6f1f120]
+
+	* src/lib-sieve/plugins/variables/draft-ietf-sieve-variables-08.txt,
+	src/lib-sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/rfc5229.txt:
+	Variables: updated included specification to new RFC 5229.
+	[970977365e61]
+
+	* README:
+	Updated documentation.
+	[8223da28978b]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: made variable identifiers case insensitive.
+	[22ba1d548f77]
+
+2008-02-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/variables-errors.sieve:
+	Variables: added check for equal precedence and added comment.
+	[78ac4b9fd4b7]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated 'quotewildcard' set modifier and fixed a bug.
+	[f5cc923c0cf8]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated 'length' set modifier.
+	[571ff4050c4e]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated support for set command modifiers.
+	[9c3840cc68f6]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Adjusted body extension to compile with dovecot past 1.1.beta16
+	(message parser changes)
+	[854549e5e6d9]
+
+2008-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* AUTHORS:
+	Added notice about the omission CMU code to the AUTHORS file.
+	[e10b34c008dd]
+
+	* .hgignore, configure.in:
+	Assigned proper package version and name.
+	[19fa7bfb0623]
+
+	* .hgignore, COPYING:
+	Removed duplicate licence.
+	[be7aad6c814d]
+
+	* Makefile.am:
+	Added maintainermode functions to Makefile.am
+	[fdf2ea8d11d3]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/sieve-address-parts.c, src/lib-
+	sieve/sieve-ast.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Incorporated changes in dovecot-1.1
+	[c8c67641d0dc]
+
+2008-02-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: set modifiers are now sorted.
+	[5ceb8e6709ef]
+
+2008-02-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Added code support for set modifiers.
+	[edba29e3d158]
+
+2008-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/tst-
+	string.c, src/lib-sieve/plugins/variables/variables.sieve, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Fixed bugs in validation error handling and fixed bugs in dynamic
+	argument support.
+	[207f7dea843e]
+
+2008-01-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-validator.c:
+	First successful variable substitutions.
+	[beaacb4d8406]
+
+	* Merged concurrent changes.
+	[8e8f0012b6c1]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-comparators.c, src/lib-
+	sieve/sieve-comparators.h, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-
+	sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Changed operand read API to get access to the runtime environment
+	inside the read functions.
+	[be351797c032]
+
+2008-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/interesting.sieve, src/lib-sieve/sieve-parser.c:
+	Minor fix in the error reporting of the sieve parser.
+	[d403335a9351]
+
+	* src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h,
+	src/lib-sieve/sieve.c:
+	Implemented dynamic sieve_get_capabilities() for proper MANAGESIEVE
+	support.
+	[5ecaa79ab879]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Published compiler API using script objects instead of paths.
+	[16d8c8b63bcc]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed segfault occuring when command did not exist.
+	[31182d66d254]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-script.c:
+	Small changes: removed T_FRAME and improved an error message.
+	[dac13553f2fa]
+
+2008-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/include/ext-
+	include-common.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	error-private.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-script-
+	private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src
+	/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c, src/sieve-bin
+	/sieve-test.c:
+	Implemented required features for use with MANAGESIEVE service.
+	[41d479d33f26]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Added strbuf error handler.
+	[57118bf13efc]
+
+2007-12-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-match-types.c:
+	Added variable operand to the variables extension.
+	[cd89ce24b255]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.h, src
+	/lib-sieve/sieve-match-types.c:
+	Added support for adding new types operands to the engine.
+	[6f5eadd0e4c8]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Defined variable argument for the variables extension.
+	[b0552c08b279]
+
+2007-12-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-generator.c, src
+	/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h:
+	Changed validation and generation of string list argument to fully
+	support the new string list encoding.
+	[f65dd8431ae8]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-binary.c, src
+	/lib-sieve/sieve-code.c:
+	Changed encoding of stringlist. Now it contains string operands in
+	stead of bare strings.
+	[7bac41b7e6c1]
+
+	* src/lib-sieve/sieve-extensions-private.h:
+	Removed obsolete code.
+	[9aeb0333b0d7]
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/ext-body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-
+	cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-extensions-private.h, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-validator.c:
+	Removed much code duplication between extensions that provide
+	support for further extension.
+	[3009bde82cd7]
+
+2007-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions-private.h, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Further migrated implementation of extensions to new extension
+	architecture.
+	[4ac0b9e8635c]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-
+	encoded-character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/copy/copy.sieve, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.h, src/lib-sieve/plugins/variables/ext-
+	variables.c, src/lib-sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	extensions-private.h, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-validator.c, src/lib-
+	sieve/sieve.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Major changes in the extensions support.
+	[8b74028295fd]
+
+2007-12-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h:
+	Changed implementation of command context handling and instanced
+	tags to avoid duplicate lookups.
+	[74d12bfed7c8]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables.c,
+	src/lib-sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Further developed the variables extension.
+	[492938049fc1]
+
+2007-12-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/draft-ietf-sieve-variables-08.txt, src/lib-sieve/plugins/variables
+	/ext-variables.c, src/lib-sieve/plugins/variables/variables.sieve,
+	src/lib-sieve/sieve-extensions.c:
+	Started skeleton implementation of variables extension.
+	[cac5b0cdb8e6]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/ext-encoded-
+	character.c:
+	Fixed non-standard behavior for the encoded-character extension.
+	[6900d4693821]
+
+	* README, sieve/errors/encoded-character.sieve, sieve/tests/encoded-
+	character.sieve, src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/sieve-bin
+	/mail-raw.c:
+	Finished encoded-character extension.
+	[dd6a814d5350]
+
+	* doc/rfc/rfc3629.txt:
+	Added UTF-8 rfc to doc/rfc directory.
+	[772db2c40fd1]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/sieve-validator.c:
+	Built a little more extensive tests for the encoded-character
+	extension.
+	[f6cba45b3299]
+
+2007-12-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/cmd-redirect.c,
+	src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Encoded character extension basicly works, but no unicode support is
+	implemented.
+	[0c62d3501b83]
+
+2007-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/cmd-require.c, src/lib-sieve/ext-
+	encoded-character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src
+	/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve
+	/tst-not.c, src/lib-sieve/tst-size.c:
+	Implemented support for overriding default argument implementations
+	of number, string and string-list.
+	[811636f212aa]
+
+2007-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-3028bis-13.txt, doc/rfc/rfc3028.txt:
+	Added sieve rfc and new sieve 3028bis to the doc/rfc directory.
+	[cf0d3511810b]
+
+	* doc/rfc:
+	Removed erroneous rfc file from new doc dir.
+	[50462444b677]
+
+	* doc/rfc, sieve/tests/encoded-character.sieve, src/lib-sieve/ext-
+	encoded-character.c:
+	Forgot to add new files.
+	[ec01147fbf36]
+
+	* README:
+	Updated documentation.
+	[d870f0bb6228]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-extensions.c:
+	Started skeleton for the encoded-character extension.
+	[915854a9a6e7]
+
+	* README:
+	Updated TODO list.
+	[c4f08e56f98f]
+
+	* README, src/lib-sieve/plugins/body/ext-body.c:
+	Updated documentation.
+	[7853b0fd8c2f]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c:
+	Changed imapflags extension to use the message context instead of
+	the interpreter context.
+	[73f99ee08abb]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Changed body extension to use the message context instead of the
+	interpreter context.
+	[c769d7261264]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Introduced message context to give extensions the ability to
+	associate context data with the currently processed message.
+	[08a085d3c1b9]
+
+	* README, src/lib-sieve/plugins/body/ext-body.c:
+	Updated documentation.
+	[d47f4b7439d2]
+
+	* src/lib-sieve/plugins/body/body.sieve, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/tst-body.c:
+	Fixed minor bug in the body extension.
+	[c8ea2fb589cc]
+
+	* AUTHORS, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/body/body.sieve, src/lib-sieve/plugins/body/ext-body-
+	common.c, src/lib-sieve/plugins/body/ext-body-common.h, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h, src/lib-sieve/tst-header.c:
+	Implemented evaluation for the body test introduced by the body
+	extension.
+	[7dc23ed0c79f]
+
+	* src/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h:
+	Implemented validation and code generation for body extension.
+	[24a83b8759f7]
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/body/Makefile.am,
+	src/lib-sieve/plugins/body/draft-ietf-sieve-body-07.txt, src/lib-
+	sieve/plugins/body/ext-body.c:
+	Started skeleton for the body extension.
+	[87141cd62e03]
+
+	* README, src/lib-sieve/plugins/include/ext-include.c:
+	Updated documentation.
+	[ebdc3d4b1ebb]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/cmd-return.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/included2.sieve, src/lib-
+	sieve/sieve-binary.c:
+	Implemented return command for include extension.
+	[2ecc3c3f89cf]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-error.c:
+	Basic include functionality seems to be working and if source
+	scripts are changed the binary is always recompiled.
+	[4d87cc13eb79]
+
+2007-12-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-script.h, src/lib-sieve/sieve.c:
+	Working towards proper dependency handling for sieve binaries.
+	[7055341a175d]
+
+	* src/lib-sieve/sieve-binary.c:
+	Added support for lazy binary load.
+	[443f611ba331]
+
+2007-12-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-sieve/sieve-
+	binary.c:
+	Added internal support for different methods of loading a binary.
+	[06efb6d54463]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve.c, src/sieve-
+	bin/sieved.c:
+	Working towards complete binary support for the include extension.
+	[1f60d0e233a2]
+
+2007-12-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[cd70b1e8764f]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-interpreter.c:
+	Fixed bug regarding stop command in combination with include
+	extension.
+	[84c480ec5cd3]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Simplified the include loop a little.
+	[e930ac1deb4e]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h:
+	Implemented mostly untested deep-level include execution support.
+	[c88db860a282]
+
+2007-12-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve.c:
+	First successful (single level) execution of four consecutive
+	includes.
+	[5f1564b65675]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h:
+	Added support for interrupting an interpreter and continuing
+	execution later.
+	[1af35588edfc]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c:
+	Include extension now generates include opcode. Not executable yet
+	though.
+	[ac8496b3d19c]
+
+	* src/lib-sieve/sieve-binary.c:
+	Implemented the binary_free event for binary extensions. Script
+	references in the include extension are now properly released.
+	[d0a0bbdaf6b0]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-common.h:
+	Fixed behavior of binary object with respect to pre-loaded
+	extensons. Broke it with last change.
+	[ce0e32e63adc]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h:
+	Changed binary object's extension linkage for extending the binary
+	itself.
+	[5633827bd892]
+
+2007-12-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-script.c,
+	src/lib-sieve/sieve-script.h:
+	Doubly included scripts are no longer compiled and included multiple
+	times.
+	[64ffbd9afaaa]
+
+	* src/lib-sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-
+	binary.c:
+	Forgot to set the number of blocks in the binary header.
+	[69967868a8cc]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included1.sieve:
+	Re-established circular include detection for include extension.
+	[e8867e044d2c]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h,
+	src/lib-sieve/sieve.c:
+	Further developed the include extension to compile included scripts
+	in additional blocks of the binary.
+	[6d0b5b112f00]
+
+2007-12-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-
+	sieve/sieve.c:
+	Further developed the binary format: binary can now contain multiple
+	blocks with arbitrary data.
+	[958ac41805fc]
+
+	* README:
+	Updated documentation: Changed priorities in TODO list.
+	[c27f92353192]
+
+	* README:
+	Updated documentation.
+	[b1b5f7d6ff6c]
+
+2007-12-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary.c, src/lib-
+	sieve/sieve-binary.h, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-script.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/sieve-bin/sieved.c:
+	Moved actual include operation from validator to generator stage.
+	[c49356652255]
+
+	* .hgignore, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	script.c, src/lib-sieve/sieve-script.h, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/sieve-bin/sievec.c:
+	Sieve executables now work with binaries too.
+	[8e7a1b3c0ad9]
+
+	* .hgignore, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-script.c, src/sieve-
+	bin/Makefile.am, src/sieve-bin/sievec.c, src/sieve-bin/sieved.c:
+	Made a basic implementation of saving binaries to disk.
+	[60a7a53897cf]
+
+2007-12-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-parser.c, src/lib-
+	sieve/sieve.c:
+	Cleaned up ast implementation a little.
+	[82fb78a39773]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve.c:
+	Prevented more scripts from being included when errors have occured.
+	[fade5794fecf]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve-lexer.c,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c:
+	Properly implemented circular include detection for the include
+	extension.
+	[d3b8e1347bb5]
+
+	* src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/sieve-common.h, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	lexer.h, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h:
+	First defined an encapsulating script object and implemented part of
+	the include extension.
+	[20278c7b7254]
+
+2007-12-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/draft-daboo-sieve-include-05.txt, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-sieve/sieve-
+	extensions.c:
+	Started skeleton implementation for the include extension.
+	[fae946e07bd2]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Updated documentation.
+	[3ffe74253949]
+
+2007-12-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/plugins/vacation/ext-
+	vacation.c:
+	Added :addresses support to the vacation extension.
+	[22045e56dec8]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-exists.c, src/lib-sieve/tst-header.c:
+	Added support for reading an entire stringlist into memory. Also
+	fixed various identical bugs in stringlist-related error handling.
+	[a2ae74cddb58]
+
+	* README:
+	Added two TODO items.
+	[5b3f80ba5fa5]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Tiny update to documentation and removed a compiler warning.
+	[57bef612b360]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	generator.c:
+	Added :mime support to vacation extension.
+	[e0170e8422a7]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Renamed mail_environment to script_env.
+	[357df85b1c14]
+
+	* README, src/lib-sieve/cmd-redirect.c:
+	Added mail-loop detection to the redirect action.
+	[5208c9de6da9]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins
+	/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-exec.c:
+	Changed execution error handling a little.
+	[9bedd7aaed60]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-
+	validator.c:
+	Adopted code to use Dovecot's new T_FRAME* macros.
+	[7d056b0525a8]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	code-dumper.h, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	validator.h:
+	Added proper ATTR_FORMAT to all functions that accept a string
+	format and fixed one bug in the process.
+	[ed5bbe4892fe]
+
+	* README:
+	Further updated documentation and cleaned up the README file.
+	[34dd6d80f884]
+
+	* INSTALL, README:
+	Updated documentation. We are gettin closer to a first release.
+	[ba0d6c952726]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-result.c, src/sieve-bin/bin-common.c, src/sieve-bin
+	/sieve-exec.c:
+	Implemented implicit keep to execute when not canceled or when the
+	preceeding action execution fails.
+	[83139c099737]
+
+2007-12-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-interpreter.c:
+	Fixed minor bugs in the error reporting.
+	[3cf617a5c19b]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed tiny bug in the error reporting in the lda-sieve plugin.
+	[dd6d34c328e0]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Further developed the error handling.
+	[b440e2ecb968]
+
+2007-12-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Added a little more error logging to the lda-sieve plugin.
+	[22100a6b83a0]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Implemented logfile error handler and assigned it to the lda-sieve
+	plugin.
+	[1dd0d188e90d]
+
+2007-12-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-parser.c,
+	src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/bin-common.c, src/sieve-
+	bin/sievec.c:
+	Further developed error handling.
+	[38b7c79a1bc9]
+
+2007-12-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Forgot to initialize sieve library in lda-sieve plugin. It has now
+	successfully delivered its first message.
+	[0bb383b96a44]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.h:
+	Fixed misnamed module entry points for the lda-sieve plugin.
+	[b8b366a08231]
+
+	* configure.in, src/Makefile.am, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/plugins/lda-sieve/Makefile.am, src/plugins/lda-
+	sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-sieve-plugin.h,
+	src/sieve-bin/bin-common.c:
+	Included sieve plugin into the build process.
+	[0eee6014369f]
+
+	* README, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sievec.c:
+	Documentation updates.
+	[f48f95ebfcad]
+
+	* src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/sieve-bin/sievec.c:
+	Implemented sieve test binaries further. They now have proper
+	command line arguments.
+	[c1e500086b9c]
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/bin-common.c, src/sieve-bin
+	/bin-common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c, src/sieve-bin/sievec.c:
+	Updated and cleaned-up the sieve test binaries.
+	[9ed2f2979c35]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tag-flags.c, src
+	/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src
+	/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c, src/sieve-
+	bin/sievec.c:
+	Properly implemented the code dumper. Dumps are now printed in a
+	stream. The individual opcode and operand implementations no longer
+	use printf()s.
+	[b68f9e45a6bd]
+
+	* src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-
+	dumper.h:
+	Forgot to add new files.
+	[3a75f9a2a4ac]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-interpreter.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, src/lib-sieve/tst-size.c:
+	Exported sieve-code-dumper from sieve-interpreter containing all
+	code dumping related implementation. Now to remove all printfs....
+	[ca3bfa6b2284]
+
+2007-12-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed bug in handling optional operands to opcodes that have no
+	mandatory operands (0 is no longer a valid opcode)
+	[77e421643cc2]
+
+	* sieve/errors/action-conflicts.sieve, sieve/errors/action-
+	duplicates.sieve, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-
+	keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c,
+	src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-
+	vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added conflict and duplicate checking to vacation and reject
+	actions.
+	[c33bb67f8b09]
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve.h, src/sieve-
+	bin/sieve-exec.c, src/sieve-bin/sieve-test.c:
+	Implemented actions reject and vacation.
+	[d34c2fe9ac63]
+
+	* src/lib-sieve/ext-envelope.c:
+	Fixed minor bug in envelope extension.
+	[e39957361fed]
+
+2007-11-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve-validator.c:
+	Further developed imapflags extension and added proper logging
+	functions to the result object.
+	[bc668e541c89]
+
+2007-11-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.h,
+	src/lib-sieve/sieve-interpreter.c:
+	The :flags tag introduced by the imapflags extension now attaches
+	side-effects to the appropriate action commands.
+	[b3f4220296e2]
+
+	* README, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-result.c:
+	Properly implemented handling of the implicit keep flag and fully
+	implemented the copy extension.
+	[24896ebd3e8d]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added basic execution support to copy extension. Not completely
+	functional yet.
+	[8ad6e3739a65]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code.c:
+	Added support for reading side effect operands.
+	[04e8fa76e983]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c:
+	Added registration of side-effect extension into binary.
+	[98c1c9798c08]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h:
+	Defined side-effect object for the copy extension.
+	[f22e0d5b9788]
+
+	* src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/tst-header.c:
+	Incorporated the signedness of the id_code in the optional_read
+	functions as well
+	[2923c10f41b9]
+
+2007-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/tst-size.c:
+	Changed id_code for optional operands to signed and fixed a
+	ext_my_id-related error in the vacation and copy extensions.
+	[38a9854e21ca]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-extensions.c:
+	Added operand emission support for action side effects.
+	[8b9ba3e6a631]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h:
+	Created pre-loaded action side effects 'extension'.
+	[37a2969e9787]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-match-types.c:
+	Removed part of the code duplication between address-part, match-
+	type and comparator implementations.
+	[34b4be8738f2]
+
+	* src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added untested support for side effects to result object.
+	[ec22e9a0a06d]
+
+2007-11-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c, src/lib-sieve/plugins/imapflags/imapflags.sieve,
+	src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-result.c:
+	Added :flags tag to the imapflags extension and fixed bug in the
+	result execution.
+	[e4ccc420bbc8]
+
+	* README:
+	Updated documentation.
+	[0b63e817f6b6]
+
+	* src/lib-sieve/plugins/copy/copy.sieve, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Added support for externally adding tags to (possibly not yet
+	registered) command. The copy extension now adds such a tag to
+	fileinto and redirect.
+	[9ad768a6d2b9]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/copy/Makefile.am,
+	src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/copy/rfc3894.txt, src/lib-sieve/sieve-extensions.c,
+	src/sieve-bin/sieve-exec.c:
+	Added skeleton for the copy extension.
+	[f4d0e3674a8c]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c:
+	Minor changes
+	[da31c25af3df]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c, src/sieve-
+	bin/sieve-exec.c:
+	Store action seems to work properly now.
+	[eec88e2b625d]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c, src/lib-
+	sieve/sieve-actions.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/Makefile.am, src/sieve-bin/mail-raw.c,
+	src/sieve-bin/mail-raw.h, src/sieve-bin/namespaces.c, src/sieve-
+	bin/namespaces.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Almost finished implementing the store action. But, I still get
+	strange errors when the mail transaction commits. Mail is stored
+	though.
+	[246c88fea246]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-result.c:
+	Turned action execution into a transaction.
+	[d9a51d8e6d16]
+
+	* README, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added (not yet active) handling of implicit keep and adjusted
+	commands accordingly.
+	[d8eaf00dd960]
+
+	* README:
+	Added TODO item.
+	[2e2cbe36ac1d]
+
+2007-11-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Added inbox location to mail environment and made keep command use
+	it to generate its store action.
+	[1fabb5b3de8f]
+
+	* README, src/lib-sieve/ext-fileinto.c:
+	Updated documentation.
+	[b77f5ae48116]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/Makefile.am, src/lib-sieve
+	/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h:
+	Fileinto command now produces a store action which is now produced
+	by the keep command as well.
+	[b59ff97b1b4b]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-keep.c:
+	Made discard command add discard action to the result.
+	[d00c1ecbe750]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-keep.c, src/lib-sieve/sieve-commands.c:
+	Exported discard command to its own separate file.
+	[8bedc7e9f17e]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added support for detecting action conflicts.
+	[37fcab36395a]
+
+	* README:
+	Updated documentation.
+	[eb3c1925ac1f]
+
+	* sieve/tests/redirect.sieve, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h:
+	Added support for avoiding duplicate actions in the sieve result.
+	[7fa2aeb9a269]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c:
+	Made keep command add keep action to the result.
+	[b4ac2186369d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/sieve-commands-private.h, src/lib-sieve/sieve-commands.c:
+	Exported keep command to its own separate file.
+	[a061b79e6eb1]
+
+2007-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c, src/sieve-
+	bin/sieve-test.c:
+	Minor changes to the executables.
+	[1c349f5cf532]
+
+	* README, src/lib-sieve/sieve-interpreter.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c:
+	Added mail-file parameter to the sieve-test and sieve-exec binaries.
+	[38ff5f7794ad]
+
+	* .hgignore, sieve/tests/redirect.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	bin/Makefile.am, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src
+	/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c, src/sieve-
+	bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Cleaned up implementation of sieve test binaries and added sieve-
+	exec
+	[ab2fd12a0195]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Removed spurious debug message.
+	[5b53dd17b678]
+
+2007-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/Makefile.am, src/sieve-
+	bin/sieve_test.c:
+	Added first action execution support. Redirect is the first command
+	to actually work.
+	[3ea3f400caa9]
+
+	* README:
+	Added TODO item.
+	[312bfe51f644]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Moved address-part, match-type and comparator code registries from
+	interpreter to binary where they belong.
+	[17fe832ec983]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-interpreter.c:
+	Added extension context storage support to the sieve binary.
+	[bf61316d9b84]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/comparator-i-ascii-numeric
+	/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-match-types.c:
+	Added binary_load event to the sieve extensions.
+	[abc3d97f3cfe]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h,
+	src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h,
+	src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-match-types.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve.c, src/lib-sieve/tst-address.c,
+	src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-
+	sieve/tst-size.c:
+	Grouped runtime parameters into a single runtime environment and
+	started implementation of result composition/execution.
+	[7c800bfa74cc]
+
+	* src/lib-sieve/sieve-interpreter.c:
+	Changed interpreter in the event of an unimplemented opcode.
+	[91fd90402931]
+
+	* README, src/lib-sieve/plugins/imapflags/ext-imapflags.c:
+	Updated documentation.
+	[9dd4fe921d74]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c:
+	Implemented hasflag command interpretation for the imapflags
+	extension.
+	[30917ef6965c]
+
+2007-11-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/tst-size.c:
+	Added actual flag management to the imapflags extension. Addflag,
+	removeflag and setflag now do what they should do.
+	[610b5f638c33]
+
+	* README, src/lib-sieve/cmd-if.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c:
+	Finished i;ascii-numeric comparator and fixed a segfault bug in the
+	process.
+	[8cd504cc2e3a]
+
+	* README, src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/tst-header.c:
+	Added hasflag test to the imapflags extension.
+	[cc5f85570a9a]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h:
+	Implemented code generation and interpretation for the commands
+	introduced by the imapflags extension.
+	[f0c34dee6ae7]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-match-types.c,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-
+	sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Upgraded opcode extension support to handle more than one opcode per
+	extension.
+	[2a2d82471e77]
+
+2007-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve:
+	imapflags: Added (dummy) check for the existance of the variables
+	extension.
+	[9d97ea5c52c6]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-sieve/sieve-
+	validator.c:
+	Implemented validation for the commands introduced by the imapflags
+	extension.
+	[82e86518dfc9]
+
+	* src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	validator.c:
+	Created skeletons for the commands introduced by the imapflags
+	extension.
+	[c0471778290f]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/draft-ietf-sieve-imapflags-05.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c:
+	Started skeleton for the imapflags extension.
+	[6ea6b7699606]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/sieve-bin/Makefile.am:
+	Cleaned up make process and included the 'plugins' into the main
+	sieve library archive.
+	[b669519df1b5]
+
+	* README, src/lib-sieve/sieve-commands.c:
+	Updated documentation.
+	[ab270d1accc1]
+
+	* sieve/examples/vivil.sieve, sieve/tests/stop.sieve, src/lib-sieve
+	/cmd-if.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h:
+	Removed unecessary jump after commands like stop.
+	[a487f6447efa]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/sieve-match-types.c:
+	Debugged :matches match type and no more bugs are currently known.
+	[acdcd1d8f031]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c:
+	Made first buggy implementation of :matches match type.
+	[d3756743700b]
+
+2007-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation with respect to extensions.
+	[cd8b13651e87]
+
+	* sieve/tests/reject.sieve, src/lib-sieve/ext-reject.c:
+	Added dummy execution support to reject extension.
+	[29620589f088]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Updated documentation.
+	[3dcfafbef34d]
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/plugins/vacation/ext-
+	vacation.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Implemented dummy execution for vacation extension.
+	[ef682330f822]
+
+	* src/lib-sieve/ext-envelope.c:
+	Resolved compiler warning in envelope extension.
+	[7e2d6e8893dc]
+
+	* sieve/tests/redirect.sieve:
+	Added test script for redirect command.
+	[30ec001eaee2]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h:
+	Properly implemented stop command and associated opcode.
+	[cb2ac2578b83]
+
+	* src/sieve-bin/sieve_test.c:
+	Added status message to sieve_test to indicate successful script
+	run.
+	[64e0b6403468]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.h:
+	Created dummy interpretation support for the redirect command.
+	[382920e5c5ae]
+
+	* sieve/tests/fileinto.sieve, src/lib-sieve/ext-fileinto.c:
+	Created dummy interpretation support for the fileinto extension.
+	[c410f5746af3]
+
+	* src/lib-sieve/ext-envelope.c:
+	Removed debug lines in envelope extension.
+	[0d144c5c6726]
+
+	* src/lib-sieve/ext-envelope.c:
+	Made ext_envelope_get_fields cleaner.
+	[962e5ed2a7b0]
+
+	* README, src/lib-sieve/ext-envelope.c:
+	Updated documentation.
+	[c05059b64271]
+
+	* sieve/tests/envelope.sieve, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-parts.h,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/sieve-
+	bin/sieve_test.c:
+	Made basic execution implementation of the envelope extension.
+	[6bf04ad6e814]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-common.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c,
+	src/lib-sieve/tst-size.c, src/sieve-bin/sieve_test.c:
+	Added envelope data to the interpreter environment.
+	[b9cf89b005f2]
+
+	* README, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c:
+	Completed implementation of the relational extension.
+	[7dd971306703]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-match-types.h:
+	Improved match handling and started implementing the interpretation
+	of the relational match type.
+	[158169910d95]
+
+2007-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/match-type-errors.sieve, sieve/tests/match-type.sieve,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-match-types.c:
+	Implemented context validation for :contains match type.
+	[6f1dcac24c57]
+
+	* README, src/lib-sieve/plugins/regex/ext-regex.c:
+	Updated documentation with respect to regex externsion and match-
+	type support.
+	[37fd899b7dca]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Last commit broke execution of match types other than
+	:regex...fixed.
+	[f9e2b975f5eb]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/sieve-address-parts.c, src/lib-
+	sieve/sieve-address-parts.h, src/lib-sieve/sieve-common.h, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Implemented regex match execution.
+	[114ec23016dd]
+
+	* sieve/examples/sanjay.sieve:
+	Fixed missing require in sanjay.sieve example
+	[81baf031527e]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c:
+	Forgot to handle stringlists in :regex validation.
+	[4e082129513a]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/regex/ext-
+	regex.c, src/lib-sieve/plugins/regex/regex-errors.sieve, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Implemented :regex match validation.
+	[fefebffac65f]
+
+	* sieve/errors/address-part-errors.sieve,
+	sieve/errors/interesting.sieve, sieve/errors/match-type-
+	errors.sieve, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-validator.c:
+	Implemented detection of duplicate optional arguments.
+	[9add85be3ddd]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/regex-errors.sieve, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-
+	sieve/sieve-validator.c:
+	Made regex match complaint about comparators other than i;octet or i
+	;ascii-casemap
+	[ebf35c004764]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Added support for match-type argument context validation.
+	[9db6e7335e9e]
+
+	* src/lib-sieve/sieve-validator.c:
+	Added support for argument context validation.
+	[7dcaf16bcf7d]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/tst-size.c:
+	Added validat_context method to command arguments for the to-be-
+	implemented argument context validation.
+	[754320bac6bb]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-match-types.c:
+	Changed argument generator function prototype to assign
+	responsibility of advancing to the next argument to the generator
+	itself.
+	[6ba97a809b25]
+
+	* src/lib-sieve/sieve-commands.c:
+	Removed i_unreached() at inappropriate location.
+	[80a6ca8aa099]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-validator.c:
+	Removed code duplication in validator: merged command and test
+	validation in one function.
+	[55047d9405c9]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed bug in the command validation.
+	[0f7c34ca82a9]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-require.c, src/lib-sieve
+	/sieve-commands.h:
+	Improved validation of command placement for if and require
+	commands.
+	[7666f12ccc2a]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve
+	/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-commands-
+	private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-allof.c,
+	src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve
+	/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c:
+	Changed validator's command syntax validation such that command
+	implementations don't have to call the argument, test and block
+	validation functions explicitly.
+	[e43df7ab9749]
+
+2007-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve
+	/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.h,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h, src/lib-sieve/tst-address.c, src/lib-
+	sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src
+	/lib-sieve/tst-size.c:
+	Changed argument validation to record the first positional argument
+	into the command context by default. Also furter improved
+	validator's error handling.
+	[d357da9effa4]
+
+	* sieve/errors/address-errors.sieve, sieve/errors/header-errors.sieve,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/subaddress/subaddress.sieve,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve
+	/tst-header.c, src/lib-sieve/tst-size.c:
+	Revised positional argument checking and fixed the validator's error
+	handling.
+	[31ade1ddf884]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Prevent unimplemented match type from causing a segfault.
+	[614e7a053e31]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-interpreter.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-header.c:
+	Implemented match type execution and activated match types :is and
+	:contains.
+	[44f7b3f89e34]
+
+2007-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c:
+	Minor updates to the documentation.
+	[033d7cb3a8dd]
+
+	* src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Fixed code generation for relational extension.
+	[9aedfec64626]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Implemented support for additional parameters to match-types and
+	implemented validation for the relational extension.
+	[c49afa847933]
+
+	* configure.in, sieve/tests/match-type.sieve, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/regex/Makefile.am,
+	src/lib-sieve/plugins/regex/draft-murchison-sieve-regex-07.txt, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/relational/rfc3431.txt, src/lib-sieve/sieve-
+	extensions.c, src/sieve-bin/Makefile.am:
+	Created skeletons for regex and relational extensions. These are to
+	be developed simultaneously with the match-type support in general.
+	[f3db84e346eb]
+
+	* README, sieve/tests/match-type.sieve, src/lib-sieve/Makefile.am, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-
+	sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Started implementation of match-type support and fixed compilation
+	error.
+	[b352686b0063]
+
+	* README, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/sieve-comparators.c:
+	Updated README and a few minor cosmetic changes to the code.
+	[8eddb5ec9ddb]
+
+	* configure.in, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/Makefile.am, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/cmp-i-ascii-numeric.sieve, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/comparator-i-ascii-numeric/rfc2244.txt, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-header.c, src/sieve-
+	bin/Makefile.am:
+	Implemented comparator-i;ascii-numeric extension and activated
+	comparator extension support.
+	[01386a471dc7]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Added dummy extensions for core comparators.
+	[ae2e6fd6f94e]
+
+	* sieve/tests/extensions.sieve, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/sieve-address-parts.c:
+	A few small cosmetic changes in addr-part code and generic extension
+	support.
+	[7b9f9e71030e]
+
+2007-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-common.h:
+	Finished implementation of subaddress extension.
+	[05c4031e501e]
+
+	* configure.in, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/subaddress/rfc3598.txt, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-commands.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-validator.c, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-size.c, src/sieve-bin/Makefile.am:
+	Implemented support for the subaddress extension and fixed extension
+	support to work properly.
+	[4e9f385adc07]
+
+2007-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/tst-address.c:
+	Implemented address part execution support.
+	[af5ea3cdd396]
+
+2007-11-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-validator.c, src/lib-sieve/tst-address.c:
+	Activated address-part code generation support.
+	[60ab1abd0d01]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-ast.h, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve
+	/sieve-lexer.h, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-
+	parser.h, src/lib-sieve/sieve-validator.h:
+	Lots of cosmetic changes
+	[19366331bc99]
+
+	* INSTALL, README:
+	Added a little documentation to the README file.
+	[2fd76028ca9b]
+
+	* src/lib-sieve/sieve-validator.c:
+	Removed unused static pre-declaration from validator.
+	[f745b4988763]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/Makefile.am, src/lib-
+	sieve/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c,
+	src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-validator.c,
+	src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	header.c, src/sieve-bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Rewrote large parts of the extension support and added partial
+	address-part implementation.
+	[bbbf416d458c]
+
+2007-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/sieve_test.c:
+	Upgraded sieve_test to 1.1.beta8
+	[beaeb564662c]
+
+	* src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Enabled comparator execution support.
+	[5b4103b61afd]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-
+	size.c:
+	Added support for optional operators to the byte code
+	implementation.
+	[9355ea520e77]
+
+2007-11-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Started implementation of comparator execution support.
+	[a3e2d0467235]
+
+2007-11-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Changed string-list single-string handling for coded list.
+	[494b84c7dab4]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Properly implemented opcode and operand handing and moved code to
+	more appropriate units.
+	[6d30cd3270b4]
+
+2007-11-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/examples/sieve_examples.sieve, sieve/examples/stephan.sieve,
+	sieve/examples/unparsed-elvey.sieve, src/lib-sieve/sieve-code.h:
+	A few minor changes
+	[8eb67ba19a03]
+
+	* sieve/examples/elvey.sieve, sieve/examples/jerry.sieve,
+	sieve/examples/mjohnson.sieve, sieve/examples/mklose.sieve,
+	sieve/examples/sanjay.sieve, sieve/examples/vivil.sieve:
+	Added sieve example and documented the others with author and the
+	url where I found them.
+	[36b747fc5a42]
+
+2007-10-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h:
+	Moved literall access functions from interpreter to binary.
+	[df004c3d4967]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h:
+	Implemented comparator support towards code generation,
+	interpretation is not possible yet.
+	[c4eb303c242c]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, src/lib-sieve/tst-size.c:
+	Changed argument to operand processing to be much more flexible.
+	[b07f5129b239]
+
+2007-10-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h:
+	Moved literal emission functions from generator to binary source.
+	[8d9c3aa76abf]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-size.c:
+	First steps towards implementing code generation and interpretation
+	for proper comperators.
+	[8f8c18edbd39]
+
+	* src/lib-sieve/tst-exists.c:
+	Extremely minor cosmetic change.
+	[8b215ab7e80f]
+
+	* src/lib-sieve/plugins/Makefile, src/lib-sieve/plugins/Makefile.in:
+	Removed files with intermittent compilation results from the
+	repository (oops)
+	[3c56353ce681]
+
+	* sieve/tests/basic.sieve, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/tst-exists.c, src/lib-sieve/tst-header.c:
+	Made header and exists tests executable.
+	[38b4e757271d]
+
+2007-10-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/basic.sieve, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-size.c, src/sieve-
+	bin/Makefile.am, src/sieve-bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Made address and size tests executable and fixed minor bug regarding
+	the lexer.
+	[931a0b442f19]
+
+	* .hgignore, src/lib-sieve/Makefile.am, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src
+	/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-bin/Makefile, src
+	/sieve-bin/Makefile.am, src/sieve-bin/Makefile.in, src/sieve-
+	bin/sieve_test.c, src/sieve-bin/sievec, src/sieve-bin/sievec.c, src
+	/sieve-bin/sievec.o:
+	Created libsieve interface and started the sieve_test binary.
+	[8d922df3dd5c]
+
+2007-10-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/Makefile, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-commands.c, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-lexer.c, src/lib-sieve/sieve-parser.c, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-size.c, src/sieve-bin/Makefile, src
+	/sieve-bin/Makefile.am, src/sieve-bin/Makefile.in, src/sieve-
+	bin/sievec, src/sieve-bin/sievec.o:
+	Upgraded from dovecot-1.0 to dovecot-1.1 (array changes and various
+	_unref differences)
+	[f36e62f9baf9]
+
+	* configure.in, sieve/errors/address-errors.sieve, sieve/errors
+	/header-errors.sieve, sieve/errors/if-errors.sieve,
+	sieve/errors/interesting.sieve, sieve/errors/keep-errors.sieve,
+	sieve/errors/parse-errors.sieve, sieve/errors/require-errors.sieve,
+	sieve/errors/size-errors.sieve, sieve/errors/stop-errors.sieve,
+	sieve/errors/tag-errors.sieve, sieve/examples/elvey.sieve,
+	sieve/examples/mjohnson.sieve, sieve/examples/mklose.sieve,
+	sieve/examples/rfc3028.sieve, sieve/examples/sanjay.sieve,
+	sieve/examples/sieve_examples.sieve, sieve/examples/stephan.sieve,
+	sieve/examples/unparsed-elvey.sieve, sieve/examples/vacation.sieve,
+	sieve/examples/vivil.sieve, sieve/tests/basic.sieve,
+	sieve/tests/extensions.sieve, sieve/tests/if.sieve, src/Makefile.am,
+	src/lib-sieve/Makefile.am, src/lib-sieve/scripts/errors/address-
+	errors.sieve, src/lib-sieve/scripts/errors/header-errors.sieve, src
+	/lib-sieve/scripts/errors/if-errors.sieve, src/lib-
+	sieve/scripts/errors/interesting.sieve, src/lib-sieve/scripts/errors
+	/keep-errors.sieve, src/lib-sieve/scripts/errors/parse-errors.sieve,
+	src/lib-sieve/scripts/errors/require-errors.sieve, src/lib-
+	sieve/scripts/errors/size-errors.sieve, src/lib-sieve/scripts/errors
+	/stop-errors.sieve, src/lib-sieve/scripts/errors/tag-errors.sieve,
+	src/lib-sieve/scripts/examples/elvey.sieve, src/lib-
+	sieve/scripts/examples/mjohnson.sieve, src/lib-
+	sieve/scripts/examples/mklose.sieve, src/lib-
+	sieve/scripts/examples/rfc3028.sieve, src/lib-
+	sieve/scripts/examples/sanjay.sieve, src/lib-
+	sieve/scripts/examples/sieve_examples.sieve, src/lib-
+	sieve/scripts/examples/stephan.sieve, src/lib-sieve/scripts/examples
+	/unparsed-elvey.sieve, src/lib-
+	sieve/scripts/examples/vacation.sieve, src/lib-
+	sieve/scripts/examples/vivil.sieve, src/lib-
+	sieve/scripts/tests/extensions.sieve, src/lib-
+	sieve/scripts/tests/if.sieve, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sievec.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src
+	/sieve-bin/Makefile, src/sieve-bin/Makefile.am, src/sieve-
+	bin/Makefile.in, src/sieve-bin/sievec, src/sieve-bin/sievec.c, src
+	/sieve-bin/sievec.o:
+	Exported sievec binary to separate directory called sieve-bin.
+	[f3dd838d3893]
+
+2007-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-size.c:
+	Started first support for actual execution of sieve script.
+	[7d3b717d834d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-interpreter.h, src/plugins/Makefile.am, src/plugins/lda-
+	sieve/Makefile.am, src/plugins/lda-sieve/lda-sieve-plugin.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.h:
+	* Minor changes to the extension implementation
+	* Started the lda plugin source
+	[5252fd9fd951]
+
+2007-10-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address.c:
+	Changed (currently unused) sieve-address.c to use dovecot rfc822
+	parser.
+	[d32cc88f0ecf]
+
+	* src/lib-sieve/plugins/vacation/draft-ietf-sieve-vacation-07.txt:
+	Added draft RFC for vacation extension.
+	[4f6590dd1d7e]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/Makefile, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/Makefile.in, src
+	/lib-sieve/plugins/comparator-i;ascii-numeric.c, src/lib-
+	sieve/plugins/copy.c, src/lib-sieve/plugins/vacation/Makefile.am,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/vacation/vacation.sieve, src/lib-
+	sieve/scripts/tests/extensions.sieve, src/lib-sieve/sieve-
+	extensions.c:
+	* Further developed the extension support
+	* Added plugins as static libraries (for now)
+	[2b26d303f3d1]
+
+	* src/lib-sieve/scripts/tests/extensions.sieve, src/lib-
+	sieve/scripts/tests/reject.sieve:
+	Renamed reject.sieve to extensions.sieve for generic extensions
+	testing.
+	[3993600b2e1f]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/ext-fileinto.c:
+	* Added generation support to the fileinto extension.
+	* Fixed a bug in the require command generation.
+	[4f38530232e6]
+
+	* .hgignore, src/lib-sieve/Makefile.am, src/lib-sieve/cmd-require.c,
+	src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/scripts/tests/reject.sieve, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-binary.h, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sievec.c:
+	Added basic extension support to generator and interpreter.
+	[2f78fc8c9919]
+
+2007-10-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-reject.c, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	commands-private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-size.c:
+	Initial commit didn't compile because it was comitted in the middle
+	of a new feature.
+	[b50c7ada434a]
+
+	* autogen.sh:
+	Added autogen.sh from the dovecot project (removed doc/wiki code)
+	[10ed2a377ea0]
+
+2007-10-21  stephan  <stephan@flappie>
+
+	* .hgignore, libsieve-config.h.in:
+	Added -config files to the hgignore and removed them from the
+	repository
+	[ddac82bec3c3]
+
+	* .hgignore, AUTHORS, COPYING.LGPL, INSTALL, Makefile.am, NEWS,
+	README, configure.in, libsieve-config.h.in, src/Makefile.am, src
+	/lib-sieve/Makefile.am, src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/cmd-require.c, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/comparator-i;ascii-numeric.c, src
+	/lib-sieve/plugins/copy.c, src/lib-sieve/scripts/errors/address-
+	errors.sieve, src/lib-sieve/scripts/errors/header-errors.sieve, src
+	/lib-sieve/scripts/errors/if-errors.sieve, src/lib-
+	sieve/scripts/errors/interesting.sieve, src/lib-sieve/scripts/errors
+	/keep-errors.sieve, src/lib-sieve/scripts/errors/parse-errors.sieve,
+	src/lib-sieve/scripts/errors/require-errors.sieve, src/lib-
+	sieve/scripts/errors/size-errors.sieve, src/lib-sieve/scripts/errors
+	/stop-errors.sieve, src/lib-sieve/scripts/errors/tag-errors.sieve,
+	src/lib-sieve/scripts/examples/elvey.sieve, src/lib-
+	sieve/scripts/examples/mjohnson.sieve, src/lib-
+	sieve/scripts/examples/mklose.sieve, src/lib-
+	sieve/scripts/examples/rfc3028.sieve, src/lib-
+	sieve/scripts/examples/sanjay.sieve, src/lib-
+	sieve/scripts/examples/sieve_examples.sieve, src/lib-
+	sieve/scripts/examples/stephan.sieve, src/lib-sieve/scripts/examples
+	/unparsed-elvey.sieve, src/lib-
+	sieve/scripts/examples/vacation.sieve, src/lib-
+	sieve/scripts/examples/vivil.sieve, src/lib-
+	sieve/scripts/tests/if.sieve, src/lib-sieve/sieve-address.c, src
+	/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	commands-private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sievec.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-
+	size.c, stamp.h.in:
+	First entered libsieve into new Hg repository
+	[d31c1c993bcf]
+
Index: b/sieve/INSTALL
===================================================================
--- /dev/null
+++ b/sieve/INSTALL
@@ -0,0 +1,231 @@
+For the most up-to-date information you are referred to the Dovecot wiki:
+
+http://wiki.dovecot.org/LDA/Sieve/Dovecot
+
+Compiling
+---------
+
+Compilation is identical among the CMUSieve and the new Sieve plugin. Use
+--with-dovecot=<path> to point to dovecot-config file's directory. There are two
+possibilities where this could exist:
+
+  1. If you configured Dovecot with --enable-header-install, you'll have
+     dovecot-config installed in $prefix/lib/dovecot/ directory. For example:
+
+     ./configure --with-dovecot=/usr/local/lib/dovecot
+     make
+     sudo make install
+
+  2. Compiled Dovecot sources' root directory. For example:
+
+     ./configure --with-dovecot=../dovecot-1.2.0/
+     make
+     make install
+
+If you downloaded the sources using Mercurial, you will need to execute
+`./autogen.sh' first to build the automake structure in your source tree. This
+process requires autotools and libtool to be installed.
+
+Dovecot Sieve includes several command line tools to perform tasks such as
+compile, verify and debug Sieve scripts (refer to the README file for more
+information). These are built only if you use method 2, because they need to
+link Dovecot's .a libraries, which can only be found from Dovecot's source tree
+(make install doesn't install them).
+
+Basic Configuration
+-------------------
+
+To use Sieve, you will first need to make sure you are using Dovecot's deliver
+for delivering incoming mail to users' mailboxes. Then, you need to enable the
+Sieve plugin in your dovecot.conf:
+
+protocol lda {
+..
+  # Support for dynamically loadable plugins. mail_plugins is a space separated
+  # list of plugins to load.
+  mail_plugins = sieve # ... other plugins like quota
+}
+
+The sieve plugin recognizes the following configuration options in the plugin
+section of the config file (default values are shown if applicable):
+
+sieve = ~/.dovecot.sieve
+  The path to the user's main active script.
+
+sieve_global_path
+  A path to a global sieve script file, which gets executed ONLY if user's
+  private Sieve script doesn't exist, e.g. /var/lib/dovecot/default.sieve. Be
+  sure to pre-compile this script manually using the sievec command line tool,
+  as explained in the README file.
+
+sieve_global_dir =
+  Directory for :global include scripts for the include extension.
+
+sieve_dir = ~/
+  Directory for :personal include scripts for the include extension.
+
+sieve_extensions =
+  Which Sieve language extensions are available to users. By default, all
+  supported extensions are available, except for deprecated extensions or those
+  that are still under development. Some system administrators may want to
+  disable certain Sieve extensions or enable those that are not available by
+  default. Supported extensions are listed on this page. This setting can use
+  '+' and '-' to specify differences relative to the default. For example
+  `sieve_extensions = +imapflags' will enable the deprecated imapflags extension
+  in addition to all extensions enabled by default.
+
+sieve_subaddress_sep = +
+  The separator that is expected between the :user and :detail address parts
+  introduced by the subaddress extension. This may also be a sequence of
+  characters (e.g. '--'). The current implementation looks for the separator
+  from the left of the localpart and uses the first one encountered. The :user
+  part is left of the separator and the :detail part is right.
+
+For example:
+
+plugin {
+...
+   # The location of the user's active script:
+   sieve = ~/.dovecot.sieve
+
+   # If the user has no personal active script (i.e. if the file
+   # indicated in sieve= does not exist), use this one:
+   sieve_global_path = /var/lib/dovecot/sieve/default.sieve
+
+   # The include extension fetches the :personal scripts from this
+   # directory. When ManageSieve is used, this is also where scripts
+   # are uploaded.
+   sieve_dir = ~/sieve
+
+   # The include extension fetches the :global scripts from this
+   # directory.
+   sieve_global_dir = /var/lib/dovecot/sieve/global/
+}
+
+Per-user Sieve script location
+------------------------------
+
+By default, the Dovecot Sieve plugin looks for the user's Sieve script file in
+the user's home directory (~/.dovecot.sieve). This requires that the home
+directory is set for the user.
+
+If you want to store the script elsewhere, you can override the default using
+the sieve setting, which specifies the path to the user's script file. This can
+be done in two ways:
+
+ 1. Define the sieve setting in the plugin section of dovecot.conf.
+ 2. Return sieve extra field from userdb extra fields.
+
+For example, to use a Sieve script file named <username>.sieve in
+/var/sieve-scripts, use:
+
+plugin {
+...
+
+ sieve = /var/sieve-scripts/%u.sieve
+}
+
+You may use templates like %u, as shown in the example. See all variables.
+
+A relative path (or just a filename) will be interpreted to point under the
+user's home directory.
+
+Executing Multiple Scripts Sequentially
+---------------------------------------
+
+The Dovecot Sieve plugin allows executing multiple Sieve scripts sequentially.
+The extra scripts can be executed before and after the user's private script.
+For example, this allows executing global Sieve policies before the user's
+script. This is not possible using the sieve_global_path setting, because that
+is only used when the user's private script does not exist. The following
+settings in the plugin section of the Dovecot config file control the execution
+sequence:
+
+sieve_before =
+  Path to a script file or a directory containing script files that need to be
+  executed before the user's script. If the path points to a directory, all the
+  Sieve scripts contained therein (with the proper .sieve extension) are
+  executed. The order of execution is determined by the file names, using a
+  normal 8bit per-character comparison.
+
+sieve_after =
+  Identical to sieve_before, only the specified scripts are executed after the
+  user's script (only when keep is still in effect!).
+
+The script execution ends when the currently executing script in the sequence
+does not yield a "keep" result: when the script terminates, the next script is
+only executed if an implicit or explicit "keep" is in effect. Thus, to end all
+script execution, a script must not execute keep and it must cancel the
+implicit keep, e.g. by executing "discard; stop;". This means that the command
+"keep;" has different semantics when used in a sequence of scripts. For normal
+Sieve execution, "keep;" is equivalent to "fileinto "INBOX";", because both
+cause the message to be stored in INBOX. However, in sequential script
+execution, it only controls whether the next script is executed. Storing the
+message into INBOX (the default folder) is not done until the last script in
+the sequence executes (implicit) keep. To force storing the message into INBOX
+earlier in the sequence, the fileinto command can be used (with ":copy" or
+together with "keep;").
+
+Apart from the keep action, all actions triggered in a script in the sequence
+are executed before continuing to the next script. This means that when a script
+in the sequence encounters an error, actions from earlier executed scripts are
+not affected. The sequence is broken however, meaning that the script execution
+of the offending script is aborted and no further scripts are executed. An
+implicit keep is executed in stead.
+
+Just as for executing a single script the normal way, the Dovecot Sieve plugin
+takes care never to duplicate deliveries, forwards or responses. When vacation
+actions are executed multiple times in different scripts, the usual error is not
+triggered: the subsequent duplicate vacation actions are simply discarded.
+
+For example:
+
+plugin {
+...
+   # Scripts executed before the user's script.
+   #   E.g. handling messages marked as dangerous
+   sieve_before = /var/lib/dovecot/sieve/discard-virusses.sieve
+
+   # Scripts executed after the user's script (if keep is still in effect)
+   #   E.g. default mail filing rules.
+   sieve_after = /var/lib/dovecot/sieve/after.d/
+}
+
+IMPORTANT: Be sure to manually pre-compile the scripts specified by sieve_before
+and sieve_after using the sievec tool, as explained in the README file.
+
+Migration from CMUSieve
+-----------------------
+
+For the most part, migration from CMUSieve to the new Sieve plugin is just a
+matter of changing the used plugin name from cmusieve to sieve in the
+mail_plugins option in the protocol lda section of the config file (as explained
+above). However, there are a few important differences:
+
+ * The imapflags extension is now called imap4flags. The CMUSieve implementation
+   is based on an old draft specification that is not completely compatible.
+   Particularly, the mark and unmark commands were removed from the new
+   specification. For backwards compatibility, support for the old imapflags
+   extension can be enabled using the sieve_extensions setting (as explained
+   above). This is disabled by default.
+
+ * The notify extension is now called enotify. Sieve scripts need to be adjusted
+   to incorporate this change: unlike imapflags, no backwards compatibility is
+   provided currently.
+
+ * The include extension now requires your script file names to end with
+   ".sieve" : include :personal "myscript"; won't work unless you rename
+   "myscript" to "myscript.sieve"
+
+Test Suite
+----------
+
+This package includes a test suite to verify the basic processing of the Sieve
+interpreter on your particular platform. Note that the test suite is not
+available when this package is compiled against the Dovecot headers only. The
+test suite executes a list of test cases and halts when one of them fails. If it
+executes all test cases successfully, the test suite finishes. You can execute
+the test suite using `make test`.
+
+A failing test case is always a bug and a report is greatly appreciated.
+
Index: b/sieve/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/Makefile.am
@@ -0,0 +1,132 @@
+SUBDIRS = src
+
+unfinished = doc/man/sieve-filter.1
+
+if BUILD_UNFINISHED
+unfinished_mans = $(unfinished)
+else
+unfinished_dist = $(unfinished)
+endif
+
+EXTRA_DIST = \
+	tests \
+	examples/* \
+	doc/rfc \
+	doc/devel \
+	COPYING.LGPL \
+	ChangeLog \
+	$(unfinished_dist)
+
+dist_man_MANS = \
+	doc/man/sievec.1 \
+	doc/man/sieved.1 \
+	doc/man/sieve-test.1 \
+	$(unfinished_mans)
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
+
+# Testsuite tests
+
+TESTSUITE_BIN = $(top_srcdir)/src/testsuite/testsuite
+
+if TESTSUITE_VALGRIND
+TEST_BIN = valgrind -q --error-exitcode=1 --show-reachable=yes --leak-check=full $(TESTSUITE_BIN)
+else
+TEST_BIN = $(TESTSUITE_BIN)
+endif
+
+test_cases = \
+	tests/testsuite.svtest\
+	tests/control-structures.svtest \
+	tests/compile/compile.svtest \
+	tests/compile/errors.svtest \
+	tests/compile/warnings.svtest \
+	tests/execute/errors.svtest \
+	tests/execute/actions.svtest \
+	tests/execute/smtp.svtest \
+	tests/execute/mailstore.svtest \
+	tests/execute/examples.svtest \
+	tests/exists.svtest \
+	tests/header.svtest \
+	tests/address.svtest \
+	tests/lexer.svtest \
+	tests/comparators/core.svtest \
+	tests/match-types/is.svtest \
+	tests/match-types/contains.svtest \
+	tests/match-types/matches.svtest \
+	tests/extensions/encoded-character.svtest \
+	tests/extensions/envelope.svtest \
+	tests/extensions/variables/basic.svtest \
+	tests/extensions/variables/match.svtest \
+	tests/extensions/variables/modifiers.svtest \
+	tests/extensions/variables/quoting.svtest \
+	tests/extensions/variables/string.svtest \
+	tests/extensions/variables/errors.svtest \
+	tests/extensions/variables/regex.svtest \
+	tests/extensions/include/errors.svtest \
+	tests/extensions/include/variables.svtest \
+	tests/extensions/include/once.svtest \
+	tests/extensions/include/twice.svtest \
+	tests/extensions/include/rfc.svtest \
+	tests/extensions/include/execute.svtest \
+	tests/extensions/imap4flags/basic.svtest \
+	tests/extensions/imap4flags/hasflag.svtest \
+	tests/extensions/imap4flags/errors.svtest \
+	tests/extensions/imap4flags/execute.svtest \
+	tests/extensions/imap4flags/multiscript.svtest \
+	tests/extensions/imap4flags/flagstore.svtest \
+	tests/extensions/body/basic.svtest \
+	tests/extensions/body/raw.svtest \
+	tests/extensions/body/content.svtest \
+	tests/extensions/body/match-values.svtest \
+	tests/extensions/regex/basic.svtest \
+	tests/extensions/regex/match-values.svtest \
+	tests/extensions/regex/errors.svtest \
+	tests/extensions/reject/execute.svtest \
+	tests/extensions/reject/smtp.svtest \
+	tests/extensions/relational/basic.svtest \
+	tests/extensions/relational/rfc.svtest \
+	tests/extensions/relational/errors.svtest \
+	tests/extensions/subaddress/basic.svtest \
+	tests/extensions/subaddress/rfc.svtest \
+	tests/extensions/vacation/errors.svtest \
+	tests/extensions/vacation/execute.svtest \
+	tests/extensions/vacation/message.svtest \
+	tests/extensions/vacation/smtp.svtest \
+	tests/extensions/enotify/basic.svtest \
+	tests/extensions/enotify/encodeurl.svtest \
+	tests/extensions/enotify/valid_notify_method.svtest \
+	tests/extensions/enotify/notify_method_capability.svtest \
+	tests/extensions/enotify/errors.svtest \
+	tests/extensions/enotify/execute.svtest \
+	tests/extensions/enotify/mailto.svtest \
+	tests/extensions/environment/basic.svtest \
+	tests/extensions/environment/rfc.svtest \
+	tests/extensions/mailbox/execute.svtest \
+	tests/extensions/date/basic.svtest \
+	tests/extensions/date/date-parts.svtest \
+	tests/extensions/date/zones.svtest \
+	tests/multiscript/basic.svtest \
+	tests/deprecated/notify/basic.svtest \
+	tests/deprecated/notify/mailto.svtest \
+	tests/deprecated/notify/errors.svtest \
+	tests/deprecated/notify/execute.svtest
+
+if HAVE_DOVECOT_LIBS
+
+$(test_cases):
+	@$(TEST_BIN) $@
+
+.PHONY: $(test_cases)
+
+test: $(test_cases)
+
+else
+
+test:
+	@echo "Cannot compile or execute the testsuite without the Dovecot sources."
+
+endif
Index: b/sieve/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/Makefile.in
@@ -0,0 +1,929 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = .
+DIST_COMMON = README $(am__configure_deps) $(dist_man_MANS) \
+	$(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/dsieve-config.h.in $(srcdir)/dummy-config.h.in \
+	$(srcdir)/stamp.h.in $(top_srcdir)/configure AUTHORS COPYING \
+	ChangeLog INSTALL NEWS TODO config.guess config.rpath \
+	config.sub depcomp install-sh ltmain.sh missing
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = dummy-config.h dsieve-config.h
+CONFIG_CLEAN_FILES = stamp.h
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+man1dir = $(mandir)/man1
+am__installdirs = "$(DESTDIR)$(man1dir)"
+NROFF = nroff
+MANS = $(dist_man_MANS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir dist dist-all distcheck
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d "$(distdir)" \
+    || { find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr "$(distdir)"; }; }
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = src
+unfinished = doc/man/sieve-filter.1
+@BUILD_UNFINISHED_TRUE@unfinished_mans = $(unfinished)
+@BUILD_UNFINISHED_FALSE@unfinished_dist = $(unfinished)
+EXTRA_DIST = \
+	tests \
+	examples/* \
+	doc/rfc \
+	doc/devel \
+	COPYING.LGPL \
+	ChangeLog \
+	$(unfinished_dist)
+
+dist_man_MANS = \
+	doc/man/sievec.1 \
+	doc/man/sieved.1 \
+	doc/man/sieve-test.1 \
+	$(unfinished_mans)
+
+
+# Testsuite tests
+TESTSUITE_BIN = $(top_srcdir)/src/testsuite/testsuite
+@TESTSUITE_VALGRIND_FALSE@TEST_BIN = $(TESTSUITE_BIN)
+@TESTSUITE_VALGRIND_TRUE@TEST_BIN = valgrind -q --error-exitcode=1 --show-reachable=yes --leak-check=full $(TESTSUITE_BIN)
+test_cases = \
+	tests/testsuite.svtest\
+	tests/control-structures.svtest \
+	tests/compile/compile.svtest \
+	tests/compile/errors.svtest \
+	tests/compile/warnings.svtest \
+	tests/execute/errors.svtest \
+	tests/execute/actions.svtest \
+	tests/execute/smtp.svtest \
+	tests/execute/mailstore.svtest \
+	tests/execute/examples.svtest \
+	tests/exists.svtest \
+	tests/header.svtest \
+	tests/address.svtest \
+	tests/lexer.svtest \
+	tests/comparators/core.svtest \
+	tests/match-types/is.svtest \
+	tests/match-types/contains.svtest \
+	tests/match-types/matches.svtest \
+	tests/extensions/encoded-character.svtest \
+	tests/extensions/envelope.svtest \
+	tests/extensions/variables/basic.svtest \
+	tests/extensions/variables/match.svtest \
+	tests/extensions/variables/modifiers.svtest \
+	tests/extensions/variables/quoting.svtest \
+	tests/extensions/variables/string.svtest \
+	tests/extensions/variables/errors.svtest \
+	tests/extensions/variables/regex.svtest \
+	tests/extensions/include/errors.svtest \
+	tests/extensions/include/variables.svtest \
+	tests/extensions/include/once.svtest \
+	tests/extensions/include/twice.svtest \
+	tests/extensions/include/rfc.svtest \
+	tests/extensions/include/execute.svtest \
+	tests/extensions/imap4flags/basic.svtest \
+	tests/extensions/imap4flags/hasflag.svtest \
+	tests/extensions/imap4flags/errors.svtest \
+	tests/extensions/imap4flags/execute.svtest \
+	tests/extensions/imap4flags/multiscript.svtest \
+	tests/extensions/imap4flags/flagstore.svtest \
+	tests/extensions/body/basic.svtest \
+	tests/extensions/body/raw.svtest \
+	tests/extensions/body/content.svtest \
+	tests/extensions/body/match-values.svtest \
+	tests/extensions/regex/basic.svtest \
+	tests/extensions/regex/match-values.svtest \
+	tests/extensions/regex/errors.svtest \
+	tests/extensions/reject/execute.svtest \
+	tests/extensions/reject/smtp.svtest \
+	tests/extensions/relational/basic.svtest \
+	tests/extensions/relational/rfc.svtest \
+	tests/extensions/relational/errors.svtest \
+	tests/extensions/subaddress/basic.svtest \
+	tests/extensions/subaddress/rfc.svtest \
+	tests/extensions/vacation/errors.svtest \
+	tests/extensions/vacation/execute.svtest \
+	tests/extensions/vacation/message.svtest \
+	tests/extensions/vacation/smtp.svtest \
+	tests/extensions/enotify/basic.svtest \
+	tests/extensions/enotify/encodeurl.svtest \
+	tests/extensions/enotify/valid_notify_method.svtest \
+	tests/extensions/enotify/notify_method_capability.svtest \
+	tests/extensions/enotify/errors.svtest \
+	tests/extensions/enotify/execute.svtest \
+	tests/extensions/enotify/mailto.svtest \
+	tests/extensions/environment/basic.svtest \
+	tests/extensions/environment/rfc.svtest \
+	tests/extensions/mailbox/execute.svtest \
+	tests/extensions/date/basic.svtest \
+	tests/extensions/date/date-parts.svtest \
+	tests/extensions/date/zones.svtest \
+	tests/multiscript/basic.svtest \
+	tests/deprecated/notify/basic.svtest \
+	tests/deprecated/notify/mailto.svtest \
+	tests/deprecated/notify/errors.svtest \
+	tests/deprecated/notify/execute.svtest
+
+all: dummy-config.h dsieve-config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+
+.SUFFIXES:
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+dummy-config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/dummy-config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status dummy-config.h
+$(srcdir)/dummy-config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+dsieve-config.h: stamp-h2
+	@if test ! -f $@; then \
+	  rm -f stamp-h2; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h2; \
+	else :; fi
+
+stamp-h2: $(srcdir)/dsieve-config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h2
+	cd $(top_builddir) && $(SHELL) ./config.status dsieve-config.h
+
+distclean-hdr:
+	-rm -f dummy-config.h stamp-h1 dsieve-config.h stamp-h2
+stamp.h: $(top_builddir)/config.status $(srcdir)/stamp.h.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+install-man1: $(dist_man_MANS)
+	@$(NORMAL_INSTALL)
+	test -z "$(man1dir)" || $(MKDIR_P) "$(DESTDIR)$(man1dir)"
+	@list=''; test -n "$(man1dir)" || exit 0; \
+	{ for i in $$list; do echo "$$i"; done; \
+	l2='$(dist_man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.1[a-z]*$$/p'; \
+	} | while read p; do \
+	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; echo "$$p"; \
+	done | \
+	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,' | \
+	sed 'N;N;s,\n, ,g' | { \
+	list=; while read file base inst; do \
+	  if test "$$base" = "$$inst"; then list="$$list $$file"; else \
+	    echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man1dir)/$$inst'"; \
+	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man1dir)/$$inst" || exit $$?; \
+	  fi; \
+	done; \
+	for i in $$list; do echo "$$i"; done | $(am__base_list) | \
+	while read files; do \
+	  test -z "$$files" || { \
+	    echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(man1dir)'"; \
+	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man1dir)" || exit $$?; }; \
+	done; }
+
+uninstall-man1:
+	@$(NORMAL_UNINSTALL)
+	@list=''; test -n "$(man1dir)" || exit 0; \
+	files=`{ for i in $$list; do echo "$$i"; done; \
+	l2='$(dist_man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.1[a-z]*$$/p'; \
+	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
+	test -z "$$files" || { \
+	  echo " ( cd '$(DESTDIR)$(man1dir)' && rm -f" $$files ")"; \
+	  cd "$(DESTDIR)$(man1dir)" && rm -f $$files; }
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES) dummy-config.h.in dsieve-config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS) dummy-config.h.in dsieve-config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) dummy-config.h.in dsieve-config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) dummy-config.h.in dsieve-config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@list='$(MANS)'; if test -n "$$list"; then \
+	  list=`for p in $$list; do \
+	    if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	    if test -f "$$d$$p"; then echo "$$d$$p"; else :; fi; done`; \
+	  if test -n "$$list" && \
+	    grep 'ab help2man is required to generate this page' $$list >/dev/null; then \
+	    echo "error: found man pages containing the \`missing help2man' replacement text:" >&2; \
+	    grep -l 'ab help2man is required to generate this page' $$list | sed 's/^/         /' >&2; \
+	    echo "       to fix them, install help2man, remove and regenerate the man pages;" >&2; \
+	    echo "       typically \`make maintainer-clean' will remove them" >&2; \
+	    exit 1; \
+	  else :; fi; \
+	else :; fi
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-lzma: distdir
+	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
+	$(am__remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lzma*) \
+	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@$(am__cd) '$(distuninstallcheck_dir)' \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(MANS) dummy-config.h dsieve-config.h
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(man1dir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-man
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man: install-man1
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-man
+
+uninstall-man: uninstall-man1
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all \
+	ctags-recursive install-am install-strip tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-am clean clean-generic \
+	clean-libtool ctags ctags-recursive dist dist-all dist-bzip2 \
+	dist-gzip dist-lzma dist-shar dist-tarZ dist-xz dist-zip \
+	distcheck distclean distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distcleancheck distdir \
+	distuninstallcheck dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-man1 install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am uninstall-man uninstall-man1
+
+
+@MAINTAINER_MODE_TRUE@ChangeLog: .hg/dirstate
+@MAINTAINER_MODE_TRUE@	hg log --style=changelog > ChangeLog
+
+@HAVE_DOVECOT_LIBS_TRUE@$(test_cases):
+@HAVE_DOVECOT_LIBS_TRUE@	@$(TEST_BIN) $@
+
+@HAVE_DOVECOT_LIBS_TRUE@.PHONY: $(test_cases)
+
+@HAVE_DOVECOT_LIBS_TRUE@test: $(test_cases)
+
+@HAVE_DOVECOT_LIBS_FALSE@test:
+@HAVE_DOVECOT_LIBS_FALSE@	@echo "Cannot compile or execute the testsuite without the Dovecot sources."
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/NEWS
===================================================================
--- /dev/null
+++ b/sieve/NEWS
@@ -0,0 +1,298 @@
+v0.1.14 19-12-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	* Made the imposed limits on the number of redirects and the number of
+	  actions configurable. The settings are called sieve_max_actions and
+	  sieve_max_redirects.
+	* Did a major rework of extension handling, making sure that no global state
+	  is maintained. This change was triggered by problems that global state info
+	  would cause for Dovecot v2.0, but it is also important for v1.2 as it
+	  significantly cleans up the library implementation.
+	+ Made LDA Sieve plugin recognize the deliver_log_format setting.
+	+ Message headers produced from user-supplied data are now RFC2047-encoded if
+	  necessary for outgoing messages. This is for example important for the
+	  :subject argument of the vacation action.
+	+ Added support for the $text$ substitution in the deprecated notify
+	  extension.
+	+ The subaddress extension now also accepts recipient_delimiter setting as an
+	  alias for sieve_subaddress_sep setting. This anticipates the
+	  recipient_delimiter setting in v2.0.
+	- Fixed logging of mailbox names. It logged the converted mUTF7 version in
+	  stead of the original UTF8 version supplied by the user.
+	- Fixed a minor memory leak in the multiscript support.
+	- Fixed a bug in the recompilation of Sieve scripts. Made sure that scripts
+	  are only recompiled when the script file - or the symlink pointing to it -
+	  is strictly newer.
+
+v0.1.13 18-10-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	+ Body extension: implemented proper handling of the :raw transform and added
+	  various new tests to the test suite. However, :content "multipart" and
+	  :content "message/rfc822" are still not working.
+	+ Fixed race condition occuring when multiple instances are saving the same
+	  binary (patch by Timo Sirainen).
+	+ Test suite: added support for testing multiscript execution.
+	- Made compiler more lenient towars missing CRLF at the end of the script in a
+	  hash comment.
+	- Body extension: don't give SKIP_BODY_BLOCK flag to message parser, we want
+	  the body! (patch by Timo Sirainen).
+	- Fixed handling of implicit side effects for multiscript execution.
+	- Fixed bugs in multiscript support; subsequent keep actions were not always
+	  merged correctly and implicit side effects were not always handled
+	  correctly.
+	- Fixed a segfault bug in the sieve-test tool occuring when compile fails.
+	- Fixed segfault bug in action procesing. It was triggered while merging side
+	  effects in duplicate actions.
+	- Fixed bug in the Sieve plugin that caused it to try to stat() a NULL path,
+	  yielding a 'Bad address' error.
+
+v0.1.12 21-08-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	+ Testsuite: added support for testing binaries stored on disk.
+	+ Implemented the new date extension. This allows matching against date values
+	  in header fields and the current date at the time of script evaluation.
+
+v0.1.11 08-08-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	+ Built skeleton implementation for the date extension (RFC 5260). It
+	  compiles, but it does not do anything useful yet. Therefore, it is not part
+	  of the default compilation.
+	- Fixed ARM portability issues caused by char type not being signed on that
+	  platform. Reading optional operands from a binary would fail for action side
+	  effects. Also, an accidental mixup of an int return type with bool caused
+	  the interpreter to continue on ARM even though an error occured.
+	- Removed direct stdint.h includes to prevent portability issues.
+	- Fixed segfault bug in the handling of script open failures.
+	- Include: improved user error messages and system log messages.
+	- Fixed copy-paste mixup between sieve_after and sieve_before settings in the
+	  LDA Sieve plugin. If only a sieve_after script was active, nothing would
+	  have been executed. Patch by Mike Abbott.
+	- Include: fixed a bug in HOME substitution in the sieve_dir path. Surfaced in
+	  ManageSieve.
+
+v0.1.10 03-08-2009 Stephan Bosch <stephan@rename-it.nl>
+
+	* Changed action execution of fileinto and keep. These changes depend on API
+	  additions in Dovecot, making this release depend on Dovecot v1.2.2 or newer.
+	* Further developed the sieve-filter command line tool. This required a few
+	  changes to the action execution of the Sieve engine. The tool was
+	  successfully tested on folders with a few 100k spam messages. However, the
+	  commandline options are still incomplete, a man page is missing and it needs
+	  much more testing before I can recommend anyone to use this tool.
+	+ Added support for the mailbox extension. This allows checking whether a
+	  mailbox exists using the mailboxexists command and it adds the :create
+	  argument to the fileinto command to create the mailbox when it is missing.
+	  The :create feature is useless unless the Deliver LDA is run with the -n
+	  option.
+	+ Improved the testsuite with tests for message delivery. Messages stored
+	  using keep and fileinto can be fed back into the Sieve engine for
+	  verification. This includes testing of applied IMAP flags.
+	+ Updated the man pages with the new method of specifying the supported
+	  extensions using + and - (for the -x parameter of the sieve tools)
+	+ Further developed the deprecated notify extension. A dummy for the denotify
+	  command exists, meaning that its use does not cause an error anymore.
+	- Fixed a bug in the derivation of the binary path from the script path. A
+	  bare filename would yield a path relative to root.
+	- Fixed a bug in the value matching code. The context data now uses a proper
+	  pool in stead of the data stack. Bug reported by Jan Sechser.
+	- Fixed assertion fail in the include extension caused by missing
+	  initialization upon binary load. This bug surfaces only for stored
+	  binaries. Bug reported by Tom Hendrikx.
+	- Fixed include error message for failed :global include. It mentioned the
+	  wrong config parameter.
+	- Fixed broken wiki reference in an error message of the plugin about the
+	  'sieve' setting.
+	- Fixed behavior of fileinto when delivering into a namespace prefix.
+	  Previous fix used the wrong storage.
+
+v0.1.9 22-07-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Removed the unfinished sieve-filter tool from the default build. It is now
+	  only built when the --with-unfinished-features switch is supplied during
+	  configure.
+	+ Started building support for the ereject version of the reject action,
+	  which has a preference to use an SMTP/LMTP protocol error in stead of a
+	  bounce message. This is to be used to make the Sieve plugin honour Deliver's
+	  -e parameter. This is not yet finished and not built by default.
+	+ Improved 'Permission denied' error messages just like Dovecot does,
+	  precisely specifying what permission is missing to access or create a file.
+	+ Added additional headers to the list of allowed headers for the address
+	  test. The restrictive nature of the address test is not always appropriate.
+	  Still thinking of a better, less restrictive implementation.
+	+ Made the deprecated notify extension compatible with the old CMUSieve
+	  plugin. However, the denotify command and the $text$ substitution are not
+	  yet supported.
+	+ Made the discard action log a message to avoid confusion about disappearing
+	  messages.
+	- Fixed behavior of fileinto when delivering into a namespace prefix. It now
+	  uses silent delivery into INBOX as fallback.
+	- Fixed logging of folder namespace prefix upon delivery into a prefixed
+	  namespace. Formerly it only logged the bare folder name.
+	- Fixed a potential segfault in the argument validation. It didn't surface
+	  because no command could have a :tag followed by an associated parameter as
+	  last argument.
+	- Fixed segfault bug occuring in envelope test when performed on null (<>)
+	  envelope path. The fix involves a rather large restructuring of the code to
+	  make sure envelope addresses are properly handled everywhere (bug reported
+	  by Nikita Koshikov)
+	- Envelope: fixed bug in application of address parts; failure to obtain
+	  the part would cause inappropriate match success (bug reported by Ron Lee)
+	- Fixed extension conflict checks during validation. It could sometimes
+	  produce useless errormessages. This is currently only used by the
+	  deprecated extensions.
+	- Forgot to remove old explicit storage library dependency (patch by
+	  Arkadiusz Miskiewicz).
+	- Fixed compiler warnings on certain platforms regarding the use fwrite for
+	  outgoing message construction
+
+v0.1.8 12-07-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	- Fixed AIX compile problem. For portability, the typeof operator is
+	  not used anymore.
+	+ Added partial support for the deprecated notify extension. However, it
+	  turns out that the implementation provided by cmusieve is even older (2001),
+	  meaning that this is currently not backwards compatible with cmusieve.
+
+v0.1.7 05-07-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	+ Added support for CRLF line breaks in strbuf error handler to fix a
+	  ManageSieve problem.
+	+ Improved consistency of sieve tool documentation and fixed missing
+	  parameters in internal tool help output.
+	+ Enhanced extensions configuration, allowing to specify the enabled
+	  extensions relatively to the default (patch by Steffen Kaiser).
+	- Forgot to initialize script execution status in Sieve plugin, causing
+	  segfaults on compile errors in specific conditions.
+	- Fixed logging in Sieve plugin for execution of default main script (went
+	  to STDERR).
+
+v0.1.6 18-06-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Adjusted to changes in Dovecot to make it compile against v1.2.rc5
+	* Made default of sieve_dir setting match the ManageSieve implementation.
+	- Fixed a few problems in de body extension that caused assert failures in
+	  specific situations.
+
+v0.1.5 18-04-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Ported the implementation of the Sieve include extension to the latest
+	  draft. This means that the import and export commands are replaced by a new
+	  command called global. The import and export commands are now DEPRICATED and
+	  are mere aliases for the global command. The new specification also adds the
+	  :once modifier to the include command. The also newly specified global.*
+	  variable namespace is not implemented yet as support for variable namespaces
+	  is currently missing.
+	* Did a major rework of the multiscript support for better error handling and
+	  made sure that persistent global scripts (sieve_before/sieve_after) are
+	  always executed, even when the user does not have a script of his own and
+	  a global default is missing.
+	+ Provided basic support for the environment extension. Currenly, the name,
+	  version and host items are useful. Others are pending.
+	+ Improved error message that is presented when an unknown Sieve extension is
+	  provided as argument to the require command. It now notifies the user that
+	  Sieve core commands do not need to be specified in require.
+	- Fixed bug in includes at levels deeper than one.
+	- Fixed bug in address matching that was caused by the failure to handle group
+	  specifications. In dovecot, these are marked by address items with NULL
+	  elements, which causes a segfault if not considered. The group 'undisclosed-
+	  recipients:;' in particular triggered this bug. Bug reported by Bernhard
+	  Schmidt.
+
+v0.1.4 21-03-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Started work on the sieve-filter tool. With this command line tool it will
+	  be possible to (re-)apply Sieve filters on a mail folder. It is currently
+	  undocumented and far from functional.
+	+ Added a custom debug extension that provides the possibility to print debug
+	  messages from scripts executed by the Sieve tools.
+	- Fixed issue with opening relative paths as a mail file. Bug reported by Ian
+	  P. Christian.
+	- Fixed MAC OSX compile problem. Turns out the extern modifier was missing at
+	  multiple places. Bug reported by Edgar Fuss.
+	- Fixed Solaris compile problem: removed unecessary and unportable linker
+	  flags that caused compile to fail. Bug reported by Andrés Yacopino.
+
+v0.1.3 12-02-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot
+	  >= 1.2.beta1
+	* Made mail address comparison fully case-insensitive. This is particularly
+	  noticeable for the :addresses argument of the vacation command.
+	+ Finished enotify extension. Currently, only the mailto notification method
+	  is implemented. All still needs to be tested thoroughly.
+	+ Implemented multiscript support. It is now possible to execute multiple
+	  Sieve scripts sequentially. Administrator-controlled scripts can be
+	  executed before and after the user's script. Still needs to be tested
+	  thoroughly.
+	+ Implemented support for configuring the available Sieve extensions.
+	+ Made the subaddress extension (partially) configurable using the
+	  sieve_subaddress_sep setting, which allows specifying a (multi-charater)
+	  separator other than '+'.
+	+ Compiler now warns about invalid header field names used for the header and
+	  address tests.
+	+ Vacation extension now properly generates a References header for the
+	  response message.
+	+ Added testing of basic result execution to the test suite. Also added
+	  supportfor testing the outgoing messages produced by the Sieve interpreter.
+	+ Included execution of the actual result in the sieve-test command line tool.
+	  The undocumented sieve-exec tool that existed for this is now removed as
+	  planned.
+	+ Added support for the now obsolete 'imapflags' extension for backwards
+	  compatibility with CMUSieve. This also implements the mark/unmark commands.
+	- Fixed bugs in the regex extension: 1) if an optional match value did not in
+	  fact match, subsequent match values would get unexpected indexes. 2) fixed
+	  segfault bug occuring when regex is freed.
+	- Fixed bug in the use of the :from agrument for the vacation command. If this
+	  address included a phrase part, the response would not be a valid RFC822
+	  message.
+	- Plugged a theoretical security hole occuring when a directory is opened as a
+	  Sieve binary.
+	- Cleaned up and fixed various log messages.
+	- Fixed bug in the outgoing address verification. Addresses ending in ',' were
+	  erroneously accepted.
+
+v0.1.2 26-11-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	- Fixed important bug in the redirect action (and probably other actions like
+	  reject and vacation that only send messages). This was a bug in the handling
+	  of context information during the execution of actions. It caused the sieve
+	  interpreter to crash with a segfault when redirect was executed.
+
+v0.1.1 24-11-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	* Re-enabled support for compiling against dovecot headers. Much like
+	  cmusieve, command line tools like sievec and sieved are not compiled in this
+	  case.
+	* Started implementation of enotify extension. Not anywhere near finished
+	  though.
+	* Adapted to changes in Dovecot on various occasions, making this release
+	  dependent on Dovecot >= v1.2.alpa4.
+
+	+ Improved logging of errors at specific occasions and added debug messages to
+	  find script execution problems quicker.
+	+ Removed code duplication between command line tools and the test suite.
+	  Also restructured the sources of the tools.
+	+ Added UTF-8 to UTF-7 folder name conversion for compatibility with IMAP.
+	+ Created man pages for the command line tools. These are automatically
+	  installed upon 'make install'
+	+ Incorporated Valgrind support into the testsuite and fixed a few memory
+	  leaks in the process.
+	- Fixed compile error surfacing for gcc3.4. Forgot mask argument for the
+	  open() system call when the O_CREAT flag is specified. Bug found by
+	  Sergey Ivanov.
+	- Fixed bug in the sievec tool. -d output was always written to stdout.
+	- Fixed important bug in the imap4flags extension. When no :flags argument is
+	  specified, the previous version would always use the final value of the
+	  internal variable to set the flags. This means that modifications to the
+	  internal variable also affected the bare fileinto/keep actions executed
+	  earlier. This does not comply to the RFC.
+	- Fixed bug in the include extension's import/export commands. Duplicate
+	  import/exports caused problems.
+	- Fixed bug in the handling of non-existent scripts. Errors were sometimes
+	  ignored.
+	- Dovecot omitted unfolding multi-line headers. This was added to the cmusieve
+	  plugin after the code was incorporated into the new implementation. This is
+	  now mplicitly fixed by concurrent change in Dovecot.
+
+v0.1.0 23-10-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	* Initial release
Index: b/sieve/README
===================================================================
--- /dev/null
+++ b/sieve/README
@@ -0,0 +1,269 @@
+Sieve implementation for Dovecot v1.2
+
+For the most up-to-date information you are referred to the Dovecot wiki:
+
+http://wiki.dovecot.org/LDA/Sieve/Dovecot
+
+Introduction
+------------
+
+Sieve is a machine language specifically tailored for internet message
+filtering. This package compiles into a Sieve plugin for the Dovecot local
+delivery agent called Deliver. The plugin adds Sieve filtering support to the
+delivery process.
+
+Previously, the same functionality was provided by the cmusieve plugin for
+Dovecot. This old plugin is based on the CMU Sieve implementation included with
+the Cyrus project. This new package provides a complete rewrite of the Sieve
+engine integrating it tightly with Dovecot. The actual execution of the Sieve
+actions is based on the original cmusieve plugin, but only on the code added to
+interface the CMU Sieve implementation with Dovocot.
+
+The main reason for rewriting the Sieve engine is to provide more reliable
+script execution and to provide better error messages to users and system
+administrators. Also, since the Sieve language evolves quickly, with new
+language extensions published every year, the aim is to provide support for
+quickly extending the engine with new features.
+
+Features
+--------
+
+* Well-structured 3-stage compiler:
+
+  Uses dovecot framework and avoids using lex/yacc. Compiler doesn't bail on
+  first error, but tries to find more. Produced errors are aimed to be useful
+  and generally user-comprehensible. Things like 'Generic error' are a nuisance
+  of the past.
+
+* Highly extendable with new Sieve capabilities:
+
+  This keeps the possibility of plugins in mind. It should eventually provide
+  the necessary infrastructure for at least all currently known (proposed)
+  extensions. The goal is to keep the extension interface provided by sieve
+  engine as generic as possible, i.e. without explicit support for specific
+  extensions. New similar extensions can then use the same interface methods
+  without changes to the sieve engine code. If an extension is not loaded using
+  the require command, the compiler truly does not know of its existance.
+
+* Supports all extensions provided by the original CMUSieve plugin:
+
+  In addition, it has support for the new and very useful variables extension
+  (see next section).
+
+  NOTE: The original CMUSieve plugin is based on old specifications of the
+  imap4flags and enotify extension. Among other subtle differences, these
+  extensions were known as 'imapflags' and 'notify' for the CMU Sieve plugin.
+  Support for the old imapflags extension is provided for backwards compatibility.
+
+* Supports executing multiple scrips sequentially.
+
+  Using this feature it is possible to execute administrator-controlled Sieve
+  scripts before and after the user's Sieve script is executed. As long as the
+  verdict is at least (implicit) keep, the execution will continue with the next
+  script. Multiple scripts can be executed before or after the user's script by
+  specifying directories containing sieve files.
+
+* Supported by ManageSieve service:
+
+  This Sieve implementation is supported by the ManageSieve implementation for
+  Dovecot v1.2. Therefore, ManageSieve support can be added to Dovecot for the
+  new Sieve plugin just as for the cmusieve plugin.
+
+* Test suite included:
+
+  This package includes a test suite to automatically asses whether the compiled
+  sieve engine works correctly. The test suite is an extension to the Sieve
+  language and is therefore easily extended with new tests. Currently, the
+  test suite is mostly limited to testing script processing. The performed actions
+  are not tested fully yet.
+
+Implementation Status
+---------------------
+
+The the core of the language (as specified in RFC 5228) is fully supported. In
+addition to that, this Sieve implementation features various extensions. The
+following list outlines the implementation status of each supported extension:
+
+  The the core of the language (as specified in RFC 5228) is fully supported,
+  including the language extensions defined in the base specification:
+
+    encoded-character (RFC 5228; page 10)
+    fileinto (RFC 5228; page 23)
+    envelope (RFC 5228; page 27)
+
+  The following Sieve language extensions are also supported:
+
+    copy (RFC 3894): fully supported
+    body (RFC 5173): almost fully supported, but the text body-transform
+      implementation is simple and some issues make it still not completely
+      RFC compliant.
+    environment (RFC 5183): basic support is provided (v0.1.5+)
+    variables (RFC 5229): almost fully supported, but currently no support
+      for namespaces is available (include depends on this)
+    vacation (RFC 5230): fully supported
+    relational (RFC 5231): fully supported
+    imap4flags (RFC 5232): fully supported
+    subaddress (RFC 5233): fully supported, but with limited configurability
+    date (RFC 5260; page 3): fully supported (v0.1.12+)
+    reject (RFC 5429; page 6): fully supported
+    enotify (RFC 5435): fully supported (v0.1.3+), but only the mailto
+      notification mechanism is available
+    mailbox (RFC 5490; page 2): fully supported (v0.1.10+), but
+      ACL permissions are not verified for mailboxexists
+    include (draft): almost fully supported, but the global namespace is
+      missing and the global command is can only be placed at the top of the
+      script
+    regex (draft): almost fully supported, but UTF-8 is not supported.
+
+  The following deprecated extensions are supported for backwards
+  compatibility:
+
+    imapflags (obsolete draft): fully backwards compatible (v0.1.3+)
+    notify (obsolete draft): denotify command is a dummy
+
+    The availability of these deprecated extensions is disabled by default.
+
+  The following extensions are under development:
+
+    ereject (RFC 5429; page 4): implemented, but currently equal to reject
+
+  Many more extensions to the language exist. Not all of these extensions are
+  useful for Dovecot in particular, but many of them are. Currently, the
+  author has taken notice of the following extensions:
+
+    spamtest and virustest (RFC 5235): planned
+    index (RFC 5260; page 7): planned
+    editheader (RFC 5293): planned
+    foreverypart, mime, replace, enclose, and extracttext (RFC 5703): planned
+
+    These extensions will be added as soon as the necessary infrastructure is
+    available.
+
+Compiling and Configuring
+-------------------------
+
+Refer to INSTALL file.
+
+Using
+-----
+
+The main purpose of this package is to replace the existing cmusieve plugin
+that is currently available for Dovecot's deliver. With respect to its main
+functionalityit is currently not very different from the cmusieve plugin
+implementation.
+
+However, unlike cmusieve, this sieve module logs runtime errors to
+<scriptfile>.log if it can and not <scriptfile>.err. Also, the cmusieve plugin
+compiled the script into a file with an appended 'c', e.g. 'test.sievec'.
+This new implementation recognizes scripts to have the .sieve  extension.
+The binary is (by default) written to a file with extension .svbin. This is
+explained further in section `Script Compiling' below.
+
+To test the sieve engine outside deliver, it is useful to try the commands that
+exist in the src/sieve-tools/ directory of this package. After installation,
+these are available at your $prefix/bin directory. The following commands are
+installed:
+
+sievec     - Compiles sieve scripts into a binary representation for later
+             execution. Refer to `Script Compiling' section below.
+
+sieve-test - This is a universal Sieve test tool for testing the effect of a
+             Sieve script on a particular message. It allows compiling, running
+             and testing Sieve scripts. It can either be used to display the
+             actions that would be performed on the provided test message or it
+             can be used to test the actual delivery of the message and show the
+             messages that would normally be sent through SMTP.
+
+sieved     - Dumps the content of a Sieve binary file for (development)
+             debugging purposes.
+
+When installed, man pages are also available for these commands. In this package
+the man pages are present in doc/man and can be viewed before install using
+e.g.:
+
+man -l doc/man/sieve-test.1
+
+Various example scripts are bundled in the directory 'examples'. These scripts
+were downloaded from various locations. View the top comment in the scripts for
+url and author information.
+
+Script Compiling
+----------------
+
+When the Sieve plugin executes a script for the first time (or after it has been
+changed), it's compiled into into a binary form. Dovecot Sieve implementation
+uses the .svbin extension to store compiled Sieve scripts (e.g. .dovecot.svbin).
+To store the binary, the plugin needs write access in the directory in which the
+script is located.
+
+A problem occurs when a global script is encountered by the plugin. For security
+reasons, global script directories are not supposed to be writable by the user.
+Therefore, the plugin cannot store the binary when the script is first compiled.
+Note that this doesn't mean that the old compiled version of the script is used
+when the binary cannot be written: it compiles and uses the current script
+version. The only real problem is that the plugin will not be able to update
+the binary on disk, meaning that the global script needs to be recompiled each
+time it needs to be executed, i.e. for every incoming message, which is
+inefficient.
+
+To mitigate this problem, the administrator must manually pre-compile global
+scripts using the sievec command line tool. For example:
+
+sievec /var/lib/dovecot/sieve/global/
+
+This is necessary for scripts listed in the sieve_global_path, sieve_before and
+sieve_after settings. For global scripts that are only included in other scripts
+using the include extension, this step is not necessary, since included scripts
+are incorporated into the binary produced for the main script.
+
+When manually compiling scripts with sievec, if those scripts use the include
+sieve extension and your sieve_dir is not the sieve subfolder of the directory
+of the main file, you can specify it by defining the SIEVE_DIR environment
+variable (e.g SIEVE_DIR=~/.sieve sievec .dovecot.sieve )
+
+Compile and Runtime Logging
+---------------------------
+
+Log messages produced at runtime by the Sieve plugin are written to two
+locations:
+
+  * A log file is written in the same directory as the user's main private
+    script (as specified by the sieve setting). This log file bears the name of
+    that script file appended with ".log", e.g. .dovecot.sieve.log. If there are
+    errors or warnings in the script, the messages are appended to that log file
+    until it eventually grows too large. When that happens, the old log file is
+    rotated to a ".log.0" file and an empty log file is started. Informational
+    messages are not written to this log file and the log file is not created
+    until messages are actually logged, i.e. when an error or warning is
+    produced.
+
+  * Messages that could be of interest to the system administrator are also
+    written to the Dovecot logging facility (usually syslog). This includes
+    informational messages that indicate what actions are executed on incoming
+    messages. Compile errors encountered in the user's private script are not
+    logged here.
+
+Known issues
+------------
+
+Most open issues are outlined in the TODO file. The more generic ones are (re-)
+listed here:
+
+- Compile errors are sometimes a bit obscure and long. This needs work.
+  Suggestions for improvement are welcome.
+- The documentation needs work.
+
+Authors
+-------
+
+Refer to AUTHORS file.
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about
+this package. You can post to the list without subscribing, the mail then waits
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
Index: b/sieve/TODO
===================================================================
--- /dev/null
+++ b/sieve/TODO
@@ -0,0 +1,100 @@
+Current activities:
+
+* Finish body extension:
+	- Implement proper :content "multipart" behavior
+	- Implement proper :content "message/rfc822" behavior
+	- Build test cases for decoding MIME encodings to UTF-8
+* Finish ereject extension
+* Build a sieve tool to filter an entire existing mailbox through a Sieve
+  script:
+	- Add commandline options to fully customize execution
+	- Write manual page
+
+Next (in order of descending priority/precedence):
+
+* Implement namespace support for variables extension (to complete include
+  extension)
+* Update include extension to latest draft:
+	- Perform script name check
+	- Implement global namespace
+	- Allow placing the global command anywhere in the script
+	- Implement required ManageSieve behavior
+* Implement mechanism for implicitly including an account's aliases in the
+  vacation command's :addresses list.
+* Improve error handling. Now it is not very consistent, especially for the
+  Sieve command line tools.
+* Detect permission errors when writing global script binaries and advise the
+  administrator on using sievec to precompile the scripts.
+* Improve debugging support in the sieve-test tool:
+	- Improve trace debugging towards something more intuitively readable.
+	- Give trace debugging multiple levels of verbosity (e.g. to include more
+    messy output like value matching).
+* Implement dropping errors in the user's mailbox as a mail message.
+* Implement a better way to encode source line numbers into a binary for
+  reporting errors at runtime. Currently, this is done explicitly for each
+  command that adds actions to the result. However, some tests, match types etc.
+  will also need this when the variables extension is active. Many of the RFC
+  deviations listed below depend on this. Also trace debugging will benefit.
+* Fix remaining RFC deviations:
+	- Fix issues listed in doc/rfc/RFC-questions.txt based on answers
+	- Allow for the existance of dynamic comparators (i.e. specified by
+	  variables).
+	- Allow for :regex matching with variable key.
+	- Detect assignment of too large constant values to variables at compile
+	  time.
+	- Verify outgoing mail addresses at runtime when necessary
+	  (e.g. after variables substitution)
+	- Body: handling of :content "multipart" and :content "message/rfc822" don't
+	  work.
+	- Improve handling of invalid addresses in headers (requires Dovecot changes)
+* Add normalize() method to comparators to normalize the string before matching
+  (for efficiency).
+* Properly implement Sieve internationalization support (utf-8 handling),
+  currently it is not complete:
+	- Make this implementation fully conform section 2.7.2 of RFC5228 (Comparisons
+	  Across Character Sets).
+	- Verify validity of utf8 where necessary.
+	- Implement comparator-i;unicode-casemap.
+* Make testsuite much more exhaustive:
+	- Add support for testing the content of result actions
+	- Test as many error/warning/info conditions as possible.
+	- Review the specification documents and check whether the given conditions
+	  are tested at least once.
+* Code cleanup:
+	- Make address handling more uniform.
+	- Review all FIXMEs
+
+* Build a server with test mail accounts that processes lots and lots of mail
+  (e.g. spam, mailing lists etc.)
+
+* ## MAKE A SECOND RELEASE (0.2.x) ##
+
+* Add support for stream matching for handling large values, e.g. from the body
+  extension.
+* Provide a solution for mail_get_headers_utf8 reparsing the whole message each
+  time it is called (header and address test; Timo might provide solution from
+  within Dovecot)
+* Optimize code containing true/false tests to omit explicit JMP opcodes
+  (i.e. optimize the test away and any code that negatively depends on it)
+* Use lib/str-find.h for :contains and :matches match types
+* Warn during compile if using non-existent folders.
+* Implement index extension
+* Enotify extension: detect use of variable values extracted from the message
+  that are used in the method argument. RFC reports this as a security issue.
+* Implement editheader extension
+* Implement mimeloop extension
+* Import ManageSieve into this package and provide support for alternate types
+  of script storage like LDAP or SQL database.
+
+* Implement IMAP plugin for IMAPSieve support:
+	- This may include support for manually running a script on a set of messages
+	  through IMAP (no specification for something like this is available; we will
+	  have to provide our own)
+* Variables extension: implement compile time evaluation of constant values
+* Add development documentation, i.e. comment on library functions and document
+  the binary and byte-code format.
+* Give the byte code format some more thought, it is currently quite rough and
+  to the point.
+* Implement proposed notify mechanisms other than mailto. Currently defined:
+  xmpp and sip
+
Index: b/sieve/aclocal.m4
===================================================================
--- /dev/null
+++ b/sieve/aclocal.m4
@@ -0,0 +1,8957 @@
+# generated automatically by aclocal 1.11 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.65],,
+[m4_warning([this file was generated for autoconf 2.65.
+You have another version of autoconf.  It may work, but is not guaranteed to.
+If you have problems, you may need to regenerate the build system entirely.
+To do so, use the procedure documented by the package, typically `autoreconf'.])])
+
+# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+m4_define([_LT_COPYING], [dnl
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+])
+
+# serial 56 LT_INIT
+
+
+# LT_PREREQ(VERSION)
+# ------------------
+# Complain and exit if this libtool version is less that VERSION.
+m4_defun([LT_PREREQ],
+[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,
+       [m4_default([$3],
+		   [m4_fatal([Libtool version $1 or higher is required],
+		             63)])],
+       [$2])])
+
+
+# _LT_CHECK_BUILDDIR
+# ------------------
+# Complain if the absolute build directory name contains unusual characters
+m4_defun([_LT_CHECK_BUILDDIR],
+[case `pwd` in
+  *\ * | *\	*)
+    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;
+esac
+])
+
+
+# LT_INIT([OPTIONS])
+# ------------------
+AC_DEFUN([LT_INIT],
+[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT
+AC_BEFORE([$0], [LT_LANG])dnl
+AC_BEFORE([$0], [LT_OUTPUT])dnl
+AC_BEFORE([$0], [LTDL_INIT])dnl
+m4_require([_LT_CHECK_BUILDDIR])dnl
+
+dnl Autoconf doesn't catch unexpanded LT_ macros by default:
+m4_pattern_forbid([^_?LT_[A-Z_]+$])dnl
+m4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl
+dnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4
+dnl unless we require an AC_DEFUNed macro:
+AC_REQUIRE([LTOPTIONS_VERSION])dnl
+AC_REQUIRE([LTSUGAR_VERSION])dnl
+AC_REQUIRE([LTVERSION_VERSION])dnl
+AC_REQUIRE([LTOBSOLETE_VERSION])dnl
+m4_require([_LT_PROG_LTMAIN])dnl
+
+dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)dnl
+
+_LT_SETUP
+
+# Only expand once:
+m4_define([LT_INIT])
+])# LT_INIT
+
+# Old names:
+AU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])
+AU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PROG_LIBTOOL], [])
+dnl AC_DEFUN([AM_PROG_LIBTOOL], [])
+
+
+# _LT_CC_BASENAME(CC)
+# -------------------
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+m4_defun([_LT_CC_BASENAME],
+[for cc_temp in $1""; do
+  case $cc_temp in
+    compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
+    distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+])
+
+
+# _LT_FILEUTILS_DEFAULTS
+# ----------------------
+# It is okay to use these file commands and assume they have been set
+# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.
+m4_defun([_LT_FILEUTILS_DEFAULTS],
+[: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+])# _LT_FILEUTILS_DEFAULTS
+
+
+# _LT_SETUP
+# ---------
+m4_defun([_LT_SETUP],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+_LT_DECL([], [host_alias], [0], [The host system])dnl
+_LT_DECL([], [host], [0])dnl
+_LT_DECL([], [host_os], [0])dnl
+dnl
+_LT_DECL([], [build_alias], [0], [The build system])dnl
+_LT_DECL([], [build], [0])dnl
+_LT_DECL([], [build_os], [0])dnl
+dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+dnl
+AC_REQUIRE([AC_PROG_LN_S])dnl
+test -z "$LN_S" && LN_S="ln -s"
+_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl
+dnl
+AC_REQUIRE([LT_CMD_MAX_LEN])dnl
+_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally "o")])dnl
+_LT_DECL([], [exeext], [0], [Executable file suffix (normally "")])dnl
+dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+m4_require([_LT_CMD_RELOAD])dnl
+m4_require([_LT_CHECK_MAGIC_METHOD])dnl
+m4_require([_LT_CMD_OLD_ARCHIVE])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+
+_LT_CONFIG_LIBTOOL_INIT([
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+])
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+_LT_CHECK_OBJDIR
+
+m4_require([_LT_TAG_COMPILER])dnl
+_LT_PROG_ECHO_BACKSLASH
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+sed_quote_subst='s/\([["`$\\]]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([["`\\]]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+_LT_CC_BASENAME([$compiler])
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    _LT_PATH_MAGIC
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+LT_SUPPORTED_TAG([CC])
+_LT_LANG_C_CONFIG
+_LT_LANG_DEFAULT_CONFIG
+_LT_CONFIG_COMMANDS
+])# _LT_SETUP
+
+
+# _LT_PROG_LTMAIN
+# ---------------
+# Note that this code is called both from `configure', and `config.status'
+# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,
+# `config.status' has no value for ac_aux_dir unless we are using Automake,
+# so we pass a copy along to make sure it has a sensible value anyway.
+m4_defun([_LT_PROG_LTMAIN],
+[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl
+_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
+ltmain="$ac_aux_dir/ltmain.sh"
+])# _LT_PROG_LTMAIN
+
+
+
+# So that we can recreate a full libtool script including additional
+# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS
+# in macros and then make a single call at the end using the `libtool'
+# label.
+
+
+# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])
+# ----------------------------------------
+# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL_INIT],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_INIT])
+
+
+# _LT_CONFIG_LIBTOOL([COMMANDS])
+# ------------------------------
+# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])
+
+
+# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])
+# -----------------------------------------------------
+m4_defun([_LT_CONFIG_SAVE_COMMANDS],
+[_LT_CONFIG_LIBTOOL([$1])
+_LT_CONFIG_LIBTOOL_INIT([$2])
+])
+
+
+# _LT_FORMAT_COMMENT([COMMENT])
+# -----------------------------
+# Add leading comment marks to the start of each line, and a trailing
+# full-stop to the whole comment if one is not present already.
+m4_define([_LT_FORMAT_COMMENT],
+[m4_ifval([$1], [
+m4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],
+              [['`$\]], [\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])
+)])
+
+
+
+
+
+# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])
+# -------------------------------------------------------------------
+# CONFIGNAME is the name given to the value in the libtool script.
+# VARNAME is the (base) name used in the configure script.
+# VALUE may be 0, 1 or 2 for a computed quote escaped value based on
+# VARNAME.  Any other value will be used directly.
+m4_define([_LT_DECL],
+[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],
+    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],
+	[m4_ifval([$1], [$1], [$2])])
+    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])
+    m4_ifval([$4],
+	[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])
+    lt_dict_add_subkey([lt_decl_dict], [$2],
+	[tagged?], [m4_ifval([$5], [yes], [no])])])
+])
+
+
+# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])
+# --------------------------------------------------------
+m4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])
+
+
+# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_tag_varnames],
+[_lt_decl_filter([tagged?], [yes], $@)])
+
+
+# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])
+# ---------------------------------------------------------
+m4_define([_lt_decl_filter],
+[m4_case([$#],
+  [0], [m4_fatal([$0: too few arguments: $#])],
+  [1], [m4_fatal([$0: too few arguments: $#: $1])],
+  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],
+  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],
+  [lt_dict_filter([lt_decl_dict], $@)])[]dnl
+])
+
+
+# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])
+# --------------------------------------------------
+m4_define([lt_decl_quote_varnames],
+[_lt_decl_filter([value], [1], $@)])
+
+
+# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_dquote_varnames],
+[_lt_decl_filter([value], [2], $@)])
+
+
+# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_varnames_tagged],
+[m4_assert([$# <= 2])dnl
+_$0(m4_quote(m4_default([$1], [[, ]])),
+    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),
+    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])
+m4_define([_lt_decl_varnames_tagged],
+[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])
+
+
+# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_all_varnames],
+[_$0(m4_quote(m4_default([$1], [[, ]])),
+     m4_if([$2], [],
+	   m4_quote(lt_decl_varnames),
+	m4_quote(m4_shift($@))))[]dnl
+])
+m4_define([_lt_decl_all_varnames],
+[lt_join($@, lt_decl_varnames_tagged([$1],
+			lt_decl_tag_varnames([[, ]], m4_shift($@))))dnl
+])
+
+
+# _LT_CONFIG_STATUS_DECLARE([VARNAME])
+# ------------------------------------
+# Quote a variable value, and forward it to `config.status' so that its
+# declaration there will have the same value as in `configure'.  VARNAME
+# must have a single quote delimited value for this to work.
+m4_define([_LT_CONFIG_STATUS_DECLARE],
+[$1='`$ECHO "X$][$1" | $Xsed -e "$delay_single_quote_subst"`'])
+
+
+# _LT_CONFIG_STATUS_DECLARATIONS
+# ------------------------------
+# We delimit libtool config variables with single quotes, so when
+# we write them to config.status, we have to be sure to quote all
+# embedded single quotes properly.  In configure, this macro expands
+# each variable declared with _LT_DECL (and _LT_TAGDECL) into:
+#
+#    <var>='`$ECHO "X$<var>" | $Xsed -e "$delay_single_quote_subst"`'
+m4_defun([_LT_CONFIG_STATUS_DECLARATIONS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),
+    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAGS
+# ----------------
+# Output comment and list of tags supported by the script
+m4_defun([_LT_LIBTOOL_TAGS],
+[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl
+available_tags="_LT_TAGS"dnl
+])
+
+
+# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])
+# -----------------------------------
+# Extract the dictionary values for VARNAME (optionally with TAG) and
+# expand to a commented shell variable setting:
+#
+#    # Some comment about what VAR is for.
+#    visible_name=$lt_internal_name
+m4_define([_LT_LIBTOOL_DECLARE],
+[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],
+					   [description])))[]dnl
+m4_pushdef([_libtool_name],
+    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl
+m4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),
+    [0], [_libtool_name=[$]$1],
+    [1], [_libtool_name=$lt_[]$1],
+    [2], [_libtool_name=$lt_[]$1],
+    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl
+m4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl
+])
+
+
+# _LT_LIBTOOL_CONFIG_VARS
+# -----------------------
+# Produce commented declarations of non-tagged libtool config variables
+# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'
+# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG
+# section) are produced by _LT_LIBTOOL_TAG_VARS.
+m4_defun([_LT_LIBTOOL_CONFIG_VARS],
+[m4_foreach([_lt_var],
+    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAG_VARS(TAG)
+# -------------------------
+m4_define([_LT_LIBTOOL_TAG_VARS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])
+
+
+# _LT_TAGVAR(VARNAME, [TAGNAME])
+# ------------------------------
+m4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])
+
+
+# _LT_CONFIG_COMMANDS
+# -------------------
+# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of
+# variables for single and double quote escaping we saved from calls
+# to _LT_DECL, we can put quote escaped variables declarations
+# into `config.status', and then the shell code to quote escape them in
+# for loops in `config.status'.  Finally, any additional code accumulated
+# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
+m4_defun([_LT_CONFIG_COMMANDS],
+[AC_PROVIDE_IFELSE([LT_OUTPUT],
+	dnl If the libtool generation code has been placed in $CONFIG_LT,
+	dnl instead of duplicating it all over again into config.status,
+	dnl then we will have config.status run $CONFIG_LT later, so it
+	dnl needs to know what name is stored there:
+        [AC_CONFIG_COMMANDS([libtool],
+            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],
+    dnl If the libtool generation code is destined for config.status,
+    dnl expand the accumulated commands and init code now:
+    [AC_CONFIG_COMMANDS([libtool],
+        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])
+])#_LT_CONFIG_COMMANDS
+
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],
+[
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+_LT_CONFIG_STATUS_DECLARATIONS
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# Quote evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_quote_varnames); do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_dquote_varnames); do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Fix-up fallback echo if it was mangled by the above quoting rules.
+case \$lt_ECHO in
+*'\\\[$]0 --fallback-echo"')dnl "
+  lt_ECHO=\`\$ECHO "X\$lt_ECHO" | \$Xsed -e 's/\\\\\\\\\\\\\\\[$]0 --fallback-echo"\[$]/\[$]0 --fallback-echo"/'\`
+  ;;
+esac
+
+_LT_OUTPUT_LIBTOOL_INIT
+])
+
+
+# LT_OUTPUT
+# ---------
+# This macro allows early generation of the libtool script (before
+# AC_OUTPUT is called), incase it is used in configure for compilation
+# tests.
+AC_DEFUN([LT_OUTPUT],
+[: ${CONFIG_LT=./config.lt}
+AC_MSG_NOTICE([creating $CONFIG_LT])
+cat >"$CONFIG_LT" <<_LTEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate a libtool stub with the current configuration.
+
+lt_cl_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AS_SHELL_SANITIZE
+_AS_PREPARE
+
+exec AS_MESSAGE_FD>&1
+exec AS_MESSAGE_LOG_FD>>config.log
+{
+  echo
+  AS_BOX([Running $as_me.])
+} >&AS_MESSAGE_LOG_FD
+
+lt_cl_help="\
+\`$as_me' creates a local libtool stub from the current configuration,
+for use in further configure time tests before the real libtool is
+generated.
+
+Usage: $[0] [[OPTIONS]]
+
+  -h, --help      print this help, then exit
+  -V, --version   print version number, then exit
+  -q, --quiet     do not print progress messages
+  -d, --debug     don't remove temporary files
+
+Report bugs to <bug-libtool@gnu.org>."
+
+lt_cl_version="\
+m4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl
+m4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])
+configured by $[0], generated by m4_PACKAGE_STRING.
+
+Copyright (C) 2008 Free Software Foundation, Inc.
+This config.lt script is free software; the Free Software Foundation
+gives unlimited permision to copy, distribute and modify it."
+
+while test $[#] != 0
+do
+  case $[1] in
+    --version | --v* | -V )
+      echo "$lt_cl_version"; exit 0 ;;
+    --help | --h* | -h )
+      echo "$lt_cl_help"; exit 0 ;;
+    --debug | --d* | -d )
+      debug=: ;;
+    --quiet | --q* | --silent | --s* | -q )
+      lt_cl_silent=: ;;
+
+    -*) AC_MSG_ERROR([unrecognized option: $[1]
+Try \`$[0] --help' for more information.]) ;;
+
+    *) AC_MSG_ERROR([unrecognized argument: $[1]
+Try \`$[0] --help' for more information.]) ;;
+  esac
+  shift
+done
+
+if $lt_cl_silent; then
+  exec AS_MESSAGE_FD>/dev/null
+fi
+_LTEOF
+
+cat >>"$CONFIG_LT" <<_LTEOF
+_LT_OUTPUT_LIBTOOL_COMMANDS_INIT
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AC_MSG_NOTICE([creating $ofile])
+_LT_OUTPUT_LIBTOOL_COMMANDS
+AS_EXIT(0)
+_LTEOF
+chmod +x "$CONFIG_LT"
+
+# configure is writing to config.log, but config.lt does its own redirection,
+# appending to config.log, which fails on DOS, as config.log is still kept
+# open by configure.  Here we exec the FD to /dev/null, effectively closing
+# config.log, so it can be properly (re)opened and appended to by config.lt.
+if test "$no_create" != yes; then
+  lt_cl_success=:
+  test "$silent" = yes &&
+    lt_config_lt_args="$lt_config_lt_args --quiet"
+  exec AS_MESSAGE_LOG_FD>/dev/null
+  $SHELL "$CONFIG_LT" $lt_config_lt_args || lt_cl_success=false
+  exec AS_MESSAGE_LOG_FD>>config.log
+  $lt_cl_success || AS_EXIT(1)
+fi
+])# LT_OUTPUT
+
+
+# _LT_CONFIG(TAG)
+# ---------------
+# If TAG is the built-in tag, create an initial libtool script with a
+# default configuration from the untagged config vars.  Otherwise add code
+# to config.status for appending the configuration named by TAG from the
+# matching tagged config vars.
+m4_defun([_LT_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_CONFIG_SAVE_COMMANDS([
+  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl
+  m4_if(_LT_TAG, [C], [
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+_LT_COPYING
+_LT_LIBTOOL_TAGS
+
+# ### BEGIN LIBTOOL CONFIG
+_LT_LIBTOOL_CONFIG_VARS
+_LT_LIBTOOL_TAG_VARS
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+  _LT_PROG_LTMAIN
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  _LT_PROG_XSI_SHELLFNS
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+],
+[cat <<_LT_EOF >> "$ofile"
+
+dnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded
+dnl in a comment (ie after a #).
+# ### BEGIN LIBTOOL TAG CONFIG: $1
+_LT_LIBTOOL_TAG_VARS(_LT_TAG)
+# ### END LIBTOOL TAG CONFIG: $1
+_LT_EOF
+])dnl /m4_if
+],
+[m4_if([$1], [], [
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'], [])
+])dnl /_LT_CONFIG_SAVE_COMMANDS
+])# _LT_CONFIG
+
+
+# LT_SUPPORTED_TAG(TAG)
+# ---------------------
+# Trace this macro to discover what tags are supported by the libtool
+# --tag option, using:
+#    autoconf --trace 'LT_SUPPORTED_TAG:$1'
+AC_DEFUN([LT_SUPPORTED_TAG], [])
+
+
+# C support is built-in for now
+m4_define([_LT_LANG_C_enabled], [])
+m4_define([_LT_TAGS], [])
+
+
+# LT_LANG(LANG)
+# -------------
+# Enable libtool support for the given language if not already enabled.
+AC_DEFUN([LT_LANG],
+[AC_BEFORE([$0], [LT_OUTPUT])dnl
+m4_case([$1],
+  [C],			[_LT_LANG(C)],
+  [C++],		[_LT_LANG(CXX)],
+  [Java],		[_LT_LANG(GCJ)],
+  [Fortran 77],		[_LT_LANG(F77)],
+  [Fortran],		[_LT_LANG(FC)],
+  [Windows Resource],	[_LT_LANG(RC)],
+  [m4_ifdef([_LT_LANG_]$1[_CONFIG],
+    [_LT_LANG($1)],
+    [m4_fatal([$0: unsupported language: "$1"])])])dnl
+])# LT_LANG
+
+
+# _LT_LANG(LANGNAME)
+# ------------------
+m4_defun([_LT_LANG],
+[m4_ifdef([_LT_LANG_]$1[_enabled], [],
+  [LT_SUPPORTED_TAG([$1])dnl
+  m4_append([_LT_TAGS], [$1 ])dnl
+  m4_define([_LT_LANG_]$1[_enabled], [])dnl
+  _LT_LANG_$1_CONFIG($1)])dnl
+])# _LT_LANG
+
+
+# _LT_LANG_DEFAULT_CONFIG
+# -----------------------
+m4_defun([_LT_LANG_DEFAULT_CONFIG],
+[AC_PROVIDE_IFELSE([AC_PROG_CXX],
+  [LT_LANG(CXX)],
+  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_F77],
+  [LT_LANG(F77)],
+  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_FC],
+  [LT_LANG(FC)],
+  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])
+
+dnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal
+dnl pulling things in needlessly.
+AC_PROVIDE_IFELSE([AC_PROG_GCJ],
+  [LT_LANG(GCJ)],
+  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],
+    [LT_LANG(GCJ)],
+    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],
+      [LT_LANG(GCJ)],
+      [m4_ifdef([AC_PROG_GCJ],
+	[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([A][M_PROG_GCJ],
+	[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([LT_PROG_GCJ],
+	[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])
+
+AC_PROVIDE_IFELSE([LT_PROG_RC],
+  [LT_LANG(RC)],
+  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])
+])# _LT_LANG_DEFAULT_CONFIG
+
+# Obsolete macros:
+AU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])
+AU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])
+AU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])
+AU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_CXX], [])
+dnl AC_DEFUN([AC_LIBTOOL_F77], [])
+dnl AC_DEFUN([AC_LIBTOOL_FC], [])
+dnl AC_DEFUN([AC_LIBTOOL_GCJ], [])
+
+
+# _LT_TAG_COMPILER
+# ----------------
+m4_defun([_LT_TAG_COMPILER],
+[AC_REQUIRE([AC_PROG_CC])dnl
+
+_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl
+_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl
+_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl
+_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+])# _LT_TAG_COMPILER
+
+
+# _LT_COMPILER_BOILERPLATE
+# ------------------------
+# Check for compiler boilerplate output or warnings with
+# the simple compiler test code.
+m4_defun([_LT_COMPILER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+])# _LT_COMPILER_BOILERPLATE
+
+
+# _LT_LINKER_BOILERPLATE
+# ----------------------
+# Check for linker boilerplate output or warnings with
+# the simple link test code.
+m4_defun([_LT_LINKER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+])# _LT_LINKER_BOILERPLATE
+
+# _LT_REQUIRED_DARWIN_CHECKS
+# -------------------------
+m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
+  case $host_os in
+    rhapsody* | darwin*)
+    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])
+    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])
+    AC_CHECK_TOOL([LIPO], [lipo], [:])
+    AC_CHECK_TOOL([OTOOL], [otool], [:])
+    AC_CHECK_TOOL([OTOOL64], [otool64], [:])
+    _LT_DECL([], [DSYMUTIL], [1],
+      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])
+    _LT_DECL([], [NMEDIT], [1],
+      [Tool to change global to local symbols on Mac OS X])
+    _LT_DECL([], [LIPO], [1],
+      [Tool to manipulate fat objects and archives on Mac OS X])
+    _LT_DECL([], [OTOOL], [1],
+      [ldd/readelf like tool for Mach-O binaries on Mac OS X])
+    _LT_DECL([], [OTOOL64], [1],
+      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])
+
+    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
+      [lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&AS_MESSAGE_LOG_FD
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi])
+    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
+      [lt_cv_ld_exported_symbols_list],
+      [lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+	[lt_cv_ld_exported_symbols_list=yes],
+	[lt_cv_ld_exported_symbols_list=no])
+	LDFLAGS="$save_LDFLAGS"
+    ])
+    case $host_os in
+    rhapsody* | darwin1.[[012]])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[[012]]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+])
+
+
+# _LT_DARWIN_LINKER_FEATURES
+# --------------------------
+# Checks for linker and compiler features on darwin
+m4_defun([_LT_DARWIN_LINKER_FEATURES],
+[
+  m4_require([_LT_REQUIRED_DARWIN_CHECKS])
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_automatic, $1)=yes
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=''
+  _LT_TAGVAR(link_all_deplibs, $1)=yes
+  _LT_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=echo
+    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    m4_if([$1], [CXX],
+[   if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+],[])
+  else
+  _LT_TAGVAR(ld_shlibs, $1)=no
+  fi
+])
+
+# _LT_SYS_MODULE_PATH_AIX
+# -----------------------
+# Links a minimal program and checks the executable
+# for the system default hardcoded library path. In most cases,
+# this is /usr/lib:/lib, but when the MPI compilers are used
+# the location of the communication and MPI libs are included too.
+# If we don't find anything, use the default library path according
+# to the aix ld manual.
+m4_defun([_LT_SYS_MODULE_PATH_AIX],
+[m4_require([_LT_DECL_SED])dnl
+AC_LINK_IFELSE(AC_LANG_PROGRAM,[
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi],[])
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+])# _LT_SYS_MODULE_PATH_AIX
+
+
+# _LT_SHELL_INIT(ARG)
+# -------------------
+m4_define([_LT_SHELL_INIT],
+[ifdef([AC_DIVERSION_NOTICE],
+	     [AC_DIVERT_PUSH(AC_DIVERSION_NOTICE)],
+	 [AC_DIVERT_PUSH(NOTICE)])
+$1
+AC_DIVERT_POP
+])# _LT_SHELL_INIT
+
+
+# _LT_PROG_ECHO_BACKSLASH
+# -----------------------
+# Add some code to the start of the generated configure script which
+# will find an echo command which doesn't interpret backslashes.
+m4_defun([_LT_PROG_ECHO_BACKSLASH],
+[_LT_SHELL_INIT([
+# Check that we are running under the correct shell.
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+case X$lt_ECHO in
+X*--fallback-echo)
+  # Remove one level of quotation (which was required for Make).
+  ECHO=`echo "$lt_ECHO" | sed 's,\\\\\[$]\\[$]0,'[$]0','`
+  ;;
+esac
+
+ECHO=${lt_ECHO-echo}
+if test "X[$]1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X[$]1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' ; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell.
+  exec $SHELL "[$]0" --no-reexec ${1+"[$]@"}
+fi
+
+if test "X[$]1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<_LT_EOF
+[$]*
+_LT_EOF
+  exit 0
+fi
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test -z "$lt_ECHO"; then
+  if test "X${echo_test_string+set}" != Xset; then
+    # find a string as large as possible, as long as the shell can cope with it
+    for cmd in 'sed 50q "[$]0"' 'sed 20q "[$]0"' 'sed 10q "[$]0"' 'sed 2q "[$]0"' 'echo test'; do
+      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&
+	 { test "X$echo_test_string" = "X$echo_test_string"; } 2>/dev/null
+      then
+        break
+      fi
+    done
+  fi
+
+  if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+     echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+     test "X$echo_testing_string" = "X$echo_test_string"; then
+    :
+  else
+    # The Solaris, AIX, and Digital Unix default echo programs unquote
+    # backslashes.  This makes it impossible to quote backslashes using
+    #   echo "$something" | sed 's/\\/\\\\/g'
+    #
+    # So, first we look for a working echo in the user's PATH.
+
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for dir in $PATH /usr/ucb; do
+      IFS="$lt_save_ifs"
+      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+         test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        ECHO="$dir/echo"
+        break
+      fi
+    done
+    IFS="$lt_save_ifs"
+
+    if test "X$ECHO" = Xecho; then
+      # We didn't find a better echo, so look for alternatives.
+      if test "X`{ print -r '\t'; } 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`{ print -r "$echo_test_string"; } 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        # This shell has a builtin print -r that does the trick.
+        ECHO='print -r'
+      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&
+	   test "X$CONFIG_SHELL" != X/bin/ksh; then
+        # If we have ksh, try running configure again with it.
+        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+        export ORIGINAL_CONFIG_SHELL
+        CONFIG_SHELL=/bin/ksh
+        export CONFIG_SHELL
+        exec $CONFIG_SHELL "[$]0" --no-reexec ${1+"[$]@"}
+      else
+        # Try using printf.
+        ECHO='printf %s\n'
+        if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+	   echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	  # Cool, printf works
+	  :
+        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "[$]0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($ORIGINAL_CONFIG_SHELL "[$]0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	  export CONFIG_SHELL
+	  SHELL="$CONFIG_SHELL"
+	  export SHELL
+	  ECHO="$CONFIG_SHELL [$]0 --fallback-echo"
+        elif echo_testing_string=`($CONFIG_SHELL "[$]0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($CONFIG_SHELL "[$]0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  ECHO="$CONFIG_SHELL [$]0 --fallback-echo"
+        else
+	  # maybe with a smaller string...
+	  prev=:
+
+	  for cmd in 'echo test' 'sed 2q "[$]0"' 'sed 10q "[$]0"' 'sed 20q "[$]0"' 'sed 50q "[$]0"'; do
+	    if { test "X$echo_test_string" = "X`eval $cmd`"; } 2>/dev/null
+	    then
+	      break
+	    fi
+	    prev="$cmd"
+	  done
+
+	  if test "$prev" != 'sed 50q "[$]0"'; then
+	    echo_test_string=`eval $prev`
+	    export echo_test_string
+	    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "[$]0" ${1+"[$]@"}
+	  else
+	    # Oops.  We lost completely, so just stick with echo.
+	    ECHO=echo
+	  fi
+        fi
+      fi
+    fi
+  fi
+fi
+
+# Copy echo and quote the copy suitably for passing to libtool from
+# the Makefile, instead of quoting the original, which is used later.
+lt_ECHO=$ECHO
+if test "X$lt_ECHO" = "X$CONFIG_SHELL [$]0 --fallback-echo"; then
+   lt_ECHO="$CONFIG_SHELL \\\$\[$]0 --fallback-echo"
+fi
+
+AC_SUBST(lt_ECHO)
+])
+_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])
+_LT_DECL([], [ECHO], [1],
+    [An echo program that does not interpret backslashes])
+])# _LT_PROG_ECHO_BACKSLASH
+
+
+# _LT_ENABLE_LOCK
+# ---------------
+m4_defun([_LT_ENABLE_LOCK],
+[AC_ARG_ENABLE([libtool-lock],
+  [AS_HELP_STRING([--disable-libtool-lock],
+    [avoid locking (might break parallel builds)])])
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '[#]line __oline__ "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_i386"
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
+    [AC_LANG_PUSH(C)
+     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])
+     AC_LANG_POP])
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+])# _LT_ENABLE_LOCK
+
+
+# _LT_CMD_OLD_ARCHIVE
+# -------------------
+m4_defun([_LT_CMD_OLD_ARCHIVE],
+[AC_CHECK_TOOL(AR, ar, false)
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+_LT_DECL([], [AR], [1], [The archiver])
+_LT_DECL([], [AR_FLAGS], [1])
+
+AC_CHECK_TOOL(STRIP, strip, :)
+test -z "$STRIP" && STRIP=:
+_LT_DECL([], [STRIP], [1], [A symbol stripping program])
+
+AC_CHECK_TOOL(RANLIB, ranlib, :)
+test -z "$RANLIB" && RANLIB=:
+_LT_DECL([], [RANLIB], [1],
+    [Commands used to install an old-style archive])
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+_LT_DECL([], [old_postinstall_cmds], [2])
+_LT_DECL([], [old_postuninstall_cmds], [2])
+_LT_TAGDECL([], [old_archive_cmds], [2],
+    [Commands used to build an old-style archive])
+])# _LT_CMD_OLD_ARCHIVE
+
+
+# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#		[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------------------
+# Check whether the given compiler option works
+AC_DEFUN([_LT_COMPILER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$3"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:__oline__: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:__oline__: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       $2=yes
+     fi
+   fi
+   $RM conftest*
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$5], , :, [$5])
+else
+    m4_if([$6], , :, [$6])
+fi
+])# _LT_COMPILER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])
+
+
+# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#                  [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------
+# Check whether the given linker option works
+AC_DEFUN([_LT_LINKER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $3"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&AS_MESSAGE_LOG_FD
+       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         $2=yes
+       fi
+     else
+       $2=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$4], , :, [$4])
+else
+    m4_if([$5], , :, [$5])
+fi
+])# _LT_LINKER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])
+
+
+# LT_CMD_MAX_LEN
+#---------------
+AC_DEFUN([LT_CMD_MAX_LEN],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# find the maximum length of command line arguments
+AC_MSG_CHECKING([the maximum length of command line arguments])
+AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
+  i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[	 ]]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`$SHELL [$]0 --fallback-echo "X$teststring$teststring" 2>/dev/null` \
+	         = "XX$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+])
+if test -n $lt_cv_sys_max_cmd_len ; then
+  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
+else
+  AC_MSG_RESULT(none)
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+_LT_DECL([], [max_cmd_len], [0],
+    [What is the maximum length of a command?])
+])# LT_CMD_MAX_LEN
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])
+
+
+# _LT_HEADER_DLFCN
+# ----------------
+m4_defun([_LT_HEADER_DLFCN],
+[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl
+])# _LT_HEADER_DLFCN
+
+
+# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,
+#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)
+# ----------------------------------------------------------------
+m4_defun([_LT_TRY_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "$cross_compiling" = yes; then :
+  [$4]
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+[#line __oline__ "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}]
+_LT_EOF
+  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) $1 ;;
+      x$lt_dlneed_uscore) $2 ;;
+      x$lt_dlunknown|x*) $3 ;;
+    esac
+  else :
+    # compilation failed
+    $3
+  fi
+fi
+rm -fr conftest*
+])# _LT_TRY_DLOPEN_SELF
+
+
+# LT_SYS_DLOPEN_SELF
+# ------------------
+AC_DEFUN([LT_SYS_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],[
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ])
+    ;;
+
+  *)
+    AC_CHECK_FUNC([shl_load],
+	  [lt_cv_dlopen="shl_load"],
+      [AC_CHECK_LIB([dld], [shl_load],
+	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	[AC_CHECK_FUNC([dlopen],
+	      [lt_cv_dlopen="dlopen"],
+	  [AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],
+	    [AC_CHECK_LIB([svld], [dlopen],
+		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
+	      [AC_CHECK_LIB([dld], [dld_link],
+		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+	      ])
+	    ])
+	  ])
+	])
+      ])
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    AC_CACHE_CHECK([whether a program can dlopen itself],
+	  lt_cv_dlopen_self, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,
+	    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)
+    ])
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],
+	  lt_cv_dlopen_self_static, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,
+	    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)
+      ])
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+_LT_DECL([dlopen_support], [enable_dlopen], [0],
+	 [Whether dlopen is supported])
+_LT_DECL([dlopen_self], [enable_dlopen_self], [0],
+	 [Whether dlopen of programs is supported])
+_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],
+	 [Whether dlopen of statically linked programs is supported])
+])# LT_SYS_DLOPEN_SELF
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])
+
+
+# _LT_COMPILER_C_O([TAGNAME])
+# ---------------------------
+# Check to see if options -c and -o are simultaneously supported by compiler.
+# This macro does not hard code the compiler like AC_PROG_CC_C_O.
+m4_defun([_LT_COMPILER_C_O],
+[m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:__oline__: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:__oline__: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+     fi
+   fi
+   chmod u+w . 2>&AS_MESSAGE_LOG_FD
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+])
+_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],
+	[Does compiler simultaneously support -c and -o options?])
+])# _LT_COMPILER_C_O
+
+
+# _LT_COMPILER_FILE_LOCKS([TAGNAME])
+# ----------------------------------
+# Check to see if we can do hard links to lock some files if needed
+m4_defun([_LT_COMPILER_FILE_LOCKS],
+[m4_require([_LT_ENABLE_LOCK])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_COMPILER_C_O([$1])
+
+hard_links="nottested"
+if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  AC_MSG_CHECKING([if we can lock with hard links])
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  AC_MSG_RESULT([$hard_links])
+  if test "$hard_links" = no; then
+    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])
+])# _LT_COMPILER_FILE_LOCKS
+
+
+# _LT_CHECK_OBJDIR
+# ----------------
+m4_defun([_LT_CHECK_OBJDIR],
+[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],
+[rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null])
+objdir=$lt_cv_objdir
+_LT_DECL([], [objdir], [0],
+         [The name of the directory that contains temporary libtool files])dnl
+m4_pattern_allow([LT_OBJDIR])dnl
+AC_DEFINE_UNQUOTED(LT_OBJDIR, "$lt_cv_objdir/",
+  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+])# _LT_CHECK_OBJDIR
+
+
+# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])
+# --------------------------------------
+# Check hardcoding attributes.
+m4_defun([_LT_LINKER_HARDCODE_LIBPATH],
+[AC_MSG_CHECKING([how to hardcode library paths into programs])
+_LT_TAGVAR(hardcode_action, $1)=
+if test -n "$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)" ||
+   test -n "$_LT_TAGVAR(runpath_var, $1)" ||
+   test "X$_LT_TAGVAR(hardcode_automatic, $1)" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$_LT_TAGVAR(hardcode_direct, $1)" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" != no &&
+     test "$_LT_TAGVAR(hardcode_minus_L, $1)" != no; then
+    # Linking always hardcodes the temporary library directory.
+    _LT_TAGVAR(hardcode_action, $1)=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    _LT_TAGVAR(hardcode_action, $1)=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  _LT_TAGVAR(hardcode_action, $1)=unsupported
+fi
+AC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])
+
+if test "$_LT_TAGVAR(hardcode_action, $1)" = relink ||
+   test "$_LT_TAGVAR(inherit_rpath, $1)" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+_LT_TAGDECL([], [hardcode_action], [0],
+    [How to hardcode a shared library path into an executable])
+])# _LT_LINKER_HARDCODE_LIBPATH
+
+
+# _LT_CMD_STRIPLIB
+# ----------------
+m4_defun([_LT_CMD_STRIPLIB],
+[m4_require([_LT_DECL_EGREP])
+striplib=
+old_striplib=
+AC_MSG_CHECKING([whether stripping libraries is possible])
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  AC_MSG_RESULT([yes])
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  *)
+    AC_MSG_RESULT([no])
+    ;;
+  esac
+fi
+_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])
+_LT_DECL([], [striplib], [1])
+])# _LT_CMD_STRIPLIB
+
+
+# _LT_SYS_DYNAMIC_LINKER([TAG])
+# -----------------------------
+# PORTME Fill in your ld.so characteristics
+m4_defun([_LT_SYS_DYNAMIC_LINKER],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_OBJDUMP])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_MSG_CHECKING([dynamic linker characteristics])
+m4_if([$1],
+	[], [
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if $ECHO "$lt_search_path_spec" | $GREP ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[[lt_foo]]++; }
+  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }
+}'`
+  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi])
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[[4-9]]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[[01]] | aix4.[[01]].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[[45]]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if $ECHO "$sys_lib_search_path_spec" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+m4_if([$1], [],[
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"])
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[[123]]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[[01]]* | freebsdelf3.[[01]]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \
+  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+interix[[3-9]]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # Some binutils ld are patched to set DT_RUNPATH
+  save_LDFLAGS=$LDFLAGS
+  save_libdir=$libdir
+  eval "libdir=/foo; wl=\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\"; \
+       LDFLAGS=\"\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\""
+  AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+    [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null],
+       [shlibpath_overrides_runpath=yes])])
+  LDFLAGS=$save_LDFLAGS
+  libdir=$save_libdir
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[[89]] | openbsd2.[[89]].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+AC_MSG_RESULT([$dynamic_linker])
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+_LT_DECL([], [variables_saved_for_relink], [1],
+    [Variables whose values should be saved in libtool wrapper scripts and
+    restored at link time])
+_LT_DECL([], [need_lib_prefix], [0],
+    [Do we need the "lib" prefix for modules?])
+_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])
+_LT_DECL([], [version_type], [0], [Library versioning type])
+_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])
+_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])
+_LT_DECL([], [shlibpath_overrides_runpath], [0],
+    [Is shlibpath searched before the hard-coded library search path?])
+_LT_DECL([], [libname_spec], [1], [Format of library name prefix])
+_LT_DECL([], [library_names_spec], [1],
+    [[List of archive names.  First name is the real one, the rest are links.
+    The last name is the one that the linker finds with -lNAME]])
+_LT_DECL([], [soname_spec], [1],
+    [[The coded name of the library, if different from the real name]])
+_LT_DECL([], [postinstall_cmds], [2],
+    [Command to use after installation of a shared archive])
+_LT_DECL([], [postuninstall_cmds], [2],
+    [Command to use after uninstallation of a shared archive])
+_LT_DECL([], [finish_cmds], [2],
+    [Commands used to finish a libtool library installation in a directory])
+_LT_DECL([], [finish_eval], [1],
+    [[As "finish_cmds", except a single script fragment to be evaled but
+    not shown]])
+_LT_DECL([], [hardcode_into_libs], [0],
+    [Whether we should hardcode library paths into libraries])
+_LT_DECL([], [sys_lib_search_path_spec], [2],
+    [Compile-time system search path for libraries])
+_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],
+    [Run-time system search path for libraries])
+])# _LT_SYS_DYNAMIC_LINKER
+
+
+# _LT_PATH_TOOL_PREFIX(TOOL)
+# --------------------------
+# find a file program which can recognize shared library
+AC_DEFUN([_LT_PATH_TOOL_PREFIX],
+[m4_require([_LT_DECL_EGREP])dnl
+AC_MSG_CHECKING([for $1])
+AC_CACHE_VAL(lt_cv_path_MAGIC_CMD,
+[case $MAGIC_CMD in
+[[\\/*] |  ?:[\\/]*])
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+dnl $ac_dummy forces splitting on constant user-supplied paths.
+dnl POSIX.2 word splitting is done only on the output of word expansions,
+dnl not every word.  This closes a longstanding sh security hole.
+  ac_dummy="m4_if([$2], , $PATH, [$2])"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$1; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/$1"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac])
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  AC_MSG_RESULT($MAGIC_CMD)
+else
+  AC_MSG_RESULT(no)
+fi
+_LT_DECL([], [MAGIC_CMD], [0],
+	 [Used to examine libraries when file_magic_cmd begins with "file"])dnl
+])# _LT_PATH_TOOL_PREFIX
+
+# Old name:
+AU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])
+
+
+# _LT_PATH_MAGIC
+# --------------
+# find a file program which can recognize a shared library
+m4_defun([_LT_PATH_MAGIC],
+[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)
+  else
+    MAGIC_CMD=:
+  fi
+fi
+])# _LT_PATH_MAGIC
+
+
+# LT_PATH_LD
+# ----------
+# find the pathname to the GNU or non-GNU linker
+AC_DEFUN([LT_PATH_LD],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+
+AC_ARG_WITH([gnu-ld],
+    [AS_HELP_STRING([--with-gnu-ld],
+	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
+    [test "$withval" = no || with_gnu_ld=yes],
+    [with_gnu_ld=no])dnl
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by $CC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]]* | ?:[[\\/]]*)
+      re_direlt='/[[^/]][[^/]]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(lt_cv_path_LD,
+[if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+_LT_PATH_LD_GNU
+AC_SUBST([LD])
+
+_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])
+])# LT_PATH_LD
+
+# Old names:
+AU_ALIAS([AM_PROG_LD], [LT_PATH_LD])
+AU_ALIAS([AC_PROG_LD], [LT_PATH_LD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_LD], [])
+dnl AC_DEFUN([AC_PROG_LD], [])
+
+
+# _LT_PATH_LD_GNU
+#- --------------
+m4_defun([_LT_PATH_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac])
+with_gnu_ld=$lt_cv_prog_gnu_ld
+])# _LT_PATH_LD_GNU
+
+
+# _LT_CMD_RELOAD
+# --------------
+# find reload flag for linker
+#   -- PORTME Some linkers may need a different reload flag.
+m4_defun([_LT_CMD_RELOAD],
+[AC_CACHE_CHECK([for $LD option to reload object files],
+  lt_cv_ld_reload_flag,
+  [lt_cv_ld_reload_flag='-r'])
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+_LT_DECL([], [reload_flag], [1], [How to create reloadable object files])dnl
+_LT_DECL([], [reload_cmds], [2])dnl
+])# _LT_CMD_RELOAD
+
+
+# _LT_CHECK_MAGIC_METHOD
+# ----------------------
+# how to check for library dependencies
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_MAGIC_METHOD],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+AC_CACHE_CHECK([how to recognize dependent libraries],
+lt_cv_deplibs_check_method,
+[lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[[4-9]]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[[45]]*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  if ( file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]']
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]].[[0-9]]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[[3-9]]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+])
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+_LT_DECL([], [deplibs_check_method], [1],
+    [Method to check whether dependent libraries are shared objects])
+_LT_DECL([], [file_magic_cmd], [1],
+    [Command to use when deplibs_check_method == "file_magic"])
+])# _LT_CHECK_MAGIC_METHOD
+
+
+# LT_PATH_NM
+# ----------
+# find the pathname to a BSD- or MS-compatible name lister
+AC_DEFUN([LT_PATH_NM],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,
+[if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi])
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  AC_CHECK_TOOLS(DUMPBIN, ["dumpbin -symbols" "link -dump -symbols"], :)
+  AC_SUBST([DUMPBIN])
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+AC_SUBST([NM])
+_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl
+
+AC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],
+  [lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:__oline__: $ac_compile\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:__oline__: $NM \\\"conftest.$ac_objext\\\"\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:__oline__: output\"" >&AS_MESSAGE_LOG_FD)
+  cat conftest.out >&AS_MESSAGE_LOG_FD
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*])
+])# LT_PATH_NM
+
+# Old names:
+AU_ALIAS([AM_PROG_NM], [LT_PATH_NM])
+AU_ALIAS([AC_PROG_NM], [LT_PATH_NM])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_NM], [])
+dnl AC_DEFUN([AC_PROG_NM], [])
+
+
+# LT_LIB_M
+# --------
+# check for math library
+AC_DEFUN([LT_LIB_M],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+LIBM=
+case $host in
+*-*-beos* | *-*-cygwin* | *-*-pw32* | *-*-darwin*)
+  # These system don't have libm, or don't need it
+  ;;
+*-ncr-sysv4.3*)
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(m, cos, LIBM="$LIBM -lm")
+  ;;
+*)
+  AC_CHECK_LIB(m, cos, LIBM="-lm")
+  ;;
+esac
+AC_SUBST([LIBM])
+])# LT_LIB_M
+
+# Old name:
+AU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_CHECK_LIBM], [])
+
+
+# _LT_COMPILER_NO_RTTI([TAGNAME])
+# -------------------------------
+m4_defun([_LT_COMPILER_NO_RTTI],
+[m4_require([_LT_TAG_COMPILER])dnl
+
+_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+
+if test "$GCC" = yes; then
+  _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+
+  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],
+    lt_cv_prog_compiler_rtti_exceptions,
+    [-fno-rtti -fno-exceptions], [],
+    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)="$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions"])
+fi
+_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],
+	[Compiler flag to turn off builtin functions])
+])# _LT_COMPILER_NO_RTTI
+
+
+# _LT_CMD_GLOBAL_SYMBOLS
+# ----------------------
+m4_defun([_LT_CMD_GLOBAL_SYMBOLS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+AC_MSG_CHECKING([command to parse $NM output from $compiler object])
+AC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],
+[
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[[BCDEGRST]]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([[_A-Za-z]][[_A-Za-z0-9]]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[[BCDT]]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[[ABCDGISTW]]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[[ABCDEGRST]]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[[BCDEGRST]]'
+  ;;
+osf*)
+  symcode='[[BCDEGQRST]]'
+  ;;
+solaris*)
+  symcode='[[BDRT]]'
+  ;;
+sco3.2v5*)
+  symcode='[[DT]]'
+  ;;
+sysv4.2uw2*)
+  symcode='[[DT]]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[[ABDT]]'
+  ;;
+sysv4)
+  symcode='[[DFNSTU]]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[[ABCDGIRSTW]]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([[^ ]]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK ['"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx]"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[[]] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)"
+	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&AS_MESSAGE_LOG_FD
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&AS_MESSAGE_LOG_FD
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "$progname: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+])
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  AC_MSG_RESULT(failed)
+else
+  AC_MSG_RESULT(ok)
+fi
+
+_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],
+    [Take the output of nm and produce a listing of raw symbols and C names])
+_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],
+    [Transform the output of nm in a proper C declaration])
+_LT_DECL([global_symbol_to_c_name_address],
+    [lt_cv_sys_global_symbol_to_c_name_address], [1],
+    [Transform the output of nm in a C name address pair])
+_LT_DECL([global_symbol_to_c_name_address_lib_prefix],
+    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
+    [Transform the output of nm in a C name address pair when lib prefix is needed])
+]) # _LT_CMD_GLOBAL_SYMBOLS
+
+
+# _LT_COMPILER_PIC([TAGNAME])
+# ---------------------------
+m4_defun([_LT_COMPILER_PIC],
+[m4_require([_LT_TAG_COMPILER])dnl
+_LT_TAGVAR(lt_prog_compiler_wl, $1)=
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+_LT_TAGVAR(lt_prog_compiler_static, $1)=
+
+AC_MSG_CHECKING([for $compiler option to produce PIC])
+m4_if([$1], [CXX], [
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+      ;;
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[[4-9]]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	else
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, $1)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  xlc* | xlC*)
+	    # IBM XL 8.0 on PPC
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd* | netbsdelf*-gnu)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+	;;
+    esac
+  fi
+],
+[
+  if test "$GCC" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      else
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC (with -KPIC) is the default.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+        ;;
+      ccc*)
+        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+        # All Alpha code is PIC.
+        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+        ;;
+      xl*)
+	# IBM XL C 8.0/Fortran 10.1 on PPC
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)
+	  # Sun C 5.9
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  ;;
+	*Sun\ F*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # All OSF/1 code is PIC.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    rdos*)
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    unicos*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+    esac
+  fi
+])
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+    ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)="$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])"
+    ;;
+esac
+AC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])
+_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],
+	[How to pass a linker flag through the compiler])
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],
+    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],
+    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],
+    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in
+     "" | " "*) ;;
+     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=" $_LT_TAGVAR(lt_prog_compiler_pic, $1)" ;;
+     esac],
+    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])
+fi
+_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],
+	[Additional compiler flags for building library objects])
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\"
+_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],
+  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),
+  $lt_tmp_static_flag,
+  [],
+  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])
+_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],
+	[Compiler flag to prevent dynamic linking])
+])# _LT_COMPILER_PIC
+
+
+# _LT_LINKER_SHLIBS([TAGNAME])
+# ----------------------------
+# See if the linker supports building shared libraries.
+m4_defun([_LT_LINKER_SHLIBS],
+[AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+m4_if([$1], [CXX], [
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  case $host_os in
+  aix[[4-9]]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
+  ;;
+  cygwin* | mingw* | cegcc*)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  linux* | k*bsd*-gnu)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+  ;;
+  *)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  esac
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+], [
+  runpath_var=
+  _LT_TAGVAR(allow_undefined_flag, $1)=
+  _LT_TAGVAR(always_export_symbols, $1)=no
+  _LT_TAGVAR(archive_cmds, $1)=
+  _LT_TAGVAR(archive_expsym_cmds, $1)=
+  _LT_TAGVAR(compiler_needs_object, $1)=no
+  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+  _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(hardcode_automatic, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_direct_absolute, $1)=no
+  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+  _LT_TAGVAR(hardcode_minus_L, $1)=no
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(inherit_rpath, $1)=no
+  _LT_TAGVAR(link_all_deplibs, $1)=unknown
+  _LT_TAGVAR(module_cmds, $1)=
+  _LT_TAGVAR(module_expsym_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_new_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=
+  _LT_TAGVAR(thread_safe_flag_spec, $1)=
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  _LT_TAGVAR(include_expsyms, $1)=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+dnl Note also adjust exclude_expsyms for C++ above.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  linux* | k*bsd*-gnu)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+    ;;
+  esac
+
+  _LT_TAGVAR(ld_shlibs, $1)=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[[3-9]]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+      # as there is no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=no
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/'\'' | $SED -e '\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    interix[[3-9]]*)
+      _LT_TAGVAR(hardcode_direct, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+	  tmp_sharedflag='--shared' ;;
+	xl[[cC]]*)			# IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        _LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.1[[0-5]].*)
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+    esac
+
+    if test "$_LT_TAGVAR(ld_shlibs, $1)" = no; then
+      runpath_var=
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	_LT_TAGVAR(hardcode_direct, $1)=unsupported
+      fi
+      ;;
+
+    aix[[4-9]]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      _LT_TAGVAR(archive_cmds, $1)=''
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[[012]]|aix4.[[012]].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	_LT_TAGVAR(link_all_deplibs, $1)=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	_LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        _LT_SYS_MODULE_PATH_AIX
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	  _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 _LT_SYS_MODULE_PATH_AIX
+	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[[45]]*)
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `$ECHO "X$deplibs" | $Xsed -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+      # FIXME: Should let the user specify the lib program.
+      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w "$srcfile"`'
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      ;;
+
+    darwin* | rhapsody*)
+      _LT_DARWIN_LINKER_FEATURES($1)
+      ;;
+
+    dgux*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    freebsd1*)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	_LT_TAGVAR(hardcode_minus_L, $1)=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  ;;
+	*)
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        AC_LINK_IFELSE(int foo(void) {},
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+        )
+        LDFLAGS="$save_LDFLAGS"
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(inherit_rpath, $1)=yes
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)
+	     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	     ;;
+	   *)
+	     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    os2*)
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO " SINGLE NONSHARED" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      case $host_os in
+      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+        ;;
+	motorola)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4.3*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	_LT_TAGVAR(ld_shlibs, $1)=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+])
+AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld
+
+_LT_DECL([], [libext], [0], [Old archive suffix (normally "a")])dnl
+_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally ".so")])dnl
+_LT_DECL([], [extract_expsyms_cmds], [2],
+    [The commands to extract the exported symbol list from a shared archive])
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$_LT_TAGVAR(archive_cmds_need_lc, $1)" in
+x|xyes)
+  # Assume -lc should be added
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $_LT_TAGVAR(archive_cmds, $1) in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      AC_MSG_CHECKING([whether -lc should be explicitly linked in])
+      $RM conftest*
+      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if AC_TRY_EVAL(ac_compile) 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)
+	pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)
+        _LT_TAGVAR(allow_undefined_flag, $1)=
+        if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1)
+        then
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        else
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+        fi
+        _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $RM conftest*
+      AC_MSG_RESULT([$_LT_TAGVAR(archive_cmds_need_lc, $1)])
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],
+    [Whether or not to add -lc for building shared libraries])
+_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],
+    [enable_shared_with_static_runtimes], [0],
+    [Whether or not to disallow shared libs when runtime libs are static])
+_LT_TAGDECL([], [export_dynamic_flag_spec], [1],
+    [Compiler flag to allow reflexive dlopens])
+_LT_TAGDECL([], [whole_archive_flag_spec], [1],
+    [Compiler flag to generate shared objects directly from archives])
+_LT_TAGDECL([], [compiler_needs_object], [1],
+    [Whether the compiler copes with passing no objects directly])
+_LT_TAGDECL([], [old_archive_from_new_cmds], [2],
+    [Create an old-style archive from a shared archive])
+_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],
+    [Create a temporary old-style archive to link instead of a shared archive])
+_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])
+_LT_TAGDECL([], [archive_expsym_cmds], [2])
+_LT_TAGDECL([], [module_cmds], [2],
+    [Commands used to build a loadable module if different from building
+    a shared archive.])
+_LT_TAGDECL([], [module_expsym_cmds], [2])
+_LT_TAGDECL([], [with_gnu_ld], [1],
+    [Whether we are building with GNU ld or not])
+_LT_TAGDECL([], [allow_undefined_flag], [1],
+    [Flag that allows shared libraries with undefined symbols to be built])
+_LT_TAGDECL([], [no_undefined_flag], [1],
+    [Flag that enforces no undefined symbols])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],
+    [Flag to hardcode $libdir into a binary during linking.
+    This must work even if $libdir does not exist])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],
+    [[If ld is used when linking, flag to hardcode $libdir into a binary
+    during linking.  This must work even if $libdir does not exist]])
+_LT_TAGDECL([], [hardcode_libdir_separator], [1],
+    [Whether we need a single "-rpath" flag with a separated argument])
+_LT_TAGDECL([], [hardcode_direct], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary])
+_LT_TAGDECL([], [hardcode_direct_absolute], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary and the resulting library dependency is
+    "absolute", i.e impossible to change by setting ${shlibpath_var} if the
+    library is relocated])
+_LT_TAGDECL([], [hardcode_minus_L], [0],
+    [Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_shlibpath_var], [0],
+    [Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_automatic], [0],
+    [Set to "yes" if building a shared library automatically hardcodes DIR
+    into the library and all subsequent libraries and executables linked
+    against it])
+_LT_TAGDECL([], [inherit_rpath], [0],
+    [Set to yes if linker adds runtime paths of dependent libraries
+    to runtime path list])
+_LT_TAGDECL([], [link_all_deplibs], [0],
+    [Whether libtool must link a program against all its dependency libraries])
+_LT_TAGDECL([], [fix_srcfile_path], [1],
+    [Fix the shell variable $srcfile for the compiler])
+_LT_TAGDECL([], [always_export_symbols], [0],
+    [Set to "yes" if exported symbols are required])
+_LT_TAGDECL([], [export_symbols_cmds], [2],
+    [The commands to list exported symbols])
+_LT_TAGDECL([], [exclude_expsyms], [1],
+    [Symbols that should not be listed in the preloaded symbols])
+_LT_TAGDECL([], [include_expsyms], [1],
+    [Symbols that must always be exported])
+_LT_TAGDECL([], [prelink_cmds], [2],
+    [Commands necessary for linking programs (against libraries) with templates])
+_LT_TAGDECL([], [file_list_spec], [1],
+    [Specify filename containing input files])
+dnl FIXME: Not yet implemented
+dnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],
+dnl    [Compiler flag to generate thread safe objects])
+])# _LT_LINKER_SHLIBS
+
+
+# _LT_LANG_C_CONFIG([TAG])
+# ------------------------
+# Ensure that the configuration variables for a C compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_C_CONFIG],
+[m4_require([_LT_DECL_EGREP])dnl
+lt_save_CC="$CC"
+AC_LANG_PUSH(C)
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+_LT_TAG_COMPILER
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_SYS_DYNAMIC_LINKER($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+  LT_SYS_DLOPEN_SELF
+  _LT_CMD_STRIPLIB
+
+  # Report which library types will actually be built
+  AC_MSG_CHECKING([if libtool supports shared libraries])
+  AC_MSG_RESULT([$can_build_shared])
+
+  AC_MSG_CHECKING([whether to build shared libraries])
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[[4-9]]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  AC_MSG_RESULT([$enable_shared])
+
+  AC_MSG_CHECKING([whether to build static libraries])
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  AC_MSG_RESULT([$enable_static])
+
+  _LT_CONFIG($1)
+fi
+AC_LANG_POP
+CC="$lt_save_CC"
+])# _LT_LANG_C_CONFIG
+
+
+# _LT_PROG_CXX
+# ------------
+# Since AC_PROG_CXX is broken, in that it returns g++ if there is no c++
+# compiler, we have our own version here.
+m4_defun([_LT_PROG_CXX],
+[
+pushdef([AC_MSG_ERROR], [_lt_caught_CXX_error=yes])
+AC_PROG_CXX
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  AC_PROG_CXXCPP
+else
+  _lt_caught_CXX_error=yes
+fi
+popdef([AC_MSG_ERROR])
+])# _LT_PROG_CXX
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([_LT_PROG_CXX], [])
+
+
+# _LT_LANG_CXX_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a C++ compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_CXX_CONFIG],
+[AC_REQUIRE([_LT_PROG_CXX])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+
+AC_LANG_PUSH(C++)
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(compiler_needs_object, $1)=no
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+    else
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+      LT_PATH_LD
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          _LT_TAGVAR(whole_archive_flag_spec, $1)=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+    _LT_TAGVAR(ld_shlibs, $1)=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+      aix[[4-9]]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        _LT_TAGVAR(archive_cmds, $1)=''
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[[012]]|aix4.[[012]].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        _LT_TAGVAR(always_export_symbols, $1)=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          _LT_SYS_MODULE_PATH_AIX
+          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	    _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    _LT_SYS_MODULE_PATH_AIX
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	    # Exported symbols can be pulled into shared objects from archives
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+        # as there is no search path for DLLs.
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+        _LT_TAGVAR(always_export_symbols, $1)=no
+        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+
+        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+          # If the export-symbols file already is a .def file (1st line
+          # is EXPORTS), use it as is; otherwise, prepend...
+          _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    cp $export_symbols $output_objdir/$soname.def;
+          else
+	    echo EXPORTS > $output_objdir/$soname.def;
+	    cat $export_symbols >> $output_objdir/$soname.def;
+          fi~
+          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        else
+          _LT_TAGVAR(ld_shlibs, $1)=no
+        fi
+        ;;
+      darwin* | rhapsody*)
+        _LT_DARWIN_LINKER_FEATURES($1)
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      freebsd[[12]]*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      freebsd-elf*)
+        _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+        ;;
+
+      gnu*)
+        ;;
+
+      hpux9*)
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            _LT_TAGVAR(ld_shlibs, $1)=no
+            ;;
+          aCC*)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              _LT_TAGVAR(ld_shlibs, $1)=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            _LT_TAGVAR(hardcode_direct, $1)=no
+            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+            ;;
+          *)
+            _LT_TAGVAR(hardcode_direct, $1)=yes
+            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[[3-9]]*)
+	_LT_TAGVAR(hardcode_direct, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` -o $lib'
+	      fi
+	    fi
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+	    ;;
+        esac
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(inherit_rpath, $1)=yes
+        ;;
+
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [[1-5]]* | *pgcpp\ [[1-5]]*)
+	      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | $NL2SP`"'
+	      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | $NL2SP`~
+		$RANLIB $oldlib'
+	      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 will use weak symbols
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+	  xl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	      _LT_TAGVAR(compiler_needs_object, $1)=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='echo'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      m88k*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	esac
+	;;
+
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
+
+      *nto* | *qnx*)
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+	;;
+
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=echo
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && $ECHO "X${wl}-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+		;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes
+	    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	    case $host_os in
+	      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+
+	    output_verbose_link_cmd='echo'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+	      fi
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+		*)
+		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
+      ;;
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+	_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+	_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+	_LT_TAGVAR(link_all_deplibs, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	  *)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
+      ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+    esac
+
+    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+    test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+    _LT_TAGVAR(GCC, $1)="$GXX"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
+AC_LANG_POP
+])# _LT_LANG_CXX_CONFIG
+
+
+# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])
+# ---------------------------------
+# Figure out "hidden" library dependencies from verbose
+# compiler output when linking a shared library.
+# Parse the compiler output and extract the necessary
+# objects, libraries and library flags.
+m4_defun([_LT_SYS_HIDDEN_LIBDEPS],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+# Dependencies to place before and after the object being linked:
+_LT_TAGVAR(predep_objects, $1)=
+_LT_TAGVAR(postdep_objects, $1)=
+_LT_TAGVAR(predeps, $1)=
+_LT_TAGVAR(postdeps, $1)=
+_LT_TAGVAR(compiler_lib_search_path, $1)=
+
+dnl we can't use the lt_simple_compile_test_code here,
+dnl because it contains code intended for an executable,
+dnl not a library.  It's possible we should let each
+dnl tag define a new lt_????_link_test_code variable,
+dnl but it's only used here...
+m4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF
+int a;
+void foo (void) { a = 0; }
+_LT_EOF
+], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
+], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer*4 a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF
+public class foo {
+  private int a;
+  public void bar (void) {
+    a = 0;
+  }
+};
+_LT_EOF
+])
+dnl Parse the compiler output and extract the necessary
+dnl objects, libraries and library flags.
+if AC_TRY_EVAL(ac_compile); then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case $p in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       else
+	 prev=
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 case $p in
+	 -L* | -R*)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$_LT_TAGVAR(compiler_lib_search_path, $1)"; then
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${prev}${p}"
+	   else
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$_LT_TAGVAR(postdeps, $1)"; then
+	   _LT_TAGVAR(postdeps, $1)="${prev}${p}"
+	 else
+	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} ${prev}${p}"
+	 fi
+       fi
+       ;;
+
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$_LT_TAGVAR(predep_objects, $1)"; then
+	   _LT_TAGVAR(predep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(predep_objects, $1)="$_LT_TAGVAR(predep_objects, $1) $p"
+	 fi
+       else
+	 if test -z "$_LT_TAGVAR(postdep_objects, $1)"; then
+	   _LT_TAGVAR(postdep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(postdep_objects, $1)="$_LT_TAGVAR(postdep_objects, $1) $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling $1 test program"
+fi
+
+$RM -f confest.$objext
+
+# PORTME: override above test on systems where it is broken
+m4_if([$1], [CXX],
+[case $host_os in
+interix[[3-9]]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  _LT_TAGVAR(predep_objects,$1)=
+  _LT_TAGVAR(postdep_objects,$1)=
+  _LT_TAGVAR(postdeps,$1)=
+  ;;
+
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+
+solaris*)
+  case $cc_basename in
+  CC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+esac
+])
+
+case " $_LT_TAGVAR(postdeps, $1) " in
+*" -lc "*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;
+esac
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=
+if test -n "${_LT_TAGVAR(compiler_lib_search_path, $1)}"; then
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+_LT_TAGDECL([], [compiler_lib_search_dirs], [1],
+    [The directories searched by this compiler when creating a shared library])
+_LT_TAGDECL([], [predep_objects], [1],
+    [Dependencies to place before and after the objects being linked to
+    create a shared library])
+_LT_TAGDECL([], [postdep_objects], [1])
+_LT_TAGDECL([], [predeps], [1])
+_LT_TAGDECL([], [postdeps], [1])
+_LT_TAGDECL([], [compiler_lib_search_path], [1],
+    [The library search path used internally by the compiler when linking
+    a shared library])
+])# _LT_SYS_HIDDEN_LIBDEPS
+
+
+# _LT_PROG_F77
+# ------------
+# Since AC_PROG_F77 is broken, in that it returns the empty string
+# if there is no fortran compiler, we have our own version here.
+m4_defun([_LT_PROG_F77],
+[
+pushdef([AC_MSG_ERROR], [_lt_disable_F77=yes])
+AC_PROG_F77
+if test -z "$F77" || test "X$F77" = "Xno"; then
+  _lt_disable_F77=yes
+fi
+popdef([AC_MSG_ERROR])
+])# _LT_PROG_F77
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([_LT_PROG_F77], [])
+
+
+# _LT_LANG_F77_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a Fortran 77 compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_F77_CONFIG],
+[AC_REQUIRE([_LT_PROG_F77])dnl
+AC_LANG_PUSH(Fortran 77)
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for f77 test sources.
+ac_ext=f
+
+# Object file extension for compiled f77 test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the F77 compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_F77" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  CC=${F77-"f77"}
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+  GCC=$G77
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$G77"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+fi # test "$_lt_disable_F77" != yes
+
+AC_LANG_POP
+])# _LT_LANG_F77_CONFIG
+
+
+# _LT_PROG_FC
+# -----------
+# Since AC_PROG_FC is broken, in that it returns the empty string
+# if there is no fortran compiler, we have our own version here.
+m4_defun([_LT_PROG_FC],
+[
+pushdef([AC_MSG_ERROR], [_lt_disable_FC=yes])
+AC_PROG_FC
+if test -z "$FC" || test "X$FC" = "Xno"; then
+  _lt_disable_FC=yes
+fi
+popdef([AC_MSG_ERROR])
+])# _LT_PROG_FC
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([_LT_PROG_FC], [])
+
+
+# _LT_LANG_FC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for a Fortran compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_FC_CONFIG],
+[AC_REQUIRE([_LT_PROG_FC])dnl
+AC_LANG_PUSH(Fortran)
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for fc test sources.
+ac_ext=${ac_fc_srcext-f}
+
+# Object file extension for compiled fc test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the FC compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_FC" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  CC=${FC-"f95"}
+  compiler=$CC
+  GCC=$ac_cv_fc_compiler_gnu
+
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$ac_cv_fc_compiler_gnu"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+fi # test "$_lt_disable_FC" != yes
+
+AC_LANG_POP
+])# _LT_LANG_FC_CONFIG
+
+
+# _LT_LANG_GCJ_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Java Compiler compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GCJ_CONFIG],
+[AC_REQUIRE([LT_PROG_GCJ])dnl
+AC_LANG_SAVE
+
+# Source file extension for Java test sources.
+ac_ext=java
+
+# Object file extension for compiled Java test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="class foo {}"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GCJ-"gcj"}
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# GCJ did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC="$lt_save_CC"
+])# _LT_LANG_GCJ_CONFIG
+
+
+# _LT_LANG_RC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for the Windows resource compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_RC_CONFIG],
+[AC_REQUIRE([LT_PROG_RC])dnl
+AC_LANG_SAVE
+
+# Source file extension for RC test sources.
+ac_ext=rc
+
+# Object file extension for compiled RC test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }'
+
+# Code to be used in simple link tests
+lt_simple_link_test_code="$lt_simple_compile_test_code"
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_GCC=$GCC
+GCC=
+CC=${RC-"windres"}
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_CC_BASENAME([$compiler])
+_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+
+if test -n "$compiler"; then
+  :
+  _LT_CONFIG($1)
+fi
+
+GCC=$lt_save_GCC
+AC_LANG_RESTORE
+CC="$lt_save_CC"
+])# _LT_LANG_RC_CONFIG
+
+
+# LT_PROG_GCJ
+# -----------
+AC_DEFUN([LT_PROG_GCJ],
+[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],
+  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],
+    [AC_CHECK_TOOL(GCJ, gcj,)
+      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
+      AC_SUBST(GCJFLAGS)])])[]dnl
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_GCJ], [])
+
+
+# LT_PROG_RC
+# ----------
+AC_DEFUN([LT_PROG_RC],
+[AC_CHECK_TOOL(RC, windres,)
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_RC], [])
+
+
+# _LT_DECL_EGREP
+# --------------
+# If we don't have a new enough Autoconf to choose the best grep
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_EGREP],
+[AC_REQUIRE([AC_PROG_EGREP])dnl
+AC_REQUIRE([AC_PROG_FGREP])dnl
+test -z "$GREP" && GREP=grep
+_LT_DECL([], [GREP], [1], [A grep program that handles long lines])
+_LT_DECL([], [EGREP], [1], [An ERE matcher])
+_LT_DECL([], [FGREP], [1], [A literal string matcher])
+dnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too
+AC_SUBST([GREP])
+])
+
+
+# _LT_DECL_OBJDUMP
+# --------------
+# If we don't have a new enough Autoconf to choose the best objdump
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_OBJDUMP],
+[AC_CHECK_TOOL(OBJDUMP, objdump, false)
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])
+AC_SUBST([OBJDUMP])
+])
+
+
+# _LT_DECL_SED
+# ------------
+# Check for a fully-functional sed program, that truncates
+# as few characters as possible.  Prefer GNU sed if found.
+m4_defun([_LT_DECL_SED],
+[AC_PROG_SED
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+_LT_DECL([], [SED], [1], [A sed program that does not truncate output])
+_LT_DECL([], [Xsed], ["\$SED -e 1s/^X//"],
+    [Sed that helps us avoid accidentally triggering echo(1) options like -n])
+])# _LT_DECL_SED
+
+m4_ifndef([AC_PROG_SED], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_SED.  When it is available in   #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+
+m4_defun([AC_PROG_SED],
+[AC_MSG_CHECKING([for a sed that does not truncate output])
+AC_CACHE_VAL(lt_cv_path_SED,
+[# Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for lt_ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
+        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+IFS=$as_save_IFS
+lt_ac_max=0
+lt_ac_count=0
+# Add /usr/xpg4/bin/sed as it is typically found on Solaris
+# along with /bin/sed that truncates output.
+for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
+  test ! -f $lt_ac_sed && continue
+  cat /dev/null > conftest.in
+  lt_ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >conftest.in
+  # Check for GNU sed and select it if it is found.
+  if "$lt_ac_sed" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then
+    lt_cv_path_SED=$lt_ac_sed
+    break
+  fi
+  while true; do
+    cat conftest.in conftest.in >conftest.tmp
+    mv conftest.tmp conftest.in
+    cp conftest.in conftest.nl
+    echo >>conftest.nl
+    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
+    cmp -s conftest.out conftest.nl || break
+    # 10000 chars as input seems more than enough
+    test $lt_ac_count -gt 10 && break
+    lt_ac_count=`expr $lt_ac_count + 1`
+    if test $lt_ac_count -gt $lt_ac_max; then
+      lt_ac_max=$lt_ac_count
+      lt_cv_path_SED=$lt_ac_sed
+    fi
+  done
+done
+])
+SED=$lt_cv_path_SED
+AC_SUBST([SED])
+AC_MSG_RESULT([$SED])
+])#AC_PROG_SED
+])#m4_ifndef
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_SED], [])
+
+
+# _LT_CHECK_SHELL_FEATURES
+# ------------------------
+# Find out whether the shell is Bourne or XSI compatible,
+# or has some other useful features.
+m4_defun([_LT_CHECK_SHELL_FEATURES],
+[AC_MSG_CHECKING([whether the shell understands some XSI constructs])
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+AC_MSG_RESULT([$xsi_shell])
+_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
+
+AC_MSG_CHECKING([whether the shell understands "+="])
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$[1]+=\$[2]" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+AC_MSG_RESULT([$lt_shell_append])
+_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+_LT_DECL([], [lt_unset], [0], [whether the shell understands "unset"])dnl
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl
+_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl
+])# _LT_CHECK_SHELL_FEATURES
+
+
+# _LT_PROG_XSI_SHELLFNS
+# ---------------------
+# Bourne and XSI compatible variants of some useful shell functions.
+m4_defun([_LT_PROG_XSI_SHELLFNS],
+[case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $[*] ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+dnl func_dirname_and_basename
+dnl A portable version of this function is already defined in general.m4sh
+dnl so there is no need for it here.
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[[^=]]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[[^=]]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "X${1}" | $Xsed -e "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "X${1}" | $Xsed -e 's/\.[[^.]]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$[@]"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$[1]" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$[1]+=\$[2]"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$[1]=\$$[1]\$[2]"
+}
+
+_LT_EOF
+    ;;
+  esac
+])
+
+# Helper functions for option handling.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltoptions.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])
+
+
+# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)
+# ------------------------------------------
+m4_define([_LT_MANGLE_OPTION],
+[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])
+
+
+# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)
+# ---------------------------------------
+# Set option OPTION-NAME for macro MACRO-NAME, and if there is a
+# matching handler defined, dispatch to it.  Other OPTION-NAMEs are
+# saved as a flag.
+m4_define([_LT_SET_OPTION],
+[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl
+m4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),
+        _LT_MANGLE_DEFUN([$1], [$2]),
+    [m4_warning([Unknown $1 option `$2'])])[]dnl
+])
+
+
+# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])
+# ------------------------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+m4_define([_LT_IF_OPTION],
+[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])
+
+
+# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)
+# -------------------------------------------------------
+# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME
+# are set.
+m4_define([_LT_UNLESS_OPTIONS],
+[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+	    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),
+		      [m4_define([$0_found])])])[]dnl
+m4_ifdef([$0_found], [m4_undefine([$0_found])], [$3
+])[]dnl
+])
+
+
+# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)
+# ----------------------------------------
+# OPTION-LIST is a space-separated list of Libtool options associated
+# with MACRO-NAME.  If any OPTION has a matching handler declared with
+# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about
+# the unknown option and exit.
+m4_defun([_LT_SET_OPTIONS],
+[# Set options
+m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+    [_LT_SET_OPTION([$1], _LT_Option)])
+
+m4_if([$1],[LT_INIT],[
+  dnl
+  dnl Simply set some default values (i.e off) if boolean options were not
+  dnl specified:
+  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no
+  ])
+  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no
+  ])
+  dnl
+  dnl If no reference was made to various pairs of opposing options, then
+  dnl we run the default mode handler for the pair.  For example, if neither
+  dnl `shared' nor `disable-shared' was passed, we enable building of shared
+  dnl archives by default:
+  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])
+  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],
+  		   [_LT_ENABLE_FAST_INSTALL])
+  ])
+])# _LT_SET_OPTIONS
+
+
+
+# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)
+# -----------------------------------------
+m4_define([_LT_MANGLE_DEFUN],
+[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])
+
+
+# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)
+# -----------------------------------------------
+m4_define([LT_OPTION_DEFINE],
+[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl
+])# LT_OPTION_DEFINE
+
+
+# dlopen
+# ------
+LT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes
+])
+
+AU_DEFUN([AC_LIBTOOL_DLOPEN],
+[_LT_SET_OPTION([LT_INIT], [dlopen])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `dlopen' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])
+
+
+# win32-dll
+# ---------
+# Declare package support for building win32 dll's.
+LT_OPTION_DEFINE([LT_INIT], [win32-dll],
+[enable_win32_dll=yes
+
+case $host in
+*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-cegcc*)
+  AC_CHECK_TOOL(AS, as, false)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+  AC_CHECK_TOOL(OBJDUMP, objdump, false)
+  ;;
+esac
+
+test -z "$AS" && AS=as
+_LT_DECL([], [AS],      [0], [Assembler program])dnl
+
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [0], [DLL creation program])dnl
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [0], [Object dumper program])dnl
+])# win32-dll
+
+AU_DEFUN([AC_LIBTOOL_WIN32_DLL],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+_LT_SET_OPTION([LT_INIT], [win32-dll])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `win32-dll' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])
+
+
+# _LT_ENABLE_SHARED([DEFAULT])
+# ----------------------------
+# implement the --enable-shared flag, and supports the `shared' and
+# `disable-shared' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_SHARED],
+[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([shared],
+    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],
+	[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)
+
+    _LT_DECL([build_libtool_libs], [enable_shared], [0],
+	[Whether or not to build shared libraries])
+])# _LT_ENABLE_SHARED
+
+LT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])
+])
+
+AC_DEFUN([AC_DISABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], [disable-shared])
+])
+
+AU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])
+AU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_SHARED], [])
+dnl AC_DEFUN([AM_DISABLE_SHARED], [])
+
+
+
+# _LT_ENABLE_STATIC([DEFAULT])
+# ----------------------------
+# implement the --enable-static flag, and support the `static' and
+# `disable-static' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_STATIC],
+[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([static],
+    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],
+	[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)
+
+    _LT_DECL([build_old_libs], [enable_static], [0],
+	[Whether or not to build static libraries])
+])# _LT_ENABLE_STATIC
+
+LT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])
+])
+
+AC_DEFUN([AC_DISABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], [disable-static])
+])
+
+AU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])
+AU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_STATIC], [])
+dnl AC_DEFUN([AM_DISABLE_STATIC], [])
+
+
+
+# _LT_ENABLE_FAST_INSTALL([DEFAULT])
+# ----------------------------------
+# implement the --enable-fast-install flag, and support the `fast-install'
+# and `disable-fast-install' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_FAST_INSTALL],
+[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([fast-install],
+    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],
+    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)
+
+_LT_DECL([fast_install], [enable_fast_install], [0],
+	 [Whether or not to optimize for fast installation])dnl
+])# _LT_ENABLE_FAST_INSTALL
+
+LT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])
+
+# Old names:
+AU_DEFUN([AC_ENABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `fast-install' option into LT_INIT's first parameter.])
+])
+
+AU_DEFUN([AC_DISABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], [disable-fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `disable-fast-install' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])
+dnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])
+
+
+# _LT_WITH_PIC([MODE])
+# --------------------
+# implement the --with-pic flag, and support the `pic-only' and `no-pic'
+# LT_INIT options.
+# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.
+m4_define([_LT_WITH_PIC],
+[AC_ARG_WITH([pic],
+    [AS_HELP_STRING([--with-pic],
+	[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],
+    [pic_mode="$withval"],
+    [pic_mode=default])
+
+test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
+
+_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl
+])# _LT_WITH_PIC
+
+LT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])
+
+# Old name:
+AU_DEFUN([AC_LIBTOOL_PICMODE],
+[_LT_SET_OPTION([LT_INIT], [pic-only])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `pic-only' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])
+
+
+m4_define([_LTDL_MODE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],
+		 [m4_define([_LTDL_MODE], [nonrecursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [recursive],
+		 [m4_define([_LTDL_MODE], [recursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [subproject],
+		 [m4_define([_LTDL_MODE], [subproject])])
+
+m4_define([_LTDL_TYPE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [installable],
+		 [m4_define([_LTDL_TYPE], [installable])])
+LT_OPTION_DEFINE([LTDL_INIT], [convenience],
+		 [m4_define([_LTDL_TYPE], [convenience])])
+
+# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-
+#
+# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+# Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltsugar.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])
+
+
+# lt_join(SEP, ARG1, [ARG2...])
+# -----------------------------
+# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their
+# associated separator.
+# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier
+# versions in m4sugar had bugs.
+m4_define([lt_join],
+[m4_if([$#], [1], [],
+       [$#], [2], [[$2]],
+       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])
+m4_define([_lt_join],
+[m4_if([$#$2], [2], [],
+       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])
+
+
+# lt_car(LIST)
+# lt_cdr(LIST)
+# ------------
+# Manipulate m4 lists.
+# These macros are necessary as long as will still need to support
+# Autoconf-2.59 which quotes differently.
+m4_define([lt_car], [[$1]])
+m4_define([lt_cdr],
+[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
+       [$#], 1, [],
+       [m4_dquote(m4_shift($@))])])
+m4_define([lt_unquote], $1)
+
+
+# lt_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.
+# Note that neither SEPARATOR nor STRING are expanded; they are appended
+# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
+# No SEPARATOR is output if MACRO-NAME was previously undefined (different
+# than defined and empty).
+#
+# This macro is needed until we can rely on Autoconf 2.62, since earlier
+# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.
+m4_define([lt_append],
+[m4_define([$1],
+	   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])
+
+
+
+# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])
+# ----------------------------------------------------------
+# Produce a SEP delimited list of all paired combinations of elements of
+# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list
+# has the form PREFIXmINFIXSUFFIXn.
+# Needed until we can rely on m4_combine added in Autoconf 2.62.
+m4_define([lt_combine],
+[m4_if(m4_eval([$# > 3]), [1],
+       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl
+[[m4_foreach([_Lt_prefix], [$2],
+	     [m4_foreach([_Lt_suffix],
+		]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,
+	[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])
+
+
+# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])
+# -----------------------------------------------------------------------
+# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited
+# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.
+m4_define([lt_if_append_uniq],
+[m4_ifdef([$1],
+	  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],
+		 [lt_append([$1], [$2], [$3])$4],
+		 [$5])],
+	  [lt_append([$1], [$2], [$3])$4])])
+
+
+# lt_dict_add(DICT, KEY, VALUE)
+# -----------------------------
+m4_define([lt_dict_add],
+[m4_define([$1($2)], [$3])])
+
+
+# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)
+# --------------------------------------------
+m4_define([lt_dict_add_subkey],
+[m4_define([$1($2:$3)], [$4])])
+
+
+# lt_dict_fetch(DICT, KEY, [SUBKEY])
+# ----------------------------------
+m4_define([lt_dict_fetch],
+[m4_ifval([$3],
+	m4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),
+    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])
+
+
+# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])
+# -----------------------------------------------------------------
+m4_define([lt_if_dict_fetch],
+[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],
+	[$5],
+    [$6])])
+
+
+# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])
+# --------------------------------------------------------------
+m4_define([lt_dict_filter],
+[m4_if([$5], [], [],
+  [lt_join(m4_quote(m4_default([$4], [[, ]])),
+           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),
+		      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl
+])
+
+# ltversion.m4 -- version numbers			-*- Autoconf -*-
+#
+#   Copyright (C) 2004 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# Generated from ltversion.in.
+
+# serial 3017 ltversion.m4
+# This file is part of GNU Libtool
+
+m4_define([LT_PACKAGE_VERSION], [2.2.6b])
+m4_define([LT_PACKAGE_REVISION], [1.3017])
+
+AC_DEFUN([LTVERSION_VERSION],
+[macro_version='2.2.6b'
+macro_revision='1.3017'
+_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])
+_LT_DECL(, macro_revision, 0)
+])
+
+# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
+#
+#   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004.
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 4 lt~obsolete.m4
+
+# These exist entirely to fool aclocal when bootstrapping libtool.
+#
+# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
+# which have later been changed to m4_define as they aren't part of the
+# exported API, or moved to Autoconf or Automake where they belong.
+#
+# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN
+# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us
+# using a macro with the same name in our local m4/libtool.m4 it'll
+# pull the old libtool.m4 in (it doesn't see our shiny new m4_define
+# and doesn't know about Autoconf macros at all.)
+#
+# So we provide this file, which has a silly filename so it's always
+# included after everything else.  This provides aclocal with the
+# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
+# because those macros already exist, or will be overwritten later.
+# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6.
+#
+# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
+# Yes, that means every name once taken will need to remain here until
+# we give up compatibility with versions before 1.7, at which point
+# we need to keep only those names which we still refer to.
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])
+
+m4_ifndef([AC_LIBTOOL_LINKER_OPTION],	[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])
+m4_ifndef([AC_PROG_EGREP],		[AC_DEFUN([AC_PROG_EGREP])])
+m4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_AC_SHELL_INIT],		[AC_DEFUN([_LT_AC_SHELL_INIT])])
+m4_ifndef([_LT_AC_SYS_LIBPATH_AIX],	[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])
+m4_ifndef([_LT_PROG_LTMAIN],		[AC_DEFUN([_LT_PROG_LTMAIN])])
+m4_ifndef([_LT_AC_TAGVAR],		[AC_DEFUN([_LT_AC_TAGVAR])])
+m4_ifndef([AC_LTDL_ENABLE_INSTALL],	[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])
+m4_ifndef([AC_LTDL_PREOPEN],		[AC_DEFUN([AC_LTDL_PREOPEN])])
+m4_ifndef([_LT_AC_SYS_COMPILER],	[AC_DEFUN([_LT_AC_SYS_COMPILER])])
+m4_ifndef([_LT_AC_LOCK],		[AC_DEFUN([_LT_AC_LOCK])])
+m4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],	[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])
+m4_ifndef([_LT_AC_TRY_DLOPEN_SELF],	[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])
+m4_ifndef([AC_LIBTOOL_PROG_CC_C_O],	[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])
+m4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])
+m4_ifndef([AC_LIBTOOL_OBJDIR],		[AC_DEFUN([AC_LIBTOOL_OBJDIR])])
+m4_ifndef([AC_LTDL_OBJDIR],		[AC_DEFUN([AC_LTDL_OBJDIR])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])
+m4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],	[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])
+m4_ifndef([AC_PATH_MAGIC],		[AC_DEFUN([AC_PATH_MAGIC])])
+m4_ifndef([AC_PROG_LD_GNU],		[AC_DEFUN([AC_PROG_LD_GNU])])
+m4_ifndef([AC_PROG_LD_RELOAD_FLAG],	[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])
+m4_ifndef([AC_DEPLIBS_CHECK_METHOD],	[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])
+m4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],	[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])
+m4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],	[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])
+m4_ifndef([LT_AC_PROG_EGREP],		[AC_DEFUN([LT_AC_PROG_EGREP])])
+m4_ifndef([LT_AC_PROG_SED],		[AC_DEFUN([LT_AC_PROG_SED])])
+m4_ifndef([_LT_CC_BASENAME],		[AC_DEFUN([_LT_CC_BASENAME])])
+m4_ifndef([_LT_COMPILER_BOILERPLATE],	[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])
+m4_ifndef([_LT_LINKER_BOILERPLATE],	[AC_DEFUN([_LT_LINKER_BOILERPLATE])])
+m4_ifndef([_AC_PROG_LIBTOOL],		[AC_DEFUN([_AC_PROG_LIBTOOL])])
+m4_ifndef([AC_LIBTOOL_SETUP],		[AC_DEFUN([AC_LIBTOOL_SETUP])])
+m4_ifndef([_LT_AC_CHECK_DLFCN],		[AC_DEFUN([_LT_AC_CHECK_DLFCN])])
+m4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],	[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])
+m4_ifndef([_LT_AC_TAGCONFIG],		[AC_DEFUN([_LT_AC_TAGCONFIG])])
+m4_ifndef([AC_DISABLE_FAST_INSTALL],	[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])
+m4_ifndef([_LT_AC_LANG_CXX],		[AC_DEFUN([_LT_AC_LANG_CXX])])
+m4_ifndef([_LT_AC_LANG_F77],		[AC_DEFUN([_LT_AC_LANG_F77])])
+m4_ifndef([_LT_AC_LANG_GCJ],		[AC_DEFUN([_LT_AC_LANG_GCJ])])
+m4_ifndef([AC_LIBTOOL_RC],		[AC_DEFUN([AC_LIBTOOL_RC])])
+m4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])
+m4_ifndef([_LT_AC_LANG_C_CONFIG],	[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])
+m4_ifndef([_LT_AC_LANG_CXX_CONFIG],	[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])
+m4_ifndef([_LT_AC_LANG_F77_CONFIG],	[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])
+m4_ifndef([_LT_AC_LANG_GCJ_CONFIG],	[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])
+m4_ifndef([_LT_AC_LANG_RC_CONFIG],	[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])
+m4_ifndef([AC_LIBTOOL_CONFIG],		[AC_DEFUN([AC_LIBTOOL_CONFIG])])
+m4_ifndef([_LT_AC_FILE_LTDLL_C],	[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])
+
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+# (This private macro should not be called outside this file.)
+AC_DEFUN([AM_AUTOMAKE_VERSION],
+[am__api_version='1.11'
+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
+dnl require some minimum version.  Point them to the right macro.
+m4_if([$1], [1.11], [],
+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
+])
+
+# _AM_AUTOCONF_VERSION(VERSION)
+# -----------------------------
+# aclocal traces this macro to find the Autoconf version.
+# This is a private macro too.  Using m4_define simplifies
+# the logic in aclocal, which can simply ignore this definition.
+m4_define([_AM_AUTOCONF_VERSION], [])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+[AM_AUTOMAKE_VERSION([1.11])dnl
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 9
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])dnl
+AC_SUBST([$1_FALSE])dnl
+_AM_SUBST_NOTMAKE([$1_TRUE])dnl
+_AM_SUBST_NOTMAKE([$1_FALSE])dnl
+m4_define([_AM_COND_VALUE_$1], [$2])dnl
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 10
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  am__universal=false
+  m4_case([$1], [CC],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac],
+    [CXX],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac])
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 5
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[{
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`AS_DIRNAME("$mf")`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`AS_DIRNAME(["$file"])`
+      AS_MKDIR_P([$dirpart/$fdir])
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 16
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.62])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+			     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+		  [_AM_DEPENDENCIES(CC)],
+		  [define([AC_PROG_CC],
+			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+		  [_AM_DEPENDENCIES(CXX)],
+		  [define([AC_PROG_CXX],
+			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJC],
+		  [_AM_DEPENDENCIES(OBJC)],
+		  [define([AC_PROG_OBJC],
+			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+])
+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
+AC_CONFIG_COMMANDS_PRE(dnl
+[m4_provide_if([_AM_COMPILER_EXEEXT],
+  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
+])
+
+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
+dnl mangled by Autoconf and run in a shell conditional statement.
+m4_define([_AC_COMPILER_EXEEXT],
+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_arg=$1
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+AC_SUBST(install_sh)])
+
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
+# From Jim Meyering
+
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 5
+
+# AM_MAINTAINER_MODE([DEFAULT-MODE])
+# ----------------------------------
+# Control maintainer-specific portions of Makefiles.
+# Default is to disable them, unless `enable' is passed literally.
+# For symmetry, `disable' may be passed as well.  Anyway, the user
+# can override the default with the --enable/--disable switch.
+AC_DEFUN([AM_MAINTAINER_MODE],
+[m4_case(m4_default([$1], [disable]),
+       [enable], [m4_define([am_maintainer_other], [disable])],
+       [disable], [m4_define([am_maintainer_other], [enable])],
+       [m4_define([am_maintainer_other], [enable])
+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed
+  AC_ARG_ENABLE([maintainer-mode],
+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer],
+      [USE_MAINTAINER_MODE=$enableval],
+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
+  MAINT=$MAINTAINER_MODE_TRUE
+  AC_SUBST([MAINT])dnl
+]
+)
+
+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 6
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([missing])dnl
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check for `mkdir -p'.
+AC_DEFUN([AM_PROG_MKDIR_P],
+[AC_PREREQ([2.60])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
+dnl while keeping a definition of mkdir_p for backward compatibility.
+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
+dnl Makefile.ins that do not define MKDIR_P, so we do our own
+dnl adjustment using top_builddir (which is defined more often than
+dnl MKDIR_P).
+AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
+case $mkdir_p in
+  [[\\/$]]* | ?:[[\\/]]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 5
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[[\\\"\#\$\&\'\`$am_lf]]*)
+    AC_MSG_ERROR([unsafe absolute working directory name]);;
+esac
+case $srcdir in
+  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
+# This macro is traced by Automake.
+AC_DEFUN([_AM_SUBST_NOTMAKE])
+
+# AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Public sister of _AM_SUBST_NOTMAKE.
+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
Index: b/sieve/config.guess
===================================================================
--- /dev/null
+++ b/sieve/config.guess
@@ -0,0 +1,1526 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
+
+timestamp='2008-01-23'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Originally written by Per Bothner <per@bothner.com>.
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit build system type.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep __ELF__ >/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[456])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:FreeBSD:*:*)
+	case ${UNAME_MACHINE} in
+	    pc98)
+		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    *:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    *:Interix*:[3456]*)
+    	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    EM64T | authenticamd)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    arm*:Linux:*:*)
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	else
+	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    mips:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^CPU/{
+		s: ::g
+		p
+	    }'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-gnu
+	exit ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit ;;
+    xtensa*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    i*86:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
+			 | sed -ne '/supported targets:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported targets: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_targets" in
+	  elf32-i386)
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		;;
+	  a.out-i386-linux)
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit ;;
+	  coff-i386)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit ;;
+	  "")
+		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+		# one that does not give us useful --help.
+		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+		exit ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ >= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
+EOF
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
+	    /^LIBC/{
+		s: ::g
+		p
+	    }'`"
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && { echo i486-ncr-sysv4; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+eval $set_cc_for_build
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    c34*)
+	echo c34-convex-bsd
+	exit ;;
+    c38*)
+	echo c38-convex-bsd
+	exit ;;
+    c4*)
+	echo c4-convex-bsd
+	exit ;;
+    esac
+fi
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+and
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
Index: b/sieve/config.rpath
===================================================================
--- /dev/null
+++ b/sieve/config.rpath
@@ -0,0 +1,666 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2007 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+#   This file is free software; the Free Software Foundation gives
+#   unlimited permission to copy and/or distribute it, with or without
+#   modifications, as long as this notice is preserved.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# Known limitations:
+# - On IRIX 6.5 with CC="cc", the run time search patch must not be longer
+#   than 256 bytes, otherwise the compiler driver will dump core. The only
+#   known workaround is to choose shorter directory names for the build
+#   directory and/or the installation directory.
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+shrext=.so
+
+host="$1"
+host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+# Code taken from libtool.m4's _LT_CC_BASENAME.
+
+for cc_temp in $CC""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`echo "$cc_temp" | sed -e 's%^.*/%%'`
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
+
+wl=
+if test "$GCC" = yes; then
+  wl='-Wl,'
+else
+  case "$host_os" in
+    aix*)
+      wl='-Wl,'
+      ;;
+    darwin*)
+      case $cc_basename in
+        xlc*)
+          wl='-Wl,'
+          ;;
+      esac
+      ;;
+    mingw* | cygwin* | pw32* | os2*)
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6* | nonstopux*)
+      wl='-Wl,'
+      ;;
+    newsos6)
+      ;;
+    linux* | k*bsd*-gnu)
+      case $cc_basename in
+        icc* | ecc*)
+          wl='-Wl,'
+          ;;
+        pgcc | pgf77 | pgf90)
+          wl='-Wl,'
+          ;;
+        ccc*)
+          wl='-Wl,'
+          ;;
+        como)
+          wl='-lopt='
+          ;;
+        *)
+          case `$CC -V 2>&1 | sed 5q` in
+            *Sun\ C*)
+              wl='-Wl,'
+              ;;
+          esac
+          ;;
+      esac
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    rdos*)
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      wl='-Wl,'
+      ;;
+    sysv4*MP*)
+      ;;
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      wl='-Wl,'
+      ;;
+    unicos*)
+      wl='-Wl,'
+      ;;
+    uts4*)
+      ;;
+  esac
+fi
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case "$host_os" in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # Set some defaults for GNU ld with shared library support. These
+  # are reset later if shared libraries are not supported. Putting them
+  # here allows them to be overridden if necessary.
+  # Unlike libtool, we use -rpath here, not --rpath, since the documented
+  # option of GNU ld is called -rpath, not --rpath.
+  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+        ld_shlibs=no
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we cannot use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      ;;
+    gnu* | linux* | k*bsd*-gnu)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    netbsd*)
+      ;;
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+          ld_shlibs=no
+          ;;
+        *)
+          if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+            hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+          else
+            ld_shlibs=no
+          fi
+          ;;
+      esac
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test "$ld_shlibs" = no; then
+    hardcode_libdir_flag_spec=
+  fi
+else
+  case "$host_os" in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+          ;;
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test "$GCC" = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f "$collect2name" && \
+            strings "$collect2name" | grep resolve_lib_name >/dev/null
+          then
+            # We have reworked collect2
+            :
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+          ;;
+        esac
+      fi
+      # Begin _LT_AC_SYS_LIBPATH_AIX.
+      echo 'int main () { return 0; }' > conftest.c
+      ${CC} ${LDFLAGS} conftest.c -o conftest
+      aix_libpath=`dump -H conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      if test -z "$aix_libpath"; then
+        aix_libpath=`dump -HX64 conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      fi
+      if test -z "$aix_libpath"; then
+        aix_libpath="/usr/lib:/lib"
+      fi
+      rm -f conftest.c conftest
+      # End _LT_AC_SYS_LIBPATH_AIX.
+      if test "$aix_use_runtimelinking" = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+      else
+        if test "$host_cpu" = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    bsdi[45]*)
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=no
+      if test "$GCC" = yes ; then
+        :
+      else
+        case $cc_basename in
+          xlc*)
+            ;;
+          *)
+            ld_shlibs=no
+            ;;
+        esac
+      fi
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd* | dragonfly*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      ;;
+    hpux10*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        hardcode_direct=yes
+        # hardcode_minus_L: Not really in the search PATH,
+        # but as the default location of the library.
+        hardcode_minus_L=yes
+      fi
+      ;;
+    hpux11*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        case $host_cpu in
+          hppa*64*|ia64*)
+            hardcode_direct=no
+            ;;
+          *)
+            hardcode_direct=yes
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+        esac
+      fi
+      ;;
+    irix5* | irix6* | nonstopux*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+        hardcode_direct=yes
+        if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+          hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+        else
+          case "$host_os" in
+            openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+              hardcode_libdir_flag_spec='-R$libdir'
+              ;;
+            *)
+              hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+              ;;
+          esac
+        fi
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test "$GCC" = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      case $host_vendor in
+        sni)
+          hardcode_direct=yes # is this really true???
+          ;;
+        siemens)
+          hardcode_direct=no
+          ;;
+        motorola)
+          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+          ;;
+      esac
+      ;;
+    sysv4.3*)
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      ;;
+    sysv5* | sco3.2v5* | sco5v6*)
+      hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator=':'
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
+# Unlike libtool.m4, here we don't care about _all_ names of the library, but
+# only about the one the linker finds when passed -lNAME. This is the last
+# element of library_names_spec in libtool.m4, or possibly two of them if the
+# linker has special search rules.
+library_names_spec=      # the last element of library_names_spec in libtool.m4
+libname_spec='lib$name'
+case "$host_os" in
+  aix3*)
+    library_names_spec='$libname.a'
+    ;;
+  aix4* | aix5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  amigaos*)
+    library_names_spec='$libname.a'
+    ;;
+  beos*)
+    library_names_spec='$libname$shrext'
+    ;;
+  bsdi[45]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  cygwin* | mingw* | pw32*)
+    shrext=.dll
+    library_names_spec='$libname.dll.a $libname.lib'
+    ;;
+  darwin* | rhapsody*)
+    shrext=.dylib
+    library_names_spec='$libname$shrext'
+    ;;
+  dgux*)
+    library_names_spec='$libname$shrext'
+    ;;
+  freebsd1*)
+    ;;
+  freebsd* | dragonfly*)
+    case "$host_os" in
+      freebsd[123]*)
+        library_names_spec='$libname$shrext$versuffix' ;;
+      *)
+        library_names_spec='$libname$shrext' ;;
+    esac
+    ;;
+  gnu*)
+    library_names_spec='$libname$shrext'
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    case $host_cpu in
+      ia64*)
+        shrext=.so
+        ;;
+      hppa*64*)
+        shrext=.sl
+        ;;
+      *)
+        shrext=.sl
+        ;;
+    esac
+    library_names_spec='$libname$shrext'
+    ;;
+  interix[3-9]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  irix5* | irix6* | nonstopux*)
+    library_names_spec='$libname$shrext'
+    case "$host_os" in
+      irix5* | nonstopux*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ") libsuff= shlibsuff= ;;
+          *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ") libsuff=32 shlibsuff=N32 ;;
+          *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ") libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    ;;
+  linux*oldld* | linux*aout* | linux*coff*)
+    ;;
+  linux* | k*bsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  knetbsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  netbsd*)
+    library_names_spec='$libname$shrext'
+    ;;
+  newsos6)
+    library_names_spec='$libname$shrext'
+    ;;
+  nto-qnx*)
+    library_names_spec='$libname$shrext'
+    ;;
+  openbsd*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  os2*)
+    libname_spec='$name'
+    shrext=.dll
+    library_names_spec='$libname.a'
+    ;;
+  osf3* | osf4* | osf5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  rdos*)
+    ;;
+  solaris*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sunos4*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  sysv4 | sysv4.3*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv4*MP*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    library_names_spec='$libname$shrext'
+    ;;
+  uts4*)
+    library_names_spec='$libname$shrext'
+    ;;
+esac
+
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
+shlibext=`echo "$shrext" | sed -e 's,^\.,,'`
+escaped_libname_spec=`echo "X$libname_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_library_names_spec=`echo "X$library_names_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+
+LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
+
+# How to pass a linker flag through the compiler.
+wl="$escaped_wl"
+
+# Static library suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally "so").
+shlibext="$shlibext"
+
+# Format of library name prefix.
+libname_spec="$escaped_libname_spec"
+
+# Library names that the linker finds when passed -lNAME.
+library_names_spec="$escaped_library_names_spec"
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator="$hardcode_libdir_separator"
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct="$hardcode_direct"
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L="$hardcode_minus_L"
+
+EOF
Index: b/sieve/config.sub
===================================================================
--- /dev/null
+++ b/sieve/config.sub
@@ -0,0 +1,1658 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+#   Free Software Foundation, Inc.
+
+timestamp='2008-01-16'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
+2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray)
+		os=
+		basic_machine=$1
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| bfin \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fido | fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | mcore | mep \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| mt \
+	| msp430 \
+	| nios | nios2 \
+	| ns16k | ns32k \
+	| or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu | strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xc16x | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| z8k)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* | avr32-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| m32c-* | m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
+	| msp430-* \
+	| nios-* | nios2-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa*-* \
+	| ymp-* \
+	| z8k-*)
+		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+		;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rdos)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+	tile*)
+		basic_machine=tile-unknown
+		os=-linux-gnu
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+        -os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+        -tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+        score-*)
+		os=-elf
+		;;
+        spu-*)
+		os=-elf
+		;;
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+        c4x-* | tic4x-*)
+        	os=-coff
+		;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+        mep-*)
+		os=-elf
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
+	*-ibm)
+		os=-aix
+		;;
+    	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
Index: b/sieve/configure
===================================================================
--- /dev/null
+++ b/sieve/configure
@@ -0,0 +1,12854 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.65 for Dovecot Sieve 0.1.14.
+#
+# Report bugs to <dovecot@dovecot.org>.
+#
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation,
+# Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  # We cannot yet assume a decent shell, so we have to provide a
+	# neutralization value for shells without unset; and this also
+	# works around shells that cannot unset nonexistent variables.
+	BASH_ENV=/dev/null
+	ENV=/dev/null
+	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+	export CONFIG_SHELL
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org and
+$0: dovecot@dovecot.org about your system, including any
+$0: error possibly output before this message. Then install
+$0: a modern shell, or manually run the script under such a
+$0: shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+
+# Check that we are running under the correct shell.
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+case X$lt_ECHO in
+X*--fallback-echo)
+  # Remove one level of quotation (which was required for Make).
+  ECHO=`echo "$lt_ECHO" | sed 's,\\\\\$\\$0,'$0','`
+  ;;
+esac
+
+ECHO=${lt_ECHO-echo}
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' ; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell.
+  exec $SHELL "$0" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<_LT_EOF
+$*
+_LT_EOF
+  exit 0
+fi
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test -z "$lt_ECHO"; then
+  if test "X${echo_test_string+set}" != Xset; then
+    # find a string as large as possible, as long as the shell can cope with it
+    for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do
+      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&
+	 { test "X$echo_test_string" = "X$echo_test_string"; } 2>/dev/null
+      then
+        break
+      fi
+    done
+  fi
+
+  if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+     echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+     test "X$echo_testing_string" = "X$echo_test_string"; then
+    :
+  else
+    # The Solaris, AIX, and Digital Unix default echo programs unquote
+    # backslashes.  This makes it impossible to quote backslashes using
+    #   echo "$something" | sed 's/\\/\\\\/g'
+    #
+    # So, first we look for a working echo in the user's PATH.
+
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for dir in $PATH /usr/ucb; do
+      IFS="$lt_save_ifs"
+      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+         test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        ECHO="$dir/echo"
+        break
+      fi
+    done
+    IFS="$lt_save_ifs"
+
+    if test "X$ECHO" = Xecho; then
+      # We didn't find a better echo, so look for alternatives.
+      if test "X`{ print -r '\t'; } 2>/dev/null`" = 'X\t' &&
+         echo_testing_string=`{ print -r "$echo_test_string"; } 2>/dev/null` &&
+         test "X$echo_testing_string" = "X$echo_test_string"; then
+        # This shell has a builtin print -r that does the trick.
+        ECHO='print -r'
+      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&
+	   test "X$CONFIG_SHELL" != X/bin/ksh; then
+        # If we have ksh, try running configure again with it.
+        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+        export ORIGINAL_CONFIG_SHELL
+        CONFIG_SHELL=/bin/ksh
+        export CONFIG_SHELL
+        exec $CONFIG_SHELL "$0" --no-reexec ${1+"$@"}
+      else
+        # Try using printf.
+        ECHO='printf %s\n'
+        if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
+	   echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	  # Cool, printf works
+	  :
+        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	  export CONFIG_SHELL
+	  SHELL="$CONFIG_SHELL"
+	  export SHELL
+	  ECHO="$CONFIG_SHELL $0 --fallback-echo"
+        elif echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	     test "X$echo_testing_string" = 'X\t' &&
+	     echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	     test "X$echo_testing_string" = "X$echo_test_string"; then
+	  ECHO="$CONFIG_SHELL $0 --fallback-echo"
+        else
+	  # maybe with a smaller string...
+	  prev=:
+
+	  for cmd in 'echo test' 'sed 2q "$0"' 'sed 10q "$0"' 'sed 20q "$0"' 'sed 50q "$0"'; do
+	    if { test "X$echo_test_string" = "X`eval $cmd`"; } 2>/dev/null
+	    then
+	      break
+	    fi
+	    prev="$cmd"
+	  done
+
+	  if test "$prev" != 'sed 50q "$0"'; then
+	    echo_test_string=`eval $prev`
+	    export echo_test_string
+	    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "$0" ${1+"$@"}
+	  else
+	    # Oops.  We lost completely, so just stick with echo.
+	    ECHO=echo
+	  fi
+        fi
+      fi
+    fi
+  fi
+fi
+
+# Copy echo and quote the copy suitably for passing to libtool from
+# the Makefile, instead of quoting the original, which is used later.
+lt_ECHO=$ECHO
+if test "X$lt_ECHO" = "X$CONFIG_SHELL $0 --fallback-echo"; then
+   lt_ECHO="$CONFIG_SHELL \\\$\$0 --fallback-echo"
+fi
+
+
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME='Dovecot Sieve'
+PACKAGE_TARNAME='dovecot-1.2-sieve'
+PACKAGE_VERSION='0.1.14'
+PACKAGE_STRING='Dovecot Sieve 0.1.14'
+PACKAGE_BUGREPORT='dovecot@dovecot.org'
+PACKAGE_URL=''
+
+ac_unique_file="src"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='am__EXEEXT_FALSE
+am__EXEEXT_TRUE
+LTLIBOBJS
+LIBOBJS
+moduledir
+dovecot_incdir
+MODULE_LIBS
+RAND_LIBS
+LIBICONV
+STORAGE_LIBS
+TESTSUITE_VALGRIND_FALSE
+TESTSUITE_VALGRIND_TRUE
+BUILD_UNFINISHED_FALSE
+BUILD_UNFINISHED_TRUE
+HAVE_DOVECOT_LIBS_FALSE
+HAVE_DOVECOT_LIBS_TRUE
+dovecotdir
+OTOOL64
+OTOOL
+LIPO
+NMEDIT
+DSYMUTIL
+lt_ECHO
+RANLIB
+AR
+OBJDUMP
+LN_S
+NM
+ac_ct_DUMPBIN
+DUMPBIN
+LD
+FGREP
+EGREP
+GREP
+SED
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+LIBTOOL
+CPP
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+MAINT
+MAINTAINER_MODE_FALSE
+MAINTAINER_MODE_TRUE
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_maintainer_mode
+enable_dependency_tracking
+enable_shared
+enable_static
+with_pic
+enable_fast_install
+with_gnu_ld
+enable_libtool_lock
+with_dovecot
+with_unfinished_features
+enable_valgrind
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information."
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures Dovecot Sieve 0.1.14 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root
+                          [DATAROOTDIR/doc/dovecot-1.2-sieve]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of Dovecot Sieve 0.1.14:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-shared[=PKGS]  build shared libraries [default=yes]
+  --enable-static[=PKGS]  build static libraries [default=yes]
+  --enable-fast-install[=PKGS]
+                          optimize for fast installation [default=yes]
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+  --enable-valgrind       Enable Valgrind memory leak checks in testsuite
+                          [default=no]
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pic              try to use only PIC/non-PIC objects [default=use
+                          both]
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+  --with-dovecot=DIR      Dovecot base directory [../dovecot]
+  --with-unfinished-features
+                          Build unfinished new features/extensions
+                          [default=no]
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to <dovecot@dovecot.org>.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+Dovecot Sieve configure 0.1.14
+generated by GNU Autoconf 2.65
+
+Copyright (C) 2009 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_func
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by Dovecot Sieve $as_me 0.1.14, which was
+generated by GNU Autoconf 2.65.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  ac_site_file1=$CONFIG_SITE
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+# Autoheader is not needed and does more harm than good for this package. However, it is
+# tightly integrated in autoconf/automake and therefore it is difficult not to use it. As
+# a workaround we give autoheader a dummy config header to chew on and we handle the
+# real config header ourselves.
+ac_config_headers="$ac_config_headers dummy-config.h dsieve-config.h"
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIEVE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIEVE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+am__api_version='1.11'
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[\\\"\#\$\&\'\`$am_lf]*)
+    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
+esac
+case $srcdir in
+  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
+    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" "$LINENO" 5
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   as_fn_error "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if test "${ac_cv_path_mkdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  test -d ./--version && rmdir ./--version
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+mkdir_p="$MKDIR_P"
+case $mkdir_p in
+  [\\/$]* | ?:[\\/]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='dovecot-1.2-sieve'
+ VERSION='0.1.14'
+
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
+$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
+    # Check whether --enable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then :
+  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
+$as_echo "$USE_MAINTAINER_MODE" >&6; }
+   if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "no acceptable C compiler found in \$PATH
+See \`config.log' for more details." "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+if test -z "$ac_file"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ as_fn_set_status 77
+as_fn_error "C compiler cannot create executables
+See \`config.log' for more details." "$LINENO" 5; }; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+ac_exeext=$ac_cv_exeext
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+rm -f conftest conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+FILE *f = fopen ("conftest.out", "w");
+ return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files="$ac_clean_files conftest.out"
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+if test "$cross_compiling" != yes; then
+  { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+  if { ac_try='./conftest$ac_cv_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." "$LINENO" 5; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if test "${ac_cv_objext+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
+
+
+
+macro_version='2.2.6b'
+macro_revision='1.3017'
+
+
+
+
+
+
+
+
+
+
+
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if test "${ac_cv_path_SED+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if test "${ac_cv_path_FGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+
+test -z "$GREP" && GREP=grep
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
+$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+if test "${lt_cv_path_NM+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
+$as_echo "$lt_cv_path_NM" >&6; }
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in "dumpbin -symbols" "link -dump -symbols"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DUMPBIN"; then
+  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DUMPBIN=$ac_cv_prog_DUMPBIN
+if test -n "$DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
+$as_echo "$DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$DUMPBIN" && break
+  done
+fi
+if test -z "$DUMPBIN"; then
+  ac_ct_DUMPBIN=$DUMPBIN
+  for ac_prog in "dumpbin -symbols" "link -dump -symbols"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DUMPBIN"; then
+  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
+if test -n "$ac_ct_DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
+$as_echo "$ac_ct_DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_DUMPBIN" && break
+done
+
+  if test "x$ac_ct_DUMPBIN" = x; then
+    DUMPBIN=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DUMPBIN=$ac_ct_DUMPBIN
+  fi
+fi
+
+
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
+$as_echo_n "checking the name lister ($NM) interface... " >&6; }
+if test "${lt_cv_nm_interface+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:4573: $ac_compile\"" >&5)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:4576: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:4579: output\"" >&5)
+  cat conftest.out >&5
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
+$as_echo "$lt_cv_nm_interface" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
+fi
+
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+    i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`$SHELL $0 --fallback-echo "X$teststring$teststring" 2>/dev/null` \
+	         = "XX$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+
+fi
+
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
+$as_echo "none" >&6; }
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+
+
+
+
+
+
+: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
+$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
+$as_echo "$xsi_shell" >&6; }
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
+$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
+$as_echo "$lt_shell_append" >&6; }
+
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+
+
+
+
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if test "${lt_cv_ld_reload_flag+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
+$as_echo "$OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OBJDUMP="objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
+$as_echo "$ac_ct_OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OBJDUMP" = x; then
+    OBJDUMP="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJDUMP=$ac_ct_OBJDUMP
+  fi
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
+$as_echo_n "checking how to recognize dependent libraries... " >&6; }
+if test "${lt_cv_deplibs_check_method+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[4-9]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  if ( file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]'
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9].[0-9]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[3-9]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
+$as_echo "$lt_cv_deplibs_check_method" >&6; }
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AR+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+test -z "$STRIP" && STRIP=:
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+test -z "$RANLIB" && RANLIB=:
+
+
+
+
+
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
+$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDEGRST]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris*)
+  symcode='[BDRT]'
+  ;;
+sco3.2v5*)
+  symcode='[DT]'
+  ;;
+sysv4.2uw2*)
+  symcode='[DT]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[ABDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK '"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\""; } >&5
+  (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
+$as_echo "failed" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
+fi
+
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line 5785 "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_i386"
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if test "${lt_cv_cc_needs_belf+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_cc_needs_belf=yes
+else
+  lt_cv_cc_needs_belf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+
+
+  case $host_os in
+    rhapsody* | darwin*)
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DSYMUTIL"; then
+  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DSYMUTIL=$ac_cv_prog_DSYMUTIL
+if test -n "$DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
+$as_echo "$DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_DSYMUTIL"; then
+  ac_ct_DSYMUTIL=$DSYMUTIL
+  # Extract the first word of "dsymutil", so it can be a program name with args.
+set dummy dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DSYMUTIL"; then
+  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
+if test -n "$ac_ct_DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
+$as_echo "$ac_ct_DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_DSYMUTIL" = x; then
+    DSYMUTIL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DSYMUTIL=$ac_ct_DSYMUTIL
+  fi
+else
+  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
+set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NMEDIT"; then
+  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+NMEDIT=$ac_cv_prog_NMEDIT
+if test -n "$NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
+$as_echo "$NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_NMEDIT"; then
+  ac_ct_NMEDIT=$NMEDIT
+  # Extract the first word of "nmedit", so it can be a program name with args.
+set dummy nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_NMEDIT"; then
+  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
+if test -n "$ac_ct_NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
+$as_echo "$ac_ct_NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_NMEDIT" = x; then
+    NMEDIT=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    NMEDIT=$ac_ct_NMEDIT
+  fi
+else
+  NMEDIT="$ac_cv_prog_NMEDIT"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
+set dummy ${ac_tool_prefix}lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LIPO"; then
+  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+LIPO=$ac_cv_prog_LIPO
+if test -n "$LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
+$as_echo "$LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_LIPO"; then
+  ac_ct_LIPO=$LIPO
+  # Extract the first word of "lipo", so it can be a program name with args.
+set dummy lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_LIPO"; then
+  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_LIPO="lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
+if test -n "$ac_ct_LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
+$as_echo "$ac_ct_LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_LIPO" = x; then
+    LIPO=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LIPO=$ac_ct_LIPO
+  fi
+else
+  LIPO="$ac_cv_prog_LIPO"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+$as_echo "$OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+$as_echo "$ac_ct_OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL64"; then
+  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL64=$ac_cv_prog_OTOOL64
+if test -n "$OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
+$as_echo "$OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL64"; then
+  ac_ct_OTOOL64=$OTOOL64
+  # Extract the first word of "otool64", so it can be a program name with args.
+set dummy otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL64"; then
+  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL64="otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
+if test -n "$ac_ct_OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
+$as_echo "$ac_ct_OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL64" = x; then
+    OTOOL64=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL64=$ac_ct_OTOOL64
+  fi
+else
+  OTOOL64="$ac_cv_prog_OTOOL64"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
+$as_echo_n "checking for -single_module linker flag... " >&6; }
+if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&5
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&5
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
+$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
+$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
+if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_ld_exported_symbols_list=yes
+else
+  lt_cv_ld_exported_symbols_list=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
+$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
+    case $host_os in
+    rhapsody* | darwin1.[012])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[012]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
+
+fi
+
+done
+
+
+
+# Set options
+
+
+
+        enable_dlopen=no
+
+
+  enable_win32_dll=no
+
+
+            # Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then :
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_shared=yes
+fi
+
+
+
+
+
+
+
+
+
+  # Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then :
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_static=yes
+fi
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then :
+  withval=$with_pic; pic_mode="$withval"
+else
+  pic_mode=default
+fi
+
+
+test -z "$pic_mode" && pic_mode=default
+
+
+
+
+
+
+
+  # Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then :
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
+
+
+
+
+
+
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+test -z "$LN_S" && LN_S="ln -s"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if test "${lt_cv_objdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
+
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define LT_OBJDIR "$lt_cv_objdir/"
+_ACEOF
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+if test -n "$compiler"; then
+
+lt_prog_compiler_no_builtin_flag=
+
+if test "$GCC" = yes; then
+  lt_prog_compiler_no_builtin_flag=' -fno-builtin'
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7174: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:7178: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
+
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
+
+fi
+
+
+
+
+
+
+  lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='--shared'
+	lt_prog_compiler_static='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      xl*)
+	# IBM XL C 8.0/Fortran 10.1 on PPC
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-qpic'
+	lt_prog_compiler_static='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)
+	  # Sun C 5.9
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Wl,'
+	  ;;
+	*Sun\ F*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl=''
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    rdos*)
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
+
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
+$as_echo "$lt_prog_compiler_pic" >&6; }
+
+
+
+
+
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7513: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:7517: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
+else
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
+fi
+
+fi
+
+
+
+
+
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
+$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+    :
+else
+    lt_prog_compiler_static=
+fi
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7618: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:7622: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7673: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:7677: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  runpath_var=
+  allow_undefined_flag=
+  always_export_symbols=no
+  archive_cmds=
+  archive_expsym_cmds=
+  compiler_needs_object=no
+  enable_shared_with_static_runtimes=no
+  export_dynamic_flag_spec=
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  hardcode_automatic=no
+  hardcode_direct=no
+  hardcode_direct_absolute=no
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_flag_spec_ld=
+  hardcode_libdir_separator=
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  inherit_rpath=no
+  link_all_deplibs=unknown
+  module_cmds=
+  module_expsym_cmds=
+  old_archive_from_new_cmds=
+  old_archive_from_expsyms_cmds=
+  thread_safe_flag_spec=
+  whole_archive_flag_spec=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  linux* | k*bsd*-gnu)
+    link_all_deplibs=no
+    ;;
+  esac
+
+  ld_shlibs=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[3-9]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  whole_archive_flag_spec=
+	  tmp_sharedflag='--shared' ;;
+	xl[cC]*)			# IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
+	  hardcode_libdir_flag_spec=
+	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
+	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        ld_shlibs=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix[4-9]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_direct_absolute=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      file_list_spec='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	link_all_deplibs=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      export_dynamic_flag_spec='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  whole_archive_flag_spec='$convenience'
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      allow_undefined_flag=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds='$CC -o $lib $libobjs $compiler_flags `$ECHO "X$deplibs" | $Xsed -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_from_new_cmds='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes=yes
+      ;;
+
+    darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc=no
+  hardcode_direct=no
+  hardcode_automatic=yes
+  hardcode_shlibpath_var=unsupported
+  whole_archive_flag_spec=''
+  link_all_deplibs=yes
+  allow_undefined_flag="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=echo
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+
+  else
+  ld_shlibs=no
+  fi
+
+      ;;
+
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_flag_spec_ld='+b $libdir'
+	hardcode_libdir_separator=:
+	hardcode_direct=yes
+	hardcode_direct_absolute=yes
+	export_dynamic_flag_spec='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  hardcode_direct_absolute=yes
+	  export_dynamic_flag_spec='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int foo(void) {}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+        LDFLAGS="$save_LDFLAGS"
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      inherit_rpath=yes
+      link_all_deplibs=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	hardcode_direct=yes
+	hardcode_shlibpath_var=no
+	hardcode_direct_absolute=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	  export_dynamic_flag_spec='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     hardcode_libdir_flag_spec='-R$libdir'
+	     ;;
+	   *)
+	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO " SINGLE NONSHARED" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_separator=:
+      ;;
+
+    solaris*)
+      no_undefined_flag=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      link_all_deplibs=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      ld_shlibs=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
+
+with_gnu_ld=$with_gnu_ld
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+      $RM conftest*
+      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$lt_prog_compiler_wl
+	pic_flag=$lt_prog_compiler_pic
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$allow_undefined_flag
+        allow_undefined_flag=
+        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+        then
+	  archive_cmds_need_lc=no
+        else
+	  archive_cmds_need_lc=yes
+        fi
+        allow_undefined_flag=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $RM conftest*
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc" >&5
+$as_echo "$archive_cmds_need_lc" >&6; }
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if $ECHO "$lt_search_path_spec" | $GREP ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[lt_foo]++; }
+  if (lt_freq[lt_foo] == 1) { print lt_foo; }
+}'`
+  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # Some binutils ld are patched to set DT_RUNPATH
+  save_LDFLAGS=$LDFLAGS
+  save_libdir=$libdir
+  eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
+       LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
+  shlibpath_overrides_runpath=yes
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LDFLAGS=$save_LDFLAGS
+  libdir=$save_libdir
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" ||
+   test -n "$runpath_var" ||
+   test "X$hardcode_automatic" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
+
+if test "$hardcode_action" = relink ||
+   test "$inherit_rpath" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+  if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+
+fi
+
+    ;;
+
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
+else
+  ac_cv_lib_dld_shl_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_svld_dlopen=yes
+else
+  ac_cv_lib_svld_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_dld_link=yes
+else
+  ac_cv_lib_dld_dld_link=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 10057 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self_static+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 10153 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+striplib=
+old_striplib=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+    ;;
+  *)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+  # Report which library types will actually be built
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[4-9]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
+
+
+
+
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+CC="$lt_save_CC"
+
+
+
+
+
+
+
+
+
+
+
+
+
+        ac_config_commands="$ac_config_commands libtool"
+
+
+
+
+# Only expand once:
+
+
+
+
+# Check whether --with-dovecot was given.
+if test "${with_dovecot+set}" = set; then :
+  withval=$with_dovecot; dovecotdir="$withval"
+else
+  dovecotdir=../dovecot
+
+fi
+
+old=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $old
+
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  as_fn_error "dovecot-config not found" "$LINENO" 5
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  echo "WARNING: Cannot build Sieve commandline tools without the compiled"
+  echo "         Dovecot sources. Compiling against headers will only build"
+  echo "         the Sieve plugin."
+  have_dovecot_libs=no
+fi
+ if test "$have_dovecot_libs" = "yes"; then
+  HAVE_DOVECOT_LIBS_TRUE=
+  HAVE_DOVECOT_LIBS_FALSE='#'
+else
+  HAVE_DOVECOT_LIBS_TRUE='#'
+  HAVE_DOVECOT_LIBS_FALSE=
+fi
+
+
+# Extensions under development
+#
+
+
+# Check whether --with-unfinished-features was given.
+if test "${with_unfinished_features+set}" = set; then :
+  withval=$with_unfinished_features; if test x$withval = xno || test x$withval = xauto; then
+                want_unfinished_features=$withval
+        else
+                want_unfinished_features=yes
+        fi
+else
+  want_unfinished_features=no
+fi
+
+ if test "$want_unfinished_features" = "yes"; then
+  BUILD_UNFINISHED_TRUE=
+  BUILD_UNFINISHED_FALSE='#'
+else
+  BUILD_UNFINISHED_TRUE='#'
+  BUILD_UNFINISHED_FALSE=
+fi
+
+
+if test "$want_unfinished_features" = "yes"; then
+
+$as_echo "#define HAVE_SIEVE_UNFINISHED /**/" >>confdefs.h
+
+fi
+
+#
+#
+
+# Check whether --enable-valgrind was given.
+if test "${enable_valgrind+set}" = set; then :
+  enableval=$enable_valgrind; if test x$enableval = xno || test x$enableval = xauto; then
+        want_valgrind=$enableval
+    else
+        want_valgrind=yes
+    fi
+else
+  want_valgrind=no
+fi
+
+ if test "$want_valgrind" = "yes"; then
+  TESTSUITE_VALGRIND_TRUE=
+  TESTSUITE_VALGRIND_FALSE='#'
+else
+  TESTSUITE_VALGRIND_TRUE='#'
+  TESTSUITE_VALGRIND_FALSE=
+fi
+
+
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+
+
+
+
+
+
+
+ac_config_files="$ac_config_files Makefile src/Makefile src/lib-sieve/Makefile src/lib-sieve/plugins/Makefile src/lib-sieve/plugins/vacation/Makefile src/lib-sieve/plugins/subaddress/Makefile src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile src/lib-sieve/plugins/relational/Makefile src/lib-sieve/plugins/regex/Makefile src/lib-sieve/plugins/imap4flags/Makefile src/lib-sieve/plugins/copy/Makefile src/lib-sieve/plugins/include/Makefile src/lib-sieve/plugins/body/Makefile src/lib-sieve/plugins/variables/Makefile src/lib-sieve/plugins/enotify/Makefile src/lib-sieve/plugins/notify/Makefile src/lib-sieve/plugins/environment/Makefile src/lib-sieve/plugins/mailbox/Makefile src/lib-sieve/plugins/date/Makefile src/lib-sieve-tool/Makefile src/plugins/Makefile src/plugins/lda-sieve/Makefile src/sieve-tools/Makefile src/sieve-tools/debug/Makefile src/testsuite/Makefile stamp.h"
+
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+ if test -n "$EXEEXT"; then
+  am__EXEEXT_TRUE=
+  am__EXEEXT_FALSE='#'
+else
+  am__EXEEXT_TRUE='#'
+  am__EXEEXT_FALSE=
+fi
+
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${HAVE_DOVECOT_LIBS_TRUE}" && test -z "${HAVE_DOVECOT_LIBS_FALSE}"; then
+  as_fn_error "conditional \"HAVE_DOVECOT_LIBS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${BUILD_UNFINISHED_TRUE}" && test -z "${BUILD_UNFINISHED_FALSE}"; then
+  as_fn_error "conditional \"BUILD_UNFINISHED\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${TESTSUITE_VALGRIND_TRUE}" && test -z "${TESTSUITE_VALGRIND_FALSE}"; then
+  as_fn_error "conditional \"TESTSUITE_VALGRIND\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by Dovecot Sieve $as_me 0.1.14, which was
+generated by GNU Autoconf 2.65.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <dovecot@dovecot.org>."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+Dovecot Sieve config.status 0.1.14
+configured by $0, generated by GNU Autoconf 2.65,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2009 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+macro_version='`$ECHO "X$macro_version" | $Xsed -e "$delay_single_quote_subst"`'
+macro_revision='`$ECHO "X$macro_revision" | $Xsed -e "$delay_single_quote_subst"`'
+enable_shared='`$ECHO "X$enable_shared" | $Xsed -e "$delay_single_quote_subst"`'
+enable_static='`$ECHO "X$enable_static" | $Xsed -e "$delay_single_quote_subst"`'
+pic_mode='`$ECHO "X$pic_mode" | $Xsed -e "$delay_single_quote_subst"`'
+enable_fast_install='`$ECHO "X$enable_fast_install" | $Xsed -e "$delay_single_quote_subst"`'
+host_alias='`$ECHO "X$host_alias" | $Xsed -e "$delay_single_quote_subst"`'
+host='`$ECHO "X$host" | $Xsed -e "$delay_single_quote_subst"`'
+host_os='`$ECHO "X$host_os" | $Xsed -e "$delay_single_quote_subst"`'
+build_alias='`$ECHO "X$build_alias" | $Xsed -e "$delay_single_quote_subst"`'
+build='`$ECHO "X$build" | $Xsed -e "$delay_single_quote_subst"`'
+build_os='`$ECHO "X$build_os" | $Xsed -e "$delay_single_quote_subst"`'
+SED='`$ECHO "X$SED" | $Xsed -e "$delay_single_quote_subst"`'
+Xsed='`$ECHO "X$Xsed" | $Xsed -e "$delay_single_quote_subst"`'
+GREP='`$ECHO "X$GREP" | $Xsed -e "$delay_single_quote_subst"`'
+EGREP='`$ECHO "X$EGREP" | $Xsed -e "$delay_single_quote_subst"`'
+FGREP='`$ECHO "X$FGREP" | $Xsed -e "$delay_single_quote_subst"`'
+LD='`$ECHO "X$LD" | $Xsed -e "$delay_single_quote_subst"`'
+NM='`$ECHO "X$NM" | $Xsed -e "$delay_single_quote_subst"`'
+LN_S='`$ECHO "X$LN_S" | $Xsed -e "$delay_single_quote_subst"`'
+max_cmd_len='`$ECHO "X$max_cmd_len" | $Xsed -e "$delay_single_quote_subst"`'
+ac_objext='`$ECHO "X$ac_objext" | $Xsed -e "$delay_single_quote_subst"`'
+exeext='`$ECHO "X$exeext" | $Xsed -e "$delay_single_quote_subst"`'
+lt_unset='`$ECHO "X$lt_unset" | $Xsed -e "$delay_single_quote_subst"`'
+lt_SP2NL='`$ECHO "X$lt_SP2NL" | $Xsed -e "$delay_single_quote_subst"`'
+lt_NL2SP='`$ECHO "X$lt_NL2SP" | $Xsed -e "$delay_single_quote_subst"`'
+reload_flag='`$ECHO "X$reload_flag" | $Xsed -e "$delay_single_quote_subst"`'
+reload_cmds='`$ECHO "X$reload_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+OBJDUMP='`$ECHO "X$OBJDUMP" | $Xsed -e "$delay_single_quote_subst"`'
+deplibs_check_method='`$ECHO "X$deplibs_check_method" | $Xsed -e "$delay_single_quote_subst"`'
+file_magic_cmd='`$ECHO "X$file_magic_cmd" | $Xsed -e "$delay_single_quote_subst"`'
+AR='`$ECHO "X$AR" | $Xsed -e "$delay_single_quote_subst"`'
+AR_FLAGS='`$ECHO "X$AR_FLAGS" | $Xsed -e "$delay_single_quote_subst"`'
+STRIP='`$ECHO "X$STRIP" | $Xsed -e "$delay_single_quote_subst"`'
+RANLIB='`$ECHO "X$RANLIB" | $Xsed -e "$delay_single_quote_subst"`'
+old_postinstall_cmds='`$ECHO "X$old_postinstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+old_postuninstall_cmds='`$ECHO "X$old_postuninstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_cmds='`$ECHO "X$old_archive_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+CC='`$ECHO "X$CC" | $Xsed -e "$delay_single_quote_subst"`'
+CFLAGS='`$ECHO "X$CFLAGS" | $Xsed -e "$delay_single_quote_subst"`'
+compiler='`$ECHO "X$compiler" | $Xsed -e "$delay_single_quote_subst"`'
+GCC='`$ECHO "X$GCC" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_pipe='`$ECHO "X$lt_cv_sys_global_symbol_pipe" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_cdecl='`$ECHO "X$lt_cv_sys_global_symbol_to_cdecl" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "X$lt_cv_sys_global_symbol_to_c_name_address" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "X$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $Xsed -e "$delay_single_quote_subst"`'
+objdir='`$ECHO "X$objdir" | $Xsed -e "$delay_single_quote_subst"`'
+SHELL='`$ECHO "X$SHELL" | $Xsed -e "$delay_single_quote_subst"`'
+ECHO='`$ECHO "X$ECHO" | $Xsed -e "$delay_single_quote_subst"`'
+MAGIC_CMD='`$ECHO "X$MAGIC_CMD" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag='`$ECHO "X$lt_prog_compiler_no_builtin_flag" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_wl='`$ECHO "X$lt_prog_compiler_wl" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_pic='`$ECHO "X$lt_prog_compiler_pic" | $Xsed -e "$delay_single_quote_subst"`'
+lt_prog_compiler_static='`$ECHO "X$lt_prog_compiler_static" | $Xsed -e "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o='`$ECHO "X$lt_cv_prog_compiler_c_o" | $Xsed -e "$delay_single_quote_subst"`'
+need_locks='`$ECHO "X$need_locks" | $Xsed -e "$delay_single_quote_subst"`'
+DSYMUTIL='`$ECHO "X$DSYMUTIL" | $Xsed -e "$delay_single_quote_subst"`'
+NMEDIT='`$ECHO "X$NMEDIT" | $Xsed -e "$delay_single_quote_subst"`'
+LIPO='`$ECHO "X$LIPO" | $Xsed -e "$delay_single_quote_subst"`'
+OTOOL='`$ECHO "X$OTOOL" | $Xsed -e "$delay_single_quote_subst"`'
+OTOOL64='`$ECHO "X$OTOOL64" | $Xsed -e "$delay_single_quote_subst"`'
+libext='`$ECHO "X$libext" | $Xsed -e "$delay_single_quote_subst"`'
+shrext_cmds='`$ECHO "X$shrext_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+extract_expsyms_cmds='`$ECHO "X$extract_expsyms_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+archive_cmds_need_lc='`$ECHO "X$archive_cmds_need_lc" | $Xsed -e "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes='`$ECHO "X$enable_shared_with_static_runtimes" | $Xsed -e "$delay_single_quote_subst"`'
+export_dynamic_flag_spec='`$ECHO "X$export_dynamic_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
+whole_archive_flag_spec='`$ECHO "X$whole_archive_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
+compiler_needs_object='`$ECHO "X$compiler_needs_object" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_from_new_cmds='`$ECHO "X$old_archive_from_new_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds='`$ECHO "X$old_archive_from_expsyms_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+archive_cmds='`$ECHO "X$archive_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+archive_expsym_cmds='`$ECHO "X$archive_expsym_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+module_cmds='`$ECHO "X$module_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+module_expsym_cmds='`$ECHO "X$module_expsym_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+with_gnu_ld='`$ECHO "X$with_gnu_ld" | $Xsed -e "$delay_single_quote_subst"`'
+allow_undefined_flag='`$ECHO "X$allow_undefined_flag" | $Xsed -e "$delay_single_quote_subst"`'
+no_undefined_flag='`$ECHO "X$no_undefined_flag" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec='`$ECHO "X$hardcode_libdir_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_ld='`$ECHO "X$hardcode_libdir_flag_spec_ld" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_libdir_separator='`$ECHO "X$hardcode_libdir_separator" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_direct='`$ECHO "X$hardcode_direct" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_direct_absolute='`$ECHO "X$hardcode_direct_absolute" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_minus_L='`$ECHO "X$hardcode_minus_L" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_shlibpath_var='`$ECHO "X$hardcode_shlibpath_var" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_automatic='`$ECHO "X$hardcode_automatic" | $Xsed -e "$delay_single_quote_subst"`'
+inherit_rpath='`$ECHO "X$inherit_rpath" | $Xsed -e "$delay_single_quote_subst"`'
+link_all_deplibs='`$ECHO "X$link_all_deplibs" | $Xsed -e "$delay_single_quote_subst"`'
+fix_srcfile_path='`$ECHO "X$fix_srcfile_path" | $Xsed -e "$delay_single_quote_subst"`'
+always_export_symbols='`$ECHO "X$always_export_symbols" | $Xsed -e "$delay_single_quote_subst"`'
+export_symbols_cmds='`$ECHO "X$export_symbols_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+exclude_expsyms='`$ECHO "X$exclude_expsyms" | $Xsed -e "$delay_single_quote_subst"`'
+include_expsyms='`$ECHO "X$include_expsyms" | $Xsed -e "$delay_single_quote_subst"`'
+prelink_cmds='`$ECHO "X$prelink_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+file_list_spec='`$ECHO "X$file_list_spec" | $Xsed -e "$delay_single_quote_subst"`'
+variables_saved_for_relink='`$ECHO "X$variables_saved_for_relink" | $Xsed -e "$delay_single_quote_subst"`'
+need_lib_prefix='`$ECHO "X$need_lib_prefix" | $Xsed -e "$delay_single_quote_subst"`'
+need_version='`$ECHO "X$need_version" | $Xsed -e "$delay_single_quote_subst"`'
+version_type='`$ECHO "X$version_type" | $Xsed -e "$delay_single_quote_subst"`'
+runpath_var='`$ECHO "X$runpath_var" | $Xsed -e "$delay_single_quote_subst"`'
+shlibpath_var='`$ECHO "X$shlibpath_var" | $Xsed -e "$delay_single_quote_subst"`'
+shlibpath_overrides_runpath='`$ECHO "X$shlibpath_overrides_runpath" | $Xsed -e "$delay_single_quote_subst"`'
+libname_spec='`$ECHO "X$libname_spec" | $Xsed -e "$delay_single_quote_subst"`'
+library_names_spec='`$ECHO "X$library_names_spec" | $Xsed -e "$delay_single_quote_subst"`'
+soname_spec='`$ECHO "X$soname_spec" | $Xsed -e "$delay_single_quote_subst"`'
+postinstall_cmds='`$ECHO "X$postinstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+postuninstall_cmds='`$ECHO "X$postuninstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+finish_cmds='`$ECHO "X$finish_cmds" | $Xsed -e "$delay_single_quote_subst"`'
+finish_eval='`$ECHO "X$finish_eval" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_into_libs='`$ECHO "X$hardcode_into_libs" | $Xsed -e "$delay_single_quote_subst"`'
+sys_lib_search_path_spec='`$ECHO "X$sys_lib_search_path_spec" | $Xsed -e "$delay_single_quote_subst"`'
+sys_lib_dlsearch_path_spec='`$ECHO "X$sys_lib_dlsearch_path_spec" | $Xsed -e "$delay_single_quote_subst"`'
+hardcode_action='`$ECHO "X$hardcode_action" | $Xsed -e "$delay_single_quote_subst"`'
+enable_dlopen='`$ECHO "X$enable_dlopen" | $Xsed -e "$delay_single_quote_subst"`'
+enable_dlopen_self='`$ECHO "X$enable_dlopen_self" | $Xsed -e "$delay_single_quote_subst"`'
+enable_dlopen_self_static='`$ECHO "X$enable_dlopen_self_static" | $Xsed -e "$delay_single_quote_subst"`'
+old_striplib='`$ECHO "X$old_striplib" | $Xsed -e "$delay_single_quote_subst"`'
+striplib='`$ECHO "X$striplib" | $Xsed -e "$delay_single_quote_subst"`'
+
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# Quote evaled strings.
+for var in SED \
+GREP \
+EGREP \
+FGREP \
+LD \
+NM \
+LN_S \
+lt_SP2NL \
+lt_NL2SP \
+reload_flag \
+OBJDUMP \
+deplibs_check_method \
+file_magic_cmd \
+AR \
+AR_FLAGS \
+STRIP \
+RANLIB \
+CC \
+CFLAGS \
+compiler \
+lt_cv_sys_global_symbol_pipe \
+lt_cv_sys_global_symbol_to_cdecl \
+lt_cv_sys_global_symbol_to_c_name_address \
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
+SHELL \
+ECHO \
+lt_prog_compiler_no_builtin_flag \
+lt_prog_compiler_wl \
+lt_prog_compiler_pic \
+lt_prog_compiler_static \
+lt_cv_prog_compiler_c_o \
+need_locks \
+DSYMUTIL \
+NMEDIT \
+LIPO \
+OTOOL \
+OTOOL64 \
+shrext_cmds \
+export_dynamic_flag_spec \
+whole_archive_flag_spec \
+compiler_needs_object \
+with_gnu_ld \
+allow_undefined_flag \
+no_undefined_flag \
+hardcode_libdir_flag_spec \
+hardcode_libdir_flag_spec_ld \
+hardcode_libdir_separator \
+fix_srcfile_path \
+exclude_expsyms \
+include_expsyms \
+file_list_spec \
+variables_saved_for_relink \
+libname_spec \
+library_names_spec \
+soname_spec \
+finish_eval \
+old_striplib \
+striplib; do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in reload_cmds \
+old_postinstall_cmds \
+old_postuninstall_cmds \
+old_archive_cmds \
+extract_expsyms_cmds \
+old_archive_from_new_cmds \
+old_archive_from_expsyms_cmds \
+archive_cmds \
+archive_expsym_cmds \
+module_cmds \
+module_expsym_cmds \
+export_symbols_cmds \
+prelink_cmds \
+postinstall_cmds \
+postuninstall_cmds \
+finish_cmds \
+sys_lib_search_path_spec \
+sys_lib_dlsearch_path_spec; do
+    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Fix-up fallback echo if it was mangled by the above quoting rules.
+case \$lt_ECHO in
+*'\\\$0 --fallback-echo"')  lt_ECHO=\`\$ECHO "X\$lt_ECHO" | \$Xsed -e 's/\\\\\\\\\\\\\\\$0 --fallback-echo"\$/\$0 --fallback-echo"/'\`
+  ;;
+esac
+
+ac_aux_dir='$ac_aux_dir'
+xsi_shell='$xsi_shell'
+lt_shell_append='$lt_shell_append'
+
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'
+
+
+
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "dummy-config.h") CONFIG_HEADERS="$CONFIG_HEADERS dummy-config.h" ;;
+    "dsieve-config.h") CONFIG_HEADERS="$CONFIG_HEADERS dsieve-config.h" ;;
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
+    "src/lib-sieve/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/Makefile" ;;
+    "src/lib-sieve/plugins/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/Makefile" ;;
+    "src/lib-sieve/plugins/vacation/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/vacation/Makefile" ;;
+    "src/lib-sieve/plugins/subaddress/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/subaddress/Makefile" ;;
+    "src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile" ;;
+    "src/lib-sieve/plugins/relational/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/relational/Makefile" ;;
+    "src/lib-sieve/plugins/regex/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/regex/Makefile" ;;
+    "src/lib-sieve/plugins/imap4flags/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/imap4flags/Makefile" ;;
+    "src/lib-sieve/plugins/copy/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/copy/Makefile" ;;
+    "src/lib-sieve/plugins/include/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/include/Makefile" ;;
+    "src/lib-sieve/plugins/body/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/body/Makefile" ;;
+    "src/lib-sieve/plugins/variables/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/variables/Makefile" ;;
+    "src/lib-sieve/plugins/enotify/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/enotify/Makefile" ;;
+    "src/lib-sieve/plugins/notify/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/notify/Makefile" ;;
+    "src/lib-sieve/plugins/environment/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/environment/Makefile" ;;
+    "src/lib-sieve/plugins/mailbox/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/mailbox/Makefile" ;;
+    "src/lib-sieve/plugins/date/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve/plugins/date/Makefile" ;;
+    "src/lib-sieve-tool/Makefile") CONFIG_FILES="$CONFIG_FILES src/lib-sieve-tool/Makefile" ;;
+    "src/plugins/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/Makefile" ;;
+    "src/plugins/lda-sieve/Makefile") CONFIG_FILES="$CONFIG_FILES src/plugins/lda-sieve/Makefile" ;;
+    "src/sieve-tools/Makefile") CONFIG_FILES="$CONFIG_FILES src/sieve-tools/Makefile" ;;
+    "src/sieve-tools/debug/Makefile") CONFIG_FILES="$CONFIG_FILES src/sieve-tools/debug/Makefile" ;;
+    "src/testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES src/testsuite/Makefile" ;;
+    "stamp.h") CONFIG_FILES="$CONFIG_FILES stamp.h" ;;
+
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$tmp/config.h" "$ac_file" \
+	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error "could not create -" "$LINENO" 5
+  fi
+# Compute "$ac_file"'s index in $config_headers.
+_am_arg="$ac_file"
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
+$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$_am_arg" : 'X\(//\)[^/]' \| \
+	 X"$_am_arg" : 'X\(//\)$' \| \
+	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$_am_arg" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`/stamp-h$_am_stamp_count
+ ;;
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+    "libtool":C)
+
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008 Free Software Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags=""
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Which release of libtool.m4 was used?
+macro_version=$macro_version
+macro_revision=$macro_revision
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# What type of objects to build.
+pic_mode=$pic_mode
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
+
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
+
+# A sed program that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="\$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP=$lt_GREP
+
+# An ERE matcher.
+EGREP=$lt_EGREP
+
+# A literal string matcher.
+FGREP=$lt_FGREP
+
+# A BSD- or MS-compatible name lister.
+NM=$lt_NM
+
+# Whether we need soft or hard links.
+LN_S=$lt_LN_S
+
+# What is the maximum length of a command?
+max_cmd_len=$max_cmd_len
+
+# Object file suffix (normally "o").
+objext=$ac_objext
+
+# Executable file suffix (normally "").
+exeext=$exeext
+
+# whether the shell understands "unset".
+lt_unset=$lt_unset
+
+# turn spaces into newlines.
+SP2NL=$lt_lt_SP2NL
+
+# turn newlines into spaces.
+NL2SP=$lt_lt_NL2SP
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# An object symbol dumper.
+OBJDUMP=$lt_OBJDUMP
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == "file_magic".
+file_magic_cmd=$lt_file_magic_cmd
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# A symbol stripping program.
+STRIP=$lt_STRIP
+
+# Commands used to install an old-style archive.
+RANLIB=$lt_RANLIB
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# A C compiler.
+LTCC=$lt_CC
+
+# LTCC compiler flags.
+LTCFLAGS=$lt_CFLAGS
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# An echo program that does not interpret backslashes.
+ECHO=$lt_ECHO
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=$MAGIC_CMD
+
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=$lt_DSYMUTIL
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=$lt_NMEDIT
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=$lt_LIPO
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=$lt_OTOOL
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=$lt_OTOOL64
+
+# Old archive suffix (normally "a").
+libext=$libext
+
+# Shared library suffix (normally ".so").
+shrext_cmds=$lt_shrext_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink=$lt_variables_saved_for_relink
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Library versioning type.
+version_type=$version_type
+
+# Shared library runtime path variable.
+runpath_var=$runpath_var
+
+# Shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=$lt_postinstall_cmds
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=$lt_finish_eval
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds
+
+# A language specific compiler.
+CC=$lt_compiler
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds
+module_expsym_cmds=$lt_module_expsym_cmds
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# If ld is used when linking, flag to hardcode \$libdir into a binary
+# during linking.  This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path=$lt_fix_srcfile_path
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $* ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "X${3}" \
+           | $Xsed -e "s%^${1}%%" -e "s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[^=]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "X${1}" | $Xsed -e "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "X${1}" | $Xsed -e 's/\.[^.]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$@"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1+=\$2"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1=\$$1\$2"
+}
+
+_LT_EOF
+    ;;
+  esac
+
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+
+ ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit $?
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
Index: b/sieve/configure.in
===================================================================
--- /dev/null
+++ b/sieve/configure.in
@@ -0,0 +1,128 @@
+AC_INIT([Dovecot Sieve], [0.1.14], [dovecot@dovecot.org], [dovecot-1.2-sieve])
+AC_CONFIG_SRCDIR([src])
+
+# Autoheader is not needed and does more harm than good for this package. However, it is
+# tightly integrated in autoconf/automake and therefore it is difficult not to use it. As
+# a workaround we give autoheader a dummy config header to chew on and we handle the
+# real config header ourselves.
+AC_CONFIG_HEADERS([dummy-config.h dsieve-config.h])
+
+AC_DEFINE_UNQUOTED(SIEVE_NAME, "$PACKAGE_NAME",
+	[Define to the full name of this Sieve implementation.])
+AC_DEFINE_UNQUOTED(SIEVE_VERSION, "$PACKAGE_VERSION",
+	[Define to the version of this Sieve implementation.])
+
+AM_INIT_AUTOMAKE([no-define foreign])
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[AC_HELP_STRING([--with-dovecot=DIR], [Dovecot base directory [../dovecot]])],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+old=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $old
+AC_SUBST(dovecotdir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  echo "WARNING: Cannot build Sieve commandline tools without the compiled"
+  echo "         Dovecot sources. Compiling against headers will only build"
+  echo "         the Sieve plugin."
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+# Extensions under development
+#
+
+AC_ARG_WITH(unfinished-features,
+[AC_HELP_STRING([--with-unfinished-features],
+	[Build unfinished new features/extensions [default=no]])],
+        if test x$withval = xno || test x$withval = xauto; then
+                want_unfinished_features=$withval
+        else
+                want_unfinished_features=yes
+        fi,
+        want_unfinished_features=no)
+AM_CONDITIONAL(BUILD_UNFINISHED, test "$want_unfinished_features" = "yes")
+
+if test "$want_unfinished_features" = "yes"; then
+	AC_DEFINE(HAVE_SIEVE_UNFINISHED,,
+		[Define to build Sieve unfinished features/extensions.])
+fi
+
+#
+#
+
+AC_ARG_ENABLE(valgrind,
+[AC_HELP_STRING([--enable-valgrind], [Enable Valgrind memory leak checks in testsuite [default=no]])],
+    if test x$enableval = xno || test x$enableval = xauto; then
+        want_valgrind=$enableval
+    else
+        want_valgrind=yes
+    fi,
+    want_valgrind=no)
+AM_CONDITIONAL(TESTSUITE_VALGRIND, test "$want_valgrind" = "yes")
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/lib-sieve/Makefile
+src/lib-sieve/plugins/Makefile
+src/lib-sieve/plugins/vacation/Makefile
+src/lib-sieve/plugins/subaddress/Makefile
+src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile
+src/lib-sieve/plugins/relational/Makefile
+src/lib-sieve/plugins/regex/Makefile
+src/lib-sieve/plugins/imap4flags/Makefile
+src/lib-sieve/plugins/copy/Makefile
+src/lib-sieve/plugins/include/Makefile
+src/lib-sieve/plugins/body/Makefile
+src/lib-sieve/plugins/variables/Makefile
+src/lib-sieve/plugins/enotify/Makefile
+src/lib-sieve/plugins/notify/Makefile
+src/lib-sieve/plugins/environment/Makefile
+src/lib-sieve/plugins/mailbox/Makefile
+src/lib-sieve/plugins/date/Makefile
+src/lib-sieve-tool/Makefile
+src/plugins/Makefile
+src/plugins/lda-sieve/Makefile
+src/sieve-tools/Makefile
+src/sieve-tools/debug/Makefile
+src/testsuite/Makefile
+stamp.h])
+
+AC_OUTPUT
Index: b/sieve/depcomp
===================================================================
--- /dev/null
+++ b/sieve/depcomp
@@ -0,0 +1,589 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2007-03-29.01
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007 Free Software
+# Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by `PROGRAMS ARGS'.
+  object      Object file output by `PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputing dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "depcomp $scriptversion"
+    exit $?
+    ;;
+esac
+
+if test -z "$depmode" || test -z "$source" || test -z "$object"; then
+  echo "depcomp: Variables source, object and depmode must be set" 1>&2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo "$object" |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f "$tmpdepfile"
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test "$depmode" = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test "$depmode" = dashXmstdout; then
+   # This is just like dashmstdout with a different argument.
+   dashmflag=-xM
+   depmode=dashmstdout
+fi
+
+case "$depmode" in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+## Unfortunately, FreeBSD c89 acceptance of flags depends upon
+## the command line argument order; so add the flags where they
+## appear in depend2.am.  Note that the slowdown incurred here
+## affects only configure: in makefiles, %FASTDEP% shortcuts this.
+  for arg
+  do
+    case $arg in
+    -c) set fnord "$@" -MT "$object" -MD -MP -MF "$tmpdepfile" "$arg" ;;
+    *)  set fnord "$@" "$arg" ;;
+    esac
+    shift # fnord
+    shift # $arg
+  done
+  "$@"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  mv "$tmpdepfile" "$depfile"
+  ;;
+
+gcc)
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z "$gccflag"; then
+    gccflag=-MD,
+  fi
+  "$@" -Wp,"$gccflag$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+## The second -e expression handles DOS-style file names with drive letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
+## This next piece of magic avoids the `deleted header file' problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+  tr ' ' '
+' < "$tmpdepfile" |
+## Some versions of gcc put a space before the `:'.  On the theory
+## that the space means something, we add a space to the output as
+## well.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test "$libtool" = yes; then
+    "$@" "-Wp,-MDupdate,$tmpdepfile"
+  else
+    "$@" -MDupdate "$tmpdepfile"
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+
+  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
+    echo "$object : \\" > "$depfile"
+
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like `#:fec' to the end of the
+    # dependency line.
+    tr ' ' '
+' < "$tmpdepfile" \
+    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
+    tr '
+' ' ' >> $depfile
+    echo >> $depfile
+
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' '
+' < "$tmpdepfile" \
+   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+   >> $depfile
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$base.u
+    tmpdepfile3=$dir.libs/$base.u
+    "$@" -Wc,-M
+  else
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$dir$base.u
+    tmpdepfile3=$dir$base.u
+    "$@" -M
+  fi
+  stat=$?
+
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    # Each line is of the form `foo.o: dependent.h'.
+    # Do two passes, one to just change these to
+    # `$object: dependent.h' and one to simply `dependent.h:'.
+    sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+    # That's a tab and a space in the [].
+    sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+icc)
+  # Intel's C compiler understands `-MD -MF file'.  However on
+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
+  # ICC 7.0 will fill foo.d with something like
+  #    foo.o: sub/foo.c
+  #    foo.o: sub/foo.h
+  # which is wrong.  We want:
+  #    sub/foo.o: sub/foo.c
+  #    sub/foo.o: sub/foo.h
+  #    sub/foo.c:
+  #    sub/foo.h:
+  # ICC 7.1 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using \ :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
+    sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp2)
+  # The "hp" stanza above does not work with aCC (C++) and HP's ia64
+  # compilers, which have integrated preprocessors.  The correct option
+  # to use with these is +Maked; it writes dependencies to a file named
+  # 'foo.d', which lands next to the object file, wherever that
+  # happens to be.
+  # Much of this is similar to the tru64 case; see comments there.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir.libs/$base.d
+    "$@" -Wc,+Maked
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    "$@" +Maked
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+     rm -f "$tmpdepfile1" "$tmpdepfile2"
+     exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    sed -e "s,^.*\.[a-z]*:,$object:," "$tmpdepfile" > "$depfile"
+    # Add `dependent.h:' lines.
+    sed -ne '2,${; s/^ *//; s/ \\*$//; s/$/:/; p;}' "$tmpdepfile" >> "$depfile"
+  else
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile" "$tmpdepfile2"
+  ;;
+
+tru64)
+   # The Tru64 compiler uses -MD to generate dependencies as a side
+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+   # dependencies in `foo.d' instead, so we check for that too.
+   # Subdirectories are respected.
+   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+   test "x$dir" = "x$object" && dir=
+   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+
+   if test "$libtool" = yes; then
+      # With Tru64 cc, shared objects can also be used to make a
+      # static library.  This mechanism is used in libtool 1.4 series to
+      # handle both shared and static libraries in a single compilation.
+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
+      #
+      # With libtool 1.5 this exception was removed, and libtool now
+      # generates 2 separate objects for the 2 libraries.  These two
+      # compilations output dependencies in $dir.libs/$base.o.d and
+      # in $dir$base.o.d.  We have to check for both files, because
+      # one of the two compilations can be disabled.  We should prefer
+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+      # automatically cleaned when .libs/ is deleted, while ignoring
+      # the former would cause a distcleancheck panic.
+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
+      tmpdepfile2=$dir$base.o.d          # libtool 1.5
+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
+      "$@" -Wc,-MD
+   else
+      tmpdepfile1=$dir$base.o.d
+      tmpdepfile2=$dir$base.d
+      tmpdepfile3=$dir$base.d
+      tmpdepfile4=$dir$base.d
+      "$@" -MD
+   fi
+
+   stat=$?
+   if test $stat -eq 0; then :
+   else
+      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+      exit $stat
+   fi
+
+   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+   do
+     test -f "$tmpdepfile" && break
+   done
+   if test -f "$tmpdepfile"; then
+      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+      # That's a tab and a space in the [].
+      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+   else
+      echo "#dummy" > "$depfile"
+   fi
+   rm -f "$tmpdepfile"
+   ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z "$dashmflag" && dashmflag=-M
+  # Require at least two characters before searching for `:'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  "$@" $dashmflag |
+    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  tr ' ' '
+' < "$tmpdepfile" | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  "$@" || exit $?
+  # Remove any Libtool call
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no
+  for arg in "$@"; do
+    case $cleared in
+    no)
+      set ""; shift
+      cleared=yes ;;
+    esac
+    case "$arg" in
+    -D*|-I*)
+      set fnord "$@" "$arg"; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -*|$object)
+      ;;
+    *)
+      set fnord "$@" "$arg"; shift ;;
+    esac
+  done
+  obj_suffix="`echo $object | sed 's/^.*\././'`"
+  touch "$tmpdepfile"
+  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  sed '1,2d' "$tmpdepfile" | tr ' ' '
+' | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile" "$tmpdepfile".bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  "$@" -E |
+    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
+    sed '$ s: \\$::' > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  cat < "$tmpdepfile" >> "$depfile"
+  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o,
+  # because we must use -o when running libtool.
+  "$@" || exit $?
+  IFS=" "
+  for arg
+  do
+    case "$arg" in
+    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
+	set fnord "$@"
+	shift
+	shift
+	;;
+    *)
+	set fnord "$@" "$arg"
+	shift
+	shift
+	;;
+    esac
+  done
+  "$@" -E |
+  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::echo "`cygpath -u \\"\1\\"`":p' | sort | uniq > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
+  echo "	" >> "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+none)
+  exec "$@"
+  ;;
+
+*)
+  echo "Unknown depmode $depmode" 1>&2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
Index: b/sieve/doc/devel/DESIGN
===================================================================
--- /dev/null
+++ b/sieve/doc/devel/DESIGN
@@ -0,0 +1,45 @@
+The compiler consists of the following stages:
+
+PARSER: sieve-parser.c, sieve-lexer.c
+  Parses the scriptfile and produces an abstract syntax tree for it
+  (sieve-ast.c).
+
+VALIDATOR: sieve-validator.c
+  Performs contextual analysis on the ast produced by the parser. This checks
+  for the validity of commands, tests and arguments. Also, the ast is decorated
+  with any context data acquired during the process. This context is used by the
+  last compiler stage.
+
+GENERATOR: sieve-generator.c
+  This last compiler stage uses a visitor pattern to wander through the ast and
+  produces sieve byte code (sieve-binary.c).
+
+The resulting (in-memory) binary can be fed to the interpreter for execution:
+
+INTERPRETER: sieve-interpreter.c
+  The interpreter executes the byte code and produces a sieve_result object.
+  This result is no more than just a collection of actions to be performed.
+  During execution, action commands add actions to the result. Duplates and
+  conflicts between actions are handled in this execution phase.
+
+RESULT: sieve-result.c sieve-actions.c
+  When the result is to be executed, it needs no further checking, as the
+  validity of the result was verified during interpretation already. The
+  result's actions are executed in a transaction-like atomic manner. If one of
+  the actions fails, the whole transaction is rolled back meaning that either
+  everything succeeds or everything fails. This is only possible to some extent:
+  transmitted responses can of course not be rolled back. However, these are
+  executed in the commit phase, meaning that they will only be performed if all
+  other actions were successful.
+
+Debugging:
+
+BINARY-DUMPER: sieve-code-dumper.c sieve-binary-dumper.c
+  A loaded binary can be dumped to a stream in human-readable form using the
+  binary-dumper. The binary-dumper displays information on all the blocks that
+  the binary consists off. Program code blocks are dumped using the code-dumper.
+  It's implementation is similar to the interpreter, with the exception that it
+  performs no actions and just sequentially wanders through the byte code
+  printing instructions along the way. The term human-readable is a bit optimistic
+  though; currently, the presented data looks like an assembly language.
+
Index: b/sieve/doc/man/sieve-filter.1
===================================================================
--- /dev/null
+++ b/sieve/doc/man/sieve-filter.1
@@ -0,0 +1,151 @@
+.TH "SIEVE-FILTER" "1" "5 August 2009"
+.SH NAME
+sieve-filter \- Sieve mailbox filter tool for the Dovecot secure IMAP server
+.PP
+\fBWARNING: \fRThis tool is not finished and should \fB*NOT*\fR be used, unless you feel like testing newly developed
+features! The behavior described in this manual page represents the design and not necessarily what the tool currently implements.
+
+.SH SYNOPSIS
+sieve-filter [\fIoptions\fR] \fIscript-file\fR \fIsource-location\fR \fIsource-mailbox\fR [\fIinbox-namespace\fR [\fInamespace\fR ...]]
+.TP
+\fInamepace\fR = [prefix=]location[;option=value,option=value,...]
+.TP
+[FIXME: what would be the easiest way to specify a filter operation without always needing to
+delve into the complexity of namespaces]
+
+.SH DESCRIPTION
+.PP
+The \fBsieve-filter\fP command is part of the Sieve implementation for the Dovecot secure
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering
+e-mail messages. It can be implemented for any type of mail access protocol, mail
+architecture and operating system. The language cannot execute external programs and in
+its basic form it does not provide the means to cause infinite loops, making it suitable
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+The Sieve language was originally meant for filtering messages upon delivery. However, there are
+occasions when it is desirable to filter messages that are already stored in a mailbox, for
+instance when a bug in a Sieve script caused many messages to be delivered incorrectly.
+Using the sieve-filter tool it is possible to apply a Sieve script on all messages in a particular
+mailbox, making it possible to delete messages, to store them in a different folder and to change
+the assigned IMAP flags and keywords. Attempts to send messages to the outside world are ignored by default
+for obvious reasons, but, using the proper command line options, it is possible to capture outgoing
+mail as well.
+.PP
+The command has three mandatory arguments: the \fIscript-file\fP argument, which specifies the path of the
+Sieve script, the \fIsource-location\fP argument, which specifies the mail storage of the source mailbox
+(e.g. `maildir:~/Maildir'), and the \fIsource-mailbox\fP argument, which specifies the name of the source
+mailbox within the specified mail storage (e.g. `INBOX.Spam').
+.PP
+This tool does not (yet) use Dovecot's configuration file to obtain information on namespaces and the
+location of mailboxes. Therefore, any used namespaces need to be specified on the command line. These
+specifications directly follow the \fIsource-mailbox\fP parameter. The first specified namespace will
+be the INBOX namespace.
+.PP
+If no namespaces are defined on the commandline, the source-location is used as the default mail store
+where the INBOX is located. This means that the keep action could operate on the folder the message
+originates from. In this case the message remains untouched and it is not duplicated, but IMAP flags and
+keywords can be evaluated and changed with the imap4flags extension . If namespaces are defined explicitly,
+the source location is available as a namespace with prefix `#src/'.
+.PP
+If no options are specified, the sieve-filter command runs in a simulation mode in which it only
+prints what would be performed, without actually doing anything. Use the \fB-e\fP option to activate
+true script execution. Also, the source mailbox is opened read-only by default, so that the source mailbox
+remains unchanged. Use the \fB-W\fP to allow changes in the source mailbox.
+
+.SH CAUTION
+Although this is a very useful tool, it can also be very destructive when used improperly. A small
+bug in your Sieve script in combination with the wrong command line options could cause it to
+discard (many) more e-mails than it was supposed to. Therefore, users are advised to read this manual
+carefully and to use the simulation mode first to check what the script will do.
+.PP
+\fBMAKING A BACKUP IS IMPERATIVE FOR ANY IMPORTANT MAIL!\fP
+.PP
+By default, it will open the source mailbox in a read-only mode, such that it will not delete any of your
+e-mails. However, it can still litter other mailboxes with spurious copies of your e-mails if your
+Sieve script decides to do so.
+
+.SH OPTIONS
+.TP
+\fB-D\fP \fIsource-action\fP
+By default, the sieve-filter command does not delete the messages from the source mailbox. This means that
+a copy operation is executed by default and the source mailbox is not altered. The \fIsource-action\fP
+parameter of the \fB-D\fP option can take four different values:
+.RS 7
+.TP
+\fBkeep\fP (default)
+Keep messages in source folder. If \fB-W\fR is specified and the source mailbox is the destination of
+a keep or fileinto action, flags can be changed by the Sieve script. Messages are never duplicated in the
+source mailbox.
+.TP
+\fBflag\fP
+Flag messages as \\DELETED.
+.TP
+\fBmove\fP [\fIfolder\fP]
+Move messages to the indicated \fIfolder\fP.
+.TP
+\fBexpunge\fP
+Expunge messages, meaning that these are removed irreversibly when the tool finishes filtering.
+.PP
+Note that values other than `keep' have no effect, unless the \fB-W\fP option is specified as well.
+.RE
+.TP
+\fB-e\fP
+Turns on execution mode. By default, the sieve-filter command runs in simulation mode in which it
+changes nothing, meaning that no mailbox is altered in any way and no actions are performed. It only
+prints what would be done. Using this option the sieve-filter command becomes active and performs the
+requested actions.
+.TP
+\fB-f\fP \fIenvelope-sender\fP
+The envelope sender or return path. This is what Sieve's envelope test will compare to when the
+"from" envelope part is requested. Also, this is where response messages are sent to.
+.TP
+\fB-m\fP \fIdefault-mailbox\fP
+The mailbox within the default namespace where the keep action stores the message. This is "INBOX"
+by default.
+.TP
+\fB-Q\fP \fImail-command\fP
+Send outgoing e-mail through the specified program. By default, the sieve-filter command ignores
+Sieve actions such as redirect, reject, vacation and notify, but using this option outgoing messages
+can be fed to the \fBstdin\fP of an external shell command. This option has no effect in simulation
+mode, Unless you really know what you are doing, \fBDO NOT USE THIS TO FEED MAIL TO SENDMAIL!\f.
+.TP
+\fB-r\fP \fIrecipient-address\fP
+The envelope recipient address. This is what Sieve's envelope test will compare to when the "to"
+envelope part is requested. Some tests and actions will also use this as the owner's e-mail address.
+.TP
+\fB-S\fP \fIscript-file\fP
+Specify additional scripts to be executed before the main script. Multiple \fB-s\fP arguments are
+allowed and the specified scripts are executed sequentially in the order specified at the command
+line.
+.TP
+\fB-W\fP
+Enables write access to the source mailbox. This allows deleting the messages from the source mailbox
+and changing the assigned IMAP flags and keywords.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored and a
+warning is produced. By default, all supported extensions are available, except for deprecated extensions
+or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+
+.SH EXAMPLES
+
+.TP
+[...]
+
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieved (1),
+.BR sieve-test (1)
+
Index: b/sieve/doc/man/sieve-test.1
===================================================================
--- /dev/null
+++ b/sieve/doc/man/sieve-test.1
@@ -0,0 +1,130 @@
+.TH "SIEVE-TEST" "1" "4 July 2009"
+.SH NAME
+sieve-test \- Sieve script tester for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sieve-test
+[\fB-c\fR]
+[\fB-d\fR \fIdump-file\fR]
+[\fB-e\fR]
+[\fB-f\fR \fIenvelope-sender\fR]
+[\fB-l\fR \fImail-location\fR]
+[\fB-m\fR \fIdefault-mailbox\fR]
+[\fB-r\fR \fIrecipient-address\fR]
+[\fB-s\fR \fIscript-file\fR]
+[\fB-t\fR]
+[\fB-x\fR "\fIextension extension ...\fR"]
+\fIscript-file\fR \fImail-file\fR
+.SH DESCRIPTION
+.PP
+The \fBsieve-test\fP command is part of the Sieve implementation for the Dovecot secure
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering
+e-mail messages. It can be implemented for any type of mail access protocol, mail
+architecture and operating system. The language cannot execute external programs and in
+its basic form it does not provide the means to cause infinite loops, making it suitable
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsieve-test\fP command, the execution of Sieve scripts can be tested. This evaluates
+the script for the provided message, yielding a set of Sieve actions. Unless the \fB-e\fP option is
+specified, it does not actually execute these actions, meaning that it does not store or forward the
+message anywere. In stead, it prints a detailed list of what actions would normally take place.
+Note that, even when \fB-e\fP is specified, no messages are ever transmitted to remote SMTP
+recipients. The outgoing messages are printed to \fBstdout\fP in stead.
+.PP
+This is a very useful tool to debug the execution of Sieve scripts. It can be used to verify
+newly installed scripts for the intended behaviour and it can provide more detailed information
+about script execution problems that are reported by the Sieve plugin.
+.PP
+The command has two mandatory arguments: the \fIscript-file\fP argument, which specifies the
+script to (compile and) execute, and the \fImail-file\fP argument, which specifies the file
+containing the e-mail message to filter.
+
+Note that this tool looks for a pre-compiled binary file with a \fI.svbin\fP extension and
+with basename and path identical to the specified script. Use the \fB-c\fP option to disable this
+behavior by forcing the script to be compiled into a new binary.
+.SH OPTIONS
+.TP
+\fB-c\fP
+Force compilation. By default, the compiled binary is stored on disk. When this binary is found
+during the next execution of \fBsieve-test\fP and its modification time is more recent than the
+script file, it is used and the script is not compiled again. This option forces the script to be
+compiled, thus ignoring any present binary. Refer to \fBsievec\fP(1) for more information about
+Sieve compilation.
+.TP
+\fB-d\fP \fIdump-file\fP
+Causes a dump of the generated code to be written to the specified file. This is identical to the
+dump produced by \fBsieved\fR(1). Using '-' as filename causes the dump to be written to \fBstdout\fP.
+.TP
+\fB-e\fP
+Turns on true execution of the set of actions that results from running the script. In combination
+with the \fB-l\fP parameter, the actual delivery of messages can be tested. Note that this will
+not transmit any messages to remote SMTP recipients. Such actions only print the outgoing message
+to \fBstdout\fP.
+.TP
+\fB-f\fP \fIenvelope-sender\fP
+The envelope sender or return path. This is what Sieve's envelope test will compare to when the
+"from" envelope part is requested. Also, this is where response messages are sent to.
+.TP
+\fB-l\fP \fImail-location\fP
+The location of the user's mail store. The syntax of this option's \fImail-location\fP parameter
+is identical to what is used for the mail_location setting in the Dovecot config file. This
+parameter is typically used in combination with \fB-e\fP to test the actual delivery of messages.
+If \fB-l\fP is omitted when \fB-e\fP is specified, mail store actions like fileinto and keep are
+skipped.
+.TP
+\fB-m\fP \fIdefault-mailbox\fP
+The mailbox where the keep action stores the message. This is "INBOX" by default.
+.TP
+\fB-r\fP \fIrecipient-address\fP
+The envelope recipient address. This is what Sieve's envelope test will compare to when the "to"
+envelope part is requested. Some tests and actions will also use this as the owner's e-mail address.
+.TP
+\fB-s\fP \fIscript-file\fP
+Specify additional scripts to be executed before the main script. Multiple \fB-s\fP arguments are
+allowed and the specified scripts are executed sequentially in the order specified at the command
+line.
+.TP
+\fB-t\fP
+Enable simple trace debugging; prints all encountered byte code instructions to \fBstdout\fP. This is
+currently only intelligible for developers.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored and a
+warning is produced. By default, all supported extensions are available, except for deprecated extensions
+or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+.SH DEBUG SUPPORT
+.PP
+To improve script debugging, the Sieve command line tools such as \fBsieve-test\fP support a custom
+Sieve language extension called 'vnd.dovecot.debug'. It adds the \fBdebug_print\fP command that allows
+printing debug messages to \fBstdout\fP.
+.PP
+Example:
+.PP
+require "vnd.dovecot.debug";
+.PP
+if header :contains "subject" "hello" {
+.PP
+  debug_print "Subject header contains hello!";
+.PP
+}
+.PP
+Other tools like \fBsievec\fP and \fBsieved\fP also recognize the vnd.dovecot.debug extension. In contrast,
+the actual Sieve plugin for the Dovecot LDA does not allow the use of the debug extension. So, keep in mind that
+scripts and compiled binaries that refer to de debug extension will fail to be run by the Sieve plugin itself.
+.PP
+Note that it is not necessary to enable nor possible to disable the availability of the debug extension with
+the \fB-x\fP option.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieved (1)
+
Index: b/sieve/doc/man/sievec.1
===================================================================
--- /dev/null
+++ b/sieve/doc/man/sievec.1
@@ -0,0 +1,72 @@
+.TH "SIEVEC" "1" "4 July 2009"
+.SH NAME
+sievec \- Sieve script compiler for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sievec [\fB-d\fR] [\fB-x\fR "\fIextension extension ...\fR"] \fIscript-file\fR [\fIout-file\fR]
+.SH DESCRIPTION
+.PP
+The \fBsievec\fP command is part of the Sieve implementation for the Dovecot secure
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering
+e-mail messages. It can be implemented for any type of mail access protocol, mail
+architecture and operating system. The language cannot execute external programs and in
+its basic form it does not provide the means to cause infinite loops, making it suitable
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsievec\fP command, Sieve scripts can be compiled into a binary representation.
+The resulting binary can be used directly to process e-mail messages during the delivery process.
+The delivery of mail messages and therefore also the execution of Sieve scripts is
+performed by Dovecot's local delivery agent (LDA) called \fBdeliver\fP. Usually, it is not
+necessary to compile the Sieve script manually using \fBsievec\fP, because \fBdeliver\fP will do
+this automatically if the binary is missing. However, in some cases \fBdeliver\fP does not have
+permission to write the compiled binary to disk, forcing it to recompile the script every time it
+is executed. Using the \fBsievec\fP tool, this can be performed manually by an authorized user to
+increase performance.
+.PP
+The \fBsievec\fP command accepts two arguments: the \fIscript-file\fP argument specifies the
+script to be compiled and the \fIout-file\fR argument specifies where the (binary) output is to
+be written. This Sieve implementation reconizes files with a \fB.sieve\fP extension as Sieve
+scripts and corresponding files with a \fB.svbin\fP extension as the associated compiled binary.
+This means for example that Dovecot's deliver process will look for a binary file 'dovecot.svbin'
+when it needs to execute 'dovecot.sieve'. Such filename is chosen automatically for the binary output
+when the out-file argument is missing.
+.PP
+If the \fIscript-file\fP  argument is a directory, all files in that directory with a \fI.sieve\fP
+extension are compiled into a corresponding \fI.svbin\fP binary file. The compilation is not halted
+upon errors; it attempts to compile as many scripts in the directory as possible. Note that the
+\fB-d\fP option and the \fIout-file\fP argument are not allowed when the \fIscript-file\fP argument
+is a directory.
+.PP
+The \fBsievec\fP command is also useful to verify Sieve scripts before using. Additionally, with
+the \fB-d\fP option it can output a textual (and thus human-readable) dump of the generated Sieve
+code to the specified file. The output is then identical to what the \fBsieved\fP(1) command produces
+for a stored binary file. This output is mainly useful to find bugs in the compiler that yield corrupt
+binaries.
+.SH OPTIONS
+.TP
+\fB-d\fP
+Don't write the binary to \fIout-file\fP, but write a textual dump of the binary in
+stead. In this context, the \fIout-file\fP value '-' has special meaning: it causes the the textual
+dump to be written to \fBstdout\fP. The \fIout-file\fP argument may also be omitted, which has
+the same effect as '-'. The output is identical to what the \fBsieved\fP(1) command produces for
+a compiled Sieve binary file. Note that this option is not allowed when the \fIout-file\fP argument
+is a directory.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored
+and a warning is produced. By default, all supported extensions are available, except for deprecated
+extensions or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sieved (1),
+.BR sieve-test (1)
+
Index: b/sieve/doc/man/sieved.1
===================================================================
--- /dev/null
+++ b/sieve/doc/man/sieved.1
@@ -0,0 +1,55 @@
+.TH "SIEVED" "1" "4 July 2009"
+.SH NAME
+sieved \- Sieve script binary dump tool for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sieved [\fB-x\fR "\fIextension extension ...\fR"] \fIsieve-binary\fR [\fIout-file\fR]
+.br
+.SH DESCRIPTION
+.PP
+The \fBsieved\fP command is part of the Sieve implementation for the Dovecot secure
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering
+e-mail messages. It can be implemented for any type of mail access protocol, mail
+architecture and operating system. The language cannot execute external programs and in
+its basic form it does not provide the means to cause infinite loops, making it suitable
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsieved\fP command, Sieve binaries, which are produced for instance by
+\fBsievec\fP(1), can be transformed into a human-readable textual representation. This can
+provide valuable insight in how the Sieve script is executed. This is also particularly useful
+to view corrupt binaries that can result from bugs in the Sieve implementation. This tool is
+intended mainly for development purposes, so normally system administrators and users will not
+need to use this tool.
+.PP
+The \fIsieve-binary\fR argument specifies the Sieve binary file that needs to be dumped. The
+optional \fIout-file\fR argument specifies where the output must be written. If omitted, the
+output is written to \fBstdout\fR.
+.PP
+The format of the output is not explained here in detail, but it should be relatively easy
+to understand. The Sieve binaries comprise a set of data blocks, each of which can contain
+arbitrary data. For the base language implementation two blocks are used: the first containing
+a specification of all required language extensions and the second containing the main Sieve
+program. Compiled Sieve programs are represented as flat byte code and therefore the dump of
+the main program is a disassembly listing of the interpreter operations. Extensions can define
+new operations and use additional blocks. Therefore, the output of \fBsieved\fP depends greatly
+on the language extensions used when compiling the binary.
+.SH OPTIONS
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The parameter is a space-separated list of the active extensions. By
+prepending the extension identifiers with \fB+\fP or \fB-\fP, extensions can be included or excluded
+relative to the default set of extensions. If no extensions have a \fB+\fP or \fB-\fP prefix, only
+those extensions that are explicitly listed will be enabled. Unknown extensions are ignored and a
+warning is produced. By default, all supported extensions are available, except for deprecated
+extensions or those that are still under development.
+
+For example \fB-x\fP "+imapflags -enotify" will enable the deprecated imapflags extension along with all
+extensions that are available by default, except for the enotify extension.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieve-test (1)
+
Index: b/sieve/dsieve-config.h.in
===================================================================
--- /dev/null
+++ b/sieve/dsieve-config.h.in
@@ -0,0 +1,9 @@
+
+/* Define to the full name of this Sieve implementation. */
+#undef SIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef SIEVE_VERSION
+
+/* Define to build Sieve unfinished features/extensions. */
+#undef HAVE_SIEVE_UNFINISHED
Index: b/sieve/dummy-config.h.in
===================================================================
--- /dev/null
+++ b/sieve/dummy-config.h.in
@@ -0,0 +1,65 @@
+/* dummy-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to build Sieve unfinished features/extensions. */
+#undef HAVE_SIEVE_UNFINISHED
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to the full name of this Sieve implementation. */
+#undef SIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef SIEVE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
Index: b/sieve/examples/elvey.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/elvey.sieve
@@ -0,0 +1,153 @@
+# Example Sieve Script
+#   Author: Matthew Elvey (Slightly modified to remove syntax and context errors)
+#   URL: http://www.elvey.com/it/sieve/SieveScript.txt
+
+# Initial version completed and put in place 4/1/02 by Matthew Elvey  (firstname@lastname.com ; I've checked and it's not a valid address.); Copyright (C).and.current as of 5/19/2002
+#Change log:
+#+ spam[:high]; major reordering; +DFC,BugTraq, PB up +Economist, FolderPath corrections
+#+ redid .0 matches. +Korean + whitelist +@f(useful once I start bouncing mail!)
+#+open mag, simplifications, to fm=spamNOTwhite, Bulk changes, IETF rules, +lst
+#Reword spam bounce.+scalable@ re-correction+++Work+activate Spam Optimization, etc...
+#oops high = 2x threshold, so 2x1 is 2!  Too low. To @fm:bounce.  Added tons of comments.
+require ["fileinto", "reject", "vacation", "envelope", "regex"];
+
+if header :contains "subject" ["un eject", "lastname.com/spamoff.htm agreed to"] {  #I give out "uneject" to people to let them bypass the spam or size filters.
+  keep;
+} elsif header :contains "subject" ["ADV:", "bounceme", "2002 Gov Grants",   #bounceme is useful for testing.
+             "ADV:ADLT", "ADV-ADULT", "ADULT ADVERTISEMENT"] {  #Subject text required by various US State laws
+  reject text:
+  Hello.  The server content filter/spam detector I use has bounced your message. It appears to be spam.
+
+  I do not accept spam/UCE (Unsolicited Commercial Email).
+
+Please ask me how to bypass this filter if your email is not UCE.  In that case, I am sorry about this
+highly unusual error.  The filter is >99% accurate.
+
+  (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+  -Firstname
+
+  (P.S. You may also override the filter if you accept the terms at http://www.lastname.com/spamoff.htm,
+         by including "lastname.com/spamoff.htm agreed to." in the subject.)
+.
+   ;
+}
+# LINE 30.
+  elsif size :over 10M {    # (note that the four leading dots get "stuffed" to three)
+
+  reject text:
+   Message NOT delivered!
+   This system normally accepts email that is less than 10MB in size, because that is how I configured it.
+   You may want to put your file on a server and send me the URL.
+   Or, you may request override permission and/or unreject instructions via another (smaller) email.
+   Sorry for the inconvenience.
+
+   Thanks,
+
+.... Firstname
+   (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+   Unsolicited advertising sent to this E-Mail address is expressly prohibited
+   under USC Title 47, Section 227.  Violators are subject to charge of up to
+   $1,500 per incident or treble actual costs, whichever is greater.
+.
+  ;
+#LINE 47.
+} elsif header :contains "From" "Firstname@lastname.com" {	#if I send myself email, leave it in the Inbox.
+  keep;			#next, is the processing for the various mailing lists I'm on.
+} elsif header :contains ["Sender", "X-Sender", "Mailing-List", "Delivered-To", "List-Post", "Subject", "To", "Cc", "From", "Reply-to", "Received"] "burningman" {
+  fileinto "INBOX.DaBurn";
+} elsif header :contains ["Subject", "From", "Received"] ["E*TRADE", "Datek", "TD Waterhouse", "NetBank"] {
+  fileinto "INBOX.finances.status";
+} elsif header :contains "subject" "\[pacbell" {
+  fileinto "INBOX.pacbell.dslreports";
+} elsif header :contains "From" ["owner-te-wg ", "te-wg ", "iana.org"] {
+  fileinto "INBOX.lst.IETF";
+} elsif header :contains ["Mailing-List", "Subject", "From", "Received"] ["Red Hat", "Double Funk Crunch", "@economist.com", "Open Magazine", "@nytimes.com", "mottimorell", "Harrow Technology Report"] {
+  fileinto "INBOX.lst.interesting";
+} elsif header :contains ["Mailing-List", "Subject", "From", "Received", "X-LinkName"] ["DJDragonfly", "Ebates", "Webmonkey", "DHJ8091@aol.com", "Expedia Fare Tracker", "SoulShine", "Martel and Nabiel", "\[ecc\]"] {
+  fileinto "INBOX.lst.lame";
+} elsif header :contains ["Subject", "From", "To"] ["guru.com", "monster.com", "hotjobs", "dice.com", "linkify.com"] {  #job boards and current clients.
+  fileinto "INBOX.lst.jobs";
+} elsif header :contains "subject" "\[yaba" {
+  fileinto "INBOX.rec.yaba";
+} elsif header :contains ["to", "cc"] "scalable@" {
+  fileinto "INBOX.lst.scalable";
+} elsif header :contains ["Sender", "To", "Return-Path", "Received"] "NTBUGTRAQ@listserv.ntbugtraq.com" {
+  fileinto "INBOX.lst.bugtraq";
+} elsif header :contains "subject" "Wired" {
+  fileinto "INBOX.lst.wired";
+#LINE 72.
+} elsif anyof (header :contains "From" ["postmaster", "daemon", "abuse"], header :contains "Subject" ["warning:", "returned mail", "failure notice", "undelivered mail"] ) {
+keep;		#this one is important - don't want to miss any bounce messages!
+#LINE 77.
+} elsif anyof (header :contains "From" ["and here I put a whitelist of pretty much all the email addresses in my address book - it's several pages..."]) {
+  fileinto "INBOX.white";
+# better than keep;
+# LINE 106.
+
+
+} elsif anyof (address :all :is ["To", "CC", "BCC"] "Firstname.lastname@fastmail.fm",    #a couple people send to this, but I have have all their addrs in whitelist so OK.
+           header :matches "X-Spam-score"  ["9.?" , "10.?", "9", "10", "11.?", "12.?" ,"13.?", "14.?", "11", "12","13", "14", "15.?", "16.?", "17.?" ,"18.?", "19.?", "15", "16", "17" ,"18", "19", "2?.?", "2?", "3?.?" , "3?", "40"]) { 		 #"5.?", "6.?", "5", "6" "7.?" , "8.?" , "7", "8"
+  reject text:
+  Hello.  The server content filter/spam detector I use has bounced your message. It appears to be spam.
+
+  I do not accept spam/UCE (Unsolicited Commercial Email).
+
+Please ask me how to bypass this filter if your email is not UCE.  In that case, I am sorry about this
+highly unusual error.  The filter is >99% accurate.
+
+  (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+  -Firstname
+
+  (P.S. You may also override the filter if you accept the terms at http://www.lastname.com/spamoff.htm,
+         by including "lastname.com/spamoff.htm agreed to." in the subject.)
+.
+   ;
+#LINE 127.
+
+} elsif
+header :matches "X-Spam" ["spam", "high"] { if					#optimization idea line 1/2
+           header :matches "X-Spam-score" ["5.?", "6.?", "5", "6"] {
+  fileinto "INBOX.Spam.5-7";
+} elsif header :matches "X-Spam-score" ["7.?" , "8.?" , "7", "8"] {
+  fileinto "INBOX.Spam.7-9";
+#} elsif header :matches "X-Spam-score" ["9.?" , "10.?" , "9", "10"] { 	#These lines obsoleted by reject text rule above, but others will find 'em useful!
+#  fileinto "INBOX.Spam.9-11";
+#} elsif header :matches "X-Spam-score" ["11.?" , "12.?" ,"13.?" , "14.?", "11" , "12" ,"13" , "14"] {
+#  fileinto "INBOX.Spam.11-15";
+#} elsif header :matches "X-Spam-score" ["15.?" , "16.?" ,"17.?" ,"18.?" , "19.?", "15" , "16" ,"17" ,"18" , "19"] {
+#  fileinto "INBOX.Spam.15-20";
+#} elsif header :matches "X-Spam-score" ["2?.?", "2?" ] {
+#  fileinto "Inbox.Spam.20-30";
+#} elsif header :matches "X-Spam-score" ["3?.?" , "3?", "40"] {
+#fileinto "Inbox.Spam.30-40";
+ }											#optimization idea  line 2/2
+
+#LINE 149.
+
+} elsif header:contains ["Content-Type","Subject"] ["ks_c_5601-1987","euc_kr","euc-kr"]{
+  fileinto "Inbox.Spam.kr";								#block Korean; it's prolly spam and I certainly can't read it.
+} elsif header :contains "Received" "yale.edu" {
+  fileinto "INBOX.Yale";								#if it made it past all the filters above, it's probably of interest.
+      } elsif anyof (header :contains "Subject" ["HR 1910", "viagra", "MLM", "               ","	" ], # common in spam.  (prolly redundant to SpamAssassin.)
+      not exists ["From", "Date"], 						#RFC822 violations common in spam.
+      header :contains ["Sender", "X-Sender", "Mailing-List", "X-Apparently-From", "X-Version", "X-Sender-IP", "Received", "Return-Path", "Delivered-To", "List-Post", "Date", "Subject", "To", "Cc", "From", "Reply-to", "X-AntiAbuse", "Content-Type", "Received", "X-LinkName"] ["btamail.net.cn", "@arabia.com" ] ) {               #spam havens.
+  fileinto "INBOX.GreyMail";
+} elsif header :contains ["Precedence", "Priority", "X-Priority", "Mailing-List", "Subject", "From", "Received", "X-LinkName"] ["Bulk", "Newsletter"] {
+  fileinto "INBOX.Bulk Precedence";
+} elsif header :contains ["to", "cc", "Received"] ["IT@lastname.com", "mail.freeservers.com"] {
+  fileinto "INBOX.lastname.IT";
+} elsif header :contains ["To", "CC"] "Firstname@lastname.com" {
+  fileinto "INBOX.lastname.non-BCC";
+}
+#LINE 167.
+#END OF SCRIPT.  Implied 'keep' is part of the Sieve spec.
+
+
+
+
+
+
+
Index: b/sieve/examples/jerry.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/jerry.sieve
@@ -0,0 +1,224 @@
+# Example Sieve Script
+#   Author: Jerry
+#   URL: http://www.emaildiscussions.com/showthread.php?postid=145322#post145322
+
+require ["fileinto", "reject", "vacation", "regex", "relational",
+"comparator-i;ascii-numeric"];
+
+
+#### BLACKLIST - BOUNCE ANYTHING THAT MATCHES
+#    From individual addresses
+         if header :contains "from"
+         [
+           "username@example.com",
+           "username@example.net"
+         ]
+         { reject "Message bounced by server content filter"; stop; }
+
+#    From domains
+         elsif header :contains "from"
+         [
+           "example.com",
+           "example.net"
+         ]
+         { reject "Message bounced by server content filter"; stop; }
+
+
+
+#### BLACKLIST - DELETE ANYTHING THAT MATCHES
+#    From individual addresses
+         elsif header :contains "from"
+         [
+           "username@example.com",
+           "username@example.net"
+         ]
+         { discard; stop; }
+
+#    From domains
+         elsif header :contains "from"
+         [
+           "example.com",
+           "example.net"
+         ]
+         { discard; stop; }
+
+#    I just added the following section after the joe-job
+#    that we all suffered at the hands of "inbox.com".
+#    The "myusername" is MY username at FastMail.
+#    DISCARDing this mail instead of directing it to a
+#    SPAM folder kept me from going over quota repeatedly.
+
+#    To individual addresses
+         elsif header :contains "to"
+         [
+           "myusername@inbox.com",
+           "myusername@example.net"
+         ]
+         { discard; stop; }
+
+         elsif  allof
+             (
+                 not anyof
+                 (
+#### WHITELIST - KEEP ANYTHING THAT MATCHES
+#    From individual addresses
+                     header :contains "from"
+                     [
+                       "username@example.com",
+                       "username@example.net"
+                     ],
+
+#    From trusted domains
+                     header :contains "from"
+                     [
+                       "example.com",
+                       "example.net"
+                     ],
+
+#    Specific "to" address (mailing lists etc)
+                     header :contains ["to", "cc"]
+                     [
+                       "username@example.com",
+                       "username@example.net"
+                     ],
+
+#    Specific "subject" keywords
+                     header :contains "subject"
+                     [
+                       "code_word_for_friend_#1",
+                       "code_word_for_friend_#2"
+                     ]
+
+                 ),
+                 anyof
+                 (
+
+#    Filter by keywords in subject or from headers
+                     header :contains ["subject", "from"]
+                     [
+                       "adilt", "adult", "advertise", "affordable",
+                       "as seen on tv", "antenna", "alarm",
+                       "background check", "bankrupt", "bargain",
+                       "best price", "bikini", "boost reliability",
+                       "brand new", "breast", "business directory",
+                       "business opportunity", "based business", "best
+                       deal", "bachelor's", "benefits", "cable",
+                       "career", "casino", "celeb", "cheapest", "child
+                       support", "cd-r", "catalog", "classified ad",
+                       "click here", "coed", "classmate", "commerce",
+                       "congratulations", "credit", "cruise", "cds",
+                       "complimentary", "columbia house", "crushlink",
+                       "debt", "detective", "diploma", "directv",
+                       "directtv", "dish", "dream vacation", "deluxe",
+                       "drug", "dvds", "dvd movie", "doubleclick",
+                       "digital tv", "erotic", "exciting new",
+                       "equalamail", "fantastic business", "fat
+                       burning", "financial independence", "finalist",
+                       "for life", "financing", "fitness", "fixed
+                       rate", "four reports", "free!", "free
+                       business", "from home", "funds", "fbi know",
+                       "fortune", "gambl", "getaway", "girls", "great
+                       price", "guaranteed", "get big", "get large",
+                       "giveaway", "hard core", "hardcore", "home
+                       document imaging", "home employment directory",
+                       "homeowner", "home owner", "homeworker", "home
+                       security", "home video", "immediate release",
+                       "information you requested", "income",
+                       "inkjet", "insurance", "interest rate",
+                       "invest", "internet connection", "join price",
+                       "judicial judgment", "just released", "know
+                       your rights", "legal", "license", "loan", "long
+                       distance", "look great", "low interest",
+                       "low-interest", "low rate", "lust", "lbs",
+                       "make money", "market", "master card",
+                       "mastercard", "meg web", "merchant account",
+                       "millionaire", "mini-vacation", "mortgage",
+                       "master's", "magazine", "nasty", "new car",
+                       "nigeria", "nude", "nympho", "naked",
+                       "obligation", "online business", "opportunity",
+                       "pager", "paying too much", "pda", "penis",
+                       "pennies", "pills", "porn", "pounds",
+                       "pre-approved", "prescri", "prscri", "prize",
+                       "prostate", "printer ink", "quote", "refinanc",
+                       "remove fat", "removing fat", "reward",
+                       "sales", "satellite", "saw your site",
+                       "scrambler", "sex", "smoking", "snoring", "some
+                       people succeed", "special invitation", "special
+                       offer", "stock", "saving", "singles", "teen",
+                       "ticket", "tired of", "truth about anyone",
+                       "the best", "ucking", "unbelievable",
+                       "uncensored", "uncollected", "unlimited", "USA
+                       domains", "urgent", "valium", "viagra",
+                       "venture capital", "virgin", "visa", "vitamin",
+                       "waist", "wealth", "webcam", "weight", "win a",
+                       "winner", "win one", "work smarter", "work at
+                       home", "xxx", "younger", "your web site", "your
+                       money", "your date is wait",
+                       "!!!", "$", "%", "10K"
+                     ],
+
+#    Filter when the subject is all uppercase (no lowercase)
+                     header :regex :comparator
+                     "i;octet" "subject" "^[^[:lower:]]+$",
+
+#    Filter using regular expressions on the subject
+                     header :regex    "subject"
+                     [
+                       "start.+business", "live.+auction",
+                       "discover.+card", "pay.+college", "apr$",
+                       "apr[^[:alnum:]]", "adv[^[:alnum:]]",
+                       "free.+(coupon|info|install|money)",
+                       "free.+(phone|sample|test|trial)",
+                       "(buy|sell).+(house|home)"
+                     ],
+
+#    Filter with tracker codes in the subject
+                     header :regex    "subject"
+                     "[[:space:].\-_]{4}#?\[?[[:alnum:]-]+\]?$",
+
+#    Filter spam with no to/from address set
+                     not exists    ["To", "From"],
+
+#    Filter spam not addressed to me
+#        Put here all of your own addresses (and alias) that you expect
+#        mail addressed to.  I found a lot of my spam didn't have my
+#        name in the TO or CC fields at all -- it must have been in the
+#        BCC (which doesn't show in the headers).  I can still get BCC
+#        mail from legitimate sources because everyone in my address
+#        book is on the WHITELIST above.
+
+                     not header :contains ["to", "cc"]
+                     [
+                       "myusername@example.com",
+                       "myusername@example.net"
+                     ]
+
+                 )
+             )
+         { fileinto "INBOX.1_spam"; }
+
+
+
+#### Virus Filter
+         elsif  header :contains ["subject", "from"]
+         [
+           "infected file rejected",
+           "infected file rejected"
+         ]
+         { fileinto "INBOX.1_virus"; }
+
+
+#### Telephone Alerts
+#        Any message that gets this far should not be spam,
+#        and a copy gets sent to my cell-phone as a TEXT message.
+
+         elsif  header :contains ["to", "cc"]
+         [
+           "myusername@example.com",
+           "myaliasname@example.com"
+         ]
+         { redirect "2135551234@mobile.example.net"; keep; }
+
+
+
+# END OF SCRIPT
Index: b/sieve/examples/mjohnson.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/mjohnson.sieve
@@ -0,0 +1,421 @@
+# Example Sieve Script
+#  Author: Matthew Johnson
+#  URL: http://wiki.fastmail.fm/index.php?title=MatthewJohnson
+
+##########################################################################
+#######  SIEVE SCRIPT by Matthew Johnson - MRJ Solutions, Inc. ###########
+#######  Email me at mailto:mattjohnson2005@gmail.com ##
+#######  Code Version: 12JUN2004                               ###########
+##########################################################################
+require ["envelope", "fileinto", "reject", "vacation", "regex", "relational",
+         "comparator-i;ascii-numeric"];
+#
+# todo:
+# change to a nested format with
+#   allof()s and nots.
+# add "in address book" check. ex:"header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes""
+# finish reformating lines to <= 75 col (for web edit box)
+#   and delete rulers.
+# Mine Michael Klose script for ideas.
+# Check out the update to the Sieve pages on the Fastmail Wiki.
+#
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+require ["envelope", "fileinto", "reject", "vacation", "regex",
+         "relational", "comparator-i;ascii-numeric"];
+
+
+
+# BLACKLIST - Mails to discard, drop on the floor.
+#   -high spam values except those delivered to me
+#   -Chinese content except for low spam values
+#   -virus rejected notifications
+#   -known spam addresses
+#   -newsletters that refuse my removal requests
+#   -twit-list
+#   -double twit-list
+#   -other
+
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+if  anyof
+    (
+      allof       # combo test one - high spam values except for mail to/from me
+      (
+        # spam score is greater or equal to 14
+        header :value "ge" :comparator "i;ascii-numeric"
+                           ["X-Spam-score"] ["14"],
+        not header :contains "X-Spam-Score" "-",
+        not header :contains "X-Spam-Score" "0.0",
+        not header :contains ["to","from","cc","bcc","received"]
+           [
+             # do not discard email to me, will file or discard
+             # as spam later if needed
+             "matt@zeta.net",
+             "matthew@bigsc.com",
+             "matthew_johnson@bigsmallcompany.com",
+             "mmm@spend.com",
+             "finger@spend.com",
+             "myyaacct@yahoo.com"
+           ]
+       ), # end allof
+      allof       #combo test two - chinese content except for low spam values
+      (
+        anyof
+        (
+           header :regex "Subject"  "^=\\?(gb|GB)2312\\?",  # Chinese ecoding at subject
+           header :regex "Subject"  "^=\\?big5\\?", # Other kind of  Chinese mail
+
+           # Chinese content type
+           header :contains "Content-Type"
+            [
+             "GB2312",
+             "big5"
+            ]
+        ), #end anyof
+        not anyof
+        (
+           #We have to check the sign and the value separately: ascii-numeric, defined at
+           #header :contains "X-Spam-Score" "-",
+           header :value "lt" :comparator "i;ascii-numeric" "X-Spam-Score" "3"
+         )  #end not anyof
+     ), # end allof - test two
+
+     # single tests
+
+     # discard fastmail virus notifications
+     header :is ["subject"] ["Infected file rejected"],
+
+     # black list, invalid addresses receiving a large amount of spam
+     # or spam bounces,rejected zeta.net accounts.
+     header :contains ["X-Delivered-to"]
+
+                        ["eagleeye@zeta.net","ealgeeye@zeta.net",
+                        "alica.thiele@zeta.net", "2005@theta.com",
+                        "jimlovingu2@zeta.net",
+                        "alpha@zeta.net",
+                        "JoshuaS@zeta.net",
+                        "donnaf@zeta.net",
+                        "pspinks@zeta.net",
+                        "jsherman@zeta.net",
+                        "holly@zeta.net",
+                        "clabarca@zeta.net",
+                        "meghanr@zeta.net",
+                        "rtaylor@zeta.net",
+                        "lboone@zeta.net",
+                        "brower@zeta.net",
+                        "jenj@zeta.net",
+                        "cbackus@zeta.net",
+                        "spengles@zeta.net",
+                        "adams@zeta.net",
+                        "dsmith@zeta.net",
+                        "jwilderman@zeta.net",
+                        "TimF@zeta.net",
+                        "zd@zeta.net",
+                        "louise@zeta.net"]
+
+     # single 'not' tests
+     # ---out for testing---  not header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes"
+    ) # end anyof()
+{
+   discard;
+   stop;
+}
+
+
+#
+# WHITELIST - Keep these mails and put them in the inbox
+#             (some kept getting put in Junk Mail)
+#             Family, Friends, Current Vendors, Customers
+#             Contents of fastmail address book.
+#
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+if  anyof (  header :contains ["from","to","cc","bcc"]
+                     [ "notification@eBay.com",
+                       "MAILER-DAEMON@zeta.net",
+                       "USPS_Track_Confirm@usps.com",
+                       "credit.services@target.com",
+                       "Comcast_Paydirect@comcast.net",
+                       "mary@zeta.net",
+                       "betty@zeta.net",
+                       "andmanymore@zeta.net"
+                       ],
+            header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes"
+          )
+{
+  fileinto "INBOX";
+  stop;
+}
+
+# redirects
+if header :contains ["to", "cc"] "mary1@zeta.net"
+ {
+  redirect "mary@zeta.net";
+  stop;
+ }
+
+
+#
+#   +Spam filtering by score on 3, 5 and 14(above).
+#
+#
+if  header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["5"]  {
+    fileinto "INBOX.Junk Mail.ge5";
+    stop;
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+} elsif  header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["3"]  {
+    fileinto "INBOX.Junk Mail.ge3";
+    stop;
+}
+
+
+# Potential Blacklist, start with soft discard, then migrate to full discard above
+#
+# Blacklist (2nd) During testing, throw into "Junk Mail.discard" until
+#                 ready to discard.
+#
+if anyof
+   (
+    # rejects for accounts across all domains
+    header :contains ["X-Delivered-to"]
+                  [
+                  "drjoe@","VX@",
+                  "alfa@zeta.net",
+                  "media@zeta.net",
+                  "zeta@zeta.net",
+                  "xyz@zeta.net"
+                  ],
+
+    # other criteria - weird message from this account
+    header :contains ["from"] ["Charlie Root"],
+    # mailers that are always sending spam returns to me
+    header :contains ["from"] ["MAILER-DAEMON@aol.com"] ,
+    header :contains ["from"] ["MAILER-DAEMON@otenet.gr"] ,
+
+    # common account names that I don't use in any of my domains and that spammers like
+    header :contains ["X-Delivered-to"]
+                     [ "biz@","sales@","support@", "service@", "reg@",
+                       "registration@", "regisration@", "root@", "webmaster@", "noreply@"
+                     ],
+    # zeta.net common account names to reject
+    header :contains ["X-Delivered-to"] ["info@zeta.net"],
+    # bigsc.com  rejects
+    header :contains ["X-Delivered-to"] ["info@bigsc.com"],
+    # theta.com rejects
+    header :contains ["X-Delivered-to"] ["info@theta.com"],
+    header :contains ["X-Delivered-to"] ["reg@theta.com"]
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+        # saves for use maybe later
+        #   header :contains ["X-Delivered-to"] ["webmaster@zeta.net"],
+        #   header :contains ["X-Delivered-to"] ["webmaster@theta.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@bs.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@theta.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@bigsc.com"],
+        #   header :contains ["X-Delivered-to"] "root@zeta.net",
+
+   )   #end  anyof() 2nd blacklist
+{
+
+  fileinto "INBOX.Junk Mail.discard";
+  stop;
+}
+
+
+#  +Greylist, move to "INBOX.Junk Mail.greylist"
+#
+#   'Soft' Blacklist  ?Greylist?
+#
+
+#annoying person(s) that send questionable attachments
+#  look at occationally
+if  header :contains "from" "alex@yahoo.com"
+{
+  fileinto "INBOX.Junk Mail.greylist";
+} elsif  header :contains "subject" "MAILER-DAEMON@fastmail.fm"
+                                     #  non-person, but might
+                                     # want to look at it while
+								     # figuring issues
+{
+  fileinto "INBOX.Junk Mail.greylist";
+  stop;
+}
+
+#   +Spammy domains to filter
+#
+# domains that are known to be present in spam
+#
+if  header :contains ["from", "received"] [".ru",".jp", ".kr", ".pt",
+					                     ".pl",".at",".cz",".cn",".lu" ]
+{
+  fileinto "INBOX.Junk Mail.discard";
+  stop;
+}
+
+
+#
+#  Annoying newsletters that won't unsubscribe me, reject
+#
+
+if anyof (
+           #annoying newsletters
+           header :contains ["from"] "VistaPrintNews",               # 2003
+           header :contains ["from"] "newsletter@briantracyintl.com", # 2003
+           header :contains ["from"] "info@yogalist.com",            # 2003
+           header :contains ["from"] "The Angela Larson Real Estate Team",
+           header :contains ["from"] "Brian Tracy"
+         )
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+{
+   reject "I HAVE TRIED TO UNSUBSCRIBE; I DO NOT WANT YOUR NEWSLETTER; PLEASE UNSUBSCRIBE ME";
+  stop;
+}
+
+
+
+
+#
+# Suspected zeta.net user from/to Zeta Institute, NY - reject
+#
+#
+#
+if    header :contains ["X-Delivered-to","from"]
+          [
+          # aaaaNEW_ENTRIES_ABOVE  ###################################
+          "neville@zeta.net",
+          "animika@zeta.net",
+          "linda@zeta.net",
+          "jerry@zeta.net",
+          "adamS@zeta.net",
+          "lkdamon@zeta.net",
+          "AdamS@zeta.net",
+          "DConnor@zeta.net",
+          "LOUISR@zeta.net",
+
+          # Start of Alpha #############################################
+          "Allanv@zeta.net",
+          "AmberJ@zeta.net",
+          "DANDERSON@zeta.net",
+          "Jonas@zeta.net",
+          "KarenE@zeta.net",
+          "J.R.C.@zeta.net", # check to see if this is working
+          "PMackey@zeta.net",
+
+          "adrienne@zeta.net","alpha@zeta.net","amina@zeta.net",
+          "anamika@zeta.net",
+          "claborca@zeta.net","communications@zeta.net",
+          "cz241@zeta.net",
+          "dee@zeta.net",
+          "ellenb@zeta.net","evis@zeta.net",
+          "frivera@zeta.net",
+          "gblack@zeta.net","gbrown@zeta.net","george@zeta.net","grace@zeta.net",
+          "happygolucky@zeta.net","hsp@zeta.net",
+          "ila@zeta.net",
+          "jacqueline_fenatifa@zeta.net","jlengler@zeta.net",
+          "joel@zeta.net","jolsen@zeta.net", "jsherman@zeta.net",
+          "kronjeklandish@zeta.net","kwilcox@zeta.net","bettyb@zeta.net",
+          "laurie@zeta.net","llmansell@zeta.net",
+          "louise@zeta.net","lzollo@zeta.net",
+          "mcraft@zeta.net","meganB@zeta.net","mwezi@zeta.net",
+          "nanwile@zeta.net",
+          "zetasound@zeta.net",
+          "peter@zeta.net",
+          "randi@zeta.net", "rcbackus@zeta.net", "registration@zeta.net",
+          "registration@omgea.org",
+          "rtaylor@zeta.net",
+          "sdonnarumma@zeta.net","stephanR@zeta.net","suzanne@zeta.net","suzzane@zeta.net",
+          "taryngaughan_dn@zeta.net"
+          # zzzzEND_OF_LIST####
+          ]   #end of Xdelivered-to list for possible zeta institute users
+
+{
+  reject text:
+      ERROR: Your email has not been delivered.
+
+      You have reached the mailer at zeta.net
+
+      Perhaps you want to send to Zeta Institute in DillyDally, NY, USA?
+
+      Use  USER@zeta.net for them
+
+      or try registration@zeta.net
+      Check the website at  http://www.zeta.net/zeta/contact/
+      Call Registration at    1 800 944 1001.
+
+      or use this information:
+
+      Zeta Institute
+      150 River Drive
+      DillyDally, NY 12666
+      Registration: 800-900-0000
+      Ph: 845-200-0000
+      Fax: 845-200-0001
+      registration@zeta.net
+
+      sincerely, POSTMASTER
+.
+;
+  fileinto "Inbox.Junk Mail.ezeta";
+  stop;
+ }
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+# +Move messages into folders
+#
+# Process other messages into separate folders
+#
+ # newsletters and mail lists
+if  header :contains  ["subject"]
+                      [ "newsletter", "[tc-ieee-", "[icntc",
+                        "JUG News", "Xdesksoftware",
+                        "announcement"   ]
+{
+  fileinto "INBOX.Newsletters";
+} elsif header :contains ["from","subject"] ["Anthony Robbins"] {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains ["from","subject"] ["MN Entrepreneurs","ME!"]  {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains ["from","received"] "adc.apple.com" {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "wnewadmn@ieee.org" {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "@lb.bcentral.com" {  # techworthy@lb.bcentral.com
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "announcement@netbriefings.com" {  #st paul company
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "newsletter@eletters.extremetech.com" {  #semi-annoying rag
+  fileinto "INBOX.Newsletters";
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+# my newsletter throw-away addresses
+} elsif  header :contains "to" ["microcenter@zeta.net","nmha@zeta.net"] {
+  fileinto "INBOX.Newsletters";
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+#
+# Alerts mailbox
+} elsif header :contains ["subject", "from"]
+                         [
+                          "Alert",                         # F-Prot virus alert service, matches:
+                                                           # "FRISK Virus Alert"
+                                                           #     or use s:FRISK Virus Alert:
+                                                           #     or use f:support@f-prot.com
+                          "Payment",                       # Alerts from other payments
+                          "credit.services@target.com",    # Target Card Payments
+                          "notify@quickbase.com"           # Tic Talkers Database changes
+                         ]
+{
+  fileinto "INBOX.Alerts";
+  stop;
+}
+
+# +Announcements from Dave Rolm, forward
+#
+# Perl Announcements from Dave Rolm
+if  header :contains "from" "dave@other.org"
+{
+  fileinto "Inbox";
+  keep;
+}
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+#######################################################################
+#### END OF SIEVE SCRIPT by Matthew Johnson - MRJ Solutions, Inc. #####
+################ email me at mailto:mattjohnson2005@gmail.com   #
+
Index: b/sieve/examples/mklose.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/mklose.sieve
@@ -0,0 +1,303 @@
+# Example Sieve Script
+#   Author: Michael Klose
+#   URL: http://wiki.fastmail.fm/index.php?title=MichaelKloseSieveScript
+
+require ["fileinto", "reject", "vacation", "regex", "relational", "comparator-i;ascii-numeric"];
+
+# Experimental
+
+# End experimental
+
+
+
+# ----------------------------------------------
+#    Discard messages (high Spam values)
+# ----------------------------------------------
+
+if anyof
+    (
+     allof
+      (
+       #Spam score > 17?
+       #We have to check the sign and the value separately: ascii-numeric, defined at http://www.ietf.org/rfc/rfc2244.txt, doesn't see minus signs or decimal points ("-" or ".").
+       header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "17",
+       not header :contains "X-Spam-Score" "-",
+
+       not header :contains ["to","cc"]
+        [
+         "@my-domain.de",
+         "myemail@myotherdomain.us",
+         "myotheremail@myotherdomain.us",
+         "myotheremail2@myotherdomain.us"
+         # Do not discard stuff going to me - gets filed into Junk later
+        ],
+       not header :contains "from"
+        [
+         "lockergnome.com",
+         "Excite@info.excite.com" # gets filed into Junk later
+        ]
+
+
+      ),
+     allof
+      (
+       header :contains "X-LinkName" "hotmail", # OR anything from Hotmail with low spam
+       allof
+        (
+         header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "7",
+         not header :contains "X-Spam-Score" "-"
+        )
+      ),
+
+     # Black List
+
+     header :contains "from"
+      [
+       "ahbbcom@cncorn.com",
+       "Darg. B."
+      ],
+
+     # Chinese Encoding at BEGINNING of Subject
+
+     allof
+      (
+       anyof
+        (
+         header :regex "Subject"  "^=\\?(gb|GB)2312\\?",  # Chinese ecoding at subject
+         header :regex "Subject"  "^=\\?big5\\?", # Other kind of Chinese mail
+
+         # Chinese content type
+
+         header :contains "Content-Type"
+          [
+           "GB2312",
+           "big5"
+          ]
+        ),
+       not anyof
+        (
+      #Spam score > -4? <sic> - ascii-numeric ignores the ".9"!.  -Or is this correct?
+       #We have to check the sign and the value separately: ascii-numeric, defined at http://www.ietf.org/rfc/rfc2244.txt, doesn't see minus signs or decimal points ("-" or ".").
+
+         header :contains "X-Spam-Score" "-",
+         header :value "lt" :comparator "i;ascii-numeric" "X-Spam-Score" "4"
+        )
+      )
+    )
+
+{
+
+
+  # discard;
+
+  if header :contains "X-LinkName" "hotmail"
+   { discard; }
+  else
+   { fileinto "INBOX.Junk.Reject"; }
+   # I used to reject this stuff, but I wanted to know what I was rejecting, and this stuck.
+  stop;
+}
+
+
+
+# Addresses that need to be forwarded to a different domain here before spam checking
+# ******************************Michael - I don't understand what you're doing here!  -elvey
+# REPLY: this here is actually used to forward stuff addressed to my sister (using my domain)
+# to her - without using one of the own-domain aliases.
+
+if header :contains ["to", "cc"]
+ [
+  "bla@blabla.de",
+  "bla2@blabla.us",
+  "bla3@blabla.us"
+ ]
+ {
+  redirect "otheremailaddress@something.com";
+  redirect "anotheremailadress@something.com";
+  stop;
+ }
+
+
+# File into a folder before Spam filtering
+
+if header :contains ["to","cc"]
+ [
+  "important@mydomain.us",
+  "important2@mydomain.us"
+ ]
+ {
+  fileinto "Inbox.Important";
+  stop;
+ }
+
+
+
+# -------------------------------------------
+#              Filing rules
+# -------------------------------------------
+
+
+# Pre-SPAM
+
+
+if size :over 750K
+ {
+  fileinto "INBOX.largemail";
+  stop;
+ }
+
+
+if header :contains "from"
+   [
+
+# White list 1 (with SMS notification)
+
+    "Fred Bloggs",
+    "f.bloggs@hotmail.com",
+    "myboss@somecompany.com",
+    "Trisha",
+    "endofauction@ebay.de" # I want to know about end of auctions
+    ]
+ {
+  fileinto "Inbox";
+
+  # Send an SMS
+  redirect "smsgateway@somegateway.de";
+  keep;
+
+  stop;
+ }
+
+  # Advertising I want to receive, which normally ends up in the SPAM filter
+
+  if anyof
+   (
+    header :contains "from"
+
+     [
+
+# Advertising whitelist
+
+      "Mark Libbert",
+      "newsletter@snapfish.dom"
+     ],
+    header :contains "Return-Path" "mailings@gmx.dom"
+   )
+   { fileinto "INBOX.Ads"; }
+  elsif  header :contains "from"
+   [
+    "newsletter@neuseelandhaus.dom",
+    "Lockergnome",
+    "CNET News.com"
+   ]
+   { fileinto "INBOX.Newsletter";
+
+
+
+# Spam protection
+
+
+} elsif anyof
+   (
+
+    #Spam assasin
+    allof
+     (
+      header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "6",
+      not header :contains "X-Spam-Score" "-",
+      not anyof # White list
+       (
+        header :contains "From"         # Whitelist From addresses
+         [
+          "CNN Quick News",
+          "FastMail.FM Support",
+          "lockergnome.com"
+         ]
+       )
+     ),
+
+    # User defined
+
+    # Filter out Femalename1234z12@ spam (base64 encoded)
+    allof
+     (
+      header :regex "From" "alpha:{2,}digit:{2,}alpha:+digit:{2,}@",
+      header :contains "Content-Type" "multipart/mixed"
+     ),
+    # Filter our Spam with invalid headers. You can see this because FM adds
+    # @fastmail.fm to them. For safty, check that mklose@ @michael-klose mkmail@gmx do
+    # not appear
+
+    # Mklose: addition: The only negative side effect I have seen of the condition below
+    # is that it catches the FM newsletters. So far I find them in the spam occasionly
+    # but since they are so few, I have never bothered changing this to not catch them.
+
+    allof
+     (
+      header :contains "To" "@fastmail.fm", # I do not have a fastmail address   # This doesn't catch BCC's; you should be checking the envelop instead.  -elvey
+      not header :contains ["To", "CC", "Reply-To"] ["klose","mkmail@gmx.dom", "chaospower"]
+     )
+   )
+  {
+   fileinto "INBOX.Junk";
+   stop;
+  }
+
+
+# Post Spam-protection
+
+  elsif  header :contains ["to", "cc"] "gpc@gnu.dom" {
+  fileinto "INBOX.GPC";
+} elsif  header :contains ["to", "cc"] "alfs\-discuss@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-Support.ALFS";
+} elsif  header :contains "subject" "(usagi\-users" {
+  fileinto "INBOX.Usagi";
+} elsif anyof (header :contains "Subject" "\[eplus-de\]", header :contains "Reply-To" "eplus-de") {
+  fileinto "INBOX.E-Plus";
+} elsif  header :contains ["to", "cc"] "lfs\-support@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-Support";
+} elsif  header :contains ["to", "cc"] "netdev@oss.sgi.dom" {
+  fileinto "INBOX.NetDev";
+} elsif  header :contains ["to", "cc"] "lfs\-dev@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-DEV";
+} elsif  header :contains "from" "GMX Best Price" {
+  fileinto "INBOX.Werbung";
+} elsif  header :contains "subject" "RHN Errata Alert" {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "from"
+  [
+   "EmailDiscussions.com Mailer",
+   "help1@dungorm.dom"
+  ] {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "subject" "\[Gaim\-commits\]" {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "subject" "\[Bug" {
+  fileinto "INBOX.Notifications.Bugzilla";
+} elsif header :contains "X-LinkName" "hotmail" {
+  fileinto "INBOX.Old Hotmail.new";
+}
+
+
+# -----------------------------------------------------------------------
+#               SMS notifications and forwarding
+# -----------------------------------------------------------------------
+
+if allof
+    (
+     header :contains "to" ["@mydomain1.de","email@mydomain2.us","email2@somedomain"],
+     not header :contains "from"
+      [
+
+# This avoids sending SMS notifications if I am the sender
+
+       "@mydomain1.de",
+       "myotheremail@somedomain.de",
+       "myotheremail@someotherdomain.de"
+      ]
+    )
+ {
+  redirect "smsgateway@somegateway.com";
+  keep;
+ }
+
Index: b/sieve/examples/relational.rfc5231.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/relational.rfc5231.sieve
@@ -0,0 +1,33 @@
+require ["relational", "comparator-i;ascii-numeric", "fileinto"];
+
+if header :value "lt" :comparator "i;ascii-numeric"
+	["x-priority"] ["3"]
+{
+	fileinto "Priority";
+}
+
+elsif address :count "gt" :comparator "i;ascii-numeric"
+	["to"] ["5"]
+{
+	# everything with more than 5 recipients in the "to" field
+	# is considered SPAM
+	fileinto "SPAM";
+}
+
+elsif address :value "gt" :all :comparator "i;ascii-casemap"
+	["from"] ["M"]
+{
+	fileinto "From N-Z";
+} else {
+	fileinto "From A-M";
+}
+
+if allof (
+	address :count "eq" :comparator "i;ascii-numeric"
+		["to", "cc"] ["1"] ,
+	address :all :comparator "i;ascii-casemap"
+		["to", "cc"] ["me@foo.example.com"] )
+{
+	fileinto "Only me";
+}
+
Index: b/sieve/examples/rfc3028.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/rfc3028.sieve
@@ -0,0 +1,58 @@
+#
+# Example Sieve Filter
+# Declare any optional features or extension used by the script
+#
+require ["fileinto", "reject"];
+
+#
+# Reject any large messages (note that the four leading dots get
+# "stuffed" to three)
+#
+if size :over 1M
+    {
+    reject text:
+Please do not send me large attachments.
+Put your file on a server and send me the URL.
+Thank you.
+.... Fred
+.
+;
+    stop;
+    }
+#
+
+# Handle messages from known mailing lists
+# Move messages from IETF filter discussion list to filter folder
+#
+if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+    {
+    fileinto "filter";  # move to "filter" folder
+    }
+#
+# Keep all messages to or from people in my company
+#
+elsif address :domain :is ["From", "To"] "example.com"
+    {
+    keep;               # keep in "In" folder
+    }
+
+#
+# Try and catch unsolicited email.  If a message is not to me,
+# or it contains a subject known to be spam, file it away.
+#
+elsif anyof (not address :all :contains
+         ["To", "Cc", "Bcc"] "me@example.com",
+     header :matches "subject"
+         ["*make*money*fast*", "*university*dipl*mas*"])
+    {
+    # If message header does not contain my address,
+    # it's from a list.
+    fileinto "spam";   # move to "spam" folder
+    }
+ else
+    {
+    # Move all other (non-company) mail to "personal"
+    # folder.
+    fileinto "personal";
+    }
+
Index: b/sieve/examples/sanjay.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/sanjay.sieve
@@ -0,0 +1,171 @@
+# Example Sieve Script
+#   Author: SanjaySheth
+#   URL: http://wiki.fastmail.fm/index.php?title=SanjaySieveSpamFilter
+
+require "fileinto";
+
+if anyof (
+
+      # Blacklisted sender domains
+      header :contains ["from", "Received", "X-Sender", "Sender",
+                        "To","CC","Subject","X-Mail-from"]
+             [ "123greetings", "allfreewebsite.com",
+               "new-fields.com","atlasrewards","azogle.com",
+               "bannerport.net","bettingextreme.com","bigemailoffers.com",
+               "BlingMail.com",
+               "beyondoffers.net", ".biz ", ".biz]",
+               "cavalrymail.com","ciol.com","citywire.co.uk",
+               "cosmicclick.com",
+               "consumergamblingreport","creativemailoffers.com","creativeoffers.com",
+               "daily-promotions.com",
+               "dailypromo.","dailypromotions.",
+               "dandyoffers","dlbdirect",
+               "e54.org",  "email-specials.net","email-ware.com","emailoffersondemand",
+               "emailbargain.com","emailofferz","emailrewardz","etoll.net","emailvalues.com",
+               "evaluemarketing.com","exitrequest.com",
+               "fantastic-bargain.com","fpsamplesmail.com","freelotto",
+               "findtv.com", "freddysfabulousfinds.com",
+               "genuinerewards.com",
+               "hotdailydeal.com","hulamediamail","hy-e.net",
+               "inboxbargains.com","idealemail.com",
+               "jackpot.com","jpmailer.com",
+               "lolita","lund.com.br",
+               "mafgroup.com","mailasia.com","mailtonic.net","migada.com","ms83.com",
+               "nationaloffers.com","nexdeals.com ",
+               "offercatch.com","offermagnet.com","offerservice.net","offertime.com",
+               "offersdaily.net","optnetwork.net",
+               "ombramarketing.com","on-line-offers.com","outblaze.com",
+               "permissionpass","primetimedirect.net","productsontheweb.net",
+               "rapid-e.net","recessionspecials", "redmoss","remit2india",
+               "sampleoffers.com","savingsmansion.com","sendoutmail.com","simpleoffers.com",
+               "specialdailydeals4u.com","Select-Point.net",
+               "speedyvalues.com","sportsoffers","sporttime.info","suntekglobal.com",
+               "superstorespecials.com", "synapseconnect","sunsetterawnings.com",
+               "thefreesamplenews","truemail.net",
+               "ub-kool","ultimatesports.info","uniquemailoffers","utopiad.com",
+               "unixlovers.net",
+               "valuesdirect","virtualoffers.net",
+               "wagerzine", "webdpoffrz",
+               "yestshirt.com",
+               "z-offer.com", "zipido.com"
+             ],
+
+      # Blacklisted ip subnets due to excessive spam from them
+      header :contains "Received"
+             [ "[4.63.221.224",
+               "[24.244.141.112",
+               "[61.171.253.177",
+               "[63.123.149.", "[63.209.206.", "(63.233.30.73", "[63.251.200.",
+               "[64.41.183.","[64.49.250.", "[64.57.188.", "[64.57.221.",
+               "[64.62.204.",
+               "[64.70.17.", "[64.70.44.", "[64.70.53.",
+               "[64.39.27.6", "[64.39.27.7","[64.191.25.","[64.191.36.",
+               "[64.191.9.",
+               "[64.125.181.", "[64.191.123.", "[64.191.23.", "[64.239.182.",
+               "[65.211.3.",
+               "[66.46.150.", "[66.62.162.", "[66.118.170.", "[66.129.124.",
+               "[66.205.217.", "[66.216.111.", "[66.239.204.",
+               "[67.86.69.",
+               "[80.34.206.", "[80.80.98.",
+               "[81.72.233.13",
+               "[128.242.120.",
+               "[157.238.18",
+               "[168.234.195.18]",
+               "[193.253.198.57",
+               "[194.25.83.1",
+               "[200.24.129.", "[200.161.203.",
+               "[202.164.182.76]","[202.57.69.116",
+               "[203.19.220.","[203.22.104.","[203.22.105.",
+               "[204.188.52.",
+               "[205.153.154.203",
+               "[206.26.195.", "[206.154.33.","[206.169.178",
+               "[207.142.3.",
+               "[208.46.5.","[208.187.",
+               "[209.164.27.","[209.236.",
+               "[210.90.75.129]",
+               "[211.101.138.199","[211.185.7.125]","[211.239.231.",
+               "[212.240.95.",
+               "[213.47.250.139", "[213.225.61.",
+               "[216.22.79.","[216.39.115.","[216.99.240.",
+               "[216.126.32.", "[216.187.123.","[217.36.124.53",
+               "[218.145.25","[218.52.71.103","[218.158.136.115",
+               "[218.160.42.74", "[218.242.112.4]"
+             ],
+
+      # Blacklisted SpamAssassin flags
+      header :contains ["SPAM", "X-Spam-hits"]
+             ["ADDRESSES_ON_CD","ACT_NOW","ADULT_SITE", "ALL_CAP_PORN",
+              "AMATEUR_PORN", "AS_SEEN_ON",
+              "BAD_CREDIT", "BALANCE_FOR_LONG_20K", "BARELY_LEGAL", "BEEN_TURNED_DOWN",
+              "BANG_GUARANTEE", "BANG_MONEY","BASE64_ENC_TEXT",
+              "BAYES_99","BAYES_90",
+              "BE_BOSS", "BEST_PORN", "BULK_EMAIL",
+              "CASINO", "CONSOLIDATE_DEBT", "COPY_ACCURATELY", "COPY_DVD",
+              "DIET", "DO_IT_TODAY","DOMAIN_4U2",
+              "EMAIL_MARKETING","EMAIL_ROT13", "EXPECT_TO_EARN","EARN_MONEY",
+              "FIND_ANYTHING", "FORGED_AOL_RCVD",
+              "FORGED_HOTMAIL_RCVD", "FORGED_YAHOO_RCVD",
+              "FORGED_RCVD_TRAIL", "FORGED_JUNO_RCVD",
+              "FORGED_MUA_",
+              "FREE_MONEY","FREE_PORN",
+              "GENTLE_FEROCITY", "GET_PAID", "GUARANTEED_STUFF", "GUARANTEED_100_PERCENT",
+              "HAIR_LOSS", "HIDDEN_ASSETS", "HGH,", "HOME_EMPLOYMENT","HOT_NASTY","HTTP_ESCAPED_HOST",
+              "HTTP_USERNAME_USED","HTML_FONT_INVISIBLE",
+              "IMPOTENCE","INVALID_MSGID","INVESTMENT",
+              "LESBIAN","LIVE_PORN","LOSE_POUNDS",
+              "MARKETING_PARTNERS", "MORTGAGE_OBFU", "MORTGAGE_RATES",
+              "NIGERIAN_SCAM", "NIGERIAN_TRANSACTION_1", "NIGERIAN_BODY", "NUMERIC_HTTP_ADDR",
+              "NO_MX_FOR_FROM","NO_DNS_FOR_FROM",
+              "OBFUSCATING_COMMENT", "ONLINE_PHARMACY",
+              "PENIS_ENLARGE",
+              "PREST_NON_ACCREDITED", "PURE_PROFIT","PORN_4",
+              "RCVD_IN_DSBL", "RCVD_IN_OSIRUSOFT_COM","RCVD_IN_BL_SPAMCOP_NET", "RCVD_IN_SBL",
+              "RCVD_IN_MULTIHOP_DSBL", "RCVD_IN_RELAYS_ORDB_ORG", "RCVD_IN_UNCONFIRMED_DSBL",
+              "RCVD_FAKE_HELO_DOTCOM", "RCVD_IN_RFCI", "RCVD_IN_NJABL","RCVD_IN_SORBS",
+              "REFINANCE", "REVERSE_AGING",
+              "SAVE_ON_INSURANCE","SPAM_REDIRECTOR", "STOCK_ALERT", "STOCK_PICK", "STRONG_BUY",
+              "SEE_FOR_YOURSELF", "SUPPLIES_LIMITED",
+              "THE_BEST_RATE","TONER",
+              "UNSECURED_CREDIT",
+              "VACATION_SCAM", "VIAGRA", "VJESTIKA",
+              "WHILE_SUPPLIES", "WORK_AT_HOME",
+              "X_OSIRU_DUL", "X_OSIRU_SPAMWARE_SITE", "X_OSIRU_SPAM_SRC"
+             ],
+
+
+      # Blacklisted subjects
+
+      header :contains ["From","Subject"]
+             [" penis ",
+              "ADV:", "adult dvd", "adult movie", "adultdirect", "adultemail",
+              "background check", "bankrupt", "boobs", "business opportunity","big@boss.com",
+              "casino", "cash guarantee",
+              "debt free", "diet bread", "ebay secrets", "erection",
+              "financial freedom", "free credit",
+              "gambl", "gov grants", "jackpot",
+              "life insurance", "lottery", "lotto",
+              "mortgage", "nude", "OTCBB",
+              "penis", "porn", "promotion", "proven System",
+              " rape ",
+              " sex ", "skin resurfacing", "special offer",
+              "ultimate software", "viagra", "V1AGRA", "vivatrim",
+              "win money","work from home", "xxx"
+             ],
+
+      # often spam emails to multiple addresses with same name & different domain
+      header :matches ["To","CC"]
+             ["*fastmail*fastmail*fastmail*fastmail*fastmail*"],
+
+      # Almost all emails from these domains is spam (at least for me)
+      header :contains ["from", "received"]
+                       [".ru ",".jp ", ".kr ", ".pt ",".pl ",".at ",".cz ",
+                        ".ru>",".jp>", ".kr>", ".pt>", ".pl>",".at>",".cz>"],
+
+      # Really high SpamAssassin scores (15.0+)
+      header :matches ["X-Spam-score","X-Remote-Spam-score"] [
+          "1?.?", "2?.?", "3?.?", "4?.?", "5?.?", "6?.?"     # 10.0 to 69.9
+      ]
+) {
+      fileinto "INBOX.Spam.discard";
+      stop;
+}
Index: b/sieve/examples/sieve_examples.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/sieve_examples.sieve
@@ -0,0 +1,73 @@
+# Example Sieve Script
+#   Author: unknown
+#   URL: http://wiki.fastmail.fm/index.php?title=MoreSieveExamples
+
+require ["fileinto", "reject"];
+
+###BYPASSES###
+
+if anyof (
+              header :contains ["From"] "friend1",
+              header :contains ["From"] "friend12",
+              header :contains ["From"] "friend3",
+              header :contains ["From"] "friendsdomanin",
+              header :contains ["Subject"] "elephant"  ##a safeword
+         )
+             {
+                   fileinto "INBOX";
+                   stop;
+             }
+
+###BIG MESSAGE PROTECTION
+if size :over 5000K {
+         reject "Message over 5MB size limit.  Please contact me before sending this.";
+}
+
+##SPAM FILTERING##
+if header :contains ["X-Spam"] "high" {
+      discard;
+      stop;
+}
+if header :contains ["X-Spam-Flag"] "HIGH" {
+      discard;
+      stop;
+}
+if header :contains ["X-Spam"] "spam" {
+      fileinto "INBOX.spam";  #emails forwarded from my unviersity account get SA tagged like this
+      stop;
+}
+if header :contains ["X-Spam-Flag"] "YES" {
+      fileinto "INBOX.spam";
+      stop;
+}
+
+####LOCAL SPAM RULES#######
+if header :contains ["From"]  "bannerport" { discard; stop; }  ##keyword filters for when SA doesn't quite catch them
+if header :contains ["To"]  "MATT NOONE" { discard; stop; }
+###AUTO management rules###
+
+####Student Digest stuff#### ###   Examples of boolean OR rules
+if anyof (
+            header :contains ["X-BeenThere"] "student-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "firstyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "secondyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "thirdyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "fourthyear-digest@list.xxx.edu"
+         )
+         {
+            fileinto "INBOX.lists.digests";
+            stop;
+         }
+if allof (   ###A Boolean AND rule
+            header :contains ["From"] "buddy1",
+            header :contains ["To"]   "myotheraddress"
+         )
+         {
+            fileinto "INBOX.scc.annoy";
+            stop;
+         }
+
+#other local rules
+if header :contains ["Subject"]  "helmreich" { fileinto "INBOX.lists.helmreich"; stop; }
+if header :contains ["Subject"]  "helmcomm" { fileinto "INBOX.lists.helmreich"; stop; }
+if header :contains ["Subject"]  "packeteer" { fileinto "INBOX.lists"; stop; }
Index: b/sieve/examples/subaddress.rfc5233.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/subaddress.rfc5233.sieve
@@ -0,0 +1,23 @@
+require ["envelope", "subaddress", "fileinto"];
+
+# In this example the same user account receives mail for both
+# "ken@example.com" and "postmaster@example.com"
+
+# File all messages to postmaster into a single mailbox,
+# ignoring the :detail part.
+if envelope :user "to" "postmaster" {
+	fileinto "inbox.postmaster";
+	stop;
+}
+
+# File mailing list messages (subscribed as "ken+mta-filters").
+if envelope :detail "to" "mta-filters" {
+	fileinto "inbox.ietf-mta-filters";
+}
+
+# Redirect all mail sent to "ken+foo".
+if envelope :detail "to" "foo" {
+	redirect "ken@example.net";
+}
+
+
Index: b/sieve/examples/vacation.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/vacation.sieve
@@ -0,0 +1,23 @@
+require ["fileinto","reject", "vacation"];
+if allof (header :contains  "X-Spam-Flag" "YES")
+{
+    discard ;
+}
+
+elsif allof (header :contains "subject" "<quation>")
+{
+vacation
+:addresses "<name@domain.ru>"
+:subject "<Answear>"
+:mime "MIME-Version: 1.0
+Content-Type: text/html; charset=KOI8-R
+Content-Transfer-Encoding: 7bit
+<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">
+<HTML><HEAD><META http-equiv=Content-Type content=\"text/html; charset=windows-KOI8-R\">
+</HEAD><BODY>123</BODY></HTML>";
+ discard ;
+}
+else
+{
+     keep;
+}
Index: b/sieve/examples/vivil.sieve
===================================================================
--- /dev/null
+++ b/sieve/examples/vivil.sieve
@@ -0,0 +1,94 @@
+# Example Sieve Script
+#   Author: Vivil
+#   URL: http://wiki.fastmail.fm/index.php?title=Vivil
+#   Removed unused notify require
+
+# *************************************************************************
+require ["envelope", "fileinto", "reject", "vacation", "regex", "relational",
+"comparator-i;ascii-numeric"];
+
+
+if size :over 2048K {
+  reject "Message not delivered; size over limit accepted by recipient";
+  stop;
+}
+
+#because of the use of elsif below, none of the "stop;"'s below are needed, but they're good 'defensive programming'. Only the one above is actually needed.
+
+redirect "login@gmail.dom";
+
+if header :contains ["from","cc"]
+[
+  "from-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "sex.com newsletter",
+  "ad@gator.com",
+  "newsletter@takecareof.com",
+  "from-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+
+elsif header :contains ["from"]
+[
+  "mygirlfriend-who-use-incredimail@foo.dom"
+]
+{
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+
+#use of "to" field detection next lines is ONLY USEFUL FOR DOMAIN NAME OWNERS if you forward your mail to your fastmail account, some virus/spam send mail to well known addresses as info@willemijns.dom i never use...
+
+elsif header :contains ["to","cc"]
+[
+  "to-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "FTPsebastien@willemijns.dom",
+  "info@willemijns.dom",
+  "webmaster@willemijns.dom",
+  "to-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+
+elsif header :contains ["subject"]
+[
+  "subject-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "Undeliverable mail: Registration is accepted",
+  "subject-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+elsif header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["6"]  {
+  fileinto "INBOX.Junk Mail";
+  stop;
+}
+elsif header :contains "from" "reflector@launay.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains "from" "do-not-reply@franconews.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains "from" "devnull@news.telefonica.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains ["to"] ["sebastien@willemijns.dom"] {
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+elsif header :contains ["to"] ["seb@willemijns.dom"] {
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+else {
+  fileinto "INBOX";
+}
+# ********************************************************************
Index: b/sieve/install-sh
===================================================================
--- /dev/null
+++ b/sieve/install-sh
@@ -0,0 +1,519 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2006-12-25.00
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+
+nl='
+'
+IFS=" ""	$nl"
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=${DOITPROG-}
+if test -z "$doit"; then
+  doit_exec=exec
+else
+  doit_exec=$doit
+fi
+
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
+
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
+
+posix_glob='?'
+initialize_posix_glob='
+  test "$posix_glob" != "?" || {
+    if (set -f) 2>/dev/null; then
+      posix_glob=
+    else
+      posix_glob=:
+    fi
+  }
+'
+
+posix_mkdir=
+
+# Desired mode of installed file.
+mode=0755
+
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
+rmcmd="$rmprog -f"
+stripcmd=
+
+src=
+dst=
+dir_arg=
+dst_arg=
+
+copy_on_change=false
+no_target_directory=
+
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
+
+  -c            (ignored)
+  -C            install only if different (preserve the last data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -s            $stripprog installed files.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
+"
+
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
+
+    -C) copy_on_change=true;;
+
+    -d) dir_arg=true;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+	shift;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) mode=$2
+	case $mode in
+	  *' '* | *'	'* | *'
+'*	  | *'*'* | *'?'* | *'['*)
+	    echo "$0: invalid mode: $mode" >&2
+	    exit 1;;
+	esac
+	shift;;
+
+    -o) chowncmd="$chownprog $2"
+	shift;;
+
+    -s) stripcmd=$stripprog;;
+
+    -t) dst_arg=$2
+	shift;;
+
+    -T) no_target_directory=true;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    --)	shift
+	break;;
+
+    -*)	echo "$0: invalid option: $1" >&2
+	exit 1;;
+
+    *)  break;;
+  esac
+  shift
+done
+
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+  done
+fi
+
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+if test -z "$dir_arg"; then
+  trap '(exit $?); exit' 1 2 13 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+
+    dst=$dst_arg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dst_arg: Is a directory" >&2
+	exit 1
+      fi
+      dstdir=$dst
+      dst=$dstdir/`basename "$src"`
+      dstdir_status=0
+    else
+      # Prefer dirname, but fall back on a substitute if dirname fails.
+      dstdir=`
+	(dirname "$dst") 2>/dev/null ||
+	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	     X"$dst" : 'X\(//\)[^/]' \| \
+	     X"$dst" : 'X\(//\)$' \| \
+	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
+	echo X"$dst" |
+	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)[^/].*/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\).*/{
+		   s//\1/
+		   q
+		 }
+		 s/.*/./; q'
+      `
+
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+	# Create intermediate dirs using mode 755 as modified by the umask.
+	# This is like FreeBSD 'install' as of 1997-10-28.
+	umask=`umask`
+	case $stripcmd.$umask in
+	  # Optimize common cases.
+	  *[2367][2367]) mkdir_umask=$umask;;
+	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;
+
+	  *[0-7])
+	    mkdir_umask=`expr $umask + 22 \
+	      - $umask % 100 % 40 + $umask % 20 \
+	      - $umask % 10 % 4 + $umask % 2
+	    `;;
+	  *) mkdir_umask=$umask,go-w;;
+	esac
+
+	# With -d, create the new directory with the user-specified mode.
+	# Otherwise, rely on $mkdir_umask.
+	if test -n "$dir_arg"; then
+	  mkdir_mode=-m$mode
+	else
+	  mkdir_mode=
+	fi
+
+	posix_mkdir=false
+	case $umask in
+	  *[123567][0-7][0-7])
+	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
+	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
+	    ;;
+	  *)
+	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+
+	    if (umask $mkdir_umask &&
+		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+	    then
+	      if test -z "$dir_arg" || {
+		   # Check for POSIX incompatibilities with -m.
+		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+		   # other-writeable bit of parent directory when it shouldn't.
+		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+		   case $ls_ld_tmpdir in
+		     d????-?r-*) different_mode=700;;
+		     d????-?--*) different_mode=755;;
+		     *) false;;
+		   esac &&
+		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
+		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+		   }
+		 }
+	      then posix_mkdir=:
+	      fi
+	      rmdir "$tmpdir/d" "$tmpdir"
+	    else
+	      # Remove any dirs left behind by ancient mkdir implementations.
+	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+	    fi
+	    trap '' 0;;
+	esac;;
+    esac
+
+    if
+      $posix_mkdir && (
+	umask $mkdir_umask &&
+	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # The umask is ridiculous, or mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+	/*) prefix='/';;
+	-*) prefix='./';;
+	*)  prefix='';;
+      esac
+
+      eval "$initialize_posix_glob"
+
+      oIFS=$IFS
+      IFS=/
+      $posix_glob set -f
+      set fnord $dstdir
+      shift
+      $posix_glob set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+	test -z "$d" && continue
+
+	prefix=$prefix$d
+	if test -d "$prefix"; then
+	  prefixes=
+	else
+	  if $posix_mkdir; then
+	    (umask=$mkdir_umask &&
+	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+	    # Don't fail if two instances are running concurrently.
+	    test -d "$prefix" || exit 1
+	  else
+	    case $prefix in
+	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+	      *) qprefix=$prefix;;
+	    esac
+	    prefixes="$prefixes '$qprefix'"
+	  fi
+	fi
+	prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+	# Don't fail if two instances are running concurrently.
+	(umask $mkdir_umask &&
+	 eval "\$doit_exec \$mkdirprog $prefixes") ||
+	  test -d "$dstdir" || exit 1
+	obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
+
+       eval "$initialize_posix_glob" &&
+       $posix_glob set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       $posix_glob set +f &&
+
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+	# Now remove or move aside any old file at destination location.
+	# We try this two ways since rm can't unlink itself on some
+	# systems and the destination file might be busy for other
+	# reasons.  In this case, the final cleanup might fail but the new
+	# file should still install successfully.
+	{
+	  test ! -f "$dst" ||
+	  $doit $rmcmd -f "$dst" 2>/dev/null ||
+	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
+	  } ||
+	  { echo "$0: cannot unlink or rename $dst" >&2
+	    (exit 1); exit 1
+	  }
+	} &&
+
+	# Now rename the file to the real destination.
+	$doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
Index: b/sieve/ltmain.sh
===================================================================
--- /dev/null
+++ b/sieve/ltmain.sh
@@ -0,0 +1,8413 @@
+# Generated from ltmain.m4sh.
+
+# ltmain.sh (GNU libtool) 2.2.6b
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#     --config             show all configuration variables
+#     --debug              enable verbose shell tracing
+# -n, --dry-run            display commands without modifying any files
+#     --features           display basic configuration information and exit
+#     --mode=MODE          use operation mode MODE
+#     --preserve-dup-deps  don't remove duplicate dependency libraries
+#     --quiet, --silent    don't print informational messages
+#     --tag=TAG            use configuration variables from tag TAG
+# -v, --verbose            print informational messages (default)
+#     --version            print version information
+# -h, --help               print short or long help message
+#
+# MODE must be one of the following:
+#
+#       clean              remove files from the build directory
+#       compile            compile a source file into a libtool object
+#       execute            automatically set library path, then run a program
+#       finish             complete the installation of libtool libraries
+#       install            install libraries or executables
+#       link               create a library or an executable
+#       uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#       host-triplet:	$host
+#       shell:		$SHELL
+#       compiler:		$LTCC
+#       compiler flags:		$LTCFLAGS
+#       linker:		$LD (gnu? $with_gnu_ld)
+#       $progname:		(GNU libtool) 2.2.6b Debian-2.2.6b-2
+#       automake:		$automake_version
+#       autoconf:		$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION="2.2.6b Debian-2.2.6b-2"
+TIMESTAMP=""
+package_revision=1.3017
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# NLS nuisances: We save the old values to restore during execute mode.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+lt_user_locale=
+lt_safe_locale=
+for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
+	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+	fi"
+done
+
+$lt_unset CDPATH
+
+
+
+
+
+: ${CP="cp -f"}
+: ${ECHO="echo"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
+: ${LN_S="ln -s"}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SED="/bin/sed"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+# Generated shell functions inserted here.
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+# In the unlikely event $progname began with a '-', it would play havoc with
+# func_echo (imagine progname=-n), so we prepend ./ in that case:
+func_dirname_and_basename "$progpath"
+progname=$func_basename_result
+case $progname in
+  -*) progname=./$progname ;;
+esac
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=$func_dirname_result
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=:
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+opt_warning=:
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname${mode+: }$mode: $*"
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $opt_warning && $ECHO "$progname${mode+: }$mode: warning: "${1+"$@"} 1>&2
+
+    # bash bug again:
+    :
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "X$my_directory_path" | $Xsed -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "X$my_dir_list" | $Xsed -e 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "X$my_tmpdir" | $Xsed
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "X$1" | $Xsed -e "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "X$1" | $Xsed \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+# func_show_eval_locale cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$lt_user_locale
+	    $my_cmd"
+      my_status=$?
+      eval "$lt_safe_locale"
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $SED -n '/^# Usage:/,/# -h/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    $ECHO
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help
+# Echo long help message to standard output and exit.
+func_help ()
+{
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
+	p
+     }' < "$progpath"
+    exit $?
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    func_error "missing argument for $1"
+    exit_cmd=exit
+}
+
+exit_cmd=:
+
+
+
+
+
+# Check that we have a working $ECHO.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t'; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell, and then maybe $ECHO will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+magic="%%%MAGIC variable%%%"
+magic_exe="%%%MAGIC EXE variable%%%"
+
+# Global variables.
+# $mode is unset
+nonopt=
+execute_dlfiles=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+opt_dry_run=false
+opt_duplicate_deps=false
+opt_silent=false
+opt_debug=:
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    $ECHO "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $ECHO "enable shared libraries"
+    else
+      $ECHO "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $ECHO "enable static libraries"
+    else
+      $ECHO "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+# Parse options once, thoroughly.  This comes as soon as possible in
+# the script to make things like `libtool --version' happen quickly.
+{
+
+  # Shorthand for --mode=foo, only valid as the first argument
+  case $1 in
+  clean|clea|cle|cl)
+    shift; set dummy --mode clean ${1+"$@"}; shift
+    ;;
+  compile|compil|compi|comp|com|co|c)
+    shift; set dummy --mode compile ${1+"$@"}; shift
+    ;;
+  execute|execut|execu|exec|exe|ex|e)
+    shift; set dummy --mode execute ${1+"$@"}; shift
+    ;;
+  finish|finis|fini|fin|fi|f)
+    shift; set dummy --mode finish ${1+"$@"}; shift
+    ;;
+  install|instal|insta|inst|ins|in|i)
+    shift; set dummy --mode install ${1+"$@"}; shift
+    ;;
+  link|lin|li|l)
+    shift; set dummy --mode link ${1+"$@"}; shift
+    ;;
+  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+    shift; set dummy --mode uninstall ${1+"$@"}; shift
+    ;;
+  esac
+
+  # Parse non-mode specific arguments:
+  while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+      --config)		func_config					;;
+
+      --debug)		preserve_args="$preserve_args $opt"
+			func_echo "enabling shell trace mode"
+			opt_debug='set -x'
+			$opt_debug
+			;;
+
+      -dlopen)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			execute_dlfiles="$execute_dlfiles $1"
+			shift
+			;;
+
+      --dry-run | -n)	opt_dry_run=:					;;
+      --features)       func_features					;;
+      --finish)		mode="finish"					;;
+
+      --mode)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			case $1 in
+			  # Valid mode arguments:
+			  clean)	;;
+			  compile)	;;
+			  execute)	;;
+			  finish)	;;
+			  install)	;;
+			  link)		;;
+			  relink)	;;
+			  uninstall)	;;
+
+			  # Catch anything else as an error
+			  *) func_error "invalid argument for $opt"
+			     exit_cmd=exit
+			     break
+			     ;;
+		        esac
+
+			mode="$1"
+			shift
+			;;
+
+      --preserve-dup-deps)
+			opt_duplicate_deps=:				;;
+
+      --quiet|--silent)	preserve_args="$preserve_args $opt"
+			opt_silent=:
+			;;
+
+      --verbose| -v)	preserve_args="$preserve_args $opt"
+			opt_silent=false
+			;;
+
+      --tag)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			preserve_args="$preserve_args $opt $1"
+			func_enable_tag "$1"	# tagname is set here
+			shift
+			;;
+
+      # Separate optargs to long options:
+      -dlopen=*|--mode=*|--tag=*)
+			func_opt_split "$opt"
+			set dummy "$func_opt_split_opt" "$func_opt_split_arg" ${1+"$@"}
+			shift
+			;;
+
+      -\?|-h)		func_usage					;;
+      --help)		opt_help=:					;;
+      --version)	func_version					;;
+
+      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
+
+      *)		nonopt="$opt"
+			break
+			;;
+    esac
+  done
+
+
+  case $host in
+    *cygwin* | *mingw* | *pw32* | *cegcc*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps
+      ;;
+  esac
+
+  # Having warned about all mis-specified options, bail out if
+  # anything was wrong.
+  $exit_cmd $EXIT_FAILURE
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+$opt_help || {
+  # Sanity checks first:
+  func_check_version_match
+
+  if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+    func_fatal_configuration "not configured to build any kind of library"
+  fi
+
+  test -z "$mode" && func_fatal_error "error: you must specify a MODE."
+
+
+  # Darwin sucks
+  eval std_shrext=\"$shrext_cmds\"
+
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    func_error "unrecognized option \`-dlopen'"
+    $ECHO "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+}
+
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    test -f "$1" &&
+      $SED -e 4q "$1" 2>/dev/null \
+        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 0<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_script_p file
+# True iff FILE is a libtool wrapper script
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_script_p ()
+{
+    func_lalib_p "$1"
+}
+
+# func_ltwrapper_executable_p file
+# True iff FILE is a libtool wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_executable_p ()
+{
+    func_ltwrapper_exec_suffix=
+    case $1 in
+    *.exe) ;;
+    *) func_ltwrapper_exec_suffix=.exe ;;
+    esac
+    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
+}
+
+# func_ltwrapper_scriptname file
+# Assumes file is an ltwrapper_executable
+# uses $file to determine the appropriate filename for a
+# temporary ltwrapper_script.
+func_ltwrapper_scriptname ()
+{
+    func_ltwrapper_scriptname_result=""
+    if func_ltwrapper_executable_p "$1"; then
+	func_dirname_and_basename "$1" "" "."
+	func_stripname '' '.exe' "$func_basename_result"
+	func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+    fi
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script or wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+        func_quote_for_eval "$arg"
+	CC_quoted="$CC_quoted $func_quote_for_eval_result"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_quote_for_eval "$arg"
+	      CC_quoted="$CC_quoted $func_quote_for_eval_result"
+	    done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      $MV "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          pie_flag="$pie_flag $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_quote_for_eval "$arg"
+	    lastarg="$lastarg $func_quote_for_eval_result"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_quote_for_eval "$lastarg"
+      base_compile="$base_compile $func_quote_for_eval_result"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    case $libobj in
+    *.[cCFSifmso] | \
+    *.ada | *.adb | *.ads | *.asm | \
+    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
+    *.[fF][09]? | *.for | *.java | *.obj | *.sx)
+      func_xform "$libobj"
+      libobj=$func_xform_result
+      ;;
+    esac
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_dirname_and_basename "$obj" "/" ""
+    objname="$func_basename_result"
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2* | cegcc*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      removelist="$removelist $output_obj"
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    removelist="$removelist $lockfile"
+    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      func_show_eval_locale "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      func_show_eval_locale "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+	removelist=$lockfile
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+$opt_help || {
+test "$mode" = compile && func_mode_compile ${1+"$@"}
+}
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$mode'"
+        ;;
+    esac
+
+    $ECHO
+    $ECHO "Try \`$progname --help' for more information about other modes."
+
+    exit $?
+}
+
+  # Now that we've collected a possible --mode arg, show help if necessary
+  $opt_help && func_mode_help
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_script_p "$file"; then
+	  func_source "$file"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	elif func_ltwrapper_executable_p "$file"; then
+	  func_ltwrapper_scriptname "$file"
+	  func_source "$func_ltwrapper_scriptname_result"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_quote_for_eval "$file"
+      args="$args $func_quote_for_eval_result"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	$ECHO "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    $ECHO "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $ECHO "   $libdir"
+    done
+    $ECHO
+    $ECHO "If you ever happen to want to link against installed libraries"
+    $ECHO "in a given directory, LIBDIR, you must either use libtool, and"
+    $ECHO "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $ECHO "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $ECHO "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $ECHO "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $ECHO "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $ECHO "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $ECHO "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $ECHO
+
+    $ECHO "See any operating system documentation about shared libraries for"
+    case $host in
+      solaris2.[6789]|solaris2.1[0-9])
+        $ECHO "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	$ECHO "pages."
+	;;
+      *)
+        $ECHO "more information, such as the ld(1) and ld.so(8) manual pages."
+        ;;
+    esac
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $ECHO "X$nonopt" | $GREP shtool >/dev/null; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    install_prog="$install_prog$func_quote_for_eval_result"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      install_prog="$install_prog $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname_and_basename "$dest" "" "."
+      destdir="$func_dirname_result"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "X$destdir" | $Xsed -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32* | cegcc*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin* | *mingw*)
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      wrapper=$func_ltwrapper_scriptname_result
+	    else
+	      func_stripname '' '.exe' "$file"
+	      wrapper=$func_stripname_result
+	    fi
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_script_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_verbose "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_verbose "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_verbose "extracting global C symbols from \`$progfile'"
+	    $opt_dry_run || eval "$NM $progfile | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* | *cegcc* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin | *mingw* | *cegcc* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+	  $opt_dry_run || {
+	    eval '$ECHO ": $name " >> "$nlist"'
+	    eval "$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	  }
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    $ECHO '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+"
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc* )
+	    $ECHO >> "$output_objdir/$my_dlsyms" "\
+/* DATA imports from DLLs on WIN32 con't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs.  */"
+	    lt_dlsym_const= ;;
+	  *osf5*)
+	    echo >> "$output_objdir/$my_dlsyms" "\
+/* This system does not cope well with relocations in const data */"
+	    lt_dlsym_const= ;;
+	  *)
+	    lt_dlsym_const=const ;;
+	  esac
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+extern $lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+$lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  case $need_lib_prefix in
+	  no)
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  *)
+	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  esac
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) symtab_cflags="$symtab_cflags $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* | *cegcc* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" 'exit $?'
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  func_arith $extracted_serial + 1
+	  extracted_serial=$func_arith_result
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_verbose "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename "$darwin_archive"`
+	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      $LIPO -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+
+# func_emit_wrapper_part1 [arg=no]
+#
+# Emit the first part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part1 ()
+{
+	func_emit_wrapper_part1_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part1_arg1=$1
+	fi
+
+	$ECHO "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    ECHO=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`{ \$ECHO '\t'; } 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$ECHO works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$ECHO will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$ECHO "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+"
+}
+# end: func_emit_wrapper_part1
+
+# func_emit_wrapper_part2 [arg=no]
+#
+# Emit the second part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part2 ()
+{
+	func_emit_wrapper_part2_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part2_arg1=$1
+	fi
+
+	$ECHO "\
+
+  # Usually 'no', except on cygwin/mingw when embedded into
+  # the cwrapper.
+  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1
+  if test \"\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\" = \"yes\"; then
+    # special case for '.'
+    if test \"\$thisdir\" = \".\"; then
+      thisdir=\`pwd\`
+    fi
+    # remove .libs from thisdir
+    case \"\$thisdir\" in
+    *[\\\\/]$objdir ) thisdir=\`\$ECHO \"X\$thisdir\" | \$Xsed -e 's%[\\\\/][^\\\\/]*$%%'\` ;;
+    $objdir )   thisdir=. ;;
+    esac
+  fi
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $ECHO "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$ECHO "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2* | *-cegcc*)
+	  $ECHO "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $ECHO "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$ECHO "\
+      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
+      exit 1
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    $ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+}
+# end: func_emit_wrapper_part2
+
+
+# func_emit_wrapper [arg=no]
+#
+# Emit a libtool wrapper script on stdout.
+# Don't directly open a file because we may want to
+# incorporate the script contents within a cygwin/mingw
+# wrapper executable.  Must ONLY be called from within
+# func_mode_link because it depends on a number of variables
+# set therein.
+#
+# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
+# variable will take.  If 'yes', then the emitted script
+# will assume that the directory in which it is stored is
+# the $objdir directory.  This is a cygwin/mingw-specific
+# behavior.
+func_emit_wrapper ()
+{
+	func_emit_wrapper_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_arg1=$1
+	fi
+
+	# split this up so that func_emit_cwrapperexe_src
+	# can call each part independently.
+	func_emit_wrapper_part1 "${func_emit_wrapper_arg1}"
+	func_emit_wrapper_part2 "${func_emit_wrapper_arg1}"
+}
+
+
+# func_to_host_path arg
+#
+# Convert paths to host format when used with build tools.
+# Intended for use with "native" mingw (where libtool itself
+# is running under the msys shell), or in the following cross-
+# build environments:
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+# where wine is equipped with the `winepath' executable.
+# In the native mingw case, the (msys) shell automatically
+# converts paths for any non-msys applications it launches,
+# but that facility isn't available from inside the cwrapper.
+# Similar accommodations are necessary for $host mingw and
+# $build cygwin.  Calling this function does no harm for other
+# $host/$build combinations not listed above.
+#
+# ARG is the path (on $build) that should be converted to
+# the proper representation for $host. The result is stored
+# in $func_to_host_path_result.
+func_to_host_path ()
+{
+  func_to_host_path_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        case $build in
+          *mingw* ) # actually, msys
+            # awkward: cmd appends spaces to result
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_path_tmp1=`( cmd //c echo "$1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_path_tmp1=`cygpath -w "$1"`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # Unfortunately, winepath does not exit with a non-zero
+            # error code, so we are forced to check the contents of
+            # stdout. On the other hand, if the command is not
+            # found, the shell will set an exit code of 127 and print
+            # *an error message* to stdout. So we must check for both
+            # error code of zero AND non-empty stdout, which explains
+            # the odd construction:
+            func_to_host_path_tmp1=`winepath -w "$1" 2>/dev/null`
+            if test "$?" -eq 0 && test -n "${func_to_host_path_tmp1}"; then
+              func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+                $SED -e "$lt_sed_naive_backslashify"`
+            else
+              # Allow warning below.
+              func_to_host_path_result=""
+            fi
+            ;;
+        esac
+        if test -z "$func_to_host_path_result" ; then
+          func_error "Could not determine host path corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback:
+          func_to_host_path_result="$1"
+        fi
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_path
+
+# func_to_host_pathlist arg
+#
+# Convert pathlists to host format when used with build tools.
+# See func_to_host_path(), above. This function supports the
+# following $build/$host combinations (but does no harm for
+# combinations not listed here):
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+#
+# Path separators are also converted from $build format to
+# $host format. If ARG begins or ends with a path separator
+# character, it is preserved (but converted to $host format)
+# on output.
+#
+# ARG is a pathlist (on $build) that should be converted to
+# the proper representation on $host. The result is stored
+# in $func_to_host_pathlist_result.
+func_to_host_pathlist ()
+{
+  func_to_host_pathlist_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        # Remove leading and trailing path separator characters from
+        # ARG. msys behavior is inconsistent here, cygpath turns them
+        # into '.;' and ';.', and winepath ignores them completely.
+        func_to_host_pathlist_tmp2="$1"
+        # Once set for this call, this variable should not be
+        # reassigned. It is used in tha fallback case.
+        func_to_host_pathlist_tmp1=`echo "$func_to_host_pathlist_tmp2" |\
+          $SED -e 's|^:*||' -e 's|:*$||'`
+        case $build in
+          *mingw* ) # Actually, msys.
+            # Awkward: cmd appends spaces to result.
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_pathlist_tmp2=`( cmd //c echo "$func_to_host_pathlist_tmp1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_pathlist_tmp2=`cygpath -w -p "$func_to_host_pathlist_tmp1"`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # unfortunately, winepath doesn't convert pathlists
+            func_to_host_pathlist_result=""
+            func_to_host_pathlist_oldIFS=$IFS
+            IFS=:
+            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do
+              IFS=$func_to_host_pathlist_oldIFS
+              if test -n "$func_to_host_pathlist_f" ; then
+                func_to_host_path "$func_to_host_pathlist_f"
+                if test -n "$func_to_host_path_result" ; then
+                  if test -z "$func_to_host_pathlist_result" ; then
+                    func_to_host_pathlist_result="$func_to_host_path_result"
+                  else
+                    func_to_host_pathlist_result="$func_to_host_pathlist_result;$func_to_host_path_result"
+                  fi
+                fi
+              fi
+              IFS=:
+            done
+            IFS=$func_to_host_pathlist_oldIFS
+            ;;
+        esac
+        if test -z "$func_to_host_pathlist_result" ; then
+          func_error "Could not determine the host path(s) corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback. This may break if $1 contains DOS-style drive
+          # specifications. The fix is not to complicate the expression
+          # below, but for the user to provide a working wine installation
+          # with winepath so that path translation in the cross-to-mingw
+          # case works properly.
+          lt_replace_pathsep_nix_to_dos="s|:|;|g"
+          func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp1" |\
+            $SED -e "$lt_replace_pathsep_nix_to_dos"`
+        fi
+        # Now, add the leading and trailing path separators back
+        case "$1" in
+          :* ) func_to_host_pathlist_result=";$func_to_host_pathlist_result"
+            ;;
+        esac
+        case "$1" in
+          *: ) func_to_host_pathlist_result="$func_to_host_pathlist_result;"
+            ;;
+        esac
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_pathlist
+
+# func_emit_cwrapperexe_src
+# emit the source code for a wrapper executable on stdout
+# Must ONLY be called from within func_mode_link because
+# it depends on a number of variable set therein.
+func_emit_cwrapperexe_src ()
+{
+	cat <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "$SHELL $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat <<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef _MSC_VER
+# include <direct.h>
+# include <process.h>
+# include <io.h>
+# define setmode _setmode
+#else
+# include <unistd.h>
+# include <stdint.h>
+# ifdef __CYGWIN__
+#  include <io.h>
+#  define HAVE_SETENV
+#  ifdef __STRICT_ANSI__
+char *realpath (const char *, char *);
+int putenv (char *);
+int setenv (const char *, const char *, int);
+#  endif
+# endif
+#endif
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef S_IXOTH
+# define S_IXOTH 0
+#endif
+#ifndef S_IXGRP
+# define S_IXGRP 0
+#endif
+
+#ifdef _MSC_VER
+# define S_IXUSR _S_IEXEC
+# define stat _stat
+# ifndef _INTPTR_T_DEFINED
+#  define intptr_t int
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# define FOPEN_WB "wb"
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#ifdef __CYGWIN__
+# define FOPEN_WB "wb"
+#endif
+
+#ifndef FOPEN_WB
+# define FOPEN_WB "w"
+#endif
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+#undef LTWRAPPER_DEBUGPRINTF
+#if defined DEBUGWRAPPER
+# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args
+static void
+ltwrapper_debugprintf (const char *fmt, ...)
+{
+    va_list args;
+    va_start (args, fmt);
+    (void) vfprintf (stderr, fmt, args);
+    va_end (args);
+}
+#else
+# define LTWRAPPER_DEBUGPRINTF(args)
+#endif
+
+const char *program_name = NULL;
+
+void *xmalloc (size_t num);
+char *xstrdup (const char *string);
+const char *base_name (const char *name);
+char *find_executable (const char *wrapper);
+char *chase_symlinks (const char *pathspec);
+int make_executable (const char *path);
+int check_executable (const char *path);
+char *strendzap (char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+void lt_setenv (const char *name, const char *value);
+char *lt_extend_str (const char *orig_value, const char *add, int to_end);
+void lt_opt_process_env_set (const char *arg);
+void lt_opt_process_env_prepend (const char *arg);
+void lt_opt_process_env_append (const char *arg);
+int lt_split_name_value (const char *arg, char** name, char** value);
+void lt_update_exe_path (const char *name, const char *value);
+void lt_update_lib_path (const char *name, const char *value);
+
+static const char *script_text_part1 =
+EOF
+
+	    func_emit_wrapper_part1 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+	    cat <<EOF
+
+static const char *script_text_part2 =
+EOF
+	    func_emit_wrapper_part2 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+
+	    cat <<EOF
+const char * MAGIC_EXE = "$magic_exe";
+const char * LIB_PATH_VARNAME = "$shlibpath_var";
+EOF
+
+	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+              func_to_host_pathlist "$temp_rpath"
+	      cat <<EOF
+const char * LIB_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * LIB_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test -n "$dllsearchpath"; then
+              func_to_host_pathlist "$dllsearchpath:"
+	      cat <<EOF
+const char * EXE_PATH_VARNAME = "PATH";
+const char * EXE_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * EXE_PATH_VARNAME = "";
+const char * EXE_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test "$fast_install" = yes; then
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
+EOF
+	    else
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
+EOF
+	    fi
+
+
+	    cat <<"EOF"
+
+#define LTWRAPPER_OPTION_PREFIX         "--lt-"
+#define LTWRAPPER_OPTION_PREFIX_LENGTH  5
+
+static const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;
+static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
+
+static const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX "dump-script";
+
+static const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;
+static const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX "env-set";
+  /* argument is putenv-style "foo=bar", value of foo is set to bar */
+
+static const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;
+static const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX "env-prepend";
+  /* argument is putenv-style "foo=bar", new value of foo is bar${foo} */
+
+static const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;
+static const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX "env-append";
+  /* argument is putenv-style "foo=bar", new value of foo is ${foo}bar */
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int  newargc;
+  char *tmp_pathspec;
+  char *actual_cwrapper_path;
+  char *actual_cwrapper_name;
+  char *target_name;
+  char *lt_argv_zero;
+  intptr_t rval = 127;
+
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) argv[0]      : %s\n", argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) program_name : %s\n", program_name));
+
+  /* very simple arg parsing; don't want to rely on getopt */
+  for (i = 1; i < argc; i++)
+    {
+      if (strcmp (argv[i], dumpscript_opt) == 0)
+	{
+EOF
+	    case "$host" in
+	      *mingw* | *cygwin* )
+		# make stdout use "unix" line endings
+		echo "          setmode(1,_O_BINARY);"
+		;;
+	      esac
+
+	    cat <<"EOF"
+	  printf ("%s", script_text_part1);
+	  printf ("%s", script_text_part2);
+	  return 0;
+	}
+    }
+
+  newargz = XMALLOC (char *, argc + 1);
+  tmp_pathspec = find_executable (argv[0]);
+  if (tmp_pathspec == NULL)
+    lt_fatal ("Couldn't find %s", argv[0]);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (before symlink chase) at : %s\n",
+			  tmp_pathspec));
+
+  actual_cwrapper_path = chase_symlinks (tmp_pathspec);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (after symlink chase) at : %s\n",
+			  actual_cwrapper_path));
+  XFREE (tmp_pathspec);
+
+  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));
+  strendzap (actual_cwrapper_path, actual_cwrapper_name);
+
+  /* wrapper name transforms */
+  strendzap (actual_cwrapper_name, ".exe");
+  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
+  XFREE (actual_cwrapper_name);
+  actual_cwrapper_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  /* target_name transforms -- use actual target program name; might have lt- prefix */
+  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
+  strendzap (target_name, ".exe");
+  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
+  XFREE (target_name);
+  target_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  LTWRAPPER_DEBUGPRINTF (("(main) libtool target name: %s\n",
+			  target_name));
+EOF
+
+	    cat <<EOF
+  newargz[0] =
+    XMALLOC (char, (strlen (actual_cwrapper_path) +
+		    strlen ("$objdir") + 1 + strlen (actual_cwrapper_name) + 1));
+  strcpy (newargz[0], actual_cwrapper_path);
+  strcat (newargz[0], "$objdir");
+  strcat (newargz[0], "/");
+EOF
+
+	    cat <<"EOF"
+  /* stop here, and copy so we don't have to do this twice */
+  tmp_pathspec = xstrdup (newargz[0]);
+
+  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
+  strcat (newargz[0], actual_cwrapper_name);
+
+  /* DO want the lt- prefix here if it exists, so use target_name */
+  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
+  XFREE (tmp_pathspec);
+  tmp_pathspec = NULL;
+EOF
+
+	    case $host_os in
+	      mingw*)
+	    cat <<"EOF"
+  {
+    char* p;
+    while ((p = strchr (newargz[0], '\\')) != NULL)
+      {
+	*p = '/';
+      }
+    while ((p = strchr (lt_argv_zero, '\\')) != NULL)
+      {
+	*p = '/';
+      }
+  }
+EOF
+	    ;;
+	    esac
+
+	    cat <<"EOF"
+  XFREE (target_name);
+  XFREE (actual_cwrapper_path);
+  XFREE (actual_cwrapper_name);
+
+  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
+  lt_setenv ("DUALCASE", "1");  /* for MSK sh */
+  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);
+  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
+
+  newargc=0;
+  for (i = 1; i < argc; i++)
+    {
+      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)
+        {
+          if (argv[i][env_set_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_set_opt_len + 1;
+              lt_opt_process_env_set (p);
+            }
+          else if (argv[i][env_set_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_set (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_set_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)
+        {
+          if (argv[i][env_prepend_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_prepend_opt_len + 1;
+              lt_opt_process_env_prepend (p);
+            }
+          else if (argv[i][env_prepend_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_prepend (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_prepend_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)
+        {
+          if (argv[i][env_append_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_append_opt_len + 1;
+              lt_opt_process_env_append (p);
+            }
+          else if (argv[i][env_append_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_append (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_append_opt);
+          continue;
+        }
+      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)
+        {
+          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
+             namespace, but it is not one of the ones we know about and
+             have already dealt with, above (inluding dump-script), then
+             report an error. Otherwise, targets might begin to believe
+             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX
+             namespace. The first time any user complains about this, we'll
+             need to make LTWRAPPER_OPTION_PREFIX a configure-time option
+             or a configure.ac-settable value.
+           */
+          lt_fatal ("Unrecognized option in %s namespace: '%s'",
+                    ltwrapper_option_prefix, argv[i]);
+        }
+      /* otherwise ... */
+      newargz[++newargc] = xstrdup (argv[i]);
+    }
+  newargz[++newargc] = NULL;
+
+  LTWRAPPER_DEBUGPRINTF     (("(main) lt_argv_zero : %s\n", (lt_argv_zero ? lt_argv_zero : "<NULL>")));
+  for (i = 0; i < newargc; i++)
+    {
+      LTWRAPPER_DEBUGPRINTF (("(main) newargz[%d]   : %s\n", i, (newargz[i] ? newargz[i] : "<NULL>")));
+    }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+  /* execv doesn't actually work on mingw as expected on unix */
+  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  if (rval == -1)
+    {
+      /* failed to start process */
+      LTWRAPPER_DEBUGPRINTF (("(main) failed to launch target \"%s\": errno = %d\n", lt_argv_zero, errno));
+      return 127;
+    }
+  return rval;
+EOF
+		;;
+	      *)
+		cat <<"EOF"
+  execv (lt_argv_zero, newargz);
+  return rval; /* =127, but avoids unused variable warning */
+EOF
+		;;
+	    esac
+
+	    cat <<"EOF"
+}
+
+void *
+xmalloc (size_t num)
+{
+  void *p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
+			  string) : NULL;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char) name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable (const char *path)
+{
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(check_executable)  : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0)
+      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
+    return 1;
+  else
+    return 0;
+}
+
+int
+make_executable (const char *path)
+{
+  int rval = 0;
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(make_executable)   : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if (stat (path, &st) >= 0)
+    {
+      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);
+    }
+  return rval;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise
+   Does not chase symlinks, even on platforms that support them.
+*/
+char *
+find_executable (const char *wrapper)
+{
+  int has_slash = 0;
+  const char *p;
+  const char *p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char *concat_name;
+
+  LTWRAPPER_DEBUGPRINTF (("(find_executable)   : %s\n",
+			  wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!"));
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable (concat_name))
+	return concat_name;
+      XFREE (concat_name);
+    }
+  else
+    {
+#endif
+      if (IS_DIR_SEPARATOR (wrapper[0]))
+	{
+	  concat_name = xstrdup (wrapper);
+	  if (check_executable (concat_name))
+	    return concat_name;
+	  XFREE (concat_name);
+	}
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+    }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+      {
+	has_slash = 1;
+	break;
+      }
+  if (!has_slash)
+    {
+      /* no slashes; search PATH */
+      const char *path = getenv ("PATH");
+      if (path != NULL)
+	{
+	  for (p = path; *p; p = p_next)
+	    {
+	      const char *q;
+	      size_t p_len;
+	      for (q = p; *q; q++)
+		if (IS_PATH_SEPARATOR (*q))
+		  break;
+	      p_len = q - p;
+	      p_next = (*q == '\0' ? q : q + 1);
+	      if (p_len == 0)
+		{
+		  /* empty path: current directory */
+		  if (getcwd (tmp, LT_PATHMAX) == NULL)
+		    lt_fatal ("getcwd failed");
+		  tmp_len = strlen (tmp);
+		  concat_name =
+		    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, tmp, tmp_len);
+		  concat_name[tmp_len] = '/';
+		  strcpy (concat_name + tmp_len + 1, wrapper);
+		}
+	      else
+		{
+		  concat_name =
+		    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, p, p_len);
+		  concat_name[p_len] = '/';
+		  strcpy (concat_name + p_len + 1, wrapper);
+		}
+	      if (check_executable (concat_name))
+		return concat_name;
+	      XFREE (concat_name);
+	    }
+	}
+      /* not found in PATH; assume curdir */
+    }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen (tmp);
+  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable (concat_name))
+    return concat_name;
+  XFREE (concat_name);
+  return NULL;
+}
+
+char *
+chase_symlinks (const char *pathspec)
+{
+#ifndef S_ISLNK
+  return xstrdup (pathspec);
+#else
+  char buf[LT_PATHMAX];
+  struct stat s;
+  char *tmp_pathspec = xstrdup (pathspec);
+  char *p;
+  int has_symlinks = 0;
+  while (strlen (tmp_pathspec) && !has_symlinks)
+    {
+      LTWRAPPER_DEBUGPRINTF (("checking path component for symlinks: %s\n",
+			      tmp_pathspec));
+      if (lstat (tmp_pathspec, &s) == 0)
+	{
+	  if (S_ISLNK (s.st_mode) != 0)
+	    {
+	      has_symlinks = 1;
+	      break;
+	    }
+
+	  /* search backwards for last DIR_SEPARATOR */
+	  p = tmp_pathspec + strlen (tmp_pathspec) - 1;
+	  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    p--;
+	  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    {
+	      /* no more DIR_SEPARATORS left */
+	      break;
+	    }
+	  *p = '\0';
+	}
+      else
+	{
+	  char *errstr = strerror (errno);
+	  lt_fatal ("Error accessing file %s (%s)", tmp_pathspec, errstr);
+	}
+    }
+  XFREE (tmp_pathspec);
+
+  if (!has_symlinks)
+    {
+      return xstrdup (pathspec);
+    }
+
+  tmp_pathspec = realpath (pathspec, buf);
+  if (tmp_pathspec == 0)
+    {
+      lt_fatal ("Could not follow symlinks for %s", pathspec);
+    }
+  return xstrdup (tmp_pathspec);
+#endif
+}
+
+char *
+strendzap (char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert (str != NULL);
+  assert (pat != NULL);
+
+  len = strlen (str);
+  patlen = strlen (pat);
+
+  if (patlen <= len)
+    {
+      str += len - patlen;
+      if (strcmp (str, pat) == 0)
+	*str = '\0';
+    }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char *mode,
+	       const char *message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+
+void
+lt_setenv (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_setenv) setting '%s' to '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+  {
+#ifdef HAVE_SETENV
+    /* always make a copy, for consistency with !HAVE_SETENV */
+    char *str = xstrdup (value);
+    setenv (name, str, 1);
+#else
+    int len = strlen (name) + 1 + strlen (value) + 1;
+    char *str = XMALLOC (char, len);
+    sprintf (str, "%s=%s", name, value);
+    if (putenv (str) != EXIT_SUCCESS)
+      {
+        XFREE (str);
+      }
+#endif
+  }
+}
+
+char *
+lt_extend_str (const char *orig_value, const char *add, int to_end)
+{
+  char *new_value;
+  if (orig_value && *orig_value)
+    {
+      int orig_value_len = strlen (orig_value);
+      int add_len = strlen (add);
+      new_value = XMALLOC (char, add_len + orig_value_len + 1);
+      if (to_end)
+        {
+          strcpy (new_value, orig_value);
+          strcpy (new_value + orig_value_len, add);
+        }
+      else
+        {
+          strcpy (new_value, add);
+          strcpy (new_value + add_len, orig_value);
+        }
+    }
+  else
+    {
+      new_value = xstrdup (add);
+    }
+  return new_value;
+}
+
+int
+lt_split_name_value (const char *arg, char** name, char** value)
+{
+  const char *p;
+  int len;
+  if (!arg || !*arg)
+    return 1;
+
+  p = strchr (arg, (int)'=');
+
+  if (!p)
+    return 1;
+
+  *value = xstrdup (++p);
+
+  len = strlen (arg) - strlen (*value);
+  *name = XMALLOC (char, len);
+  strncpy (*name, arg, len-1);
+  (*name)[len - 1] = '\0';
+
+  return 0;
+}
+
+void
+lt_opt_process_env_set (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_set_opt, arg);
+    }
+
+  lt_setenv (name, value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_prepend (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_prepend_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 0);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_append (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_append_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 1);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_update_exe_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      /* some systems can't cope with a ':'-terminated path #' */
+      int len = strlen (new_value);
+      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+        {
+          new_value[len-1] = '\0';
+        }
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+void
+lt_update_lib_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_lib_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+
+EOF
+}
+# end: func_emit_cwrapperexe_src
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) deplibs="$deplibs $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  weak_libs="$weak_libs $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  # See comment for -static flag below, for more details.
+	  func_append compile_command " $link_static_flag"
+	  func_append finalize_command " $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname '-L' '' "$arg"
+	dir=$func_stripname_result
+	if test -z "$dir"; then
+	  if test "$#" -gt 0; then
+	    func_fatal_error "require no space between \`-L' and \`$1'"
+	  else
+	    func_fatal_error "need path for \`-L' option"
+	  fi
+	fi
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`$ECHO "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  ::) dllsearchpath=$dir;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) new_inherited_linker_flags="$new_inherited_linker_flags $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # and Darwin in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $wl$func_quote_for_eval_result"
+	  linker_flags="$linker_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -msg_* for osf cc
+      -msg_*)
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -F/path gives path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_duplicate_deps ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  case $lib in
+	  *.la)	func_source "$lib" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+            deplib_base=`$ECHO "X$deplib" | $Xsed -e "$basename"`
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) deplibs="$deplibs $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  if test "$linkmode" = lib; then
+	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
+	  else
+	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
+	  fi
+	  for searchdir in $searchdirs; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    dir=$func_stripname_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"X$deplib\"" 2>/dev/null | $Xsed -e 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		$ECHO
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because the file extensions .$libext of this argument makes me believe"
+		$ECHO "*** that it is just a static archive that I should not use here."
+	      else
+		$ECHO
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "X$inherited_linker_flags" | $Xsed -e 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) new_inherited_linker_flags="$new_inherited_linker_flags $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO "X $dependency_libs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	    tmp_libs=
+	    for deplib in $dependency_libs; do
+	      deplibs="$deplib $deplibs"
+	      if $opt_duplicate_deps ; then
+		case "$tmp_libs " in
+		*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+		esac
+	      fi
+	      tmp_libs="$tmp_libs $deplib"
+	    done
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	    # Keep a list of preopened convenience libraries to check
+	    # that they are being used correctly in the link pass.
+	    test -z "$libdir" && \
+		dlpreconveniencelibs="$dlpreconveniencelibs $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         newlib_search_path="$newlib_search_path $func_stripname_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) temp_rpath="$temp_rpath$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc*)
+	      # No point in relinking DLLs because paths are not encoded
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    $ECHO
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw* | *cegcc*)
+	        func_arith $current - $age
+		major=$func_arith_result
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_verbose "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  $ECHO
+			  $ECHO "*** And there doesn't seem to be a static archive available"
+			  $ECHO "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $ECHO
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** I have the capability to make that library automatically link in when"
+	    $ECHO "*** you link to this library.  But I can only do this if you have a"
+	    $ECHO "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $ECHO "*** But as you try to build a module library, libtool will still create "
+	      $ECHO "*** a static module, that should work as long as the dlopening application"
+	      $ECHO "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$ECHO
+		$ECHO "*** However, this would only work if libtool was able to extract symbol"
+		$ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$ECHO "*** not find such a program.  So, this module is probably useless."
+		$ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      path=
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_dirname "$deplib" "" "."
+		dir="$func_dirname_result"
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                      fi
+		      compiler_flags="$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      linker_flags="$linker_flags -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      if test "$pass" = link; then
+	if test "$linkmode" = "prog"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags "`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	fi
+      fi
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  $ECHO
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows|none)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_minor"
+	    lt_irix_increment=no
+	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  func_arith $current + 1
+	  minor_current=$func_arith_result
+	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  if test "X$lt_irix_increment" = "Xno"; then
+	    func_arith $current - $age
+	  else
+	    func_arith $current - $age + 1
+	  fi
+	  major=$func_arith_result
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    func_arith $revision - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    func_arith $current - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  func_arith $current - $age
+	  major=$func_arith_result
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      libobjs="$libobjs $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext | *.gcno)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "X$lib_search_path " | $Xsed -e "s% $path % %g"`
+      #	deplibs=`$ECHO "X$deplibs " | $Xsed -e "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "X$dependency_libs " | $Xsed -e "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $ECHO
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    $ECHO "*** I have the capability to make that library automatically link in when"
+		    $ECHO "*** you link to this library.  But I can only do this if you have a"
+		    $ECHO "*** shared version of the library, which I believe you do not have"
+		    $ECHO "*** because a test_compile did reveal that the linker did not use it for"
+		    $ECHO "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $ECHO
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      $ECHO "*** I have the capability to make that library automatically link in when"
+		      $ECHO "*** you link to this library.  But I can only do this if you have a"
+		      $ECHO "*** shared version of the library, which you do not appear to have"
+		      $ECHO "*** because a test_compile did reveal that the linker did not use this one"
+		      $ECHO "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $ECHO
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $ECHO "*** make it link in!  You will probably need to install it or some"
+		  $ECHO "*** library that it depends on before this library will be fully"
+		  $ECHO "*** functional.  Installing it before continuing would be even better."
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"X$potent_lib\"" 2>/dev/null | $Xsed -e 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO "X $deplibs" | $Xsed \
+	      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO "X $tmp_deplibs" | $Xsed -e "s,$i,,"`
+	    done
+	  fi
+	  if $ECHO "X $tmp_deplibs" | $Xsed -e 's/[	 ]//g' |
+	     $GREP . >/dev/null; then
+	    $ECHO
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $ECHO "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $ECHO "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $ECHO "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $ECHO
+	    $ECHO "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $ECHO "*** a static module, that should work as long as the dlopening"
+	    $ECHO "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $ECHO
+	      $ECHO "*** However, this would only work if libtool was able to extract symbol"
+	      $ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $ECHO "*** not find such a program.  So, this module is probably useless."
+	      $ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $ECHO "*** The inter-library dependencies that have been dropped here will be"
+	    $ECHO "*** automatically added whenever a program is linked with this library"
+	    $ECHO "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $ECHO
+	      $ECHO "*** Since this library must not contain undefined symbols,"
+	      $ECHO "*** because either the platform does not support them or"
+	      $ECHO "*** it was explicitly requested with -no-undefined,"
+	      $ECHO "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO "X $deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  delfiles="$delfiles $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw* | cegcc*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      func_len " $cmd"
+	      len=$func_len_result
+	      if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_verbose "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    tmp_deplibs="$tmp_deplibs $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   func_len " $test_cmds" &&
+	   len=$func_len_result &&
+	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$ECHO "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_verbose "creating GNU ld script: $output"
+	    $ECHO 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    $ECHO ')' >> $output
+	    delfiles="$delfiles $output"
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_verbose "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    delfiles="$delfiles $output"
+	    output=$firstobj\"$file_list_spec$output\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_verbose "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      eval test_cmds=\"$reload_cmds\"
+	      func_len " $test_cmds"
+	      len0=$func_len_result
+	      len=$len0
+
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		func_len " $obj"
+		func_arith $len + $func_len_result
+		len=$func_arith_result
+		if test "X$objlist" = X ||
+		   test "$len" -lt "$max_cmd_len"; then
+		  func_append objlist " $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj~\$RM $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  func_arith $k + 1
+		  k=$func_arith_result
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=$obj
+		  func_len " $last_robj"
+		  func_arith $len0 + $func_len_result
+		  len=$func_arith_result
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+	      if test -n "$last_robj"; then
+	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	      fi
+	      delfiles="$delfiles $output"
+
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_verbose "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	      if test -n "$last_robj"; then
+		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
+	      fi
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_verbose "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  libobjs="$libobjs $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "X$tmp_whole_archive_flags" | $Xsed -e 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      compile_command="$compile_command ${wl}-bind_at_load"
+	      finalize_command="$finalize_command ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  ::) dllsearchpath=$libdir;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *cegcc)
+        # Disable wrappers for cegcc, we are cross compiling anyway.
+        wrappers_required=no
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      # Now create the wrapper script.
+      func_verbose "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $ECHO for shipping.
+      if test "X$ECHO" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$ECHO "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$ECHO "X$ECHO" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    func_dirname_and_basename "$output" "" "."
+	    output_name=$func_basename_result
+	    output_path=$func_dirname_result
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_cwrapperexe_src > $cwrappersource
+
+	    # The wrapper executable is built using the $host compiler,
+	    # because it contains $host paths and files. If cross-
+	    # compiling, it, like the target executable, must be
+	    # executed on the $host or under an emulation environment.
+	    $opt_dry_run || {
+	      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource
+	      $STRIP $cwrapper
+	    }
+
+	    # Now, create the wrapper script for func_source use:
+	    func_ltwrapper_scriptname $cwrapper
+	    $RM $func_ltwrapper_scriptname_result
+	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
+	    $opt_dry_run || {
+	      # note: this script will not be executed, so do not chmod.
+	      if test "x$build" = "x$host" ; then
+		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
+	      else
+		func_emit_wrapper no > $func_ltwrapper_scriptname_result
+	      fi
+	    }
+	  ;;
+	  * )
+	    $RM $output
+	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_wrapper no > $output
+	    chmod +x $output
+	  ;;
+	esac
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    oldobjs="$oldobjs $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  oldobjs="$oldobjs $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $ECHO "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		func_arith $counter + 1
+		counter=$func_arith_result
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+	eval cmds=\"$old_archive_cmds\"
+
+	func_len " $cmds"
+	len=$func_len_result
+	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_verbose "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  eval test_cmds=\"$old_archive_cmds\"
+	  func_len " $test_cmds"
+	  len0=$func_len_result
+	  len=$len0
+	  for obj in $save_oldobjs
+	  do
+	    func_len " $obj"
+	    func_arith $len + $func_len_result
+	    len=$func_arith_result
+	    func_append objlist " $obj"
+	    if test "$len" -lt "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	      len=$len0
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_verbose "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlfiles="$newdlfiles $libdir/$name"
+		;;
+	      *) newdlfiles="$newdlfiles $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlprefiles="$newdlprefiles $libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$mode" = link || test "$mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) RM="$RM $arg"; rmforce=yes ;;
+      -*) RM="$RM $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      relink_command=
+	      func_source $func_ltwrapper_scriptname_result
+	      rmfiles="$rmfiles $func_ltwrapper_scriptname_result"
+	    else
+	      relink_command=
+	      func_source $dir/$noexename
+	    fi
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$mode" = uninstall || test "$mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
+
Index: b/sieve/missing
===================================================================
--- /dev/null
+++ b/sieve/missing
@@ -0,0 +1,367 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+
+scriptversion=2006-05-10.23
+
+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006
+#   Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+run=:
+sed_output='s/.* --output[ =]\([^ ]*\).*/\1/p'
+sed_minuso='s/.* -o \([^ ]*\).*/\1/p'
+
+# In the cases where this matters, `missing' is being run in the
+# srcdir already.
+if test -f configure.ac; then
+  configure_ac=configure.ac
+else
+  configure_ac=configure.in
+fi
+
+msg="missing on your system"
+
+case $1 in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  "$@" && exit 0
+  # Exit code 63 means version mismatch.  This often happens
+  # when the user try to use an ancient version of a tool on
+  # a file that requires a minimum version.  In this case we
+  # we should proceed has if the program had been absent, or
+  # if --run hadn't been passed.
+  if test $? = 63; then
+    run=:
+    msg="probably too old"
+  fi
+  ;;
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  autom4te     touch the output file, or create a stub one
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+
+Send bug reports to <bug-automake@gnu.org>."
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing $scriptversion (GNU Automake)"
+    exit $?
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+esac
+
+# Now exit if we have it, but it failed.  Also exit now if we
+# don't have it and --version was passed (most likely to detect
+# the program).
+case $1 in
+  lex|yacc)
+    # Not GNU programs, they don't have --version.
+    ;;
+
+  tar)
+    if test -n "$run"; then
+       echo 1>&2 "ERROR: \`tar' requires --run"
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       exit 1
+    fi
+    ;;
+
+  *)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       # Could not run --version or --help.  This is probably someone
+       # running `$TOOL --version' or `$TOOL --help' to check whether
+       # $TOOL exists and not knowing $TOOL uses missing.
+       exit 1
+    fi
+    ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case $1 in
+  aclocal*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`${configure_ac}'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
+    test -z "$files" && files="config.h"
+    touch_files=
+    for f in $files; do
+      case $f in
+      *:*) touch_files="$touch_files "`echo "$f" |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files="$touch_files $f.in";;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch "$f"; done
+    ;;
+
+  autom4te)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, but is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1' as part of \`Autoconf' from any GNU
+         archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo "#! /bin/sh"
+	echo "# Created by GNU Automake missing as a replacement of"
+	echo "#  $ $@"
+	echo "exit 0"
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
+  bison|yacc)
+    echo 1>&2 "\
+WARNING: \`$1' $msg.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    rm -f y.tab.c y.tab.h
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.y)
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.c
+	    fi
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f y.tab.h; then
+	echo >y.tab.h
+    fi
+    if test ! -f y.tab.c; then
+	echo 'main() { return 0; }' >y.tab.c
+    fi
+    ;;
+
+  lex|flex)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site."
+    rm -f lex.yy.c
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.l)
+	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f lex.yy.c; then
+	echo 'main() { return 0; }' >lex.yy.c
+    fi
+    ;;
+
+  help2man)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo ".ab help2man is required to generate this page"
+	exit 1
+    fi
+    ;;
+
+  makeinfo)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    # The file to touch is that specified with -o ...
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -z "$file"; then
+      # ... or it is the one specified with @setfilename ...
+      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '
+	/^@setfilename/{
+	  s/.* \([^ ]*\) *$/\1/
+	  p
+	  q
+	}' $infile`
+      # ... or it is derived from the source name (dir/f.texi becomes f.info)
+      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
+    fi
+    # If the file does not exist, the user really needs makeinfo;
+    # let's fail without touching anything.
+    test -f $file || exit 1
+    touch $file
+    ;;
+
+  tar)
+    shift
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version > /dev/null 2>&1); then
+       gnutar "$@" && exit 0
+    fi
+    if (gtar --version > /dev/null 2>&1); then
+       gtar "$@" && exit 0
+    fi
+    firstarg="$1"
+    if shift; then
+	case $firstarg in
+	*o*)
+	    firstarg=`echo "$firstarg" | sed s/o//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+	case $firstarg in
+	*h*)
+	    firstarg=`echo "$firstarg" | sed s/h//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1>&2 "\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments."
+    exit 1
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequisites for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
Index: b/sieve/src/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/Makefile.am
@@ -0,0 +1,6 @@
+if HAVE_DOVECOT_LIBS
+LIB_DEPEND_DIRS=lib-sieve-tool sieve-tools testsuite
+endif
+
+SUBDIRS = lib-sieve plugins $(LIB_DEPEND_DIRS)
+
Index: b/sieve/src/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/Makefile.in
@@ -0,0 +1,560 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = lib-sieve plugins lib-sieve-tool sieve-tools testsuite
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@HAVE_DOVECOT_LIBS_TRUE@LIB_DEPEND_DIRS = lib-sieve-tool sieve-tools testsuite
+SUBDIRS = lib-sieve plugins $(LIB_DEPEND_DIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
+	install-am install-strip tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve-tool/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve-tool/Makefile.am
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve-tool.la
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-storage/index \
+	-I$(dovecot_incdir)/src/lib-storage/index/raw
+
+libsieve_tool_la_SOURCES = \
+	sieve-tool.c \
+	mail-raw.c
+
+noinst_HEADERS = \
+	sieve-tool.h \
+	mail-raw.h
Index: b/sieve/src/lib-sieve-tool/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve-tool/Makefile.in
@@ -0,0 +1,493 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve-tool
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_tool_la_LIBADD =
+am_libsieve_tool_la_OBJECTS = sieve-tool.lo mail-raw.lo
+libsieve_tool_la_OBJECTS = $(am_libsieve_tool_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_tool_la_SOURCES)
+DIST_SOURCES = $(libsieve_tool_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve-tool.la
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-storage/index \
+	-I$(dovecot_incdir)/src/lib-storage/index/raw
+
+libsieve_tool_la_SOURCES = \
+	sieve-tool.c \
+	mail-raw.c
+
+noinst_HEADERS = \
+	sieve-tool.h \
+	mail-raw.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve-tool/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve-tool/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve-tool.la: $(libsieve_tool_la_OBJECTS) $(libsieve_tool_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_tool_la_OBJECTS) $(libsieve_tool_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mail-raw.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-tool.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve-tool/mail-raw.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve-tool/mail-raw.c
@@ -0,0 +1,284 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: This file was gratefully stolen from dovecot/src/deliver/deliver.c and
+ * altered to suit our needs. So, this contains lots and lots of duplicated
+ * code.
+ */
+
+#include "lib.h"
+#include "istream.h"
+#include "istream-seekable.h"
+#include "fd-set-nonblock.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "strescape.h"
+#include "safe-mkstemp.h"
+#include "close-keep-errno.h"
+#include "mkdir-parents.h"
+#include "message-address.h"
+#include "mbox-from.h"
+#include "raw-storage.h"
+#include "mail-namespace.h"
+
+#include "mail-raw.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Configuration
+ */
+
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/* After buffer grows larger than this, create a temporary file to /tmp
+   where to read the mail. */
+#define MAIL_MAX_MEMORY_BUFFER (1024*128)
+
+static const char *wanted_headers[] = {
+	"From", "Message-ID", "Subject", "Return-Path",
+	NULL
+};
+
+/*
+ * Global data
+ */
+
+static struct mail_namespace *raw_ns;
+static struct mail_user *raw_mail_user;
+
+/*
+ * Raw mail implementation
+ */
+
+static int seekable_fd_callback
+(const char **path_r, void *context ATTR_UNUSED)
+{
+	const char *dir, *p;
+	string_t *path;
+	int fd;
+
+	path = t_str_new(128);
+	str_append(path, "/tmp/dovecot.sieve-tool.");
+	fd = safe_mkstemp(path, 0600, (uid_t)-1, (gid_t)-1);
+	if (fd == -1 && errno == ENOENT) {
+		dir = str_c(path);
+		p = strrchr(dir, '/');
+		if (p != NULL) {
+			dir = t_strdup_until(dir, p);
+			if ( mkdir_parents(dir, 0600) < 0 ) {
+				i_error("mkdir_parents(%s) failed: %m", dir);
+				return -1;
+			}
+			fd = safe_mkstemp(path, 0600, (uid_t)-1, (gid_t)-1);
+		}
+	}
+
+	if (fd == -1) {
+		i_error("safe_mkstemp(%s) failed: %m", str_c(path));
+		return -1;
+	}
+
+	/* we just want the fd, unlink it */
+	if (unlink(str_c(path)) < 0) {
+		/* shouldn't happen.. */
+		i_error("unlink(%s) failed: %m", str_c(path));
+		close_keep_errno(fd);
+		return -1;
+	}
+
+	*path_r = str_c(path);
+	return fd;
+}
+
+static struct istream *create_raw_stream
+(int fd, time_t *mtime_r, const char **sender)
+{
+	struct istream *input, *input2, *input_list[2];
+	const unsigned char *data;
+	size_t i, size;
+	int ret, tz;
+	char *env_sender;
+
+	*mtime_r = (time_t)-1;
+	fd_set_nonblock(fd, FALSE);
+
+	input = i_stream_create_fd(fd, 4096, FALSE);
+	input->blocking = TRUE;
+	/* If input begins with a From-line, drop it */
+	ret = i_stream_read_data(input, &data, &size, 5);
+	if (ret > 0 && size >= 5 && memcmp(data, "From ", 5) == 0) {
+		/* skip until the first LF */
+		i_stream_skip(input, 5);
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			for (i = 0; i < size; i++) {
+				if (data[i] == '\n')
+					break;
+			}
+			if (i != size) {
+				(void)mbox_from_parse(data, i, mtime_r, &tz, &env_sender);
+				i_stream_skip(input, i + 1);
+				break;
+			}
+			i_stream_skip(input, size);
+		}
+	}
+
+	if (sender != NULL) {
+		*sender = t_strdup(env_sender);
+	}
+	i_free(env_sender);
+
+	if (input->v_offset == 0) {
+		input2 = input;
+		i_stream_ref(input2);
+	} else {
+		input2 = i_stream_create_limit(input, (uoff_t)-1);
+	}
+	i_stream_unref(&input);
+
+    input_list[0] = input2; input_list[1] = NULL;
+    input = i_stream_create_seekable(input_list, MAIL_MAX_MEMORY_BUFFER,
+                     seekable_fd_callback, raw_mail_user);
+    i_stream_unref(&input2);
+    return input;
+
+}
+
+/*
+ * Init/Deinit
+ */
+
+void mail_raw_init(const char *user)
+{
+	const char *error;
+
+	raw_mail_user = mail_user_init(user);
+	mail_user_set_home(raw_mail_user, NULL);
+	raw_ns = mail_namespaces_init_empty(raw_mail_user);
+	raw_ns->flags |= NAMESPACE_FLAG_NOQUOTA | NAMESPACE_FLAG_NOACL;
+
+	if ( mail_storage_create(raw_ns, "raw", "/tmp",
+		MAIL_STORAGE_FLAG_FULL_FS_ACCESS,
+		FILE_LOCK_METHOD_FCNTL, &error) < 0 ) {
+ 		i_fatal("Couldn't create internal raw storage: %s", error);
+	}
+}
+
+void mail_raw_deinit(void)
+{
+	mail_user_unref(&raw_mail_user);
+}
+
+
+/*
+ * Open raw mail data
+ */
+
+static struct mail_raw *mail_raw_create
+(struct istream *input, const char *mailfile, const char *sender,
+	time_t mtime)
+{
+	pool_t pool;
+	struct raw_mailbox *raw_box;
+	struct mail_raw *mailr;
+	enum mail_error error;
+
+	if ( mailfile != NULL ) {
+		if ( *mailfile != '/') {
+			char cwd[PATH_MAX];
+
+			/* Expand relative paths */
+			if (getcwd(cwd, sizeof(cwd)) == NULL)
+				i_fatal("getcwd() failed: %m");
+
+			mailfile = t_strconcat(cwd, "/", mailfile, NULL);
+		}
+	}
+
+	pool = pool_alloconly_create("mail_raw", 1024);
+	mailr = p_new(pool, struct mail_raw, 1);
+	mailr->pool = pool;
+
+	if ( mailfile == NULL ) {
+		mailr->box = mailbox_open(&raw_ns->storage, "Dovecot Raw Mail",
+				   input, MAILBOX_OPEN_NO_INDEX_FILES);
+	} else {
+		mtime = (time_t)-1;
+		mailr->box = mailbox_open(&raw_ns->storage, mailfile, NULL,
+				   MAILBOX_OPEN_NO_INDEX_FILES);
+	}
+
+	if ( mailr->box == NULL ) {
+		i_fatal("Can't open mail stream as raw: %s",
+			mail_storage_get_last_error(raw_ns->storage, &error));
+	}
+
+	if ( mailbox_sync(mailr->box, 0, 0, NULL ) < 0) {
+		enum mail_error error;
+
+		i_fatal("Can't sync delivery mail: %s",
+			mail_storage_get_last_error(raw_ns->storage, &error));
+	}
+
+	raw_box = (struct raw_mailbox *)mailr->box;
+	raw_box->envelope_sender = sender != NULL ? sender : DEFAULT_ENVELOPE_SENDER;
+	raw_box->mtime = mtime;
+
+	mailr->trans = mailbox_transaction_begin(mailr->box, 0);
+	mailr->headers_ctx = mailbox_header_lookup_init(mailr->box, wanted_headers);
+	mailr->mail = mail_alloc(mailr->trans, 0, mailr->headers_ctx);
+	mail_set_seq(mailr->mail, 1);
+
+	return mailr;
+}
+
+struct mail_raw *mail_raw_open_data(string_t *mail_data)
+{
+	struct mail_raw *mailr;
+	struct istream *input;
+
+	input = i_stream_create_from_data(str_data(mail_data), str_len(mail_data));
+
+	mailr = mail_raw_create(input, NULL, NULL, (time_t)-1);
+
+	i_stream_unref(&input);
+
+	return mailr;
+}
+
+struct mail_raw *mail_raw_open_file(const char *path)
+{
+	struct mail_raw *mailr;
+	struct istream *input = NULL;
+	time_t mtime;
+	const char *sender = NULL;
+
+	if ( path == NULL || strcmp(path, "-") == 0 ) {
+		path = NULL;
+		input = create_raw_stream(0, &mtime, &sender);
+	}
+
+	mailr = mail_raw_create(input, path, sender, mtime);
+
+	if ( input != NULL )
+		i_stream_unref(&input);
+
+	return mailr;
+}
+
+void mail_raw_close(struct mail_raw *mailr)
+{
+	mailbox_header_lookup_unref(&mailr->headers_ctx);
+
+	mail_free(&mailr->mail);
+	mailbox_transaction_rollback(&mailr->trans);
+	mailbox_close(&mailr->box);
+
+	pool_unref(&mailr->pool);
+}
+
Index: b/sieve/src/lib-sieve-tool/mail-raw.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve-tool/mail-raw.h
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MAIL_RAW_H
+#define __MAIL_RAW_H
+
+struct mail_raw {
+	pool_t pool;
+	struct mail *mail;
+
+	struct mailbox *box;
+	struct mailbox_header_lookup_ctx *headers_ctx;
+	struct mailbox_transaction_context *trans;
+};
+
+void mail_raw_init(const char *user);
+void mail_raw_deinit(void);
+
+struct mail_raw *mail_raw_open_file(const char *path);
+struct mail_raw *mail_raw_open_data(string_t *mail_data);
+void mail_raw_close(struct mail_raw *mailr);
+
+
+#endif /* __MAIL_RAW_H */
Index: b/sieve/src/lib-sieve-tool/sieve-tool.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve-tool/sieve-tool.c
@@ -0,0 +1,217 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "lib-signals.h"
+#include "ioloop.h"
+#include "ostream.h"
+#include "hostpid.h"
+#include "mail-storage.h"
+
+#include "sieve.h"
+#include "sieve-tool.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Global state
+ */
+
+static struct ioloop *ioloop;
+
+/* Sieve instance */
+
+struct sieve_instance *sieve_instance;
+
+/*
+ * Settings management
+ */
+
+const char *sieve_tool_get_setting
+(void *context ATTR_UNUSED, const char *identifier)
+{
+	return getenv(t_str_ucase(identifier));
+}
+
+const char *sieve_tool_get_homedir
+(void *context ATTR_UNUSED)
+{
+	return getenv("HOME");
+}
+
+const struct sieve_callbacks sieve_tool_callbacks = {
+	sieve_tool_get_homedir,
+	sieve_tool_get_setting
+};
+
+/*
+ * Signal handlers
+ */
+
+static void sig_die(const siginfo_t *si, void *context ATTR_UNUSED)
+{
+	/* warn about being killed because of some signal, except SIGINT (^C)
+	 * which is too common at least while testing :)
+	 */
+	if (si->si_signo != SIGINT) {
+		/* FIMXE: strange error for a command line tool */
+		i_warning("Killed with signal %d (by pid=%s uid=%s code=%s)",
+			si->si_signo, dec2str(si->si_pid),
+			dec2str(si->si_uid),
+			lib_signal_code_to_str(si->si_signo, si->si_code));
+	}
+	io_loop_stop(current_ioloop);
+}
+
+/*
+ * Initialization
+ */
+
+void sieve_tool_init(const struct sieve_callbacks *callbacks)
+{
+	lib_init();
+
+	ioloop = io_loop_create();
+
+	lib_signals_init();
+	lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+	lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+	lib_signals_ignore(SIGPIPE, TRUE);
+	lib_signals_ignore(SIGALRM, FALSE);
+
+	if ( callbacks == NULL ) callbacks = &sieve_tool_callbacks;
+
+	if ( (sieve_instance=sieve_init(callbacks, NULL)) == NULL )
+		i_fatal("failed to initialize sieve implementation\n");
+}
+
+void sieve_tool_deinit(void)
+{
+	sieve_deinit(&sieve_instance);
+
+	lib_signals_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+}
+
+/*
+ * Commonly needed functionality
+ */
+
+const char *sieve_tool_get_user(void)
+{
+	const char *user;
+	uid_t process_euid;
+	struct passwd *pw;
+
+	user = getenv("USER");
+
+	if ( user == NULL || *user == '\0' ) {
+		process_euid = geteuid();
+
+		if ((pw = getpwuid(process_euid)) != NULL) {
+			user = t_strdup(pw->pw_name);
+		}
+
+		if ( user == NULL || *user == '\0' ) {
+			i_fatal("couldn't lookup our username (uid=%s)", dec2str(process_euid));
+		}
+	}
+
+	return user;
+}
+
+void sieve_tool_get_envelope_data
+	(struct mail *mail, const char **recipient, const char **sender)
+{
+	/* Get recipient address */
+	if ( *recipient == NULL )
+		(void)mail_get_first_header(mail, "Envelope-To", recipient);
+	if ( *recipient == NULL )
+		(void)mail_get_first_header(mail, "To", recipient);
+	if ( *recipient == NULL )
+		*recipient = "recipient@example.com";
+
+	/* Get sender address */
+	if ( *sender == NULL )
+		(void)mail_get_first_header(mail, "Return-path", sender);
+	if ( *sender == NULL )
+		(void)mail_get_first_header(mail, "Sender", sender);
+	if ( *sender == NULL )
+		(void)mail_get_first_header(mail, "From", sender);
+	if ( *sender == NULL )
+		*sender = "sender@example.com";
+}
+
+/*
+ * Sieve script handling
+ */
+
+struct sieve_binary *sieve_tool_script_compile
+(const char *filename, const char *name)
+{
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	if ( (sbin = sieve_compile(sieve_instance, filename, name, ehandler)) == NULL )
+		i_error("failed to compile sieve script '%s'\n", filename);
+
+	sieve_error_handler_unref(&ehandler);
+
+	return sbin;
+}
+
+struct sieve_binary *sieve_tool_script_open(const char *filename)
+{
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	if ( (sbin = sieve_open(sieve_instance, filename, NULL, ehandler, NULL)) == NULL ) {
+		sieve_error_handler_unref(&ehandler);
+		i_fatal("Failed to compile sieve script\n");
+	}
+
+	sieve_error_handler_unref(&ehandler);
+
+	return sbin;
+}
+
+void sieve_tool_dump_binary_to(struct sieve_binary *sbin, const char *filename)
+{
+	int dfd = -1;
+	struct ostream *dumpstream;
+
+	if ( filename == NULL ) return;
+
+	if ( strcmp(filename, "-") == 0 )
+		dumpstream = o_stream_create_fd(1, 0, FALSE);
+	else {
+		if ( (dfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT, 0600)) < 0 ) {
+			i_fatal("failed to open dump-file for writing: %m");
+		}
+
+		dumpstream = o_stream_create_fd(dfd, 0, FALSE);
+	}
+
+	if ( dumpstream != NULL ) {
+		(void) sieve_dump(sbin, dumpstream);
+		o_stream_destroy(&dumpstream);
+	} else {
+		i_fatal("Failed to create stream for sieve code dump.");
+	}
+
+	if ( dfd != -1 )
+		close(dfd);
+}
+
Index: b/sieve/src/lib-sieve-tool/sieve-tool.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve-tool/sieve-tool.h
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_TOOL_H
+#define __SIEVE_TOOL_H
+
+/* Functionality common to all Sieve command line tools. */
+
+/*
+ * Sieve instance
+ */
+
+struct sieve_instance *sieve_instance;
+
+const char *sieve_tool_get_setting(void *context, const char *identifier);
+const char *sieve_tool_get_homedir(void *context);
+
+const struct sieve_callbacks sieve_tool_callbacks;
+
+/*
+ * Initialization
+ */
+
+void sieve_tool_init(const struct sieve_callbacks *callbacks);
+void sieve_tool_deinit(void);
+
+/*
+ * Commonly needed functionality
+ */
+
+const char *sieve_tool_get_user(void);
+
+void sieve_tool_get_envelope_data
+	(struct mail *mail, const char **recipient, const char **sender);
+
+/*
+ * Sieve script handling
+ */
+
+struct sieve_binary *sieve_tool_script_compile
+	(const char *filename, const char *name);
+struct sieve_binary *sieve_tool_script_open(const char *filename);
+void sieve_tool_dump_binary_to(struct sieve_binary *sbin, const char *filename);
+
+#endif /* __SIEVE_TOOL_H */
Index: b/sieve/src/lib-sieve/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/Makefile.am
@@ -0,0 +1,137 @@
+SUBDIRS = plugins
+
+noinst_LTLIBRARIES = libsieve.la
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-imap
+
+tests = \
+	tst-truefalse.c \
+	tst-not.c \
+	tst-anyof.c \
+	tst-allof.c \
+	tst-address.c \
+	tst-header.c \
+	tst-exists.c \
+	tst-size.c
+
+commands = \
+	cmd-require.c \
+	cmd-stop.c \
+	cmd-if.c \
+	cmd-keep.c \
+	cmd-redirect.c \
+	cmd-discard.c
+
+extensions = \
+	ext-fileinto.c \
+	ext-reject.c \
+	ext-envelope.c \
+	ext-encoded-character.c
+
+match_types = \
+	mcht-is.c \
+	mcht-contains.c \
+	mcht-matches.c
+
+comparators = \
+	cmp-i-octet.c \
+	cmp-i-ascii-casemap.c
+
+if BUILD_UNFINISHED
+unfinished_plugins =
+endif
+
+# These are not actual plugins just yet...
+plugins = \
+	./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+ 	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/notify/libsieve_ext_notify.la \
+	./plugins/environment/libsieve_ext_environment.la \
+	./plugins/mailbox/libsieve_ext_mailbox.la \
+	./plugins/date/libsieve_ext_date.la \
+	$(unfinished_plugins)
+
+libsieve_la_DEPENDENCIES = $(plugins)
+libsieve_la_LIBADD = $(plugins)
+
+libsieve_la_SOURCES = \
+	rfc2822.c \
+	sieve-settings.c \
+	sieve-message.c \
+	sieve-lexer.c \
+	sieve-script.c \
+	sieve-ast.c \
+	sieve-binary.c \
+	sieve-parser.c \
+	sieve-address.c \
+	sieve-validator.c \
+	sieve-generator.c \
+	sieve-interpreter.c \
+	sieve-code-dumper.c \
+	sieve-binary-dumper.c \
+	sieve-result.c \
+	sieve-error.c \
+	sieve-objects.c \
+	sieve-comparators.c \
+	sieve-match-types.c \
+	sieve-address-parts.c \
+	sieve-match.c \
+	sieve-commands.c \
+	sieve-code.c \
+	sieve-actions.c \
+	sieve-extensions.c \
+	$(comparators) \
+	$(match_types) \
+	$(tests) \
+	$(commands) \
+	$(extensions) \
+	sieve.c
+
+noinst_HEADERS = \
+	rfc2822.h \
+	sieve-config.h \
+	sieve-types.h \
+	sieve-common.h \
+	sieve-limits.h \
+	sieve-settings.h \
+	sieve-message.h \
+	sieve-lexer.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve-ast.h \
+	sieve-binary.h \
+	sieve-parser.h \
+	sieve-address.h \
+	sieve-validator.h \
+	sieve-generator.h \
+	sieve-interpreter.h \
+	sieve-code-dumper.h \
+	sieve-binary-dumper.h \
+	sieve-dump.h \
+	sieve-result.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-objects.h \
+	sieve-match.h \
+	sieve-comparators.h \
+	sieve-match-types.h \
+	sieve-address-parts.h \
+	sieve-commands.h \
+	sieve-code.h \
+	sieve-actions.h \
+	sieve-extensions.h \
+	sieve.h
Index: b/sieve/src/lib-sieve/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/Makefile.in
@@ -0,0 +1,839 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = ./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/notify/libsieve_ext_notify.la \
+	./plugins/environment/libsieve_ext_environment.la \
+	./plugins/mailbox/libsieve_ext_mailbox.la \
+	./plugins/date/libsieve_ext_date.la $(am__DEPENDENCIES_1)
+am__objects_1 = cmp-i-octet.lo cmp-i-ascii-casemap.lo
+am__objects_2 = mcht-is.lo mcht-contains.lo mcht-matches.lo
+am__objects_3 = tst-truefalse.lo tst-not.lo tst-anyof.lo tst-allof.lo \
+	tst-address.lo tst-header.lo tst-exists.lo tst-size.lo
+am__objects_4 = cmd-require.lo cmd-stop.lo cmd-if.lo cmd-keep.lo \
+	cmd-redirect.lo cmd-discard.lo
+am__objects_5 = ext-fileinto.lo ext-reject.lo ext-envelope.lo \
+	ext-encoded-character.lo
+am_libsieve_la_OBJECTS = rfc2822.lo sieve-settings.lo sieve-message.lo \
+	sieve-lexer.lo sieve-script.lo sieve-ast.lo sieve-binary.lo \
+	sieve-parser.lo sieve-address.lo sieve-validator.lo \
+	sieve-generator.lo sieve-interpreter.lo sieve-code-dumper.lo \
+	sieve-binary-dumper.lo sieve-result.lo sieve-error.lo \
+	sieve-objects.lo sieve-comparators.lo sieve-match-types.lo \
+	sieve-address-parts.lo sieve-match.lo sieve-commands.lo \
+	sieve-code.lo sieve-actions.lo sieve-extensions.lo \
+	$(am__objects_1) $(am__objects_2) $(am__objects_3) \
+	$(am__objects_4) $(am__objects_5) sieve.lo
+libsieve_la_OBJECTS = $(am_libsieve_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_la_SOURCES)
+DIST_SOURCES = $(libsieve_la_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+HEADERS = $(noinst_HEADERS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = plugins
+noinst_LTLIBRARIES = libsieve.la
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-imap
+
+tests = \
+	tst-truefalse.c \
+	tst-not.c \
+	tst-anyof.c \
+	tst-allof.c \
+	tst-address.c \
+	tst-header.c \
+	tst-exists.c \
+	tst-size.c
+
+commands = \
+	cmd-require.c \
+	cmd-stop.c \
+	cmd-if.c \
+	cmd-keep.c \
+	cmd-redirect.c \
+	cmd-discard.c
+
+extensions = \
+	ext-fileinto.c \
+	ext-reject.c \
+	ext-envelope.c \
+	ext-encoded-character.c
+
+match_types = \
+	mcht-is.c \
+	mcht-contains.c \
+	mcht-matches.c
+
+comparators = \
+	cmp-i-octet.c \
+	cmp-i-ascii-casemap.c
+
+@BUILD_UNFINISHED_TRUE@unfinished_plugins =
+
+# These are not actual plugins just yet...
+plugins = \
+	./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+ 	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/notify/libsieve_ext_notify.la \
+	./plugins/environment/libsieve_ext_environment.la \
+	./plugins/mailbox/libsieve_ext_mailbox.la \
+	./plugins/date/libsieve_ext_date.la \
+	$(unfinished_plugins)
+
+libsieve_la_DEPENDENCIES = $(plugins)
+libsieve_la_LIBADD = $(plugins)
+libsieve_la_SOURCES = \
+	rfc2822.c \
+	sieve-settings.c \
+	sieve-message.c \
+	sieve-lexer.c \
+	sieve-script.c \
+	sieve-ast.c \
+	sieve-binary.c \
+	sieve-parser.c \
+	sieve-address.c \
+	sieve-validator.c \
+	sieve-generator.c \
+	sieve-interpreter.c \
+	sieve-code-dumper.c \
+	sieve-binary-dumper.c \
+	sieve-result.c \
+	sieve-error.c \
+	sieve-objects.c \
+	sieve-comparators.c \
+	sieve-match-types.c \
+	sieve-address-parts.c \
+	sieve-match.c \
+	sieve-commands.c \
+	sieve-code.c \
+	sieve-actions.c \
+	sieve-extensions.c \
+	$(comparators) \
+	$(match_types) \
+	$(tests) \
+	$(commands) \
+	$(extensions) \
+	sieve.c
+
+noinst_HEADERS = \
+	rfc2822.h \
+	sieve-config.h \
+	sieve-types.h \
+	sieve-common.h \
+	sieve-limits.h \
+	sieve-settings.h \
+	sieve-message.h \
+	sieve-lexer.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve-ast.h \
+	sieve-binary.h \
+	sieve-parser.h \
+	sieve-address.h \
+	sieve-validator.h \
+	sieve-generator.h \
+	sieve-interpreter.h \
+	sieve-code-dumper.h \
+	sieve-binary-dumper.h \
+	sieve-dump.h \
+	sieve-result.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-objects.h \
+	sieve-match.h \
+	sieve-comparators.h \
+	sieve-match-types.h \
+	sieve-address-parts.h \
+	sieve-commands.h \
+	sieve-code.h \
+	sieve-actions.h \
+	sieve-extensions.h \
+	sieve.h
+
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve.la: $(libsieve_la_OBJECTS) $(libsieve_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_la_OBJECTS) $(libsieve_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-discard.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-if.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-keep.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-redirect.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-require.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-stop.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmp-i-ascii-casemap.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmp-i-octet.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-encoded-character.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-envelope.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-fileinto.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-reject.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-contains.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-is.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-matches.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rfc2822.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-actions.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-address-parts.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-address.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-ast.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-binary-dumper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-binary.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-code-dumper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-code.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-commands.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-comparators.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-extensions.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-generator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-interpreter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-lexer.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-match-types.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-match.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-message.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-objects.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-parser.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-result.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-script.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-settings.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-validator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-address.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-allof.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-anyof.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-exists.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-header.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-not.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-size.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-truefalse.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
+	install-am install-strip tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	clean-noinstLTLIBRARIES ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/cmd-discard.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmd-discard.c
@@ -0,0 +1,154 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-dump.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/*
+ * Discard command
+ *
+ * Syntax
+ *   discard
+ */
+
+static bool cmd_discard_generate
+	(const struct sieve_codegen_env *cgenv,
+		struct sieve_command *ctx ATTR_UNUSED);
+
+const struct sieve_command_def cmd_discard = {
+	"discard",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_discard_generate,
+	NULL
+};
+
+/*
+ * Discard operation
+ */
+
+static bool cmd_discard_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_discard_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def cmd_discard_operation = {
+	"DISCARD",
+	NULL,
+	SIEVE_OPERATION_DISCARD,
+	cmd_discard_operation_dump,
+	cmd_discard_operation_execute
+};
+
+/*
+ * Discard actions
+ */
+
+static void act_discard_print
+	(const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+static bool act_discard_commit
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+
+const struct sieve_action_def act_discard = {
+	"discard",
+	0,
+	NULL, NULL, NULL,
+	act_discard_print,
+	NULL, NULL,
+	act_discard_commit,
+	NULL
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_discard_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, NULL, &cmd_discard_operation);
+
+	/* Emit line number */
+  sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_discard_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "DISCARD");
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	return sieve_code_dumper_print_optional_operands(denv, address);
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_discard_operation_execute
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	unsigned int source_line;
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "failed to read source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "DISCARD action");
+
+	return ( sieve_result_add_action
+		(renv, NULL, &act_discard, NULL, source_line, NULL, 0) >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static void act_discard_print
+(const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_result_print_env *rpenv, bool *keep)
+{
+	sieve_result_action_printf(rpenv, "discard");
+
+	*keep = FALSE;
+}
+
+static bool act_discard_commit
+(const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv,
+	void *tr_context ATTR_UNUSED, bool *keep)
+{
+	sieve_result_log(aenv,
+		"marked message to be discarded if not explicitly delivered "
+		"(discard action)");
+	*keep = FALSE;
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/cmd-if.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmd-if.c
@@ -0,0 +1,225 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/*
+ * Commands
+ */
+
+/* If command
+ *
+ * Syntax:
+ *   if <test1: test> <block1: block>
+ */
+
+static bool cmd_if_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_if_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_if = {
+	"if",
+	SCT_COMMAND,
+	0, 1, TRUE, TRUE,
+	NULL, NULL,
+	cmd_if_validate,
+	cmd_if_generate,
+	NULL
+};
+
+/* ElsIf command
+ *
+ * Santax:
+ *   elsif <test2: test> <block2: block>
+ */
+
+static bool cmd_elsif_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_elsif = {
+    "elsif",
+	SCT_COMMAND,
+	0, 1, TRUE, TRUE,
+	NULL, NULL,
+	cmd_elsif_validate,
+	cmd_if_generate,
+	NULL
+};
+
+/* Else command
+ *
+ * Syntax:
+ *   else <block>
+ */
+
+static bool cmd_else_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_else = {
+    "else",
+	SCT_COMMAND,
+	0, 0, TRUE, TRUE,
+	NULL, NULL,
+	cmd_elsif_validate,
+	cmd_else_generate,
+	NULL
+};
+
+/*
+ * Context management
+ */
+
+struct cmd_if_context_data {
+	struct cmd_if_context_data *previous;
+	struct cmd_if_context_data *next;
+
+	bool jump_generated;
+	sieve_size_t exit_jump;
+};
+
+static void cmd_if_initialize_context_data
+(struct sieve_command *cmd, struct cmd_if_context_data *previous)
+{
+	struct cmd_if_context_data *cmd_data;
+
+	/* Assign context */
+	cmd_data = p_new(sieve_command_pool(cmd), struct cmd_if_context_data, 1);
+	cmd_data->exit_jump = 0;
+	cmd_data->jump_generated = FALSE;
+
+	/* Update linked list of contexts */
+	cmd_data->previous = previous;
+	cmd_data->next = NULL;
+	if ( previous != NULL )
+		previous->next = cmd_data;
+
+	/* Assign to command context */
+	cmd->data = cmd_data;
+}
+
+/*
+ * Validation
+ */
+
+static bool cmd_if_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd)
+{
+	/* Start if-command structure */
+	cmd_if_initialize_context_data(cmd, NULL);
+
+	return TRUE;
+}
+
+static bool cmd_elsif_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_command *prev = sieve_command_prev(cmd);
+
+	/* Check valid command placement */
+	if ( prev == NULL ||
+		( !sieve_command_is(prev, cmd_if) && !sieve_command_is(prev, cmd_elsif) ) )
+	{
+		sieve_command_validate_error(valdtr, cmd,
+			"the %s command must follow an if or elseif command",
+			sieve_command_identifier(cmd));
+		return FALSE;
+	}
+
+	/* Previous command in this block is 'if' or 'elsif', so we can safely refer
+	 * to its context data
+	 */
+	cmd_if_initialize_context_data(cmd, prev->data);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+/* The if command does not generate specific IF-ELSIF-ELSE opcodes, but only uses
+ * JMP instructions. This is why the implementation of the if command does not
+ * include an opcode implementation.
+ */
+
+static void cmd_if_resolve_exit_jumps
+(struct sieve_binary *sbin, struct cmd_if_context_data *cmd_data)
+{
+	struct cmd_if_context_data *if_ctx = cmd_data->previous;
+
+	/* Iterate backwards through all if-command contexts and resolve the
+	 * exit jumps to the current code position.
+	 */
+	while ( if_ctx != NULL ) {
+		if ( if_ctx->jump_generated )
+			sieve_binary_resolve_offset(sbin, if_ctx->exit_jump);
+		if_ctx = if_ctx->previous;
+	}
+}
+
+static bool cmd_if_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct cmd_if_context_data *cmd_data =
+		(struct cmd_if_context_data *) cmd->data;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist jmplist;
+
+	/* Prepare jumplist */
+	sieve_jumplist_init_temp(&jmplist, sbin);
+
+	/* Generate test condition */
+	test = sieve_ast_test_first(cmd->ast_node);
+	if ( !sieve_generate_test(cgenv, test, &jmplist, FALSE) )
+		return FALSE;
+
+	/* Case true { */
+	if ( !sieve_generate_block(cgenv, cmd->ast_node) )
+		return FALSE;
+
+	/* Are we the final command in this if-elsif-else structure? */
+	if ( cmd_data->next != NULL ) {
+		/* No, generate jump to end of if-elsif-else structure (resolved later)
+		 * This of course is not necessary if the {} block contains a command
+		 * like stop at top level that unconditionally exits the block already
+		 * anyway.
+		 */
+		if ( !sieve_command_block_exits_unconditionally(cmd) ) {
+			sieve_operation_emit(sbin, NULL, &sieve_jmp_operation);
+			cmd_data->exit_jump = sieve_binary_emit_offset(sbin, 0);
+			cmd_data->jump_generated = TRUE;
+		}
+	} else {
+		/* Yes, Resolve previous exit jumps to this point */
+		cmd_if_resolve_exit_jumps(sbin, cmd_data);
+	}
+
+	/* Case false ... (subsequent elsif/else commands might generate more) */
+	sieve_jumplist_resolve(&jmplist);
+
+	return TRUE;
+}
+
+static bool cmd_else_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct cmd_if_context_data *cmd_data =
+		(struct cmd_if_context_data *) cmd->data;
+
+	/* Else { */
+	if ( !sieve_generate_block(cgenv, cmd->ast_node) )
+		return FALSE;
+
+	/* } End: resolve all exit blocks */
+	cmd_if_resolve_exit_jumps(cgenv->sbin, cmd_data);
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/cmd-keep.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmd-keep.c
@@ -0,0 +1,118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-dump.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/*
+ * Keep command
+ *
+ * Syntax:
+ *   keep
+ */
+
+static bool cmd_keep_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_keep = {
+	"keep",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_keep_generate,
+	NULL
+};
+
+/*
+ * Keep operation
+ */
+
+static bool cmd_keep_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_keep_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def cmd_keep_operation = {
+	"KEEP",
+	NULL,
+	SIEVE_OPERATION_KEEP,
+	cmd_keep_operation_dump,
+	cmd_keep_operation_execute
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_keep_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	/* Emit opcode */
+	sieve_operation_emit(cgenv->sbin, NULL, &cmd_keep_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_keep_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "KEEP");
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	return sieve_code_dumper_print_optional_operands(denv, address);
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_keep_operation_execute
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	struct sieve_side_effects_list *slist = NULL;
+	unsigned int source_line;
+	int ret = 0;
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands (side effects only) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	sieve_runtime_trace(renv, "KEEP action");
+
+	/* Add keep action to result.
+	 */
+	ret = sieve_result_add_keep(renv, slist, source_line);
+
+	return ( ret >= 0 );
+}
+
+
Index: b/sieve/src/lib-sieve/cmd-redirect.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmd-redirect.c
@@ -0,0 +1,388 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "istream-crlf.h"
+#include "istream-header-filter.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-address.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+#include <stdio.h>
+
+/*
+ * Configuration
+ */
+
+#define CMD_REDIRECT_DUPLICATE_KEEP (3600 * 24)
+
+/*
+ * Redirect command
+ *
+ * Syntax
+ *   redirect <address: string>
+ */
+
+static bool cmd_redirect_validate
+	(struct sieve_validator *validator, struct sieve_command *cmd);
+static bool cmd_redirect_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_redirect = {
+	"redirect",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_redirect_validate,
+	cmd_redirect_generate,
+	NULL
+};
+
+/*
+ * Redirect operation
+ */
+
+static bool cmd_redirect_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_redirect_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def cmd_redirect_operation = {
+	"REDIRECT",
+	NULL,
+	SIEVE_OPERATION_REDIRECT,
+	cmd_redirect_operation_dump,
+	cmd_redirect_operation_execute
+};
+
+/*
+ * Redirect action
+ */
+
+static bool act_redirect_equals
+	(const struct sieve_script_env *senv, const struct sieve_action *act1,
+		const struct sieve_action *act2);
+static int act_redirect_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+static void act_redirect_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		bool *keep);
+static bool act_redirect_commit
+	(const struct sieve_action *action, const struct sieve_action_exec_env *aenv,
+		void *tr_context, bool *keep);
+
+const struct sieve_action_def act_redirect = {
+	"redirect",
+	SIEVE_ACTFLAG_TRIES_DELIVER,
+	act_redirect_equals,
+	act_redirect_check_duplicate,
+	NULL,
+	act_redirect_print,
+	NULL, NULL,
+	act_redirect_commit,
+	NULL
+};
+
+struct act_redirect_context {
+	const char *to_address;
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_redirect_validate
+(struct sieve_validator *validator, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	/* Check and activate address argument */
+
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "address", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+
+	/* We can only assess the validity of the outgoing address when it is
+	 * a string literal. For runtime-generated strings this needs to be
+	 * done at runtime (FIXME!)
+     */
+	if ( sieve_argument_is_string_literal(arg) ) {
+		string_t *address = sieve_ast_argument_str(arg);
+		const char *error;
+		const char *norm_address;
+
+		T_BEGIN {
+			/* Verify and normalize the address to 'local_part@domain' */
+			norm_address = sieve_address_normalize(address, &error);
+
+			if ( norm_address == NULL ) {
+				sieve_argument_validate_error(validator, arg,
+					"specified redirect address '%s' is invalid: %s",
+					str_sanitize(str_c(address),128), error);
+			} else {
+				/* Replace string literal in AST */
+				sieve_ast_argument_string_setc(arg, norm_address);
+			}
+		} T_END;
+
+		return ( norm_address != NULL );
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_redirect_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, NULL,  &cmd_redirect_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_redirect_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "REDIRECT");
+	sieve_code_descend(denv);
+
+	/* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) )
+		return FALSE;
+
+	return sieve_opr_string_dump(denv, address, "reason");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_redirect_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_instance *svinst = renv->svinst;
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_redirect_context *act;
+	string_t *redirect;
+	unsigned int source_line;
+	pool_t pool;
+	int ret = 0;
+
+	/* Source line */
+    if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands (side effects) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	/* Read the address */
+	if ( !sieve_opr_string_read(renv, address, &redirect) ) {
+		sieve_runtime_trace_error(renv, "invalid address string");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* FIXME: perform address normalization if the string is not a string literal
+	 */
+
+	sieve_runtime_trace(renv, "REDIRECT action (\"%s\")",
+		str_sanitize(str_c(redirect), 64));
+
+	/* Add redirect action to the result */
+
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_redirect_context, 1);
+	act->to_address = p_strdup(pool, str_c(redirect));
+
+	ret = sieve_result_add_action
+		(renv, NULL, &act_redirect, slist, source_line, (void *) act,
+			svinst->max_redirects);
+
+	return ( ret >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static bool act_redirect_equals
+(const struct sieve_script_env *senv ATTR_UNUSED,
+	const struct sieve_action *act1, const struct sieve_action *act2)
+{
+	struct act_redirect_context *rd_ctx1 =
+		(struct act_redirect_context *) act1->context;
+	struct act_redirect_context *rd_ctx2 =
+		(struct act_redirect_context *) act2->context;
+
+	/* Address is already normalized */
+	return ( sieve_address_compare
+		(rd_ctx1->to_address, rd_ctx2->to_address, TRUE) == 0 );
+}
+
+static int act_redirect_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action *act,
+	const struct sieve_action *act_other)
+{
+	return ( act_redirect_equals(renv->scriptenv, act, act_other) ? 1 : 0 );
+}
+
+static void act_redirect_print
+(const struct sieve_action *action,
+	const struct sieve_result_print_env *rpenv, bool *keep)
+{
+	struct act_redirect_context *ctx =
+		(struct act_redirect_context *) action->context;
+
+	sieve_result_action_printf(rpenv, "redirect message to: %s",
+		str_sanitize(ctx->to_address, 128));
+
+	*keep = FALSE;
+}
+
+static bool act_redirect_send
+(const struct sieve_action_exec_env *aenv, struct act_redirect_context *ctx)
+{
+	static const char *hide_headers[] = { "Return-Path", "X-Sieve" };
+
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const char *sender = sieve_message_get_sender(aenv->msgctx);
+	struct istream *input, *crlf_input;
+	void *smtp_handle;
+	FILE *f;
+	const unsigned char *data;
+	size_t size;
+	int ret;
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "redirect action has no means to send mail.");
+		return TRUE;
+	}
+
+	if (mail_get_stream(msgdata->mail, NULL, NULL, &input) < 0)
+		return FALSE;
+
+	/* Open SMTP transport */
+	smtp_handle = senv->smtp_open(ctx->to_address, sender, &f);
+
+	/* Remove unwanted headers */
+	input = i_stream_create_header_filter
+		(input, HEADER_FILTER_EXCLUDE, hide_headers,
+			N_ELEMENTS(hide_headers), null_header_filter_callback, NULL);
+
+	/* Make sure the message contains CRLF consistently */
+	crlf_input = i_stream_create_crlf(input);
+
+	/* Prepend sieve version header (should not affect signatures) */
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+
+	/* Pipe the message to the outgoing SMTP transport */
+	while ((ret = i_stream_read_data(crlf_input, &data, &size, 0)) > 0) {
+		if (fwrite(data, size, 1, f) == 0)
+			break;
+		i_stream_skip(crlf_input, size);
+	}
+
+	i_stream_unref(&crlf_input);
+	i_stream_unref(&input);
+
+	/* Close SMTP transport */
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv,
+			"failed to redirect message to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(ctx->to_address, 80));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool act_redirect_commit
+(const struct sieve_action *action,
+	const struct sieve_action_exec_env *aenv, void *tr_context ATTR_UNUSED,
+	bool *keep)
+{
+	struct act_redirect_context *ctx =
+		(struct act_redirect_context *) action->context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const char *dupeid;
+
+	/* Prevent mail loops if possible */
+	dupeid = msgdata->id == NULL ?
+		NULL : t_strdup_printf("%s-%s", msgdata->id, ctx->to_address);
+	if (dupeid != NULL) {
+		/* Check whether we've seen this message before */
+		if (senv->duplicate_check(dupeid, strlen(dupeid), senv->username)) {
+			sieve_result_log(aenv, "discarded duplicate forward to <%s>",
+				str_sanitize(ctx->to_address, 128));
+			return TRUE;
+		}
+	}
+
+	/* Try to forward the message */
+	if ( act_redirect_send(aenv, ctx) ) {
+
+		/* Mark this message id as forwarded to the specified destination */
+		if (dupeid != NULL) {
+			senv->duplicate_mark(dupeid, strlen(dupeid), senv->username,
+				ioloop_time + CMD_REDIRECT_DUPLICATE_KEEP);
+		}
+
+		sieve_result_log(aenv, "forwarded to <%s>",
+			str_sanitize(ctx->to_address, 128));
+
+		/* Indicate that message was successfully forwarded */
+		aenv->exec_status->message_forwarded = TRUE;
+
+		/* Cancel implicit keep */
+		*keep = FALSE;
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
Index: b/sieve/src/lib-sieve/cmd-require.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmd-require.c
@@ -0,0 +1,85 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+
+/*
+ * Require command
+ *
+ * Syntax
+ *   Syntax: require <capabilities: string-list>
+ */
+
+static bool cmd_require_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_require = {
+	"require",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_require_validate,
+	NULL, NULL
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_require_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	bool result = TRUE;
+	struct sieve_ast_argument *arg;
+	struct sieve_command *prev = sieve_command_prev(cmd);
+
+	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) ||
+		( !sieve_command_is_first(cmd) && prev != NULL &&
+			!sieve_command_is(prev, cmd_require) ) )
+	{
+		sieve_command_validate_error(valdtr, cmd,
+			"require commands can only be placed at top level "
+			"at the beginning of the file");
+		return FALSE;
+	}
+
+	/* Check argument and load specified extension(s) */
+
+	arg = cmd->first_positional;
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		const struct sieve_extension *ext = sieve_validator_extension_load
+			(valdtr, cmd, arg, sieve_ast_argument_str(arg));
+
+		if ( ext == NULL ) result = FALSE;
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+
+		while ( stritem != NULL ) {
+			const struct sieve_extension *ext = sieve_validator_extension_load
+				(valdtr, cmd, stritem, sieve_ast_strlist_str(stritem));
+
+			if ( ext == NULL ) result = FALSE;
+
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		/* Something else */
+		sieve_argument_validate_error(valdtr, arg,
+			"the require command accepts a single string or string list argument, "
+			"but %s was found",
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+
+	return result;
+}
Index: b/sieve/src/lib-sieve/cmd-stop.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmd-stop.c
@@ -0,0 +1,86 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+/*
+ * Stop command
+ *
+ * Syntax
+ *   stop
+ */
+
+static bool cmd_stop_generate
+	(const struct sieve_codegen_env *cgenv,
+		struct sieve_command *ctx ATTR_UNUSED);
+static bool cmd_stop_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_stop = {
+	"stop",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_stop_validate,
+	cmd_stop_generate,
+	NULL
+};
+
+/*
+ * Stop operation
+ */
+
+static int opc_stop_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def cmd_stop_operation = {
+	"STOP",
+	NULL,
+	SIEVE_OPERATION_STOP,
+	NULL,
+	opc_stop_execute
+};
+
+/*
+ * Command validation
+ */
+
+static bool cmd_stop_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd)
+{
+	sieve_command_exit_block_unconditionally(cmd);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_stop_generate
+(const struct sieve_codegen_env *cgenv,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	sieve_operation_emit(cgenv->sbin, NULL, &cmd_stop_operation);
+
+	return TRUE;
+}
+
+/*
+ * Code execution
+ */
+
+static int opc_stop_execute
+(const struct sieve_runtime_env *renv,  sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_runtime_trace(renv, "STOP");
+
+	sieve_interpreter_interrupt(renv->interp);
+
+	return SIEVE_EXEC_OK;
+}
+
Index: b/sieve/src/lib-sieve/cmp-i-ascii-casemap.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmp-i-ascii-casemap.c
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Comparator 'i;ascii-casemap':
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+
+/*
+ * Forward declarations
+ */
+
+static int cmp_i_ascii_casemap_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+static bool cmp_i_ascii_casemap_char_match
+	(const struct sieve_comparator *cmp, const char **val1, const char *val1_end,
+		const char **val2, const char *val2_end);
+
+/*
+ * Comparator object
+ */
+
+const struct sieve_comparator_def i_ascii_casemap_comparator = {
+	SIEVE_OBJECT
+		("i;ascii-casemap", &comparator_operand, SIEVE_COMPARATOR_I_ASCII_CASEMAP),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY |
+		SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH | SIEVE_COMPARATOR_FLAG_PREFIX_MATCH,
+	cmp_i_ascii_casemap_compare,
+	cmp_i_ascii_casemap_char_match,
+	sieve_comparator_octet_skip
+};
+
+/*
+ * Comparator implementation
+ */
+
+static int cmp_i_ascii_casemap_compare(
+	const struct sieve_comparator *cmp ATTR_UNUSED,
+	const char *val1, size_t val1_size, const char *val2, size_t val2_size)
+{
+	int result;
+
+	if ( val1_size == val2_size ) {
+		return strncasecmp(val1, val2, val1_size);
+	}
+
+	if ( val1_size > val2_size ) {
+		result = strncasecmp(val1, val2, val2_size);
+
+		if ( result == 0 ) return 1;
+
+		return result;
+	}
+
+	result = strncasecmp(val1, val2, val1_size);
+
+	if ( result == 0 ) return -1;
+
+	return result;
+}
+
+static bool cmp_i_ascii_casemap_char_match
+	(const struct sieve_comparator *cmp ATTR_UNUSED,
+		const char **val, const char *val_end,
+		const char **key, const char *key_end)
+{
+	const char *val_begin = *val;
+	const char *key_begin = *key;
+
+	while ( i_tolower(**val) == i_tolower(**key) &&
+		*val < val_end && *key < key_end ) {
+		(*val)++;
+		(*key)++;
+	}
+
+	if ( *key < key_end ) {
+		/* Reset */
+		*val = val_begin;
+		*key = key_begin;
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/cmp-i-octet.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/cmp-i-octet.c
@@ -0,0 +1,93 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Comparator 'i;octet':
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int cmp_i_octet_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+static bool cmp_i_octet_char_match
+	(const struct sieve_comparator *cmp, const char **val1, const char *val1_end,
+		const char **val2, const char *val2_end);
+
+/*
+ * Comparator object
+ */
+
+const struct sieve_comparator_def i_octet_comparator = {
+	SIEVE_OBJECT("i;octet",	&comparator_operand, SIEVE_COMPARATOR_I_OCTET),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY |
+		SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH | SIEVE_COMPARATOR_FLAG_PREFIX_MATCH,
+	cmp_i_octet_compare,
+	cmp_i_octet_char_match,
+	sieve_comparator_octet_skip
+};
+
+/*
+ * Comparator implementation
+ */
+
+static int cmp_i_octet_compare(
+	const struct sieve_comparator *cmp ATTR_UNUSED,
+	const char *val1, size_t val1_size, const char *val2, size_t val2_size)
+{
+	int result;
+
+	if ( val1_size == val2_size ) {
+		return memcmp((void *) val1, (void *) val2, val1_size);
+	}
+
+	if ( val1_size > val2_size ) {
+		result = memcmp((void *) val1, (void *) val2, val2_size);
+
+		if ( result == 0 ) return 1;
+
+		return result;
+	}
+
+	result = memcmp((void *) val1, (void *) val2, val1_size);
+
+	if ( result == 0 ) return -1;
+
+	return result;
+}
+
+static bool cmp_i_octet_char_match
+	(const struct sieve_comparator *cmp ATTR_UNUSED,
+		const char **val, const char *val_end,
+		const char **key, const char *key_end)
+{
+	const char *val_begin = *val;
+	const char *key_begin = *key;
+
+	while ( **val == **key && *val < val_end && *key < key_end ) {
+		(*val)++;
+		(*key)++;
+	}
+
+	if ( *key < key_end ) {
+		/* Reset */
+		*val = val_begin;
+		*key = key_begin;
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/ext-encoded-character.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/ext-encoded-character.c
@@ -0,0 +1,277 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension encoded-character
+ * ---------------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+
+#include <ctype.h>
+
+/*
+ * Extension
+ */
+
+static bool ext_encoded_character_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+struct sieve_extension_def encoded_character_extension = {
+	"encoded-character",
+	NULL, NULL,
+	ext_encoded_character_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/*
+ * Encoded string argument
+ */
+
+bool arg_encoded_string_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *context);
+
+const struct sieve_argument_def encoded_string_argument = {
+	"@encoded-string",
+	NULL,
+	arg_encoded_string_validate,
+	NULL, NULL, NULL
+};
+
+/* Parsing */
+
+static bool _skip_whitespace
+	(const char **in, const char *inend)
+{
+	while ( *in < inend ) {
+		if ( **in == '\r' ) {
+			(*in)++;
+			if ( **in != '\n' )
+				return FALSE;
+			continue;
+		}
+
+		/* (Loose LF is non-standard) */
+		if ( **in != ' ' && **in != '\n' && **in != '\t' )
+			break;
+
+		(*in)++;
+	}
+
+	return TRUE;
+}
+
+static bool _parse_hexint
+(const char **in, const char *inend, int max_digits, unsigned int *result)
+{
+	int digit = 0;
+	*result = 0;
+
+	while ( *in < inend && (max_digits == 0 || digit < max_digits) ) {
+
+		if ( (**in) >= '0' && (**in) <= '9' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) '0');
+		else if ( (**in) >= 'a' && (**in) <= 'f' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) 'a') + 0x0a;
+		else if ( (**in) >= 'A' && (**in) <= 'F' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) 'A') + 0x0a;
+		else
+			return ( digit > 0 );
+
+		(*in)++;
+		digit++;
+	}
+
+	if ( digit == max_digits ) {
+		/* Hex digit _MUST_ end here */
+		if ( (**in >= '0' && **in <= '9')	|| (**in >= 'a' && **in <= 'f') ||
+			(**in >= 'A' && **in <= 'F') )
+			return FALSE;
+
+		return TRUE;
+	}
+
+	return ( digit > 0 );
+}
+
+static bool _decode_hex
+(const char **in, const char *inend, string_t *result)
+{
+	int values = 0;
+
+	while ( *in < inend ) {
+		unsigned int hexpair;
+
+		if ( !_skip_whitespace(in, inend) ) return FALSE;
+
+		if ( !_parse_hexint(in, inend, 2, &hexpair) ) break;
+
+		str_append_c(result, (unsigned char) hexpair);
+		values++;
+	}
+
+	return ( values > 0 );
+}
+
+static int _decode_unicode
+(const char **in, const char *inend, string_t *result, unsigned int *error_hex)
+{
+	int values = 0;
+	bool valid = TRUE;
+
+	while ( *in < inend ) {
+		unsigned int unicode_hex;
+
+		if ( !_skip_whitespace(in, inend) ) return FALSE;
+
+		if ( !_parse_hexint(in, inend, 0, &unicode_hex) ) break;
+
+		if ( (unicode_hex <= 0xD7FF) ||
+			(unicode_hex >= 0xE000 && unicode_hex <= 0x10FFFF)	)
+			uni_ucs4_to_utf8_c((unichar_t) unicode_hex, result);
+		else {
+			if ( valid ) *error_hex = unicode_hex;
+			valid = FALSE;
+		}
+		values++;
+	}
+
+	return ( values > 0 );
+}
+
+bool arg_encoded_string_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd)
+{
+	bool result = TRUE;
+	enum { ST_NONE, ST_OPEN, ST_TYPE, ST_CLOSE }
+		state = ST_NONE;
+	string_t *str = sieve_ast_argument_str(*arg);
+	string_t *tmpstr, *newstr = NULL;
+	const char *p, *mark, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	unsigned int error_hex = 0;
+
+	T_BEGIN {
+		tmpstr = t_str_new(32);
+
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+			/* Normal string */
+			case ST_NONE:
+				if ( *p == '$' ) {
+					substart = p;
+					state = ST_OPEN;
+				}
+				p++;
+				break;
+			/* Parsed '$' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_TYPE;
+					p++;
+				} else
+					state = ST_NONE;
+				break;
+			/* Parsed '${' */
+			case ST_TYPE:
+				mark = p;
+				/* Scan for 'hex' or 'unicode' */
+				while ( p < strend && i_isalpha(*p) ) p++;
+
+				if ( *p != ':' ) {
+					state = ST_NONE;
+					break;
+				}
+
+				state = ST_CLOSE;
+
+				str_truncate(tmpstr, 0);
+				if ( strncasecmp(mark, "hex", p - mark) == 0 ) {
+					/* Hexadecimal */
+					p++;
+					if ( !_decode_hex(&p, strend, tmpstr) )
+						state = ST_NONE;
+				} else if ( strncasecmp(mark, "unicode", p - mark) == 0 ) {
+					/* Unicode */
+					p++;
+					if ( !_decode_unicode(&p, strend, tmpstr, &error_hex) )
+						state = ST_NONE;
+				} else {
+					/* Invalid encoding */
+					p++;
+					state = ST_NONE;
+				}
+				break;
+			case ST_CLOSE:
+				if ( *p == '}' ) {
+					/* We now know that the substitution is valid */
+
+					if ( error_hex != 0 ) {
+						sieve_argument_validate_error(valdtr, *arg,
+							"invalid unicode character 0x%08x in encoded character substitution",
+							error_hex);
+						result = FALSE;
+						break;
+					}
+
+					if ( newstr == NULL ) {
+						newstr = str_new(sieve_ast_pool((*arg)->ast), str_len(str)*2);
+					}
+
+					str_append_n(newstr, strstart, substart-strstart);
+					str_append_str(newstr, tmpstr);
+
+					strstart = p + 1;
+					substart = strstart;
+
+					p++;
+				}
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	if ( !result ) return FALSE;
+
+	if ( newstr != NULL ) {
+		if ( strstart != strend )
+			str_append_n(newstr, strstart, strend-strstart);
+
+		sieve_ast_argument_string_set(*arg, newstr);
+	}
+
+	/* Pass the processed string to a (possible) next layer of processing */
+	return sieve_validator_argument_activate_super
+		(valdtr, cmd, *arg, TRUE);
+}
+
+/*
+ * Extension implementation
+ */
+
+static bool ext_encoded_character_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Override the constant string argument with our own */
+	sieve_validator_argument_override
+		(valdtr, SAT_CONST_STRING, ext, &encoded_string_argument);
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/ext-envelope.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/ext-envelope.c
@@ -0,0 +1,530 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension envelope
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-message.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_command_def envelope_test;
+const struct sieve_operation_def envelope_operation;
+const struct sieve_extension_def envelope_extension;
+
+/*
+ * Extension
+ */
+
+static bool ext_envelope_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def envelope_extension = {
+	"envelope",
+	NULL, NULL,
+	ext_envelope_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(envelope_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_envelope_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new test */
+	sieve_validator_register_command(valdtr, ext, &envelope_test);
+
+	return TRUE;
+}
+
+/*
+ * Envelope test
+ *
+ * Syntax
+ *   envelope [COMPARATOR] [ADDRESS-PART] [MATCH-TYPE]
+ *     <envelope-part: string-list> <key-list: string-list>
+ */
+
+static bool tst_envelope_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_envelope_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_envelope_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+static const struct sieve_command_def envelope_test = {
+	"envelope",
+	SCT_TEST,
+	2, 0, FALSE, FALSE,
+	tst_envelope_registered,
+	NULL,
+	tst_envelope_validate,
+	tst_envelope_generate,
+	NULL
+};
+
+/*
+ * Envelope operation
+ */
+
+static bool ext_envelope_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_envelope_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def envelope_operation = {
+	"ENVELOPE",
+	&envelope_extension,
+	0,
+	ext_envelope_operation_dump,
+	ext_envelope_operation_execute
+};
+
+/*
+ * Envelope parts
+ *
+ * FIXME: not available to extensions
+ */
+
+struct sieve_envelope_part {
+	const char *identifier;
+
+	const struct sieve_address *const *(*get_addresses)
+		(const struct sieve_runtime_env *renv);
+	const char * const *(*get_values)
+		(const struct sieve_runtime_env *renv);
+};
+
+static const struct sieve_address *const *_from_part_get_addresses
+	(const struct sieve_runtime_env *renv);
+static const char *const *_from_part_get_values
+	(const struct sieve_runtime_env *renv);
+static const struct sieve_address *const *_to_part_get_addresses
+	(const struct sieve_runtime_env *renv);
+static const char *const *_to_part_get_values
+	(const struct sieve_runtime_env *renv);
+static const char *const *_auth_part_get_values
+	(const struct sieve_runtime_env *renv);
+
+static const struct sieve_envelope_part _from_part = {
+	"from",
+	_from_part_get_addresses,
+	_from_part_get_values,
+};
+
+static const struct sieve_envelope_part _to_part = {
+	"to",
+	_to_part_get_addresses,
+	_to_part_get_values,
+};
+
+static const struct sieve_envelope_part _auth_part = {
+	"auth",
+	NULL,
+	_auth_part_get_values,
+};
+
+static const struct sieve_envelope_part *_envelope_parts[] = {
+	/* Required */
+	&_from_part, &_to_part,
+
+	/* Non-standard */
+	&_auth_part
+};
+
+static unsigned int _envelope_part_count = N_ELEMENTS(_envelope_parts);
+
+static const struct sieve_envelope_part *_envelope_part_find
+(const char *identifier)
+{
+	unsigned int i;
+
+	for ( i = 0; i < _envelope_part_count; i++ ) {
+		if ( strcasecmp( _envelope_parts[i]->identifier, identifier ) == 0 ) {
+			return _envelope_parts[i];
+        }
+	}
+
+	return NULL;
+}
+
+
+/*
+ * Command Registration
+ */
+
+static bool tst_envelope_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_AM_OPT_COMPARATOR);
+	sieve_address_parts_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_ADDRESS_PART);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static int _envelope_part_is_supported
+(void *context, struct sieve_ast_argument *arg)
+{
+	const struct sieve_envelope_part **not_address =
+		(const struct sieve_envelope_part **) context;
+
+	if ( sieve_argument_is_string_literal(arg) ) {
+		const struct sieve_envelope_part *epart;
+
+		if ( (epart=_envelope_part_find(sieve_ast_strlist_strc(arg))) != NULL ) {
+			if ( epart->get_addresses == NULL ) {
+				if ( *not_address == NULL )
+					*not_address = epart;
+			}
+
+			return TRUE;
+		}
+
+		return FALSE;
+	}
+
+	return TRUE; /* Can't check at compile time */
+}
+
+static bool tst_envelope_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_ast_argument *epart;
+	struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_envelope_part *not_address = NULL;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "envelope part", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Check whether supplied envelope parts are supported
+	 *   FIXME: verify dynamic envelope parts at runtime
+	 */
+	epart = arg;
+	if ( !sieve_ast_stringlist_map(&epart, (void *) &not_address,
+		_envelope_part_is_supported) ) {
+
+		sieve_argument_validate_error(valdtr, epart,
+			"specified envelope part '%s' is not supported by the envelope test",
+				str_sanitize(sieve_ast_strlist_strc(epart), 64));
+		return FALSE;
+	}
+
+	if ( not_address != NULL ) {
+		struct sieve_ast_argument *addrp_arg =
+			sieve_command_find_argument(tst, &address_part_tag);
+
+		if ( addrp_arg != NULL ) {
+			sieve_argument_validate_error(valdtr, addrp_arg,
+				"address part ':%s' specified while non-address envelope part '%s' "
+				"is tested with the envelope test",
+                sieve_ast_argument_tag(addrp_arg), not_address->identifier);
+	        return FALSE;
+		}
+	}
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_envelope_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	(void)sieve_operation_emit(cgenv->sbin, cmd->ext, &envelope_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool ext_envelope_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "ENVELOPE");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_addrmatch_default_dump_optionals(denv, address) )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "envelope part") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static const struct sieve_address *const *_from_part_get_addresses
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const struct sieve_address *);
+	const struct sieve_address *address =
+		sieve_message_get_sender_address(renv->msgctx);
+
+	if ( address != NULL ) {
+		t_array_init(&envelope_values, 2);
+
+        array_append(&envelope_values, &address, 1);
+
+	    (void)array_append_space(&envelope_values);
+    	return array_idx(&envelope_values, 0);
+	}
+
+	return NULL;
+}
+
+static const char *const *_from_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->return_path != NULL ) {
+        array_append(&envelope_values, &renv->msgdata->return_path, 1);
+	}
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+static const struct sieve_address *const *_to_part_get_addresses
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const struct sieve_address *);
+	const struct sieve_address *address =
+		sieve_message_get_recipient_address(renv->msgctx);
+
+	if ( address != NULL && address->local_part != NULL ) {
+		t_array_init(&envelope_values, 2);
+
+        array_append(&envelope_values, &address, 1);
+
+	    (void)array_append_space(&envelope_values);
+    	return array_idx(&envelope_values, 0);
+	}
+
+	return NULL;
+}
+
+static const char *const *_to_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->to_address != NULL ) {
+        array_append(&envelope_values, &renv->msgdata->to_address, 1);
+	}
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+
+static const char *const *_auth_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->auth_user != NULL )
+        array_append(&envelope_values, &renv->msgdata->auth_user, 1);
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+static int ext_envelope_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_address_part addrp =
+		SIEVE_ADDRESS_PART_DEFAULT(all_address_part);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *envp_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *envp_item;
+	bool matched;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+
+	sieve_runtime_trace(renv, "ENVELOPE test");
+
+	if ( (ret=sieve_addrmatch_default_get_optionals
+		(renv, address, &addrp, &mcht, &cmp)) <= 0 )
+		return ret;
+
+	/* Read envelope-part */
+	if ( (envp_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid envelope-part operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+	/* Iterate through all requested headers to match */
+	envp_item = NULL;
+	matched = FALSE;
+	while ( result && !matched &&
+		(result=sieve_coded_stringlist_next_item(envp_list, &envp_item))
+		&& envp_item != NULL ) {
+		const struct sieve_envelope_part *epart;
+
+		if ( (epart=_envelope_part_find(str_c(envp_item))) != NULL ) {
+			const struct sieve_address * const *addresses = NULL;
+			int i;
+
+			if ( epart->get_addresses != NULL ) {
+				/* Field contains addresses */
+				addresses = epart->get_addresses(renv);
+
+				if ( addresses != NULL ) {
+					for ( i = 0; !matched && addresses[i] != NULL; i++ ) {
+						if ( addresses[i]->local_part == NULL ) {
+							/* Null path <> */
+							ret = sieve_match_value(mctx, "", 0);
+						} else {
+							const char *part = NULL;
+
+							if ( addrp.def != NULL && addrp.def->extract_from	!= NULL )
+								part = addrp.def->extract_from(&addrp, addresses[i]);
+
+							if ( part != NULL )
+								ret = sieve_match_value(mctx, part, strlen(part));
+							else
+								ret = 0;
+						}
+
+						if ( ret < 0 ) {
+							result = FALSE;
+							break;
+						}
+
+						matched = ret > 0;
+					}
+				}
+			}
+
+			if ( epart->get_values != NULL && addresses == NULL &&
+				sieve_address_part_is(&addrp, all_address_part) ) {
+				/* Field contains something else */
+				const char *const *values = epart->get_values(renv);
+
+				if ( values == NULL ) continue;
+
+				for ( i = 0; !matched && values[i] != NULL; i++ ) {
+
+					if ( (ret=sieve_match_value
+						(mctx, values[i], strlen(values[i]))) < 0 ) {
+						result = FALSE;
+						break;
+					}
+
+					matched = ret > 0;
+				}
+			}
+		}
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	if ( result ) {
+		/* Set test result for subsequent conditional jump */
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
Index: b/sieve/src/lib-sieve/ext-fileinto.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/ext-fileinto.c
@@ -0,0 +1,208 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension fileinto
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "imap-utf7.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_command_def fileinto_command;
+const struct sieve_operation_def fileinto_operation;
+const struct sieve_extension_def fileinto_extension;
+
+/*
+ * Extension
+ */
+
+static bool ext_fileinto_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def fileinto_extension = {
+	"fileinto",
+	NULL, NULL,
+	ext_fileinto_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(fileinto_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_fileinto_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new command */
+	sieve_validator_register_command(valdtr, ext, &fileinto_command);
+
+	return TRUE;
+}
+
+/*
+ * Fileinto command
+ *
+ * Syntax:
+ *   fileinto <folder: string>
+ */
+
+static bool cmd_fileinto_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_fileinto_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+static const struct sieve_command_def fileinto_command = {
+	"fileinto",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_fileinto_validate,
+	cmd_fileinto_generate,
+	NULL
+};
+
+/*
+ * Fileinto operation
+ */
+
+static bool ext_fileinto_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_fileinto_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def fileinto_operation = {
+	"FILEINTO",
+	&fileinto_extension,
+	0,
+	ext_fileinto_operation_dump,
+	ext_fileinto_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_fileinto_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "folder", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_fileinto_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &fileinto_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool ext_fileinto_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "FILEINTO");
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) ) {
+		return FALSE;
+	}
+
+	return sieve_opr_string_dump(denv, address, "folder");
+}
+
+/*
+ * Execution
+ */
+
+static int ext_fileinto_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL;
+	string_t *folder;
+	const char *mailbox;
+	unsigned int source_line;
+	int ret = 0;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands */
+	if ( (ret=sieve_interpreter_handle_optional_operands(renv, address, &slist))
+		<= 0 )
+		return ret;
+
+	/* Folder operand */
+	if ( !sieve_opr_string_read(renv, address, &folder) ) {
+		sieve_runtime_trace_error(renv, "invalid folder operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	mailbox = str_sanitize(str_c(folder), 64);
+	sieve_runtime_trace(renv, "FILEINTO action (\"%s\")", mailbox);
+
+	/* Add action to result */
+	ret = sieve_act_store_add_to_result
+		(renv, slist, str_c(folder), source_line);
+
+	return ( ret >= 0 );
+}
+
+
+
+
+
+
Index: b/sieve/src/lib-sieve/ext-reject.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/ext-reject.c
@@ -0,0 +1,539 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension reject
+ * ----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5429
+ * Implementation: full
+ * Status: experimental
+ *
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "hostpid.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "message-size.h"
+#include "istream.h"
+#include "istream-header-filter.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_command_def reject_command;
+static const struct sieve_operation_def reject_operation;
+
+static const struct sieve_command_def ereject_command;
+static const struct sieve_operation_def ereject_operation;
+
+/*
+ * Extensions
+ */
+
+/* Reject */
+
+static bool ext_reject_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def reject_extension = {
+	"reject",
+	NULL, NULL,
+	ext_reject_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(reject_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_reject_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new command */
+	sieve_validator_register_command(valdtr, ext, &reject_command);
+
+	return TRUE;
+}
+
+/* EReject */
+
+static bool ext_ereject_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def ereject_extension = {
+	"ereject",
+	NULL, NULL,
+	ext_ereject_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(ereject_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_ereject_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new command */
+	sieve_validator_register_command(valdtr, ext, &ereject_command);
+
+	return TRUE;
+}
+
+/*
+ * Commands
+ */
+
+/* Forward declarations */
+
+static bool cmd_reject_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_reject_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+/* Reject command
+ *
+ * Syntax:
+ *   reject <reason: string>
+ */
+
+static const struct sieve_command_def reject_command = {
+	"reject",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_reject_validate,
+	cmd_reject_generate,
+	NULL
+};
+
+/* EReject command
+ *
+ * Syntax:
+ *   ereject <reason: string>
+ */
+
+static const struct sieve_command_def ereject_command = {
+	"ereject",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_reject_validate,
+	cmd_reject_generate,
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+/* Forward declarations */
+
+static bool ext_reject_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_reject_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Reject operation */
+
+static const struct sieve_operation_def reject_operation = {
+	"REJECT",
+	&reject_extension,
+	0,
+	ext_reject_operation_dump,
+	ext_reject_operation_execute
+};
+
+/* EReject operation */
+
+static const struct sieve_operation_def ereject_operation = {
+	"EREJECT",
+	&ereject_extension,
+	0,
+	ext_reject_operation_dump,
+	ext_reject_operation_execute
+};
+
+/*
+ * Reject action
+ */
+
+static int act_reject_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+int act_reject_check_conflict
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+static void act_reject_print
+	(const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+static bool act_reject_commit
+	(const struct sieve_action *action ATTR_UNUSED,
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+
+const struct sieve_action_def act_reject = {
+	"reject",
+	SIEVE_ACTFLAG_SENDS_RESPONSE,
+	NULL,
+	act_reject_check_duplicate,
+	act_reject_check_conflict,
+	act_reject_print,
+	NULL, NULL,
+	act_reject_commit,
+	NULL
+};
+
+struct act_reject_context {
+	const char *reason;
+	bool ereject;
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_reject_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_reject_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	if ( sieve_command_is(cmd, reject_command) )
+		sieve_operation_emit(cgenv->sbin, cmd->ext, &reject_operation);
+	else
+		sieve_operation_emit(cgenv->sbin, cmd->ext, &ereject_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool ext_reject_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &denv->oprtn;
+
+	sieve_code_dumpf(denv, "%s", sieve_operation_mnemonic(op));
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) )
+		return FALSE;
+
+	return sieve_opr_string_dump(denv, address, "reason");
+}
+
+/*
+ * Interpretation
+ */
+
+static int ext_reject_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &renv->oprtn;
+	const struct sieve_extension *this_ext = op->ext;
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_reject_context *act;
+	string_t *reason;
+	unsigned int source_line;
+	pool_t pool;
+	int ret;
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands (side effects) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	/* Read rejection reason */
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "%s action (\"%s\")", sieve_operation_mnemonic(op),
+		str_sanitize(str_c(reason), 64));
+
+	/* Add reject action to the result */
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_reject_context, 1);
+	act->reason = p_strdup(pool, str_c(reason));
+	act->ereject = ( sieve_operation_is(op, ereject_operation) );
+
+	ret = sieve_result_add_action
+		(renv, this_ext, &act_reject, slist, source_line, (void *) act, 0);
+
+	return ( ret >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static int act_reject_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action *act,
+	const struct sieve_action *act_other)
+{
+	if ( !act_other->executed ) {
+		sieve_runtime_error(renv, act->location,
+			"duplicate reject/ereject action not allowed "
+			"(previously triggered one was here: %s)", act_other->location);
+		return -1;
+	}
+
+	return 1;
+}
+
+int act_reject_check_conflict
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *act,
+	const struct sieve_action *act_other)
+{
+	if ( (act_other->def->flags & SIEVE_ACTFLAG_TRIES_DELIVER) > 0 ) {
+		if ( !act_other->executed ) {
+			sieve_runtime_error(renv, act->location,
+				"reject/ereject action conflicts with other action: "
+				"the %s action (%s) tries to deliver the message",
+				act_other->def->name, act_other->location);
+			return -1;
+		}
+	}
+
+	if ( (act_other->def->flags & SIEVE_ACTFLAG_SENDS_RESPONSE) > 0 ) {
+		struct act_reject_context *rj_ctx;
+
+		if ( !act_other->executed ) {
+			sieve_runtime_error(renv, act->location,
+				"reject/ereject action conflicts with other action: "
+				"the %s action (%s) also sends a response to the sender",
+				act_other->def->name, act_other->location);
+			return -1;
+		}
+
+		/* Conflicting action was already executed, transform reject into discard
+		 * equivalent.
+		 */
+		rj_ctx = (struct act_reject_context *) act->context;
+		rj_ctx->reason = NULL;
+	}
+
+	return 0;
+}
+
+static void act_reject_print
+(const struct sieve_action *action,	const struct sieve_result_print_env *rpenv,
+	bool *keep)
+{
+	struct act_reject_context *rj_ctx =
+		(struct act_reject_context *) action->context;
+
+	if ( rj_ctx->reason != NULL ) {
+		sieve_result_action_printf(rpenv, "reject message with reason: %s",
+			str_sanitize(rj_ctx->reason, 128));
+	} else {
+		sieve_result_action_printf(rpenv,
+			"reject message without sending a response (discard)");
+	}
+
+	*keep = FALSE;
+}
+
+static bool act_reject_send
+(const struct sieve_action_exec_env *aenv, struct act_reject_context *ctx,
+	const char *sender, const char *recipient)
+{
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct istream *input;
+	void *smtp_handle;
+	struct message_size hdr_size;
+	FILE *f;
+	const char *new_msgid, *boundary;
+	const unsigned char *data;
+	const char *header;
+	size_t size;
+	int ret;
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "reject action has no means to send mail");
+		return TRUE;
+	}
+
+	smtp_handle = senv->smtp_open(sender, NULL, &f);
+
+	new_msgid = sieve_message_get_new_id(senv);
+	boundary = t_strdup_printf("%s/%s", my_pid, senv->hostname);
+
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+	rfc2822_header_field_write(f, "Message-ID", new_msgid);
+	rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+	rfc2822_header_field_printf(f, "From", "Mail Delivery Subsystem <%s>",
+		senv->postmaster_address);
+	rfc2822_header_field_printf(f, "To", "<%s>", sender);
+	rfc2822_header_field_write(f, "Subject", "Automatically rejected mail");
+	rfc2822_header_field_write(f, "Auto-Submitted", "auto-replied (rejected)");
+	rfc2822_header_field_write(f, "Precedence", "bulk");
+
+	rfc2822_header_field_write(f, "MIME-Version", "1.0");
+	rfc2822_header_field_printf(f, "Content-Type",
+		"multipart/report; report-type=disposition-notification;\n"
+		"boundary=\"%s\"", boundary);
+
+	fprintf(f, "\r\nThis is a MIME-encapsulated message\r\n\r\n");
+
+	/* Human readable status report */
+	fprintf(f, "--%s\r\n", boundary);
+	fprintf(f, "Content-Type: text/plain; charset=utf-8\r\n");
+	fprintf(f, "Content-Disposition: inline\r\n");
+	fprintf(f, "Content-Transfer-Encoding: 8bit\r\n\r\n");
+
+	/* FIXME: var_expand_table expansion not possible */
+	fprintf(f, "Your message to <%s> was automatically rejected:\r\n"
+		"%s\r\n", recipient, ctx->reason);
+
+	/* MDN status report */
+	fprintf(f, "--%s\r\n"
+		"Content-Type: message/disposition-notification\r\n\r\n", boundary);
+	fprintf(f, "Reporting-UA: %s; Dovecot Mail Delivery Agent\r\n",
+		senv->hostname);
+	if (mail_get_first_header(msgdata->mail, "Original-Recipient", &header) > 0)
+		fprintf(f, "Original-Recipient: rfc822; %s\r\n", header);
+	fprintf(f, "Final-Recipient: rfc822; %s\r\n", recipient);
+
+	if ( msgdata->id != NULL )
+		fprintf(f, "Original-Message-ID: %s\r\n", msgdata->id);
+	fprintf(f, "Disposition: "
+		"automatic-action/MDN-sent-automatically; deleted\r\n");
+	fprintf(f, "\r\n");
+
+	/* original message's headers */
+	fprintf(f, "--%s\r\nContent-Type: message/rfc822\r\n\r\n", boundary);
+
+	if (mail_get_stream(msgdata->mail, &hdr_size, NULL, &input) == 0) {
+		/* Note: If you add more headers, they need to be sorted.
+		 * We'll drop Content-Type because we're not including the message
+		 * body, and having a multipart Content-Type may confuse some
+		 * MIME parsers when they don't see the message boundaries.
+		 */
+		static const char *const exclude_headers[] = {
+			"Content-Type"
+		};
+
+		input = i_stream_create_header_filter(input,
+			HEADER_FILTER_EXCLUDE | HEADER_FILTER_NO_CR | HEADER_FILTER_HIDE_BODY,
+			exclude_headers, N_ELEMENTS(exclude_headers),
+			null_header_filter_callback, NULL);
+
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			if (fwrite(data, size, 1, f) == 0)
+				break;
+			i_stream_skip(input, size);
+		}
+		i_stream_unref(&input);
+
+		i_assert(ret != 0);
+	}
+
+	fprintf(f, "\r\n\r\n--%s--\r\n", boundary);
+
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv,
+			"failed to send rejection message to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(sender, 80));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool act_reject_commit
+(const struct sieve_action *action, const struct sieve_action_exec_env *aenv,
+	void *tr_context ATTR_UNUSED, bool *keep)
+{
+	struct act_reject_context *rj_ctx =
+		(struct act_reject_context *) action->context;
+	const char *sender = sieve_message_get_sender(aenv->msgctx);
+	const char *recipient = sieve_message_get_recipient(aenv->msgctx);
+
+	if ( recipient == NULL ) {
+		sieve_result_warning(aenv,
+			"reject action aborted: envelope recipient is <>");
+		return TRUE;
+	}
+
+	if ( rj_ctx->reason == NULL ) {
+		sieve_result_log(aenv,
+			"not sending reject message (would cause second response to sender)");
+
+		*keep = FALSE;
+		return TRUE;
+	}
+
+	if ( sender == NULL ) {
+		sieve_result_log(aenv, "not sending reject message to <>");
+
+		*keep = FALSE;
+		return TRUE;
+	}
+
+	if ( act_reject_send(aenv, rj_ctx, sender, recipient) ) {
+		sieve_result_log(aenv,
+			"rejected message from <%s> (%s)", str_sanitize(sender, 80),
+			( rj_ctx->ereject ? "ereject" : "reject" ));
+
+		*keep = FALSE;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
Index: b/sieve/src/lib-sieve/mcht-contains.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/mcht-contains.c
@@ -0,0 +1,69 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':contains'
+ */
+
+#include "lib.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int mcht_contains_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type_def contains_match_type = {
+	SIEVE_OBJECT("contains", &match_type_operand,	SIEVE_MATCH_TYPE_CONTAINS),
+	TRUE, TRUE,
+	NULL,
+	sieve_match_substring_validate_context,
+	NULL,
+	mcht_contains_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+/* FIXME: Naive substring match implementation. Should switch to more
+ * efficient algorithm if large values need to be searched (e.g. message body).
+ */
+static int mcht_contains_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size,
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = mctx->comparator;
+	const char *vend = (const char *) val + val_size;
+	const char *kend = (const char *) key + key_size;
+	const char *vp = val;
+	const char *kp = key;
+
+	if ( val == NULL || val_size == 0 )
+		return ( key_size == 0 );
+
+	if ( cmp->def == NULL || cmp->def->char_match == NULL )
+		return FALSE;
+
+	while ( (vp < vend) && (kp < kend) ) {
+		if ( !cmp->def->char_match(cmp, &vp, vend, &kp, kend) )
+			vp++;
+	}
+
+	return (kp == kend);
+}
+
+
Index: b/sieve/src/lib-sieve/mcht-is.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/mcht-is.c
@@ -0,0 +1,54 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':is':
+ */
+
+#include "lib.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int mcht_is_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type_def is_match_type = {
+	SIEVE_OBJECT("is", &match_type_operand, SIEVE_MATCH_TYPE_IS),
+	TRUE, TRUE,
+	NULL, NULL, NULL,
+	mcht_is_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+static int mcht_is_match
+(struct sieve_match_context *mctx ATTR_UNUSED,
+	const char *val, size_t val_size,
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	if ( (val == NULL || val_size == 0) )
+		return ( key_size == 0 );
+
+	if ( mctx->comparator->def != NULL && mctx->comparator->def->compare != NULL )
+		return (mctx->comparator->def->compare(mctx->comparator,
+			val, val_size, key, key_size) == 0);
+
+	return FALSE;
+}
+
Index: b/sieve/src/lib-sieve/mcht-matches.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/mcht-matches.c
@@ -0,0 +1,437 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':matches'
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int mcht_matches_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type_def matches_match_type = {
+	SIEVE_OBJECT("matches", &match_type_operand, SIEVE_MATCH_TYPE_MATCHES),
+	TRUE, FALSE,
+	NULL,
+	sieve_match_substring_validate_context,
+	NULL,
+	mcht_matches_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+/* Quick 'n dirty debug */
+//#define MATCH_DEBUG
+#ifdef MATCH_DEBUG
+#define debug_printf(...) printf ("match debug: " __VA_ARGS__)
+#else
+#define debug_printf(...)
+#endif
+
+/* FIXME: Naive implementation, substitute this with dovecot src/lib/str-find.c
+ */
+static inline bool _string_find(const struct sieve_comparator *cmp,
+	const char **valp, const char *vend, const char **keyp, const char *kend)
+{
+	while ( (*valp < vend) && (*keyp < kend) ) {
+		if ( !cmp->def->char_match(cmp, valp, vend, keyp, kend) )
+			(*valp)++;
+	}
+
+	return (*keyp == kend);
+}
+
+static char _scan_key_section
+	(string_t *section, const char **wcardp, const char *key_end)
+{
+	/* Find next wildcard and resolve escape sequences */
+	str_truncate(section, 0);
+	while ( *wcardp < key_end && **wcardp != '*' && **wcardp != '?') {
+		if ( **wcardp == '\\' ) {
+			(*wcardp)++;
+		}
+		str_append_c(section, **wcardp);
+		(*wcardp)++;
+	}
+
+	/* Record wildcard character or \0 */
+	if ( *wcardp < key_end ) {
+		return **wcardp;
+	}
+
+	i_assert( *wcardp == key_end );
+	return '\0';
+}
+
+static int mcht_matches_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size,
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = mctx->comparator;
+	struct sieve_match_values *mvalues;
+	string_t *mvalue = NULL, *mchars = NULL;
+	string_t *section, *subsection;
+	const char *vend, *kend, *vp, *kp, *wp, *pvp;
+	bool backtrack = FALSE; /* TRUE: match of '?'-connected sections failed */
+	char wcard = '\0';      /* Current wildcard */
+	char next_wcard = '\0'; /* Next  widlcard */
+	unsigned int key_offset = 0;
+
+	if ( cmp->def == NULL || cmp->def->char_match == NULL )
+		return FALSE;
+
+	/* Value may be NULL, parse empty string in stead */
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	/* Key sections */
+	section = t_str_new(32);    /* Section (after beginning or *) */
+	subsection = t_str_new(32); /* Sub-section (after ?) */
+
+	/* Mark end of value and key */
+	vend = (const char *) val + val_size;
+	kend = (const char *) key + key_size;
+
+	/* Initialize pointers */
+	vp = val;                   /* Value pointer */
+	kp = key;                   /* Key pointer */
+	wp = key;                   /* Wildcard (key) pointer */
+	pvp = val;                  /* Previous value Pointer */
+
+	/* Start match values list if requested */
+	if ( (mvalues = sieve_match_values_start(mctx->interp)) != NULL ) {
+		/* Skip ${0} for now; added when match succeeds */
+		sieve_match_values_add(mvalues, NULL);
+
+		mvalue = t_str_new(32);     /* Match value (*) */
+		mchars = t_str_new(32);     /* Match characters (.?..?.??) */
+	}
+
+	/* Match the pattern:
+	 *   <pattern> = <section>*<section>*<section>...
+	 *   <section> = <sub-section>?<sub-section>?<sub-section>...
+	 *
+	 * Escape sequences \? and \* need special attention.
+	 */
+
+	debug_printf("=== Start ===\n");
+	debug_printf("  key:   %s\n", t_strdup_until(key, kend));
+	debug_printf("  value: %s\n", t_strdup_until(val, vend));
+
+	/* Loop until either key or value ends */
+	while (kp < kend && vp < vend ) {
+		const char *needle, *nend;
+
+		if ( !backtrack ) {
+			/* Search the next '*' wildcard in the key string */
+
+			wcard = next_wcard;
+
+			/* Find the needle to look for in the string */
+			key_offset = 0;
+			for (;;) {
+				next_wcard = _scan_key_section(section, &wp, kend);
+
+				if ( wcard == '\0' || str_len(section) > 0 )
+					break;
+
+				if ( next_wcard == '*' ) {
+					break;
+				}
+
+				if ( wp < kend )
+					wp++;
+				else
+					break;
+				key_offset++;
+			}
+
+			debug_printf("found wildcard '%c' at pos [%d]\n",
+				next_wcard, (int) (wp-key));
+
+			if ( mvalues != NULL )
+				str_truncate(mvalue, 0);
+		} else {
+			/* Backtracked; '*' wildcard is retained */
+			debug_printf("backtracked");
+			backtrack = FALSE;
+		}
+
+		/* Determine what we are looking for */
+		needle = str_c(section);
+		nend = PTR_OFFSET(needle, str_len(section));
+
+		debug_printf("  section needle:  '%s'\n", t_strdup_until(needle, nend));
+		debug_printf("  section key:     '%s'\n", t_strdup_until(kp, kend));
+		debug_printf("  section remnant: '%s'\n", t_strdup_until(wp, kend));
+		debug_printf("  value remnant:   '%s'\n", t_strdup_until(vp, vend));
+		debug_printf("  key offset:      %d\n", key_offset);
+
+		pvp = vp;
+		if ( next_wcard == '\0' ) {
+			/* No more wildcards; find the needle substring at the end of string */
+
+			const char *qp, *qend;
+
+			debug_printf("next_wcard = NUL; must find needle at end\n");
+
+			/* Check if the value is still large enough */
+			if ( vend - str_len(section) < vp ) {
+				debug_printf("  wont match: value is too short\n");
+				break;
+			}
+
+			/* Move value pointer to where the needle should be */
+			vp = PTR_OFFSET(vend, -str_len(section));
+
+			/* Record match values */
+			qend = vp;
+			qp = vp - key_offset;
+
+			if ( mvalues != NULL )
+				str_append_n(mvalue, pvp, qp-pvp);
+
+			/* Compare needle to end of value string */
+			if ( !cmp->def->char_match(cmp, &vp, vend, &needle, nend) ) {
+				debug_printf("  match at end failed\n");
+				break;
+			}
+
+			/* Add match values */
+			if ( mvalues != NULL ) {
+				/* Append '*' match value */
+				sieve_match_values_add(mvalues, mvalue);
+
+				/* Append any initial '?' match values */
+				for ( ; qp < qend; qp++ )
+					sieve_match_values_add_char(mvalues, *qp);
+			}
+
+			/* Finish match */
+			kp = kend;
+			vp = vend;
+
+			debug_printf("  matched end of value\n");
+			break;
+		} else {
+			/* Next wildcard found; match needle before next wildcard */
+
+			const char *prv = NULL; /* Stored value pointer for backtrack */
+			const char *prk = NULL; /* Stored key pointer for backtrack */
+			const char *prw = NULL; /* Stored wildcard pointer for backtrack */
+			const char *chars;
+
+			/* Reset '?' match values */
+			if ( mvalues != NULL )
+				str_truncate(mchars, 0);
+
+			if ( wcard == '\0' ) {
+				/* No current wildcard; match needs to happen right at the beginning */
+				debug_printf("wcard = NUL; needle should be found at the beginning.\n");
+				debug_printf("  begin needle: '%s'\n", t_strdup_until(needle, nend));
+				debug_printf("  begin value:  '%s'\n", t_strdup_until(vp, vend));
+
+				if ( !cmp->def->char_match(cmp, &vp, vend, &needle, nend) ) {
+					debug_printf("  failed to find needle at beginning\n");
+					break;
+				}
+
+			} else {
+				/* Current wildcard present; match needle between current and next wildcard */
+				debug_printf("wcard != NUL; must find needle at an offset (>= %d).\n",
+					key_offset);
+
+				/* Match may happen at any offset (>= key offset): find substring */
+				vp += key_offset;
+				if ( (vp >= vend) || !_string_find(cmp, &vp, vend, &needle, nend) ) {
+					debug_printf("  failed to find needle at an offset\n");
+					break;
+				}
+
+				prv = vp - str_len(section);
+				prk = kp;
+				prw = wp;
+
+				/* Append match values */
+				if ( mvalues != NULL ) {
+					const char *qend = vp - str_len(section);
+					const char *qp = qend - key_offset;
+
+					/* Append '*' match value */
+					str_append_n(mvalue, pvp, qp-pvp);
+
+					/* Append any initial '?' match values (those that caused the key
+					 * offset.
+					 */
+					for ( ; qp < qend; qp++ )
+						str_append_c(mchars, *qp);
+				}
+			}
+
+			/* Update wildcard and key pointers for next wildcard scan */
+			if ( wp < kend ) wp++;
+			kp = wp;
+
+			/* Scan successive '?' wildcards */
+			while ( next_wcard == '?' ) {
+				debug_printf("next_wcard = '?'; need to match arbitrary character\n");
+
+				/* Add match value */
+				if ( mvalues != NULL )
+					str_append_c(mchars, *vp);
+
+				vp++;
+
+				/* Scan for next '?' wildcard */
+				next_wcard = _scan_key_section(subsection, &wp, kend);
+				debug_printf("found next wildcard '%c' at pos [%d] (fixed match)\n",
+					next_wcard, (int) (wp-key));
+
+				/* Determine what we are looking for */
+				needle = str_c(subsection);
+				nend = PTR_OFFSET(needle, str_len(subsection));
+
+				debug_printf("  sub key:       '%s'\n", t_strdup_until(needle, nend));
+				debug_printf("  value remnant: '%s'\n", vp <= vend ? t_strdup_until(vp, vend) : "");
+
+				/* Try matching the needle at fixed position */
+				if ( (needle == nend && next_wcard == '\0' && vp < vend ) ||
+					!cmp->def->char_match(cmp, &vp, vend, &needle, nend) ) {
+
+					/* Match failed: now we have a problem. We need to backtrack to the previous
+					 * '*' wildcard occurence and start scanning for the next possible match.
+					 */
+
+					debug_printf("  failed fixed match\n");
+
+					/* Start backtrack */
+					if ( prv != NULL && prv + 1 < vend ) {
+						/* Restore pointers */
+						vp = prv;
+						kp = prk;
+						wp = prw;
+
+						/* Skip forward one value character to scan the next possible match */
+						if ( mvalues != NULL )
+							str_append_c(mvalue, *vp);
+						vp++;
+
+						/* Set wildcard state appropriately */
+						wcard = '*';
+						next_wcard = '?';
+
+						/* Backtrack */
+						backtrack = TRUE;
+
+						debug_printf("  BACKTRACK\n");
+					}
+
+					/* Break '?' wildcard scanning loop */
+					break;
+				}
+
+				/* Update wildcard and key pointers for next wildcard scan */
+				if ( wp < kend ) wp++;
+				kp = wp;
+			}
+
+			if ( !backtrack ) {
+				unsigned int i;
+
+				if ( next_wcard == '?' ) {
+					debug_printf("failed to match '?'\n");
+					break;
+				}
+
+				if ( mvalues != NULL ) {
+					if ( prv != NULL )
+						sieve_match_values_add(mvalues, mvalue);
+
+					chars = (const char *) str_data(mchars);
+
+					for ( i = 0; i < str_len(mchars); i++ ) {
+						sieve_match_values_add_char(mvalues, chars[i]);
+					}
+				}
+
+				if ( next_wcard != '*' ) {
+					debug_printf("failed to match at end of string\n");
+					break;
+				}
+			}
+		}
+
+		/* Check whether string ends in a wildcard
+		 * (avoid scanning the rest of the string)
+		 */
+		if ( kp == kend && next_wcard == '*' ) {
+			/* Add the rest of the string as match value */
+			if ( mvalues != NULL ) {
+				str_truncate(mvalue, 0);
+				str_append_n(mvalue, vp, vend-vp);
+				sieve_match_values_add(mvalues, mvalue);
+			}
+
+			/* Finish match */
+			kp = kend;
+			vp = vend;
+
+			debug_printf("key ends with '*'\n");
+			break;
+		}
+
+		debug_printf("== Loop ==\n");
+	}
+
+	/* Eat away a trailing series of *s */
+	if ( vp == vend ) {
+		while ( kp < kend && *kp == '*' ) kp++;
+	}
+
+	/* By definition, the match is only successful if both value and key pattern
+	 * are exhausted.
+	 */
+
+	debug_printf("=== Finish ===\n");
+	debug_printf("  result: %s\n", (kp == kend && vp == vend) ? "true" : "false");
+
+	if (kp == kend && vp == vend) {
+		/* Activate new match values after successful match */
+		if ( mvalues != NULL ) {
+			/* Set ${0} */
+			string_t *matched = str_new_const(pool_datastack_create(), val, val_size);
+			sieve_match_values_set(mvalues, 0, matched);
+
+			/* Commit new match values */
+			sieve_match_values_commit(mctx->interp, &mvalues);
+		}
+		return TRUE;
+	}
+
+	/* No match; drop collected match values */
+	sieve_match_values_abort(&mvalues);
+	return FALSE;
+}
+
Index: b/sieve/src/lib-sieve/plugins/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/Makefile.am
@@ -0,0 +1,23 @@
+if BUILD_UNFINISHED
+UNFINISHED =
+endif
+
+SUBDIRS = \
+	vacation \
+	subaddress \
+	comparator-i-ascii-numeric \
+	relational \
+	regex \
+	imap4flags \
+	copy \
+	include \
+	body \
+	variables \
+	enotify \
+	notify \
+	environment \
+	mailbox \
+	date \
+	$(UNFINISHED)
+
+
Index: b/sieve/src/lib-sieve/plugins/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/Makefile.in
@@ -0,0 +1,577 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@BUILD_UNFINISHED_TRUE@UNFINISHED =
+SUBDIRS = \
+	vacation \
+	subaddress \
+	comparator-i-ascii-numeric \
+	relational \
+	regex \
+	imap4flags \
+	copy \
+	include \
+	body \
+	variables \
+	enotify \
+	notify \
+	environment \
+	mailbox \
+	date \
+	$(UNFINISHED)
+
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
+	install-am install-strip tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/body/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/body/Makefile.am
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_body.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tsts = \
+	tst-body.c
+
+libsieve_ext_body_la_SOURCES = \
+	ext-body-common.c \
+	$(tsts) \
+	ext-body.c
+
+noinst_HEADERS = \
+	ext-body-common.h
Index: b/sieve/src/lib-sieve/plugins/body/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/body/Makefile.in
@@ -0,0 +1,496 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/body
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_body_la_LIBADD =
+am__objects_1 = tst-body.lo
+am_libsieve_ext_body_la_OBJECTS = ext-body-common.lo $(am__objects_1) \
+	ext-body.lo
+libsieve_ext_body_la_OBJECTS = $(am_libsieve_ext_body_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_body_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_body_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_body.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tsts = \
+	tst-body.c
+
+libsieve_ext_body_la_SOURCES = \
+	ext-body-common.c \
+	$(tsts) \
+	ext-body.c
+
+noinst_HEADERS = \
+	ext-body-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/body/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/body/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_body.la: $(libsieve_ext_body_la_OBJECTS) $(libsieve_ext_body_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_body_la_OBJECTS) $(libsieve_ext_body_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-body-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-body.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-body.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/body/ext-body-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/body/ext-body-common.c
@@ -0,0 +1,407 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "array.h"
+#include "str.h"
+#include "istream.h"
+#include "rfc822-parser.h"
+#include "message-date.h"
+#include "message-parser.h"
+#include "message-decoder.h"
+
+#include "sieve-common.h"
+#include "sieve-message.h"
+#include "sieve-interpreter.h"
+
+#include "ext-body-common.h"
+
+/* This implementation is largely borrowed from the original sieve-cmu.c of the
+ * cmusieve plugin.
+ */
+
+struct ext_body_part_cached {
+	const char *content_type;
+
+	const char *raw_body;
+	const char *decoded_body;
+	size_t raw_body_size;
+	size_t decoded_body_size;
+
+	bool have_body; /* there's the empty end-of-headers line */
+};
+
+struct ext_body_message_context {
+	pool_t pool;
+	ARRAY_DEFINE(cached_body_parts, struct ext_body_part_cached);
+	ARRAY_DEFINE(return_body_parts, struct ext_body_part);
+	buffer_t *tmp_buffer;
+	buffer_t *raw_body;
+};
+
+static bool _is_wanted_content_type
+(const char * const *wanted_types, const char *content_type)
+{
+	const char *subtype = strchr(content_type, '/');
+	size_t type_len;
+
+	type_len = ( subtype == NULL ? strlen(content_type) :
+		(size_t)(subtype - content_type) );
+
+	i_assert( wanted_types != NULL );
+
+	for (; *wanted_types != NULL; wanted_types++) {
+		const char *wanted_subtype = strchr(*wanted_types, '/');
+
+		if (**wanted_types == '\0') {
+			/* empty string matches everything */
+			return TRUE;
+		}
+		if (wanted_subtype == NULL) {
+			/* match only main type */
+			if (strlen(*wanted_types) == type_len &&
+			  strncasecmp(*wanted_types, content_type, type_len) == 0)
+				return TRUE;
+		} else {
+			/* match whole type/subtype */
+			if (strcasecmp(*wanted_types, content_type) == 0)
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+static bool ext_body_get_return_parts
+(struct ext_body_message_context *ctx, const char * const *wanted_types,
+	bool decode_to_plain)
+{
+	const struct ext_body_part_cached *body_parts;
+	unsigned int i, count;
+	struct ext_body_part *return_part;
+
+	/* Check whether any body parts are cached already */
+	body_parts = array_get(&ctx->cached_body_parts, &count);
+	if ( count == 0 )
+		return FALSE;
+
+	/* Clear result array */
+	array_clear(&ctx->return_body_parts);
+
+	/* Fill result array with requested content_types */
+	for (i = 0; i < count; i++) {
+		if (!body_parts[i].have_body) {
+			/* Part has no body; according to RFC this MUST not match to anything and
+			 * therefore it is not included in the result.
+			 */
+			continue;
+		}
+
+		/* Skip content types that are not requested */
+		if (!_is_wanted_content_type(wanted_types, body_parts[i].content_type))
+			continue;
+
+		/* Add new item to the result */
+		return_part = array_append_space(&ctx->return_body_parts);
+
+		/* Depending on whether a decoded body part is requested, the appropriate
+		 * cache item is read. If it is missing, this function fails and the cache
+		 * needs to be completed by ext_body_parts_add_missing().
+		 */
+		if (decode_to_plain) {
+			if (body_parts[i].decoded_body == NULL)
+				return FALSE;
+			return_part->content = body_parts[i].decoded_body;
+			return_part->size = body_parts[i].decoded_body_size;
+		} else {
+			if (body_parts[i].raw_body == NULL)
+				return FALSE;
+			return_part->content = body_parts[i].raw_body;
+			return_part->size = body_parts[i].raw_body_size;
+		}
+	}
+
+	return TRUE;
+}
+
+static void ext_body_part_save
+(struct ext_body_message_context *ctx, struct message_part *part,
+	struct ext_body_part_cached *body_part, bool decoded)
+{
+	buffer_t *buf = ctx->tmp_buffer;
+	char *part_data;
+	size_t part_size;
+
+	/* Add terminating NUL to the body part buffer */
+	buffer_append_c(buf, '\0');
+
+	part_data = p_malloc(ctx->pool, buf->used);
+	memcpy(part_data, buf->data, buf->used);
+	part_size = buf->used - 1;
+
+	/* Depending on whether the part is decoded or not store message body in the
+	 * appropriate cache location.
+	 */
+	if ( !decoded ) {
+		body_part->raw_body = part_data;
+		body_part->raw_body_size = part_size;
+		i_assert(buf->used - 1 == part->body_size.physical_size);
+	} else {
+		body_part->decoded_body = part_data;
+		body_part->decoded_body_size = part_size;
+	}
+
+	/* Clear buffer */
+	buffer_set_used_size(buf, 0);
+}
+
+static const char *_parse_content_type(const struct message_header_line *hdr)
+{
+	struct rfc822_parser_context parser;
+	string_t *content_type;
+
+	/* Initialize parsing */
+	rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);
+	(void)rfc822_skip_lwsp(&parser);
+
+	/* Parse content type */
+	content_type = t_str_new(64);
+	if (rfc822_parse_content_type(&parser, content_type) < 0)
+		return "";
+
+	/* Content-type value must end here, otherwise it is invalid after all */
+	(void)rfc822_skip_lwsp(&parser);
+	if ( parser.data != parser.end && *parser.data != ';' )
+		return "";
+
+	/* Success */
+	return str_c(content_type);
+}
+
+/* ext_body_parts_add_missing():
+ *   Add requested message body parts to the cache that are missing.
+ */
+static bool ext_body_parts_add_missing
+(const struct sieve_message_data *msgdata, struct ext_body_message_context *ctx,
+	const char * const *content_types, bool decode_to_plain)
+{
+	struct ext_body_part_cached *body_part = NULL;
+	struct message_parser_ctx *parser;
+	struct message_decoder_context *decoder;
+	struct message_block block, decoded;
+	struct message_part *parts, *prev_part = NULL;
+	struct istream *input;
+	unsigned int idx = 0;
+	bool save_body = FALSE, have_all;
+	int ret;
+
+	/* First check whether any are missing */
+	if (ext_body_get_return_parts(ctx, content_types, decode_to_plain)) {
+		/* Cache hit; all are present */
+		return TRUE;
+	}
+
+	/* Get the message stream */
+	if ( mail_get_stream(msgdata->mail, NULL, NULL, &input) < 0 )
+		return FALSE;
+
+	buffer_set_used_size(ctx->tmp_buffer, 0);
+
+	/* Initialize body decoder */
+	decoder = decode_to_plain ? message_decoder_init(FALSE) : NULL;
+
+	parser = message_parser_init(ctx->pool, input, 0, 0);
+	while ( (ret = message_parser_parse_next_block(parser, &block)) > 0 ) {
+		if ( block.part != prev_part ) {
+			/* Save previous body part */
+			if ( body_part != NULL && save_body ) {
+				ext_body_part_save(ctx, prev_part, body_part, decoder != NULL);
+			}
+
+			/* Start processing next */
+			prev_part = block.part;
+			body_part = array_idx_modifiable(&ctx->cached_body_parts, idx);
+			idx++;
+			body_part->content_type = "text/plain";
+		}
+
+		if ( block.hdr != NULL || block.size == 0 ) {
+			/* Reading headers */
+
+			/* Decode block */
+			if ( decoder != NULL )
+				(void)message_decoder_decode_next_block(decoder, &block, &decoded);
+
+			/* Check for end of headers */
+			if ( block.hdr == NULL ) {
+				/* Save bodies only if we have a wanted content-type */
+				save_body = _is_wanted_content_type
+					(content_types, body_part->content_type);
+				continue;
+			}
+
+			/* Encountered the empty line that indicates the end of the headers and
+			 * the start of the body
+			 */
+			if ( block.hdr->eoh )
+				body_part->have_body = TRUE;
+
+			/* We're interested of only Content-Type: header */
+			if ( strcasecmp(block.hdr->name, "Content-Type" ) != 0)
+				continue;
+
+			/* Header can have folding whitespace. Acquire the full value before
+			 * continuing
+			 */
+			if ( block.hdr->continues ) {
+				block.hdr->use_full_value = TRUE;
+				continue;
+			}
+
+			/* Parse the content type from the Content-type header */
+			T_BEGIN {
+				body_part->content_type =
+					p_strdup(ctx->pool, _parse_content_type(block.hdr));
+			} T_END;
+
+			continue;
+		}
+
+		/* Reading body */
+		if ( save_body ) {
+			if ( decoder != NULL ) {
+				(void)message_decoder_decode_next_block(decoder, &block, &decoded);
+				buffer_append(ctx->tmp_buffer, decoded.data, decoded.size);
+			} else {
+				buffer_append(ctx->tmp_buffer, block.data, block.size);
+			}
+		}
+	}
+
+	/* Save last body part if necessary */
+	if ( body_part != NULL && save_body )
+		ext_body_part_save(ctx, prev_part, body_part, decoder != NULL);
+
+	/* Try to fill the return_body_parts array once more */
+	have_all = ext_body_get_return_parts(ctx, content_types, decode_to_plain);
+
+	/* This time, failure is a bug */
+	i_assert(have_all);
+
+	/* Cleanup */
+	(void)message_parser_deinit(&parser, &parts);
+	if (decoder != NULL)
+		message_decoder_deinit(&decoder);
+
+	/* Return status */
+	return ( input->stream_errno == 0 );
+}
+
+static struct ext_body_message_context *ext_body_get_context
+(const struct sieve_extension *this_ext, struct sieve_message_context *msgctx)
+{
+	pool_t pool = sieve_message_context_pool(msgctx);
+	struct ext_body_message_context *ctx;
+
+	/* Get message context (contains cached message body information) */
+	ctx = (struct ext_body_message_context *)
+		sieve_message_context_extension_get(msgctx, this_ext);
+
+	/* Create it if it does not exist already */
+	if ( ctx == NULL ) {
+		ctx = p_new(pool, struct ext_body_message_context, 1);
+		ctx->pool = pool;
+		p_array_init(&ctx->cached_body_parts, pool, 8);
+		p_array_init(&ctx->return_body_parts, pool, 8);
+		ctx->tmp_buffer = buffer_create_dynamic(pool, 1024*64);
+		ctx->raw_body = NULL;
+
+		/* Register context */
+		sieve_message_context_extension_set(msgctx, this_ext, (void *) ctx);
+	}
+
+	return ctx;
+}
+
+bool ext_body_get_content
+(const struct sieve_runtime_env *renv, const char * const *content_types,
+	int decode_to_plain, struct ext_body_part **parts_r)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct ext_body_message_context *ctx =
+		ext_body_get_context(this_ext, renv->msgctx);
+	bool result = TRUE;
+
+	T_BEGIN {
+		/* Fill the return_body_parts array */
+		if ( !ext_body_parts_add_missing
+			(renv->msgdata, ctx, content_types, decode_to_plain != 0) )
+			result = FALSE;
+	} T_END;
+
+	/* Check status */
+	if ( !result ) return FALSE;
+
+	/* Return the array of body items */
+	(void) array_append_space(&ctx->return_body_parts); /* NULL-terminate */
+	*parts_r = array_idx_modifiable(&ctx->return_body_parts, 0);
+
+	return result;
+}
+
+bool ext_body_get_raw
+(const struct sieve_runtime_env *renv, struct ext_body_part **parts_r)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct ext_body_message_context *ctx =
+		ext_body_get_context(this_ext, renv->msgctx);
+	struct ext_body_part *return_part;
+	buffer_t *buf;
+
+	if ( ctx->raw_body == NULL ) {
+		struct mail *mail = renv->msgdata->mail;
+		struct istream *input;
+		struct message_size hdr_size, body_size;
+		const unsigned char *data;
+		size_t size;
+		int ret;
+
+		ctx->raw_body = buf = buffer_create_dynamic(ctx->pool, 1024*64);
+
+		/* Get stream for message */
+ 		if ( mail_get_stream(mail, &hdr_size, &body_size, &input) < 0 )
+			return FALSE;
+
+		/* Skip stream to beginning of body */
+		i_stream_skip(input, hdr_size.physical_size);
+
+		/* Read raw message body */
+		while ( (ret = i_stream_read_data(input, &data, &size, 0)) > 0 ) {
+			buffer_append(buf, data, size);
+
+			i_stream_skip(input, size);
+		}
+	} else {
+		buf = ctx->raw_body;
+	}
+
+	/* Clear result array */
+	array_clear(&ctx->return_body_parts);
+
+	if ( buf->used > 0  ) {
+		/* Add terminating NUL to the body part buffer */
+		buffer_append_c(buf, '\0');
+
+		/* Add single item to the result */
+		return_part = array_append_space(&ctx->return_body_parts);
+		return_part->content = buf->data;
+		return_part->size = buf->used - 1;
+	}
+
+	/* Return the array of body items */
+	(void) array_append_space(&ctx->return_body_parts); /* NULL-terminate */
+	*parts_r = array_idx_modifiable(&ctx->return_body_parts, 0);
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/plugins/body/ext-body-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/body/ext-body-common.h
@@ -0,0 +1,41 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_BODY_COMMON_H
+#define __EXT_BODY_COMMON_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def body_extension;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def body_test;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def body_operation;
+
+/*
+ * Message body part extraction
+ */
+
+struct ext_body_part {
+	const char *content;
+	unsigned long size;
+};
+
+bool ext_body_get_content
+	(const struct sieve_runtime_env *renv, const char * const *content_types,
+		int decode_to_plain, struct ext_body_part **parts_r);
+
+bool ext_body_get_raw
+	(const struct sieve_runtime_env *renv, struct ext_body_part **parts_r);
+
+#endif /* __EXT_BODY_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/body/ext-body.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/body/ext-body.c
@@ -0,0 +1,72 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension body
+ * ------------------
+ *
+ * Authors: Stephan Bosch, original CMUSieve implementation by Timo Sirainen
+ * Specification: RFC 5173
+ * Implementation: full, but text body-transform implementation is simple
+ * Status: experimental, largely untested
+ *
+ */
+
+/* FIXME:
+ *
+ * From RFC with respect to :text body transform:
+ *
+ * "Sophisticated implementations MAY strip mark-up from the text prior
+ *  to matching, and MAY convert media types other than text to text
+ *  prior to matching.
+ *
+ *  (For example, they may be able to convert proprietary text editor
+ *  formats to text or apply optical character recognition algorithms to
+ *  image data.)"
+ *
+ * We might want to do this in the future, i.e. we must evaluate whether this is
+ * feasible.
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-body-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_body_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def body_extension = {
+	"body",
+	NULL, NULL,
+	ext_body_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(body_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_body_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new test */
+	sieve_validator_register_command(valdtr, ext, &body_test);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/body/tst-body.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/body/tst-body.c
@@ -0,0 +1,435 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-body-common.h"
+
+/*
+ * Types
+ */
+
+enum tst_body_transform {
+	TST_BODY_TRANSFORM_RAW,
+	TST_BODY_TRANSFORM_CONTENT,
+	TST_BODY_TRANSFORM_TEXT
+};
+
+/*
+ * Body test
+ *
+ * Syntax
+ *   body [COMPARATOR] [MATCH-TYPE] [BODY-TRANSFORM]
+ *     <key-list: string-list>
+ */
+
+static bool tst_body_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_body_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_body_generate
+	(const struct sieve_codegen_env *cgenv,	struct sieve_command *ctx);
+
+const struct sieve_command_def body_test = {
+	"body",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	tst_body_registered,
+	NULL,
+	tst_body_validate,
+	tst_body_generate,
+	NULL
+};
+
+/*
+ * Body operation
+ */
+
+static bool ext_body_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_body_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def body_operation = {
+	"body",
+	&body_extension,
+	0,
+	ext_body_operation_dump,
+	ext_body_operation_execute
+};
+
+/*
+ * Optional operands
+ */
+
+enum tst_body_optional {
+	OPT_BODY_TRANSFORM = SIEVE_MATCH_OPT_LAST
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Forward declarations */
+
+static bool tag_body_transform_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_body_transform_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument_def body_raw_tag = {
+	"raw",
+	NULL,
+	tag_body_transform_validate,
+	NULL, NULL,
+	tag_body_transform_generate
+};
+
+static const struct sieve_argument_def body_content_tag = {
+	"content",
+	NULL,
+	tag_body_transform_validate,
+	NULL, NULL,
+	tag_body_transform_generate
+};
+
+static const struct sieve_argument_def body_text_tag = {
+	"text",
+	NULL,
+	tag_body_transform_validate,
+	NULL, NULL,
+	tag_body_transform_generate
+};
+
+/* Argument implementation */
+
+static bool tag_body_transform_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	enum tst_body_transform transform;
+	struct sieve_ast_argument *tag = *arg;
+
+	/* BODY-TRANSFORM:
+	 *   :raw
+	 *     / :content <content-types: string-list>
+	 *     / :text
+	 */
+	if ( (bool) cmd->data ) {
+		sieve_argument_validate_error(valdtr, *arg,
+			"the :raw, :content and :text arguments for the body test are mutually "
+			"exclusive, but more than one was specified");
+		return FALSE;
+	}
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	/* :content tag has a string-list argument */
+	if ( sieve_argument_is(tag, body_raw_tag) )
+		transform = TST_BODY_TRANSFORM_RAW;
+
+	else if ( sieve_argument_is(tag, body_text_tag) )
+		transform = TST_BODY_TRANSFORM_TEXT;
+
+	else if ( sieve_argument_is(tag, body_content_tag) ) {
+		/* Check syntax:
+		 *   :content <content-types: string-list>
+		 */
+		if ( !sieve_validate_tag_parameter
+			(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+			return FALSE;
+		}
+
+		if ( !sieve_validator_argument_activate(valdtr, cmd, *arg, FALSE) )
+			return FALSE;
+
+		/* Assign tag parameters */
+		tag->parameters = *arg;
+		*arg = sieve_ast_arguments_detach(*arg,1);
+
+		transform = TST_BODY_TRANSFORM_CONTENT;
+	} else
+		return FALSE;
+
+	/* Signal the presence of this tag */
+	cmd->data = (void *) TRUE;
+
+	/* Assign context data */
+	tag->argument->data = (void *) transform;
+
+	return TRUE;
+}
+
+/*
+ * Command Registration
+ */
+
+static bool tst_body_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &body_raw_tag, OPT_BODY_TRANSFORM);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &body_content_tag, OPT_BODY_TRANSFORM);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &body_text_tag, OPT_BODY_TRANSFORM);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool tst_body_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_body_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	(void)sieve_operation_emit(cgenv->sbin, cmd->ext, &body_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+static bool tag_body_transform_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	enum tst_body_transform transform =
+		(enum tst_body_transform) arg->argument->data;
+
+	sieve_binary_emit_byte(cgenv->sbin, transform);
+	sieve_generate_argument_parameters(cgenv, cmd, arg);
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool ext_body_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	enum tst_body_transform transform;
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "BODY");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_BODY_TRANSFORM:
+			if ( !sieve_binary_read_byte(denv->sbin, address, &transform) )
+				return FALSE;
+
+			switch ( transform ) {
+			case TST_BODY_TRANSFORM_RAW:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: RAW");
+				break;
+			case TST_BODY_TRANSFORM_TEXT:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: TEXT");
+				break;
+			case TST_BODY_TRANSFORM_CONTENT:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: CONTENT");
+
+				sieve_code_descend(denv);
+				if ( !sieve_opr_stringlist_dump(denv, address, "content types") )
+					return FALSE;
+				sieve_code_ascend(denv);
+				break;
+			default:
+				return FALSE;
+			}
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static int ext_body_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	static const char * const _no_content_types[] = { "", NULL };
+	int ret = SIEVE_EXEC_OK;
+	int opt_code = 0;
+	int mret;
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mtch =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	enum tst_body_transform transform;
+	struct sieve_coded_stringlist *key_list, *ctype_list = NULL;
+	struct sieve_match_context *mctx;
+	const char * const *content_types = _no_content_types;
+	struct ext_body_part *body_parts;
+	bool mvalues_active;
+	bool matched;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle any optional operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_BODY_TRANSFORM:
+			if ( !sieve_binary_read_byte(renv->sbin, address, &transform) ||
+				transform > TST_BODY_TRANSFORM_TEXT ) {
+				sieve_runtime_trace_error(renv, "invalid body transform type");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			if ( transform == TST_BODY_TRANSFORM_CONTENT ) {
+				if ( (ctype_list=sieve_opr_stringlist_read(renv, address))
+					== NULL ) {
+					sieve_runtime_trace_error(renv,
+						"invalid :content body transform operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			}
+			break;
+
+		default:
+			sieve_runtime_trace_error(renv, "unknown optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( ctype_list != NULL && !sieve_coded_stringlist_read_all
+		(ctype_list, pool_datastack_create(), &content_types) ) {
+		sieve_runtime_trace_error(renv, "invalid content-type-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "BODY action");
+
+	/* Extract requested parts */
+
+	if ( transform == TST_BODY_TRANSFORM_RAW ) {
+		if ( !ext_body_get_raw(renv, &body_parts) ) {
+			return SIEVE_EXEC_FAILURE;
+		}
+	} else {
+		if ( !ext_body_get_content
+			(renv, content_types, TRUE, &body_parts) ) {
+			return SIEVE_EXEC_FAILURE;
+		}
+	}
+
+	/* Disable match values processing as required by RFC */
+
+	mvalues_active = sieve_match_values_set_enabled(renv->interp, FALSE);
+
+	/* Iterate through all requested body parts to match */
+
+	matched = FALSE;
+	mctx = sieve_match_begin(renv->interp, &mtch, &cmp, NULL, key_list);
+	while ( !matched && body_parts->content != NULL ) {
+		if ( (mret=sieve_match_value(mctx, body_parts->content, body_parts->size))
+			< 0)
+		{
+			sieve_runtime_trace_error(renv, "invalid string list item");
+			ret = SIEVE_EXEC_BIN_CORRUPT;
+			break;
+		}
+
+		matched = ( mret > 0 );
+		body_parts++;
+	}
+
+	if ( (mret=sieve_match_end(&mctx)) < 0 ) {
+		sieve_runtime_trace_error(renv, "invalid string list item");
+		ret = SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		matched = ( mret > 0 || matched );
+
+	/* Restore match values processing */
+
+	(void)sieve_match_values_set_enabled(renv->interp, mvalues_active);
+
+	/* Set test result */
+
+	if ( ret == SIEVE_EXEC_OK )
+		sieve_interpreter_set_test_result(renv->interp, matched);
+
+	return ret;
+}
Index: b/sieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_comparator-i-ascii-numeric.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_comparator_i_ascii_numeric_la_SOURCES = \
+	ext-cmp-i-ascii-numeric.c
Index: b/sieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.in
@@ -0,0 +1,483 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/comparator-i-ascii-numeric
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_comparator_i_ascii_numeric_la_LIBADD =
+am_libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS =  \
+	ext-cmp-i-ascii-numeric.lo
+libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS =  \
+	$(am_libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_comparator_i_ascii_numeric_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_comparator_i_ascii_numeric_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_comparator-i-ascii-numeric.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_comparator_i_ascii_numeric_la_SOURCES = \
+	ext-cmp-i-ascii-numeric.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_comparator-i-ascii-numeric.la: $(libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS) $(libsieve_ext_comparator_i_ascii_numeric_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_comparator_i_ascii_numeric_la_OBJECTS) $(libsieve_ext_comparator_i_ascii_numeric_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-cmp-i-ascii-numeric.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c
@@ -0,0 +1,163 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension comparator-i;ascii-numeric
+ * ------------------------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 2244
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-comparators.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include <ctype.h>
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_operand_def my_comparator_operand;
+
+const struct sieve_comparator_def i_ascii_numeric_comparator;
+
+/*
+ * Extension
+ */
+
+static bool ext_cmp_i_ascii_numeric_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *validator);
+
+const struct sieve_extension_def comparator_i_ascii_numeric_extension = {
+	"comparator-i;ascii-numeric",
+	NULL, NULL,
+	ext_cmp_i_ascii_numeric_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(my_comparator_operand)
+};
+
+static bool ext_cmp_i_ascii_numeric_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator)
+{
+	sieve_comparator_register(validator, ext, &i_ascii_numeric_comparator);
+	return TRUE;
+}
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_comparators =
+	SIEVE_EXT_DEFINE_COMPARATOR(i_ascii_numeric_comparator);
+
+static const struct sieve_operand_def my_comparator_operand = {
+	"comparator-i;ascii-numeric",
+	&comparator_i_ascii_numeric_extension,
+	0,
+	&sieve_comparator_operand_class,
+	&ext_comparators
+};
+
+/*
+ * Comparator
+ */
+
+/* Forward declarations */
+
+static int cmp_i_ascii_numeric_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+
+/* Comparator object */
+
+const struct sieve_comparator_def i_ascii_numeric_comparator = {
+	SIEVE_OBJECT("i;ascii-numeric", &my_comparator_operand, 0),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY,
+	cmp_i_ascii_numeric_compare,
+	NULL,
+	NULL
+};
+
+/* Comparator implementation */
+
+static int cmp_i_ascii_numeric_compare
+	(const struct sieve_comparator *cmp ATTR_UNUSED,
+		const char *val, size_t val_size, const char *key, size_t key_size)
+{
+	const char *vend = val + val_size;
+	const char *kend = key + key_size;
+	const char *vp = val;
+	const char *kp = key;
+	int digits, i;
+
+	/* RFC 4790: All input is valid; strings that do not start with a digit
+	 * represent positive infinity.
+	 */
+	if ( !i_isdigit(*vp) ) {
+		if ( i_isdigit(*kp) ) {
+			/* Value is greater */
+			return -1;
+		}
+	} else {
+		if ( !i_isdigit(*kp) ) {
+			/* Value is less */
+			return -1;
+		}
+	}
+
+	/* Ignore leading zeros */
+
+	while ( *vp == '0' && vp < vend )
+		vp++;
+
+	while ( *kp == '0' && kp < kend )
+		kp++;
+
+	/* Check whether both numbers are equally long in terms of digits */
+
+	digits = 0;
+	while ( vp < vend && kp < kend && i_isdigit(*vp) && i_isdigit(*kp) ) {
+		vp++;
+		kp++;
+		digits++;
+	}
+
+	if ( vp == vend || !i_isdigit(*vp) ) {
+		if ( kp != kend && i_isdigit(*kp) ) {
+			/* Value is less */
+			return -1;
+		}
+	} else {
+		/* Value is greater */
+		return 1;
+	}
+
+	/* Equally long: compare digits */
+
+	vp -= digits;
+	kp -= digits;
+	i = 0;
+	while ( i < digits ) {
+		if ( *vp > *kp )
+			return 1;
+		else if ( *vp < *kp )
+			return -1;
+
+		kp++;
+		vp++;
+		i++;
+	}
+
+	return 0;
+}
+
Index: b/sieve/src/lib-sieve/plugins/copy/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/copy/Makefile.am
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_copy.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_copy_la_SOURCES = \
+	ext-copy.c
Index: b/sieve/src/lib-sieve/plugins/copy/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/copy/Makefile.in
@@ -0,0 +1,481 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/copy
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_copy_la_LIBADD =
+am_libsieve_ext_copy_la_OBJECTS = ext-copy.lo
+libsieve_ext_copy_la_OBJECTS = $(am_libsieve_ext_copy_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_copy_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_copy_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_copy.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_copy_la_SOURCES = \
+	ext-copy.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/copy/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/copy/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_copy.la: $(libsieve_ext_copy_la_OBJECTS) $(libsieve_ext_copy_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_copy_la_OBJECTS) $(libsieve_ext_copy_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-copy.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/copy/ext-copy.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/copy/ext-copy.c
@@ -0,0 +1,175 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension copy
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 3894
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_argument_def copy_tag;
+static const struct sieve_operand_def copy_side_effect_operand;
+
+/*
+ * Extension
+ */
+
+static bool ext_copy_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def copy_extension = {
+	"copy",
+	NULL, NULL,
+	ext_copy_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(copy_side_effect_operand)
+};
+
+static bool ext_copy_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register copy tag with redirect and fileinto commands and we don't care
+	 * whether these commands are registered or even whether they will be
+	 * registered at all. The validator handles either situation gracefully
+	 */
+	sieve_validator_register_external_tag
+		(valdtr, "redirect", ext, &copy_tag, SIEVE_OPT_SIDE_EFFECT);
+	sieve_validator_register_external_tag
+		(valdtr, "fileinto", ext, &copy_tag, SIEVE_OPT_SIDE_EFFECT);
+
+	return TRUE;
+}
+
+/*
+ * Side effect
+ */
+
+static void seff_copy_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+static void seff_copy_post_commit
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+
+const struct sieve_side_effect_def copy_side_effect = {
+	SIEVE_OBJECT("copy", &copy_side_effect_operand, 0),
+	&act_store,
+	NULL, NULL, NULL,
+	seff_copy_print,
+	NULL, NULL,
+	seff_copy_post_commit,
+	NULL
+};
+
+/*
+ * Tagged argument
+ */
+
+static bool tag_copy_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_copy_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command *cmd);
+
+static const struct sieve_argument_def copy_tag = {
+	"copy",
+	NULL,
+	tag_copy_validate,
+	NULL, NULL,
+	tag_copy_generate
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(copy_side_effect);
+
+static const struct sieve_operand_def copy_side_effect_operand = {
+	"copy operand",
+	&copy_extension,
+	0,
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/*
+ * Tag validation
+ */
+
+static bool tag_copy_validate
+	(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_ast_argument **arg ATTR_UNUSED,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool tag_copy_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit
+		(cgenv->sbin, sieve_argument_ext(arg), &copy_side_effect);
+
+	return TRUE;
+}
+
+/*
+ * Side effect implementation
+ */
+
+static void seff_copy_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_result_print_env *rpenv, bool *keep)
+{
+	sieve_result_seffect_printf(rpenv, "preserve implicit keep");
+
+	*keep = TRUE;
+}
+
+static void seff_copy_post_commit
+(const struct sieve_side_effect *seffect ATTR_UNUSED,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv ATTR_UNUSED,
+		void *tr_context ATTR_UNUSED, bool *keep)
+{
+	*keep = TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/date/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/date/Makefile.am
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_date.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tests = \
+	tst-date.c
+
+libsieve_ext_date_la_SOURCES = \
+	$(tests) \
+	ext-date-common.c \
+	ext-date.c
+
+noinst_HEADERS = \
+	ext-date-common.h
Index: b/sieve/src/lib-sieve/plugins/date/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/date/Makefile.in
@@ -0,0 +1,496 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/date
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_date_la_LIBADD =
+am__objects_1 = tst-date.lo
+am_libsieve_ext_date_la_OBJECTS = $(am__objects_1) ext-date-common.lo \
+	ext-date.lo
+libsieve_ext_date_la_OBJECTS = $(am_libsieve_ext_date_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_date_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_date_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_date.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tests = \
+	tst-date.c
+
+libsieve_ext_date_la_SOURCES = \
+	$(tests) \
+	ext-date-common.c \
+	ext-date.c
+
+noinst_HEADERS = \
+	ext-date-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/date/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/date/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_date.la: $(libsieve_ext_date_la_OBJECTS) $(libsieve_ext_date_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_date_la_OBJECTS) $(libsieve_ext_date_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-date-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-date.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-date.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/date/ext-date-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/date/ext-date-common.c
@@ -0,0 +1,466 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "utc-offset.h"
+
+#include "sieve-common.h"
+#include "sieve-interpreter.h"
+#include "sieve-message.h"
+
+#include "ext-date-common.h"
+
+#include <time.h>
+#include <ctype.h>
+
+struct ext_date_context {
+	time_t current_date;
+	int zone_offset;
+};
+
+/*
+ * Runtime initialization
+ */
+
+static void ext_date_runtime_init
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	void *context ATTR_UNUSED)
+{
+	struct ext_date_context *dctx;
+	pool_t pool;
+	struct tm *tm;
+	time_t current_date;
+	int zone_offset;
+
+	/* Get current time at instance main script is started */
+	time(&current_date);
+
+	tm = localtime(&current_date);
+	zone_offset = utc_offset(tm, current_date);
+
+	/* Create context */
+	pool = sieve_message_context_pool(renv->msgctx);
+	dctx = p_new(pool, struct ext_date_context, 1);
+	dctx->current_date = current_date;
+	dctx->zone_offset = zone_offset;
+
+	sieve_message_context_extension_set
+		(renv->msgctx, ext, (void *) dctx);
+}
+
+static struct sieve_interpreter_extension date_interpreter_extension = {
+	&date_extension,
+	ext_date_runtime_init,
+	NULL,
+};
+
+bool ext_date_interpreter_load
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	/* Register runtime hook to obtain stript start timestamp */
+	if ( renv->msgctx == NULL ||
+		sieve_message_context_extension_get(renv->msgctx, ext) == NULL ) {
+		sieve_interpreter_extension_register
+			(renv->interp, ext, &date_interpreter_extension, NULL);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Zone string
+ */
+
+bool ext_date_parse_timezone
+(const char *zone, int *zone_offset_r)
+{
+	const unsigned char *str = (const unsigned char *) zone;
+	size_t len = strlen(zone);
+
+	if (len == 5 && (*str == '+' || *str == '-')) {
+		int offset;
+
+		if (!i_isdigit(str[1]) || !i_isdigit(str[2]) ||
+		    !i_isdigit(str[3]) || !i_isdigit(str[4]))
+			return FALSE;
+
+		offset = ((str[1]-'0') * 10 + (str[2]-'0')) * 60  +
+			(str[3]-'0') * 10 + (str[4]-'0');
+
+		if ( zone_offset_r != NULL )
+			*zone_offset_r = *str == '+' ? offset : -offset;
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/*
+ * Current date
+ */
+
+time_t ext_date_get_current_date
+(const struct sieve_runtime_env *renv, int *zone_offset_r)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct ext_date_context *dctx = (struct ext_date_context *)
+		sieve_message_context_extension_get(renv->msgctx, this_ext);
+
+	if ( dctx == NULL ) {
+		ext_date_runtime_init(this_ext, renv, NULL);
+		dctx = (struct ext_date_context *)
+			sieve_message_context_extension_get(renv->msgctx, this_ext);
+
+		i_assert(dctx != NULL);
+	}
+
+	/* Read script start timestamp from message context */
+
+	if ( zone_offset_r != NULL )
+		*zone_offset_r = dctx->zone_offset;
+
+	return dctx->current_date;
+}
+
+/*
+ * Date parts
+ */
+
+/* "year"      => the year, "0000" .. "9999".
+ */
+
+static const char *ext_date_year_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part year_date_part = {
+	"year",
+	ext_date_year_part_get
+};
+
+/* "month"     => the month, "01" .. "12".
+ */
+
+static const char *ext_date_month_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part month_date_part = {
+	"month",
+	ext_date_month_part_get
+};
+
+/* "day"       => the day, "01" .. "31".
+ */
+
+static const char *ext_date_day_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part day_date_part = {
+	"day",
+	ext_date_day_part_get
+};
+
+/* "date"      => the date in "yyyy-mm-dd" format.
+ */
+
+static const char *ext_date_date_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part date_date_part = {
+	"date",
+	ext_date_date_part_get
+};
+
+/* "julian"    => the Modified Julian Day, that is, the date
+ *              expressed as an integer number of days since
+ *              00:00 UTC on November 17, 1858 (using the Gregorian
+ *              calendar).  This corresponds to the regular
+ *              Julian Day minus 2400000.5.  Sample routines to
+ *              convert to and from modified Julian dates are
+ *              given in Appendix A.
+ */
+
+static const char *ext_date_julian_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part julian_date_part = {
+	"julian",
+	ext_date_julian_part_get
+};
+
+/* "hour"      => the hour, "00" .. "23".
+ */
+static const char *ext_date_hour_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part hour_date_part = {
+	"hour",
+	ext_date_hour_part_get
+};
+
+/* "minute"    => the minute, "00" .. "59".
+ */
+static const char *ext_date_minute_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part minute_date_part = {
+	"minute",
+	ext_date_minute_part_get
+};
+
+/* "second"    => the second, "00" .. "60".
+ */
+static const char *ext_date_second_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part second_date_part = {
+	"second",
+	ext_date_second_part_get
+};
+
+/* "time"      => the time in "hh:mm:ss" format.
+ */
+static const char *ext_date_time_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part time_date_part = {
+	"time",
+	ext_date_time_part_get
+};
+
+/* "iso8601"   => the date and time in restricted ISO 8601 format.
+ */
+static const char *ext_date_iso8601_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part iso8601_date_part = {
+	"iso8601",
+	ext_date_iso8601_part_get
+};
+
+/* "std11"     => the date and time in a format appropriate
+ *                for use in a Date: header field [RFC2822].
+ */
+static const char *ext_date_std11_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part std11_date_part = {
+	"std11",
+	ext_date_std11_part_get
+};
+
+/* "zone"      => the time zone in use.  If the user specified a
+ *                time zone with ":zone", "zone" will
+ *                contain that value.  If :originalzone is specified
+ *                this value will be the original zone specified
+ *                in the date-time value.  If neither argument is
+ *                specified the value will be the server's default
+ *                time zone in offset format "+hhmm" or "-hhmm".  An
+ *                 offset of 0 (Zulu) always has a positive sign.
+ */
+static const char *ext_date_zone_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part zone_date_part = {
+	"zone",
+	ext_date_zone_part_get
+};
+
+/* "weekday"   => the day of the week expressed as an integer between
+ *                "0" and "6". "0" is Sunday, "1" is Monday, etc.
+ */
+static const char *ext_date_weekday_part_get(struct tm *tm, int zone_offset);
+
+static const struct ext_date_part weekday_date_part = {
+	"weekday",
+	ext_date_weekday_part_get
+};
+
+/*
+ * Date part extraction
+ */
+
+static const struct ext_date_part *date_parts[] = {
+	&year_date_part, &month_date_part, &day_date_part, &date_date_part,
+	&julian_date_part, &hour_date_part, &minute_date_part, &second_date_part,
+	&time_date_part, &iso8601_date_part, &std11_date_part, &zone_date_part,
+	&weekday_date_part
+};
+
+unsigned int date_parts_count = N_ELEMENTS(date_parts);
+
+const char *ext_date_part_extract
+(const char *part, struct tm *tm, int zone_offset)
+{
+	unsigned int i;
+
+	for ( i = 0; i < date_parts_count; i++ ) {
+		if ( strcasecmp(date_parts[i]->identifier, part) == 0 ) {
+			if ( date_parts[i]->get_string != NULL )
+				return date_parts[i]->get_string(tm, zone_offset);
+
+			return NULL;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * Date part implementations
+ */
+
+static const char *month_names[] = {
+	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+};
+
+static const char *weekday_names[] = {
+	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
+};
+
+static const char *ext_date_year_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%04d", tm->tm_year + 1900);
+}
+
+static const char *ext_date_month_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_mon + 1);
+}
+
+static const char *ext_date_day_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_mday);
+}
+
+static const char *ext_date_date_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%04d-%02d-%02d",
+		tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday);
+}
+
+static const char *ext_date_julian_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	int year = tm->tm_year+1900;
+	int month = tm->tm_mon+1;
+	int day = tm->tm_mday;
+	int c, ya, jd;
+
+	/* Modified from RFC 5260 Appendix A */
+
+	if ( month > 2 )
+		month -= 3;
+	else {
+		month += 9;
+		year--;
+	}
+
+	c = year / 100;
+	ya = year - c * 100;
+
+	jd = c * 146097 / 4 + ya * 1461 / 4 + (month * 153 + 2) / 5 + day + 1721119;
+
+	return t_strdup_printf("%d", jd - 2400001);
+}
+
+static const char *ext_date_hour_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_hour);
+}
+
+static const char *ext_date_minute_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_min);
+}
+
+static const char *ext_date_second_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d", tm->tm_sec);
+}
+
+static const char *ext_date_time_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%02d:%02d:%02d", tm->tm_hour, tm->tm_min, tm->tm_sec);
+}
+
+static const char *ext_date_iso8601_part_get
+(struct tm *tm, int zone_offset)
+{
+	const char *time_offset;
+
+	/*
+	 * RFC 3339: 5.6. Internet Date/Time Format
+	 *
+	 * The following profile of ISO 8601 [ISO8601] dates SHOULD be used in
+	 * new protocols on the Internet.  This is specified using the syntax
+	 * description notation defined in [ABNF].
+	 *
+	 * date-fullyear   = 4DIGIT
+	 * date-month      = 2DIGIT  ; 01-12
+	 * date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
+	 * 		                     ; month/year
+	 * time-hour       = 2DIGIT  ; 00-23
+	 * time-minute     = 2DIGIT  ; 00-59
+	 * time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
+	 * 		                     ; rules
+	 * time-secfrac    = "." 1*DIGIT
+	 * time-numoffset  = ("+" / "-") time-hour ":" time-minute
+	 * time-offset     = "Z" / time-numoffset
+	 *
+	 * partial-time    = time-hour ":" time-minute ":" time-second
+	 * 		             [time-secfrac]
+	 * full-date       = date-fullyear "-" date-month "-" date-mday
+	 * full-time       = partial-time time-offset
+	 *
+	 * date-time       = full-date "T" full-time
+	 *
+	 */
+
+	if ( zone_offset == 0 )
+		time_offset = "Z";
+	else {
+		int offset = zone_offset > 0 ? zone_offset : -zone_offset;
+
+		time_offset = t_strdup_printf
+			("%c%02d:%02d", (zone_offset > 0 ? '+' : '-'), offset / 60, offset % 60);
+	}
+
+	return t_strdup_printf("%04d-%02d-%02dT%02d:%02d:%02d%s",
+		tm->tm_year + 1900, tm->tm_mon+1, tm->tm_mday, tm->tm_hour, tm->tm_min,
+		tm->tm_sec, time_offset);
+}
+
+static const char *ext_date_std11_part_get
+(struct tm *tm, int zone_offset)
+{
+	return t_strdup_printf("%s, %02d %s %04d %02d:%02d:%02d %s",
+		weekday_names[tm->tm_wday],
+		tm->tm_mday,
+		month_names[tm->tm_mon],
+		tm->tm_year+1900,
+		tm->tm_hour, tm->tm_min, tm->tm_sec,
+		ext_date_zone_part_get(tm, zone_offset));
+}
+
+static const char *ext_date_zone_part_get
+(struct tm *tm ATTR_UNUSED, int zone_offset)
+{
+	bool negative;
+	int offset = zone_offset;
+
+	if (zone_offset >= 0)
+		negative = FALSE;
+	else {
+		negative = TRUE;
+		offset = -offset;
+	}
+
+	return t_strdup_printf
+		("%c%02d%02d", negative ? '-' : '+', offset / 60, offset % 60);
+}
+
+static const char *ext_date_weekday_part_get
+(struct tm *tm, int zone_offset ATTR_UNUSED)
+{
+	return t_strdup_printf("%d", tm->tm_wday);
+}
+
Index: b/sieve/src/lib-sieve/plugins/date/ext-date-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/date/ext-date-common.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_DATE_COMMON_H
+#define __EXT_DATE_COMMON_H
+
+#include "sieve-common.h"
+
+#include <time.h>
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def date_extension;
+
+bool ext_date_interpreter_load
+	(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+		sieve_size_t *address ATTR_UNUSED);
+
+/*
+ * Tests
+ */
+
+extern const struct sieve_command_def date_test;
+extern const struct sieve_command_def currentdate_test;
+
+/*
+ * Operations
+ */
+
+enum ext_date_opcode {
+	EXT_DATE_OPERATION_DATE,
+	EXT_DATE_OPERATION_CURRENTDATE
+};
+
+extern const struct sieve_operation_def date_operation;
+extern const struct sieve_operation_def currentdate_operation;
+
+/*
+ * Zone string
+ */
+
+bool ext_date_parse_timezone(const char *zone, int *zone_offset_r);
+
+/*
+ * Current date
+ */
+
+time_t ext_date_get_current_date
+	(const struct sieve_runtime_env *renv, int *zone_offset_r);
+
+/*
+ * Date part
+ */
+
+struct ext_date_part {
+	const char *identifier;
+
+	const char *(*get_string)(struct tm *tm, int zone_offset);
+};
+
+const char *ext_date_part_extract
+	(const char *part, struct tm *tm, int zone_offset);
+
+#endif /* __EXT_DATE_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/date/ext-date.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/date/ext-date.c
@@ -0,0 +1,66 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension date
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5260
+ * Implementation: full
+ * Status: experimental
+ *
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-date-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_date_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator);
+
+const struct sieve_operation_def *ext_date_operations[] = {
+	&date_operation,
+	&currentdate_operation
+};
+
+const struct sieve_extension_def date_extension = {
+	"date",
+	NULL, NULL,
+	ext_date_validator_load,
+	NULL,
+	ext_date_interpreter_load,
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_date_operations),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_date_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new test */
+	sieve_validator_register_command(valdtr, ext, &date_test);
+	sieve_validator_register_command(valdtr, ext, &currentdate_test);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/date/tst-date.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/date/tst-date.c
@@ -0,0 +1,547 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-date-common.h"
+
+#include <time.h>
+
+/*
+ * Tests
+ */
+
+static bool tst_date_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_date_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+/* Date test
+ *
+ * Syntax:
+ *    date [<":zone" <time-zone: string>> / ":originalzone"]
+ *         [COMPARATOR] [MATCH-TYPE] <header-name: string>
+ *         <date-part: string> <key-list: string-list>
+ */
+
+static bool tst_date_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+
+const struct sieve_command_def date_test = {
+	"date",
+	SCT_TEST,
+	3, 0, FALSE, FALSE,
+	tst_date_registered,
+	NULL,
+	tst_date_validate,
+	tst_date_generate,
+	NULL
+};
+
+/* Currentdate test
+ *
+ * Syntax:
+ *    currentdate [":zone" <time-zone: string>]
+ *                [COMPARATOR] [MATCH-TYPE]
+ *                <date-part: string> <key-list: string-list>
+ */
+
+static bool tst_currentdate_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+
+const struct sieve_command_def currentdate_test = {
+	"currentdate",
+	SCT_TEST,
+	2, 0, FALSE, FALSE,
+	tst_currentdate_registered,
+	NULL,
+	tst_date_validate,
+	tst_date_generate,
+	NULL
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Forward declarations */
+
+static bool tag_zone_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_zone_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument_def date_zone_tag = {
+ 	"zone",
+	NULL,
+	tag_zone_validate,
+	NULL, NULL,
+	tag_zone_generate
+};
+
+static const struct sieve_argument_def date_originalzone_tag = {
+	"originalzone",
+	NULL,
+	tag_zone_validate,
+	NULL, NULL,
+	tag_zone_generate
+};
+
+/*
+ * Date operation
+ */
+
+static bool tst_date_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_date_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def date_operation = {
+	"DATE",
+	&date_extension,
+	EXT_DATE_OPERATION_DATE,
+	tst_date_operation_dump,
+	tst_date_operation_execute
+};
+
+const struct sieve_operation_def currentdate_operation = {
+	"CURRENTDATE",
+	&date_extension,
+	EXT_DATE_OPERATION_CURRENTDATE,
+	tst_date_operation_dump,
+	tst_date_operation_execute
+};
+
+/*
+ * Optional operands
+ */
+
+enum tst_date_optional {
+	OPT_DATE_ZONE = SIEVE_MATCH_OPT_LAST,
+	OPT_DATE_LAST
+};
+
+/*
+ * Tag implementation
+ */
+
+static bool tag_zone_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+    struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	if ( (bool) cmd->data ) {
+		if ( sieve_command_is(cmd, date_test) ) {
+			sieve_argument_validate_error(valdtr, *arg,
+				"multiple :zone or :originalzone arguments specified for "
+				"the currentdate test");
+		} else {
+			sieve_argument_validate_error(valdtr, *arg,
+				"multiple :zone arguments specified for the currentdate test");
+		}
+		return FALSE;
+	}
+
+	/* Skip tag */
+ 	*arg = sieve_ast_argument_next(*arg);
+
+	/* :content tag has a string-list argument */
+	if ( sieve_argument_is(tag, date_zone_tag) ) {
+
+		/* Check syntax:
+		 *   :zone <time-zone: string>
+		 */
+		if ( !sieve_validate_tag_parameter
+			(valdtr, cmd, tag, *arg, SAAT_STRING) ) {
+			return FALSE;
+		}
+
+		/* Check it */
+		if ( sieve_argument_is_string_literal(*arg) ) {
+			const char *zone = sieve_ast_argument_strc(*arg);
+
+			if ( !ext_date_parse_timezone(zone, NULL) ) {
+				sieve_argument_validate_warning(valdtr, *arg,
+					"specified :zone argument '%s' is not a valid timezone",
+					str_sanitize(zone, 40));
+			}
+		}
+
+		/* Assign tag parameters */
+		tag->parameters = *arg;
+		*arg = sieve_ast_arguments_detach(*arg,1);
+	}
+
+	cmd->data = (void *) TRUE;
+
+	return TRUE;
+}
+
+/*
+ * Test registration
+ */
+
+static bool tst_date_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &date_zone_tag, OPT_DATE_ZONE);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &date_originalzone_tag, OPT_DATE_ZONE);
+
+	return TRUE;
+}
+
+static bool tst_currentdate_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &date_zone_tag, OPT_DATE_ZONE);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool tst_date_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	unsigned int arg_offset = 0 ;
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+
+	/* Check header name */
+
+	if ( sieve_command_is(tst, date_test) ) {
+		arg_offset = 1;
+
+		if ( !sieve_validate_positional_argument
+			(valdtr, tst, arg, "header name", 1, SAAT_STRING) ) {
+			return FALSE;
+		}
+
+		if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+			return FALSE;
+
+		if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+    	    return FALSE;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Check date part */
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "date part", arg_offset + 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	/* Check key list */
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", arg_offset + 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_date_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	if ( sieve_command_is(tst, date_test) )
+		sieve_operation_emit(cgenv->sbin, tst->ext, &date_operation);
+	else if ( sieve_command_is(tst, currentdate_test) )
+		sieve_operation_emit(cgenv->sbin, tst->ext, &currentdate_operation);
+	else
+		i_unreached();
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+static bool tag_zone_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command *cmd)
+{
+	if ( arg->parameters == NULL ) {
+		sieve_opr_omitted_emit(cgenv->sbin);
+		return TRUE;
+	}
+
+	return sieve_generate_argument_parameters(cgenv, cmd, arg);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_date_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+	const struct sieve_operation *op = &denv->oprtn;
+	struct sieve_operand operand;
+
+	sieve_code_dumpf(denv, "%s", sieve_operation_mnemonic(op));
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+  do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_DATE_ZONE:
+			if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+				sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+				return FALSE;
+			}
+
+			if ( sieve_operand_is_omitted(&operand) ) {
+				sieve_code_dumpf(denv, "zone: ORIGINAL");
+			} else {
+				if ( !sieve_opr_string_dump_data
+					(denv, &operand, address, "zone") )
+					return FALSE;
+			}
+			break;
+    default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	if ( sieve_operation_is(op, date_operation) &&
+		!sieve_opr_string_dump(denv, address, "header name") )
+		return FALSE;
+
+	return
+		sieve_opr_string_dump(denv, address, "date part") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_date_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &renv->oprtn;
+	bool result = TRUE, zone_specified = FALSE, got_date = FALSE, matched = FALSE;
+	int opt_code = 0;
+	const struct sieve_message_data *msgdata = renv->msgdata;
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_operand operand;
+	struct sieve_match_context *mctx;
+	string_t *header_name = NULL, *date_part = NULL, *zone = NULL;
+	struct sieve_coded_stringlist *key_list;
+	time_t date_value, local_time;
+	struct tm *date_tm;
+	const char *part_value;
+	int local_zone = 0, original_zone = 0, wanted_zone = 0;
+	int ret;
+
+	/* Read optional operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_DATE_ZONE:
+			if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+				sieve_runtime_trace_error(renv, "invalid operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			if ( !sieve_operand_is_omitted(&operand) ) {
+				if ( !sieve_opr_string_read_data
+					(renv, &operand, address, &zone) ) {
+					sieve_runtime_trace_error(renv, "invalid zone operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			}
+
+			zone_specified = TRUE;
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "unknown optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+
+	if ( sieve_operation_is(op, date_operation) ) {
+		/* Read header name */
+		if ( !sieve_opr_string_read(renv, address, &header_name) ) {
+			sieve_runtime_trace_error(renv, "invalid header-name operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	}
+
+	/* Read date part */
+	if ( !sieve_opr_string_read(renv, address, &date_part) ) {
+		sieve_runtime_trace_error(renv, "invalid date-part operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Perform test */
+
+	sieve_runtime_trace(renv, "%s test", sieve_operation_mnemonic(op));
+
+	/* Get the date value */
+
+	local_time = ext_date_get_current_date(renv, &local_zone);
+
+	if ( sieve_operation_is(op, date_operation) ) {
+		const char *header_value;
+		const char *date_string;
+
+		/* Get date from the message */
+
+		/* Read first header
+		 *   NOTE: need something for index extension to hook into some time.
+		 */
+		if ( (ret=mail_get_first_header
+			(msgdata->mail, str_c(header_name), &header_value)) > 0 ) {
+
+			/* Extract the date string value */
+			date_string = strrchr(header_value, ';');
+			if ( date_string == NULL )
+				/* Direct header value */
+				date_string = header_value;
+			else {
+				/* Delimited by ';', e.g. a Received: header */
+				date_string++;
+			}
+
+			/* Parse the date value */
+			if ( message_date_parse((const unsigned char *) date_string,
+				strlen(date_string), &date_value, &original_zone) ) {
+				got_date = TRUE;
+			}
+		}
+	} else if ( sieve_operation_is(op, currentdate_operation) ) {
+		/* Use time stamp recorded at the time the script first started */
+
+		date_value = local_time;
+		original_zone = local_zone;
+		got_date = TRUE;
+
+	} else {
+		i_unreached();
+	}
+
+	if ( got_date ) {
+		/* Apply wanted timezone */
+
+		if ( !zone_specified )
+			wanted_zone = local_zone;
+		else if ( zone == NULL
+			|| !ext_date_parse_timezone(str_c(zone), &wanted_zone) ) {
+
+			/* FIXME: warn about parse failures */
+			wanted_zone = original_zone;
+		}
+
+		date_value += wanted_zone * 60;
+
+		/* Convert timestamp to struct tm */
+
+		if ( (date_tm=gmtime(&date_value)) == NULL ) {
+			got_date = FALSE;
+		} else {
+			/* Extract the date part */
+			part_value = ext_date_part_extract
+				(str_c(date_part), date_tm, wanted_zone);
+		}
+	}
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+	if ( got_date && part_value != NULL ) {
+		/* Match value */
+		if ( (ret=sieve_match_value(mctx, part_value, strlen(part_value))) < 0 )
+			result = FALSE;
+		else
+			matched = ret > 0;
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/plugins/enotify/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/Makefile.am
@@ -0,0 +1,36 @@
+noinst_LTLIBRARIES = libsieve_ext_enotify.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-notify.c
+
+tests = \
+	tst-valid-notify-method.c \
+	tst-notify-method-capability.c
+
+var_modifiers = \
+	vmodf-encodeurl.c
+
+notify_methods = \
+	ntfy-mailto.c
+
+libsieve_ext_enotify_la_SOURCES = \
+	ext-enotify.c \
+	ext-enotify-common.c \
+	$(commands) \
+	$(tests) \
+	$(var_modifiers) \
+	$(notify_methods)
+
+noinst_HEADERS = \
+	sieve-ext-enotify.h \
+	ext-enotify-limits.h \
+	ext-enotify-common.h
+
Index: b/sieve/src/lib-sieve/plugins/enotify/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/Makefile.in
@@ -0,0 +1,522 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/enotify
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_enotify_la_LIBADD =
+am__objects_1 = cmd-notify.lo
+am__objects_2 = tst-valid-notify-method.lo \
+	tst-notify-method-capability.lo
+am__objects_3 = vmodf-encodeurl.lo
+am__objects_4 = ntfy-mailto.lo
+am_libsieve_ext_enotify_la_OBJECTS = ext-enotify.lo \
+	ext-enotify-common.lo $(am__objects_1) $(am__objects_2) \
+	$(am__objects_3) $(am__objects_4)
+libsieve_ext_enotify_la_OBJECTS =  \
+	$(am_libsieve_ext_enotify_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_enotify_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_enotify_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_enotify.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-notify.c
+
+tests = \
+	tst-valid-notify-method.c \
+	tst-notify-method-capability.c
+
+var_modifiers = \
+	vmodf-encodeurl.c
+
+notify_methods = \
+	ntfy-mailto.c
+
+libsieve_ext_enotify_la_SOURCES = \
+	ext-enotify.c \
+	ext-enotify-common.c \
+	$(commands) \
+	$(tests) \
+	$(var_modifiers) \
+	$(notify_methods)
+
+noinst_HEADERS = \
+	sieve-ext-enotify.h \
+	ext-enotify-limits.h \
+	ext-enotify-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/enotify/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/enotify/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_enotify.la: $(libsieve_ext_enotify_la_OBJECTS) $(libsieve_ext_enotify_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_enotify_la_OBJECTS) $(libsieve_ext_enotify_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-notify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-enotify-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-enotify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ntfy-mailto.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-notify-method-capability.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-valid-notify-method.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vmodf-encodeurl.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/enotify/cmd-notify.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/cmd-notify.c
@@ -0,0 +1,592 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_argument_def notify_importance_tag;
+static const struct sieve_argument_def notify_from_tag;
+static const struct sieve_argument_def notify_options_tag;
+static const struct sieve_argument_def notify_message_tag;
+
+/*
+ * Notify command
+ *
+ * Syntax:
+ *    notify [":from" string]
+ *           [":importance" <"1" / "2" / "3">]
+ *           [":options" string-list]
+ *           [":message" string]
+ *           <method: string>
+ */
+
+static bool cmd_notify_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_notify_pre_validate
+	(struct sieve_validator *validator, struct sieve_command *cmd);
+static bool cmd_notify_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_notify_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def notify_command = {
+	"notify",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	cmd_notify_registered,
+	cmd_notify_pre_validate,
+	cmd_notify_validate,
+	cmd_notify_generate,
+	NULL
+};
+
+/*
+ * Notify command tags
+ */
+
+/* Forward declarations */
+
+static bool cmd_notify_validate_string_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_notify_validate_stringlist_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_notify_validate_importance_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument_def notify_from_tag = {
+	"from",
+	NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def notify_options_tag = {
+	"options",
+	NULL,
+	cmd_notify_validate_stringlist_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def notify_message_tag = {
+	"message",
+	NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def notify_importance_tag = {
+	"importance",
+	NULL,
+	cmd_notify_validate_importance_tag,
+	NULL, NULL, NULL
+};
+
+/*
+ * Notify operation
+ */
+
+static bool cmd_notify_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_notify_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def notify_operation = {
+	"NOTIFY",
+	&enotify_extension,
+	EXT_ENOTIFY_OPERATION_NOTIFY,
+	cmd_notify_operation_dump,
+	cmd_notify_operation_execute
+};
+
+/*
+ * Notify action
+ */
+
+/* Forward declarations */
+
+static int act_notify_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+static void act_notify_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		bool *keep);
+static bool act_notify_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv,
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action_def act_notify = {
+	"notify",
+	0,
+	NULL,
+	act_notify_check_duplicate,
+	NULL,
+	act_notify_print,
+	NULL, NULL,
+	act_notify_commit,
+	NULL
+};
+
+/*
+ * Command validation context
+ */
+
+struct cmd_notify_context_data {
+	struct sieve_ast_argument *from;
+	struct sieve_ast_argument *message;
+	struct sieve_ast_argument *options;
+};
+
+/*
+ * Tag validation
+ */
+
+static bool cmd_notify_validate_string_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :from <string>
+	 *   :message <string>
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING) )
+		return FALSE;
+
+	if ( sieve_argument_is(tag, notify_from_tag) ) {
+		ctx_data->from = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+
+	} else if ( sieve_argument_is(tag, notify_message_tag) ) {
+		ctx_data->message = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+	}
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate_stringlist_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :options string-list
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) )
+		return FALSE;
+
+	/* Assign context */
+	ctx_data->options = *arg;
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate_importance_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	const struct sieve_ast_argument *tag = *arg;
+	const char *impstr;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :importance <"1" / "2" / "3">
+	 */
+
+	if ( sieve_ast_argument_type(*arg) != SAAT_STRING ) {
+		/* Not a string */
+		sieve_argument_validate_error(valdtr, *arg,
+			"the :importance tag for the notify command requires a string parameter, "
+			"but %s was found", sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+
+	impstr = sieve_ast_argument_strc(*arg);
+
+	if ( impstr[0] < '1' || impstr[0]  > '3' || impstr[1] != '\0' ) {
+		/* Invalid importance */
+		sieve_argument_validate_error(valdtr, *arg,
+			"invalid :importance value for notify command: %s", impstr);
+		return FALSE;
+	}
+
+	sieve_ast_argument_number_substitute(*arg, impstr[0] - '0');
+	(*arg)->argument = sieve_argument_create
+		((*arg)->ast, &number_argument, tag->argument->ext, tag->argument->id_code);
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+
+/*
+ * Command registration
+ */
+
+static bool cmd_notify_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_importance_tag, CMD_NOTIFY_OPT_IMPORTANCE);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_from_tag, CMD_NOTIFY_OPT_FROM);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_options_tag, CMD_NOTIFY_OPT_OPTIONS);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_message_tag, CMD_NOTIFY_OPT_MESSAGE);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_notify_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED,
+	struct sieve_command *cmd)
+{
+	struct cmd_notify_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd),
+		struct cmd_notify_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "method", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, arg, FALSE) )
+		return FALSE;
+
+	return ext_enotify_compile_check_arguments
+		(valdtr, cmd, arg, ctx_data->message, ctx_data->from, ctx_data->options);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_notify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &notify_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_notify_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 1;
+
+	sieve_code_dumpf(denv, "NOTIFY");
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case CMD_NOTIFY_OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			case CMD_NOTIFY_OPT_FROM:
+				if ( !sieve_opr_string_dump(denv, address, "from") )
+					return FALSE;
+				break;
+			case CMD_NOTIFY_OPT_OPTIONS:
+				if ( !sieve_opr_stringlist_dump(denv, address, "options") )
+					return FALSE;
+				break;
+			case CMD_NOTIFY_OPT_MESSAGE:
+				if ( !sieve_opr_string_dump(denv, address, "message") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	/* Dump reason and handle operands */
+	return
+		sieve_opr_string_dump(denv, address, "method");
+}
+
+/*
+ * Code execution
+ */
+
+static int cmd_notify_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct sieve_side_effects_list *slist = NULL;
+	struct sieve_enotify_action *act;
+	void *method_context;
+	pool_t pool;
+	int opt_code = 1, result = SIEVE_EXEC_OK;
+	sieve_number_t importance = 1;
+	struct sieve_coded_stringlist *options = NULL;
+	const struct sieve_enotify_method *method;
+	string_t *method_uri, *message = NULL, *from = NULL;
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands */
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case CMD_NOTIFY_OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 )
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			case CMD_NOTIFY_OPT_FROM:
+				if ( !sieve_opr_string_read(renv, address, &from) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case CMD_NOTIFY_OPT_MESSAGE:
+				if ( !sieve_opr_string_read(renv, address, &message) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case CMD_NOTIFY_OPT_OPTIONS:
+				if ( (options=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid options operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d",
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+
+	/* Reason operand */
+	if ( !sieve_opr_string_read(renv, address, &method_uri) ) {
+		sieve_runtime_trace_error(renv, "invalid method operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY action");
+
+	/* Check operands */
+
+	if ( (result=ext_enotify_runtime_check_operands
+		(renv, source_line, method_uri, message, from, options, &method,
+			&method_context)) )
+	{
+		/* Add notify action to the result */
+
+		pool = sieve_result_pool(renv->result);
+		act = p_new(pool, struct sieve_enotify_action, 1);
+		act->method = method;
+		act->method_context = method_context;
+		act->importance = importance;
+		if ( message != NULL )
+			act->message = p_strdup(pool, str_c(message));
+		if ( from != NULL )
+			act->from = p_strdup(pool, str_c(from));
+
+		return ( sieve_result_add_action
+			(renv, this_ext, &act_notify, slist, source_line, (void *) act, 0) >= 0 );
+	}
+
+	return result;
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_notify_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action *act ATTR_UNUSED,
+	const struct sieve_action *act_other ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *nact1, *nact2;
+	struct sieve_enotify_log nlog;
+
+	if ( act->context == NULL || act_other->context == NULL )
+		return 0;
+
+	nact1 = (const struct sieve_enotify_action *) act->context;
+	nact2 = (const struct sieve_enotify_action *) act_other->context;
+
+	if ( nact1->method == NULL || nact1->method->action_check_duplicates == NULL )
+		return 0;
+
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.location = act->location;
+	nlog.ehandler = sieve_result_get_error_handler(renv->result);
+
+	return nact1->method->action_check_duplicates
+		(&nlog, nact1->method_context, nact2->method_context, act_other->location);
+}
+
+/* Result printing */
+
+static void act_notify_print
+(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+	bool *keep ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *act =
+		(const struct sieve_enotify_action *) action->context;
+
+	sieve_result_action_printf
+		( rpenv, "send notification with method '%s:':", act->method->identifier);
+
+	if ( act->method->action_print != NULL ) {
+		struct sieve_enotify_print_env penv;
+
+		memset(&penv, 0, sizeof(penv));
+		penv.result_penv = rpenv;
+
+		act->method->action_print(&penv, act);
+	}
+}
+
+/* Result execution */
+
+static bool act_notify_commit
+(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv,
+	void *tr_context ATTR_UNUSED, bool *keep ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *act =
+		(const struct sieve_enotify_action *) action->context;
+	struct sieve_enotify_exec_env nenv;
+	struct sieve_enotify_log nlog;
+
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.aenv = aenv;
+
+	nenv.scriptenv = aenv->scriptenv;
+	nenv.msgdata = aenv->msgdata;
+	nenv.msgctx = aenv->msgctx;
+	nenv.notify_log = &nlog;
+
+	if ( act->method->action_execute != NULL )
+		return act->method->action_execute(&nenv, act);
+
+	return TRUE;
+}
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c
@@ -0,0 +1,639 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-enotify-limits.h"
+#include "ext-enotify-common.h"
+
+#include <ctype.h>
+
+/* FIXME: (from draft RFC)
+ *
+ * Header/envelope tests [Sieve] together with Sieve variables can be
+ * used to extract the list of users to receive notifications from the
+ * incoming email message or its envelope.  This is potentially quite
+ * dangerous, as this can be used for Deny Of Service attacks on
+ * recipients controlled by the message sender.  For this reason
+ * implementations SHOULD NOT allow use of variables containing values
+ * extracted from the email message in the method parameter to the
+ * notify action.  Note that violation of this SHOULD NOT may result in
+ * the creation of an open relay, i.e. any sender would be able to
+ * create specially crafted email messages that would result in
+ * notifications delivered to recipients under the control of the
+ * sender.  In worst case this might result in financial loss by user
+ * controlling the Sieve script and/or by recipients of notifications
+ * (e.g. if a notification is an SMS message).
+ *
+ * --> This is currently not possible to check.
+ */
+
+/*
+ * Notify capability
+ */
+
+static const char *ext_notify_get_methods_string
+	(const struct sieve_extension *ntfy_ext);
+
+const struct sieve_extension_capabilities notify_capabilities = {
+	"notify",
+	ext_notify_get_methods_string
+};
+
+/*
+ * Notify method registry
+ */
+
+static void ext_enotify_method_register
+(struct ext_enotify_context *ectx, const struct sieve_enotify_method *method)
+{
+	array_append(&ectx->notify_methods, &method, 1);
+}
+
+void ext_enotify_methods_init(struct ext_enotify_context *ectx)
+{
+	p_array_init(&ectx->notify_methods, default_pool, 4);
+
+	ext_enotify_method_register(ectx, &mailto_notify);
+}
+
+void ext_enotify_methods_deinit(struct ext_enotify_context *ectx)
+{
+	array_free(&ectx->notify_methods);
+}
+
+void sieve_enotify_method_register
+(struct sieve_extension *ntfy_ext, const struct sieve_enotify_method *method)
+{
+	struct ext_enotify_context *ectx =
+		(struct ext_enotify_context *) ntfy_ext->context;
+
+	ext_enotify_method_register(ectx, method);
+}
+
+const struct sieve_enotify_method *ext_enotify_method_find
+(const struct sieve_extension *ntfy_ext, const char *identifier)
+{
+	struct ext_enotify_context *ectx =
+		(struct ext_enotify_context *) ntfy_ext->context;
+	unsigned int meth_count, i;
+	const struct sieve_enotify_method *const *methods;
+
+	methods = array_get(&ectx->notify_methods, &meth_count);
+
+	for ( i = 0; i < meth_count; i++ ) {
+		if ( strcasecmp(methods[i]->identifier, identifier) == 0 ) {
+			return methods[i];
+		}
+	}
+
+	return NULL;
+}
+
+static const char *ext_notify_get_methods_string
+(const struct sieve_extension *ntfy_ext)
+{
+	struct ext_enotify_context *ectx =
+		(struct ext_enotify_context *) ntfy_ext->context;
+	unsigned int meth_count, i;
+	const struct sieve_enotify_method *const *methods;
+	string_t *result = t_str_new(128);
+
+	methods = array_get(&ectx->notify_methods, &meth_count);
+
+	if ( meth_count > 0 ) {
+		str_append(result, methods[0]->identifier);
+
+		for ( i = 1; i < meth_count; i++ ) {
+			str_append_c(result, ' ');
+			str_append(result, methods[i]->identifier);
+		}
+
+		return str_c(result);
+	}
+
+	return NULL;
+}
+
+/*
+ * Compile-time argument validation
+ */
+
+static const char *ext_enotify_uri_scheme_parse(const char **uri_p)
+{
+	string_t *scheme = t_str_new(EXT_ENOTIFY_MAX_SCHEME_LEN);
+	const char *p = *uri_p;
+	unsigned int len = 0;
+
+	/* RFC 3968:
+	 *
+	 *   scheme  = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+	 *
+	 * FIXME: we do not allow '%' in schemes. Is this correct?
+	 */
+
+	if ( !i_isalpha(*p) )
+		return NULL;
+
+	str_append_c(scheme, *p);
+	p++;
+
+	while ( *p != '\0' && len < EXT_ENOTIFY_MAX_SCHEME_LEN ) {
+
+		if ( !i_isalnum(*p) && *p != '+' && *p != '-' && *p != '.' )
+			break;
+
+		str_append_c(scheme, *p);
+		p++;
+		len++;
+	}
+
+	if ( *p != ':' )
+		return NULL;
+	p++;
+
+	*uri_p = p;
+	return str_c(scheme);
+}
+
+static bool ext_enotify_option_parse
+(struct sieve_enotify_log *nlog, const char *option, bool name_only,
+	const char **opt_name_r, const char **opt_value_r)
+{
+	const char *p = option;
+
+	/* "<optionname>=<value>".
+	 *
+	 * l-d = ALPHA / DIGIT
+	 * l-d-p = l-d / "." / "-" / "_"
+	 * optionname = l-d *l-d-p
+	 * value = *(%x01-09 / %x0B-0C / %x0E-FF)
+	 */
+
+	/*
+	 * Parse option name
+	 *
+	 * optionname = l-d *l-d-p
+	 */
+
+	/* Explicitly report empty option as such */
+	if ( *p == '\0' ) {
+		sieve_enotify_error(nlog, "empty option specified");
+		return FALSE;
+	}
+
+	/* l-d = ALPHA / DIGIT */
+	if ( i_isalnum(*p) ) {
+		p++;
+
+		/* l-d-p = l-d / "." / "-" / "_" */
+		while ( i_isalnum(*p) || *p == '.' || *p == '-' || *p == '_' )
+			p++;
+	}
+
+	/* Parsing must end at '=' and we must parse at least one character */
+	if ( *p != '=' || p == option ) {
+		sieve_enotify_error(nlog, "invalid option name specified in option '%s'",
+				str_sanitize(option, 80));
+		return FALSE;
+	}
+
+	/* Assign option name */
+	if ( opt_name_r != NULL )
+		*opt_name_r = t_strdup_until(option, p);
+
+	/* Skip '=' */
+	p++;
+
+	/* Exit now if only the option name is of interest */
+	if ( name_only )
+		return TRUE;
+
+	/*
+	 * Parse option value
+	 */
+
+	/* value = *(%x01-09 / %x0B-0C / %x0E-FF) */
+	while ( *p != '\0' && *p != 0x0A && *p != 0x0D )
+		p++;
+
+	/* Parse must end at end of string */
+	if ( *p != '\0' ) {
+		sieve_enotify_error(nlog,
+			"notify command: invalid option value specified in option '%s'",
+				str_sanitize(option, 80));
+		return FALSE;
+	}
+
+	/* Assign option value */
+	if ( opt_value_r != NULL )
+		*opt_value_r = p;
+
+	return TRUE;
+}
+
+struct _ext_enotify_option_check_context {
+	struct sieve_validator *valdtr;
+	const struct sieve_enotify_method *method;
+};
+
+static int _ext_enotify_option_check
+(void *context, struct sieve_ast_argument *arg)
+{
+	struct _ext_enotify_option_check_context *optn_context =
+		(struct _ext_enotify_option_check_context *) context;
+	struct sieve_validator *valdtr = optn_context->valdtr;
+	const struct sieve_enotify_method *method = optn_context->method;
+	struct sieve_enotify_log nlog;
+	const char *option = sieve_ast_argument_strc(arg);
+	const char *opt_name = NULL, *opt_value = NULL;
+	bool literal = sieve_argument_is_string_literal(arg);
+
+	/* Compose log structure */
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.ehandler = sieve_validator_error_handler(valdtr);
+	nlog.prefix = "notify command";
+	nlog.location = sieve_error_script_location
+		(sieve_validator_script(valdtr), arg->source_line);
+
+	/* Parse option */
+	if ( !literal ) {
+		/* Variable string: partial option parse
+		 *
+		 * If the string item is not a string literal, it cannot be validated fully
+		 * at compile time. We can however check whether the '=' is in the string
+		 * specification and whether the part before the '=' is a valid option name.
+		 * In that case, the method option check function is called with the value
+		 * parameter equal to NULL, meaning that it should only check the validity
+		 * of the option itself and not the assigned value.
+		 */
+		if ( !ext_enotify_option_parse(NULL, option, TRUE, &opt_name, &opt_value) )
+			return TRUE;
+	} else {
+		/* Literal string: full option parse */
+		if ( !ext_enotify_option_parse
+			(&nlog, option, FALSE, &opt_name, &opt_value) )
+			return FALSE;
+	}
+
+	/* Call method's option check function */
+	if ( method->compile_check_option != NULL )
+		return method->compile_check_option(&nlog, opt_name, opt_value);
+
+	return TRUE;
+}
+
+bool ext_enotify_compile_check_arguments
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *uri_arg, struct sieve_ast_argument *msg_arg,
+	struct sieve_ast_argument *from_arg, struct sieve_ast_argument *options_arg)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	const char *uri = sieve_ast_argument_strc(uri_arg);
+	const char *scheme;
+	const struct sieve_enotify_method *method;
+	struct sieve_enotify_log nlog;
+
+	/* If the uri string is not a constant literal, we cannot determine which
+	 * method is used, so we bail out successfully and defer checking to runtime.
+	 */
+	if ( !sieve_argument_is_string_literal(uri_arg) )
+		return TRUE;
+
+	/* Parse scheme part of URI */
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL ) {
+		sieve_argument_validate_error(valdtr, uri_arg,
+			"notify command: invalid scheme part for method URI '%s'",
+			str_sanitize(sieve_ast_argument_strc(uri_arg), 80));
+		return FALSE;
+	}
+
+	/* Find used method with the parsed scheme identifier */
+	if ( (method=ext_enotify_method_find(this_ext, scheme)) == NULL ) {
+		sieve_argument_validate_error(valdtr, uri_arg,
+			"notify command: invalid method '%s'", scheme);
+		return FALSE;
+	}
+
+	/* Compose log structure */
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.ehandler = sieve_validator_error_handler(valdtr);
+	nlog.prefix = "notify command";
+
+	/* Check URI itself */
+	if ( method->compile_check_uri != NULL ) {
+		/* Set log location to location of URI argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), uri_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_uri
+			(&nlog, sieve_ast_argument_strc(uri_arg), uri) )
+			return FALSE;
+	}
+
+	/* Check :message argument */
+	if ( msg_arg != NULL && sieve_argument_is_string_literal(msg_arg) &&
+		method->compile_check_message != NULL ) {
+		/* Set log location to location of :message argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), msg_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_message
+			(&nlog, sieve_ast_argument_str(msg_arg)) )
+			return FALSE;
+	}
+
+	/* Check :from argument */
+	if ( from_arg != NULL && sieve_argument_is_string_literal(from_arg) &&
+		method->compile_check_from != NULL ) {
+		/* Set log location to location of :from argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), from_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_from(&nlog, sieve_ast_argument_str(from_arg)) )
+			return FALSE;
+	}
+
+	/* Check :options argument */
+	if ( options_arg != NULL ) {
+		struct sieve_ast_argument *option = options_arg;
+		struct _ext_enotify_option_check_context optn_context = { valdtr, method };
+
+		/* Parse and check options */
+		if ( sieve_ast_stringlist_map
+			(&option, (void *) &optn_context, _ext_enotify_option_check) <= 0 )
+			return FALSE;
+
+		/* Discard argument if options are not accepted by method */
+		if ( method->compile_check_option == NULL ) {
+			sieve_argument_validate_warning(valdtr, options_arg,
+				"notify command: method '%s' accepts no options", scheme);
+			(void)sieve_ast_arguments_detach(options_arg,1);
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Runtime operand checking
+ */
+
+bool ext_enotify_runtime_method_validate
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	const struct sieve_enotify_method *method;
+	const char *uri = str_c(method_uri);
+	const char *scheme;
+
+	/* Get the method */
+
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL )
+		return FALSE;
+
+	if ( (method=ext_enotify_method_find(this_ext, scheme)) == NULL )
+		return FALSE;
+
+	/* Validate the provided URI */
+
+	if ( method->runtime_check_uri != NULL ) {
+		struct sieve_enotify_log nlog;
+
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "valid_notify_method test";
+
+		/* Use the method check function to validate the URI */
+		return method->runtime_check_uri(&nlog, str_c(method_uri), uri);
+	}
+
+	/* Method has no check function */
+	return TRUE;
+}
+
+static const struct sieve_enotify_method *ext_enotify_get_method
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, const char **uri_body_r)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	const struct sieve_enotify_method *method;
+	const char *uri = str_c(method_uri);
+	const char *scheme;
+
+	/* Parse part before ':' of the uri (the scheme) and use it to identify
+	 * notify method.
+	 */
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"invalid scheme part for method URI '%s'",
+				str_sanitize(str_c(method_uri), 80));
+		return NULL;
+	}
+
+	/* Find the notify method */
+	if ( (method=ext_enotify_method_find(this_ext, scheme)) == NULL ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"invalid notify method '%s'", scheme);
+		return NULL;
+	}
+
+	/* Return the parse pointer and the found method */
+	*uri_body_r = uri;
+	return method;
+}
+
+const char *ext_enotify_runtime_get_method_capability
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, const char *capability)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri;
+
+	/* Get method */
+	method = ext_enotify_get_method(renv, source_line, method_uri, &uri);
+	if ( method == NULL ) return NULL;
+
+	/* Get requested capability */
+	if ( method->runtime_get_method_capability != NULL ) {
+		struct sieve_enotify_log nlog;
+
+		/* Compose log structure */
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "notify_method_capability test";
+
+		/* Execute method function to acquire capability value */
+		return method->runtime_get_method_capability
+			(&nlog, str_c(method_uri), uri, capability);
+	}
+
+	return NULL;
+}
+
+int ext_enotify_runtime_check_operands
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, string_t *message, string_t *from,
+	struct sieve_coded_stringlist *options,
+	const struct sieve_enotify_method **method_r, void **method_context)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri;
+
+	/* Get method */
+	method = ext_enotify_get_method(renv, source_line, method_uri, &uri);
+	if ( method == NULL ) return SIEVE_EXEC_FAILURE;
+
+	/* Check provided operands */
+	if ( method->runtime_check_operands != NULL ) {
+		struct sieve_enotify_log nlog;
+
+		/* Compose log structure */
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "notify action";
+
+		/* Execute check function */
+		if ( method->runtime_check_operands(&nlog, str_c(method_uri), uri, message,
+			from, sieve_result_pool(renv->result), method_context) ) {
+
+			/* Check any provided options */
+			if ( options != NULL ) {
+				int result = TRUE;
+				string_t *option = NULL;
+
+				/* Iterate through all provided options */
+				while ( result &&
+					(result=sieve_coded_stringlist_next_item(options, &option)) &&
+					option != NULL ) {
+					const char *opt_name = NULL, *opt_value = NULL;
+
+					/* Parse option into <optionname> and <value> */
+					if ( ext_enotify_option_parse
+						(&nlog, str_c(option), FALSE, &opt_name, &opt_value) ) {
+
+						/* Set option */
+						if ( method->runtime_set_option != NULL ) {
+							(void) method->runtime_set_option
+								(&nlog, *method_context, opt_name, opt_value);
+						}
+					}
+				}
+
+				/* Check for binary corruptions encountered during string list iteration
+				 */
+				if ( result ) {
+					*method_r = method;
+					return SIEVE_EXEC_OK;
+				}
+
+				/* Binary corrupt */
+				sieve_runtime_trace_error(renv, "invalid item in options string list");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			/* No options */
+			*method_r = method;
+			return SIEVE_EXEC_OK;
+		}
+
+		/* Check failed */
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	/* No check function defined: a most unlikely situation */
+	*method_context = NULL;
+	*method_r = method;
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Notify method printing
+ */
+
+void sieve_enotify_method_printf
+(const struct sieve_enotify_print_env *penv, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_result_vprintf(penv->result_penv, fmt, args);
+	va_end(args);
+}
+
+/*
+ * Method logging
+ */
+
+static void sieve_enotify_vlog_message
+(const struct sieve_enotify_log *nlog, sieve_error_func_t log_func,
+	const char *fmt, va_list args)
+{
+	if ( nlog == NULL ) return;
+
+	T_BEGIN {
+		if ( nlog->aenv != NULL ) {
+			if ( nlog->prefix == NULL )
+				sieve_result_vlog_message(nlog->aenv, log_func, fmt, args);
+			else
+				sieve_result_log_message(nlog->aenv, log_func, "%s: %s", nlog->prefix,
+					t_strdup_vprintf(fmt, args));
+		} else {
+			if ( nlog->prefix == NULL )
+				log_func(nlog->ehandler, nlog->location, "%s",
+					t_strdup_vprintf(fmt, args));
+			else
+				log_func(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix,
+					t_strdup_vprintf(fmt, args));
+		}
+	} T_END;
+}
+
+void sieve_enotify_error
+(const struct sieve_enotify_log *nlog, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_enotify_vlog_message(nlog, sieve_error, fmt, args);
+	va_end(args);
+}
+
+void sieve_enotify_warning
+(const struct sieve_enotify_log *nlog, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	sieve_enotify_vlog_message(nlog, sieve_warning, fmt, args);
+	va_end(args);
+}
+
+void sieve_enotify_log
+(const struct sieve_enotify_log *nlog, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	sieve_enotify_vlog_message(nlog, sieve_info, fmt, args);
+	va_end(args);
+}
+
Index: b/sieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h
@@ -0,0 +1,139 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENOTIFY_COMMON_H
+#define __EXT_ENOTIFY_COMMON_H
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ext-variables.h"
+
+#include "sieve-ext-enotify.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def enotify_extension;
+extern const struct sieve_extension_capabilities notify_capabilities;
+
+struct ext_enotify_context {
+	const struct sieve_extension *var_ext;
+	ARRAY_DEFINE(notify_methods, const struct sieve_enotify_method *);
+};
+
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def notify_command;
+
+/* Codes for optional arguments */
+
+enum cmd_notify_optional {
+    CMD_NOTIFY_OPT_END,
+    CMD_NOTIFY_OPT_FROM,
+    CMD_NOTIFY_OPT_OPTIONS,
+    CMD_NOTIFY_OPT_MESSAGE,
+    CMD_NOTIFY_OPT_IMPORTANCE
+};
+
+/*
+ * Tests
+ */
+
+extern const struct sieve_command_def valid_notify_method_test;
+extern const struct sieve_command_def notify_method_capability_test;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def notify_operation;
+extern const struct sieve_operation_def valid_notify_method_operation;
+extern const struct sieve_operation_def notify_method_capability_operation;
+
+enum ext_variables_opcode {
+	EXT_ENOTIFY_OPERATION_NOTIFY,
+	EXT_ENOTIFY_OPERATION_VALID_NOTIFY_METHOD,
+	EXT_ENOTIFY_OPERATION_NOTIFY_METHOD_CAPABILITY
+};
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand_def encodeurl_operand;
+
+/*
+ * Modifiers
+ */
+
+extern const struct sieve_variables_modifier_def encodeurl_modifier;
+
+/*
+ * Notify methods
+ */
+
+extern const struct sieve_enotify_method mailto_notify;
+
+void ext_enotify_methods_init(struct ext_enotify_context *ectx);
+void ext_enotify_methods_deinit(struct ext_enotify_context *ectx);
+
+const struct sieve_enotify_method *ext_enotify_method_find
+	(const struct sieve_extension *ntfy_ext, const char *identifier);
+
+/*
+ * Validation
+ */
+
+bool ext_enotify_compile_check_arguments
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		struct sieve_ast_argument *uri_arg, struct sieve_ast_argument *msg_arg,
+		struct sieve_ast_argument *from_arg,
+		struct sieve_ast_argument *options_arg);
+
+/*
+ * Runtime
+ */
+
+bool ext_enotify_runtime_method_validate
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri);
+
+const char *ext_enotify_runtime_get_method_capability
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri, const char *capability);
+
+int ext_enotify_runtime_check_operands
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri, string_t *message, string_t *from,
+		struct sieve_coded_stringlist *options,
+		const struct sieve_enotify_method **method_r, void **method_context);
+
+/*
+ * Method printing
+ */
+
+struct sieve_enotify_print_env {
+	const struct sieve_result_print_env *result_penv;
+};
+
+/*
+ * Method logging
+ */
+
+struct sieve_enotify_log {
+	struct sieve_error_handler *ehandler;
+	const char *location;
+
+	const struct sieve_action_exec_env *aenv;
+
+	const char *prefix;
+};
+
+#endif /* __EXT_ENOTIFY_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENOTIFY_LIMITS_H
+#define __EXT_ENOTIFY_LIMITS_H
+
+#define EXT_ENOTIFY_MAX_SCHEME_LEN  32
+
+#endif /* __EXT_ENOTIFY_LIMITS_H */
Index: b/sieve/src/lib-sieve/plugins/enotify/ext-enotify.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/ext-enotify.c
@@ -0,0 +1,102 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension enotify
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5435
+ * Implementation: full
+ * Status: testing
+ *
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation_def *ext_enotify_operations[] = {
+	&notify_operation,
+	&valid_notify_method_operation,
+	&notify_method_capability_operation
+};
+
+/*
+ * Extension
+ */
+
+static bool ext_enotify_load(const struct sieve_extension *ext, void **context);
+static void ext_enotify_unload(const struct sieve_extension *ext);
+static bool ext_enotify_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def enotify_extension = {
+	"enotify",
+	ext_enotify_load,
+	ext_enotify_unload,
+	ext_enotify_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_enotify_operations),
+	SIEVE_EXT_DEFINE_OPERAND(encodeurl_operand)
+};
+
+static bool ext_enotify_load(const struct sieve_extension *ext, void **context)
+{
+	struct ext_enotify_context *ectx;
+
+	ectx = i_new(struct ext_enotify_context, 1);
+	ectx->var_ext = sieve_ext_variables_get_extension(ext->svinst);
+	*context = (void *) ectx;
+
+	ext_enotify_methods_init(ectx);
+
+	sieve_extension_capabilities_register(ext->svinst, ext, &notify_capabilities);
+
+	return TRUE;
+}
+
+static void ext_enotify_unload(const struct sieve_extension *ext)
+{
+	struct ext_enotify_context *ectx =
+		(struct ext_enotify_context *) ext->context;
+
+	ext_enotify_methods_deinit(ectx);
+
+	i_free(ectx);
+}
+
+static bool ext_enotify_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	struct ext_enotify_context *ectx =
+		(struct ext_enotify_context *) ext->context;
+
+	/* Register new commands */
+	sieve_validator_register_command(valdtr, ext, &notify_command);
+	sieve_validator_register_command(valdtr, ext, &valid_notify_method_test);
+	sieve_validator_register_command(valdtr, ext, &notify_method_capability_test);
+
+	/* Register new set modifier for variables extension */
+	sieve_variables_modifier_register
+		(ectx->var_ext, valdtr, ext, &encodeurl_modifier);
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c
@@ -0,0 +1,1104 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Notify method mailto
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5436
+ * Implementation: full
+ * Status: testing
+ *
+ */
+
+/* FIXME: URI syntax conforms to something somewhere in between RFC 2368 and
+ *   draft-duerst-mailto-bis-05.txt. Should fully migrate to new specification
+ *   when it matures. This requires modifications to the address parser (no
+ *   whitespace allowed within the address itself) and UTF-8 support will be
+ *   required in the URL.
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "str.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "mail-storage.h"
+
+#include "rfc2822.h"
+
+#include "sieve-ext-enotify.h"
+#include "sieve-address.h"
+#include "sieve-message.h"
+
+/*
+ * Configuration
+ */
+
+#define NTFY_MAILTO_MAX_RECIPIENTS  8
+#define NTFY_MAILTO_MAX_HEADERS     16
+#define NTFY_MAILTO_MAX_SUBJECT     256
+
+/*
+ * Types
+ */
+
+struct ntfy_mailto_header_field {
+	const char *name;
+	const char *body;
+};
+
+struct ntfy_mailto_recipient {
+	const char *full;
+	const char *normalized;
+	bool carbon_copy;
+};
+
+ARRAY_DEFINE_TYPE(recipients, struct ntfy_mailto_recipient);
+ARRAY_DEFINE_TYPE(headers, struct ntfy_mailto_header_field);
+
+/*
+ * Mailto notification method
+ */
+
+static bool ntfy_mailto_compile_check_uri
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body);
+static bool ntfy_mailto_compile_check_from
+	(const struct sieve_enotify_log *nlog, string_t *from);
+
+static const char *ntfy_mailto_runtime_get_notify_capability
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body,
+		const char *capability);
+static bool ntfy_mailto_runtime_check_uri
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body);
+static bool ntfy_mailto_runtime_check_operands
+	(const struct sieve_enotify_log *nlog, const char *uri,const char *uri_body,
+		string_t *message, string_t *from, pool_t context_pool,
+		void **method_context);
+
+static int ntfy_mailto_action_check_duplicates
+	(const struct sieve_enotify_log *nlog, void *method_ctx1, void *method_ctx2,
+		const char *dupl_location);
+
+static void ntfy_mailto_action_print
+	(const struct sieve_enotify_print_env *penv,
+		const struct sieve_enotify_action *act);
+
+static bool ntfy_mailto_action_execute
+	(const struct sieve_enotify_exec_env *nenv,
+		const struct sieve_enotify_action *act);
+
+const struct sieve_enotify_method mailto_notify = {
+	"mailto",
+	ntfy_mailto_compile_check_uri,
+	NULL,
+	ntfy_mailto_compile_check_from,
+	NULL,
+	ntfy_mailto_runtime_check_uri,
+	ntfy_mailto_runtime_get_notify_capability,
+	ntfy_mailto_runtime_check_operands,
+	NULL,
+	ntfy_mailto_action_check_duplicates,
+	ntfy_mailto_action_print,
+	ntfy_mailto_action_execute
+};
+
+/*
+ * Method context data
+ */
+
+struct ntfy_mailto_context {
+	ARRAY_TYPE(recipients) recipients;
+	ARRAY_TYPE(headers) headers;
+	const char *subject;
+	const char *body;
+	const char *from_normalized;
+};
+
+/*
+ * Reserved headers
+ */
+
+static const char *_reserved_headers[] = {
+	"auto-submitted",
+	"received",
+	"message-id",
+	"data",
+	"bcc",
+	"in-reply-to",
+	"references",
+	"resent-date",
+	"resent-from",
+	"resent-sender",
+	"resent-to",
+	"resent-cc",
+ 	"resent-bcc",
+	"resent-msg-id",
+	"from",
+	"sender",
+	NULL
+};
+
+static const char *_unique_headers[] = {
+	"reply-to",
+	NULL
+};
+
+static inline bool _ntfy_mailto_header_allowed(const char *field_name)
+{
+	const char **rhdr = _reserved_headers;
+
+	/* Check whether it is reserved */
+	while ( *rhdr != NULL ) {
+		if ( strcasecmp(field_name, *rhdr) == 0 )
+			return FALSE;
+		rhdr++;
+	}
+
+	return TRUE;
+}
+
+static inline bool _ntfy_mailto_header_unique(const char *field_name)
+{
+	const char **rhdr = _unique_headers;
+
+	/* Check whether it is supposed to be unique */
+	while ( *rhdr != NULL ) {
+		if ( strcasecmp(field_name, *rhdr) == 0 )
+			return TRUE;
+		rhdr++;
+	}
+
+	return FALSE;
+}
+
+/*
+ * Mailto URI parsing
+ */
+
+/* Util functions */
+
+#define _uri_parse_error(LOG, ...) \
+	sieve_enotify_error(LOG, "invalid mailto URI: " __VA_ARGS__ )
+
+#define _uri_parse_warning(LOG, ...) \
+	sieve_enotify_warning(LOG, "mailto URI: " __VA_ARGS__ )
+
+/* FIXME: much of this implementation will be common to other URI schemes. This
+ *        should be merged into a common implementation.
+ */
+
+static const char _qchar_lookup[256] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 00
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 10
+	0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0,  // 20
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,  // 30
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 40
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  // 50
+	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 60
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,  // 70
+
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 80
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 90
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // F0
+};
+
+static inline bool _is_qchar(unsigned char c)
+{
+	return _qchar_lookup[c];
+}
+
+static inline int _decode_hex_digit(char digit)
+{
+	switch ( digit ) {
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+		return (int) digit - '0';
+
+	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+		return (int) digit - 'a' + 0x0a;
+
+	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+		return (int) digit - 'A' + 0x0A;
+	}
+
+	return -1;
+}
+
+static bool _parse_hex_value(const char **in, char *out)
+{
+	char value;
+
+	if ( **in == '\0' || (value=_decode_hex_digit(**in)) < 0 )
+		return FALSE;
+
+	*out = value << 4;
+	(*in)++;
+
+	if ( **in == '\0' || (value=_decode_hex_digit(**in)) < 0 )
+		return FALSE;
+
+	*out |= value;
+	(*in)++;
+	return (*out != '\0');
+}
+
+static bool _uri_add_valid_recipient
+(const struct sieve_enotify_log *nlog, ARRAY_TYPE(recipients) *recipients,
+	string_t *recipient, bool cc)
+{
+	const char *error;
+	const char *normalized;
+
+	/* Verify recipient */
+	if ( (normalized=sieve_address_normalize(recipient, &error)) == NULL ) {
+		_uri_parse_error(nlog, "invalid recipient '%s': %s",
+			str_sanitize(str_c(recipient), 80), error);
+		return FALSE;
+	}
+
+	/* Add recipient to the list */
+	if ( recipients != NULL ) {
+		struct ntfy_mailto_recipient *new_recipient;
+		struct ntfy_mailto_recipient *rcpts;
+		unsigned int count, i;
+		pool_t pool;
+
+		rcpts = array_get_modifiable(recipients, &count);
+
+		/* Enforce limits */
+		if ( count >= NTFY_MAILTO_MAX_RECIPIENTS ) {
+			if ( count == NTFY_MAILTO_MAX_RECIPIENTS ) {
+				_uri_parse_warning(nlog,
+					"more than the maximum %u recipients specified; "
+					"rest is discarded", NTFY_MAILTO_MAX_RECIPIENTS);
+			}
+			return TRUE;
+		}
+
+		/* Check for duplicate first */
+		for ( i = 0; i < count; i++ ) {
+			if ( sieve_address_compare(rcpts[i].normalized, normalized, TRUE) == 0 )
+				{
+				/* Upgrade existing Cc: recipient to a To: recipient if possible */
+				rcpts[i].carbon_copy = ( rcpts[i].carbon_copy && cc );
+
+				_uri_parse_warning(nlog, "ignored duplicate recipient '%s'",
+					str_sanitize(str_c(recipient), 80));
+				return TRUE;
+			}
+		}
+
+		/* Add */
+		pool = array_get_pool(recipients);
+		new_recipient = array_append_space(recipients);
+		new_recipient->carbon_copy = cc;
+		new_recipient->full = p_strdup(pool, str_c(recipient));
+		new_recipient->normalized = p_strdup(pool, normalized);
+	}
+
+	return TRUE;
+}
+
+static bool _uri_parse_recipients
+(const struct sieve_enotify_log *nlog, const char **uri_p,
+	ARRAY_TYPE(recipients) *recipients_r)
+{
+	string_t *to = t_str_new(128);
+	const char *p = *uri_p;
+
+	if ( *p == '\0' || *p == '?' )
+		return TRUE;
+
+	while ( *p != '\0' && *p != '?' ) {
+		if ( *p == '%' ) {
+			/* % encoded character */
+			char ch;
+
+			p++;
+
+			/* Parse 2-digit hex value */
+			if ( !_parse_hex_value(&p, &ch) ) {
+				_uri_parse_error(nlog, "invalid %% encoding");
+				return FALSE;
+			}
+
+			/* Check for delimiter */
+			if ( ch == ',' ) {
+				/* Verify and add recipient */
+				if ( !_uri_add_valid_recipient(nlog, recipients_r, to, FALSE) )
+					return FALSE;
+
+				/* Reset for next recipient */
+				str_truncate(to, 0);
+			}	else {
+				/* Content character */
+				str_append_c(to, ch);
+			}
+		} else {
+			if ( *p == ':' || *p == ';' || *p == ',' || !_is_qchar(*p) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in 'to' part", *p);
+				return FALSE;
+			}
+
+			/* Content character */
+			str_append_c(to, *p);
+			p++;
+		}
+	}
+
+	/* Skip '?' */
+	if ( *p != '\0' ) p++;
+
+	/* Verify and add recipient */
+	if ( !_uri_add_valid_recipient(nlog, recipients_r, to, FALSE) )
+		return FALSE;
+
+	*uri_p = p;
+	return TRUE;
+}
+
+static bool _uri_parse_header_recipients
+(const struct sieve_enotify_log *nlog, string_t *rcpt_header,
+	ARRAY_TYPE(recipients) *recipients_r, bool cc)
+{
+	string_t *to = t_str_new(128);
+	const char *p = (const char *) str_data(rcpt_header);
+	const char *pend = p + str_len(rcpt_header);
+
+	while ( p < pend ) {
+		if ( *p == ',' ) {
+			/* Verify and add recipient */
+			if ( !_uri_add_valid_recipient(nlog, recipients_r, to, cc) )
+				return FALSE;
+
+			/* Reset for next recipient */
+			str_truncate(to, 0);
+		} else {
+			/* Content character */
+			str_append_c(to, *p);
+		}
+		p++;
+	}
+
+	/* Verify and add recipient */
+	if ( !_uri_add_valid_recipient(nlog, recipients_r, to, cc) )
+		return FALSE;
+
+	return TRUE;
+}
+
+static bool _uri_header_is_duplicate
+(ARRAY_TYPE(headers) *headers, const char *field_name)
+{
+	if ( _ntfy_mailto_header_unique(field_name) ) {
+		const struct ntfy_mailto_header_field *hdrs;
+		unsigned int count, i;
+
+		hdrs = array_get(headers, &count);
+		for ( i = 0; i < count; i++ ) {
+			if ( strcasecmp(hdrs[i].name, field_name) == 0 )
+				return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static bool _uri_parse_headers
+(const struct sieve_enotify_log *nlog, const char **uri_p,
+	ARRAY_TYPE(headers) *headers_r, ARRAY_TYPE(recipients) *recipients_r,
+	const char **body, const char **subject)
+{
+	unsigned int header_count = 0;
+	string_t *field = t_str_new(128);
+	const char *p = *uri_p;
+	pool_t pool = NULL;
+
+	if ( body != NULL )
+		*body = NULL;
+
+	if ( subject != NULL )
+		*subject = NULL;
+
+	if ( headers_r != NULL )
+		pool = array_get_pool(headers_r);
+
+	while ( *p != '\0' ) {
+		enum {
+			_HNAME_IGNORED,
+			_HNAME_GENERIC,
+			_HNAME_TO,
+			_HNAME_CC,
+			_HNAME_SUBJECT,
+			_HNAME_BODY
+		} hname_type = _HNAME_GENERIC;
+		struct ntfy_mailto_header_field *hdrf = NULL;
+		const char *field_name;
+
+		/* Parse field name */
+		while ( *p != '\0' && *p != '=' ) {
+			char ch = *p;
+			p++;
+
+			if ( ch == '%' ) {
+				/* Encoded, parse 2-digit hex value */
+				if ( !_parse_hex_value(&p, &ch) ) {
+					_uri_parse_error(nlog, "invalid %% encoding");
+					return FALSE;
+				}
+			} else if ( ch != '=' && !_is_qchar(ch) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in header field name part", ch);
+				return FALSE;
+			}
+
+			str_append_c(field, ch);
+		}
+		if ( *p != '\0' ) p++;
+
+		/* Verify field name */
+		if ( !rfc2822_header_field_name_verify(str_c(field), str_len(field)) ) {
+			_uri_parse_error(nlog, "invalid header field name");
+			return FALSE;
+		}
+
+		if ( header_count >= NTFY_MAILTO_MAX_HEADERS ) {
+			/* Refuse to accept more headers than allowed by policy */
+			if ( header_count == NTFY_MAILTO_MAX_HEADERS ) {
+				_uri_parse_warning(nlog, "more than the maximum %u headers specified; "
+					"rest is discarded", NTFY_MAILTO_MAX_HEADERS);
+			}
+
+			hname_type = _HNAME_IGNORED;
+		} else {
+			/* Add new header field to array and assign its name */
+
+			field_name = str_c(field);
+			if ( strcasecmp(field_name, "to") == 0 )
+				hname_type = _HNAME_TO;
+			else if ( strcasecmp(field_name, "cc") == 0 )
+				hname_type = _HNAME_CC;
+			else if ( strcasecmp(field_name, "subject") == 0 )
+				hname_type = _HNAME_SUBJECT;
+			else if ( strcasecmp(field_name, "body") == 0 )
+				hname_type = _HNAME_BODY;
+			else if ( _ntfy_mailto_header_allowed(field_name) ) {
+				if ( headers_r != NULL ) {
+					if ( !_uri_header_is_duplicate(headers_r, field_name) ) {
+						hdrf = array_append_space(headers_r);
+						hdrf->name = p_strdup(pool, field_name);
+					} else {
+						_uri_parse_warning(nlog,
+							"ignored duplicate for unique header field '%s'",
+							str_sanitize(field_name, 32));
+						hname_type = _HNAME_IGNORED;
+					}
+				} else {
+					hname_type = _HNAME_IGNORED;
+				}
+			} else {
+				_uri_parse_warning(nlog, "ignored reserved header field '%s'",
+					str_sanitize(field_name, 32));
+				hname_type = _HNAME_IGNORED;
+			}
+		}
+
+		header_count++;
+
+		/* Reset for field body */
+		str_truncate(field, 0);
+
+		/* Parse field body */
+		while ( *p != '\0' && *p != '&' ) {
+			char ch = *p;
+			p++;
+
+			if ( ch == '%' ) {
+				/* Encoded, parse 2-digit hex value */
+				if ( !_parse_hex_value(&p, &ch) ) {
+					_uri_parse_error(nlog, "invalid %% encoding");
+					return FALSE;
+				}
+			} else if ( ch != '=' && !_is_qchar(ch) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in header field value part", ch);
+				return FALSE;
+			}
+			str_append_c(field, ch);
+		}
+		if ( *p != '\0' ) p++;
+
+		/* Verify field body */
+		if ( hname_type == _HNAME_BODY ) {
+			// FIXME: verify body ...
+		} else {
+			if ( !rfc2822_header_field_body_verify(str_c(field), str_len(field)) ) {
+				_uri_parse_error
+					(nlog, "invalid header field body");
+				return FALSE;
+			}
+		}
+
+		/* Assign field body */
+
+		switch ( hname_type ) {
+		case _HNAME_IGNORED:
+			break;
+		case _HNAME_TO:
+			/* Gracefully allow duplicate To fields */
+			if ( !_uri_parse_header_recipients(nlog, field, recipients_r, FALSE) )
+				return FALSE;
+			break;
+		case _HNAME_CC:
+			/* Gracefully allow duplicate Cc fields */
+			if ( !_uri_parse_header_recipients(nlog, field, recipients_r, TRUE) )
+				return FALSE;
+			break;
+		case _HNAME_SUBJECT:
+			if ( subject != NULL ) {
+				/* Igore duplicate subject field */
+				if ( *subject == NULL )
+					*subject = p_strdup(pool, str_c(field));
+				else
+					_uri_parse_warning(nlog, "ignored duplicate subject field");
+			}
+			break;
+		case _HNAME_BODY:
+			if ( body != NULL ) {
+				/* Igore duplicate body field */
+				if ( *body == NULL )
+					*body = p_strdup(pool, str_c(field));
+				else
+					_uri_parse_warning(nlog, "ignored duplicate body field");
+			}
+			break;
+		case _HNAME_GENERIC:
+			if ( hdrf != NULL )
+				hdrf->body = p_strdup(pool, str_c(field));
+			break;
+		}
+
+		/* Reset for next name */
+		str_truncate(field, 0);
+	}
+
+	/* Skip '&' */
+	if ( *p != '\0' ) p++;
+
+	*uri_p = p;
+	return TRUE;
+}
+
+static bool ntfy_mailto_parse_uri
+(const struct sieve_enotify_log *nlog, const char *uri_body,
+	ARRAY_TYPE(recipients) *recipients_r, ARRAY_TYPE(headers) *headers_r,
+	const char **body, const char **subject)
+{
+	const char *p = uri_body;
+
+	/*
+	 * mailtoURI   = "mailto:" [ to ] [ hfields ]
+	 * to          = [ addr-spec *("%2C" addr-spec ) ]
+	 * hfields     = "?" hfield *( "&" hfield )
+	 * hfield      = hfname "=" hfvalue
+	 * hfname      = *qchar
+	 * hfvalue     = *qchar
+	 * addr-spec   = local-part "@" domain
+	 * local-part  = dot-atom / quoted-string
+	 * qchar       = unreserved / pct-encoded / some-delims
+	 * some-delims = "!" / "$" / "'" / "(" / ")" / "*"
+	 *               / "+" / "," / ";" / ":" / "@"
+	 *
+	 * to         ~= *tqchar
+	 * tqchar     ~= <qchar> without ";" and ":"
+	 *
+	 * Scheme 'mailto:' already parsed, starting parse after colon
+	 */
+
+	/* First extract to-part by searching for '?' and decoding % items
+	 */
+
+	if ( !_uri_parse_recipients(nlog, &p, recipients_r) )
+		return FALSE;
+
+	/* Extract hfield items */
+
+	while ( *p != '\0' ) {
+		/* Extract hfield item by searching for '&' and decoding '%' items */
+		if ( !_uri_parse_headers(nlog, &p, headers_r, recipients_r, body, subject) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool ntfy_mailto_compile_check_uri
+(const struct sieve_enotify_log *nlog, const char *uri ATTR_UNUSED,
+	const char *uri_body)
+{
+	ARRAY_TYPE(recipients) recipients;
+	ARRAY_TYPE(headers) headers;
+	const char *body = NULL, *subject = NULL;
+
+	t_array_init(&recipients, NTFY_MAILTO_MAX_RECIPIENTS);
+	t_array_init(&headers, NTFY_MAILTO_MAX_HEADERS);
+
+	if ( !ntfy_mailto_parse_uri
+		(nlog, uri_body, &recipients, &headers, &body, &subject) )
+		return FALSE;
+
+	if ( array_count(&recipients) == 0 )
+		sieve_enotify_warning(nlog, "notification URI specifies no recipients");
+
+	return TRUE;
+}
+
+static bool ntfy_mailto_compile_check_from
+(const struct sieve_enotify_log *nlog, string_t *from)
+{
+	const char *error;
+	bool result = FALSE;
+
+	T_BEGIN {
+		result = sieve_address_validate(from, &error);
+
+		if ( !result ) {
+			sieve_enotify_error(nlog,
+				"specified :from address '%s' is invalid for "
+				"the mailto method: %s",
+				str_sanitize(str_c(from), 128), error);
+		}
+	} T_END;
+
+	return result;
+}
+
+/*
+ * Runtime
+ */
+
+static const char *ntfy_mailto_runtime_get_notify_capability
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, const char *uri ATTR_UNUSED,
+	const char *uri_body, const char *capability)
+{
+	if ( !ntfy_mailto_parse_uri(NULL, uri_body, NULL, NULL, NULL, NULL) ) {
+		return NULL;
+	}
+
+	if ( strcasecmp(capability, "online") == 0 )
+		return "maybe";
+
+	return NULL;
+}
+
+static bool ntfy_mailto_runtime_check_uri
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, const char *uri ATTR_UNUSED,
+	const char *uri_body)
+{
+	return ntfy_mailto_parse_uri(NULL, uri_body, NULL, NULL, NULL, NULL);
+}
+
+static bool ntfy_mailto_runtime_check_operands
+(const struct sieve_enotify_log *nlog, const char *uri ATTR_UNUSED,
+	const char *uri_body, string_t *message ATTR_UNUSED, string_t *from,
+	pool_t context_pool, void **method_context)
+{
+	struct ntfy_mailto_context *mtctx;
+	const char *error, *normalized;
+
+	/* Need to create context before validation to have arrays present */
+	mtctx = p_new(context_pool, struct ntfy_mailto_context, 1);
+
+	/* Validate :from */
+	if ( from != NULL ) {
+		T_BEGIN {
+			normalized = sieve_address_normalize(from, &error);
+
+			if ( normalized == NULL ) {
+				sieve_enotify_error(nlog,
+					"specified :from address '%s' is invalid for "
+					"the mailto method: %s",
+					str_sanitize(str_c(from), 128), error);
+			} else
+				mtctx->from_normalized = p_strdup(context_pool, normalized);
+		} T_END;
+
+		if ( !normalized ) return FALSE;
+	}
+
+	p_array_init(&mtctx->recipients, context_pool, NTFY_MAILTO_MAX_RECIPIENTS);
+	p_array_init(&mtctx->headers, context_pool, NTFY_MAILTO_MAX_HEADERS);
+
+	if ( !ntfy_mailto_parse_uri
+		(nlog, uri_body, &mtctx->recipients, &mtctx->headers, &mtctx->body,
+			&mtctx->subject) ) {
+		return FALSE;
+	}
+
+	*method_context = (void *) mtctx;
+	return TRUE;
+}
+
+/*
+ * Action duplicates
+ */
+
+static int ntfy_mailto_action_check_duplicates
+(const struct sieve_enotify_log *nlog ATTR_UNUSED,
+	void *method_ctx1, void *method_ctx2,
+	const char *dupl_location ATTR_UNUSED)
+{
+	struct ntfy_mailto_context *mt_new =
+		(struct ntfy_mailto_context *) method_ctx1;
+	struct ntfy_mailto_context *mt_old =
+		(struct ntfy_mailto_context *) method_ctx2;
+	const struct ntfy_mailto_recipient *new_rcpts, *old_rcpts;
+	unsigned int new_count, old_count, i, j;
+	unsigned int del_start = 0, del_len = 0;
+
+	new_rcpts = array_get(&mt_new->recipients, &new_count);
+	old_rcpts = array_get(&mt_old->recipients, &old_count);
+
+	for ( i = 0; i < new_count; i++ ) {
+		for ( j = 0; j < old_count; j++ ) {
+			if ( sieve_address_compare
+				(new_rcpts[i].normalized, old_rcpts[j].normalized, TRUE) == 0 )
+				break;
+		}
+
+		if ( j == old_count ) {
+			/* Not duplicate */
+			if ( del_len > 0 ) {
+				/* Perform pending deletion */
+				array_delete(&mt_new->recipients, del_start, del_len);
+
+				/* Make sure the loop integrity is maintained */
+				i -= del_len;
+				new_rcpts = array_get(&mt_new->recipients, &new_count);
+			}
+			del_len = 0;
+		} else {
+			/* Mark deletion */
+			if ( del_len == 0 )
+				del_start = i;
+			del_len++;
+		}
+	}
+
+	/* Perform pending deletion */
+	if ( del_len > 0 ) {
+		array_delete(&mt_new->recipients, del_start, del_len);
+	}
+
+	return ( array_count(&mt_new->recipients) > 0 ? 0 : 1 );
+}
+
+/*
+ * Action printing
+ */
+
+static void ntfy_mailto_action_print
+(const struct sieve_enotify_print_env *penv,
+	const struct sieve_enotify_action *act)
+{
+	unsigned int count, i;
+	const struct ntfy_mailto_recipient *recipients;
+	const struct ntfy_mailto_header_field *headers;
+	struct ntfy_mailto_context *mtctx =
+		(struct ntfy_mailto_context *) act->method_context;
+
+	/* Print main method parameters */
+
+	sieve_enotify_method_printf
+		(penv,   "    => importance   : %d\n", act->importance);
+
+	if ( act->message != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => subject      : %s\n", act->message);
+	else if ( mtctx->subject != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => subject      : %s\n", mtctx->subject);
+
+	if ( act->from != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => from         : %s\n", act->from);
+
+	/* Print mailto: recipients */
+
+	sieve_enotify_method_printf(penv,   "    => recipients   :\n" );
+
+	recipients = array_get(&mtctx->recipients, &count);
+	if ( count == 0 ) {
+		sieve_enotify_method_printf(penv,   "       NONE, action has no effect\n");
+	} else {
+		for ( i = 0; i < count; i++ ) {
+			if ( recipients[i].carbon_copy )
+				sieve_enotify_method_printf
+					(penv,   "       + Cc: %s\n", recipients[i].full);
+			else
+				sieve_enotify_method_printf
+					(penv,   "       + To: %s\n", recipients[i].full);
+		}
+	}
+
+	/* Print accepted headers for notification message */
+
+	headers = array_get(&mtctx->headers, &count);
+	if ( count > 0 ) {
+		sieve_enotify_method_printf(penv,   "    => headers      :\n" );
+		for ( i = 0; i < count; i++ ) {
+			sieve_enotify_method_printf(penv,   "       + %s: %s\n",
+				headers[i].name, headers[i].body);
+		}
+	}
+
+	/* Print body for notification message */
+
+	if ( mtctx->body != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => body         : \n--\n%s\n--\n", mtctx->body);
+
+	/* Finish output with an empty line */
+
+	sieve_enotify_method_printf(penv,   "\n");
+}
+
+/*
+ * Action execution
+ */
+
+static bool _contains_8bit(const char *msg)
+{
+	const unsigned char *s = (const unsigned char *)msg;
+
+	for (; *s != '\0'; s++) {
+		if ((*s & 0x80) != 0)
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+static bool ntfy_mailto_send
+(const struct sieve_enotify_exec_env *nenv,
+	const struct sieve_enotify_action *act, const char *recipient)
+{
+	const struct sieve_enotify_log *nlog = nenv->notify_log;
+	const struct sieve_message_data *msgdata = nenv->msgdata;
+	const struct sieve_script_env *senv = nenv->scriptenv;
+	struct ntfy_mailto_context *mtctx =
+		(struct ntfy_mailto_context *) act->method_context;
+	const char *from = NULL, *from_smtp = NULL;
+	const char *subject = mtctx->subject;
+	const char *body = mtctx->body;
+	string_t *to, *cc;
+	const struct ntfy_mailto_recipient *recipients;
+	void *smtp_handle;
+	unsigned int count, i;
+	FILE *f;
+	const char *outmsgid;
+
+	/* Get recipients */
+	recipients = array_get(&mtctx->recipients, &count);
+	if ( count == 0  ) {
+		sieve_enotify_warning(nlog,
+			"notify mailto uri specifies no recipients; action has no effect");
+		return TRUE;
+	}
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_enotify_warning(nlog,
+			"notify mailto method has no means to send mail");
+		return TRUE;
+	}
+
+	/* Determine message from address */
+	if ( act->from == NULL ) {
+		from = t_strdup_printf("Postmaster <%s>", senv->postmaster_address);
+	} else {
+		from = act->from;
+	}
+
+	/* Determine SMTP from address */
+	if ( sieve_message_get_sender(nenv->msgctx) != NULL ) {
+		if ( mtctx->from_normalized == NULL ) {
+			from_smtp = senv->postmaster_address;
+		} else {
+			from_smtp = mtctx->from_normalized;
+		}
+	}
+
+	/* Determine subject */
+	if ( act->message != NULL ) {
+		/* FIXME: handle UTF-8 */
+		subject = str_sanitize(act->message, NTFY_MAILTO_MAX_SUBJECT);
+	} else if ( subject == NULL ) {
+		const char *const *hsubject;
+
+		/* Fetch subject from original message */
+		if ( mail_get_headers_utf8
+			(msgdata->mail, "subject", &hsubject) >= 0 )
+			subject = str_sanitize(t_strdup_printf("Notification: %s", hsubject[0]),
+				NTFY_MAILTO_MAX_SUBJECT);
+		else
+			subject = "Notification: (no subject)";
+	}
+
+	/* Compose To and Cc headers */
+	to = NULL;
+	cc = NULL;
+	for ( i = 0; i < count; i++ ) {
+		if ( recipients[i].carbon_copy ) {
+			if ( cc == NULL ) {
+				cc = t_str_new(256);
+				str_append(cc, recipients[i].full);
+			} else {
+				str_append(cc, ", ");
+				str_append(cc, recipients[i].full);
+			}
+		} else {
+			if ( to == NULL ) {
+				to = t_str_new(256);
+				str_append(to, recipients[i].full);
+			} else {
+				str_append(to, ", ");
+				str_append(to, recipients[i].full);
+			}
+		}
+	}
+
+	/* Send message to all recipients */
+	for ( i = 0; i < count; i++ ) {
+		const struct ntfy_mailto_header_field *headers;
+		unsigned int h, hcount;
+
+		smtp_handle = senv->smtp_open(recipients[i].normalized, from_smtp, &f);
+		outmsgid = sieve_message_get_new_id(senv);
+
+		rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+		rfc2822_header_field_write(f, "Message-ID", outmsgid);
+		rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+		rfc2822_header_field_utf8_printf(f, "Subject", "%s", subject);
+
+		rfc2822_header_field_utf8_printf(f, "From", "%s", from);
+
+		if ( to != NULL )
+			rfc2822_header_field_utf8_printf(f, "To", "%s", str_c(to));
+
+		if ( cc != NULL )
+			rfc2822_header_field_utf8_printf(f, "Cc", "%s", str_c(cc));
+
+		rfc2822_header_field_printf(f, "Auto-Submitted",
+			"auto-notified; owner-email=\"%s\"", recipient);
+		rfc2822_header_field_write(f, "Precedence", "bulk");
+
+		/* Set importance */
+		switch ( act->importance ) {
+		case 1:
+			rfc2822_header_field_write(f, "X-Priority", "1 (Highest)");
+			rfc2822_header_field_write(f, "Importance", "High");
+			break;
+		case 3:
+			rfc2822_header_field_write(f, "X-Priority", "5 (Lowest)");
+			rfc2822_header_field_write(f, "Importance", "Low");
+			break;
+		case 2:
+		default:
+			rfc2822_header_field_write(f, "X-Priority", "3 (Normal)");
+			rfc2822_header_field_write(f, "Importance", "Normal");
+			break;
+		}
+
+		/* Add custom headers */
+
+		headers = array_get(&mtctx->headers, &hcount);
+		for ( h = 0; h < hcount; h++ ) {
+			const char *name = rfc2822_header_field_name_sanitize(headers[h].name);
+
+			rfc2822_header_field_write(f, name, headers[h].body);
+		}
+
+		/* Generate message body */
+		if ( body != NULL ) {
+			if (_contains_8bit(body)) {
+				rfc2822_header_field_write(f, "MIME-Version", "1.0");
+				rfc2822_header_field_write
+					(f, "Content-Type", "text/plain; charset=UTF-8");
+				rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+			}
+
+			fprintf(f, "\r\n");
+			fprintf(f, "%s\r\n", body);
+
+		} else {
+			fprintf(f, "\r\n");
+			fprintf(f, "Notification of new message.\r\n");
+		}
+
+		if ( senv->smtp_close(smtp_handle) ) {
+			sieve_enotify_log(nlog,
+				"sent mail notification to <%s>",
+				str_sanitize(recipients[i].normalized, 80));
+		} else {
+			sieve_enotify_error(nlog,
+				"failed to send mail notification to <%s> "
+				"(refer to system log for more information)",
+				str_sanitize(recipients[i].normalized, 80));
+		}
+	}
+
+	return TRUE;
+}
+
+static bool ntfy_mailto_action_execute
+(const struct sieve_enotify_exec_env *nenv,
+	const struct sieve_enotify_action *act)
+{
+	const char *const *headers;
+	const char *sender = sieve_message_get_sender(nenv->msgctx);
+	const char *recipient = sieve_message_get_recipient(nenv->msgctx);
+
+	/* Is the recipient unset?
+	 */
+	if ( recipient == NULL ) {
+		sieve_enotify_warning(nenv->notify_log,
+			"notify mailto action aborted: envelope recipient is <>");
+		return TRUE;
+	}
+
+	/* Is the message an automatic reply ? */
+	if ( mail_get_headers
+		(nenv->msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		const char *const *hdsp = headers;
+
+		/* Theoretically multiple headers could exist, so lets make sure */
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_enotify_log(nenv->notify_log,
+					"not sending notification for auto-submitted message from <%s>",
+					str_sanitize(sender, 128));
+					return TRUE;
+			}
+			hdsp++;
+		}
+	}
+
+	return ntfy_mailto_send(nenv, act, recipient);
+}
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h
@@ -0,0 +1,140 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXT_ENOTIFY_H
+#define __SIEVE_EXT_ENOTIFY_H
+
+#include "lib.h"
+#include "compat.h"
+#include <stdarg.h>
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_enotify_log;
+struct sieve_enotify_context;
+struct sieve_enotify_action;
+struct sieve_enotify_print_env;
+struct sieve_enotify_exec_env;
+
+/*
+ * Notify context
+ */
+
+struct sieve_enotify_context {
+	struct sieve_error_handler *ehandler;
+
+	/* Script location */
+	const struct sieve_script *script;
+	unsigned int source_line;
+
+	const struct sieve_message_data *msgdata;
+	pool_t pool;
+};
+
+/*
+ * Notify methods
+ */
+
+struct sieve_enotify_method {
+	const char *identifier;
+
+	/* Validation */
+	bool (*compile_check_uri)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body);
+	bool (*compile_check_message)
+		(const struct sieve_enotify_log *nlog, string_t *message);
+	bool (*compile_check_from)
+		(const struct sieve_enotify_log *nlog, string_t *from);
+	bool (*compile_check_option)
+		(const struct sieve_enotify_log *nlog, const char *option,
+			const char *value);
+
+	/* Runtime */
+	bool (*runtime_check_uri)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body);
+	const char *(*runtime_get_method_capability)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body, const char *capability);
+	bool (*runtime_check_operands)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body, string_t *message, string_t *from,
+			pool_t context_pool, void **method_context);
+	bool (*runtime_set_option)
+		(const struct sieve_enotify_log *nlog, void *method_context,
+			const char *option, const char *value);
+
+	/* Action duplicates */
+	int (*action_check_duplicates)
+		(const struct sieve_enotify_log *nlog, void *method_ctx1,
+			void *method_ctx2, const char *dupl_location);
+
+	/* Action print */
+	void (*action_print)
+		(const struct sieve_enotify_print_env *penv,
+			const struct sieve_enotify_action *act);
+
+	/* Action execution */
+	bool (*action_execute)
+		(const struct sieve_enotify_exec_env *nenv,
+			const struct sieve_enotify_action *act);
+};
+
+void sieve_enotify_method_register
+(struct sieve_extension *ntfy_ext, const struct sieve_enotify_method *method);
+
+/*
+ * Notify method printing
+ */
+
+void sieve_enotify_method_printf
+	(const struct sieve_enotify_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+/*
+ * Notify execution environment
+ */
+
+struct sieve_enotify_exec_env {
+	const struct sieve_enotify_log *notify_log;
+
+	const struct sieve_script_env *scriptenv;
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+};
+
+/*
+ * Notify action
+ */
+
+struct sieve_enotify_action {
+	const struct sieve_enotify_method *method;
+	void *method_context;
+
+	sieve_number_t importance;
+	const char *message;
+	const char *from;
+};
+
+/*
+ * Logging
+ */
+
+void sieve_enotify_error
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_enotify_warning
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_enotify_log
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+#endif /* __SIEVE_EXT_ENOTIFY_H */
+
Index: b/sieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c
@@ -0,0 +1,258 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * String test
+ *
+ * Syntax:
+ *   notify_method_capability [COMPARATOR] [MATCH-TYPE]
+ *     <notification-uri: string>
+ *     <notification-capability: string>
+ *     <key-list: string-list>
+ */
+
+static bool tst_notifymc_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_notifymc_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_notifymc_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def notify_method_capability_test = {
+	"notify_method_capability",
+	SCT_TEST,
+	3, 0, FALSE, FALSE,
+	tst_notifymc_registered,
+	NULL,
+	tst_notifymc_validate,
+	tst_notifymc_generate,
+	NULL
+};
+
+/*
+ * String operation
+ */
+
+static bool tst_notifymc_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_notifymc_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def notify_method_capability_operation = {
+	"NOTIFY_METHOD_CAPABILITY",
+	&enotify_extension,
+	EXT_ENOTIFY_OPERATION_NOTIFY_METHOD_CAPABILITY,
+	tst_notifymc_operation_dump,
+	tst_notifymc_operation_execute
+};
+
+/*
+ * Optional arguments
+ */
+
+enum tst_notifymc_optional {
+	OPT_END,
+	OPT_COMPARATOR,
+	OPT_MATCH_TYPE
+};
+
+/*
+ * Test registration
+ */
+
+static bool tst_notifymc_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Test validation
+ */
+
+static bool tst_notifymc_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "notification-uri", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "notification-capability", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key-list", 3, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Test generation
+ */
+
+static bool tst_notifymc_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit
+		(cgenv->sbin, cmd->ext, &notify_method_capability_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_notifymc_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "NOTIFY_METHOD_CAPABILITY");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+
+	return
+		sieve_opr_string_dump(denv, address, "notify uri") &&
+		sieve_opr_string_dump(denv, address, "notify capability") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_notifymc_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_context *mctx;
+	string_t *notify_uri, *notify_capability;
+	struct sieve_coded_stringlist *key_list;
+	const char *cap_value;
+	bool matched;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+		return ret;
+
+	/* Check whether we neatly finished the list of optional operands */
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read notify uri */
+	if ( !sieve_opr_string_read(renv, address, &notify_uri) ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uri operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read notify capability */
+	if ( !sieve_opr_string_read(renv, address, &notify_capability) ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uri operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY_METHOD_CAPABILITY test");
+
+	cap_value = ext_enotify_runtime_get_method_capability
+		(renv, 0 /* FIXME */, notify_uri, str_c(notify_capability));
+
+	if ( cap_value != NULL ) {
+		mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+		if ( (mret=sieve_match_value(mctx, cap_value, strlen(cap_value))) < 0 )
+			result = FALSE;
+		matched = ( mret > 0 );
+
+		if ( (mret=sieve_match_end(&mctx)) < 0 )
+			result = FALSE;
+		matched = ( mret > 0 ) || matched;
+	} else {
+		matched = FALSE;
+	}
+
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c
@@ -0,0 +1,144 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Valid_notify_method test
+ *
+ * Syntax:
+ *   valid_notify_method <notification-uris: string-list>
+ */
+
+static bool tst_vnotifym_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_vnotifym_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def valid_notify_method_test = {
+	"valid_notify_method",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_vnotifym_validate,
+	tst_vnotifym_generate,
+	NULL
+};
+
+/*
+ * Valid_notify_method operation
+ */
+
+static bool tst_vnotifym_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_vnotifym_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def valid_notify_method_operation = {
+	"VALID_NOTIFY_METHOD",
+	&enotify_extension,
+	EXT_ENOTIFY_OPERATION_VALID_NOTIFY_METHOD,
+	tst_vnotifym_operation_dump,
+	tst_vnotifym_operation_execute
+};
+
+/*
+ * Test validation
+ */
+
+static bool tst_vnotifym_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "notification-uris", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/*
+ * Test generation
+ */
+
+static bool tst_vnotifym_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &valid_notify_method_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_vnotifym_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "VALID_NOTIFY_METHOD");
+	sieve_code_descend(denv);
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "notify-uris");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_vnotifym_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_coded_stringlist *notify_uris;
+	string_t *uri_item;
+	bool result = TRUE, all_valid = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Read notify uris */
+	if ( (notify_uris=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uris operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "VALID_NOTIFY_METHOD test");
+
+	uri_item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(notify_uris, &uri_item))
+		&& uri_item != NULL ) {
+
+		if ( !ext_enotify_runtime_method_validate(renv, 0 /* FIXME */, uri_item) ) {
+			all_valid = FALSE;
+			break;
+		}
+	}
+
+	if ( !result ) {
+		sieve_runtime_trace_error(renv, "invalid method uri item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_interpreter_set_test_result(renv->interp, all_valid);
+	return SIEVE_EXEC_OK;
+}
Index: b/sieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c
@@ -0,0 +1,84 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Encodeurl modifier
+ */
+
+bool mod_encodeurl_modify(string_t *in, string_t **result);
+
+const struct sieve_variables_modifier_def encodeurl_modifier = {
+	SIEVE_OBJECT("encodeurl", &encodeurl_operand, 0),
+	15,
+	mod_encodeurl_modify
+};
+
+/*
+ * Modifier operand
+ */
+
+static const struct sieve_extension_objects ext_enotify_modifiers =
+	SIEVE_VARIABLES_DEFINE_MODIFIER(encodeurl_modifier);
+
+const struct sieve_operand_def encodeurl_operand = {
+	"modifier",
+	&enotify_extension,
+	0,
+	&sieve_variables_modifier_operand_class,
+	&ext_enotify_modifiers
+};
+
+/*
+ * Modifier implementation
+ */
+
+static const char _uri_reserved_lookup[256] = {
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 00
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 10
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,  // 20
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  // 30
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 40
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  // 50
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 60
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,  // 70
+
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 80
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 90
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // A0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // B0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // D0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // F0
+};
+
+bool mod_encodeurl_modify(string_t *in, string_t **result)
+{
+	unsigned int i;
+	const unsigned char *c;
+
+	*result = t_str_new(2*str_len(in));
+	c = str_data(in);
+
+	for ( i = 0; i < str_len(in); i++, c++ ) {
+		if ( _uri_reserved_lookup[*c] ) {
+			str_printfa(*result, "%%%02X", *c);
+		} else {
+			str_append_c(*result, *c);
+		}
+	}
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/environment/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/Makefile.am
@@ -0,0 +1,20 @@
+noinst_LTLIBRARIES = libsieve_ext_environment.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tests = \
+	tst-environment.c
+
+libsieve_ext_environment_la_SOURCES = \
+	$(tests) \
+	ext-environment-common.c \
+	ext-environment.c
+
+noinst_HEADERS = \
+	ext-environment-common.h \
+	sieve-ext-environment.h
Index: b/sieve/src/lib-sieve/plugins/environment/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/Makefile.in
@@ -0,0 +1,498 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/environment
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_environment_la_LIBADD =
+am__objects_1 = tst-environment.lo
+am_libsieve_ext_environment_la_OBJECTS = $(am__objects_1) \
+	ext-environment-common.lo ext-environment.lo
+libsieve_ext_environment_la_OBJECTS =  \
+	$(am_libsieve_ext_environment_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_environment_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_environment_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_environment.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tests = \
+	tst-environment.c
+
+libsieve_ext_environment_la_SOURCES = \
+	$(tests) \
+	ext-environment-common.c \
+	ext-environment.c
+
+noinst_HEADERS = \
+	ext-environment-common.h \
+	sieve-ext-environment.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/environment/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/environment/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_environment.la: $(libsieve_ext_environment_la_OBJECTS) $(libsieve_ext_environment_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_environment_la_OBJECTS) $(libsieve_ext_environment_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-environment-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-environment.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-environment.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/environment/ext-environment-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/ext-environment-common.c
@@ -0,0 +1,197 @@
+#include "lib.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+
+#include "ext-environment-common.h"
+
+struct ext_environment_context {
+	struct hash_table *environment_items;
+};
+
+/*
+ * Core environment items
+ */
+
+static const struct sieve_environment_item *core_env_items[] = {
+	&domain_env_item,
+	&host_env_item,
+	&location_env_item,
+	&phase_env_item,
+	&name_env_item,
+	&version_env_item
+};
+
+static unsigned int core_env_items_count = N_ELEMENTS(core_env_items);
+
+/*
+ * Registration
+ */
+
+static void ext_environment_item_register
+(struct ext_environment_context *ectx,
+	const struct sieve_environment_item *item)
+{
+	hash_table_insert
+		(ectx->environment_items, (void *) item->name, (void *) item);
+}
+
+void sieve_ext_environment_item_register
+(const struct sieve_extension *ext, const struct sieve_environment_item *item)
+{
+	struct ext_environment_context *ectx =
+		(struct ext_environment_context *) ext->context;
+
+	ext_environment_item_register(ectx, item);
+}
+
+/*
+ * Initialization
+ */
+
+bool ext_environment_init
+(const struct sieve_extension *ext ATTR_UNUSED, void **context)
+{
+	struct ext_environment_context *ectx =
+		i_new(struct ext_environment_context, 1);
+
+	unsigned int i;
+
+	ectx->environment_items = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+
+	for ( i = 0; i < core_env_items_count; i++ ) {
+		ext_environment_item_register(ectx, core_env_items[i]);
+	}
+
+	*context = (void *) ectx;
+
+	return TRUE;
+}
+
+void ext_environment_deinit(const struct sieve_extension *ext)
+{
+	struct ext_environment_context *ectx =
+		(struct ext_environment_context *) ext->context;
+
+	hash_table_destroy(&ectx->environment_items);
+	i_free(ectx);
+}
+
+
+/*
+ * Retrieval
+ */
+
+const char *ext_environment_item_get_value
+(const struct sieve_extension *ext, const char *name,
+	const struct sieve_script_env *senv)
+{
+	struct ext_environment_context *ectx =
+		(struct ext_environment_context *) ext->context;
+	const struct sieve_environment_item *item =
+		(const struct sieve_environment_item *)
+			hash_table_lookup(ectx->environment_items, name);
+
+	if ( item == NULL )
+		return NULL;
+
+	if ( item->value != NULL )
+		return item->value;
+
+	if ( item->get_value != NULL )
+		return item->get_value(senv);
+
+	return NULL;
+}
+
+/*
+ * Default environment items
+ */
+
+/* "domain":
+ *
+ *   The primary DNS domain associated with the Sieve execution context, usually
+ *   but not always a proper suffix of the host name.
+ */
+const struct sieve_environment_item domain_env_item = {
+	"domain",
+	NULL,
+	NULL,
+};
+
+/* "host":
+ *
+ *   The fully-qualified domain name of the host where the Sieve script is
+ *   executing.
+ */
+
+static const char *envit_host_get_value(const struct sieve_script_env *senv)
+{
+	return senv->hostname != NULL ? senv->hostname : "";
+}
+
+const struct sieve_environment_item host_env_item = {
+	"host",
+	NULL,
+	envit_host_get_value,
+};
+
+/* "location":
+ *
+ *   Sieve evaluation can be performed at various different points as messages
+ *   are processed. This item provides additional information about the type of
+ *   service that is evaluating the script.  Possible values are:
+ *    "MTA" - the Sieve script is being evaluated by a Message Transfer Agent
+ *    "MDA" - evaluation is being performed by a Mail Delivery Agent
+ *    "MUA" - evaluation is being performed by a Mail User Agent
+ *    "MS"  - evaluation is being performed by a Message Store
+ */
+const struct sieve_environment_item location_env_item = {
+	"location",
+	NULL,
+	NULL,
+};
+
+/* "phase":
+ *
+ *   The point relative to final delivery where the Sieve script is being
+ *   evaluated.  Possible values are "pre", "during", and "post", referring
+ *   respectively to processing before, during, and after final delivery has
+ *   taken place.
+ */
+
+const struct sieve_environment_item phase_env_item = {
+	"phase",
+	NULL,
+	NULL,
+};
+
+/* "name":
+ *
+ *  The product name associated with the Sieve interpreter.
+ */
+const struct sieve_environment_item name_env_item = {
+	"name",
+	SIEVE_NAME,
+	NULL,
+};
+
+/* "version":
+ *
+ * The product version associated with the Sieve interpreter. The meaning of the
+ * product version string is product-specific and should always be considered
+ * in the context of the product name given by the "name" item.
+ */
+
+const struct sieve_environment_item version_env_item = {
+	"version",
+	SIEVE_VERSION,
+	NULL,
+};
+
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/environment/ext-environment-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/ext-environment-common.h
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENVIRONMENT_COMMON_H
+#define __EXT_ENVIRONMENT_COMMON_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ext-environment.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def environment_extension;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def tst_environment;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def tst_environment_operation;
+
+/*
+ * Environment items
+ */
+
+extern const struct sieve_environment_item domain_env_item;
+extern const struct sieve_environment_item host_env_item;
+extern const struct sieve_environment_item location_env_item;
+extern const struct sieve_environment_item phase_env_item;
+extern const struct sieve_environment_item name_env_item;
+extern const struct sieve_environment_item version_env_item;
+
+/*
+ * Initialization
+ */
+
+bool ext_environment_init(const struct sieve_extension *ext, void **context);
+void ext_environment_deinit(const struct sieve_extension *ext);
+
+/*
+ * Environment item retrieval
+ */
+
+const char *ext_environment_item_get_value
+	(const struct sieve_extension *ext, const char *name,
+		const struct sieve_script_env *senv);
+
+#endif /* __EXT_VARIABLES_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/environment/ext-environment.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/ext-environment.c
@@ -0,0 +1,51 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension variables
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5183
+ * Implementation: full
+ * Status: experimental, not thoroughly tested
+ *
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-validator.h"
+
+#include "ext-environment-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_environment_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def environment_extension = {
+	"environment",
+	ext_environment_init,
+	ext_environment_deinit,
+	ext_environment_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(tst_environment_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_environment_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	sieve_validator_register_command(valdtr, ext, &tst_environment);
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h
@@ -0,0 +1,17 @@
+#ifndef __SIEVE_EXT_ENVIRONMENT_H
+#define __SIEVE_EXT_ENVIRONMENT_H
+
+#include "sieve-common.h"
+
+struct sieve_environment_item {
+	const char *name;
+
+	const char *value;
+	const char *(*get_value)(const struct sieve_script_env *senv);
+};
+
+void sieve_ext_environment_item_register
+	(const struct sieve_extension *ext,
+		const struct sieve_environment_item *item);
+
+#endif
Index: b/sieve/src/lib-sieve/plugins/environment/tst-environment.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/environment/tst-environment.c
@@ -0,0 +1,232 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-environment-common.h"
+
+/*
+ * Environment test
+ *
+ * Syntax:
+ *   environment [COMPARATOR] [MATCH-TYPE]
+ *      <name: string> <key-list: string-list>
+ */
+
+static bool tst_environment_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_environment_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_environment_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def tst_environment = {
+	"environment",
+	SCT_TEST,
+	2, 0, FALSE, FALSE,
+	tst_environment_registered,
+	NULL,
+	tst_environment_validate,
+	tst_environment_generate,
+	NULL
+};
+
+/*
+ * Environment operation
+ */
+
+static bool tst_environment_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_environment_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def tst_environment_operation = {
+	"ENVIRONMENT",
+	&environment_extension,
+	0,
+	tst_environment_operation_dump,
+	tst_environment_operation_execute
+};
+
+/*
+ * Test registration
+ */
+
+static bool tst_environment_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Test validation
+ */
+
+static bool tst_environment_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Test generation
+ */
+
+static bool tst_environment_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &tst_environment_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_environment_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "ENVIRONMENT");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+
+	return
+		sieve_opr_string_dump(denv, address, "name") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_environment_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_context *mctx;
+	string_t *name;
+	struct sieve_coded_stringlist *key_list;
+	const char *env_item;
+	bool matched = FALSE;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+		return ret;
+
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read source */
+	if ( !sieve_opr_string_read(renv, address, &name) ) {
+		sieve_runtime_trace_error(renv, "invalid name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "ENVIRONMENT test");
+
+	env_item = ext_environment_item_get_value
+		(this_ext, str_c(name), renv->scriptenv);
+
+	if ( env_item != NULL ) {
+		mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+		if ( (mret=sieve_match_value(mctx, strlen(env_item) == 0 ? NULL : env_item,
+			strlen(env_item))) < 0 ) {
+			result = FALSE;
+		} else {
+			matched = ( mret > 0 );
+		}
+
+		if ( (mret=sieve_match_end(&mctx)) < 0 )
+			result = FALSE;
+		else
+			matched = ( mret > 0 || matched );
+	}
+
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid key list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/plugins/imap4flags/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/Makefile.am
@@ -0,0 +1,30 @@
+noinst_LTLIBRARIES = libsieve_ext_imap4flags.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+    -I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-flag.c
+
+tests = \
+	tst-hasflag.c
+
+tags = \
+	tag-flags.c
+
+libsieve_ext_imap4flags_la_SOURCES = \
+	ext-imap4flags-common.c \
+	$(commands) \
+	$(tests) \
+	$(tags) \
+	ext-imap4flags.c \
+	ext-imapflags.c
+
+
+noinst_HEADERS = \
+	ext-imap4flags-common.h
Index: b/sieve/src/lib-sieve/plugins/imap4flags/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/Makefile.in
@@ -0,0 +1,513 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/imap4flags
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_imap4flags_la_LIBADD =
+am__objects_1 = cmd-flag.lo
+am__objects_2 = tst-hasflag.lo
+am__objects_3 = tag-flags.lo
+am_libsieve_ext_imap4flags_la_OBJECTS = ext-imap4flags-common.lo \
+	$(am__objects_1) $(am__objects_2) $(am__objects_3) \
+	ext-imap4flags.lo ext-imapflags.lo
+libsieve_ext_imap4flags_la_OBJECTS =  \
+	$(am_libsieve_ext_imap4flags_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_imap4flags_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_imap4flags_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_imap4flags.la
+AM_CPPFLAGS = \
+	-I../../ \
+    -I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-flag.c
+
+tests = \
+	tst-hasflag.c
+
+tags = \
+	tag-flags.c
+
+libsieve_ext_imap4flags_la_SOURCES = \
+	ext-imap4flags-common.c \
+	$(commands) \
+	$(tests) \
+	$(tags) \
+	ext-imap4flags.c \
+	ext-imapflags.c
+
+noinst_HEADERS = \
+	ext-imap4flags-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/imap4flags/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/imap4flags/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_imap4flags.la: $(libsieve_ext_imap4flags_la_OBJECTS) $(libsieve_ext_imap4flags_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_imap4flags_la_OBJECTS) $(libsieve_ext_imap4flags_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-flag.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-imap4flags-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-imap4flags.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-imapflags.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tag-flags.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-hasflag.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c
@@ -0,0 +1,260 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Commands
+ */
+
+/* Forward declarations */
+
+static bool cmd_flag_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+/* Setflag command
+ *
+ * Syntax:
+ *   setflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command_def cmd_setflag = {
+	"setflag",
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE,
+	NULL, NULL,
+	ext_imap4flags_command_validate,
+	cmd_flag_generate,
+	NULL
+};
+
+/* Addflag command
+ *
+ * Syntax:
+ *   addflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command_def cmd_addflag = {
+	"addflag",
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE,
+	NULL, NULL,
+	ext_imap4flags_command_validate,
+	cmd_flag_generate,
+	NULL
+};
+
+
+/* Removeflag command
+ *
+ * Syntax:
+ *   removeflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command_def cmd_removeflag = {
+	"removeflag",
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE,
+	NULL, NULL,
+	ext_imap4flags_command_validate,
+	cmd_flag_generate,
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+/* Forward declarations */
+
+bool cmd_flag_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_flag_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Setflag operation */
+
+const struct sieve_operation_def setflag_operation = {
+	"SETFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_SETFLAG,
+	cmd_flag_operation_dump,
+	cmd_flag_operation_execute
+};
+
+/* Addflag operation */
+
+const struct sieve_operation_def addflag_operation = {
+	"ADDFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_ADDFLAG,
+	cmd_flag_operation_dump,
+	cmd_flag_operation_execute
+};
+
+/* Removeflag operation */
+
+const struct sieve_operation_def removeflag_operation = {
+	"REMOVEFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_REMOVEFLAG,
+	cmd_flag_operation_dump,
+	cmd_flag_operation_execute
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_flag_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	/* Emit operation */
+	if ( sieve_command_is(cmd, cmd_setflag) )
+		sieve_operation_emit(cgenv->sbin, cmd->ext, &setflag_operation);
+	else if ( sieve_command_is(cmd, cmd_addflag) )
+		sieve_operation_emit(cgenv->sbin, cmd->ext, &addflag_operation);
+	else if ( sieve_command_is(cmd, cmd_removeflag) )
+		sieve_operation_emit(cgenv->sbin, cmd->ext, &removeflag_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+bool cmd_flag_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	struct sieve_operand operand;
+
+	sieve_code_dumpf(denv, "%s", sieve_operation_mnemonic(&denv->oprtn));
+	sieve_code_descend(denv);
+
+	sieve_code_mark(denv);
+	if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	if ( sieve_operand_is_variable(&operand) ) {
+		return
+			sieve_opr_string_dump_data(denv, &operand, address,
+				"variable name") &&
+			sieve_opr_stringlist_dump(denv, address,
+				"list of flags");
+	}
+
+	return
+		sieve_opr_stringlist_dump_data(denv, &operand, address,
+			"list of flags");
+}
+
+/*
+ * Code execution
+ */
+
+static int cmd_flag_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &renv->oprtn;
+	struct sieve_operand operand;
+	bool result = TRUE;
+	string_t *flag_item;
+	struct sieve_coded_stringlist *flag_list;
+	struct sieve_variable_storage *storage;
+	unsigned int var_index;
+	ext_imapflag_flag_operation_t flag_op;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+		sieve_runtime_trace_error(renv, "invalid operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( sieve_operand_is_variable(&operand) ) {
+
+		/* Read the variable operand */
+		if ( !sieve_variable_operand_read_data
+			(renv, &operand, address, &storage, &var_index) ) {
+			sieve_runtime_trace_error(renv, "invalid variable operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		/* Read flag list */
+		if ( (flag_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+			sieve_runtime_trace_error(renv, "invalid flag-list operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+	} else if ( sieve_operand_is_stringlist(&operand) ) {
+		storage = NULL;
+		var_index = 0;
+
+		/* Read flag list */
+		if ( (flag_list=sieve_opr_stringlist_read_data
+			(renv, &operand, address)) == NULL ) {
+			sieve_runtime_trace_error(renv, "invalid flag-list operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+	} else {
+		sieve_runtime_trace_error(renv, "unexpected operand '%s'",
+			sieve_operand_name(&operand));
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "%s command", sieve_operation_mnemonic(op));
+
+	/* Determine what to do */
+
+	if ( sieve_operation_is(op, setflag_operation) )
+		flag_op = ext_imap4flags_set_flags;
+	else if ( sieve_operation_is(op, addflag_operation) )
+		flag_op = ext_imap4flags_add_flags;
+	else if ( sieve_operation_is(op, removeflag_operation) )
+		flag_op = ext_imap4flags_remove_flags;
+	else
+		i_unreached();
+
+	/* Iterate through all flags and perform requested operation */
+
+	while ( (result=sieve_coded_stringlist_next_item(flag_list, &flag_item)) &&
+		flag_item != NULL ) {
+
+		if ( (ret=flag_op(renv, storage, var_index, flag_item)) <= 0)
+			return ret;
+	}
+
+	if ( !result ) {
+		sieve_runtime_trace_error(renv, "invalid flag-list item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	return SIEVE_EXEC_OK;
+}
Index: b/sieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c
@@ -0,0 +1,529 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Forward declarations
+ */
+
+static bool flag_is_valid(const char *flag);
+
+/*
+ * Tagged arguments
+ */
+
+extern const struct sieve_argument_def tag_flags;
+extern const struct sieve_argument_def tag_flags_implicit;
+
+/*
+ * Common command functions
+ */
+
+bool ext_imap4flags_command_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct sieve_ast_argument *arg2;
+	const struct sieve_extension *var_ext;
+
+	/* Check arguments */
+
+	if ( arg == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"the %s %s expects at least one argument, but none was found",
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+		return FALSE;
+	}
+
+	if ( sieve_ast_argument_type(arg) != SAAT_STRING &&
+		sieve_ast_argument_type(arg) != SAAT_STRING_LIST )
+	{
+		sieve_argument_validate_error(valdtr, arg,
+			"the %s %s expects either a string (variable name) or "
+			"a string-list (list of flags) as first argument, but %s was found",
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+
+	arg2 = sieve_ast_argument_next(arg);
+	if ( arg2 != NULL ) {
+		/* First, check syntax sanity */
+
+		if ( sieve_ast_argument_type(arg) != SAAT_STRING )
+		{
+			if ( sieve_command_is(cmd, tst_hasflag) ) {
+				if ( sieve_ast_argument_type(arg) != SAAT_STRING_LIST ) {
+					sieve_argument_validate_error(valdtr, arg,
+						"if a second argument is specified for the hasflag, the first "
+						"must be a string-list (variable-list), but %s was found",
+						sieve_ast_argument_name(arg));
+					return FALSE;
+				}
+			} else {
+				sieve_argument_validate_error(valdtr, arg,
+					"if a second argument is specified for the %s %s, the first "
+					"must be a string (variable name), but %s was found",
+					sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+					sieve_ast_argument_name(arg));
+				return FALSE;
+			}
+		}
+
+		/* Then, check whether the second argument is permitted */
+
+		var_ext = sieve_ext_variables_get_extension(cmd->ext->svinst);
+
+		if ( var_ext == NULL || !sieve_ext_variables_is_active(var_ext, valdtr) )
+			{
+			sieve_argument_validate_error(valdtr,arg,
+				"the %s %s only allows for the specification of a "
+				"variable name when the variables extension is active",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+			return FALSE;
+		}
+
+		if ( !sieve_variable_argument_activate
+			(var_ext, valdtr, cmd, arg, !sieve_command_is(cmd, tst_hasflag) ) )
+			return FALSE;
+
+		if ( sieve_ast_argument_type(arg2) != SAAT_STRING &&
+			sieve_ast_argument_type(arg2) != SAAT_STRING_LIST )
+		{
+			sieve_argument_validate_error(valdtr, arg2,
+				"the %s %s expects a string list (list of flags) as "
+				"second argument when two arguments are specified, "
+				"but %s was found",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+				sieve_ast_argument_name(arg2));
+			return FALSE;
+		}
+	} else
+		arg2 = arg;
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, arg2, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_is(cmd, tst_hasflag) &&
+		sieve_argument_is_string_literal(arg2) ) {
+		struct ext_imap4flags_iter fiter;
+		const char *flag;
+
+		/* Warn the user about validity of verifiable flags */
+		ext_imap4flags_iter_init(&fiter, sieve_ast_argument_str(arg));
+
+		while ( (flag=ext_imap4flags_iter_get_flag(&fiter)) != NULL ) {
+			if ( !flag_is_valid(flag) ) {
+				sieve_argument_validate_warning(valdtr, arg,
+                	"IMAP flag '%s' specified for the %s command is invalid "
+					"and will be ignored (only first invalid is reported)",
+					str_sanitize(flag, 64), sieve_command_identifier(cmd));
+				break;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Flags tag registration
+ */
+
+void ext_imap4flags_attach_flags_tag
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const char *command)
+{
+	/* Register :flags tag with the command and we don't care whether it is
+	 * registered or even whether it will be registered at all. The validator
+	 * handles either situation gracefully
+	 */
+
+	/* Tag specified by user */
+	sieve_validator_register_external_tag
+		(valdtr, command, ext, &tag_flags, SIEVE_OPT_SIDE_EFFECT);
+
+    /* Implicit tag if none is specified */
+	sieve_validator_register_persistent_tag
+		(valdtr, command, ext, &tag_flags_implicit);
+}
+
+/*
+ * Result context
+ */
+
+struct ext_imap4flags_result_context {
+    string_t *internal_flags;
+};
+
+static void _get_initial_flags
+(struct sieve_result *result, string_t *flags)
+{
+	const struct sieve_message_data *msgdata =
+		sieve_result_get_message_data(result);
+	enum mail_flags mail_flags;
+	const char *const *mail_keywords;
+
+	mail_flags = mail_get_flags(msgdata->mail);
+	mail_keywords = mail_get_keywords(msgdata->mail);
+
+	if ( (mail_flags & MAIL_FLAGGED) > 0 )
+		str_printfa(flags, " \\flagged");
+
+	if ( (mail_flags & MAIL_ANSWERED) > 0 )
+		str_printfa(flags, " \\answered");
+
+	if ( (mail_flags & MAIL_DELETED) > 0 )
+		str_printfa(flags, " \\deleted");
+
+	if ( (mail_flags & MAIL_SEEN) > 0 )
+		str_printfa(flags, " \\seen");
+
+	if ( (mail_flags & MAIL_DRAFT) > 0 )
+		str_printfa(flags, " \\draft");
+
+	while ( *mail_keywords != NULL ) {
+		str_printfa(flags, " %s", *mail_keywords);
+		mail_keywords++;
+	}
+}
+
+static inline struct ext_imap4flags_result_context *_get_result_context
+(const struct sieve_extension *this_ext, struct sieve_result *result)
+{
+	struct ext_imap4flags_result_context *rctx =
+		(struct ext_imap4flags_result_context *)
+		sieve_result_extension_get_context(result, this_ext);
+
+	if ( rctx == NULL ) {
+		pool_t pool = sieve_result_pool(result);
+
+		rctx =p_new(pool, struct ext_imap4flags_result_context, 1);
+		rctx->internal_flags = str_new(pool, 32);
+		_get_initial_flags(result, rctx->internal_flags);
+
+		sieve_result_extension_set_context
+			(result, this_ext, rctx);
+	}
+
+	return rctx;
+}
+
+static string_t *_get_flags_string
+(const struct sieve_extension *this_ext, struct sieve_result *result)
+{
+	struct ext_imap4flags_result_context *ctx =
+		_get_result_context(this_ext, result);
+
+	return ctx->internal_flags;
+}
+
+/*
+ * Runtime initialization
+ */
+
+static void ext_imap4flags_runtime_init
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	void *context ATTR_UNUSED)
+{
+	sieve_result_add_implicit_side_effect
+		(renv->result, NULL, TRUE, ext, &flags_side_effect, NULL);
+}
+
+const struct sieve_interpreter_extension imap4flags_interpreter_extension = {
+	&imap4flags_extension,
+	ext_imap4flags_runtime_init,
+	NULL,
+};
+
+/*
+ * Flag operations
+ */
+
+/* FIXME: This currently accepts a potentially unlimited number of
+ * flags, making the internal or variable flag list indefinitely long
+ */
+static bool flag_is_valid(const char *flag)
+{
+	if (*flag == '\\') {
+		/* System flag */
+		const char *atom = t_str_ucase(flag);
+
+		if (
+			(strcmp(atom, "\\ANSWERED") != 0) &&
+			(strcmp(atom, "\\FLAGGED") != 0) &&
+			(strcmp(atom, "\\DELETED") != 0) &&
+			(strcmp(atom, "\\SEEN") != 0) &&
+			(strcmp(atom, "\\DRAFT") != 0) )
+		{
+			return FALSE;
+		}
+	} else {
+		/* Custom keyword:
+		 *
+		 * The validity of the keyword cannot be validated until the
+		 * target mailbox for the message is known. Meaning that the
+		 * verfication of keyword can only be performed when the
+		 * action side effect is about to be executed.
+		 *
+		 * FIXME: technically this is nonsense, since we can simply parse
+		 * using the flag-keyword grammar provided by imap.
+		 */
+	}
+
+	return TRUE;
+}
+
+void ext_imap4flags_iter_init
+(struct ext_imap4flags_iter *iter, string_t *flags_list)
+{
+	iter->flags_list = flags_list;
+	iter->offset = 0;
+	iter->last = 0;
+}
+
+const char *ext_imap4flags_iter_get_flag
+(struct ext_imap4flags_iter *iter)
+{
+	unsigned int len = str_len(iter->flags_list);
+	const unsigned char *fp;
+	const unsigned char *fbegin;
+	const unsigned char *fstart;
+	const unsigned char *fend;
+
+	if ( iter->offset >= len ) return NULL;
+
+	fbegin = str_data(iter->flags_list);
+	fp = fbegin + iter->offset;
+	fstart = fp;
+	fend = fbegin + len;
+	for (;;) {
+		if ( fp >= fend || *fp == ' ' ) {
+			if ( fp > fstart ) {
+				const char *flag = t_strdup_until(fstart, fp);
+
+				iter->last = fstart - fbegin;
+				iter->offset = fp - fbegin;
+				return flag;
+			}
+
+			fstart = fp+1;
+		}
+
+		if ( fp >= fend ) break;
+
+		fp++;
+	}
+
+	iter->last = fstart - fbegin;
+	iter->offset = fp - fbegin;
+	return NULL;
+}
+
+static void ext_imap4flags_iter_delete_last
+(struct ext_imap4flags_iter *iter)
+{
+	iter->offset++;
+	if ( iter->offset > str_len(iter->flags_list) )
+		iter->offset = str_len(iter->flags_list);
+	if ( iter->offset == str_len(iter->flags_list) )
+		iter->last--;
+
+	str_delete(iter->flags_list, iter->last, iter->offset - iter->last);
+
+	iter->offset = iter->last;
+}
+
+static bool flags_list_flag_exists
+(string_t *flags_list, const char *flag)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+
+	ext_imap4flags_iter_init(&flit, flags_list);
+
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( strcasecmp(flg, flag) == 0 )
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+static void flags_list_flag_delete
+(string_t *flags_list, const char *flag)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+
+	ext_imap4flags_iter_init(&flit, flags_list);
+
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( strcasecmp(flg, flag) == 0 ) {
+			ext_imap4flags_iter_delete_last(&flit);
+		}
+	}
+}
+
+static void flags_list_add_flags
+(string_t *flags_list, string_t *flags)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+
+	ext_imap4flags_iter_init(&flit, flags);
+
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( flag_is_valid(flg) && !flags_list_flag_exists(flags_list, flg) ) {
+			if ( str_len(flags_list) != 0 )
+				str_append_c(flags_list, ' ');
+			str_append(flags_list, flg);
+		}
+	}
+}
+
+static void flags_list_remove_flags
+(string_t *flags_list, string_t *flags)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+
+	ext_imap4flags_iter_init(&flit, flags);
+
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		flags_list_flag_delete(flags_list, flg);
+	}
+}
+
+static void flags_list_set_flags
+(string_t *flags_list, string_t *flags)
+{
+	str_truncate(flags_list, 0);
+	flags_list_add_flags(flags_list, flags);
+}
+
+/*
+ * Flag registration
+ */
+
+int ext_imap4flags_set_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->oprtn.ext, renv->result);
+
+	if ( cur_flags != NULL )
+		flags_list_set_flags(cur_flags, flags);
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_add_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->oprtn.ext, renv->result);
+
+	if ( cur_flags != NULL )
+		flags_list_add_flags(cur_flags, flags);
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_remove_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->oprtn.ext, renv->result);
+
+	if ( cur_flags != NULL )
+		flags_list_remove_flags(cur_flags, flags);
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_get_flags_string
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, const char **flags)
+{
+	string_t *cur_flags;
+
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->oprtn.ext, renv->result);
+
+	if ( cur_flags == NULL )
+		*flags = "";
+	else
+		*flags = str_c(cur_flags);
+
+	return SIEVE_EXEC_OK;
+}
+
+void ext_imap4flags_get_flags_init
+(struct ext_imap4flags_iter *iter, const struct sieve_runtime_env *renv,
+	string_t *flags_list)
+{
+	string_t *cur_flags;
+
+	if ( flags_list != NULL ) {
+		cur_flags = t_str_new(256);
+
+		flags_list_set_flags(cur_flags, flags_list);
+	}
+	else
+		cur_flags = _get_flags_string(renv->oprtn.ext, renv->result);
+
+	ext_imap4flags_iter_init(iter, cur_flags);
+}
+
+void ext_imap4flags_get_implicit_flags_init
+(struct ext_imap4flags_iter *iter, const struct sieve_extension *this_ext,
+	struct sieve_result *result)
+{
+	string_t *cur_flags = _get_flags_string(this_ext, result);
+
+	ext_imap4flags_iter_init(iter, cur_flags);
+}
+
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h
@@ -0,0 +1,120 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_IMAP4FLAGS_COMMON_H
+#define __EXT_IMAP4FLAGS_COMMON_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-ext-variables.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def imap4flags_extension;
+extern const struct sieve_interpreter_extension
+	imap4flags_interpreter_extension;
+
+/*
+ * Side effect
+ */
+
+extern const struct sieve_side_effect_def flags_side_effect;
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand_def flags_side_effect_operand;
+
+/*
+ * Operations
+ */
+
+enum ext_imap4flags_opcode {
+	ext_imap4flags_OPERATION_SETFLAG,
+	ext_imap4flags_OPERATION_ADDFLAG,
+	ext_imap4flags_OPERATION_REMOVEFLAG,
+	ext_imap4flags_OPERATION_HASFLAG
+};
+
+extern const struct sieve_operation_def setflag_operation;
+extern const struct sieve_operation_def addflag_operation;
+extern const struct sieve_operation_def removeflag_operation;
+extern const struct sieve_operation_def hasflag_operation;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def cmd_setflag;
+extern const struct sieve_command_def cmd_addflag;
+extern const struct sieve_command_def cmd_removeflag;
+
+extern const struct sieve_command_def tst_hasflag;
+
+/*
+ * Common command functions
+ */
+
+bool ext_imap4flags_command_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+
+/*
+ * Flags tagged argument
+ */
+
+void ext_imap4flags_attach_flags_tag
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		const char *command);
+
+/*
+ * Flag management
+ */
+
+struct ext_imap4flags_iter {
+	string_t *flags_list;
+	unsigned int offset;
+	unsigned int last;
+};
+
+void ext_imap4flags_iter_init
+	(struct ext_imap4flags_iter *iter, string_t *flags_list);
+
+const char *ext_imap4flags_iter_get_flag
+	(struct ext_imap4flags_iter *iter);
+
+typedef int (*ext_imapflag_flag_operation_t)
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+
+int ext_imap4flags_set_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+int ext_imap4flags_add_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+int ext_imap4flags_remove_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+
+/*
+ * Flags access
+ */
+
+int ext_imap4flags_get_flags_string
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, const char **flags);
+
+void ext_imap4flags_get_flags_init
+	(struct ext_imap4flags_iter *iter, const struct sieve_runtime_env *renv,
+		string_t *flags_list);
+void ext_imap4flags_get_implicit_flags_init
+	(struct ext_imap4flags_iter *iter, const struct sieve_extension *this_ext,
+		struct sieve_result *result);
+
+
+#endif /* __EXT_IMAP4FLAGS_COMMON_H */
+
Index: b/sieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension imap4flags
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5232
+ * Implementation: full
+ * Status: experimental, roughly tested
+ *
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation_def *imap4flags_operations[] = {
+	&setflag_operation,
+	&addflag_operation,
+	&removeflag_operation,
+	&hasflag_operation
+};
+
+/*
+ * Extension
+ */
+
+static bool ext_imap4flags_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+static bool ext_imap4flags_interpreter_load
+	(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+		sieve_size_t *address);
+
+const struct sieve_extension_def imap4flags_extension = {
+	"imap4flags",
+	NULL, NULL,
+	ext_imap4flags_validator_load,
+	NULL,
+	ext_imap4flags_interpreter_load,
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(imap4flags_operations),
+	SIEVE_EXT_DEFINE_OPERAND(flags_side_effect_operand)
+};
+
+static bool ext_imap4flags_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register commands */
+	sieve_validator_register_command(valdtr, ext, &cmd_setflag);
+	sieve_validator_register_command(valdtr, ext, &cmd_addflag);
+	sieve_validator_register_command(valdtr, ext, &cmd_removeflag);
+	sieve_validator_register_command(valdtr, ext, &tst_hasflag);
+
+	ext_imap4flags_attach_flags_tag(valdtr, ext, "keep");
+	ext_imap4flags_attach_flags_tag(valdtr, ext, "fileinto");
+
+	return TRUE;
+}
+
+static bool ext_imap4flags_interpreter_load
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_interpreter_extension_register
+		(renv->interp, ext, &imap4flags_interpreter_extension, NULL);
+
+	return TRUE;
+}
+
+
+
Index: b/sieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c
@@ -0,0 +1,189 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension imapflags
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-melnikov-sieve-imapflags-03.txt
+ * Implementation: deprecated; provided for backwards compatibility
+ * Status: deprecated
+ *
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Commands
+ */
+
+static bool cmd_mark_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+
+/* Mark command
+ *
+ * Syntax:
+ *   mark
+ */
+
+static const struct sieve_command_def cmd_mark = {
+    "mark",
+    SCT_COMMAND,
+    0, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_mark_validate,
+    NULL, NULL,
+};
+
+/* Unmark command
+ *
+ * Syntax:
+ *   unmark
+ */
+static const struct sieve_command_def cmd_unmark = {
+    "unmark",
+    SCT_COMMAND,
+    0, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_mark_validate,
+    NULL, NULL,
+};
+
+/*
+ * Extension
+ */
+
+static bool ext_imapflags_load
+	(const struct sieve_extension *ext, void **context);
+static bool ext_imapflags_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+static bool ext_imapflags_interpreter_load
+	(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+		sieve_size_t *address);
+
+const struct sieve_extension_def imapflags_extension = {
+	"imapflags",
+	ext_imapflags_load,
+	NULL,
+	ext_imapflags_validator_load,
+	NULL,
+	ext_imapflags_interpreter_load,
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_imapflags_load
+(const struct sieve_extension *ext, void **context)
+{
+	/* Make sure real extension is registered, it is needed by the binary */
+	*context = (void *)
+		sieve_extension_require(ext->svinst, &imap4flags_extension);
+
+	return TRUE;
+}
+
+/*
+ * Validator
+ */
+
+static bool ext_imapflags_validator_extension_validate
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr,
+		void *context, struct sieve_ast_argument *require_arg);
+
+const struct sieve_validator_extension imapflags_validator_extension = {
+	&imapflags_extension,
+	ext_imapflags_validator_extension_validate,
+	NULL
+};
+
+static bool ext_imapflags_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	const struct sieve_extension *master_ext =
+		(const struct sieve_extension *) ext->context;
+
+	sieve_validator_extension_register
+		(valdtr, ext, &imapflags_validator_extension, NULL);
+
+	/* Register commands */
+	sieve_validator_register_command(valdtr, master_ext, &cmd_setflag);
+	sieve_validator_register_command(valdtr, master_ext, &cmd_addflag);
+	sieve_validator_register_command(valdtr, master_ext, &cmd_removeflag);
+
+	sieve_validator_register_command(valdtr, master_ext, &cmd_mark);
+	sieve_validator_register_command(valdtr, master_ext, &cmd_unmark);
+
+	return TRUE;
+}
+
+static bool ext_imapflags_validator_extension_validate
+(const struct sieve_extension *ext, struct sieve_validator *valdtr,
+	void *context ATTR_UNUSED, struct sieve_ast_argument *require_arg)
+{
+	const struct sieve_extension *master_ext =
+		(const struct sieve_extension *) ext->context;
+
+	if ( sieve_validator_extension_loaded(valdtr, master_ext) ) {
+		sieve_argument_validate_error(valdtr, require_arg,
+			"the (deprecated) imapflags extension cannot be used "
+			"together with the imap4flags extension");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Interpreter
+ */
+
+static bool ext_imapflags_interpreter_load
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	const struct sieve_extension *master_ext =
+		(const struct sieve_extension *) ext->context;
+
+	sieve_interpreter_extension_register
+		(renv->interp, master_ext, &imap4flags_interpreter_extension, NULL);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_mark_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	if ( sieve_command_is(cmd, cmd_mark) )
+		cmd->def = &cmd_addflag;
+	else
+		cmd->def = &cmd_removeflag;
+
+	cmd->first_positional = sieve_ast_argument_cstring_create
+		(cmd->ast_node, "\\flagged", cmd->ast_node->source_line);
+
+	if ( !sieve_validator_argument_activate
+		(valdtr, cmd, cmd->first_positional, FALSE) )
+		return FALSE;
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/plugins/imap4flags/tag-flags.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/tag-flags.c
@@ -0,0 +1,426 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "array.h"
+#include "mail-storage.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-result.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-actions.h"
+#include "sieve-dump.h"
+
+#include "ext-imap4flags-common.h"
+
+#include <ctype.h>
+
+/*
+ * Flags tagged argument
+ */
+
+static bool tag_flags_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_flags_validate_persistent
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		const struct sieve_extension *ext);
+static bool tag_flags_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+const struct sieve_argument_def tag_flags = {
+	"flags",
+	NULL,
+	tag_flags_validate,
+	NULL, NULL,
+	tag_flags_generate
+};
+
+const struct sieve_argument_def tag_flags_implicit = {
+	"flags-implicit",
+	NULL,	NULL, NULL,
+	tag_flags_validate_persistent,
+	tag_flags_generate
+};
+
+/*
+ * Side effect
+ */
+
+static bool seff_flags_dump_context
+	(const struct sieve_side_effect *seffect,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static bool seff_flags_read_context
+	(const struct sieve_side_effect *seffect,
+		const struct sieve_runtime_env *renv, sieve_size_t *address,
+		void **context);
+
+static int seff_flags_merge
+	(const struct sieve_runtime_env *renv, const struct sieve_action *action,
+		const struct sieve_side_effect *old_seffect,
+		const struct sieve_side_effect *new_seffect, void **old_context);
+
+static void seff_flags_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+static bool seff_flags_pre_execute
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void **context, void *tr_context);
+
+const struct sieve_side_effect_def flags_side_effect = {
+	SIEVE_OBJECT("flags", &flags_side_effect_operand, 0),
+	&act_store,
+
+	seff_flags_dump_context,
+	seff_flags_read_context,
+	seff_flags_merge,
+	seff_flags_print,
+	seff_flags_pre_execute,
+	NULL, NULL, NULL
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(flags_side_effect);
+
+const struct sieve_operand_def flags_side_effect_operand = {
+	"flags operand",
+	&imap4flags_extension,
+	0,
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/*
+ * Tag validation
+ */
+
+static bool tag_flags_validate_persistent
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd,
+	const struct sieve_extension *ext)
+{
+	if ( sieve_command_find_argument(cmd, &tag_flags) == NULL ) {
+		sieve_command_add_dynamic_tag(cmd, ext, &tag_flags_implicit, -1);
+	}
+
+	return TRUE;
+}
+
+static bool tag_flags_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_argument_next(*arg);
+
+	/* Check syntax:
+	 *   :flags <list-of-flags: string-list>
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	tag->parameters = *arg;
+
+	/* Detach parameter */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool tag_flags_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *param;
+
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit
+		(cgenv->sbin, arg->argument->ext, &flags_side_effect);
+
+	if ( sieve_argument_is(arg, tag_flags) ) {
+		/* Explicit :flags tag */
+		param = arg->parameters;
+
+		/* Call the generation function for the argument */
+		if ( param->argument != NULL && param->argument->def != NULL &&
+			param->argument->def->generate != NULL &&
+			!param->argument->def->generate(cgenv, param, cmd) )
+			return FALSE;
+
+	} else if ( sieve_argument_is(arg, tag_flags_implicit) ) {
+		/* Implicit flags */
+		sieve_opr_omitted_emit(cgenv->sbin);
+
+	} else {
+		/* Something else?! */
+		i_unreached();
+	}
+
+	return TRUE;
+}
+
+/*
+ * Side effect implementation
+ */
+
+/* Context data */
+
+struct seff_flags_context {
+	ARRAY_DEFINE(keywords, const char *);
+	enum mail_flags flags;
+};
+
+/* Context coding */
+
+static bool seff_flags_dump_context
+(const struct sieve_side_effect *seffect ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+  struct sieve_operand operand;
+
+  if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	if ( sieve_operand_is_omitted(&operand) ) {
+		sieve_code_dumpf(denv, "flags: INTERNAL");
+		return TRUE;
+	}
+
+	return sieve_opr_stringlist_dump_data(denv, &operand, address, "flags");
+}
+
+static struct seff_flags_context *seff_flags_get_implicit_context
+(const struct sieve_extension *this_ext, struct sieve_result *result)
+{
+	pool_t pool = sieve_result_pool(result);
+	struct seff_flags_context *ctx;
+	const char *flag;
+	struct ext_imap4flags_iter flit;
+
+	ctx = p_new(pool, struct seff_flags_context, 1);
+	p_array_init(&ctx->keywords, pool, 2);
+
+	T_BEGIN {
+
+		/* Unpack */
+		ext_imap4flags_get_implicit_flags_init(&flit, this_ext, result);
+		while ( (flag=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+			if (flag != NULL && *flag != '\\') {
+				/* keyword */
+				const char *keyword = p_strdup(pool, flag);
+				array_append(&ctx->keywords, &keyword, 1);
+			} else {
+				/* system flag */
+				if (flag == NULL || strcasecmp(flag, "\\flagged") == 0)
+					ctx->flags |= MAIL_FLAGGED;
+				else if (strcasecmp(flag, "\\answered") == 0)
+					ctx->flags |= MAIL_ANSWERED;
+				else if (strcasecmp(flag, "\\deleted") == 0)
+					ctx->flags |= MAIL_DELETED;
+				else if (strcasecmp(flag, "\\seen") == 0)
+					ctx->flags |= MAIL_SEEN;
+				else if (strcasecmp(flag, "\\draft") == 0)
+					ctx->flags |= MAIL_DRAFT;
+			}
+		}
+
+	} T_END;
+
+	return ctx;
+}
+
+static bool _seff_flags_read_context
+(const struct sieve_side_effect *seffect,
+	const struct sieve_runtime_env *renv, sieve_size_t *address,
+	void **se_context)
+{
+	bool result = TRUE;
+	struct sieve_operand operand;
+	pool_t pool = sieve_result_pool(renv->result);
+	struct seff_flags_context *ctx;
+	string_t *flags_item;
+	struct sieve_coded_stringlist *flag_list;
+
+	ctx = p_new(pool, struct seff_flags_context, 1);
+	p_array_init(&ctx->keywords, pool, 2);
+
+	/* Check whether explicit flag list operand is present */
+	if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+		sieve_runtime_trace_error(renv, "invalid operand");
+		return FALSE;
+	}
+
+	if ( sieve_operand_is_omitted(&operand) ) {
+		/* Flag list is omitted, use current value of internal
+		 * variable to construct side effect context.
+		 */
+		*se_context = seff_flags_get_implicit_context
+			(SIEVE_OBJECT_EXTENSION(seffect), renv->result);
+		return TRUE;
+	}
+
+	/* Read flag-list */
+	if ( (flag_list=sieve_opr_stringlist_read_data
+		(renv, &operand, address)) == NULL ) {
+		return FALSE;
+	}
+
+	/* Unpack */
+	flags_item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(flag_list, &flags_item)) &&
+		flags_item != NULL ) {
+		const char *flag;
+		struct ext_imap4flags_iter flit;
+
+		ext_imap4flags_iter_init(&flit, flags_item);
+
+		while ( (flag=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+			if (flag != NULL && *flag != '\\') {
+				/* keyword */
+				const char *keyword = p_strdup(pool, flag);
+
+				/* FIXME: should check for duplicates (cannot trust variables) */
+				array_append(&ctx->keywords, &keyword, 1);
+
+			} else {
+				/* system flag */
+				if (flag == NULL || strcasecmp(flag, "\\flagged") == 0)
+					ctx->flags |= MAIL_FLAGGED;
+				else if (strcasecmp(flag, "\\answered") == 0)
+					ctx->flags |= MAIL_ANSWERED;
+				else if (strcasecmp(flag, "\\deleted") == 0)
+					ctx->flags |= MAIL_DELETED;
+				else if (strcasecmp(flag, "\\seen") == 0)
+					ctx->flags |= MAIL_SEEN;
+				else if (strcasecmp(flag, "\\draft") == 0)
+					ctx->flags |= MAIL_DRAFT;
+			}
+		}
+	}
+
+	*se_context = (void *) ctx;
+
+	return result;
+}
+
+static bool seff_flags_read_context
+(const struct sieve_side_effect *seffect,
+	const struct sieve_runtime_env *renv, sieve_size_t *address,
+	void **se_context)
+{
+	bool result;
+
+	T_BEGIN {
+		result = _seff_flags_read_context(seffect, renv, address, se_context);
+	} T_END;
+
+	return result;
+}
+
+
+/* Result verification */
+
+static int seff_flags_merge
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_side_effect *old_seffect ATTR_UNUSED,
+	const struct sieve_side_effect *new_seffect,
+	void **old_context)
+{
+	*old_context = new_seffect->context;
+
+	return 1;
+}
+
+/* Result printing */
+
+static void seff_flags_print
+(const struct sieve_side_effect *seffect,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_result_print_env *rpenv,bool *keep ATTR_UNUSED)
+{
+	struct sieve_result *result = rpenv->result;
+	struct seff_flags_context *ctx =
+		(struct seff_flags_context *) seffect->context;
+	unsigned int i;
+
+	if ( ctx == NULL )
+		ctx = seff_flags_get_implicit_context
+			(SIEVE_OBJECT_EXTENSION(seffect), result);
+
+	if ( ctx->flags != 0 || array_count(&ctx->keywords) > 0 ) {
+		T_BEGIN {
+			string_t *flags = t_str_new(128);
+
+			if ( (ctx->flags & MAIL_FLAGGED) > 0 )
+				str_printfa(flags, " \\flagged");
+
+			if ( (ctx->flags & MAIL_ANSWERED) > 0 )
+				str_printfa(flags, " \\answered");
+
+			if ( (ctx->flags & MAIL_DELETED) > 0 )
+				str_printfa(flags, " \\deleted");
+
+			if ( (ctx->flags & MAIL_SEEN) > 0 )
+				str_printfa(flags, " \\seen");
+
+			if ( (ctx->flags & MAIL_DRAFT) > 0 )
+				str_printfa(flags, " \\draft");
+
+			for ( i = 0; i < array_count(&ctx->keywords); i++ ) {
+				const char *const *keyword = array_idx(&ctx->keywords, i);
+				str_printfa(flags, " %s", str_sanitize(*keyword, 64));
+			}
+
+			sieve_result_seffect_printf(rpenv, "add IMAP flags:%s", str_c(flags));
+		} T_END;
+	}
+}
+
+/* Result execution */
+
+static bool seff_flags_pre_execute
+(const struct sieve_side_effect *seffect,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv, void **context, void *tr_context)
+{
+	struct seff_flags_context *ctx = (struct seff_flags_context *) *context;
+	const char *const *keywords;
+
+	if ( ctx == NULL ) {
+		ctx = seff_flags_get_implicit_context
+			(SIEVE_OBJECT_EXTENSION(seffect), aenv->result);
+		*context = (void *) ctx;
+	}
+
+	(void)array_append_space(&ctx->keywords);
+	keywords = array_idx(&ctx->keywords, 0);
+
+	sieve_act_store_add_flags(aenv, tr_context, keywords, ctx->flags);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c
@@ -0,0 +1,302 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Hasflag test
+ *
+ * Syntax:
+ *   hasflag [MATCH-TYPE] [COMPARATOR] [<variable-list: string-list>]
+ *       <list-of-flags: string-list>
+ */
+
+static bool tst_hasflag_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_hasflag_validate
+	(struct sieve_validator *valdtr,	struct sieve_command *tst);
+static bool tst_hasflag_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def tst_hasflag = {
+	"hasflag",
+	SCT_TEST,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE,
+	tst_hasflag_registered,
+	NULL,
+	tst_hasflag_validate,
+	tst_hasflag_generate,
+	NULL
+};
+
+/*
+ * Hasflag operation
+ */
+
+static bool tst_hasflag_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_hasflag_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def hasflag_operation = {
+	"HASFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_HASFLAG,
+	tst_hasflag_operation_dump,
+	tst_hasflag_operation_execute
+};
+
+/*
+ * Optional arguments
+ */
+
+enum tst_hasflag_optional {
+	OPT_VARIABLES = SIEVE_MATCH_OPT_LAST,
+};
+
+/*
+ * Tag registration
+ */
+
+static bool tst_hasflag_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool tst_hasflag_validate
+(struct sieve_validator *valdtr,	struct sieve_command *tst)
+{
+	struct sieve_ast_argument *vars = tst->first_positional;
+	struct sieve_ast_argument *keys = sieve_ast_argument_next(vars);
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+
+	if ( !ext_imap4flags_command_validate(valdtr, tst) )
+		return FALSE;
+
+	if ( keys == NULL ) {
+		keys = vars;
+		vars = NULL;
+	} else {
+		vars->argument->id_code = OPT_VARIABLES;
+	}
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, keys, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_hasflag_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &hasflag_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_hasflag_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "HASFLAG");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_VARIABLES:
+			sieve_opr_stringlist_dump(denv, address, "variables");
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "list of flags");
+}
+
+/*
+ * Interpretation
+ */
+
+static int _flag_key_extract_init
+(void **context, string_t *raw_key)
+{
+	struct ext_imap4flags_iter *iter = t_new(struct ext_imap4flags_iter, 1);
+
+	ext_imap4flags_iter_init(iter, raw_key);
+
+	*context = iter;
+
+	return TRUE;
+}
+
+static int _flag_key_extract
+(void *context, const char **key, size_t *size)
+{
+	struct ext_imap4flags_iter *iter = (struct ext_imap4flags_iter *) context;
+
+	if ( (*key = ext_imap4flags_iter_get_flag(iter)) != NULL ) {
+		*size = strlen(*key);
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static const struct sieve_match_key_extractor _flag_extractor = {
+	_flag_key_extract_init,
+	_flag_key_extract
+};
+
+static int tst_hasflag_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mtch =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *flag_list, *variables_list = NULL;
+	struct ext_imap4flags_iter iter;
+	const char *flag;
+	bool matched;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle match-type and comparator operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+
+		/* Check whether we neatly finished the list of optional operands*/
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_VARIABLES:
+			if ( (variables_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid variables-list operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	/* Read flag list */
+	if ( (flag_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid flag-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "HASFLAG test");
+
+	matched = FALSE;
+	mctx = sieve_match_begin
+		(renv->interp, &mtch, &cmp, &_flag_extractor, flag_list);
+
+	matched = FALSE;
+
+	if ( variables_list != NULL ) {
+		string_t *var_item = NULL;
+
+		/* Iterate through all requested variables to match */
+		while ( result && !matched &&
+			(result=sieve_coded_stringlist_next_item(variables_list, &var_item))
+			&& var_item != NULL ) {
+
+			ext_imap4flags_get_flags_init(&iter, renv, var_item);
+			while ( !matched && (flag=ext_imap4flags_iter_get_flag(&iter)) != NULL ) {
+				if ( (mret=sieve_match_value(mctx, flag, strlen(flag))) < 0 ) {
+					result = FALSE;
+					break;
+				}
+
+				matched = ( mret > 0 );
+			}
+		}
+	} else {
+		ext_imap4flags_get_flags_init(&iter, renv, NULL);
+		while ( !matched && (flag=ext_imap4flags_iter_get_flag(&iter)) != NULL ) {
+			if ( (mret=sieve_match_value(mctx, flag, strlen(flag))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+
+			matched = ( mret > 0 );
+		}
+	}
+
+	if ( (mret=sieve_match_end(&mctx)) < 0 ) {
+		result = FALSE;
+	} else
+		matched = ( mret > 0 || matched );
+
+	/* Assign test result */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/include/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/Makefile.am
@@ -0,0 +1,27 @@
+noinst_LTLIBRARIES = libsieve_ext_include.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-include.c \
+	cmd-return.c \
+	cmd-global.c
+
+libsieve_ext_include_la_SOURCES = \
+	$(cmds) \
+	ext-include-common.c \
+	ext-include-binary.c \
+	ext-include-variables.c \
+	ext-include.c
+
+noinst_HEADERS = \
+	ext-include-common.h \
+	ext-include-limits.h \
+	ext-include-binary.h \
+	ext-include-variables.h
Index: b/sieve/src/lib-sieve/plugins/include/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/Makefile.in
@@ -0,0 +1,510 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/include
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_include_la_LIBADD =
+am__objects_1 = cmd-include.lo cmd-return.lo cmd-global.lo
+am_libsieve_ext_include_la_OBJECTS = $(am__objects_1) \
+	ext-include-common.lo ext-include-binary.lo \
+	ext-include-variables.lo ext-include.lo
+libsieve_ext_include_la_OBJECTS =  \
+	$(am_libsieve_ext_include_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_include_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_include_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_include.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-include.c \
+	cmd-return.c \
+	cmd-global.c
+
+libsieve_ext_include_la_SOURCES = \
+	$(cmds) \
+	ext-include-common.c \
+	ext-include-binary.c \
+	ext-include-variables.c \
+	ext-include.c
+
+noinst_HEADERS = \
+	ext-include-common.h \
+	ext-include-limits.h \
+	ext-include-binary.h \
+	ext-include-variables.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/include/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/include/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_include.la: $(libsieve_ext_include_la_OBJECTS) $(libsieve_ext_include_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_include_la_OBJECTS) $(libsieve_ext_include_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-global.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-include.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-return.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include-binary.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include-variables.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-include.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/include/cmd-global.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/cmd-global.c
@@ -0,0 +1,324 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+/*
+ * Commands
+ */
+
+static bool cmd_global_validate
+  (struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_global_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_global = {
+    "global",
+    SCT_COMMAND,
+    1, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_global_validate,
+    cmd_global_generate,
+    NULL
+};
+
+/* DEPRICATED:
+ */
+
+/* Import command
+ *
+ * Syntax
+ *   import
+ */
+const struct sieve_command_def cmd_import = {
+	"import",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_global_validate,
+	cmd_global_generate,
+	NULL
+};
+
+/* Export command
+ *
+ * Syntax
+ *   export
+ */
+const struct sieve_command_def cmd_export = {
+	"export",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_global_validate,
+	cmd_global_generate,
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+static bool opc_global_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int opc_global_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Global operation */
+
+const struct sieve_operation_def global_operation = {
+	"global",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_GLOBAL,
+	opc_global_dump,
+	opc_global_execute
+};
+
+/*
+ * Validation
+ */
+
+static inline struct sieve_argument *_create_variable_argument
+(struct sieve_command *cmd, struct sieve_variable *var)
+{
+	struct sieve_argument *argument = sieve_argument_create
+		(cmd->ast_node->ast, NULL, cmd->ext, 0);
+
+	argument->data = (void *) var;
+
+	return argument;
+}
+
+static bool cmd_global_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct sieve_command *prev = sieve_command_prev(cmd);
+
+	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) ||
+		( !sieve_command_is_first(cmd) && prev != NULL &&
+			!sieve_command_is(prev, cmd_require) ) ) {
+
+		if ( sieve_command_is(cmd, cmd_global) ) {
+			if ( !sieve_command_is(prev, cmd_global) ) {
+				sieve_command_validate_error(valdtr, cmd,
+					"a global command can only be placed at top level "
+					"at the beginning of the file after any require or "
+					"other global commands");
+				return FALSE;
+			}
+		} else {
+			if ( !sieve_command_is(prev, cmd_import) &&
+				!sieve_command_is(prev, cmd_export) ) {
+				sieve_command_validate_error(valdtr, cmd,
+					"the DEPRICATED %s command can only be placed at top level "
+					"at the beginning of the file after any require or "
+					"import/export commands",
+					sieve_command_identifier(cmd));
+				return FALSE;
+				}
+		}
+	}
+
+	/* Check for use of variables extension */
+	if ( !ext_include_validator_have_variables(this_ext, valdtr) ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"%s command requires that variables extension is active",
+			sieve_command_identifier(cmd));
+		return FALSE;
+	}
+
+	/* Register global variable */
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		const char *identifier = sieve_ast_argument_strc(arg);
+		struct sieve_variable *var;
+
+		if ( (var=ext_include_variable_import_global
+			(valdtr, cmd, identifier)) == NULL )
+			return FALSE;
+
+		arg->argument = _create_variable_argument(cmd, var);
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+
+		while ( stritem != NULL ) {
+			const char *identifier = sieve_ast_argument_strc(stritem);
+			struct sieve_variable *var;
+
+			if ( (var=ext_include_variable_import_global
+				(valdtr, cmd, identifier)) == NULL )
+				return FALSE;
+
+			stritem->argument = _create_variable_argument(cmd, var);
+
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		/* Something else */
+		sieve_argument_validate_error(valdtr, arg,
+			"the %s command accepts a single string or string list argument, "
+			"but %s was found", sieve_command_identifier(cmd),
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+
+	/* Join global commands with predecessors if possible */
+	if ( sieve_commands_equal(prev, cmd) ) {
+		/* Join this command's string list with the previous one */
+		prev->first_positional = sieve_ast_stringlist_join
+			(prev->first_positional, cmd->first_positional);
+
+		if ( prev->first_positional == NULL ) {
+			/* Not going to happen unless MAXINT stringlist items are specified */
+			sieve_command_validate_error(valdtr, cmd,
+				"compiler reached AST limit (script too complex)");
+			return FALSE;
+		}
+
+		/* Detach this command node */
+		sieve_ast_node_detach(cmd->ast_node);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_global_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &global_operation);
+
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		struct sieve_variable *var = (struct sieve_variable *) arg->argument->data;
+
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, 1);
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, var->index);
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, sieve_ast_strlist_count(arg));
+
+		while ( stritem != NULL ) {
+			struct sieve_variable *var =
+				(struct sieve_variable *) stritem->argument->data;
+
+			(void)sieve_binary_emit_unsigned(cgenv->sbin, var->index);
+
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		i_unreached();
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool opc_global_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_extension *this_ext = denv->oprtn.ext;
+	unsigned int count, i, var_count;
+	struct sieve_variable_scope *scope;
+	struct sieve_variable * const *vars;
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &count) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "GLOBAL (count: %u):", count);
+
+	scope = ext_include_binary_get_global_scope(this_ext, denv->sbin);
+	vars = sieve_variable_scope_get_variables(scope, &var_count);
+
+	sieve_code_descend(denv);
+
+	for ( i = 0; i < count; i++ ) {
+		unsigned int index;
+
+		sieve_code_mark(denv);
+		if ( !sieve_binary_read_unsigned(denv->sbin, address, &index) ||
+			index >= var_count )
+			return FALSE;
+
+		sieve_code_dumpf(denv, "VAR[%d]: '%s'", index, vars[index]->identifier);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Execution
+ */
+
+static int opc_global_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct sieve_variable_scope *scope;
+	struct sieve_variable_storage *storage;
+	struct sieve_variable * const *vars;
+	unsigned int var_count, count, i;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &count) ) {
+		sieve_runtime_trace_error(renv, "invalid count operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	scope = ext_include_binary_get_global_scope(this_ext, renv->sbin);
+	vars = sieve_variable_scope_get_variables(scope, &var_count);
+	storage = ext_include_interpreter_get_global_variables
+		(renv->oprtn.ext, renv->interp);
+
+	for ( i = 0; i < count; i++ ) {
+		unsigned int index;
+
+		if ( !sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+			sieve_runtime_trace_error(renv, "invalid global variable operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		if ( index >= var_count ) {
+			sieve_runtime_trace_error(renv, "invalid global variable index (%u > %u)",
+				index, var_count);
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		/* Make sure variable is initialized (export) */
+		(void)sieve_variable_get_modifiable(storage, index, NULL);
+	}
+
+	return SIEVE_EXEC_OK;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/include/cmd-include.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/cmd-include.c
@@ -0,0 +1,355 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+
+/*
+ * Include command
+ *
+ * Syntax:
+ *   include [LOCATION] <value: string>
+ *
+ * [LOCATION]:
+ *   ":personal" / ":global"
+ */
+
+static bool cmd_include_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_include_pre_validate
+	(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd);
+static bool cmd_include_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_include_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_include = {
+	"include",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	cmd_include_registered,
+	cmd_include_pre_validate,
+	cmd_include_validate,
+	cmd_include_generate,
+	NULL
+};
+
+/*
+ * Include operation
+ */
+
+static bool opc_include_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int opc_include_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def include_operation = {
+	"include",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_INCLUDE,
+	opc_include_dump,
+	opc_include_execute
+};
+
+/*
+ * Context structures
+ */
+
+struct cmd_include_context_data {
+	enum ext_include_script_location location;
+	bool location_assigned;
+
+	bool include_once;
+
+	struct sieve_script *script;
+};
+
+/*
+ * Tagged arguments
+ */
+
+static bool cmd_include_validate_location_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def include_personal_tag = {
+	"personal",
+	NULL,
+	cmd_include_validate_location_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def include_global_tag = {
+	"global",
+	NULL,
+	cmd_include_validate_location_tag,
+	NULL, NULL, NULL
+};
+
+static bool cmd_include_validate_once_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def include_once_tag = {
+	"once",
+	NULL,
+	cmd_include_validate_once_tag,
+	NULL, NULL, NULL
+};
+
+/*
+ * Tag validation
+ */
+
+static bool cmd_include_validate_location_tag
+(struct sieve_validator *valdtr,	struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_include_context_data *ctx_data =
+		(struct cmd_include_context_data *) cmd->data;
+
+	if ( ctx_data->location_assigned) {
+		sieve_argument_validate_error(valdtr, *arg,
+			"include: cannot use location tags ':personal' and ':global' "
+			"multiple times");
+		return FALSE;
+	}
+
+	if ( sieve_argument_is(*arg, include_personal_tag) )
+		ctx_data->location = EXT_INCLUDE_LOCATION_PERSONAL;
+	else if ( sieve_argument_is(*arg, include_global_tag) )
+		ctx_data->location = EXT_INCLUDE_LOCATION_GLOBAL;
+	else
+		return FALSE;
+
+	ctx_data->location_assigned = TRUE;
+
+	/* Delete this tag (for now) */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+static bool cmd_include_validate_once_tag
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_include_context_data *ctx_data =
+		(struct cmd_include_context_data *) cmd->data;
+
+	ctx_data->include_once = TRUE;
+
+	/* Delete this tag (for now) */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/*
+ * Command registration
+ */
+
+static bool cmd_include_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &include_personal_tag, 0);
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &include_global_tag, 0);
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &include_once_tag, 0);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_include_pre_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd)
+{
+	struct cmd_include_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), struct cmd_include_context_data, 1);
+	ctx_data->location = EXT_INCLUDE_LOCATION_PERSONAL;
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static bool cmd_include_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_include_context_data *ctx_data =
+		(struct cmd_include_context_data *) cmd->data;
+	struct sieve_script *script;
+	const char *script_path, *script_name;
+	bool exists = TRUE;
+
+	/* Check argument */
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "value", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, arg, FALSE) )
+		return FALSE;
+
+	/*
+	 * Variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(arg) ) {
+		sieve_argument_validate_error(valdtr, arg,
+			"the include command requires a constant string for its value argument");
+		return FALSE;
+	}
+
+	/* Find the script */
+
+	script_name = sieve_ast_argument_strc(arg);
+
+	if ( strchr(script_name, '/') != NULL ) {
+ 		sieve_argument_validate_error(valdtr, arg,
+			"include: '/' not allowed in script name (%s)",
+			str_sanitize(script_name, 80));
+		return FALSE;
+	}
+
+	script_path = ext_include_get_script_directory
+		(this_ext, ctx_data->location, script_name);
+	if ( script_path == NULL ) {
+		sieve_argument_validate_error(valdtr, arg,
+			"include: %s location for included script '%s' is unavailable "
+			"(contact system administrator for more information)",
+			ext_include_script_location_name(ctx_data->location),
+			str_sanitize(script_name, 80));
+		return FALSE;
+	}
+
+	/* Create script object */
+	script = sieve_script_create_in_directory
+		(this_ext->svinst, script_path, script_name,
+			sieve_validator_error_handler(valdtr), &exists);
+
+	if ( script == NULL ) {
+		if ( !exists ) {
+			sieve_argument_validate_error(valdtr, arg,
+				"included %s script '%s' does not exist",
+				ext_include_script_location_name(ctx_data->location),
+				str_sanitize(script_name, 80));
+		}
+		return FALSE;
+	}
+
+	ext_include_ast_link_included_script(cmd->ext, cmd->ast_node->ast, script);
+	ctx_data->script = script;
+
+	arg = sieve_ast_arguments_detach(arg, 1);
+
+	return TRUE;
+}
+
+/*
+ * Code Generation
+ */
+
+static bool cmd_include_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct cmd_include_context_data *ctx_data =
+		(struct cmd_include_context_data *) cmd->data;
+	const struct ext_include_script_info *included;
+	unsigned int flags = ctx_data->include_once;
+
+	/* Compile (if necessary) and include the script into the binary.
+	 * This yields the id of the binary block containing the compiled byte code.
+	 */
+	if ( !ext_include_generate_include
+		(cgenv, cmd, ctx_data->location, ctx_data->script, &included,
+			ctx_data->include_once) )
+ 		return FALSE;
+
+ 	(void)sieve_operation_emit(cgenv->sbin, cmd->ext, &include_operation);
+	(void)sieve_binary_emit_unsigned(cgenv->sbin, included->id);
+	(void)sieve_binary_emit_byte(cgenv->sbin, flags);
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool opc_include_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct ext_include_script_info *included;
+	struct ext_include_binary_context *binctx;
+	unsigned int include_id, flags;
+
+	sieve_code_dumpf(denv, "INCLUDE:");
+
+	sieve_code_mark(denv);
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &include_id) )
+		return FALSE;
+
+	if ( !sieve_binary_read_byte(denv->sbin, address, &flags) )
+		return FALSE;
+
+	binctx = ext_include_binary_get_context(denv->oprtn.ext, denv->sbin);
+	included = ext_include_binary_script_get_included(binctx, include_id);
+	if ( included == NULL )
+		return FALSE;
+
+	sieve_code_descend(denv);
+	sieve_code_dumpf(denv, "script: %s %s[ID: %d, BLOCK: %d]",
+		sieve_script_filename(included->script), (flags & 0x01 ? "(once) " : ""),
+		include_id, included->block_id);
+
+	return TRUE;
+}
+
+/*
+ * Execution
+ */
+
+static int opc_include_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	unsigned int include_id, flags;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &include_id) ) {
+		sieve_runtime_trace_error(renv, "invalid include-id operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &flags) ) {
+		sieve_runtime_trace_error(renv, "invalid flags operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	return ext_include_execute_include(renv, include_id, flags & 0x01);
+}
+
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/include/cmd-return.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/cmd-return.c
@@ -0,0 +1,73 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-include-common.h"
+
+/*
+ * Return command
+ *
+ * Syntax
+ *   return
+ */
+
+static bool cmd_return_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_return = {
+	"return",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_return_generate,
+	NULL
+};
+
+/*
+ * Return operation
+ */
+
+static int opc_return_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def return_operation = {
+	"return",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_RETURN,
+	NULL,
+	opc_return_execute
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_return_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &return_operation);
+
+	return TRUE;
+}
+
+/*
+ * Execution
+ */
+
+static int opc_return_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_runtime_trace(renv, "RETURN command");
+
+	ext_include_execute_return(renv);
+	return SIEVE_EXEC_OK;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-binary.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-binary.c
@@ -0,0 +1,432 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-limits.h"
+#include "ext-include-variables.h"
+#include "ext-include-binary.h"
+
+/*
+ * Forward declarations
+ */
+
+static bool ext_include_binary_save
+	(const struct sieve_extension *ext, struct sieve_binary *sbin, void *context);
+static bool ext_include_binary_open
+	(const struct sieve_extension *ext, struct sieve_binary *sbin, void *context);
+static bool ext_include_binary_up_to_date
+	(const struct sieve_extension *ext, struct sieve_binary *sbin, void *context);
+static void ext_include_binary_free
+	(const struct sieve_extension *ext, struct sieve_binary *sbin, void *context);
+
+/*
+ * Binary include extension
+ */
+
+const struct sieve_binary_extension include_binary_ext = {
+	&include_extension,
+	ext_include_binary_save,
+	ext_include_binary_open,
+	ext_include_binary_free,
+	ext_include_binary_up_to_date
+};
+
+/*
+ * Binary context management
+ */
+
+struct ext_include_binary_context {
+	struct sieve_binary *binary;
+	unsigned int dependency_block;
+
+	struct hash_table *included_scripts;
+	ARRAY_DEFINE(include_index, struct ext_include_script_info *);
+
+	struct sieve_variable_scope *global_vars;
+};
+
+
+static struct ext_include_binary_context *ext_include_binary_create_context
+(const struct sieve_extension *this_ext, struct sieve_binary *sbin)
+{
+	pool_t pool = sieve_binary_pool(sbin);
+
+	struct ext_include_binary_context *ctx =
+		p_new(pool, struct ext_include_binary_context, 1);
+
+	ctx->binary = sbin;
+	ctx->included_scripts = hash_table_create(default_pool, pool, 0,
+		(hash_callback_t *) sieve_script_hash,
+		(hash_cmp_callback_t *) sieve_script_cmp);
+	p_array_init(&ctx->include_index, pool, 128);
+
+	sieve_binary_extension_set(sbin, this_ext, &include_binary_ext, ctx);
+
+	return ctx;
+}
+
+struct ext_include_binary_context *ext_include_binary_get_context
+(const struct sieve_extension *this_ext, struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *ctx = (struct ext_include_binary_context *)
+		sieve_binary_extension_get_context(sbin, this_ext);
+
+	if ( ctx == NULL )
+		ctx = ext_include_binary_create_context(this_ext, sbin);
+
+	return ctx;
+}
+
+struct ext_include_binary_context *ext_include_binary_init
+(const struct sieve_extension *this_ext, struct sieve_binary *sbin,
+	struct sieve_ast *ast)
+{
+	struct ext_include_ast_context *ast_ctx =
+		ext_include_get_ast_context(this_ext, ast);
+	struct ext_include_binary_context *ctx;
+
+	/* Get/create our context from the binary we are working on */
+	ctx = ext_include_binary_get_context(this_ext, sbin);
+
+	/* Create dependency block */
+	if ( ctx->dependency_block == 0 )
+		ctx->dependency_block =
+			sieve_binary_extension_create_block(sbin, this_ext);
+
+	if ( ctx->global_vars == NULL ) {
+		ctx->global_vars = ast_ctx->global_vars;
+		sieve_variable_scope_ref(ctx->global_vars);
+	}
+
+	return ctx;
+}
+
+/*
+ * Script inclusion
+ */
+
+const struct ext_include_script_info *ext_include_binary_script_include
+(struct ext_include_binary_context *binctx, struct sieve_script *script,
+	enum ext_include_script_location location, unsigned int block_id)
+{
+	pool_t pool = sieve_binary_pool(binctx->binary);
+	struct ext_include_script_info *incscript;
+
+	incscript = p_new(pool, struct ext_include_script_info, 1);
+	incscript->id = array_count(&binctx->include_index)+1;
+	incscript->script = script;
+	incscript->location = location;
+	incscript->block_id = block_id;
+
+	/* Unreferenced on binary_free */
+	sieve_script_ref(script);
+
+	hash_table_insert
+		(binctx->included_scripts, (void *) script, (void *) incscript);
+	array_append(&binctx->include_index, &incscript, 1);
+
+	return incscript;
+}
+
+bool ext_include_binary_script_is_included
+(struct ext_include_binary_context *binctx, struct sieve_script *script,
+	const struct ext_include_script_info **script_info_r)
+{
+	struct ext_include_script_info *incscript = (struct ext_include_script_info *)
+		hash_table_lookup(binctx->included_scripts, script);
+
+	if ( incscript == NULL )
+		return FALSE;
+
+	*script_info_r = incscript;
+	return TRUE;
+}
+
+const struct ext_include_script_info *ext_include_binary_script_get_included
+(struct ext_include_binary_context *binctx, unsigned int include_id)
+{
+	if ( include_id > 0 &&
+		(include_id - 1) < array_count(&binctx->include_index) ) {
+		struct ext_include_script_info *const *sinfo =
+			array_idx(&binctx->include_index, include_id - 1);
+
+		return *sinfo;
+	}
+
+	return NULL;
+}
+
+const struct ext_include_script_info *ext_include_binary_script_get
+(struct ext_include_binary_context *binctx, struct sieve_script *script)
+{
+	return (struct ext_include_script_info *)
+		hash_table_lookup(binctx->included_scripts, script);
+}
+
+unsigned int ext_include_binary_script_get_count
+(struct ext_include_binary_context *binctx)
+{
+	return array_count(&binctx->include_index);
+}
+
+/*
+ * Variables
+ */
+
+struct sieve_variable_scope *ext_include_binary_get_global_scope
+(const struct sieve_extension *this_ext, struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx =
+		ext_include_binary_get_context(this_ext, sbin);
+
+	return binctx->global_vars;
+}
+
+/*
+ * Binary extension
+ */
+
+static bool ext_include_binary_save
+(const struct sieve_extension *ext ATTR_UNUSED, struct sieve_binary *sbin,
+	void *context)
+{
+	struct ext_include_binary_context *binctx =
+		(struct ext_include_binary_context *) context;
+	struct ext_include_script_info *const *scripts;
+	unsigned int script_count, i;
+	unsigned int prvblk;
+	bool result = TRUE;
+
+	sieve_binary_block_clear(sbin, binctx->dependency_block);
+	if ( !sieve_binary_block_set_active(sbin, binctx->dependency_block, &prvblk) )
+		return FALSE;
+
+	scripts = array_get(&binctx->include_index, &script_count);
+
+	sieve_binary_emit_unsigned(sbin, script_count);
+
+	for ( i = 0; i < script_count; i++ ) {
+		struct ext_include_script_info *incscript = scripts[i];
+
+		sieve_binary_emit_unsigned(sbin, incscript->block_id);
+		sieve_binary_emit_byte(sbin, incscript->location);
+		sieve_binary_emit_cstring(sbin, sieve_script_name(incscript->script));
+	}
+
+	result = ext_include_variables_save(sbin, binctx->global_vars);
+
+	(void) sieve_binary_block_set_active(sbin, prvblk, NULL);
+
+	return result;
+}
+
+static bool ext_include_binary_open
+(const struct sieve_extension *ext, struct sieve_binary *sbin, void *context)
+{
+	struct ext_include_binary_context *binctx =
+		(struct ext_include_binary_context *) context;
+	unsigned int block, prvblk, depcount, i;
+	sieve_size_t offset;
+
+	block = sieve_binary_extension_get_block(sbin, ext);
+
+	if ( !sieve_binary_block_set_active(sbin, block, &prvblk) )
+		return FALSE;
+
+	offset = 0;
+
+	if ( !sieve_binary_read_unsigned(sbin, &offset, &depcount) ) {
+		sieve_sys_error("include: failed to read include count "
+			"for dependency block %d of binary %s", block, sieve_binary_path(sbin));
+		return FALSE;
+	}
+
+	/* Check include limit */
+	if ( depcount > EXT_INCLUDE_MAX_INCLUDES ) {
+		sieve_sys_error("include: binary %s includes too many scripts (%u > %u)",
+			sieve_binary_path(sbin), depcount, EXT_INCLUDE_MAX_INCLUDES);
+		return FALSE;
+	}
+
+	/* Read dependencies */
+	for ( i = 0; i < depcount; i++ ) {
+		unsigned int block_id;
+		enum ext_include_script_location location;
+		string_t *script_name;
+		const char *script_dir;
+		struct sieve_script *script;
+
+		if (
+			!sieve_binary_read_unsigned(sbin, &offset, &block_id) ||
+			!sieve_binary_read_byte(sbin, &offset, &location) ||
+			!sieve_binary_read_string(sbin, &offset, &script_name) ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: failed to read included script "
+				"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+			return FALSE;
+		}
+
+		if ( location >= EXT_INCLUDE_LOCATION_INVALID ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: dependency block %d of binary %s "
+				"reports invalid script location (id %d)",
+				block, sieve_binary_path(sbin), location);
+			return FALSE;
+		}
+
+		/* Can we find/open the script dependency ? */
+		script_dir = ext_include_get_script_directory
+			(ext, location, str_c(script_name));
+		if ( script_dir == NULL ||
+			!(script=sieve_script_create_in_directory
+				(ext->svinst, script_dir, str_c(script_name), NULL, NULL)) ) {
+			/* No, recompile */
+			return FALSE;
+		}
+
+		(void)ext_include_binary_script_include(binctx, script, location, block_id);
+
+		sieve_script_unref(&script);
+	}
+
+	if ( !ext_include_variables_load
+		(ext, sbin, &offset, block, &binctx->global_vars) )
+		return FALSE;
+
+	/* Restore previously active block */
+	(void)sieve_binary_block_set_active(sbin, prvblk, NULL);
+
+	return TRUE;
+}
+
+static bool ext_include_binary_up_to_date
+(const struct sieve_extension *ext ATTR_UNUSED, struct sieve_binary *sbin,
+	void *context)
+{
+	struct ext_include_binary_context *binctx =
+		(struct ext_include_binary_context *) context;
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+
+	/* Check all included scripts for changes */
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript =
+			(struct ext_include_script_info *) value;
+
+		/* Is the binary old than this dependency? */
+		if ( sieve_binary_script_newer(sbin, incscript->script) ) {
+			/* No, recompile */
+			return FALSE;
+		}
+	}
+	hash_table_iterate_deinit(&hctx);
+
+	return TRUE;
+}
+
+static void ext_include_binary_free
+(const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_binary *sbin ATTR_UNUSED, void *context)
+{
+	struct ext_include_binary_context *binctx =
+		(struct ext_include_binary_context *) context;
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+
+	/* Release references to all included script objects */
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript =
+			(struct ext_include_script_info *) value;
+
+		sieve_script_unref(&incscript->script);
+	}
+	hash_table_iterate_deinit(&hctx);
+
+	hash_table_destroy(&binctx->included_scripts);
+
+	if ( binctx->global_vars != NULL )
+		sieve_variable_scope_unref(&binctx->global_vars);
+}
+
+/*
+ * Dumping the binary
+ */
+
+bool ext_include_binary_dump
+(const struct sieve_extension *ext, struct sieve_dumptime_env *denv)
+{
+	struct sieve_binary *sbin = denv->sbin;
+	struct ext_include_binary_context *binctx =
+		ext_include_binary_get_context(ext, sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+	unsigned int prvblk = 0;
+
+	if ( !ext_include_variables_dump(denv, binctx->global_vars) )
+		return FALSE;
+
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript =
+			(struct ext_include_script_info *) value;
+
+		sieve_binary_dump_sectionf(denv, "Included %s script '%s' (block: %d)",
+			ext_include_script_location_name(incscript->location),
+			sieve_script_name(incscript->script), incscript->block_id);
+
+		if ( prvblk == 0 ) {
+			if ( !sieve_binary_block_set_active(sbin, incscript->block_id, &prvblk) )
+				return FALSE;
+		} else {
+			if ( !sieve_binary_block_set_active(sbin, incscript->block_id, NULL) )
+				return FALSE;
+		}
+
+		denv->cdumper = sieve_code_dumper_create(denv);
+
+		if ( denv->cdumper == NULL )
+			return FALSE;
+
+		sieve_code_dumper_run(denv->cdumper);
+		sieve_code_dumper_free(&(denv->cdumper));
+	}
+
+	if ( !sieve_binary_block_set_active(sbin, prvblk, NULL) )
+		return FALSE;
+
+	hash_table_iterate_deinit(&hctx);
+
+	return TRUE;
+}
+
+bool ext_include_code_dump
+(const struct sieve_extension *ext, const struct sieve_dumptime_env *denv,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	struct sieve_binary *sbin = denv->sbin;
+	struct ext_include_binary_context *binctx =
+		ext_include_binary_get_context(ext, sbin);
+	struct ext_include_context *ectx = ext_include_get_context(ext);
+
+	sieve_ext_variables_dump_set_scope
+		(ectx->var_ext, denv, ext, binctx->global_vars);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-binary.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-binary.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_BINARY_H
+#define __EXT_INCLUDE_BINARY_H
+
+#include "sieve-common.h"
+
+/*
+ * Binary context management
+ */
+
+struct ext_include_binary_context;
+
+struct ext_include_binary_context *ext_include_binary_init
+	(const struct sieve_extension *this_ext, struct sieve_binary *sbin,
+		struct sieve_ast *ast);
+struct ext_include_binary_context *ext_include_binary_get_context
+	(const struct sieve_extension *this_ext, struct sieve_binary *sbin);
+
+/*
+ * Variables
+ */
+
+struct sieve_variable_scope *ext_include_binary_get_global_scope
+	(const struct sieve_extension *this_ext, struct sieve_binary *sbin);
+
+/*
+ * Including scripts
+ */
+
+struct ext_include_script_info {
+    unsigned int id;
+
+    struct sieve_script *script;
+    enum ext_include_script_location location;
+
+    unsigned int block_id;
+};
+
+const struct ext_include_script_info *ext_include_binary_script_include
+	(struct ext_include_binary_context *binctx, struct sieve_script *script,
+		enum ext_include_script_location location, unsigned int block_id);
+bool ext_include_binary_script_is_included
+	(struct ext_include_binary_context *binctx, struct sieve_script *script,
+		const struct ext_include_script_info **script_info_r);
+
+const struct ext_include_script_info *ext_include_binary_script_get_included
+	(struct ext_include_binary_context *binctx, unsigned int include_id);
+const struct ext_include_script_info *ext_include_binary_script_get
+	(struct ext_include_binary_context *binctx, struct sieve_script *script);
+unsigned int ext_include_binary_script_get_count
+	(struct ext_include_binary_context *binctx);
+
+/*
+ * Dumping the binary
+ */
+
+bool ext_include_binary_dump
+	(const struct sieve_extension *ext, struct sieve_dumptime_env *denv);
+bool ext_include_code_dump
+	(const struct sieve_extension *ext, const struct sieve_dumptime_env *denv,
+		sieve_size_t *address ATTR_UNUSED);
+
+#endif /* __EXT_INCLUDE_BINARY_H */
+
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-common.c
@@ -0,0 +1,737 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "str-sanitize.h"
+#include "home-expand.h"
+
+#include "sieve-common.h"
+#include "sieve-settings.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-include-common.h"
+#include "ext-include-limits.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+#include <stdlib.h>
+
+/*
+ * Forward declarations
+ */
+
+/* Generator context */
+
+struct ext_include_generator_context {
+	unsigned int nesting_level;
+	struct sieve_script *script;
+	struct ext_include_generator_context *parent;
+};
+
+static inline struct ext_include_generator_context *
+	ext_include_get_generator_context
+	(const struct sieve_extension *ext_this, struct sieve_generator *gentr);
+
+/* Interpreter context */
+
+struct ext_include_interpreter_global {
+	ARRAY_DEFINE(included_scripts, struct sieve_script *);
+
+	struct sieve_variable_storage *variables;
+};
+
+struct ext_include_interpreter_context {
+	struct ext_include_interpreter_context *parent;
+	struct ext_include_interpreter_global *global;
+
+	struct sieve_interpreter *interp;
+	pool_t pool;
+
+	unsigned int nesting_level;
+
+	struct sieve_script *script;
+	const struct ext_include_script_info *script_info;
+
+	const struct ext_include_script_info *include;
+	bool returned;
+};
+
+/*
+ * Script access
+ */
+
+const char *ext_include_get_script_directory
+(const struct sieve_extension *ext, enum ext_include_script_location location,
+	const char *script_name)
+{
+	struct sieve_instance *svinst = ext->svinst;
+	const char *home = NULL, *sieve_dir = NULL;
+
+	switch ( location ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		sieve_dir = sieve_get_setting(svinst, "sieve_dir");
+
+		home = sieve_get_homedir(svinst);
+
+		if ( sieve_dir == NULL ) {
+			if ( home == NULL )	{
+				sieve_sys_error(
+					"include: sieve_dir and home not set for :personal script include "
+					"(wanted script '%s')", str_sanitize(script_name, 80));
+				return NULL;
+			}
+
+			sieve_dir = "~/sieve";
+		}
+
+		if ( home != NULL )
+			sieve_dir = home_expand_tilde(sieve_dir, home);
+
+		break;
+	case EXT_INCLUDE_LOCATION_GLOBAL:
+		sieve_dir = sieve_get_setting(svinst, "sieve_global_dir");
+
+		if (sieve_dir == NULL) {
+			sieve_sys_error(
+				"include: sieve_global_dir not set for :global script include "
+				"(wanted script '%s')", str_sanitize(script_name, 80));
+			return NULL;
+		}
+
+		break;
+	default:
+		break;
+	}
+
+	return sieve_dir;
+}
+
+/*
+ * AST context management
+ */
+
+static void ext_include_ast_free
+(const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_ast *ast ATTR_UNUSED, void *context)
+{
+	struct ext_include_ast_context *actx =
+		(struct ext_include_ast_context *) context;
+	struct sieve_script **scripts;
+	unsigned int count, i;
+
+	/* Unreference included scripts */
+	scripts = array_get_modifiable(&actx->included_scripts, &count);
+	for ( i = 0; i < count; i++ ) {
+		sieve_script_unref(&scripts[i]);
+	}
+
+	/* Unreference variable scopes */
+	if ( actx->global_vars != NULL )
+		sieve_variable_scope_unref(&actx->global_vars);
+}
+
+static const struct sieve_ast_extension include_ast_extension = {
+	&include_extension,
+	ext_include_ast_free
+};
+
+struct ext_include_ast_context *ext_include_create_ast_context
+(const struct sieve_extension *this_ext, struct sieve_ast *ast,
+	struct sieve_ast *parent)
+{
+	struct ext_include_ast_context *actx;
+
+	pool_t pool = sieve_ast_pool(ast);
+	actx = p_new(pool, struct ext_include_ast_context, 1);
+	p_array_init(&actx->included_scripts, pool, 32);
+
+	if ( parent != NULL ) {
+		struct ext_include_ast_context *parent_ctx =
+			(struct ext_include_ast_context *)
+				sieve_ast_extension_get_context(parent, this_ext);
+		actx->global_vars = parent_ctx->global_vars;
+
+		i_assert( actx->global_vars != NULL );
+
+		sieve_variable_scope_ref(actx->global_vars);
+	} else {
+		actx->global_vars = sieve_variable_scope_create(this_ext);
+	}
+
+	sieve_ast_extension_register
+		(ast, this_ext, &include_ast_extension, (void *) actx);
+
+	return actx;
+}
+
+struct ext_include_ast_context *ext_include_get_ast_context
+(const struct sieve_extension *this_ext, struct sieve_ast *ast)
+{
+	struct ext_include_ast_context *actx = (struct ext_include_ast_context *)
+		sieve_ast_extension_get_context(ast, this_ext);
+
+	if ( actx != NULL ) return actx;
+
+	return ext_include_create_ast_context(this_ext, ast, NULL);
+}
+
+void ext_include_ast_link_included_script
+(const struct sieve_extension *this_ext, struct sieve_ast *ast,
+	struct sieve_script *script)
+{
+	struct ext_include_ast_context *actx =
+		ext_include_get_ast_context(this_ext, ast);
+
+	array_append(&actx->included_scripts, &script, 1);
+}
+
+bool ext_include_validator_have_variables
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr)
+{
+	struct ext_include_context *ectx = ext_include_get_context(this_ext);
+
+	return sieve_ext_variables_is_active(ectx->var_ext, valdtr);
+}
+
+/*
+ * Generator context management
+ */
+
+static struct ext_include_generator_context *
+ext_include_create_generator_context
+(struct sieve_generator *gentr, struct ext_include_generator_context *parent,
+	struct sieve_script *script)
+{
+	struct ext_include_generator_context *ctx;
+
+	pool_t pool = sieve_generator_pool(gentr);
+	ctx = p_new(pool, struct ext_include_generator_context, 1);
+	ctx->parent = parent;
+	ctx->script = script;
+	if ( parent == NULL ) {
+		ctx->nesting_level = 0;
+	} else {
+		ctx->nesting_level = parent->nesting_level + 1;
+	}
+
+	return ctx;
+}
+
+static inline struct ext_include_generator_context *
+	ext_include_get_generator_context
+(const struct sieve_extension *this_ext, struct sieve_generator *gentr)
+{
+	return (struct ext_include_generator_context *)
+		sieve_generator_extension_get_context(gentr, this_ext);
+}
+
+static inline void ext_include_initialize_generator_context
+(const struct sieve_extension *this_ext, struct sieve_generator *gentr,
+	struct ext_include_generator_context *parent, struct sieve_script *script)
+{
+	sieve_generator_extension_set_context(gentr, this_ext,
+		ext_include_create_generator_context(gentr, parent, script));
+}
+
+void ext_include_register_generator_context
+(const struct sieve_extension *this_ext, const struct sieve_codegen_env *cgenv)
+{
+	struct ext_include_generator_context *ctx =
+		ext_include_get_generator_context(this_ext, cgenv->gentr);
+
+	/* Initialize generator context if necessary */
+	if ( ctx == NULL ) {
+		ctx = ext_include_create_generator_context(
+			cgenv->gentr, NULL, cgenv->script);
+
+		sieve_generator_extension_set_context
+			(cgenv->gentr, this_ext, (void *) ctx);
+	}
+
+	/* Initialize ast context if necessary */
+	(void)ext_include_get_ast_context(this_ext, cgenv->ast);
+	(void)ext_include_binary_init(this_ext, cgenv->sbin, cgenv->ast);
+}
+
+/*
+ * Runtime initialization
+ */
+
+static void ext_include_runtime_init
+(const struct sieve_extension *this_ext, const struct sieve_runtime_env *renv,
+	void *context)
+{
+	struct ext_include_interpreter_context *ctx =
+		(struct ext_include_interpreter_context *) context;
+	struct ext_include_context *ectx = ext_include_get_context(this_ext);
+
+	if ( ctx->parent == NULL ) {
+		ctx->global = p_new(ctx->pool, struct ext_include_interpreter_global, 1);
+		p_array_init(&ctx->global->included_scripts, ctx->pool, 10);
+
+
+		ctx->global->variables = sieve_variable_storage_create
+			(ctx->pool, ext_include_binary_get_global_scope(this_ext, renv->sbin), 0);
+	} else {
+		ctx->global = ctx->parent->global;
+	}
+
+	sieve_ext_variables_set_storage
+		(ectx->var_ext, renv->interp, ctx->global->variables, this_ext);
+}
+
+static struct sieve_interpreter_extension include_interpreter_extension = {
+	&include_extension,
+	ext_include_runtime_init,
+	NULL,
+};
+
+/*
+ * Interpreter context management
+ */
+
+static struct ext_include_interpreter_context *
+	ext_include_interpreter_context_create
+(struct sieve_interpreter *interp,
+	struct ext_include_interpreter_context *parent,
+	struct sieve_script *script, const struct ext_include_script_info *sinfo)
+{
+	struct ext_include_interpreter_context *ctx;
+
+	pool_t pool = sieve_interpreter_pool(interp);
+	ctx = p_new(pool, struct ext_include_interpreter_context, 1);
+	ctx->pool = pool;
+	ctx->parent = parent;
+	ctx->interp = interp;
+	ctx->script = script;
+	ctx->script_info = sinfo;
+
+	if ( parent == NULL ) {
+		ctx->nesting_level = 0;
+	} else {
+		ctx->nesting_level = parent->nesting_level + 1;
+	}
+
+	return ctx;
+}
+
+static inline struct ext_include_interpreter_context *
+	ext_include_get_interpreter_context
+(const struct sieve_extension *this_ext, struct sieve_interpreter *interp)
+{
+	return (struct ext_include_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, this_ext);
+}
+
+static inline struct ext_include_interpreter_context *
+	ext_include_interpreter_context_init_child
+(const struct sieve_extension *this_ext, struct sieve_interpreter *interp,
+	struct ext_include_interpreter_context *parent,
+	struct sieve_script *script, const struct ext_include_script_info *sinfo)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_interpreter_context_create(interp, parent, script, sinfo);
+
+	sieve_interpreter_extension_register
+		(interp, this_ext, &include_interpreter_extension, ctx);
+
+	return ctx;
+}
+
+void ext_include_interpreter_context_init
+(const struct sieve_extension *this_ext, struct sieve_interpreter *interp)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(this_ext, interp);
+
+	/* Is this is the top-level interpreter ? */
+	if ( ctx == NULL ) {
+		struct sieve_script *script;
+
+		/* Initialize top context */
+		script = sieve_interpreter_script(interp);
+		ctx = ext_include_interpreter_context_create
+			(interp, NULL, script, NULL);
+
+		sieve_interpreter_extension_register
+			(interp, this_ext, &include_interpreter_extension, (void *) ctx);
+	}
+}
+
+struct sieve_variable_storage *ext_include_interpreter_get_global_variables
+(const struct sieve_extension *this_ext, struct sieve_interpreter *interp)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(this_ext, interp);
+
+	return ctx->global->variables;
+}
+
+/*
+ * Including a script during code generation
+ */
+
+bool ext_include_generate_include
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+	enum ext_include_script_location location, struct sieve_script *script,
+	const struct ext_include_script_info **included_r, bool once)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	bool result = TRUE;
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_generator *gentr = cgenv->gentr;
+	struct ext_include_binary_context *binctx;
+	struct sieve_generator *subgentr;
+	struct ext_include_generator_context *ctx =
+		ext_include_get_generator_context(this_ext, gentr);
+	struct ext_include_generator_context *pctx;
+	struct sieve_error_handler *ehandler = sieve_generator_error_handler(gentr);
+	const struct ext_include_script_info *included;
+
+	*included_r = NULL;
+
+	/* Just to be sure: do not include more scripts when errors have occured
+	 * already.
+	 */
+	if ( sieve_get_errors(ehandler) > 0 )
+		return FALSE;
+
+	/* Limit nesting level */
+	if ( ctx->nesting_level >= EXT_INCLUDE_MAX_NESTING_LEVEL ) {
+		sieve_command_generate_error
+			(gentr, cmd, "cannot nest includes deeper than %d levels",
+				EXT_INCLUDE_MAX_NESTING_LEVEL);
+		return FALSE;
+	}
+
+	/* Check for circular include */
+	if ( !once ) {
+		pctx = ctx;
+		while ( pctx != NULL ) {
+			if ( sieve_script_equals(pctx->script, script) ) {
+				sieve_command_generate_error(gentr, cmd, "circular include");
+
+				return FALSE;
+			}
+
+			pctx = pctx->parent;
+		}
+	}
+
+	/* Get binary context */
+	binctx = ext_include_binary_init(this_ext, sbin, cgenv->ast);
+
+	/* Is the script already compiled into the current binary? */
+	if ( !ext_include_binary_script_is_included(binctx, script, &included) )
+	{
+		unsigned int inc_block_id, this_block_id;
+		const char *script_name = sieve_script_name(script);
+
+		/* Check whether include limit is exceeded */
+		if ( ext_include_binary_script_get_count(binctx) >=
+			EXT_INCLUDE_MAX_INCLUDES ) {
+	 		sieve_command_generate_error(gentr, cmd,
+	 			"failed to include script '%s': no more than %u includes allowed",
+				str_sanitize(script_name, 80), EXT_INCLUDE_MAX_INCLUDES);
+	 		return FALSE;
+		}
+
+		/* No, allocate a new block in the binary and mark the script as included.
+		 */
+		inc_block_id = sieve_binary_block_create(sbin);
+		included = ext_include_binary_script_include
+			(binctx, script, location, inc_block_id);
+
+		/* Parse */
+		if ( (ast = sieve_parse(script, ehandler)) == NULL ) {
+	 		sieve_command_generate_error(gentr, cmd,
+	 			"failed to parse included script '%s'", str_sanitize(script_name, 80));
+	 		return FALSE;
+		}
+
+		/* Included scripts inherit global variable scope */
+		(void)ext_include_create_ast_context(this_ext, ast, cmd->ast_node->ast);
+
+		/* Validate */
+		if ( !sieve_validate(ast, ehandler) ) {
+			sieve_command_generate_error(gentr, cmd,
+				"failed to validate included script '%s'", str_sanitize(script_name, 80));
+	 		sieve_ast_unref(&ast);
+	 		return FALSE;
+	 	}
+
+		/* Generate
+		 *
+		 * FIXME: It might not be a good idea to recurse code generation for
+		 * included scripts.
+		 */
+		if ( sieve_binary_block_set_active(sbin, inc_block_id, &this_block_id) ) {
+		 	subgentr = sieve_generator_create(ast, ehandler);
+			ext_include_initialize_generator_context(cmd->ext, subgentr, ctx, script);
+
+			if ( !sieve_generator_run(subgentr, &sbin) ) {
+				sieve_command_generate_error(gentr, cmd,
+					"failed to generate code for included script '%s'",
+					str_sanitize(script_name, 80));
+		 		result = FALSE;
+			}
+
+			if ( sbin != NULL )
+				(void) sieve_binary_block_set_active(sbin, this_block_id, NULL);
+			sieve_generator_free(&subgentr);
+		} else {
+			sieve_sys_error("include: failed to activate binary  block %d for "
+				"generating code for the included script", inc_block_id);
+			result = FALSE;
+		}
+
+		/* Cleanup */
+		sieve_ast_unref(&ast);
+	}
+
+	if ( result ) *included_r = included;
+
+	return result;
+}
+
+/*
+ * Executing an included script during interpretation
+ */
+
+static int ext_include_runtime_check_circular
+(struct ext_include_interpreter_context *ctx,
+	const struct ext_include_script_info *include)
+{
+	struct ext_include_interpreter_context *pctx;
+
+	pctx = ctx;
+	while ( pctx != NULL ) {
+
+		if ( sieve_script_equals(include->script, pctx->script) )
+			return TRUE;
+
+		pctx = pctx->parent;
+	}
+
+	return FALSE;
+}
+
+static bool ext_include_runtime_include_mark
+(struct ext_include_interpreter_context *ctx,
+	const struct ext_include_script_info *include, bool once)
+{
+	struct sieve_script *const *includes;
+	unsigned int count, i;
+
+	includes = array_get(&ctx->global->included_scripts, &count);
+	for ( i = 0; i < count; i++ )	{
+		if ( sieve_script_equals(include->script, includes[i]) )
+			return ( !once );
+	}
+
+	array_append(&ctx->global->included_scripts, &include->script, 1);
+
+	return TRUE;
+}
+
+int ext_include_execute_include
+(const struct sieve_runtime_env *renv, unsigned int include_id, bool once)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	int result = SIEVE_EXEC_OK;
+	struct ext_include_interpreter_context *ctx;
+	const struct ext_include_script_info *included;
+	struct ext_include_binary_context *binctx =
+		ext_include_binary_get_context(this_ext, renv->sbin);
+
+	/* Check for invalid include id (== corrupt binary) */
+	included = ext_include_binary_script_get_included(binctx, include_id);
+	if ( included == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid include id: %d", include_id);
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	ctx = ext_include_get_interpreter_context(this_ext, renv->interp);
+
+	sieve_runtime_trace(renv,
+		"INCLUDE command (script: %s, id: %d block: %d) START::",
+		sieve_script_name(included->script), include_id, included->block_id);
+
+	/* If :once modifier is specified, check for duplicate include */
+	if ( !ext_include_runtime_include_mark(ctx, included, once) ) {
+		/* skip */
+
+		sieve_runtime_trace(renv,
+			"INCLUDE command (block: %d) SKIPPED ::", included->block_id);
+		return result;
+	}
+
+	/* Check circular include during interpretation as well.
+	 * Let's not trust binaries.
+	 */
+	if ( ext_include_runtime_check_circular(ctx, included) ) {
+		sieve_runtime_trace_error(renv,
+			"circular include for script: %s [%d]",
+			sieve_script_name(included->script), included->block_id);
+
+		/* Situation has no valid way to emerge at runtime */
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( ctx->parent == NULL ) {
+		struct ext_include_interpreter_context *curctx = NULL;
+		struct sieve_error_handler *ehandler =
+			sieve_interpreter_get_error_handler(renv->interp);
+		struct sieve_interpreter *subinterp;
+		unsigned int this_block_id;
+		bool interrupted = FALSE;
+
+		/* We are the top-level interpreter instance */
+
+		/* Activate block for included script */
+		if ( !sieve_binary_block_set_active
+			(renv->sbin, included->block_id, &this_block_id) ) {
+			sieve_runtime_trace_error(renv, "invalid block id: %d",
+				included->block_id);
+			result = SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		if ( result == SIEVE_EXEC_OK ) {
+			/* Create interpreter for top-level included script
+			 * (first sub-interpreter)
+			 */
+			subinterp = sieve_interpreter_create(renv->sbin, ehandler);
+
+			if ( subinterp != NULL ) {
+				curctx = ext_include_interpreter_context_init_child
+					(this_ext, subinterp, ctx, included->script, included);
+
+				/* Activate and start the top-level included script */
+				result = ( sieve_interpreter_start
+					(subinterp, renv->msgdata, renv->scriptenv, renv->result,
+						&interrupted) == 1 );
+			} else
+				result = SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		/* Included scripts can have includes of their own. This is not implemented
+		 * recursively. Rather, the sub-interpreter interrupts and defers the
+		 * include to the top-level interpreter, which is here.
+		 */
+		if ( result == SIEVE_EXEC_OK && interrupted && !curctx->returned ) {
+			while ( result == SIEVE_EXEC_OK ) {
+
+				if ( ( (interrupted && curctx->returned) || (!interrupted) ) &&
+					curctx->parent != NULL ) {
+
+					/* Sub-interpreter ended or executed return */
+
+					sieve_runtime_trace(renv, "INCLUDE command (block: %d) END ::",
+						curctx->script_info->block_id);
+
+					/* Ascend interpreter stack */
+					curctx = curctx->parent;
+					sieve_interpreter_free(&subinterp);
+
+					/* This is the top-most sub-interpreter, bail out */
+					if ( curctx->parent == NULL ) break;
+
+					/* Reactivate parent */
+					(void) sieve_binary_block_set_active
+						(renv->sbin, curctx->script_info->block_id, NULL);
+					subinterp = curctx->interp;
+
+					/* Continue parent */
+					curctx->include = NULL;
+					curctx->returned = FALSE;
+
+					result = ( sieve_interpreter_continue(subinterp, &interrupted) == 1 );
+				} else {
+					if ( curctx->include != NULL ) {
+
+						/* Sub-include requested */
+
+						/* Activate the sub-include's block */
+						if ( !sieve_binary_block_set_active
+							(renv->sbin, curctx->include->block_id, NULL) ) {
+							sieve_runtime_trace_error(renv, "invalid block id: %d",
+								curctx->include->block_id);
+							result = SIEVE_EXEC_BIN_CORRUPT;
+						}
+
+						if ( result == SIEVE_EXEC_OK ) {
+							/* Create sub-interpreter */
+							subinterp = sieve_interpreter_create(renv->sbin, ehandler);
+
+							if ( subinterp != NULL ) {
+								curctx = ext_include_interpreter_context_init_child
+									(this_ext, subinterp, curctx, curctx->include->script,
+										curctx->include);
+
+								/* Start the sub-include's interpreter */
+								curctx->include = NULL;
+								curctx->returned = FALSE;
+								result = ( sieve_interpreter_start
+									(subinterp, renv->msgdata, renv->scriptenv, renv->result,
+										&interrupted) == 1 );
+							} else
+								result = SIEVE_EXEC_BIN_CORRUPT;
+						}
+					} else {
+						/* Sub-interpreter was interrupted outside this extension, probably
+						 * stop command was executed. Generate an interrupt ourselves,
+						 * ending all script execution.
+						 */
+						sieve_interpreter_interrupt(renv->interp);
+						break;
+					}
+				}
+			}
+		} else
+			sieve_runtime_trace(renv, "INCLUDE command (block: %d) END ::",
+				curctx->script_info->block_id);
+
+		/* Free any sub-interpreters that might still be active */
+		while ( curctx != NULL && curctx->parent != NULL ) {
+			struct ext_include_interpreter_context *nextctx	= curctx->parent;
+			struct sieve_interpreter *killed_interp = curctx->interp;
+
+			/* This kills curctx too */
+			sieve_interpreter_free(&killed_interp);
+
+			/* Luckily we recorded the parent earlier */
+			curctx = nextctx;
+		}
+
+		/* Return to our own block */
+		(void) sieve_binary_block_set_active(renv->sbin, this_block_id, NULL);
+	} else {
+		/* We are an included script already, defer inclusion to main interpreter */
+
+		ctx->include = included;
+		sieve_interpreter_interrupt(renv->interp);
+	}
+
+	return result;
+}
+
+void ext_include_execute_return
+(const struct sieve_runtime_env *renv)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(this_ext, renv->interp);
+
+	ctx->returned = TRUE;
+	sieve_interpreter_interrupt(renv->interp);
+}
+
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-common.h
@@ -0,0 +1,150 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_COMMON_H
+#define __EXT_INCLUDE_COMMON_H
+
+#include "lib.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+
+/*
+ * Forward declarations
+ */
+
+struct ext_include_script_info;
+struct ext_include_binary_context;
+
+/*
+ * Types
+ */
+
+enum ext_include_script_location {
+	EXT_INCLUDE_LOCATION_PERSONAL,
+	EXT_INCLUDE_LOCATION_GLOBAL,
+	EXT_INCLUDE_LOCATION_INVALID
+};
+
+static inline const char *ext_include_script_location_name
+(enum ext_include_script_location location)
+{
+	switch ( location ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		return "personal";
+
+	case EXT_INCLUDE_LOCATION_GLOBAL:
+		return "global";
+
+	default:
+		break;
+	}
+
+	return "[INVALID LOCATION]";
+}
+
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def include_extension;
+extern const struct sieve_binary_extension include_binary_ext;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def cmd_include;
+extern const struct sieve_command_def cmd_return;
+extern const struct sieve_command_def cmd_global;
+
+/* DEPRICATED */
+extern const struct sieve_command_def cmd_import;
+extern const struct sieve_command_def cmd_export;
+
+/*
+ * Operations
+ */
+
+enum ext_include_opcode {
+	EXT_INCLUDE_OPERATION_INCLUDE,
+	EXT_INCLUDE_OPERATION_RETURN,
+	EXT_INCLUDE_OPERATION_GLOBAL
+};
+
+extern const struct sieve_operation_def include_operation;
+extern const struct sieve_operation_def return_operation;
+extern const struct sieve_operation_def global_operation;
+
+/*
+ * Script access
+ */
+
+const char *ext_include_get_script_directory
+	(const struct sieve_extension *ext,
+		enum ext_include_script_location location, const char *script_name);
+
+/*
+ * Context
+ */
+
+/* Extension context */
+
+struct ext_include_context {
+	/* Extension dependencies */
+	const struct sieve_extension *var_ext;
+};
+
+static inline struct ext_include_context *ext_include_get_context
+(const struct sieve_extension *ext)
+{
+	return (struct ext_include_context *) ext->context;
+}
+
+/* AST Context */
+
+struct ext_include_ast_context {
+  struct sieve_variable_scope *global_vars;
+
+  ARRAY_DEFINE(included_scripts, struct sieve_script *);
+};
+
+struct ext_include_ast_context *ext_include_create_ast_context
+	(const struct sieve_extension *this_ext, struct sieve_ast *ast,
+		struct sieve_ast *parent);
+struct ext_include_ast_context *ext_include_get_ast_context
+	(const struct sieve_extension *this_ext, struct sieve_ast *ast);
+
+void ext_include_ast_link_included_script
+	(const struct sieve_extension *this_ext, struct sieve_ast *ast,
+		struct sieve_script *script);
+
+bool ext_include_validator_have_variables
+	(const struct sieve_extension *this_ext, struct sieve_validator *valdtr);
+
+/* Generator context */
+
+void ext_include_register_generator_context
+	(const struct sieve_extension *this_ext,
+		const struct sieve_codegen_env *cgenv);
+
+bool ext_include_generate_include
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+		enum ext_include_script_location location, struct sieve_script *script,
+		const struct ext_include_script_info **included_r, bool once);
+
+/* Interpreter context */
+
+void ext_include_interpreter_context_init
+	(const struct sieve_extension *this_ext, struct sieve_interpreter *interp);
+
+int ext_include_execute_include
+	(const struct sieve_runtime_env *renv, unsigned int block_id, bool once);
+void ext_include_execute_return(const struct sieve_runtime_env *renv);
+
+struct sieve_variable_storage *ext_include_interpreter_get_global_variables
+	(const struct sieve_extension *this_ext, struct sieve_interpreter *interp);
+
+#endif /* __EXT_INCLUDE_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-limits.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-limits.h
@@ -0,0 +1,12 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_LIMITS_H
+#define __EXT_INCLUDE_LIMITS_H
+
+#include "sieve-common.h"
+
+#define EXT_INCLUDE_MAX_NESTING_LEVEL 10
+#define EXT_INCLUDE_MAX_INCLUDES      255
+
+#endif /* __EXT_INCLUDE_LIMITS_H */
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-variables.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-variables.c
@@ -0,0 +1,152 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+/*
+ * Variable import-export
+ */
+
+struct sieve_variable *ext_include_variable_import_global
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const char *variable)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	struct sieve_ast *ast = cmd->ast_node->ast;
+	struct ext_include_ast_context *ctx =
+		ext_include_get_ast_context(this_ext, ast);
+	struct ext_include_context *ectx = ext_include_get_context(this_ext);
+	struct sieve_variable_scope *main_scope;
+	struct sieve_variable *var = NULL;
+
+	/* Sanity safeguard */
+	i_assert ( ctx->global_vars != NULL );
+
+	/* Get/Declare the variable in the global scope */
+	var = sieve_variable_scope_get_variable(ctx->global_vars, variable, TRUE);
+
+	/* Check whether scope is over its size limit */
+	if ( var == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"declaration of new global variable '%s' exceeds the limit "
+			"(max variables: %u)",
+			variable, SIEVE_VARIABLES_MAX_SCOPE_SIZE);
+	}
+
+	/* Import the global variable into the local script scope */
+	main_scope = sieve_ext_variables_get_main_scope(ectx->var_ext, valdtr);
+	(void)sieve_variable_scope_import(main_scope, var);
+
+	return var;
+}
+
+/*
+ * Binary symbol table
+ */
+
+bool ext_include_variables_save
+(struct sieve_binary *sbin, struct sieve_variable_scope *global_vars)
+{
+	unsigned int count = sieve_variable_scope_size(global_vars);
+
+	sieve_binary_emit_unsigned(sbin, count);
+
+	if ( count > 0 ) {
+		unsigned int size, i;
+		struct sieve_variable *const *vars =
+			sieve_variable_scope_get_variables(global_vars, &size);
+
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_emit_cstring(sbin, vars[i]->identifier);
+		}
+	}
+
+	return TRUE;
+}
+
+bool ext_include_variables_load
+(const struct sieve_extension *this_ext, struct sieve_binary *sbin,
+	sieve_size_t *offset, unsigned int block,
+	struct sieve_variable_scope **global_vars_r)
+{
+	unsigned int count = 0;
+	unsigned int i;
+	pool_t pool;
+
+	/* Sanity assert */
+	i_assert( *global_vars_r == NULL );
+
+	if ( !sieve_binary_read_unsigned(sbin, offset, &count) ) {
+		sieve_sys_error("include: failed to read global variables count "
+			"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+		return FALSE;
+	}
+
+	if ( count > SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		sieve_sys_error("include: global variable scope size of binary %s "
+			"exceeds the limit (%u > %u)", sieve_binary_path(sbin),
+			count, SIEVE_VARIABLES_MAX_SCOPE_SIZE );
+		return FALSE;
+	}
+
+	*global_vars_r = sieve_variable_scope_create(this_ext);
+	pool = sieve_variable_scope_pool(*global_vars_r);
+
+	/* Read global variable scope */
+	for ( i = 0; i < count; i++ ) {
+		struct sieve_variable *var;
+		string_t *identifier;
+
+		if ( !sieve_binary_read_string(sbin, offset, &identifier) ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: failed to read global variable specification "
+				"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+			return FALSE;
+		}
+
+		var = sieve_variable_scope_declare(*global_vars_r, str_c(identifier));
+
+		i_assert( var != NULL );
+		i_assert( var->index == i );
+	}
+
+	return TRUE;
+}
+
+bool ext_include_variables_dump
+(struct sieve_dumptime_env *denv, struct sieve_variable_scope *global_vars)
+{
+	unsigned int size;
+	struct sieve_variable *const *vars;
+
+	i_assert(global_vars != NULL);
+
+	vars = sieve_variable_scope_get_variables(global_vars, &size);
+
+	if ( size > 0 ) {
+		unsigned int i;
+
+		sieve_binary_dump_sectionf(denv, "Global variables");
+
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_dumpf(denv, "%3d: '%s' \n", i, vars[i]->identifier);
+		}
+	}
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/plugins/include/ext-include-variables.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include-variables.h
@@ -0,0 +1,35 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_VARIABLES_H
+#define __EXT_INCLUDE_VARIABLES_H
+
+#include "sieve-common.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+
+/*
+ * Variable import-export
+ */
+
+struct sieve_variable *ext_include_variable_import_global
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		const char *variable);
+
+/*
+ * Binary symbol table
+ */
+
+bool ext_include_variables_save
+	(struct sieve_binary *sbin, struct sieve_variable_scope *global_vars);
+bool ext_include_variables_load
+	(const struct sieve_extension *this_ext, struct sieve_binary *sbin,
+		sieve_size_t *offset, unsigned int block,
+		struct sieve_variable_scope **global_vars_r);
+bool ext_include_variables_dump
+	(struct sieve_dumptime_env *denv, struct sieve_variable_scope *global_vars);
+
+#endif /* __EXT_INCLUDE_VARIABLES_H */
+
Index: b/sieve/src/lib-sieve/plugins/include/ext-include.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/include/ext-include.c
@@ -0,0 +1,142 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension include
+ * -----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-ietf-sieve-include-01
+ * Implementation: almost full; global namespace is missing.
+ * Status: experimental
+ *
+ */
+
+/* FIXME: Current include implementation does not allow for parts of the script
+ * to be located in external binaries; all included scripts are recompiled and
+ * the resulting byte code is imported into the main binary in separate blocks.
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+
+/*
+ * Operations
+ */
+
+static const struct sieve_operation_def *ext_include_operations[] = {
+	&include_operation,
+	&return_operation,
+	&global_operation
+};
+
+/*
+ * Extension
+ */
+
+/* Forward declaration */
+
+static bool ext_include_load
+	(const struct sieve_extension *ext, void **context);
+static void ext_include_unload
+	(const struct sieve_extension *ext);
+static bool ext_include_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *validator);
+static bool ext_include_generator_load
+	(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv);
+static bool ext_include_interpreter_load
+	(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+		sieve_size_t *address);
+static bool ext_include_binary_load
+	(const struct sieve_extension *ext, struct sieve_binary *binary);
+
+/* Extension objects */
+
+const struct sieve_extension_def include_extension = {
+	"include",
+	ext_include_load,
+	ext_include_unload,
+	ext_include_validator_load,
+	ext_include_generator_load,
+	ext_include_interpreter_load,
+	ext_include_binary_load,
+	ext_include_binary_dump,
+	ext_include_code_dump,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_include_operations),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/* Extension hooks */
+
+static bool ext_include_load
+(const struct sieve_extension *ext, void **context)
+{
+	struct ext_include_context *ctx = i_new(struct ext_include_context, 1);
+
+	/* Extension dependencies */
+	ctx->var_ext = sieve_ext_variables_get_extension(ext->svinst);
+
+	*context = ctx;
+
+	return TRUE;
+}
+
+static void ext_include_unload
+(const struct sieve_extension *ext)
+{
+	struct ext_include_context *ctx = (struct ext_include_context *) ext->context;
+
+	i_free(ctx);
+}
+
+static bool ext_include_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator)
+{
+	/* Register new commands */
+	sieve_validator_register_command(validator, ext, &cmd_include);
+	sieve_validator_register_command(validator, ext, &cmd_return);
+	sieve_validator_register_command(validator, ext, &cmd_global);
+
+	/* DEPRICATED */
+	sieve_validator_register_command(validator, ext, &cmd_import);
+	sieve_validator_register_command(validator, ext, &cmd_export);
+
+	return TRUE;
+}
+
+static bool ext_include_generator_load
+(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv)
+{
+	ext_include_register_generator_context(ext, cgenv);
+
+	return TRUE;
+}
+
+static bool ext_include_interpreter_load
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	ext_include_interpreter_context_init(ext, renv->interp);
+
+	return TRUE;
+}
+
+static bool ext_include_binary_load
+(const struct sieve_extension *ext, struct sieve_binary *sbin)
+{
+	(void)ext_include_binary_get_context(ext, sbin);
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/plugins/mailbox/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/mailbox/Makefile.am
@@ -0,0 +1,22 @@
+noinst_LTLIBRARIES = libsieve_ext_mailbox.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tags = \
+	tag-mailbox-create.c
+
+tests = \
+	tst-mailboxexists.c
+
+libsieve_ext_mailbox_la_SOURCES = \
+	$(tags) \
+	$(tests) \
+	ext-mailbox.c
+
+noinst_HEADERS = \
+	ext-mailbox-common.h
Index: b/sieve/src/lib-sieve/plugins/mailbox/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/mailbox/Makefile.in
@@ -0,0 +1,501 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/mailbox
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_mailbox_la_LIBADD =
+am__objects_1 = tag-mailbox-create.lo
+am__objects_2 = tst-mailboxexists.lo
+am_libsieve_ext_mailbox_la_OBJECTS = $(am__objects_1) $(am__objects_2) \
+	ext-mailbox.lo
+libsieve_ext_mailbox_la_OBJECTS =  \
+	$(am_libsieve_ext_mailbox_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_mailbox_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_mailbox_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_mailbox.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+tags = \
+	tag-mailbox-create.c
+
+tests = \
+	tst-mailboxexists.c
+
+libsieve_ext_mailbox_la_SOURCES = \
+	$(tags) \
+	$(tests) \
+	ext-mailbox.c
+
+noinst_HEADERS = \
+	ext-mailbox-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/mailbox/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/mailbox/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_mailbox.la: $(libsieve_ext_mailbox_la_OBJECTS) $(libsieve_ext_mailbox_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_mailbox_la_OBJECTS) $(libsieve_ext_mailbox_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-mailbox.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tag-mailbox-create.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-mailboxexists.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/mailbox/ext-mailbox-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/mailbox/ext-mailbox-common.h
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_MAILBOX_COMMON_H
+#define __EXT_MAILBOX_COMMON_H
+
+#include "sieve-common.h"
+
+/*
+ * Tagged arguments
+ */
+
+extern const struct sieve_argument_def mailbox_create_tag;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def mailboxexists_test;
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand_def mailbox_create_operand;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def mailboxexists_operation;
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def mailbox_extension;
+
+#endif /* __EXT_MAILBOX_COMMON_H */
+
Index: b/sieve/src/lib-sieve/plugins/mailbox/ext-mailbox.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/mailbox/ext-mailbox.c
@@ -0,0 +1,61 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension mailbox
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5490
+ * Implementation: almost full; acl support is missing for mailboxexists
+ * Status: experimental, largely untested
+ *
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-mailbox-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_mailbox_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def mailbox_extension = {
+	"mailbox",
+	NULL, NULL,
+	ext_mailbox_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(mailboxexists_operation),
+	SIEVE_EXT_DEFINE_OPERAND(mailbox_create_operand)
+};
+
+static bool ext_mailbox_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register :create tag with fileinto command and we don't care whether this
+	 * command is registered or even whether it will be registered at all. The
+	 * validator handles either situation gracefully
+	 */
+	sieve_validator_register_external_tag
+		(valdtr, "fileinto", ext, &mailbox_create_tag, SIEVE_OPT_SIDE_EFFECT);
+
+	/* Register new test */
+	sieve_validator_register_command(valdtr, ext, &mailboxexists_test);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/mailbox/tag-mailbox-create.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/mailbox/tag-mailbox-create.c
@@ -0,0 +1,174 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-result.h"
+#include "sieve-generator.h"
+
+#include "ext-mailbox-common.h"
+
+/*
+ * Tagged argument
+ */
+
+static bool tag_mailbox_create_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_mailbox_create_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command *context);
+
+const struct sieve_argument_def mailbox_create_tag = {
+	"create",
+	NULL,
+	tag_mailbox_create_validate,
+	NULL, NULL,
+	tag_mailbox_create_generate
+};
+
+/*
+ * Side effect
+ */
+
+static void seff_mailbox_create_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+static bool seff_mailbox_create_pre_execute
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void **se_context,
+		void *tr_context);;
+
+const struct sieve_side_effect_def mailbox_create_side_effect = {
+	SIEVE_OBJECT("create", &mailbox_create_operand, 0),
+	&act_store,
+	NULL, NULL, NULL,
+	seff_mailbox_create_print,
+	seff_mailbox_create_pre_execute,
+	NULL, NULL, NULL
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(mailbox_create_side_effect);
+
+const struct sieve_operand_def mailbox_create_operand = {
+	"create operand",
+	&mailbox_extension,
+	0,
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/*
+ * Tag validation
+ */
+
+static bool tag_mailbox_create_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_ast_argument **arg, struct sieve_command *cmd ATTR_UNUSED)
+{
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool tag_mailbox_create_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *context ATTR_UNUSED)
+{
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit
+		(cgenv->sbin, arg->argument->ext, &mailbox_create_side_effect);
+
+	return TRUE;
+}
+
+/*
+ * Side effect implementation
+ */
+
+static void seff_mailbox_create_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_result_print_env *rpenv, bool *keep ATTR_UNUSED)
+{
+	sieve_result_seffect_printf(rpenv, "create mailbox if it does not exist");
+}
+
+static bool seff_mailbox_create_pre_execute
+(const struct sieve_side_effect *seffect ATTR_UNUSED,
+	const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv ATTR_UNUSED,
+	void **se_context ATTR_UNUSED, void *tr_context ATTR_UNUSED)
+{
+	struct act_store_transaction *trans =
+		(struct act_store_transaction *) tr_context;
+	struct mail_storage **storage = &(aenv->exec_status->last_storage);
+	enum mailbox_open_flags open_flags =
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT |
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	struct mailbox *box = NULL;
+
+	/* Check whether creation is necessary */
+	if ( trans->box != NULL || trans->redundant || trans->disabled )
+		return TRUE;
+
+	/* Check availability of namespace and folder name */
+	if ( trans->namespace == NULL || trans->folder == NULL )
+		return FALSE;
+
+	/* Check whether creation has a chance of working */
+	if ( trans->error_code != MAIL_ERROR_NONE
+		&& trans->error_code != MAIL_ERROR_NOTFOUND )
+		return FALSE;
+
+	*storage = trans->namespace->storage;
+
+	/* Create mailbox */
+	if ( mail_storage_mailbox_create(*storage, trans->folder, FALSE) < 0 ) {
+		box = NULL;
+
+	} else {
+		/* Subscribe to it if necessary */
+		if ( aenv->scriptenv->mailbox_autosubscribe ) {
+			(void)mailbox_list_set_subscribed
+				(trans->namespace->list, trans->folder, TRUE);
+		}
+
+		/* Open it */
+		box = mailbox_open(storage, trans->folder, NULL, open_flags);
+
+		if ( box != NULL && mailbox_sync(box, 0, 0, NULL) < 0 ) {
+			mailbox_close(&box);
+			box = NULL;
+		}
+	}
+
+	/* Fetch error */
+	if ( box == NULL )
+		sieve_act_store_get_storage_error(aenv, trans);
+
+	trans->box = box;
+
+	return ( box != NULL );
+}
+
+
+
Index: b/sieve/src/lib-sieve/plugins/mailbox/tst-mailboxexists.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/mailbox/tst-mailboxexists.c
@@ -0,0 +1,171 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-mailbox-common.h"
+
+/*
+ * Mailboxexists command
+ *
+ * Syntax:
+ *    mailboxexists <mailbox-names: string-list>
+ */
+
+static bool tst_mailboxexists_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_mailboxexists_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def mailboxexists_test = {
+	"mailboxexists",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_mailboxexists_validate,
+	tst_mailboxexists_generate,
+	NULL
+};
+
+/*
+ * Mailboxexists operation
+ */
+
+static bool tst_mailboxexists_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_mailboxexists_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def mailboxexists_operation = {
+	"MAILBOXEXISTS",
+	&mailbox_extension,
+	0,
+	tst_mailboxexists_operation_dump,
+	tst_mailboxexists_operation_execute
+};
+
+/*
+ * Test validation
+ */
+
+static bool tst_mailboxexists_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "mailbox-names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/*
+ * Test generation
+ */
+
+static bool tst_mailboxexists_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &mailboxexists_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_mailboxexists_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "MAILBOXEXISTS");
+	sieve_code_descend(denv);
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "mailbox-names");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_mailboxexists_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_coded_stringlist *mailbox_names;
+	string_t *mailbox_item;
+	bool result = TRUE, all_exist = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Read notify uris */
+	if ( (mailbox_names=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox-names operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "MAILBOXEXISTS command");
+
+	if ( renv->scriptenv->namespaces != NULL ) {
+		mailbox_item = NULL;
+		while ( (result=sieve_coded_stringlist_next_item
+			(mailbox_names, &mailbox_item))
+			&& mailbox_item != NULL ) {
+			struct mail_namespace *ns;
+			struct mail_storage *storage;
+			const char *mailbox = str_c(mailbox_item);
+			struct mailbox *box;
+
+			/* Find the namespace */
+			ns = mail_namespace_find(renv->scriptenv->namespaces, &mailbox);
+			if ( ns == NULL) {
+				all_exist = FALSE;
+				break;
+			}
+
+			/* Open the box */
+			storage = ns->storage;
+			box = mailbox_open(&storage, mailbox, NULL, MAILBOX_OPEN_FAST);
+			if ( box == NULL ) {
+				all_exist = FALSE;
+				break;
+			}
+
+			/* Also fail when it is readonly */
+			if ( mailbox_is_readonly(box) )
+				all_exist = FALSE;
+
+			/* FIXME: check acl for 'p' or 'i' ACL permissions as required by RFC */
+
+			/* Close mailbox */
+			mailbox_close(&box);
+		}
+	}
+
+	if ( !result ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox name item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_interpreter_set_test_result(renv->interp, all_exist);
+	return SIEVE_EXEC_OK;
+}
Index: b/sieve/src/lib-sieve/plugins/notify/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/Makefile.am
@@ -0,0 +1,23 @@
+noinst_LTLIBRARIES = libsieve_ext_notify.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-notify.c \
+	cmd-denotify.c
+
+libsieve_ext_notify_la_SOURCES = \
+	ext-notify.c \
+	ext-notify-common.c \
+	$(commands)
+
+noinst_HEADERS = \
+	ext-notify-common.h \
+	ext-notify-limits.h
+
Index: b/sieve/src/lib-sieve/plugins/notify/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/Makefile.in
@@ -0,0 +1,500 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/notify
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_notify_la_LIBADD =
+am__objects_1 = cmd-notify.lo cmd-denotify.lo
+am_libsieve_ext_notify_la_OBJECTS = ext-notify.lo ext-notify-common.lo \
+	$(am__objects_1)
+libsieve_ext_notify_la_OBJECTS = $(am_libsieve_ext_notify_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_notify_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_notify_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_notify.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-notify.c \
+	cmd-denotify.c
+
+libsieve_ext_notify_la_SOURCES = \
+	ext-notify.c \
+	ext-notify-common.c \
+	$(commands)
+
+noinst_HEADERS = \
+	ext-notify-common.h \
+	ext-notify-limits.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/notify/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/notify/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_notify.la: $(libsieve_ext_notify_la_OBJECTS) $(libsieve_ext_notify_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_notify_la_OBJECTS) $(libsieve_ext_notify_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-denotify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-notify.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-notify-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-notify.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/notify/cmd-denotify.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/cmd-denotify.c
@@ -0,0 +1,312 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-notify-common.h"
+
+/*
+ * Denotify command (NOT IMPLEMENTED)
+ *
+ * Syntax:
+ *   denotify [MATCH-TYPE string] [<":low" / ":normal" / ":high">]
+ */
+
+static bool cmd_denotify_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_denotify_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_denotify = {
+	"denotify",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	cmd_denotify_registered,
+	NULL,
+	NULL,
+	cmd_denotify_generate,
+	NULL
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Forward declarations */
+
+static bool tag_match_type_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command *cmd,
+		const struct sieve_extension *ext, const char *identifier, void **data);
+static bool tag_match_type_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+/* Argument object */
+
+const struct sieve_argument_def denotify_match_tag = {
+	"MATCH-TYPE-STRING",
+	tag_match_type_is_instance_of,
+	tag_match_type_validate,
+	NULL, NULL, NULL,
+};
+
+/* Codes for optional operands */
+
+enum cmd_denotify_optional {
+  OPT_END,
+  OPT_IMPORTANCE,
+  OPT_MATCH_TYPE,
+	OPT_MATCH_KEY
+};
+
+/*
+ * Denotify operation
+ */
+
+static bool cmd_denotify_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_denotify_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def denotify_operation = {
+	"DENOTIFY",
+	&notify_extension,
+	EXT_NOTIFY_OPERATION_DENOTIFY,
+	cmd_denotify_operation_dump,
+	cmd_denotify_operation_execute
+};
+
+/*
+ * Tag validation
+ */
+
+static bool tag_match_type_is_instance_of
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const struct sieve_extension *ext, const char *identifier, void **data)
+{
+	return match_type_tag.is_instance_of(valdtr, cmd, ext, identifier, data);
+}
+
+static bool tag_match_type_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+
+	if ( !match_type_tag.validate(valdtr, arg, cmd) )
+		return FALSE;
+
+	if ( *arg == NULL ) {
+		sieve_argument_validate_error(valdtr, tag,
+			"the MATCH-TYPE argument (:%s) for the denotify command requires "
+			"an additional key-string paramterer, but no more arguments were found",
+			sieve_ast_argument_tag(tag));
+		return FALSE;
+	}
+
+	if ( sieve_ast_argument_type(*arg) != SAAT_STRING )
+	{
+		sieve_argument_validate_error(valdtr, *arg,
+			"the MATCH-TYPE argument (:%s) for the denotify command requires "
+			"an additional key-string parameter, but %s was found",
+			sieve_ast_argument_tag(tag), sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, *arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_match_type_validate
+		(valdtr, cmd, *arg, &mcht_default, &cmp_default) )
+		return FALSE;
+
+	tag->argument->def = &match_type_tag;
+	tag->argument->ext = NULL;
+
+	(*arg)->argument->id_code = OPT_MATCH_KEY;
+
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Command registration
+ */
+
+static bool cmd_denotify_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &denotify_match_tag, OPT_MATCH_TYPE);
+
+	ext_notify_register_importance_tags(valdtr, cmd_reg, ext, OPT_IMPORTANCE);
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_denotify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &denotify_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_denotify_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &denv->oprtn;
+	int opt_code = 1;
+
+	sieve_code_dumpf(denv, "%s", sieve_operation_mnemonic(op));
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_MATCH_KEY:
+				if ( !sieve_opr_string_dump(denv, address, "key-string") )
+					return FALSE;
+				break;
+			case OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code execution
+ */
+
+static int cmd_denotify_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int opt_code = 1;
+	sieve_number_t importance = 1;
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+/*	const struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);*/
+	string_t *match_key = NULL;
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands */
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_read(renv, address, &mcht) ) {
+					sieve_runtime_trace_error(renv, "invalid match type operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MATCH_KEY:
+				if ( !sieve_opr_string_read(renv, address, &match_key) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 )
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d",
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "DENOTIFY action");
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
Index: b/sieve/src/lib-sieve/plugins/notify/cmd-notify.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/cmd-notify.c
@@ -0,0 +1,839 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "str.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "mail-storage.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-address.h"
+#include "sieve-message.h"
+
+#include "ext-notify-common.h"
+#include "ext-notify-limits.h"
+
+#include <ctype.h>
+
+/* Notify command (DEPRECATED)
+ *
+ * Syntax:
+ *   notify [":method" string] [":id" string] [":options" string-list]
+ *          [<":low" / ":normal" / ":high">] ["message:" string]
+ *
+ */
+
+static bool cmd_notify_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_notify_pre_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_notify_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_notify_generate
+	(const struct sieve_codegen_env *cgenv,
+		struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_notify_old = {
+	"notify",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	cmd_notify_registered,
+	cmd_notify_pre_validate,
+	cmd_notify_validate,
+	cmd_notify_generate,
+	NULL,
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Forward declarations */
+
+static bool cmd_notify_validate_string_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_notify_validate_stringlist_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument_def notify_method_tag = {
+	"method",
+	NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def notify_options_tag = {
+	"options",
+	NULL,
+	cmd_notify_validate_stringlist_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def notify_id_tag = {
+	"id",
+	NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def notify_message_tag = {
+	"message",
+	NULL,
+	cmd_notify_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+/*
+ * Notify operation
+ */
+
+static bool cmd_notify_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_notify_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def notify_old_operation = {
+	"NOTIFY",
+	&notify_extension,
+	EXT_NOTIFY_OPERATION_NOTIFY,
+	cmd_notify_operation_dump,
+	cmd_notify_operation_execute
+};
+
+/* Codes for optional operands */
+
+enum cmd_notify_optional {
+  OPT_END,
+  OPT_MESSAGE,
+  OPT_IMPORTANCE,
+  OPT_OPTIONS,
+  OPT_ID
+};
+
+/*
+ * Notify action
+ */
+
+/* Forward declarations */
+
+static int act_notify_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+static void act_notify_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		bool *keep);
+static bool act_notify_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv,
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action_def act_notify_old = {
+	"notify",
+	0,
+	NULL,
+	act_notify_check_duplicate,
+	NULL,
+	act_notify_print,
+	NULL, NULL,
+	act_notify_commit,
+	NULL
+};
+
+/*
+ * Command validation context
+ */
+
+struct cmd_notify_context_data {
+	struct sieve_ast_argument *id;
+	struct sieve_ast_argument *method;
+	struct sieve_ast_argument *options;
+	struct sieve_ast_argument *message;
+};
+
+/*
+ * Tag validation
+ */
+
+static bool cmd_notify_validate_string_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+    struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Check syntax:
+	 *   :id <string>
+	 *   :method <string>
+	 *   :message <string>
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING) )
+		return FALSE;
+
+	if ( sieve_argument_is(tag, notify_method_tag) ) {
+		ctx_data->method = *arg;
+
+		/* Removed */
+		*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	} else if ( sieve_argument_is(tag, notify_id_tag) ) {
+		ctx_data->id = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+
+	} else if ( sieve_argument_is(tag, notify_message_tag) ) {
+		ctx_data->message = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+	}
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate_stringlist_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :options string-list
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) )
+		return FALSE;
+
+	/* Assign context */
+	ctx_data->options = *arg;
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Command registration
+ */
+
+static bool cmd_notify_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_method_tag, 0);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_id_tag, OPT_ID);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_message_tag, OPT_MESSAGE);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &notify_options_tag, OPT_OPTIONS);
+
+	ext_notify_register_importance_tags(valdtr, cmd_reg, ext, OPT_IMPORTANCE);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_notify_pre_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_command *cmd)
+{
+	struct cmd_notify_context_data *ctx_data;
+
+	/* Create context */
+	ctx_data = p_new(sieve_command_pool(cmd),	struct cmd_notify_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static int cmd_notify_address_validate
+(void *context, struct sieve_ast_argument *arg)
+{
+	struct sieve_validator *valdtr = (struct sieve_validator *) context;
+
+	if ( sieve_argument_is_string_literal(arg) ) {
+		string_t *address = sieve_ast_argument_str(arg);
+		const char *error;
+		bool result = FALSE;
+
+		T_BEGIN {
+			result = sieve_address_validate(address, &error);
+
+			if ( !result ) {
+				sieve_argument_validate_error(valdtr, arg,
+					"specified :options address '%s' is invalid for "
+					"the mailto notify method: %s",
+					str_sanitize(str_c(address), 128), error);
+			}
+		} T_END;
+
+		return result;
+	}
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct cmd_notify_context_data *ctx_data =
+		(struct cmd_notify_context_data *) cmd->data;
+
+	/* Check :method argument */
+	if ( ctx_data->method != NULL )	{
+		const char *method = sieve_ast_argument_strc(ctx_data->method);
+
+		if ( strcasecmp(method, "mailto") != 0 ) {
+			sieve_command_validate_error(valdtr, cmd,
+				"the notify command of the deprecated notify extension "
+				"only supports the 'mailto' notification method");
+			return FALSE;
+		}
+	}
+
+	/* Check :options argument */
+	if ( ctx_data->options != NULL ) {
+		struct sieve_ast_argument *option = ctx_data->options;
+
+		/* Parse and check options */
+		if ( sieve_ast_stringlist_map
+			(&option, (void *) valdtr, cmd_notify_address_validate) <= 0 ) {
+			return FALSE;
+		}
+	} else {
+		sieve_command_validate_warning(valdtr, cmd,
+			"no :options (and hence recipients) specified for the notify command");
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_notify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &notify_old_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_notify_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 1;
+
+	sieve_code_dumpf(denv, "NOTIFY");
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			case OPT_ID:
+				if ( !sieve_opr_string_dump(denv, address, "id") )
+					return FALSE;
+				break;
+			case OPT_OPTIONS:
+				if ( !sieve_opr_stringlist_dump(denv, address, "options") )
+					return FALSE;
+				break;
+			case OPT_MESSAGE:
+				if ( !sieve_opr_string_dump(denv, address, "message") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code execution
+ */
+
+
+static int cmd_notify_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct ext_notify_action *act;
+	pool_t pool;
+	int opt_code = 1;
+	sieve_number_t importance = 1;
+	struct sieve_coded_stringlist *options = NULL;
+	string_t *message = NULL, *id = NULL;
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands */
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 )
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			case OPT_ID:
+				if ( !sieve_opr_string_read(renv, address, &id) ) {
+					sieve_runtime_trace_error(renv, "invalid id operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MESSAGE:
+				if ( !sieve_opr_string_read(renv, address, &message) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_OPTIONS:
+				if ( (options=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid options operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d",
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY action");
+
+	/* Compose action */
+	if ( options != NULL ) {
+		string_t *raw_address;
+		string_t *out_message;
+		bool result;
+
+		pool = sieve_result_pool(renv->result);
+		act = p_new(pool, struct ext_notify_action, 1);
+		if ( id != NULL )
+				act->id = p_strdup(pool, str_c(id));
+		act->importance = importance;
+
+		/* Process message */
+
+		out_message = t_str_new(1024);
+		ext_notify_construct_message
+			(renv, (message == NULL ? NULL : str_c(message)), out_message);
+		act->message = p_strdup(pool, str_c(out_message));
+
+		/* Normalize and verify all :options addresses */
+
+		sieve_coded_stringlist_reset(options);
+
+		p_array_init(&act->recipients, pool, 4);
+
+		raw_address = NULL;
+		while ( (result=sieve_coded_stringlist_next_item(options, &raw_address))
+			&& raw_address != NULL ) {
+			const char *error = NULL;
+			const char *addr_norm = sieve_address_normalize(raw_address, &error);
+
+			/* Add if valid address */
+			if ( addr_norm != NULL ) {
+				const struct ext_notify_recipient *rcpts;
+				unsigned int rcpt_count, i;
+
+				/* Prevent duplicates */
+				rcpts = array_get(&act->recipients, &rcpt_count);
+
+				for ( i = 0; i < rcpt_count; i++ ) {
+					if ( sieve_address_compare
+						(rcpts[i].normalized, addr_norm, TRUE) == 0 )
+						break;
+				}
+
+				/* Add only if unique */
+				if ( i != rcpt_count ) {
+					sieve_runtime_warning(renv,
+						sieve_error_script_location(renv->script, source_line),
+						"duplicate recipient '%s' specified in the :options argument of "
+						"the deprecated notify command",
+						str_sanitize(str_c(raw_address), 128));
+
+				}	else if
+					( array_count(&act->recipients) >= EXT_NOTIFY_MAX_RECIPIENTS ) {
+					sieve_runtime_warning(renv,
+						sieve_error_script_location(renv->script, source_line),
+						"more than the maximum %u recipients are specified "
+						"for the deprecated notify command; "
+						"the rest is discarded", EXT_NOTIFY_MAX_RECIPIENTS);
+					break;
+
+				} else {
+					struct ext_notify_recipient recipient;
+
+					recipient.full = p_strdup(pool, str_c(raw_address));
+					recipient.normalized = p_strdup(pool, addr_norm);
+
+					array_append(&act->recipients, &recipient, 1);
+				}
+			} else {
+				sieve_runtime_error(renv,
+					sieve_error_script_location(renv->script, source_line),
+					"specified :options address '%s' is invalid for "
+					"the deprecated notify command: %s",
+					str_sanitize(str_c(raw_address), 128), error);
+				return SIEVE_EXEC_FAILURE;
+			}
+		}
+
+		if ( !result ) {
+			sieve_runtime_trace_error(renv, "invalid options stringlist");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		return ( sieve_result_add_action
+			(renv, this_ext, &act_notify_old, NULL, source_line, (void *) act, 0)
+				>= 0 );
+	}
+
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_notify_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action *act ATTR_UNUSED,
+	const struct sieve_action *act_other ATTR_UNUSED)
+{
+	struct ext_notify_action *new_nact, *old_nact;
+	const struct ext_notify_recipient *new_rcpts;
+	const struct ext_notify_recipient *old_rcpts;
+	unsigned int new_count, old_count, i, j;
+	unsigned int del_start = 0, del_len = 0;
+
+	if ( act->context == NULL || act_other->context == NULL )
+		return 0;
+
+	new_nact = (struct ext_notify_action *) act->context;
+	old_nact = (struct ext_notify_action *) act_other->context;
+
+	new_rcpts = array_get(&new_nact->recipients, &new_count);
+	old_rcpts = array_get(&old_nact->recipients, &old_count);
+
+	for ( i = 0; i < new_count; i++ ) {
+		for ( j = 0; j < old_count; j++ ) {
+			if ( sieve_address_compare
+				(new_rcpts[i].normalized, old_rcpts[j].normalized, TRUE) == 0 )
+				break;
+		}
+
+		if ( j == old_count ) {
+			/* Not duplicate */
+			if ( del_len > 0 ) {
+				/* Perform pending deletion */
+				array_delete(&new_nact->recipients, del_start, del_len);
+
+				/* Make sure the loop integrity is maintained */
+				i -= del_len;
+				new_rcpts = array_get(&new_nact->recipients, &new_count);
+			}
+
+			del_len = 0;
+		} else {
+			/* Mark deletion */
+			if ( del_len == 0 )
+				del_start = i;
+			del_len++;
+		}
+	}
+
+	/* Perform pending deletion */
+	if ( del_len > 0 ) {
+		array_delete(&new_nact->recipients, del_start, del_len);
+	}
+
+	return ( array_count(&new_nact->recipients) > 0 ? 0 : 1 );
+}
+
+/* Result printing */
+
+static void act_notify_print
+(const struct sieve_action *action,	const struct sieve_result_print_env *rpenv,
+	bool *keep ATTR_UNUSED)
+{
+	const struct ext_notify_action *act =
+		(const struct ext_notify_action *) action->context;
+	const struct ext_notify_recipient *recipients;
+	unsigned int count, i;
+
+	sieve_result_action_printf
+		( rpenv, "send (depricated) notification with method 'mailto':");
+
+	/* Print main method parameters */
+
+	sieve_result_printf
+		( rpenv, "    => importance    : %d\n", act->importance);
+
+	if ( act->message != NULL )
+		sieve_result_printf
+			( rpenv, "    => message       : %s\n", act->message);
+
+	if ( act->id != NULL )
+		sieve_result_printf
+			( rpenv, "    => id            : %s \n", act->id);
+
+	/* Print mailto: recipients */
+
+	sieve_result_printf
+		( rpenv, "    => recipients    :\n" );
+
+	recipients = array_get(&act->recipients, &count);
+	if ( count == 0 ) {
+		sieve_result_printf(rpenv, "       NONE, action has no effect\n");
+	} else {
+		for ( i = 0; i < count; i++ ) {
+			sieve_result_printf
+				( rpenv, "       + To: %s\n", recipients[i].full);
+		}
+	}
+
+	/* Finish output with an empty line */
+
+	sieve_result_printf(rpenv, "\n");
+}
+
+/* Result execution */
+
+static bool contains_8bit(const char *msg)
+{
+	const unsigned char *s = (const unsigned char *)msg;
+
+	for (; *s != '\0'; s++) {
+		if ((*s & 0x80) != 0)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+static bool act_notify_send
+(const struct sieve_action_exec_env *aenv,
+	const struct ext_notify_action *act)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const struct ext_notify_recipient *recipients;
+	void *smtp_handle;
+	unsigned int count, i;
+	FILE *f;
+	const char *outmsgid;
+
+	/* Get recipients */
+	recipients = array_get(&act->recipients, &count);
+	if ( count == 0  ) {
+		sieve_result_warning(aenv,
+			"notify action specifies no recipients; action has no effect");
+		return TRUE;
+	}
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv,
+			"notify action has no means to send mail");
+		return TRUE;
+	}
+
+	/* Send message to all recipients */
+	for ( i = 0; i < count; i++ ) {
+
+		if ( msgdata->return_path != NULL )
+			smtp_handle = senv->smtp_open(recipients[i].normalized,
+				senv->postmaster_address, &f);
+		else
+			smtp_handle = senv->smtp_open(recipients[i].normalized, NULL, &f);
+
+		outmsgid = sieve_message_get_new_id(senv);
+
+		rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+		rfc2822_header_field_write(f, "Message-ID", outmsgid);
+		rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+
+		/* Set importance */
+		switch ( act->importance ) {
+		case 1:
+			rfc2822_header_field_write(f, "X-Priority", "1 (Highest)");
+			rfc2822_header_field_write(f, "Importance", "High");
+			break;
+		case 3:
+			rfc2822_header_field_write(f, "X-Priority", "5 (Lowest)");
+			rfc2822_header_field_write(f, "Importance", "Low");
+			break;
+		case 2:
+		default:
+			rfc2822_header_field_write(f, "X-Priority", "3 (Normal)");
+			rfc2822_header_field_write(f, "Importance", "Normal");
+			break;
+		}
+
+		rfc2822_header_field_printf(f, "From", "%s",
+			t_strdup_printf("Postmaster <%s>", senv->postmaster_address));
+
+		rfc2822_header_field_printf(f, "To", "%s", recipients[i].full);
+
+		rfc2822_header_field_write(f, "Subject", "[SIEVE] New mail notification");
+
+		rfc2822_header_field_write(f, "Auto-Submitted", "auto-generated (notify)");
+		rfc2822_header_field_write(f, "Precedence", "bulk");
+
+		if (contains_8bit(act->message)) {
+			rfc2822_header_field_write(f, "MIME-Version", "1.0");
+			rfc2822_header_field_write(f,
+				"Content-Type", "text/plain; charset=UTF-8");
+			rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+		}
+
+		/* Generate message body */
+		fprintf(f, "\r\n");
+		fprintf(f, "%s\r\n", act->message);
+
+		if ( senv->smtp_close(smtp_handle) ) {
+			sieve_result_log(aenv,
+				"sent mail notification to <%s>",
+				str_sanitize(recipients[i].normalized, 80));
+		} else {
+			sieve_result_error(aenv,
+				"failed to send mail notification to <%s> "
+				"(refer to system log for more information)",
+				str_sanitize(recipients[i].normalized, 80));
+		}
+	}
+
+	return TRUE;
+}
+
+static bool act_notify_commit
+(const struct sieve_action *action, const struct sieve_action_exec_env *aenv,
+	void *tr_context ATTR_UNUSED, bool *keep ATTR_UNUSED)
+{
+	const struct ext_notify_action *act =
+		(const struct ext_notify_action *) action->context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const char *const *headers;
+
+	/* Is the message an automatic reply ? */
+	if ( mail_get_headers
+		(msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		const char *const *hdsp = headers;
+
+		/* Theoretically multiple headers could exist, so lets make sure */
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_result_log(aenv,
+					"not sending notification for auto-submitted message from <%s>",
+					str_sanitize(msgdata->return_path, 128));
+					return TRUE;
+			}
+			hdsp++;
+		}
+	}
+
+	return act_notify_send(aenv, act);
+}
+
+
+
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/notify/ext-notify-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/ext-notify-common.c
@@ -0,0 +1,307 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "rfc822-parser.h"
+#include "message-parser.h"
+#include "message-decoder.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-message.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-notify-common.h"
+
+#include <ctype.h>
+
+/*
+ * Importance argument
+ */
+
+static bool tag_importance_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def importance_low_tag = {
+	"low",
+	NULL,
+	tag_importance_validate,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def importance_normal_tag = {
+	"normal",
+	NULL,
+	tag_importance_validate,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def importance_high_tag = {
+	"high",
+	NULL,
+	tag_importance_validate,
+	NULL, NULL, NULL
+};
+
+static bool tag_importance_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	if ( sieve_argument_is(tag, importance_low_tag) )
+		sieve_ast_argument_number_substitute(tag, 3);
+	else if ( sieve_argument_is(tag, importance_normal_tag) )
+		sieve_ast_argument_number_substitute(tag, 2);
+	else
+		sieve_ast_argument_number_substitute(tag, 1);
+
+	tag->argument = sieve_argument_create
+		(tag->ast, &number_argument, tag->argument->ext, tag->argument->id_code);
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+void ext_notify_register_importance_tags
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	const struct sieve_extension *ext, unsigned int id_code)
+{
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &importance_low_tag, id_code);
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &importance_normal_tag, id_code);
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &importance_high_tag, id_code);
+}
+
+/*
+ * Body extraction
+ */
+
+/* FIXME: overlaps somewhat with body extension */
+
+struct ext_notify_message_context {
+	pool_t pool;
+	buffer_t *body_text;
+};
+
+static struct ext_notify_message_context *ext_notify_get_message_context
+(const struct sieve_extension *this_ext, struct sieve_message_context *msgctx)
+{
+	struct ext_notify_message_context *ctx;
+
+	/* Get message context (contains cached message body information) */
+	ctx = (struct ext_notify_message_context *)
+		sieve_message_context_extension_get(msgctx, this_ext);
+
+	/* Create it if it does not exist already */
+	if ( ctx == NULL ) {
+		pool_t pool = sieve_message_context_pool(msgctx);
+		ctx = p_new(pool, struct ext_notify_message_context, 1);
+		ctx->pool = pool;
+		ctx->body_text = NULL;
+
+		/* Register context */
+		sieve_message_context_extension_set
+			(msgctx, this_ext, (void *) ctx);
+	}
+
+	return ctx;
+}
+
+static bool _is_text_content(const struct message_header_line *hdr)
+{
+	struct rfc822_parser_context parser;
+	string_t *content_type;
+	const char *data;
+
+	/* Initialize parsing */
+	rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);
+	(void)rfc822_skip_lwsp(&parser);
+
+	/* Parse content type */
+	content_type = t_str_new(64);
+	if (rfc822_parse_content_type(&parser, content_type) < 0)
+		return "";
+
+	/* Content-type value must end here, otherwise it is invalid after all */
+	(void)rfc822_skip_lwsp(&parser);
+	if ( parser.data != parser.end && *parser.data != ';' )
+		return "";
+
+	/* Success */
+	data = str_c(content_type);
+	if ( strncmp(data, "text", 4) == 0 && data[4] == '/' ) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static buffer_t *cmd_notify_extract_body_text
+(const struct sieve_runtime_env *renv)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct ext_notify_message_context *mctx;
+	struct message_parser_ctx *parser;
+	struct message_decoder_context *decoder;
+	struct message_part *parts;
+	struct message_block block, decoded;
+	struct istream *input;
+	bool is_text, save_body;
+	int ret;
+
+	/* Return cached result if available */
+	mctx = ext_notify_get_message_context(this_ext, renv->msgctx);
+	if ( mctx->body_text != NULL ) {
+		return mctx->body_text;
+	}
+
+	/* Create buffer */
+	mctx->body_text = buffer_create_dynamic(mctx->pool, 1024*64);
+
+	/* Get the message stream */
+	if ( mail_get_stream(renv->msgdata->mail, NULL, NULL, &input) < 0 )
+		return FALSE;
+
+	/* Initialize body decoder */
+	decoder = message_decoder_init(FALSE);
+
+	parser = message_parser_init(mctx->pool, input, 0, 0);
+	is_text = TRUE;
+	while ( (ret = message_parser_parse_next_block(parser, &block)) > 0 ) {
+		if ( block.hdr != NULL || block.size == 0 ) {
+			/* Decode block */
+			(void)message_decoder_decode_next_block(decoder, &block, &decoded);
+
+			/* Check for end of headers */
+			if ( block.hdr == NULL ) {
+				save_body = is_text;
+				continue;
+			}
+
+			/* We're interested of only Content-Type: header */
+			if ( strcasecmp(block.hdr->name, "Content-Type" ) != 0)
+				continue;
+
+			/* Header can have folding whitespace. Acquire the full value before
+			 * continuing
+			 */
+			if ( block.hdr->continues ) {
+				block.hdr->use_full_value = TRUE;
+				continue;
+			}
+
+			/* Is it a text part? */
+			T_BEGIN {
+				is_text = _is_text_content(block.hdr);
+			} T_END;
+
+			continue;
+		}
+
+		/* Read text body */
+		if ( save_body ) {
+			(void)message_decoder_decode_next_block(decoder, &block, &decoded);
+			buffer_append(mctx->body_text, decoded.data, decoded.size);
+			is_text = TRUE;
+		}
+	}
+
+	/* Cleanup */
+	(void)message_parser_deinit(&parser, &parts);
+	message_decoder_deinit(&decoder);
+
+	/* Return status */
+	return mctx->body_text;
+}
+
+void ext_notify_construct_message
+(const struct sieve_runtime_env *renv, const char *msg_format,
+	string_t *out_msg)
+{
+	const struct sieve_message_data *msgdata = renv->msgdata;
+	const char *p;
+
+	if ( msg_format == NULL )
+		msg_format = "$from$: $subject$";
+
+	/* Scan message for substitutions */
+	p = msg_format;
+	while ( *p != '\0' ) {
+		const char *const *header;
+
+		if ( strncasecmp(p, "$from$", 6) == 0 ) {
+			p += 6;
+
+			/* Fetch sender from oriinal message */
+			if ( mail_get_headers_utf8(msgdata->mail, "from", &header) >= 0 )
+				 str_append(out_msg, header[0]);
+
+		} else if ( strncasecmp(p, "$env-from$", 10) == 0 ) {
+			p += 10;
+
+			if ( msgdata->return_path != NULL )
+				str_append(out_msg, msgdata->return_path);
+
+		} else if ( strncasecmp(p, "$subject$", 9) == 0 ) {
+			p += 9;
+
+			/* Fetch sender from oriinal message */
+			if ( mail_get_headers_utf8(msgdata->mail, "subject", &header) >= 0 )
+				 str_append(out_msg, header[0]);
+
+		} else if ( strncasecmp(p, "$text", 5) == 0
+			&& (p[5] == '[' || p[5] == '$') ) {
+			size_t num = 0;
+			const char *begin = p;
+			bool valid = TRUE;
+
+			p += 5;
+			if ( *p == '[' ) {
+				p += 1;
+
+				while ( i_isdigit(*p) ) {
+					num = num * 10 + (*p - '0');
+					p++;
+				}
+
+				if ( *p++ != ']' || *p++ != '$' ) {
+					str_append_n(out_msg, begin, p-begin);
+					valid = FALSE;
+				}
+			} else {
+				p += 1;
+			}
+
+			if ( valid ) {
+				size_t body_size;
+				const char *body_text = (const char *)
+					buffer_get_data(cmd_notify_extract_body_text(renv), &body_size);
+
+				if ( num > 0 && num < body_size)
+					str_append_n(out_msg, body_text, num);
+				else
+					str_append_n(out_msg, body_text, body_size);
+			}
+		} else {
+			size_t len;
+
+			/* Find next substitution */
+			len = strcspn(p + 1, "$") + 1;
+
+			/* Copy normal text */
+			str_append_n(out_msg, p, len);
+			p += len;
+		}
+  }
+}
Index: b/sieve/src/lib-sieve/plugins/notify/ext-notify-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/ext-notify-common.h
@@ -0,0 +1,65 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_NOTIFY_COMMON_H
+#define __EXT_NOTIFY_COMMON_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def notify_extension;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def cmd_notify_old;
+extern const struct sieve_command_def cmd_denotify;
+
+/*
+ * Arguments
+ */
+
+void ext_notify_register_importance_tags
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+		const struct sieve_extension *this_ext, unsigned int id_code);
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def notify_old_operation;
+extern const struct sieve_operation_def denotify_operation;
+
+enum ext_notify_opcode {
+	EXT_NOTIFY_OPERATION_NOTIFY,
+	EXT_NOTIFY_OPERATION_DENOTIFY,
+};
+
+/* Action context */
+
+struct ext_notify_recipient {
+	const char *full;
+	const char *normalized;
+};
+
+ARRAY_DEFINE_TYPE(recipients, struct ext_notify_recipient);
+
+struct ext_notify_action {
+	const char *id;
+	const char *message;
+	sieve_number_t importance;
+
+	ARRAY_TYPE(recipients) recipients;
+};
+
+/*
+ * Message construct
+ */
+
+void ext_notify_construct_message
+	(const struct sieve_runtime_env *renv, const char *msg_format,
+		string_t *out_msg);
+
+#endif /* __EXT_NOTIFY_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/notify/ext-notify-limits.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/ext-notify-limits.h
@@ -0,0 +1,10 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_NOTIFY_LIMITS_H
+#define __EXT_NOTIFY_LIMITS_H
+
+#define EXT_NOTIFY_MAX_RECIPIENTS  8
+#define EXT_NOTIFY_MAX_MESSAGE     256
+
+#endif /* __EXT_NOTIFY_LIMITS_H */
Index: b/sieve/src/lib-sieve/plugins/notify/ext-notify.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/notify/ext-notify.c
@@ -0,0 +1,108 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension notify
+ * ----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-ietf-sieve-notify-00.txt
+ * Implementation: deprecated; provided for backwards compatibility
+ * Status: deprecated
+ *
+ */
+
+/* FIXME: Currently the following CMUSieve features are not supported:
+ *
+ * (*) The $text$ substitution is not available for the :message argument.
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-notify-common.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation_def *ext_notify_operations[] = {
+	&notify_old_operation,
+	&denotify_operation
+};
+
+/*
+ * Extension
+ */
+
+static bool ext_notify_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def notify_extension = {
+	"notify",
+	NULL,
+	NULL,
+	ext_notify_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_notify_operations),
+	SIEVE_EXT_DEFINE_NO_OPERANDS,
+};
+
+/*
+ * Extension validation
+ */
+
+static bool ext_notify_validator_extension_validate
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr,
+		void *context, struct sieve_ast_argument *require_arg);
+
+const struct sieve_validator_extension notify_validator_extension = {
+	&notify_extension,
+	ext_notify_validator_extension_validate,
+	NULL
+};
+
+static bool ext_notify_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register validator extension to check for conflict with enotify */
+	sieve_validator_extension_register
+		(valdtr, ext, &notify_validator_extension, NULL);
+
+	/* Register new commands */
+	sieve_validator_register_command(valdtr, ext, &cmd_notify_old);
+	sieve_validator_register_command(valdtr, ext, &cmd_denotify);
+
+	return TRUE;
+}
+
+static bool ext_notify_validator_extension_validate
+(const struct sieve_extension *ext, struct sieve_validator *valdtr,
+	void *context ATTR_UNUSED, struct sieve_ast_argument *require_arg)
+{
+	const struct sieve_extension *ext_entfy;
+
+	if ( (ext_entfy=sieve_extension_get_by_name(ext->svinst, "enotify")) != NULL ) {
+
+		/* Check for conflict with enotify */
+		if ( sieve_validator_extension_loaded(valdtr, ext_entfy) ) {
+			sieve_argument_validate_error(valdtr, require_arg,
+				"the (deprecated) notify extension cannot be used "
+				"together with the enotify extension");
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/regex/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/regex/Makefile.am
@@ -0,0 +1,16 @@
+noinst_LTLIBRARIES = libsieve_ext_regex.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_regex_la_SOURCES = \
+	mcht-regex.c \
+	ext-regex-common.c \
+	ext-regex.c
+
+noinst_HEADERS = \
+	ext-regex-common.h
Index: b/sieve/src/lib-sieve/plugins/regex/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/regex/Makefile.in
@@ -0,0 +1,492 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/regex
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_regex_la_LIBADD =
+am_libsieve_ext_regex_la_OBJECTS = mcht-regex.lo ext-regex-common.lo \
+	ext-regex.lo
+libsieve_ext_regex_la_OBJECTS = $(am_libsieve_ext_regex_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_regex_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_regex_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_regex.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_regex_la_SOURCES = \
+	mcht-regex.c \
+	ext-regex-common.c \
+	ext-regex.c
+
+noinst_HEADERS = \
+	ext-regex-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/regex/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/regex/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_regex.la: $(libsieve_ext_regex_la_OBJECTS) $(libsieve_ext_regex_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_regex_la_OBJECTS) $(libsieve_ext_regex_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-regex-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-regex.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-regex.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/regex/ext-regex-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/regex/ext-regex-common.c
@@ -0,0 +1,23 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-match-types.h"
+
+#include "ext-regex-common.h"
+
+/*
+ * Regex match type operand
+ */
+
+static const struct sieve_extension_objects ext_match_types =
+    SIEVE_EXT_DEFINE_MATCH_TYPE(regex_match_type);
+
+const struct sieve_operand_def regex_match_type_operand = {
+    "regex match",
+    &regex_extension,
+    0,
+    &sieve_match_type_operand_class,
+    &ext_match_types
+};
+
Index: b/sieve/src/lib-sieve/plugins/regex/ext-regex-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/regex/ext-regex-common.h
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_REGEX_COMMON_H
+#define __EXT_REGEX_COMMON_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def regex_extension;
+
+/*
+ * Operand
+ */
+
+extern const struct sieve_operand_def regex_match_type_operand;
+
+/*
+ * Match type
+ */
+
+extern const struct sieve_match_type_def regex_match_type;
+
+#endif /* __EXT_REGEX_COMMON_H */
+
+
Index: b/sieve/src/lib-sieve/plugins/regex/ext-regex.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/regex/ext-regex.c
@@ -0,0 +1,66 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension regex
+ * ---------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-murchison-sieve-regex-07
+ * Implementation: full, but suboptimal
+ * Status: experimental, largely untested
+ *
+ * FIXME: Regular expressions are compiled during compilation and
+ * again during interpretation. This is suboptimal and should be
+ * changed. This requires dumping the compiled regex to the binary.
+ * Most likely, this will only be possible when we implement regular
+ * expressions ourselves.
+ *
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-regex-common.h"
+
+#include <sys/types.h>
+#include <regex.h>
+
+/*
+ * Extension
+ */
+
+static bool ext_regex_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *validator);
+
+const struct sieve_extension_def regex_extension = {
+	"regex",
+	NULL, NULL,
+	ext_regex_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(regex_match_type_operand)
+};
+
+static bool ext_regex_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	sieve_match_type_register(valdtr, ext, &regex_match_type);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/regex/mcht-regex.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/regex/mcht-regex.c
@@ -0,0 +1,323 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':regex'
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "array.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-match.h"
+
+#include "ext-regex-common.h"
+
+#include <sys/types.h>
+#include <regex.h>
+#include <ctype.h>
+
+/*
+ * Configuration
+ */
+
+#define MCHT_REGEX_MAX_SUBSTITUTIONS SIEVE_MAX_MATCH_VALUES
+
+/*
+ * Match type
+ */
+
+static bool mcht_regex_validate_context
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+    struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg);
+
+static void mcht_regex_match_init(struct sieve_match_context *mctx);
+static int mcht_regex_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+    	const char *key, size_t key_size, int key_index);
+static int mcht_regex_match_deinit(struct sieve_match_context *mctx);
+
+const struct sieve_match_type_def regex_match_type = {
+	SIEVE_OBJECT("regex", &regex_match_type_operand, 0),
+	TRUE, FALSE,
+	NULL,
+	mcht_regex_validate_context,
+	mcht_regex_match_init,
+	mcht_regex_match,
+	mcht_regex_match_deinit
+};
+
+/*
+ * Match type validation
+ */
+
+/* Wrapper around the regerror function for easy access */
+static const char *_regexp_error(regex_t *regexp, int errorcode)
+{
+	size_t errsize = regerror(errorcode, regexp, NULL, 0);
+
+	if ( errsize > 0 ) {
+		char *errbuf;
+
+		buffer_t *error_buf =
+			buffer_create_dynamic(pool_datastack_create(), errsize);
+		errbuf = buffer_get_space_unsafe(error_buf, 0, errsize);
+
+		errsize = regerror(errorcode, regexp, errbuf, errsize);
+
+		/* We don't want the error to start with a capital letter */
+		errbuf[0] = i_tolower(errbuf[0]);
+
+		buffer_append_space_unsafe(error_buf, errsize);
+
+		return str_c(error_buf);
+	}
+
+	return "";
+}
+
+static int mcht_regex_validate_regexp
+(struct sieve_validator *valdtr,
+	struct sieve_match_type_context *mtctx ATTR_UNUSED,
+	struct sieve_ast_argument *key, int cflags)
+{
+	int ret;
+	regex_t regexp;
+
+	if ( (ret=regcomp(&regexp, sieve_ast_argument_strc(key), cflags)) != 0 ) {
+		sieve_argument_validate_error(valdtr, key,
+			"invalid regular expression for regex match: %s",
+			_regexp_error(&regexp, ret));
+
+		regfree(&regexp);
+		return FALSE;
+	}
+
+	regfree(&regexp);
+	return TRUE;
+}
+
+struct _regex_key_context {
+	struct sieve_validator *valdtr;
+	struct sieve_match_type_context *mtctx;
+	int cflags;
+};
+
+static int mcht_regex_validate_key_argument
+(void *context, struct sieve_ast_argument *key)
+{
+	struct _regex_key_context *keyctx = (struct _regex_key_context *) context;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(key) ) {
+		sieve_argument_validate_error(keyctx->valdtr, key,
+			"this Sieve implementation currently only accepts a literal string "
+			"for a regular expression");
+		return FALSE;
+	}
+
+	return mcht_regex_validate_regexp
+		(keyctx->valdtr, keyctx->mtctx, key, keyctx->cflags);
+}
+
+static bool mcht_regex_validate_context
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg ATTR_UNUSED,
+	struct sieve_match_type_context *mtctx, struct sieve_ast_argument *key_arg)
+{
+	const struct sieve_comparator *cmp = mtctx->comparator;
+	int cflags = REG_EXTENDED | REG_NOSUB;
+	struct _regex_key_context keyctx;
+	struct sieve_ast_argument *kitem;
+
+	if ( cmp != NULL ) {
+		if ( sieve_comparator_is(cmp, i_ascii_casemap_comparator) )
+			cflags =  REG_EXTENDED | REG_NOSUB | REG_ICASE;
+		else if ( sieve_comparator_is(cmp, i_octet_comparator) )
+			cflags =  REG_EXTENDED | REG_NOSUB;
+		else {
+			sieve_argument_validate_error(valdtr, mtctx->argument,
+				"regex match type only supports "
+				"i;octet and i;ascii-casemap comparators" );
+			return FALSE;
+		}
+	}
+
+	/* Validate regular expression keys */
+
+	keyctx.valdtr = valdtr;
+	keyctx.mtctx = mtctx;
+	keyctx.cflags = cflags;
+
+	kitem = key_arg;
+	if ( !sieve_ast_stringlist_map(&kitem, (void *) &keyctx,
+		mcht_regex_validate_key_argument) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Match type implementation
+ */
+
+struct mcht_regex_context {
+	ARRAY_DEFINE(reg_expressions, regex_t);
+	int value_index;
+	regmatch_t *pmatch;
+	size_t nmatch;
+};
+
+static void mcht_regex_match_init
+(struct sieve_match_context *mctx)
+{
+	pool_t pool = mctx->pool;
+	struct mcht_regex_context *ctx;
+
+	/* Create context */
+	ctx = p_new(pool, struct mcht_regex_context, 1);
+	p_array_init(&ctx->reg_expressions, pool, 4);
+	ctx->value_index = -1;
+
+	/* Create storage for match values if match values are requested */
+	if ( sieve_match_values_are_enabled(mctx->interp) ) {
+		ctx->pmatch = p_new(pool, regmatch_t, MCHT_REGEX_MAX_SUBSTITUTIONS);
+		ctx->nmatch = MCHT_REGEX_MAX_SUBSTITUTIONS;
+	} else {
+		ctx->pmatch = NULL;
+		ctx->nmatch = 0;
+	}
+
+	/* Assign context */
+	mctx->data = (void *) ctx;
+}
+
+static regex_t *mcht_regex_get
+(struct mcht_regex_context *ctx,
+	const struct sieve_comparator *cmp,
+	const char *key, unsigned int key_index)
+{
+	int ret;
+	int cflags;
+	regex_t *regexp;
+
+	/* If this is the first matched value, the regexes are not compiled
+	 * yet.
+	 */
+	if ( ctx->value_index <= 0 ) {
+		/* Allocate space */
+		array_idx_clear(&ctx->reg_expressions, key_index);
+		regexp = array_idx_modifiable(&ctx->reg_expressions, key_index);
+
+		/* Configure case-sensitivity according to comparator */
+		if ( sieve_comparator_is(cmp, i_octet_comparator) )
+			cflags =  REG_EXTENDED;
+		else if ( sieve_comparator_is(cmp, i_ascii_casemap_comparator) )
+			cflags =  REG_EXTENDED | REG_ICASE;
+		else
+			return NULL; /* Not supported */
+
+		/* Indicate whether match values need to be produced */
+		if ( ctx->nmatch == 0 ) cflags |= REG_NOSUB;
+
+		/* Compile regular expression */
+		if ( (ret=regcomp(regexp, key, cflags)) != 0 ) {
+			/* FIXME: Do something useful, i.e. report error somewhere */
+			return NULL;
+		}
+	} else {
+		/* Get compiled regex from cache */
+		regexp = array_idx_modifiable(&ctx->reg_expressions, key_index);
+	}
+
+	return regexp;
+}
+
+static int mcht_regex_match
+(struct sieve_match_context *mctx,
+	const char *val, size_t val_size ATTR_UNUSED,
+	const char *key, size_t key_size ATTR_UNUSED, int key_index)
+{
+	struct mcht_regex_context *ctx = (struct mcht_regex_context *) mctx->data;
+	regex_t *regexp;
+
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	if ( key_index < 0 ) return FALSE;
+
+	if ( key_index == 0 ) ctx->value_index++;
+
+	/* Get compiled regex */
+	if ( (regexp=mcht_regex_get(ctx, mctx->comparator, key, key_index)) == NULL )
+		return FALSE;
+
+	/* Execute regex */
+	if ( regexec(regexp, val, ctx->nmatch, ctx->pmatch, 0) == 0 ) {
+
+		/* Handle match values if necessary */
+		if ( ctx->nmatch > 0 ) {
+			struct sieve_match_values *mvalues;
+			size_t i;
+			int skipped = 0;
+			string_t *subst = t_str_new(32);
+
+			/* Start new list of match values */
+			mvalues = sieve_match_values_start(mctx->interp);
+
+			i_assert( mvalues != NULL );
+
+			/* Add match values from regular expression */
+			for ( i = 0; i < ctx->nmatch; i++ ) {
+				str_truncate(subst, 0);
+
+				if ( ctx->pmatch[i].rm_so != -1 ) {
+					if ( skipped > 0 ) {
+						sieve_match_values_skip(mvalues, skipped);
+						skipped = 0;
+					}
+
+					str_append_n(subst, val + ctx->pmatch[i].rm_so,
+						ctx->pmatch[i].rm_eo - ctx->pmatch[i].rm_so);
+					sieve_match_values_add(mvalues, subst);
+				} else
+					skipped++;
+			}
+
+			/* Substitute the new match values */
+			sieve_match_values_commit(mctx->interp, &mvalues);
+		}
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+int mcht_regex_match_deinit
+(struct sieve_match_context *mctx)
+{
+	struct mcht_regex_context *ctx = (struct mcht_regex_context *) mctx->data;
+	regex_t *regexps;
+	unsigned int count, i;
+
+	/* Clean up compiled regular expressions */
+	regexps = array_get_modifiable(&ctx->reg_expressions, &count);
+	for ( i = 0; i < count; i++ ) {
+		regfree(&regexps[i]);
+	}
+
+	return FALSE;
+}
+
Index: b/sieve/src/lib-sieve/plugins/relational/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/Makefile.am
@@ -0,0 +1,17 @@
+noinst_LTLIBRARIES = libsieve_ext_relational.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_relational_la_SOURCES = \
+	ext-relational-common.c \
+	mcht-value.c \
+	mcht-count.c \
+	ext-relational.c
+
+noinst_HEADERS = \
+	ext-relational-common.h
Index: b/sieve/src/lib-sieve/plugins/relational/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/Makefile.in
@@ -0,0 +1,495 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/relational
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_relational_la_LIBADD =
+am_libsieve_ext_relational_la_OBJECTS = ext-relational-common.lo \
+	mcht-value.lo mcht-count.lo ext-relational.lo
+libsieve_ext_relational_la_OBJECTS =  \
+	$(am_libsieve_ext_relational_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_relational_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_relational_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_relational.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_relational_la_SOURCES = \
+	ext-relational-common.c \
+	mcht-value.c \
+	mcht-count.c \
+	ext-relational.c
+
+noinst_HEADERS = \
+	ext-relational-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/relational/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/relational/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_relational.la: $(libsieve_ext_relational_la_OBJECTS) $(libsieve_ext_relational_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_relational_la_OBJECTS) $(libsieve_ext_relational_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-relational-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-relational.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-count.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcht-value.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/relational/ext-relational-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/ext-relational-common.c
@@ -0,0 +1,166 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Syntax:
+ *   MATCH-TYPE =/ COUNT / VALUE
+ *   COUNT = ":count" relational-match
+ *   VALUE = ":value" relational-match
+ *   relational-match = DQUOTE ( "gt" / "ge" / "lt"
+ *                             / "le" / "eq" / "ne" ) DQUOTE
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Forward declarations
+ */
+
+const struct sieve_match_type_def *rel_match_types[];
+
+/*
+ * Validation
+ */
+
+bool mcht_relational_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_match_type_context *ctx)
+{
+	struct sieve_match_type *mcht;
+	enum relational_match rel_match = REL_MATCH_INVALID;
+	string_t *rel_match_ident;
+
+	/* Check syntax:
+	 *   relational-match = DQUOTE ( "gt" / "ge" / "lt"
+ 	 *                             / "le" / "eq" / "ne" ) DQUOTE
+ 	 *
+	 * So, actually this must be a constant string and it is implemented as such
+	 */
+
+	/* Did we get a string in the first place ? */
+	if ( (*arg)->type != SAAT_STRING ) {
+		sieve_argument_validate_error(valdtr, *arg,
+			"the :%s match-type requires a constant string argument being "
+			"one of \"gt\", \"ge\", \"lt\", \"le\", \"eq\" or \"ne\", "
+			"but %s was found",
+			sieve_match_type_name(ctx->match_type), sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+
+	/* Check the relational match id */
+
+	rel_match_ident = sieve_ast_argument_str(*arg);
+	if ( str_len(rel_match_ident) == 2 ) {
+		const char *rel_match_id = str_c(rel_match_ident);
+
+		switch ( rel_match_id[0] ) {
+		/* "gt" or "ge" */
+		case 'g':
+			switch ( rel_match_id[1] ) {
+			case 't':
+				rel_match = REL_MATCH_GREATER;
+				break;
+			case 'e':
+				rel_match = REL_MATCH_GREATER_EQUAL;
+				break;
+			default:
+				rel_match = REL_MATCH_INVALID;
+			}
+			break;
+		/* "lt" or "le" */
+		case 'l':
+			switch ( rel_match_id[1] ) {
+			case 't':
+				rel_match = REL_MATCH_LESS;
+				break;
+			case 'e':
+				rel_match = REL_MATCH_LESS_EQUAL;
+				break;
+			default:
+				rel_match = REL_MATCH_INVALID;
+			}
+			break;
+		/* "eq" */
+		case 'e':
+			if ( rel_match_id[1] == 'q' )
+				rel_match = REL_MATCH_EQUAL;
+			else
+				rel_match = REL_MATCH_INVALID;
+			break;
+		/* "ne" */
+		case 'n':
+			if ( rel_match_id[1] == 'e' )
+				rel_match = REL_MATCH_NOT_EQUAL;
+			else
+				rel_match = REL_MATCH_INVALID;
+			break;
+		/* invalid */
+		default:
+			rel_match = REL_MATCH_INVALID;
+		}
+	}
+
+	if ( rel_match >= REL_MATCH_INVALID ) {
+		sieve_argument_validate_error(valdtr, *arg,
+			"the :%s match-type requires a constant string argument being "
+			"one of \"gt\", \"ge\", \"lt\", \"le\", \"eq\" or \"ne\", "
+			"but \"%s\" was found",
+			sieve_match_type_name(ctx->match_type),
+			str_sanitize(str_c(rel_match_ident), 32));
+		return FALSE;
+	}
+
+	/* Delete argument */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Not used just yet */
+	ctx->ctx_data = (void *) rel_match;
+
+	/* Override the actual match type with a parameter-specific one
+	 * FIXME: ugly!
+	 */
+	mcht = p_new(sieve_ast_argument_pool(*arg), struct sieve_match_type, 1);
+	mcht->object.ext = ctx->match_type->object.ext;
+	SIEVE_OBJECT_SET_DEF(mcht, rel_match_types
+		[REL_MATCH_INDEX(ctx->match_type->object.def->code, rel_match)]);
+	ctx->match_type = mcht;
+
+	return TRUE;
+}
+
+/*
+ * Relational match-type operand
+ */
+
+const const struct sieve_match_type_def *rel_match_types[] = {
+    &rel_match_value_gt, &rel_match_value_ge, &rel_match_value_lt,
+    &rel_match_value_le, &rel_match_value_eq, &rel_match_value_ne,
+    &rel_match_count_gt, &rel_match_count_ge, &rel_match_count_lt,
+    &rel_match_count_le, &rel_match_count_eq, &rel_match_count_ne
+};
+
+static const struct sieve_extension_objects ext_match_types =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(rel_match_types);
+
+const struct sieve_operand_def rel_match_type_operand = {
+    "relational match",
+    &relational_extension,
+    0,
+    &sieve_match_type_operand_class,
+    &ext_match_types
+};
+
Index: b/sieve/src/lib-sieve/plugins/relational/ext-relational-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/ext-relational-common.h
@@ -0,0 +1,93 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_RELATIONAL_COMMON_H
+#define __EXT_RELATIONAL_COMMON_H
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+/*
+ * Types
+ */
+
+enum ext_relational_match_type {
+	RELATIONAL_VALUE,
+	RELATIONAL_COUNT
+};
+
+enum relational_match {
+	REL_MATCH_GREATER,
+	REL_MATCH_GREATER_EQUAL,
+	REL_MATCH_LESS,
+	REL_MATCH_LESS_EQUAL,
+	REL_MATCH_EQUAL,
+	REL_MATCH_NOT_EQUAL,
+	REL_MATCH_INVALID
+};
+
+#define REL_MATCH_INDEX(type, match) \
+	(type * REL_MATCH_INVALID + match)
+#define REL_MATCH_TYPE(index) \
+	(index / REL_MATCH_INVALID)
+#define REL_MATCH(index) \
+	(index % REL_MATCH_INVALID)
+
+/*
+ * Extension definitions
+ */
+
+extern const struct sieve_extension_def relational_extension;
+
+/*
+ * Match types
+ */
+
+/* Registered for validation */
+
+extern const struct sieve_match_type_def value_match_type;
+extern const struct sieve_match_type_def count_match_type;
+
+/* Used in byte code */
+
+extern const struct sieve_match_type_def rel_match_count_gt;
+extern const struct sieve_match_type_def rel_match_count_ge;
+extern const struct sieve_match_type_def rel_match_count_lt;
+extern const struct sieve_match_type_def rel_match_count_le;
+extern const struct sieve_match_type_def rel_match_count_eq;
+extern const struct sieve_match_type_def rel_match_count_ne;
+
+extern const struct sieve_match_type_def rel_match_value_gt;
+extern const struct sieve_match_type_def rel_match_value_ge;
+extern const struct sieve_match_type_def rel_match_value_lt;
+extern const struct sieve_match_type_def rel_match_value_le;
+extern const struct sieve_match_type_def rel_match_value_eq;
+extern const struct sieve_match_type_def rel_match_value_ne;
+
+/*
+ * Operand
+ */
+
+extern const struct sieve_operand_def rel_match_type_operand;
+
+
+/*
+ * Match type validation
+ */
+
+bool mcht_relational_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_match_type_context *ctx);
+
+/*
+ * Value match function (also used by :count)
+ */
+
+int mcht_value_match
+    (struct sieve_match_context *mctx, const char *val, size_t val_size,
+        const char *key, size_t key_size, int key_index);
+
+
+#endif /* __EXT_RELATIONAL_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/relational/ext-relational.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/ext-relational.c
@@ -0,0 +1,56 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension relational
+ * --------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 3431
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_relational_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def relational_extension = {
+	"relational",
+	NULL, NULL,
+	ext_relational_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(rel_match_type_operand)
+};
+
+static bool ext_relational_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	sieve_match_type_register(valdtr, ext, &value_match_type);
+	sieve_match_type_register(valdtr, ext, &count_match_type);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/relational/mcht-count.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/mcht-count.c
@@ -0,0 +1,136 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':count'
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-match.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Forward declarations
+ */
+
+static void mcht_count_match_init(struct sieve_match_context *mctx);
+static int mcht_count_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+		const char *key, size_t key_size, int key_index);
+static int mcht_count_match_deinit(struct sieve_match_context *mctx);
+
+/*
+ * Match-type objects
+ */
+
+const struct sieve_match_type_def count_match_type = {
+	SIEVE_OBJECT("count", &rel_match_type_operand, RELATIONAL_COUNT),
+	FALSE, FALSE,
+	mcht_relational_validate,
+	NULL, NULL, NULL, NULL
+};
+
+#define COUNT_MATCH_TYPE(name, rel_match)                     \
+const struct sieve_match_type_def rel_match_count_ ## name = {    \
+	SIEVE_OBJECT(                                             \
+		"count-" #name, &rel_match_type_operand,              \
+		REL_MATCH_INDEX(RELATIONAL_COUNT, rel_match)),        \
+	FALSE, FALSE,                                             \
+	NULL, NULL,                                               \
+	mcht_count_match_init,                                    \
+	mcht_count_match,                                         \
+	mcht_count_match_deinit                                   \
+}
+
+COUNT_MATCH_TYPE(gt, REL_MATCH_GREATER);
+COUNT_MATCH_TYPE(ge, REL_MATCH_GREATER_EQUAL);
+COUNT_MATCH_TYPE(lt, REL_MATCH_LESS);
+COUNT_MATCH_TYPE(le, REL_MATCH_LESS_EQUAL);
+COUNT_MATCH_TYPE(eq, REL_MATCH_EQUAL);
+COUNT_MATCH_TYPE(ne, REL_MATCH_NOT_EQUAL);
+
+/*
+ * Match-type implementation
+ */
+
+struct mcht_count_context {
+	unsigned int count;
+};
+
+static void mcht_count_match_init(struct sieve_match_context *mctx)
+{
+	struct mcht_count_context *cctx = p_new(mctx->pool, struct mcht_count_context, 1);
+
+	cctx->count = 0;
+	mctx->data = (void *) cctx;
+}
+
+static int mcht_count_match
+(struct sieve_match_context *mctx,
+	const char *val ATTR_UNUSED, size_t val_size ATTR_UNUSED,
+	const char *key ATTR_UNUSED, size_t key_size ATTR_UNUSED,
+	int key_index)
+{
+	if ( val == NULL )
+		return FALSE;
+
+	/* Count values */
+	if ( key_index == -1 ) {
+		struct mcht_count_context *cctx =
+			(struct mcht_count_context *) mctx->data;
+
+		cctx->count++;
+	}
+
+	return FALSE;
+}
+
+static int mcht_count_match_deinit(struct sieve_match_context *mctx)
+{
+	struct mcht_count_context *cctx =
+            (struct mcht_count_context *) mctx->data;
+	int key_index;
+	string_t *key_item;
+    sieve_coded_stringlist_reset(mctx->key_list);
+	bool ok = TRUE;
+
+	string_t *value = t_str_new(20);
+	str_printfa(value, "%d", cctx->count);
+
+    /* Match to all key values */
+    key_index = 0;
+    key_item = NULL;
+    while ( (ok=sieve_coded_stringlist_next_item(mctx->key_list, &key_item))
+		&& key_item != NULL )
+    {
+		int ret = mcht_value_match
+			(mctx, str_c(value), str_len(value), str_c(key_item),
+				str_len(key_item), key_index);
+
+		if ( ret > 0 )
+			return TRUE;
+
+		if ( ret < 0 )
+			return ret;
+
+        key_index++;
+    }
+
+	return ( ok ? FALSE : -1 );
+}
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/relational/mcht-value.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/relational/mcht-value.c
@@ -0,0 +1,92 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-match.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Match-type objects
+ */
+
+const struct sieve_match_type_def value_match_type = {
+	SIEVE_OBJECT("value", &rel_match_type_operand, RELATIONAL_VALUE),
+	TRUE, TRUE,
+	mcht_relational_validate,
+	NULL, NULL, NULL, NULL
+};
+
+#define VALUE_MATCH_TYPE(name, rel_match)                   \
+const struct sieve_match_type_def rel_match_value_ ## name = {  \
+	SIEVE_OBJECT(                                           \
+		"value-" #name, &rel_match_type_operand,            \
+		REL_MATCH_INDEX(RELATIONAL_VALUE, rel_match)),      \
+	TRUE, TRUE,                                             \
+	NULL, NULL, NULL,                                       \
+	mcht_value_match,                                       \
+	NULL                                                    \
+}
+
+VALUE_MATCH_TYPE(gt, REL_MATCH_GREATER);
+VALUE_MATCH_TYPE(ge, REL_MATCH_GREATER_EQUAL);
+VALUE_MATCH_TYPE(lt, REL_MATCH_LESS);
+VALUE_MATCH_TYPE(le, REL_MATCH_LESS_EQUAL);
+VALUE_MATCH_TYPE(eq, REL_MATCH_EQUAL);
+VALUE_MATCH_TYPE(ne, REL_MATCH_NOT_EQUAL);
+
+/*
+ * Match-type implementation
+ */
+
+int mcht_value_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size,
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_match_type *mtch = mctx->match_type;
+	unsigned int rel_match = REL_MATCH(mtch->object.def->code);
+	int cmp_result;
+
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	cmp_result = mctx->comparator->def->
+		compare(mctx->comparator, val, val_size, key, key_size);
+
+	switch ( rel_match ) {
+	case REL_MATCH_GREATER:
+		return ( cmp_result > 0 );
+	case REL_MATCH_GREATER_EQUAL:
+		return ( cmp_result >= 0 );
+	case REL_MATCH_LESS:
+		return ( cmp_result < 0 );
+	case REL_MATCH_LESS_EQUAL:
+		return ( cmp_result <= 0 );
+	case REL_MATCH_EQUAL:
+		return ( cmp_result == 0 );
+	case REL_MATCH_NOT_EQUAL:
+		return ( cmp_result != 0 );
+	case REL_MATCH_INVALID:
+ 	default:
+		break;
+	}
+
+	return FALSE;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/subaddress/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/subaddress/Makefile.am
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_subaddress.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_subaddress_la_SOURCES = \
+	ext-subaddress.c
Index: b/sieve/src/lib-sieve/plugins/subaddress/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/subaddress/Makefile.in
@@ -0,0 +1,482 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/subaddress
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_subaddress_la_LIBADD =
+am_libsieve_ext_subaddress_la_OBJECTS = ext-subaddress.lo
+libsieve_ext_subaddress_la_OBJECTS =  \
+	$(am_libsieve_ext_subaddress_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_subaddress_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_subaddress_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_subaddress.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+libsieve_ext_subaddress_la_SOURCES = \
+	ext-subaddress.c
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/subaddress/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/subaddress/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_subaddress.la: $(libsieve_ext_subaddress_la_OBJECTS) $(libsieve_ext_subaddress_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_subaddress_la_OBJECTS) $(libsieve_ext_subaddress_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-subaddress.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c
@@ -0,0 +1,190 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension subaddress
+ * --------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 3598
+ * Implementation: full, but not fully configurable
+ * Status: experimental
+ *
+ */
+
+#include "sieve-common.h"
+
+#include "sieve-settings.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Configuration
+ */
+
+#define SUBADDRESS_DEFAULT_DELIM "+"
+
+struct ext_subaddress_config {
+	char *delimiter;
+};
+
+/*
+ * Forward declarations
+ */
+
+const struct sieve_address_part_def user_address_part;
+const struct sieve_address_part_def detail_address_part;
+
+static struct sieve_operand_def subaddress_operand;
+
+/*
+ * Extension
+ */
+
+static bool ext_subaddress_load
+	(const struct sieve_extension *ext, void **context);
+static void ext_subaddress_unload
+	(const struct sieve_extension *ext);
+static bool ext_subaddress_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *validator);
+
+const struct sieve_extension_def subaddress_extension = {
+	"subaddress",
+	ext_subaddress_load,
+	ext_subaddress_unload,
+	ext_subaddress_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(subaddress_operand)
+};
+
+static bool ext_subaddress_load
+(const struct sieve_extension *ext, void **context)
+{
+	struct ext_subaddress_config *config;
+	const char *delim = sieve_get_setting(ext->svinst, "sieve_subaddress_sep");
+
+	/* Fallback to Dovecot setting */
+	if ( delim == NULL )
+		delim = sieve_get_setting(ext->svinst, "recipient_delimiter");
+
+	/* Fallback to default */
+	if ( delim == NULL )
+		delim = SUBADDRESS_DEFAULT_DELIM;
+
+	config = i_new(struct ext_subaddress_config, 1);
+	config->delimiter = i_strdup(delim);
+
+	*context = (void *) config;
+
+	return TRUE;
+}
+
+static void ext_subaddress_unload
+(const struct sieve_extension *ext)
+{
+	struct ext_subaddress_config *config =
+		(struct ext_subaddress_config *) ext->context;
+
+	i_free(config->delimiter);
+	i_free(config);
+}
+
+static bool ext_subaddress_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator)
+{
+	sieve_address_part_register(validator, ext, &user_address_part);
+	sieve_address_part_register(validator, ext, &detail_address_part);
+
+	return TRUE;
+}
+
+/*
+ * Address parts
+ */
+
+enum ext_subaddress_address_part {
+  SUBADDRESS_USER,
+  SUBADDRESS_DETAIL
+};
+
+/* Forward declarations */
+
+static const char *subaddress_user_extract_from
+	(const struct sieve_address_part *addrp, const struct sieve_address *address);
+static const char *subaddress_detail_extract_from
+	(const struct sieve_address_part *addrp, const struct sieve_address *address);
+
+/* Address part objects */
+
+const struct sieve_address_part_def user_address_part = {
+	SIEVE_OBJECT("user", &subaddress_operand, SUBADDRESS_USER),
+	subaddress_user_extract_from
+};
+
+const struct sieve_address_part_def detail_address_part = {
+	SIEVE_OBJECT("detail", &subaddress_operand, SUBADDRESS_DETAIL),
+	subaddress_detail_extract_from
+};
+
+/* Address part implementation */
+
+static const char *subaddress_user_extract_from
+(const struct sieve_address_part *addrp, const struct sieve_address *address)
+{
+	struct ext_subaddress_config *config =
+		(struct ext_subaddress_config *) addrp->object.ext->context;
+	const char *delim;
+
+	delim = strstr(address->local_part, config->delimiter);
+
+	if ( delim == NULL ) return address->local_part;
+
+	return t_strdup_until(address->local_part, delim);
+}
+
+static const char *subaddress_detail_extract_from
+(const struct sieve_address_part *addrp, const struct sieve_address *address)
+{
+	struct ext_subaddress_config *config =
+		(struct ext_subaddress_config *) addrp->object.ext->context;
+	const char *delim;
+
+	if ( (delim=strstr(address->local_part, config->delimiter)) == NULL )
+		return NULL;
+
+	delim += strlen(config->delimiter);
+
+	/* Just to be sure */
+	if ( delim > (address->local_part + strlen(address->local_part)) )
+		return NULL;
+
+	return delim;
+}
+
+/*
+ * Operand
+ */
+
+const struct sieve_address_part_def *ext_subaddress_parts[] = {
+	&user_address_part, &detail_address_part
+};
+
+static const struct sieve_extension_objects ext_address_parts =
+	SIEVE_EXT_DEFINE_ADDRESS_PARTS(ext_subaddress_parts);
+
+static struct sieve_operand_def subaddress_operand = {
+	"address-part",
+	&subaddress_extension, 0,
+	&sieve_address_part_operand_class,
+	&ext_address_parts
+};
+
Index: b/sieve/src/lib-sieve/plugins/vacation/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/vacation/Makefile.am
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_vacation.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-vacation.c
+
+libsieve_ext_vacation_la_SOURCES = \
+	$(cmds) \
+	ext-vacation.c
+
+noinst_HEADERS = \
+	ext-vacation-common.h
+
Index: b/sieve/src/lib-sieve/plugins/vacation/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/vacation/Makefile.in
@@ -0,0 +1,494 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/vacation
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_vacation_la_LIBADD =
+am__objects_1 = cmd-vacation.lo
+am_libsieve_ext_vacation_la_OBJECTS = $(am__objects_1) ext-vacation.lo
+libsieve_ext_vacation_la_OBJECTS =  \
+	$(am_libsieve_ext_vacation_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_vacation_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_vacation_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_vacation.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-vacation.c
+
+libsieve_ext_vacation_la_SOURCES = \
+	$(cmds) \
+	ext-vacation.c
+
+noinst_HEADERS = \
+	ext-vacation-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/vacation/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/vacation/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_vacation.la: $(libsieve_ext_vacation_la_OBJECTS) $(libsieve_ext_vacation_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_vacation_la_OBJECTS) $(libsieve_ext_vacation_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-vacation.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-vacation.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/vacation/cmd-vacation.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/vacation/cmd-vacation.c
@@ -0,0 +1,1127 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "md5.h"
+#include "hostpid.h"
+#include "str-sanitize.h"
+#include "message-address.h"
+#include "message-date.h"
+#include "ioloop.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+#include "ext-vacation-common.h"
+
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_argument_def vacation_days_tag;
+static const struct sieve_argument_def vacation_subject_tag;
+static const struct sieve_argument_def vacation_from_tag;
+static const struct sieve_argument_def vacation_addresses_tag;
+static const struct sieve_argument_def vacation_mime_tag;
+static const struct sieve_argument_def vacation_handle_tag;
+
+/*
+ * Vacation command
+ *
+ * Syntax:
+ *    vacation [":days" number] [":subject" string]
+ *                 [":from" string] [":addresses" string-list]
+ *                 [":mime"] [":handle" string] <reason: string>
+ */
+
+static bool cmd_vacation_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_vacation_pre_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_vacation_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_vacation_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def vacation_command = {
+	"vacation",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	cmd_vacation_registered,
+	cmd_vacation_pre_validate,
+	cmd_vacation_validate,
+	cmd_vacation_generate,
+	NULL
+};
+
+/*
+ * Vacation command tags
+ */
+
+/* Forward declarations */
+
+static bool cmd_vacation_validate_number_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_vacation_validate_string_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_vacation_validate_stringlist_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_vacation_validate_mime_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument_def vacation_days_tag = {
+	"days",
+	NULL,
+	cmd_vacation_validate_number_tag,
+	NULL, NULL, NULL,
+};
+
+static const struct sieve_argument_def vacation_subject_tag = {
+	"subject",
+	NULL,
+	cmd_vacation_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def vacation_from_tag = {
+	"from",
+	NULL,
+	cmd_vacation_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def vacation_addresses_tag = {
+	"addresses",
+	NULL,
+	cmd_vacation_validate_stringlist_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def vacation_mime_tag = {
+	"mime",
+	NULL,
+	cmd_vacation_validate_mime_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def vacation_handle_tag = {
+	"handle",
+	NULL,
+	cmd_vacation_validate_string_tag,
+	NULL, NULL, NULL
+};
+
+/* Codes for optional arguments */
+
+enum cmd_vacation_optional {
+	OPT_END,
+	OPT_DAYS,
+	OPT_SUBJECT,
+	OPT_FROM,
+	OPT_ADDRESSES,
+	OPT_MIME
+};
+
+/*
+ * Vacation operation
+ */
+
+static bool ext_vacation_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_vacation_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def vacation_operation = {
+	"VACATION",
+	&vacation_extension,
+	0,
+	ext_vacation_operation_dump,
+	ext_vacation_operation_execute
+};
+
+/*
+ * Vacation action
+ */
+
+/* Forward declarations */
+
+static int act_vacation_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+int act_vacation_check_conflict
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+static void act_vacation_print
+	(const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+static bool act_vacation_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv,
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action_def act_vacation = {
+	"vacation",
+	SIEVE_ACTFLAG_SENDS_RESPONSE,
+	NULL,
+	act_vacation_check_duplicate,
+	act_vacation_check_conflict,
+	act_vacation_print,
+	NULL, NULL,
+	act_vacation_commit,
+	NULL
+};
+
+/* Action context information */
+
+struct act_vacation_context {
+	const char *reason;
+
+	sieve_number_t days;
+	const char *subject;
+	const char *handle;
+	bool mime;
+	const char *from;
+	const char *from_normalized;
+	const char *const *addresses;
+};
+
+/*
+ * Command validation context
+ */
+
+struct cmd_vacation_context_data {
+	string_t *from;
+	string_t *subject;
+
+	bool mime;
+
+	string_t *handle;
+};
+
+/*
+ * Tag validation
+ */
+
+static bool cmd_vacation_validate_number_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :days number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Enforce :days > 0 */
+	if ( sieve_ast_argument_number(*arg) == 0 ) {
+		sieve_ast_argument_number_set(*arg, 1);
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_string_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_vacation_context_data *ctx_data =
+		(struct cmd_vacation_context_data *) cmd->data;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :subject string
+	 *   :from string
+	 *   :handle string
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( sieve_argument_is(tag, vacation_from_tag) ) {
+		if ( sieve_argument_is_string_literal(*arg) ) {
+			string_t *address = sieve_ast_argument_str(*arg);
+			const char *error;
+	 		bool result;
+
+	 		T_BEGIN {
+	 			result = sieve_address_validate(address, &error);
+
+				if ( !result ) {
+					sieve_argument_validate_error(valdtr, *arg,
+						"specified :from address '%s' is invalid for vacation action: %s",
+						str_sanitize(str_c(address), 128), error);
+				}
+			} T_END;
+
+			if ( !result )
+				return FALSE;
+		}
+
+		ctx_data->from = sieve_ast_argument_str(*arg);
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+
+	} else if ( sieve_argument_is(tag, vacation_subject_tag) ) {
+		ctx_data->subject = sieve_ast_argument_str(*arg);
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+
+	} else if ( sieve_argument_is(tag, vacation_handle_tag) ) {
+		ctx_data->handle = sieve_ast_argument_str(*arg);
+
+		/* Detach optional argument (emitted as mandatory) */
+		*arg = sieve_ast_arguments_detach(*arg,1);
+	}
+
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_stringlist_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :addresses string-list
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_mime_tag
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_vacation_context_data *ctx_data =
+		(struct cmd_vacation_context_data *) cmd->data;
+
+	ctx_data->mime = TRUE;
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Command registration
+ */
+
+static bool cmd_vacation_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &vacation_days_tag, OPT_DAYS);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &vacation_subject_tag, OPT_SUBJECT);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &vacation_from_tag, OPT_FROM);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &vacation_addresses_tag, OPT_ADDRESSES);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &vacation_mime_tag, OPT_MIME);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &vacation_handle_tag, 0);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_vacation_pre_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_command *cmd)
+{
+	struct cmd_vacation_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd),
+		struct cmd_vacation_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static const char _handle_empty_subject[] = "<default-subject>";
+static const char _handle_empty_from[] = "<default-from>";
+static const char _handle_mime_enabled[] = "<MIME>";
+static const char _handle_mime_disabled[] = "<NO-MIME>";
+
+static bool cmd_vacation_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_vacation_context_data *ctx_data =
+		(struct cmd_vacation_context_data *) cmd->data;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, arg, FALSE) )
+		return FALSE;
+
+	/* Construct handle if not set explicitly */
+	if ( ctx_data->handle == NULL ) {
+		string_t *reason = sieve_ast_argument_str(arg);
+		unsigned int size = str_len(reason);
+
+		/* Precalculate the size of it all */
+		size += ctx_data->subject == NULL ?
+			sizeof(_handle_empty_subject) - 1 : str_len(ctx_data->subject);
+		size += ctx_data->from == NULL ?
+			sizeof(_handle_empty_from) - 1 : str_len(ctx_data->from);
+		size += ctx_data->mime ?
+			sizeof(_handle_mime_enabled) - 1 : sizeof(_handle_mime_disabled) - 1;
+
+		/* Construct the string */
+		ctx_data->handle = str_new(sieve_command_pool(cmd), size);
+		str_append_str(ctx_data->handle, reason);
+
+		if ( ctx_data->subject != NULL )
+			str_append_str(ctx_data->handle, ctx_data->subject);
+		else
+			str_append(ctx_data->handle, _handle_empty_subject);
+
+		if ( ctx_data->from != NULL )
+			str_append_str(ctx_data->handle, ctx_data->from);
+		else
+			str_append(ctx_data->handle, _handle_empty_from);
+
+		str_append(ctx_data->handle,
+			ctx_data->mime ? _handle_mime_enabled : _handle_mime_disabled );
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_vacation_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct cmd_vacation_context_data *ctx_data =
+		(struct cmd_vacation_context_data *) cmd->data;
+
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &vacation_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(cmd));
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	/* FIXME: this will not allow the handle to be a variable */
+	sieve_opr_string_emit(cgenv->sbin, ctx_data->handle);
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool ext_vacation_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 1;
+
+	sieve_code_dumpf(denv, "VACATION");
+	sieve_code_descend(denv);
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_DAYS:
+				if ( !sieve_opr_number_dump(denv, address, "days") )
+					return FALSE;
+				break;
+			case OPT_SUBJECT:
+				if ( !sieve_opr_string_dump(denv, address, "subject") )
+					return FALSE;
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_dump(denv, address, "from") )
+					return FALSE;
+				break;
+			case OPT_ADDRESSES:
+				if ( !sieve_opr_stringlist_dump(denv, address, "addresses") )
+					return FALSE;
+				break;
+			case OPT_MIME:
+				sieve_code_dumpf(denv, "mime");
+				break;
+
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	/* Dump reason and handle operands */
+	return
+		sieve_opr_string_dump(denv, address, "reason") &&
+		sieve_opr_string_dump(denv, address, "handle");
+}
+
+/*
+ * Code execution
+ */
+
+static int ext_vacation_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_extension *this_ext = renv->oprtn.ext;
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_vacation_context *act;
+	pool_t pool;
+	int opt_code = 1;
+	sieve_number_t days = 7;
+	bool mime = FALSE;
+	struct sieve_coded_stringlist *addresses = NULL;
+	string_t *reason, *subject = NULL, *from = NULL, *handle = NULL;
+	unsigned int source_line;
+	const char *from_normalized = NULL;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands */
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_DAYS:
+				if ( !sieve_opr_number_read(renv, address, &days) ) {
+					sieve_runtime_trace_error(renv,
+						"invalid days operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+
+				/* Enforce days > 0 (just to be sure) */
+				if ( days == 0 )
+					days = 1;
+				break;
+			case OPT_SUBJECT:
+				if ( !sieve_opr_string_read(renv, address, &subject) ) {
+					sieve_runtime_trace_error(renv,
+						"invalid subject operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_read(renv, address, &from) ) {
+					sieve_runtime_trace_error(renv,
+						"invalid from address operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_ADDRESSES:
+				if ( (addresses=sieve_opr_stringlist_read(renv, address))
+					== NULL ) {
+					sieve_runtime_trace_error(renv,
+						"invalid addresses operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MIME:
+				mime = TRUE;
+				break;
+			default:
+				sieve_runtime_trace_error(renv,
+					"unknown optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+
+	/* Reason operand */
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Handle operand */
+	if ( !sieve_opr_string_read(renv, address, &handle) ) {
+		sieve_runtime_trace_error(renv, "invalid handle operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "VACATION action");
+
+	/* Check and normalize :from address */
+	if ( from != NULL ) {
+		const char *error;
+
+		from_normalized = sieve_address_normalize(from, &error);
+
+		if ( from_normalized == NULL) {
+			sieve_runtime_error(renv,
+				sieve_error_script_location(renv->script, source_line),
+				"specified :from address '%s' is invalid for vacation action: %s",
+				str_sanitize(str_c(from), 128), error);
+   		}
+	}
+
+	/* Add vacation action to the result */
+
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_vacation_context, 1);
+	act->reason = p_strdup(pool, str_c(reason));
+	act->handle = p_strdup(pool, str_c(handle));
+	act->days = days;
+	act->mime = mime;
+	if ( subject != NULL )
+		act->subject = p_strdup(pool, str_c(subject));
+	if ( from != NULL ) {
+		act->from = p_strdup(pool, str_c(from));
+		act->from_normalized = p_strdup(pool, from_normalized);
+	}
+
+	/* Normalize all addresses */
+	if ( addresses != NULL ) {
+		ARRAY_DEFINE(norm_addresses, const char *);
+		string_t *raw_address;
+		bool result = FALSE;
+
+		sieve_coded_stringlist_reset(addresses);
+
+		p_array_init(&norm_addresses, pool, 4);
+
+		raw_address = NULL;
+		while ( (result=sieve_coded_stringlist_next_item(addresses, &raw_address))
+			&& raw_address != NULL ) {
+			const char *error;
+			const char *addr_norm = sieve_address_normalize(raw_address, &error);
+
+			if ( addr_norm != NULL ) {
+				addr_norm = p_strdup(pool, addr_norm);
+
+				array_append(&norm_addresses, &addr_norm, 1);
+			} else {
+				/* FIXME: report proper warning */
+			}
+		}
+
+		if ( !result ) {
+			sieve_runtime_trace_error(renv, "invalid addresses stringlist");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		(void)array_append_space(&norm_addresses);
+		act->addresses = array_idx(&norm_addresses, 0);
+	}
+
+	return ( sieve_result_add_action
+		(renv, this_ext, &act_vacation, slist, source_line, (void *) act, 0) >= 0 );
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_vacation_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action *act,
+	const struct sieve_action *act_other)
+{
+	if ( !act_other->executed ) {
+		sieve_runtime_error(renv, act->location,
+			"duplicate vacation action not allowed "
+			"(previously triggered one was here: %s)", act_other->location);
+		return -1;
+	}
+
+	/* Not an error if executed in preceeding script */
+	return 1;
+}
+
+int act_vacation_check_conflict
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *act,
+	const struct sieve_action *act_other)
+{
+	if ( (act_other->def->flags & SIEVE_ACTFLAG_SENDS_RESPONSE) > 0 ) {
+		if ( !act_other->executed && !act->executed) {
+			sieve_runtime_error(renv, act->location,
+				"vacation action conflicts with other action: "
+				"the %s action (%s) also sends a response back to the sender",
+				act_other->def->name, act_other->location);
+			return -1;
+		} else {
+			/* Not an error if executed in preceeding script */
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/* Result printing */
+
+static void act_vacation_print
+(const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_result_print_env *rpenv, bool *keep ATTR_UNUSED)
+{
+	struct act_vacation_context *ctx =
+		(struct act_vacation_context *) action->context;
+
+	sieve_result_action_printf( rpenv, "send vacation message:");
+	sieve_result_printf(rpenv, "    => days   : %d\n", ctx->days);
+	if ( ctx->subject != NULL )
+		sieve_result_printf(rpenv, "    => subject: %s\n", ctx->subject);
+	if ( ctx->from != NULL )
+		sieve_result_printf(rpenv, "    => from   : %s\n", ctx->from);
+	if ( ctx->handle != NULL )
+		sieve_result_printf(rpenv, "    => handle : %s\n", ctx->handle);
+	sieve_result_printf(rpenv, "\nSTART MESSAGE\n%s\nEND MESSAGE\n", ctx->reason);
+}
+
+/* Result execution */
+
+/* Headers known to be associated with mailing lists
+ */
+static const char * const _list_headers[] = {
+	"list-id",
+	"list-owner",
+	"list-subscribe",
+	"list-post",
+	"list-unsubscribe",
+	"list-help",
+	"list-archive",
+	NULL
+};
+
+/* Headers that should be searched for the user's own mail address(es)
+ */
+
+static const char * const _my_address_headers[] = {
+	"to",
+	"cc",
+	"bcc",
+	"resent-to",
+	"resent-cc",
+	"resent-bcc",
+	NULL
+};
+
+static inline bool _is_system_address(const char *address)
+{
+	if ( strncasecmp(address, "MAILER-DAEMON", 13) == 0 )
+		return TRUE;
+
+	if ( strncasecmp(address, "LISTSERV", 8) == 0 )
+		return TRUE;
+
+	if ( strncasecmp(address, "majordomo", 9) == 0 )
+		return TRUE;
+
+	if ( strstr(address, "-request@") != NULL )
+		return TRUE;
+
+	if ( strncmp(address, "owner-", 6) == 0 )
+		return TRUE;
+
+	return FALSE;
+}
+
+static inline bool _contains_my_address
+	(const char * const *headers, const char *my_address)
+{
+	const char *const *hdsp = headers;
+	bool result = FALSE;
+
+	while ( *hdsp != NULL && !result ) {
+		const struct message_address *addr;
+
+		T_BEGIN {
+
+			addr = message_address_parse
+				(pool_datastack_create(), (const unsigned char *) *hdsp,
+					strlen(*hdsp), 256, FALSE);
+
+			while ( addr != NULL && !result ) {
+				if (addr->domain != NULL) {
+					const char *hdr_address;
+
+					i_assert(addr->mailbox != NULL);
+
+					hdr_address = t_strconcat(addr->mailbox, "@", addr->domain, NULL);
+					if ( sieve_address_compare(hdr_address, my_address, TRUE) == 0 ) {
+						result = TRUE;
+						break;
+					}
+				}
+
+				addr = addr->next;
+			}
+		} T_END;
+
+		hdsp++;
+	}
+
+	return result;
+}
+
+static bool act_vacation_send
+(const struct sieve_action_exec_env *aenv, struct act_vacation_context *ctx,
+	const char *sender, const char *recipient)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	void *smtp_handle;
+	FILE *f;
+ 	const char *outmsgid;
+ 	const char *const *headers;
+	int ret;
+
+	/* Check smpt functions just to be sure */
+
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "vacation action has no means to send mail");
+		return TRUE;
+	}
+
+	/* Open smtp session */
+
+	smtp_handle = senv->smtp_open(sender, NULL, &f);
+	outmsgid = sieve_message_get_new_id(senv);
+
+	/* Produce a proper reply */
+
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+	rfc2822_header_field_write(f, "Message-ID", outmsgid);
+	rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+
+	if ( ctx->from != NULL && *(ctx->from) != '\0' )
+		rfc2822_header_field_utf8_printf(f, "From", "%s", ctx->from);
+	else if ( recipient != NULL )
+		rfc2822_header_field_printf(f, "From", "<%s>", recipient);
+	else
+		rfc2822_header_field_printf(f, "From", "Postmaster <%s>", senv->postmaster_address);
+
+	/* FIXME: If From header of message has same address, we should use that in
+	 * stead properly include the phrase part.
+	 */
+	rfc2822_header_field_printf(f, "To", "<%s>", sender);
+
+	rfc2822_header_field_utf8_printf(f, "Subject", "%s",
+		str_sanitize(ctx->subject, 256));
+
+	/* Compose proper in-reply-to and references headers */
+
+	ret = mail_get_headers
+		(aenv->msgdata->mail, "references", &headers);
+
+	if ( msgdata->id != NULL ) {
+		rfc2822_header_field_write(f, "In-Reply-To", msgdata->id);
+
+		if ( ret >= 0 && headers[0] != NULL )
+			rfc2822_header_field_write
+				(f, "References", t_strconcat(headers[0], " ", msgdata->id, NULL));
+		else
+			rfc2822_header_field_write(f, "References", msgdata->id);
+	} else if ( ret >= 0 && headers[0] != NULL ) {
+		rfc2822_header_field_write(f, "References", headers[0]);
+	}
+
+	rfc2822_header_field_write(f, "Auto-Submitted", "auto-replied (vacation)");
+	rfc2822_header_field_write(f, "Precedence", "bulk");
+
+	rfc2822_header_field_write(f, "MIME-Version", "1.0");
+
+	if ( !ctx->mime ) {
+		rfc2822_header_field_write(f, "Content-Type", "text/plain; charset=utf-8");
+		rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+		fprintf(f, "\r\n");
+	}
+
+	fprintf(f, "%s\r\n", ctx->reason);
+
+	/* Close smtp session */
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv,
+			"failed to send vacation response to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(sender, 128));
+		return TRUE;
+	}
+
+	return TRUE;
+}
+
+static void act_vacation_hash
+(struct act_vacation_context *vctx, const char *sender, unsigned char hash_r[])
+{
+	const char *rpath = t_str_lcase(sender);
+	struct md5_context ctx;
+
+	md5_init(&ctx);
+	md5_update(&ctx, rpath, strlen(rpath));
+
+	md5_update(&ctx, vctx->handle, strlen(vctx->handle));
+
+	md5_final(&ctx, hash_r);
+}
+
+static bool act_vacation_commit
+(const struct sieve_action *action, const struct sieve_action_exec_env *aenv,
+	void *tr_context ATTR_UNUSED, bool *keep ATTR_UNUSED)
+{
+	const char *const *hdsp;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	struct act_vacation_context *ctx =
+		(struct act_vacation_context *) action->context;
+	unsigned char dupl_hash[MD5_RESULTLEN];
+	const char *const *headers;
+	const char *sender = sieve_message_get_sender(aenv->msgctx);
+	const char *recipient = sieve_message_get_recipient(aenv->msgctx);
+	pool_t pool;
+
+	/* Is the recipient unset?
+	 */
+	if ( recipient == NULL ) {
+		sieve_result_warning(aenv, "vacation action aborted: envelope recipient is <>");
+		return TRUE;
+	}
+
+	/* Is the return path unset ?
+	 */
+	if ( sender == NULL ) {
+		sieve_result_log(aenv, "discarded vacation reply to <>");
+		return TRUE;
+	}
+
+	/* Are we perhaps trying to respond to ourselves ?
+	 * (FIXME: verify this to :addresses as well?)
+	 */
+	if ( sieve_address_compare(sender, recipient, TRUE)
+		== 0 ) {
+		sieve_result_log(aenv, "discarded vacation reply to own address");
+		return TRUE;
+	}
+
+	/* Did whe respond to this user before? */
+	if ( senv->duplicate_check != NULL ) {
+		act_vacation_hash(ctx, sender, dupl_hash);
+
+		if ( senv->duplicate_check(dupl_hash, sizeof(dupl_hash), senv->username) )
+		{
+			sieve_result_log(aenv, "discarded duplicate vacation response to <%s>",
+				str_sanitize(sender, 128));
+			return TRUE;
+		}
+	}
+
+	/* Are we trying to respond to a mailing list ? */
+	hdsp = _list_headers;
+	while ( *hdsp != NULL ) {
+		if ( mail_get_headers
+			(msgdata->mail, *hdsp, &headers) >= 0 && headers[0] != NULL ) {
+			/* Yes, bail out */
+			sieve_result_log(aenv,
+				"discarding vacation response to mailinglist recipient <%s>",
+				str_sanitize(sender, 128));
+			return TRUE;
+		}
+		hdsp++;
+	}
+
+	/* Is the message that we are replying to an automatic reply ? */
+	if ( mail_get_headers
+		(msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		/* Theoretically multiple headers could exist, so lets make sure */
+		hdsp = headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_result_log(aenv,
+					"discardig vacation response to auto-submitted message from <%s>",
+					str_sanitize(sender, 128));
+					return TRUE;
+			}
+			hdsp++;
+		}
+	}
+
+	/* Check for the (non-standard) precedence header */
+	if ( mail_get_headers
+		(msgdata->mail, "precedence", &headers) >= 0 ) {
+		/* Theoretically multiple headers could exist, so lets make sure */
+		hdsp = headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "junk") == 0 || strcasecmp(*hdsp, "bulk") == 0 ||
+				strcasecmp(*hdsp, "list") == 0 ) {
+				sieve_result_log(aenv,
+					"discarding vacation response to precedence=%s message from <%s>",
+					*hdsp, str_sanitize(sender, 128));
+					return TRUE;
+			}
+			hdsp++;
+		}
+	}
+
+	/* Do not reply to system addresses */
+	if ( _is_system_address(sender) ) {
+		sieve_result_log(aenv,
+			"not sending vacation response to system address <%s>",
+			str_sanitize(sender, 128));
+		return TRUE;
+	}
+
+	/* Is the original message directly addressed to the user or the addresses
+	 * specified using the :addresses tag?
+	 */
+	hdsp = _my_address_headers;
+	while ( *hdsp != NULL ) {
+		if ( mail_get_headers_utf8
+			(msgdata->mail, *hdsp, &headers) >= 0 && headers[0] != NULL ) {
+
+			if ( _contains_my_address(headers, recipient) )
+				break;
+
+			if ( ctx->addresses != NULL ) {
+				bool found = FALSE;
+				const char * const *my_address = ctx->addresses;
+
+				while ( !found && *my_address != NULL ) {
+					found = _contains_my_address(headers, *my_address);
+					my_address++;
+				}
+
+				if ( found ) break;
+			}
+		}
+		hdsp++;
+	}
+
+	if ( *hdsp == NULL ) {
+		/* No, bail out */
+		sieve_result_log(aenv,
+			"discarding vacation response for message implicitly delivered to <%s>",
+			recipient );
+		return TRUE;
+	}
+
+	/* Make sure we have a subject for our reply */
+	if ( ctx->subject == NULL || *(ctx->subject) == '\0' ) {
+		if ( mail_get_headers_utf8
+			(msgdata->mail, "subject", &headers) >= 0 && headers[0] != NULL ) {
+			pool = sieve_result_pool(aenv->result);
+			ctx->subject = p_strconcat(pool, "Auto: ", headers[0], NULL);
+		}	else {
+			ctx->subject = "Automated reply";
+		}
+	}
+
+	/* Send the message */
+
+	if ( act_vacation_send(aenv, ctx, sender, recipient) ) {
+		sieve_result_log(aenv, "sent vacation response to <%s>",
+			str_sanitize(sender, 128));
+
+		/* Mark as replied */
+		if ( senv->duplicate_mark != NULL )
+			senv->duplicate_mark(dupl_hash, sizeof(dupl_hash), senv->username,
+				ioloop_time + ctx->days * (24 * 60 * 60));
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h
@@ -0,0 +1,25 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VACATION_COMMON_H
+#define __EXT_VACATION_COMMON_H
+
+#include "sieve-common.h"
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def vacation_command;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def vacation_operation;
+
+/* Extension */
+
+extern const struct sieve_extension_def vacation_extension;
+
+#endif /* __EXT_VACATION_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/vacation/ext-vacation.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/vacation/ext-vacation.c
@@ -0,0 +1,51 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension vacation
+ * ------------------
+ *
+ * Authors: Stephan Bosch <stephan@rename-it.nl>
+ * Specification: RFC 5230
+ * Implementation: almost complete; the required sopport for Refences header
+ *   is missing.
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-vacation-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_vacation_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def vacation_extension = {
+	"vacation",
+	NULL, NULL,
+	ext_vacation_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(vacation_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_vacation_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	/* Register new command */
+	sieve_validator_register_command(valdtr, ext, &vacation_command);
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/plugins/variables/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/Makefile.am
@@ -0,0 +1,35 @@
+noinst_LTLIBRARIES = libsieve_ext_variables.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-set.c
+
+tsts = \
+	tst-string.c
+
+libsieve_ext_variables_la_SOURCES = \
+	ext-variables-common.c \
+	ext-variables-name.c \
+	ext-variables-arguments.c \
+	ext-variables-operands.c \
+	ext-variables-modifiers.c \
+	ext-variables-dump.c \
+	$(cmds) \
+	$(tsts) \
+	ext-variables.c
+
+noinst_HEADERS = \
+	ext-variables-common.h \
+	ext-variables-limits.h \
+	ext-variables-name.h \
+	ext-variables-arguments.h \
+	ext-variables-operands.h \
+	ext-variables-modifiers.h \
+	ext-variables-dump.h \
+	sieve-ext-variables.h
Index: b/sieve/src/lib-sieve/plugins/variables/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/Makefile.in
@@ -0,0 +1,523 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sieve/plugins/variables
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_variables_la_LIBADD =
+am__objects_1 = cmd-set.lo
+am__objects_2 = tst-string.lo
+am_libsieve_ext_variables_la_OBJECTS = ext-variables-common.lo \
+	ext-variables-name.lo ext-variables-arguments.lo \
+	ext-variables-operands.lo ext-variables-modifiers.lo \
+	ext-variables-dump.lo $(am__objects_1) $(am__objects_2) \
+	ext-variables.lo
+libsieve_ext_variables_la_OBJECTS =  \
+	$(am_libsieve_ext_variables_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_variables_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_variables_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_variables.la
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-set.c
+
+tsts = \
+	tst-string.c
+
+libsieve_ext_variables_la_SOURCES = \
+	ext-variables-common.c \
+	ext-variables-name.c \
+	ext-variables-arguments.c \
+	ext-variables-operands.c \
+	ext-variables-modifiers.c \
+	ext-variables-dump.c \
+	$(cmds) \
+	$(tsts) \
+	ext-variables.c
+
+noinst_HEADERS = \
+	ext-variables-common.h \
+	ext-variables-limits.h \
+	ext-variables-name.h \
+	ext-variables-arguments.h \
+	ext-variables-operands.h \
+	ext-variables-modifiers.h \
+	ext-variables-dump.h \
+	sieve-ext-variables.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/lib-sieve/plugins/variables/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/lib-sieve/plugins/variables/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_variables.la: $(libsieve_ext_variables_la_OBJECTS) $(libsieve_ext_variables_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_variables_la_OBJECTS) $(libsieve_ext_variables_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-set.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-arguments.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-common.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-dump.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-modifiers.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-name.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables-operands.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-variables.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-string.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/lib-sieve/plugins/variables/cmd-set.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/cmd-set.c
@@ -0,0 +1,372 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+
+#include "sieve-code.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-modifiers.h"
+
+/*
+ * Set command
+ *
+ * Syntax:
+ *    set [MODIFIER] <name: string> <value: string>
+ */
+
+static bool cmd_set_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_set_pre_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_set_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_set = {
+	"set",
+	SCT_COMMAND,
+	2, 0, FALSE, FALSE,
+	cmd_set_registered,
+	cmd_set_pre_validate,
+	cmd_set_validate,
+	cmd_set_generate,
+	NULL
+};
+
+/*
+ * Set operation
+ */
+
+static bool cmd_set_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_set_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def cmd_set_operation = {
+	"SET",
+	&variables_extension,
+	EXT_VARIABLES_OPERATION_SET,
+	cmd_set_operation_dump,
+	cmd_set_operation_execute
+};
+
+/*
+ * Compiler context
+ */
+
+struct cmd_set_context {
+	ARRAY_DEFINE(modifiers, const struct sieve_variables_modifier *);
+};
+
+/*
+ * Set modifier tag
+ *
+ * [MODIFIER]:
+ *   ":lower" / ":upper" / ":lowerfirst" / ":upperfirst" /
+ *             ":quotewildcard" / ":length"
+ */
+
+/* Forward declarations */
+
+static bool tag_modifier_is_instance_of
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		const struct sieve_extension *ext, const char *identifier, void **context);
+static bool tag_modifier_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+/* Modifier tag object */
+
+const struct sieve_argument_def modifier_tag = {
+	"MODIFIER",
+	tag_modifier_is_instance_of,
+	tag_modifier_validate,
+	NULL, NULL, NULL
+};
+
+/* Modifier tag implementation */
+
+static bool tag_modifier_is_instance_of
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const struct sieve_extension *ext, const char *identifier, void **data)
+{
+	const struct sieve_variables_modifier *modf;
+
+	if ( data == NULL ) {
+		return ext_variables_modifier_exists(ext, valdtr, identifier);
+	}
+
+	if ( (modf=ext_variables_modifier_create_instance
+		(ext, valdtr, cmd, identifier)) == NULL )
+		return FALSE;
+
+	*data = (void *) modf;
+
+	return TRUE;
+}
+
+static bool tag_modifier_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	unsigned int i, modf_count;
+	bool inserted;
+	const struct sieve_variables_modifier *modf =
+		(const struct sieve_variables_modifier *) (*arg)->argument->data;
+	const struct sieve_variables_modifier *const *modfs;
+	struct cmd_set_context *sctx = (struct cmd_set_context *) cmd->data;
+
+	inserted = FALSE;
+	modfs = array_get(&sctx->modifiers, &modf_count);
+	for ( i = 0; i < modf_count && !inserted; i++ ) {
+
+		if ( modfs[i]->def->precedence == modf->def->precedence ) {
+			sieve_argument_validate_error(valdtr, *arg,
+				"modifiers :%s and :%s specified for the set command conflict "
+				"having equal precedence",
+				modfs[i]->def->obj_def.identifier, modf->def->obj_def.identifier);
+			return FALSE;
+		}
+
+		if ( modfs[i]->def->precedence < modf->def->precedence ) {
+			array_insert(&sctx->modifiers, i, &modf, 1);
+			inserted = TRUE;
+		}
+	}
+
+	if ( !inserted )
+		array_append(&sctx->modifiers, &modf, 1);
+
+	/* Added to modifier list; self-destruct to prevent duplicate generation */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/* Command registration */
+
+static bool cmd_set_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &modifier_tag, 0);
+
+	return TRUE;
+}
+
+/*
+ * Command validation
+ */
+
+static bool cmd_set_pre_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_command *cmd)
+{
+	pool_t pool = sieve_command_pool(cmd);
+	struct cmd_set_context *sctx = p_new(pool, struct cmd_set_context, 1);
+
+	/* Create an array for the sorted list of modifiers */
+	p_array_init(&sctx->modifiers, pool, 2);
+
+	cmd->data = (void *) sctx;
+
+	return TRUE;
+}
+
+static bool cmd_set_validate(struct sieve_validator *valdtr,
+	struct sieve_command *cmd)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_variable_argument_activate(this_ext, valdtr, cmd, arg, TRUE) ) {
+		return FALSE;
+	}
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "value", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	const struct sieve_extension *this_ext = cmd->ext;
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct cmd_set_context *sctx = (struct cmd_set_context *) cmd->data;
+	const struct sieve_variables_modifier *const *modfs;
+	unsigned int i, modf_count;
+
+	sieve_operation_emit(sbin, this_ext, &cmd_set_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	/* Generate modifiers (already sorted during validation) */
+	sieve_binary_emit_byte(sbin, array_count(&sctx->modifiers));
+
+	modfs = array_get(&sctx->modifiers, &modf_count);
+	for ( i = 0; i < modf_count; i++ ) {
+		ext_variables_opr_modifier_emit(sbin, modfs[i]->object.ext, modfs[i]->def);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_set_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int mdfs, i;
+
+	sieve_code_dumpf(denv, "SET");
+	sieve_code_descend(denv);
+
+	/* Print both variable name and string value */
+	if ( !sieve_opr_string_dump(denv, address, "variable") ||
+		!sieve_opr_string_dump(denv, address, "value") )
+		return FALSE;
+
+	/* Read the number of applied modifiers we need to read */
+	if ( !sieve_binary_read_byte(denv->sbin, address, &mdfs) )
+		return FALSE;
+
+	/* Print all modifiers (sorted during code generation already) */
+	for ( i = 0; i < mdfs; i++ ) {
+		if ( !ext_variables_opr_modifier_dump(denv, address) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Code execution
+ */
+
+static int cmd_set_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_variable_storage *storage;
+	unsigned int var_index, mdfs, i;
+	string_t *value;
+	int ret = SIEVE_EXEC_OK;
+
+	/*
+	 * Read the normal operands
+	 */
+
+	/* Read the variable */
+	if ( !sieve_variable_operand_read
+		(renv, address, &storage, &var_index) ) {
+		sieve_runtime_trace_error(renv, "invalid variable operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read the raw string value */
+	if ( !sieve_opr_string_read(renv, address, &value) ) {
+		sieve_runtime_trace_error(renv, "invalid string operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read the number of modifiers used */
+	if ( !sieve_binary_read_byte(renv->sbin, address, &mdfs) ) {
+		sieve_runtime_trace_error(renv, "invalid modifier count");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Determine and assign the value
+	 */
+
+	sieve_runtime_trace(renv, "SET action");
+
+	/* Hold value within limits */
+	if ( str_len(value) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+		str_truncate(value, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+
+	T_BEGIN {
+		/* Apply modifiers if necessary (sorted during code generation already) */
+		if ( str_len(value) > 0 ) {
+			for ( i = 0; i < mdfs; i++ ) {
+				string_t *new_value;
+				struct sieve_variables_modifier modf;
+
+				if ( !ext_variables_opr_modifier_read(renv, address, &modf) ) {
+					value = NULL;
+
+					sieve_runtime_trace_error(renv, "invalid modifier operand");
+					ret = SIEVE_EXEC_BIN_CORRUPT;
+					break;
+				}
+
+				if ( modf.def != NULL && modf.def->modify != NULL ) {
+					if ( !modf.def->modify(value, &new_value) ) {
+						value = NULL;
+						ret = SIEVE_EXEC_FAILURE;
+						break;
+					}
+
+					value = new_value;
+					if ( value == NULL )
+						break;
+
+					/* Hold value within limits */
+					if ( str_len(value) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+						str_truncate(value, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+				}
+			}
+		}
+
+		/* Actually assign the value if all is well */
+		if ( value != NULL ) {
+			if ( !sieve_variable_assign(storage, var_index, value) )
+				ret = SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} T_END;
+
+	if ( ret <= 0 )
+		return ret;
+
+	return ( value != NULL );
+}
+
+
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c
@@ -0,0 +1,454 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-limits.h"
+#include "ext-variables-name.h"
+#include "ext-variables-operands.h"
+#include "ext-variables-arguments.h"
+
+/*
+ * Common error messages
+ */
+
+static inline void _ext_variables_scope_size_error
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	const char *variable)
+{
+	sieve_argument_validate_error(valdtr, arg,
+		"(implicit) declaration of new variable '%s' exceeds the limit "
+		"(max variables: %u)", variable,
+		SIEVE_VARIABLES_MAX_SCOPE_SIZE);
+}
+
+static inline void _ext_variables_match_index_error
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	unsigned int variable_index)
+{
+	sieve_argument_validate_error(valdtr, arg,
+		"match value index %u out of range (max: %u)", variable_index,
+		SIEVE_VARIABLES_MAX_MATCH_INDEX);
+}
+
+/*
+ * Variable argument
+ */
+
+static bool arg_variable_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *context);
+
+const struct sieve_argument_def variable_argument = {
+	"@variable",
+	NULL, NULL, NULL, NULL,
+	arg_variable_generate
+};
+
+static struct sieve_ast_argument *ext_variables_variable_argument_create
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr,
+	struct sieve_ast *ast, unsigned int source_line, const char *variable)
+{
+	struct sieve_variable *var;
+	struct sieve_ast_argument *arg;
+
+	var = ext_variables_validator_get_variable(this_ext, valdtr, variable, TRUE);
+
+	if ( var == NULL )
+		return NULL;
+
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = sieve_argument_create(ast, &variable_argument, this_ext, 0);
+	arg->argument->data = (void *) var;
+
+	return arg;
+}
+
+static bool _sieve_variable_argument_activate
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr,
+	struct sieve_command *cmd ATTR_UNUSED, struct sieve_ast_argument *arg,
+	bool assignment)
+{
+	struct sieve_ast *ast = arg->ast;
+	bool result = FALSE;
+	struct sieve_variable *var;
+	string_t *variable;
+	const char *varstr, *varend;
+	ARRAY_TYPE(ext_variable_name) vname;
+	int nelements = 0;
+
+	T_BEGIN {
+		t_array_init(&vname, 2);
+
+		variable = sieve_ast_argument_str(arg);
+		varstr = str_c(variable);
+		varend = PTR_OFFSET(varstr, str_len(variable));
+		nelements = ext_variable_name_parse(&vname, &varstr, varend);
+
+		/* Check whether name parsing succeeded */
+		if ( nelements < 0 || varstr != varend ) {
+			/* Parse failed */
+			sieve_argument_validate_error(valdtr, arg,
+				"invalid variable name '%s'", str_sanitize(str_c(variable),80));
+		} else if ( nelements == 1 ) {
+			/* Normal (match) variable */
+
+			const struct ext_variable_name *cur_element =
+				array_idx(&vname, 0);
+
+			if ( cur_element->num_variable < 0 ) {
+				/* Variable */
+				var = ext_variables_validator_get_variable
+					(this_ext, valdtr, str_c(cur_element->identifier), TRUE);
+
+				if ( var == NULL ) {
+					_ext_variables_scope_size_error
+						(valdtr, arg, str_c(cur_element->identifier));
+				} else {
+					arg->argument = sieve_argument_create
+						(ast, &variable_argument, this_ext, 0);
+					arg->argument->data = (void *) var;
+
+					result = TRUE;
+				}
+			} else {
+				/* Match value */
+				if ( !assignment ) {
+					if ( cur_element->num_variable > SIEVE_VARIABLES_MAX_MATCH_INDEX ) {
+						_ext_variables_match_index_error
+							(valdtr, arg, cur_element->num_variable);
+					} else {
+						arg->argument = sieve_argument_create
+							(ast, &match_value_argument, this_ext, 0);
+						arg->argument->data = (void *)
+							POINTER_CAST(cur_element->num_variable);
+
+						result = TRUE;
+					}
+				} else {
+					sieve_argument_validate_error(valdtr, arg,
+						"cannot assign to match variable");
+				}
+			}
+		} else {
+			/* Namespace variable */
+
+			const struct ext_variable_name *cur_element =
+				array_idx(&vname, 0);
+
+			/* FIXME: Variable namespaces unsupported. */
+
+			/* References to namespaces without a prior require statement for
+			 * the relevant extension MUST cause an error.
+			 */
+
+			sieve_argument_validate_error(valdtr, arg,
+				"cannot %s to variable in unknown namespace '%s'",
+				assignment ? "assign" : "refer", str_c(cur_element->identifier));
+		}
+	} T_END;
+
+	return result;
+}
+
+bool sieve_variable_argument_activate
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr,
+	struct sieve_command *cmd, struct sieve_ast_argument *arg,
+	bool assignment)
+{
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		return _sieve_variable_argument_activate
+			(this_ext, valdtr, cmd, arg, assignment);
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem;
+
+		i_assert ( !assignment );
+
+		stritem = sieve_ast_strlist_first(arg);
+		while ( stritem != NULL ) {
+			if ( !_sieve_variable_argument_activate
+				(this_ext, valdtr, cmd, stritem, assignment) )
+				return FALSE;
+
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+
+		arg->argument = sieve_argument_create
+			(arg->ast, &string_list_argument, NULL, 0);
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static bool arg_variable_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *context ATTR_UNUSED)
+{
+	struct sieve_argument *argument = arg->argument;
+	struct sieve_variable *var = (struct sieve_variable *) argument->data;
+
+	ext_variables_opr_variable_emit(cgenv->sbin, argument->ext, var);
+
+	return TRUE;
+}
+
+/*
+ * Match value argument
+ */
+
+static bool arg_match_value_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *context ATTR_UNUSED);
+
+const struct sieve_argument_def match_value_argument = {
+	"@match_value",
+	NULL, NULL, NULL, NULL,
+	arg_match_value_generate
+};
+
+static struct sieve_ast_argument *ext_variables_match_value_argument_create
+(const struct sieve_extension *this_ext,
+	struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast *ast,
+	unsigned int source_line,	unsigned int index)
+{
+	struct sieve_ast_argument *arg;
+
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = sieve_argument_create
+		(ast, &match_value_argument, this_ext, 0);
+	arg->argument->data = (void *) POINTER_CAST(index);
+
+	return arg;
+}
+
+static bool arg_match_value_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *context ATTR_UNUSED)
+{
+	struct sieve_argument *argument = arg->argument;
+	unsigned int index = POINTER_CAST_TO(argument->data, unsigned int);
+
+	ext_variables_opr_match_value_emit(cgenv->sbin, argument->ext, index);
+
+	return TRUE;
+}
+
+/*
+ * Variable string argument
+ */
+
+static bool arg_variable_string_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+const struct sieve_argument_def variable_string_argument = {
+	"@variable-string",
+	NULL,
+	arg_variable_string_validate,
+	NULL, NULL,
+	sieve_arg_catenated_string_generate,
+};
+
+static bool arg_variable_string_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	const struct sieve_extension *this_ext = (*arg)->argument->ext;
+	enum { ST_NONE, ST_OPEN, ST_VARIABLE, ST_CLOSE } state = ST_NONE;
+	pool_t pool = sieve_ast_pool((*arg)->ast);
+	struct sieve_arg_catenated_string *catstr = NULL;
+	string_t *str = sieve_ast_argument_str(*arg);
+	const char *p, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	bool result = TRUE;
+
+	ARRAY_TYPE(ext_variable_name) substitution;
+	int nelements = 0;
+
+	T_BEGIN {
+		/* Initialize substitution structure */
+		t_array_init(&substitution, 2);
+
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+
+			/* Nothing found yet */
+			case ST_NONE:
+				if ( *p == '$' ) {
+					substart = p;
+					state = ST_OPEN;
+				}
+				p++;
+				break;
+
+			/* Got '$' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_VARIABLE;
+					p++;
+				} else
+					state = ST_NONE;
+				break;
+
+			/* Got '${' */
+			case ST_VARIABLE:
+				nelements = ext_variable_name_parse(&substitution, &p, strend);
+
+				if ( nelements < 0 )
+					state = ST_NONE;
+				else
+					state = ST_CLOSE;
+
+				break;
+
+			/* Finished parsing name, expecting '}' */
+			case ST_CLOSE:
+				if ( *p == '}' ) {
+					struct sieve_ast_argument *strarg;
+
+					/* We now know that the substitution is valid */
+
+					if ( catstr == NULL ) {
+						catstr = sieve_arg_catenated_string_create(*arg);
+					}
+
+					/* Add the substring that is before the substitution to the
+					 * variable-string AST.
+					 *
+					 * FIXME: For efficiency, if the variable is not found we should
+					 * coalesce this substring with the one after the substitution.
+					 */
+					if ( substart > strstart ) {
+						string_t *newstr = str_new(pool, substart - strstart);
+						str_append_n(newstr, strstart, substart - strstart);
+
+						strarg = sieve_ast_argument_string_create_raw
+							((*arg)->ast, newstr, (*arg)->source_line);
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+
+						/* Give other substitution extensions a chance to do their work */
+						if ( !sieve_validator_argument_activate_super
+							(valdtr, cmd, strarg, FALSE) ) {
+							result = FALSE;
+							break;
+						}
+					}
+
+					/* Find the variable */
+					if ( nelements == 1 ) {
+						const struct ext_variable_name *cur_element =
+							array_idx(&substitution, 0);
+
+						if ( cur_element->num_variable == -1 ) {
+							/* Add variable argument '${identifier}' */
+							string_t *cur_ident = cur_element->identifier;
+
+							strarg = ext_variables_variable_argument_create
+								(this_ext, valdtr, (*arg)->ast, (*arg)->source_line,
+									str_c(cur_ident));
+
+							if ( strarg != NULL )
+								sieve_arg_catenated_string_add_element(catstr, strarg);
+							else {
+								_ext_variables_scope_size_error
+									(valdtr, *arg, str_c(cur_element->identifier));
+								result = FALSE;
+								break;
+							}
+						} else {
+							/* Add match value argument '${000}' */
+							if ( cur_element->num_variable > SIEVE_VARIABLES_MAX_MATCH_INDEX ) {
+								_ext_variables_match_index_error
+									(valdtr, *arg, cur_element->num_variable);
+								result = FALSE;
+								break;
+							}
+
+							strarg = ext_variables_match_value_argument_create
+								(this_ext, valdtr, (*arg)->ast, (*arg)->source_line,
+								cur_element->num_variable);
+
+							if ( strarg != NULL )
+								sieve_arg_catenated_string_add_element(catstr, strarg);
+						}
+					} else {
+						const struct ext_variable_name *cur_element =
+							array_idx(&substitution, 0);
+
+						/* FIXME: Namespaces are not supported. */
+
+						/* References to namespaces without a prior require
+						 * statement for thecrelevant extension MUST cause an error.
+					 	 */
+						sieve_argument_validate_error(valdtr, *arg,
+							"referring to variable in unknown namespace '%s'",
+							str_c(cur_element->identifier));
+						result = FALSE;
+						break;
+					}
+
+					strstart = p + 1;
+					substart = strstart;
+
+					p++;
+				}
+
+				/* Finished, reset for the next substitution */
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	/* Bail out early if substitution is invalid */
+	if ( !result ) return FALSE;
+
+	/* Check whether any substitutions were found */
+	if ( catstr == NULL ) {
+		/* No substitutions in this string, pass it on to any other substution
+		 * extension.
+		 */
+		return sieve_validator_argument_activate_super(valdtr, cmd, *arg, TRUE);
+	}
+
+	/* Add the final substring that comes after the last substitution to the
+	 * variable-string AST.
+	 */
+	if ( strend > strstart ) {
+		struct sieve_ast_argument *strarg;
+		string_t *newstr = str_new(pool, strend - strstart);
+		str_append_n(newstr, strstart, strend - strstart);
+
+		strarg = sieve_ast_argument_string_create_raw
+			((*arg)->ast, newstr, (*arg)->source_line);
+		sieve_arg_catenated_string_add_element(catstr, strarg);
+
+		/* Give other substitution extensions a chance to do their work */
+		if ( !sieve_validator_argument_activate_super
+			(valdtr, cmd, strarg, FALSE) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_ARGUMENTS_H
+#define __EXT_VARIABLES_ARGUMENTS_H
+
+#include "sieve-common.h"
+
+/*
+ * Variable argument
+ */
+
+extern const struct sieve_argument_def variable_argument;
+
+/*
+ * Match value argument
+ */
+
+extern const struct sieve_argument_def match_value_argument;
+
+/*
+ * Variable string argument
+ */
+
+extern const struct sieve_argument_def variable_string_argument;
+
+#endif /* __EXT_VARIABLES_ARGUMENTS_H */
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-common.c
@@ -0,0 +1,577 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-objects.h"
+#include "sieve-match-types.h"
+
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-name.h"
+#include "ext-variables-modifiers.h"
+
+/*
+ * Variable scope
+ */
+
+struct sieve_variable_scope {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_variable *error_var;
+
+	const struct sieve_extension *ext;
+
+	struct hash_table *variables;
+	ARRAY_DEFINE(variable_index, struct sieve_variable *);
+};
+
+struct sieve_variable_scope_iter {
+	struct sieve_variable_scope *scope;
+	struct hash_iterate_context *hctx;
+};
+
+struct sieve_variable_scope *sieve_variable_scope_create
+	(const struct sieve_extension *ext)
+{
+	struct sieve_variable_scope *scope;
+	pool_t pool;
+
+	pool = pool_alloconly_create("sieve_variable_scope", 4096);
+	scope = p_new(pool, struct sieve_variable_scope, 1);
+	scope->pool = pool;
+	scope->refcount = 1;
+
+	scope->ext = ext;
+	scope->variables = hash_table_create
+		(default_pool, pool, 0, strcase_hash, (hash_cmp_callback_t *)strcasecmp);
+	p_array_init(&scope->variable_index, pool, 128);
+
+	return scope;
+}
+
+void sieve_variable_scope_ref(struct sieve_variable_scope *scope)
+{
+	scope->refcount++;
+}
+
+void sieve_variable_scope_unref(struct sieve_variable_scope **scope)
+{
+	i_assert((*scope)->refcount > 0);
+
+	if (--(*scope)->refcount != 0)
+		return;
+
+	hash_table_destroy(&(*scope)->variables);
+
+	pool_unref(&(*scope)->pool);
+    *scope = NULL;
+}
+
+pool_t sieve_variable_scope_pool(struct sieve_variable_scope *scope)
+{
+	return scope->pool;
+}
+
+struct sieve_variable *sieve_variable_scope_declare
+(struct sieve_variable_scope *scope, const char *identifier)
+{
+	struct sieve_variable *new_var;
+
+	new_var = p_new(scope->pool, struct sieve_variable, 1);
+	new_var->ext = scope->ext;
+
+	if ( array_count(&scope->variable_index) >= SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		if ( scope->error_var == NULL ) {
+			new_var->identifier = "@ERROR@";
+			new_var->index = 0;
+
+			scope->error_var = new_var;
+			return NULL;
+		}
+
+		return scope->error_var;
+	}
+
+	new_var->identifier = p_strdup(scope->pool, identifier);
+	new_var->index = array_count(&scope->variable_index);
+
+	hash_table_insert(scope->variables, (void *) new_var->identifier, (void *) new_var);
+	array_append(&scope->variable_index, &new_var, 1);
+
+	return new_var;
+}
+
+struct sieve_variable *sieve_variable_scope_get_variable
+(struct sieve_variable_scope *scope, const char *identifier, bool declare)
+{
+	struct sieve_variable *var =
+		(struct sieve_variable *) hash_table_lookup(scope->variables, identifier);
+
+	if ( var == NULL && declare ) {
+		var = sieve_variable_scope_declare(scope, identifier);
+	}
+
+	return var;
+}
+
+struct sieve_variable *sieve_variable_scope_import
+(struct sieve_variable_scope *scope, struct sieve_variable *var)
+{
+	struct sieve_variable *new_var = p_new(scope->pool, struct sieve_variable, 1);
+	memcpy(new_var, var, sizeof(struct sieve_variable));
+
+	hash_table_insert(scope->variables, (void *) new_var->identifier, (void *) new_var);
+
+	/* Not entered into the index because it is an external variable
+	 * (This can be done unlimited; only limited by the size of the external scope)
+	 */
+
+	return new_var;
+}
+
+struct sieve_variable_scope_iter *sieve_variable_scope_iterate_init
+(struct sieve_variable_scope *scope)
+{
+	struct sieve_variable_scope_iter *iter = t_new(struct sieve_variable_scope_iter, 1);
+	iter->scope = scope;
+	iter->hctx = hash_table_iterate_init(scope->variables);
+
+	return iter;
+}
+
+bool sieve_variable_scope_iterate
+(struct sieve_variable_scope_iter *iter, struct sieve_variable **var_r)
+{
+	void *key, *value;
+
+	if ( !hash_table_iterate(iter->hctx, &key, &value) )
+		return FALSE;
+
+	*var_r = (struct sieve_variable *) value;
+	return TRUE;
+}
+
+void sieve_variable_scope_iterate_deinit
+(struct sieve_variable_scope_iter **iter)
+{
+	hash_table_iterate_deinit(&(*iter)->hctx);
+	*iter = NULL;
+}
+
+unsigned int sieve_variable_scope_declarations
+(struct sieve_variable_scope *scope)
+{
+	return hash_table_count(scope->variables);
+}
+
+unsigned int sieve_variable_scope_size
+(struct sieve_variable_scope *scope)
+{
+	return array_count(&scope->variable_index);
+}
+
+struct sieve_variable * const *sieve_variable_scope_get_variables
+(struct sieve_variable_scope *scope, unsigned int *size_r)
+{
+	return array_get(&scope->variable_index, size_r);
+}
+
+struct sieve_variable *sieve_variable_scope_get_indexed
+(struct sieve_variable_scope *scope, unsigned int index)
+{
+	struct sieve_variable * const *var;
+
+	if ( index >= array_count(&scope->variable_index) )
+		return NULL;
+
+	var = array_idx(&scope->variable_index, index);
+
+	return *var;
+}
+
+/*
+ * Variable storage
+ */
+
+struct sieve_variable_storage {
+	pool_t pool;
+	struct sieve_variable_scope *scope;
+	unsigned int max_size;
+	ARRAY_DEFINE(var_values, string_t *);
+};
+
+struct sieve_variable_storage *sieve_variable_storage_create
+(pool_t pool, struct sieve_variable_scope *scope, unsigned int max_size)
+{
+	struct sieve_variable_storage *storage;
+
+	storage = p_new(pool, struct sieve_variable_storage, 1);
+	storage->pool = pool;
+	storage->scope = scope;
+
+	if ( scope != NULL )
+		storage->max_size = sieve_variable_scope_size(scope);
+	else
+		storage->max_size = max_size;
+
+	p_array_init(&storage->var_values, pool, 4);
+
+	return storage;
+}
+
+static inline bool sieve_variable_valid
+(struct sieve_variable_storage *storage, unsigned int index)
+{
+	if ( storage->scope == NULL ) return TRUE;
+
+	return ( index < storage->max_size );
+}
+
+bool sieve_variable_get_identifier
+(struct sieve_variable_storage *storage, unsigned int index, const char **identifier)
+{
+	struct sieve_variable * const *var;
+	*identifier = NULL;
+
+	if ( storage->scope == NULL ) return TRUE;
+
+	/* FIXME: direct invasion of the scope object is a bit ugly */
+	if ( index >= array_count(&storage->scope->variable_index) )
+		return FALSE;
+
+	var = array_idx(&storage->scope->variable_index, index);
+
+	if ( *var != NULL )
+		*identifier = (*var)->identifier;
+
+	return TRUE;
+}
+
+bool sieve_variable_get
+(struct sieve_variable_storage *storage, unsigned int index, string_t **value)
+{
+	*value = NULL;
+
+	if  ( index < array_count(&storage->var_values) ) {
+		string_t * const *varent;
+
+		varent = array_idx(&storage->var_values, index);
+
+		*value = *varent;
+	} else if ( !sieve_variable_valid(storage, index) )
+		return FALSE;
+
+	return TRUE;
+}
+
+bool sieve_variable_get_modifiable
+(struct sieve_variable_storage *storage, unsigned int index, string_t **value)
+{
+	string_t *dummy;
+
+	if ( value == NULL ) value = &dummy;
+
+	if ( !sieve_variable_get(storage, index, value) )
+		return FALSE;
+
+	if ( *value == NULL ) {
+		*value = str_new(storage->pool, 256);
+		array_idx_set(&storage->var_values, index, value);
+	}
+
+	return TRUE;
+}
+
+bool sieve_variable_assign
+(struct sieve_variable_storage *storage, unsigned int index,
+	const string_t *value)
+{
+	string_t *varval;
+
+	if ( !sieve_variable_get_modifiable(storage, index, &varval) )
+		return FALSE;
+
+	str_truncate(varval, 0);
+	str_append_str(varval, value);
+
+	/* Just a precaution, caller should prevent this in the first place */
+	if ( str_len(varval) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+		str_truncate(varval, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+
+	return TRUE;
+}
+
+/*
+ * AST Context
+ */
+
+static void ext_variables_ast_free
+(const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_ast *ast ATTR_UNUSED, void *context)
+{
+	struct sieve_variable_scope *main_scope =
+		(struct sieve_variable_scope *) context;
+
+	/* Unreference main variable scope */
+	sieve_variable_scope_unref(&main_scope);
+}
+
+static const struct sieve_ast_extension variables_ast_extension = {
+    &variables_extension,
+    ext_variables_ast_free
+};
+
+static struct sieve_variable_scope *ext_variables_create_main_scope
+(const struct sieve_extension *this_ext, struct sieve_ast *ast)
+{
+	struct sieve_variable_scope *scope;
+
+	scope = sieve_variable_scope_create(NULL);
+
+	sieve_ast_extension_register
+		(ast, this_ext, &variables_ast_extension, (void *) scope);
+
+	return scope;
+}
+
+static struct sieve_variable_scope *ext_variables_ast_get_main_scope
+(const struct sieve_extension *this_ext, struct sieve_ast *ast)
+{
+	struct sieve_variable_scope *main_scope = (struct sieve_variable_scope *)
+		sieve_ast_extension_get_context(ast, this_ext);
+
+	return main_scope;
+}
+
+/*
+ * Validator context
+ */
+
+static struct ext_variables_validator_context *
+ext_variables_validator_context_create
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr)
+{
+	pool_t pool = sieve_validator_pool(valdtr);
+	struct ext_variables_validator_context *ctx;
+	struct sieve_ast *ast = sieve_validator_ast(valdtr);
+
+	ctx = p_new(pool, struct ext_variables_validator_context, 1);
+	ctx->modifiers = sieve_validator_object_registry_create(valdtr);
+	ctx->main_scope = ext_variables_create_main_scope(this_ext, ast);
+
+	sieve_validator_extension_set_context(valdtr, this_ext, (void *) ctx);
+	return ctx;
+}
+
+struct ext_variables_validator_context *ext_variables_validator_context_get
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx =
+		(struct ext_variables_validator_context *)
+		sieve_validator_extension_get_context(valdtr, this_ext);
+
+	if ( ctx == NULL ) {
+		ctx = ext_variables_validator_context_create(this_ext, valdtr);
+	}
+
+	return ctx;
+}
+
+void ext_variables_validator_initialize
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx;
+
+	/* Create our context */
+	ctx = ext_variables_validator_context_get(this_ext, valdtr);
+
+	ext_variables_register_core_modifiers(this_ext, ctx);
+
+	ctx->active = TRUE;
+}
+
+struct sieve_variable *ext_variables_validator_get_variable
+(const struct sieve_extension *this_ext, struct sieve_validator *validator,
+	const char *variable, bool declare)
+{
+	struct ext_variables_validator_context *ctx =
+		ext_variables_validator_context_get(this_ext, validator);
+
+	return sieve_variable_scope_get_variable(ctx->main_scope, variable, declare);
+}
+
+struct sieve_variable_scope *sieve_ext_variables_get_main_scope
+(const struct sieve_extension *var_ext, struct sieve_validator *validator)
+{
+	struct ext_variables_validator_context *ctx =
+		ext_variables_validator_context_get(var_ext, validator);
+
+	return ctx->main_scope;
+}
+
+bool sieve_ext_variables_is_active
+(const struct sieve_extension *var_ext, struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx =
+		ext_variables_validator_context_get(var_ext, valdtr);
+
+	return ( ctx != NULL && ctx->active );
+}
+
+/*
+ * Code generation
+ */
+
+bool ext_variables_generator_load
+(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv)
+{
+	struct sieve_variable_scope *main_scope =
+		ext_variables_ast_get_main_scope(ext, cgenv->ast);
+	unsigned int count = sieve_variable_scope_size(main_scope);
+	sieve_size_t jump;
+
+	sieve_binary_emit_unsigned(cgenv->sbin, count);
+
+	jump = sieve_binary_emit_offset(cgenv->sbin, 0);
+
+	if ( count > 0 ) {
+		unsigned int size, i;
+		struct sieve_variable *const *vars =
+			sieve_variable_scope_get_variables(main_scope, &size);
+
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_emit_cstring(cgenv->sbin, vars[i]->identifier);
+		}
+	}
+
+	sieve_binary_resolve_offset(cgenv->sbin, jump);
+
+	return TRUE;
+}
+
+/*
+ * Interpreter context
+ */
+
+struct ext_variables_interpreter_context {
+	struct sieve_variable_storage *local_storage;
+	ARRAY_DEFINE(ext_storages, struct sieve_variable_storage *);
+};
+
+static struct ext_variables_interpreter_context *
+ext_variables_interpreter_context_create
+(const struct sieve_extension *this_ext, struct sieve_interpreter *interp,
+	unsigned int max_size)
+{
+	pool_t pool = sieve_interpreter_pool(interp);
+	struct ext_variables_interpreter_context *ctx;
+
+	ctx = p_new(pool, struct ext_variables_interpreter_context, 1);
+	ctx->local_storage = sieve_variable_storage_create(pool, NULL, max_size);
+	p_array_init(&ctx->ext_storages, pool,
+		sieve_extensions_get_count(this_ext->svinst));
+
+	sieve_interpreter_extension_set_context
+		(interp, this_ext, (void *) ctx);
+
+	return ctx;
+}
+
+bool ext_variables_interpreter_load
+(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+	sieve_size_t *address)
+{
+	struct ext_variables_interpreter_context *ctx;
+	unsigned int scope_size;
+	sieve_size_t pc;
+	int end_offset;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &scope_size) ) {
+		sieve_sys_error("variables: failed to read main scope size");
+		return FALSE;
+	}
+
+	if ( scope_size > SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		sieve_sys_error("variables: scope size exceeds the limit (%u > %u)",
+			scope_size, SIEVE_VARIABLES_MAX_SCOPE_SIZE );
+		return FALSE;
+	}
+
+	pc = *address;
+	if ( !sieve_binary_read_offset(renv->sbin, address, &end_offset) )
+		return NULL;
+	*address = pc + end_offset;
+
+	/* Create our context */
+	ctx = ext_variables_interpreter_context_create
+		(ext, renv->interp, scope_size);
+
+	/* Enable support for match values */
+	(void) sieve_match_values_set_enabled(renv->interp, TRUE);
+
+	return TRUE;
+}
+
+static inline struct ext_variables_interpreter_context *
+ext_variables_interpreter_context_get
+(const struct sieve_extension *this_ext, struct sieve_interpreter *interp)
+{
+	return (struct ext_variables_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, this_ext);
+}
+
+struct sieve_variable_storage *sieve_ext_variables_get_storage
+(const struct sieve_extension *var_ext, struct sieve_interpreter *interp,
+	const struct sieve_extension *ext)
+{
+	struct ext_variables_interpreter_context *ctx =
+		ext_variables_interpreter_context_get(var_ext, interp);
+	struct sieve_variable_storage * const *storage;
+
+	if ( ext == NULL )
+		return ctx->local_storage;
+
+	if ( ext->id >= (int) array_count(&ctx->ext_storages) ) {
+		storage = NULL;
+	} else {
+		storage = array_idx(&ctx->ext_storages, ext->id);
+	}
+
+	if ( storage == NULL || *storage == NULL )
+		return NULL;
+
+	return *storage;
+}
+
+void sieve_ext_variables_set_storage
+(const struct sieve_extension *var_ext, struct sieve_interpreter *interp,
+	struct sieve_variable_storage *storage, const struct sieve_extension *ext)
+{
+	struct ext_variables_interpreter_context *ctx =
+		ext_variables_interpreter_context_get(var_ext, interp);
+
+	if ( ctx == NULL || ext == NULL || storage == NULL )
+		return;
+
+	if ( ext->id < 0 ) return;
+
+	array_idx_set(&ctx->ext_storages, (unsigned int) ext->id, &storage);
+}
+
+
+
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-common.h
@@ -0,0 +1,84 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_COMMON_H
+#define __EXT_VARIABLES_COMMON_H
+
+#include "sieve-common.h"
+#include "sieve-validator.h"
+
+#include "sieve-ext-variables.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def variables_extension;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def cmd_set;
+extern const struct sieve_command_def tst_string;
+
+/*
+ * Operands
+ */
+
+enum ext_variables_operand {
+	EXT_VARIABLES_OPERAND_VARIABLE,
+	EXT_VARIABLES_OPERAND_MATCH_VALUE,
+	EXT_VARIABLES_OPERAND_MODIFIER
+};
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def cmd_set_operation;
+extern const struct sieve_operation_def tst_string_operation;
+
+enum ext_variables_opcode {
+	EXT_VARIABLES_OPERATION_SET,
+	EXT_VARIABLES_OPERATION_STRING
+};
+
+/*
+ * Validator context
+ */
+
+struct ext_variables_validator_context {
+	bool active;
+
+	struct sieve_validator_object_registry *modifiers;
+
+	struct sieve_variable_scope *main_scope;
+};
+
+void ext_variables_validator_initialize
+	(const struct sieve_extension *this_ext, struct sieve_validator *validator);
+
+struct ext_variables_validator_context *ext_variables_validator_context_get
+	(const struct sieve_extension *this_ext, struct sieve_validator *valdtr);
+
+struct sieve_variable *ext_variables_validator_get_variable
+	(const struct sieve_extension *this_ext, struct sieve_validator *validator,
+		const char *variable, bool declare);
+
+/*
+ * Code generation
+ */
+
+bool ext_variables_generator_load
+	(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv);
+
+/*
+ * Interpreter context
+ */
+
+bool ext_variables_interpreter_load
+	(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+		sieve_size_t *address);
+
+#endif /* __EXT_VARIABLES_COMMON_H */
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-dump.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-dump.c
@@ -0,0 +1,161 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-dump.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-dump.h"
+
+/*
+ * Code dumper extension
+ */
+
+static void ext_variables_code_dumper_free
+	(struct sieve_code_dumper *dumper, void *context);
+
+const struct sieve_code_dumper_extension variables_dump_extension = {
+	&variables_extension,
+	ext_variables_code_dumper_free
+};
+
+/*
+ * Code dump context
+ */
+
+struct ext_variables_dump_context {
+	struct sieve_variable_scope *main_scope;
+	ARRAY_DEFINE(ext_scopes, struct sieve_variable_scope *);
+};
+
+static void ext_variables_code_dumper_free
+(struct sieve_code_dumper *dumper ATTR_UNUSED, void *context)
+{
+	struct ext_variables_dump_context *dctx =
+		(struct ext_variables_dump_context *) context;
+
+	if ( dctx == NULL || dctx->main_scope == NULL )
+		return;
+
+	sieve_variable_scope_unref(&dctx->main_scope);
+}
+
+static struct ext_variables_dump_context *ext_variables_dump_get_context
+(const struct sieve_extension *this_ext, const struct sieve_dumptime_env *denv)
+{
+	struct sieve_code_dumper *dumper = denv->cdumper;
+	struct ext_variables_dump_context *dctx = sieve_dump_extension_get_context
+		(dumper, this_ext);
+	pool_t pool;
+
+	if ( dctx == NULL ) {
+		/* Create dumper context */
+		pool = sieve_code_dumper_pool(dumper);
+		dctx = p_new(pool, struct ext_variables_dump_context, 1);
+		p_array_init(&dctx->ext_scopes, pool,
+			sieve_extensions_get_count(this_ext->svinst));
+
+		sieve_dump_extension_set_context(dumper, this_ext, dctx);
+	}
+
+	return dctx;
+}
+
+bool ext_variables_code_dump
+(const struct sieve_extension *ext,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	struct ext_variables_dump_context *dctx;
+	struct sieve_variable_scope *main_scope;
+	unsigned int i, scope_size;
+	sieve_size_t pc;
+	int end_offset;
+
+	sieve_code_mark(denv);
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &scope_size) )
+		return FALSE;
+
+	pc = *address;
+	if ( !sieve_binary_read_offset(denv->sbin, address, &end_offset) )
+		return FALSE;
+
+	main_scope = sieve_variable_scope_create(NULL);
+
+	sieve_code_dumpf(denv, "SCOPE [%u] (end: %08x)",
+		scope_size, (unsigned int) (pc + end_offset));
+
+	/* Read main variable scope */
+
+	for ( i = 0; i < scope_size; i++ ) {
+		string_t *identifier;
+
+		sieve_code_mark(denv);
+		if (!sieve_binary_read_string(denv->sbin, address, &identifier) ) {
+			return FALSE;
+		}
+
+		sieve_code_dumpf(denv, "%3d: '%s'", i, str_c(identifier));
+
+		(void) sieve_variable_scope_declare(main_scope, str_c(identifier));
+	}
+
+	dctx = ext_variables_dump_get_context(ext, denv);
+	dctx->main_scope = main_scope;
+
+	return TRUE;
+}
+
+/*
+ * Scope registry
+ */
+
+void sieve_ext_variables_dump_set_scope
+(const struct sieve_extension *var_ext, const struct sieve_dumptime_env *denv,
+	const struct sieve_extension *ext, struct sieve_variable_scope *scope)
+{
+	struct ext_variables_dump_context *dctx =
+		ext_variables_dump_get_context(var_ext, denv);
+
+	if ( ext->id < 0 ) return;
+
+	array_idx_set(&dctx->ext_scopes, (unsigned int) ext->id, &scope);
+}
+
+/*
+ * Variable identifier dump
+ */
+
+const char *ext_variables_dump_get_identifier
+(const struct sieve_extension *var_ext, const struct sieve_dumptime_env *denv,
+	const struct sieve_extension *ext, unsigned int index)
+{
+	struct ext_variables_dump_context *dctx =
+		ext_variables_dump_get_context(var_ext, denv);
+	struct sieve_variable_scope *scope;
+	struct sieve_variable *var;
+
+	if ( ext == NULL )
+		scope = dctx->main_scope;
+	else {
+		struct sieve_variable_scope *const *ext_scope;
+
+		if  ( ext->id < 0 || ext->id >= (int) array_count(&dctx->ext_scopes) )
+			return NULL;
+
+		ext_scope = array_idx(&dctx->ext_scopes, (unsigned int) ext->id);
+		scope = *ext_scope;
+	}
+
+	if ( scope == NULL )
+		return NULL;
+
+	var = sieve_variable_scope_get_indexed(scope, index);
+
+	return var->identifier;
+}
+
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-dump.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-dump.h
@@ -0,0 +1,25 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_DUMP_H
+#define __EXT_VARIABLES_DUMP_H
+
+#include "sieve-common.h"
+
+/*
+ * Code dump context
+ */
+
+bool ext_variables_code_dump
+	(const struct sieve_extension *ext, const struct sieve_dumptime_env *denv,
+		sieve_size_t *address);
+
+/*
+ * Variable identifier dump
+ */
+
+const char *ext_variables_dump_get_identifier
+(const struct sieve_extension *var_ext, const struct sieve_dumptime_env *denv,
+	const struct sieve_extension *ext, unsigned int index);
+
+#endif /* __EXT_VARIABLES_DUMP_H */
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-limits.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-limits.h
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_LIMITS_H
+#define __EXT_VARIABLES_LIMITS_H
+
+#include "sieve-limits.h"
+
+/* From RFC 5229:
+ *
+ * 6.  Implementation Limits
+ *
+ *  An implementation of this document MUST support at least 128 distinct
+ *  variables.  The supported length of variable names MUST be at least
+ *  32 characters.  Each variable MUST be able to hold at least 4000
+ *  characters.  Attempts to set the variable to a value larger than what
+ *  the implementation supports SHOULD be reported as an error at
+ *  compile-time if possible.  If the attempt is discovered during run-
+ *  time, the value SHOULD be truncated, and it MUST NOT be treated as an
+ *  error.
+
+ *  Match variables ${1} through ${9} MUST be supported.  References to
+ *  higher indices than those the implementation supports MUST be treated
+ *  as a syntax error, which SHOULD be discovered at compile-time.
+ */
+
+#define SIEVE_VARIABLES_MAX_SCOPE_SIZE              255
+#define SIEVE_VARIABLES_MAX_VARIABLE_NAME_LEN       64
+#define SIEVE_VARIABLES_MAX_VARIABLE_SIZE           (4 * 1024)
+#define SIEVE_VARIABLES_MAX_NAMESPACE_ELEMENTS      4
+
+#define SIEVE_VARIABLES_MAX_MATCH_INDEX             SIEVE_MAX_MATCH_VALUES
+
+#endif /* __EXT_VARIABLES_LIMITS_H */
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c
@@ -0,0 +1,270 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-modifiers.h"
+
+#include <ctype.h>
+
+/*
+ * Core modifiers
+ */
+
+extern const struct sieve_variables_modifier_def lower_modifier;
+extern const struct sieve_variables_modifier_def upper_modifier;
+extern const struct sieve_variables_modifier_def lowerfirst_modifier;
+extern const struct sieve_variables_modifier_def upperfirst_modifier;
+extern const struct sieve_variables_modifier_def quotewildcard_modifier;
+extern const struct sieve_variables_modifier_def length_modifier;
+
+enum ext_variables_modifier_code {
+    EXT_VARIABLES_MODIFIER_LOWER,
+    EXT_VARIABLES_MODIFIER_UPPER,
+    EXT_VARIABLES_MODIFIER_LOWERFIRST,
+    EXT_VARIABLES_MODIFIER_UPPERFIRST,
+    EXT_VARIABLES_MODIFIER_QUOTEWILDCARD,
+    EXT_VARIABLES_MODIFIER_LENGTH
+};
+
+const struct sieve_variables_modifier_def *ext_variables_core_modifiers[] = {
+	&lower_modifier,
+	&upper_modifier,
+	&lowerfirst_modifier,
+	&upperfirst_modifier,
+	&quotewildcard_modifier,
+	&length_modifier
+};
+
+const unsigned int ext_variables_core_modifiers_count =
+    N_ELEMENTS(ext_variables_core_modifiers);
+
+#define ext_variables_modifier_name(modf) \
+	(modf)->object->def->name
+#define ext_variables_modifiers_equal(modf1, modf2) \
+	( (modf1)->def == (modf2)->def )
+#define ext_variables_modifiers_equal_precedence(modf1, modf2) \
+	( (modf1)->def->precedence == (modf2)->def->precendence )
+
+/*
+ * Modifier registry
+ */
+
+void sieve_variables_modifier_register
+(const struct sieve_extension *var_ext, struct sieve_validator *valdtr,
+	const struct sieve_extension *ext,
+	const struct sieve_variables_modifier_def *smodf_def)
+{
+	struct ext_variables_validator_context *ctx =
+		ext_variables_validator_context_get(var_ext, valdtr);
+
+	sieve_validator_object_registry_add(ctx->modifiers, ext, &smodf_def->obj_def);
+}
+
+bool ext_variables_modifier_exists
+(const struct sieve_extension *var_ext, struct sieve_validator *valdtr,
+	const char *identifier)
+{
+	struct ext_variables_validator_context *ctx =
+		ext_variables_validator_context_get(var_ext, valdtr);
+
+	return sieve_validator_object_registry_find(ctx->modifiers, identifier, NULL);
+}
+
+const struct sieve_variables_modifier *ext_variables_modifier_create_instance
+(const struct sieve_extension *var_ext, struct sieve_validator *valdtr,
+	struct sieve_command *cmd, const char *identifier)
+{
+	struct ext_variables_validator_context *ctx =
+		ext_variables_validator_context_get(var_ext, valdtr);
+	struct sieve_object object;
+	struct sieve_variables_modifier *modf;
+	pool_t pool;
+
+	if ( !sieve_validator_object_registry_find
+		(ctx->modifiers, identifier, &object) )
+		return NULL;
+
+	pool = sieve_command_pool(cmd);
+	modf = p_new(pool, struct sieve_variables_modifier, 1);
+	modf->object = object;
+	modf->def = (const struct sieve_variables_modifier_def *) object.def;
+
+  return modf;
+}
+
+void ext_variables_register_core_modifiers
+(const struct sieve_extension *ext, struct ext_variables_validator_context *ctx)
+{
+	unsigned int i;
+
+	/* Register core modifiers*/
+	for ( i = 0; i < ext_variables_core_modifiers_count; i++ ) {
+		sieve_validator_object_registry_add
+			(ctx->modifiers, ext, &(ext_variables_core_modifiers[i]->obj_def));
+	}
+}
+
+/*
+ * Modifier coding
+ */
+
+const struct sieve_operand_class sieve_variables_modifier_operand_class =
+	{ "modifier" };
+
+static const struct sieve_extension_objects core_modifiers =
+	SIEVE_VARIABLES_DEFINE_MODIFIERS(ext_variables_core_modifiers);
+
+const struct sieve_operand_def modifier_operand = {
+	"modifier",
+	&variables_extension,
+	EXT_VARIABLES_OPERAND_MODIFIER,
+	&sieve_variables_modifier_operand_class,
+	&core_modifiers
+};
+
+/*
+ * Core modifiers
+ */
+
+/* Forward declarations */
+
+bool mod_lower_modify(string_t *in, string_t **result);
+bool mod_upper_modify(string_t *in, string_t **result);
+bool mod_lowerfirst_modify(string_t *in, string_t **result);
+bool mod_upperfirst_modify(string_t *in, string_t **result);
+bool mod_length_modify(string_t *in, string_t **result);
+bool mod_quotewildcard_modify(string_t *in, string_t **result);
+
+/* Modifier objects */
+
+const struct sieve_variables_modifier_def lower_modifier = {
+	SIEVE_OBJECT("lower", &modifier_operand, EXT_VARIABLES_MODIFIER_LOWER),
+	40,
+	mod_lower_modify
+};
+
+const struct sieve_variables_modifier_def upper_modifier = {
+	SIEVE_OBJECT("upper", &modifier_operand, EXT_VARIABLES_MODIFIER_UPPER),
+	40,
+	mod_upper_modify
+};
+
+const struct sieve_variables_modifier_def lowerfirst_modifier = {
+	SIEVE_OBJECT
+		("lowerfirst", &modifier_operand, EXT_VARIABLES_MODIFIER_LOWERFIRST),
+	30,
+	mod_lowerfirst_modify
+};
+
+const struct sieve_variables_modifier_def upperfirst_modifier = {
+	SIEVE_OBJECT
+		("upperfirst", &modifier_operand,	EXT_VARIABLES_MODIFIER_UPPERFIRST),
+	30,
+	mod_upperfirst_modify
+};
+
+const struct sieve_variables_modifier_def quotewildcard_modifier = {
+	SIEVE_OBJECT
+		("quotewildcard", &modifier_operand, EXT_VARIABLES_MODIFIER_QUOTEWILDCARD),
+	20,
+	mod_quotewildcard_modify
+};
+
+const struct sieve_variables_modifier_def length_modifier = {
+	SIEVE_OBJECT("length", &modifier_operand, EXT_VARIABLES_MODIFIER_LENGTH),
+	10,
+	mod_length_modify
+};
+
+/* Modifier implementations */
+
+bool mod_upperfirst_modify(string_t *in, string_t **result)
+{
+	char *content;
+
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content[0] = i_toupper(content[0]);
+
+	return TRUE;
+}
+
+bool mod_lowerfirst_modify(string_t *in, string_t **result)
+{
+	char *content;
+
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content[0] = i_tolower(content[0]);
+
+	return TRUE;
+}
+
+bool mod_upper_modify(string_t *in, string_t **result)
+{
+	char *content;
+
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content = str_ucase(content);
+
+	return TRUE;
+}
+
+bool mod_lower_modify(string_t *in, string_t **result)
+{
+	char *content;
+
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content = str_lcase(content);
+
+	return TRUE;
+}
+
+bool mod_length_modify(string_t *in, string_t **result)
+{
+	*result = t_str_new(64);
+	str_printfa(*result, "%llu", (unsigned long long) str_len(in));
+
+	return TRUE;
+}
+
+bool mod_quotewildcard_modify(string_t *in, string_t **result)
+{
+	unsigned int i;
+	const char *content;
+
+	*result = t_str_new(str_len(in) * 2);
+	content = (const char *) str_data(in);
+
+	for ( i = 0; i < str_len(in); i++ ) {
+		if ( content[i] == '*' || content[i] == '?' || content[i] == '\\' ) {
+			str_append_c(*result, '\\');
+		}
+		str_append_c(*result, content[i]);
+	}
+
+	return TRUE;
+}
+
+
+
+
+
+
+
+
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_MODIFIERS_H
+#define __EXT_VARIABLES_MODIFIERS_H
+
+#include "ext-variables-common.h"
+#include "sieve-ext-variables.h"
+
+/*
+ * Modifier registry
+ */
+
+bool ext_variables_modifier_exists
+	(const struct sieve_extension *var_ext, struct sieve_validator *valdtr,
+		const char *identifier);
+const struct sieve_variables_modifier *ext_variables_modifier_create_instance
+	(const struct sieve_extension *var_ext, struct sieve_validator *valdtr,
+		struct sieve_command *cmd, const char *identifier);
+
+void ext_variables_register_core_modifiers
+	(const struct sieve_extension *var_ext,
+		struct ext_variables_validator_context *ctx);
+
+/*
+ * Modifier operand
+ */
+
+extern const struct sieve_operand_def modifier_operand;
+
+static inline void ext_variables_opr_modifier_emit
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	const struct sieve_variables_modifier_def *modf_def)
+{
+	sieve_opr_object_emit(sbin, ext, &modf_def->obj_def);
+}
+
+static inline bool ext_variables_opr_modifier_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_variables_modifier *modf)
+{
+	if ( !sieve_opr_object_read
+		(renv, &sieve_variables_modifier_operand_class, address, &modf->object) )
+		return FALSE;
+
+	modf->def = (const struct sieve_variables_modifier_def *) modf->object.def;
+	return TRUE;
+}
+
+static inline bool ext_variables_opr_modifier_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_variables_modifier_operand_class, address, NULL);
+}
+
+#endif /* __EXT_VARIABLES_MODIFIERS_H */
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-name.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-name.c
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-limits.h"
+#include "ext-variables-name.h"
+
+#include <ctype.h>
+
+int ext_variable_name_parse
+(ARRAY_TYPE(ext_variable_name) *vname, const char **str, const char *strend)
+{
+	const char *p = *str;
+	int nspace_used = 0;
+
+	for (;;) {
+		struct ext_variable_name *cur_element;
+		string_t *cur_ident;
+
+		/* Acquire current position in the substitution structure or allocate
+		 * a new one if this substitution consists of more elements than before.
+		 */
+		if ( nspace_used < (int) array_count(vname) ) {
+			cur_element = array_idx_modifiable
+				(vname, (unsigned int) nspace_used);
+			cur_ident = cur_element->identifier;
+		} else {
+			if ( nspace_used >= SIEVE_VARIABLES_MAX_NAMESPACE_ELEMENTS )
+				return -1;
+			cur_element = array_append_space(vname);
+			cur_ident = cur_element->identifier = t_str_new(32);
+		}
+
+		/* Identifier */
+		if ( *p == '_' || i_isalpha(*p) ) {
+			cur_element->num_variable = -1;
+			str_truncate(cur_ident, 0);
+			str_append_c(cur_ident, *p);
+			p++;
+
+			while ( p < strend && (*p == '_' || i_isalnum(*p)) ) {
+				if ( str_len(cur_ident) >= SIEVE_VARIABLES_MAX_VARIABLE_NAME_LEN )
+					return -1;
+				str_append_c(cur_ident, *p);
+				p++;
+			}
+
+		/* Num-variable */
+		} else if ( i_isdigit(*p) ) {
+			cur_element->num_variable = *p - '0';
+			p++;
+
+			while ( p < strend && i_isdigit(*p) ) {
+				cur_element->num_variable = cur_element->num_variable*10 + (*p - '0');
+				p++;
+			}
+
+			/* If a num-variable is first, no more elements can follow because no
+			 * namespace is specified.
+			 */
+			if ( nspace_used == 0 ) {
+				*str = p;
+				return 1;
+			}
+		} else {
+			*str = p;
+			return -1;
+		}
+
+		nspace_used++;
+
+		if ( p < strend && *p == '.' )
+			p++;
+		else
+			break;
+	}
+
+	*str = p;
+	return nspace_used;
+}
+
+
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-name.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-name.h
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_NAME
+#define __EXT_VARIABLES_NAME
+
+/* Variable Substitution
+ * ---------------------
+ *
+ * The variable strings are preprocessed into an AST list consisting of variable
+ * substitutions and constant parts of the string. The variables to which
+ * the substitutions link are looked up and their index in their scope storage
+ * is what is added to the list and eventually emitted as byte code. So in byte
+ * code a variable string will look as a series of substrings interrupted by
+ * integer operands that refer to variables. During execution the strings and
+ * the looked-up variables are concatenated to obtain the desired result. The
+ * the variable references are simple indexes into an array of variables, so
+ * looking these up during execution is a trivial process.
+ *
+ * However (RFC 5229):
+ *   Tests or actions in future extensions may need to access the
+ *   unexpanded version of the string argument and, e.g., do the expansion
+ *   after setting variables in its namespace.  The design of the
+ *   implementation should allow this.
+ *
+ * Various options exist to provide this feature. If the extension is entirely
+ * namespace-based there is actually not very much of a problem. The variable
+ * list can easily be extended with new argument-types that refer to a variable
+ * identifier in stead of an index in the variable's storage.
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "ext-variables-common.h"
+
+/*
+ * Types
+ */
+
+struct ext_variable_name {
+	string_t *identifier;
+	int num_variable;
+};
+
+ARRAY_DEFINE_TYPE(ext_variable_name, struct ext_variable_name);
+
+/*
+ * Variable name parsing
+ */
+
+int ext_variable_name_parse
+	(ARRAY_TYPE(ext_variable_name) *vname, const char **str, const char *strend);
+
+#endif /* __EXT_VARIABLES_NAME */
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-operands.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-operands.c
@@ -0,0 +1,252 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-match-types.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-name.h"
+#include "ext-variables-dump.h"
+#include "ext-variables-operands.h"
+
+/*
+ * Variable operand
+ */
+
+static bool opr_variable_read_value
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, string_t **str);
+static bool opr_variable_dump
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name);
+
+const struct sieve_opr_string_interface variable_interface = {
+	opr_variable_dump,
+	opr_variable_read_value
+};
+
+const struct sieve_operand_def variable_operand = {
+	"variable",
+	&variables_extension,
+	EXT_VARIABLES_OPERAND_VARIABLE,
+	&string_class,
+	&variable_interface
+};
+
+void ext_variables_opr_variable_emit
+(struct sieve_binary *sbin, const struct sieve_extension *var_ext,
+	struct sieve_variable *var)
+{
+	if ( var->ext == NULL ) {
+		/* Default variable storage */
+		(void) sieve_operand_emit(sbin, var_ext, &variable_operand);
+		(void) sieve_binary_emit_byte(sbin, 0);
+		(void) sieve_binary_emit_unsigned(sbin, var->index);
+		return;
+	}
+
+	(void) sieve_operand_emit(sbin, var_ext, &variable_operand);
+	(void) sieve_binary_emit_extension(sbin, var->ext, 1);
+	(void) sieve_binary_emit_unsigned(sbin, var->index);
+}
+
+static bool opr_variable_dump
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name)
+{
+	const struct sieve_extension *this_ext = operand->ext;
+	unsigned int index = 0;
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	const char *identifier;
+
+	if ( !sieve_binary_read_extension(denv->sbin, address, &code, &ext) )
+		return FALSE;
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &index) )
+		return FALSE;
+
+	identifier = ext_variables_dump_get_identifier(this_ext, denv, ext, index);
+	identifier = identifier == NULL ? "??" : identifier;
+
+	if ( ext == NULL ) {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: VAR ${%s} (%ld)",
+				field_name, identifier, (long) index);
+		else
+			sieve_code_dumpf(denv, "VAR ${%s} (%ld)",
+				identifier, (long) index);
+	} else {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: VAR [%s] ${%s} (%ld)",
+				field_name, sieve_extension_name(ext), identifier, (long) index);
+		else
+			sieve_code_dumpf(denv, "VAR [%s] ${%s} (%ld)",
+				sieve_extension_name(ext), identifier, (long) index);
+	}
+	return TRUE;
+}
+
+static bool opr_variable_read_value
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t *address, string_t **str)
+{
+	const struct sieve_extension *this_ext = operand->ext;
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	struct sieve_variable_storage *storage;
+	unsigned int index = 0;
+
+	if ( !sieve_binary_read_extension(renv->sbin, address, &code, &ext) )
+		return FALSE;
+
+	storage = sieve_ext_variables_get_storage(this_ext, renv->interp, ext);
+	if ( storage == NULL )
+		return FALSE;
+
+	if (sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+		/* Parameter str can be NULL if we are requested to only skip and not
+		 * actually read the argument.
+		 */
+		if ( str != NULL ) {
+			if ( !sieve_variable_get(storage, index, str) )
+				return FALSE;
+
+			if ( *str == NULL ) *str = t_str_new(0);
+		}
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+bool sieve_variable_operand_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t *address, struct sieve_variable_storage **storage,
+	unsigned int *var_index)
+{
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	unsigned int idx = 0;
+
+	if ( !sieve_operand_is_variable(operand) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_binary_read_extension(renv->sbin, address, &code, &ext) )
+		return FALSE;
+
+	*storage = sieve_ext_variables_get_storage(operand->ext, renv->interp, ext);
+	if ( *storage == NULL )
+		return FALSE;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &idx) )
+		return FALSE;
+
+	*var_index = idx;
+	return TRUE;
+}
+
+bool sieve_variable_operand_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_variable_storage **storage, unsigned int *var_index)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) )
+		return FALSE;
+
+	return sieve_variable_operand_read_data
+		(renv, &operand, address, storage, var_index);
+}
+
+/*
+ * Match value operand
+ */
+
+static bool opr_match_value_read
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, string_t **str);
+static bool opr_match_value_dump
+	(const struct sieve_dumptime_env *denv,  const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name);
+
+const struct sieve_opr_string_interface match_value_interface = {
+	opr_match_value_dump,
+	opr_match_value_read
+};
+
+const struct sieve_operand_def match_value_operand = {
+	"match-value",
+	&variables_extension,
+	EXT_VARIABLES_OPERAND_MATCH_VALUE,
+	&string_class,
+	&match_value_interface
+};
+
+void ext_variables_opr_match_value_emit
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	unsigned int index)
+{
+	(void) sieve_operand_emit(sbin, ext, &match_value_operand);
+	(void) sieve_binary_emit_unsigned(sbin, index);
+}
+
+static bool opr_match_value_dump
+(const struct sieve_dumptime_env *denv,
+	const struct sieve_operand *operand ATTR_UNUSED,
+	sieve_size_t *address, const char *field_name)
+{
+	unsigned int index = 0;
+
+	if (sieve_binary_read_unsigned(denv->sbin, address, &index) ) {
+		if ( field_name != NULL )
+			sieve_code_dumpf
+				(denv, "%s: MATCHVAL %lu", field_name, (unsigned long) index);
+		else
+			sieve_code_dumpf(denv, "MATCHVAL %lu", (unsigned long) index);
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static bool opr_match_value_read
+(const struct sieve_runtime_env *renv,
+	const struct sieve_operand *operand ATTR_UNUSED,
+	sieve_size_t *address, string_t **str)
+{
+	unsigned int index = 0;
+
+	if (sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+		/* Parameter str can be NULL if we are requested to only skip and not
+		 * actually read the argument.
+		 	*/
+		if ( str != NULL ) {
+			sieve_match_values_get(renv->interp, index, str);
+
+			if ( *str == NULL )
+				*str = t_str_new(0);
+			else if ( str_len(*str) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+				str_truncate(*str, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+		}
+		return TRUE;
+	}
+
+	return FALSE;
+}
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables-operands.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables-operands.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_OPERANDS_H
+#define __EXT_VARIABLES_OPERANDS_H
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "ext-variables-common.h"
+
+/*
+ * Variable operand
+ */
+
+extern const struct sieve_operand_def variable_operand;
+
+void ext_variables_opr_variable_emit
+	(struct sieve_binary *sbin, const struct sieve_extension *var_ext,
+		struct sieve_variable *var);
+
+bool ext_variables_opr_variable_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_variable_storage **storage, unsigned int *var_index);
+
+/*
+ * Match value operand
+ */
+
+extern const struct sieve_operand_def match_value_operand;
+
+void ext_variables_opr_match_value_emit
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		unsigned int index);
+
+/*
+ * Variable string operand
+ */
+
+void ext_variables_opr_variable_string_emit
+	(struct sieve_binary *sbin, unsigned int elements);
+
+
+#endif /* __EXT_VARIABLES_OPERANDS_H */
+
Index: b/sieve/src/lib-sieve/plugins/variables/ext-variables.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/ext-variables.c
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension variables
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5229
+ * Implementation: mostly full; no support for future namespaces
+ * Status: experimental, not thoroughly tested
+ *
+ */
+
+/* FIXME: This implementation of the variables extension does not support
+ * namespaces. It recognizes them, but there is currently no support to let
+ * an extension register a new namespace. Currently no such extension exists
+ * and therefore this support has a very low implementation priority.
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-validator.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-arguments.h"
+#include "ext-variables-operands.h"
+#include "ext-variables-modifiers.h"
+#include "ext-variables-dump.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation_def *ext_variables_operations[] = {
+	&cmd_set_operation,
+	&tst_string_operation
+};
+
+/*
+ * Operands
+ */
+
+const struct sieve_operand_def *ext_variables_operands[] = {
+	&variable_operand,
+	&match_value_operand,
+	&modifier_operand
+};
+
+/*
+ * Extension
+ */
+
+static bool ext_variables_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *validator);
+
+const struct sieve_extension_def variables_extension = {
+	"variables",
+	NULL, NULL,
+	ext_variables_validator_load,
+	ext_variables_generator_load,
+	ext_variables_interpreter_load,
+	NULL, NULL,
+	ext_variables_code_dump,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_variables_operations),
+	SIEVE_EXT_DEFINE_OPERANDS(ext_variables_operands)
+};
+
+static bool ext_variables_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator)
+{
+	sieve_validator_argument_override
+		(validator, SAT_VAR_STRING, ext, &variable_string_argument);
+
+	sieve_validator_register_command(validator, ext, &cmd_set);
+	sieve_validator_register_command(validator, ext, &tst_string);
+
+	ext_variables_validator_initialize(ext, validator);
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h
@@ -0,0 +1,190 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/*
+ * Public interface for other extensions to use
+ */
+
+#ifndef __SIEVE_EXT_VARIABLES_H
+#define __SIEVE_EXT_VARIABLES_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-objects.h"
+#include "sieve-code.h"
+
+#include "ext-variables-limits.h"
+
+/*
+ * Variable extension
+ */
+
+/* FIXME: this is not suitable for future plugin support */
+
+extern const struct sieve_extension_def variables_extension;
+
+static inline const struct sieve_extension *sieve_ext_variables_get_extension
+(struct sieve_instance *svinst)
+{
+	return sieve_extension_register(svinst, &variables_extension, FALSE);
+}
+
+/*
+ * Variable scope
+ */
+
+struct sieve_variable {
+	const char *identifier;
+	unsigned int index;
+
+	const struct sieve_extension *ext;
+	void *context;
+};
+
+struct sieve_variable_scope;
+
+struct sieve_variable_scope *sieve_variable_scope_create
+	(const struct sieve_extension *ext);
+void sieve_variable_scope_ref
+	(struct sieve_variable_scope *scope);
+void sieve_variable_scope_unref
+	(struct sieve_variable_scope **scope);
+pool_t sieve_variable_scope_pool
+	(struct sieve_variable_scope *scope);
+
+struct sieve_variable *sieve_variable_scope_declare
+	(struct sieve_variable_scope *scope, const char *identifier);
+struct sieve_variable *sieve_variable_scope_import
+	(struct sieve_variable_scope *scope, struct sieve_variable *var);
+struct sieve_variable *sieve_variable_scope_get_variable
+	(struct sieve_variable_scope *scope, const char *identifier, bool create);
+struct sieve_variable *sieve_variable_scope_get_indexed
+	(struct sieve_variable_scope *scope, unsigned int index);
+
+/* Iteration over all declared variables */
+
+struct sieve_variable_scope_iter;
+
+struct sieve_variable_scope_iter *sieve_variable_scope_iterate_init
+	(struct sieve_variable_scope *scope);
+bool sieve_variable_scope_iterate
+	(struct sieve_variable_scope_iter *iter, struct sieve_variable **var_r);
+void sieve_variable_scope_iterate_deinit
+	(struct sieve_variable_scope_iter **iter);
+
+/* Statistics */
+
+unsigned int sieve_variable_scope_declarations
+	(struct sieve_variable_scope *scope);
+unsigned int sieve_variable_scope_size
+	(struct sieve_variable_scope *scope);
+
+/* Get all native variables */
+
+struct sieve_variable * const *sieve_variable_scope_get_variables
+	(struct sieve_variable_scope *scope, unsigned int *size_r);
+
+/*
+ * Variable storage
+ */
+
+struct sieve_variable_storage;
+
+struct sieve_variable_storage *sieve_variable_storage_create
+	(pool_t pool, struct sieve_variable_scope *scope, unsigned int max_size);
+bool sieve_variable_get
+	(struct sieve_variable_storage *storage, unsigned int index,
+		string_t **value);
+bool sieve_variable_get_modifiable
+	(struct sieve_variable_storage *storage, unsigned int index,
+		string_t **value);
+bool sieve_variable_assign
+	(struct sieve_variable_storage *storage, unsigned int index,
+		const string_t *value);
+bool sieve_variable_get_identifier
+	(struct sieve_variable_storage *storage, unsigned int index,
+		const char **identifier);
+
+/*
+ * Variables access
+ */
+
+bool sieve_ext_variables_is_active
+	(const struct sieve_extension *var_ext, struct sieve_validator *valdtr);
+
+struct sieve_variable_scope *sieve_ext_variables_get_main_scope
+	(const struct sieve_extension *var_ext, struct sieve_validator *valdtr);
+
+struct sieve_variable_storage *sieve_ext_variables_get_storage
+	(const struct sieve_extension *var_ext, struct sieve_interpreter *interp,
+		const struct sieve_extension *ext);
+void sieve_ext_variables_set_storage
+	(const struct sieve_extension *var_ext, struct sieve_interpreter *interp,
+		struct sieve_variable_storage *storage, const struct sieve_extension *ext);
+
+/*
+ * Variable arguments
+ */
+
+bool sieve_variable_argument_activate
+(const struct sieve_extension *this_ext, struct sieve_validator *valdtr,
+	struct sieve_command *cmd, struct sieve_ast_argument *arg, bool assignment);
+
+/*
+ * Variable operands
+ */
+
+extern const struct sieve_operand_def variable_operand;
+
+bool sieve_variable_operand_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, struct sieve_variable_storage **storage,
+		unsigned int *var_index);
+bool sieve_variable_operand_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_variable_storage **storage, unsigned int *var_index);
+
+static inline bool sieve_operand_is_variable
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->def != NULL &&
+		operand->def == &variable_operand );
+}
+
+/*
+ * Modifiers
+ */
+
+struct sieve_variables_modifier_def {
+	struct sieve_object_def obj_def;
+
+	unsigned int precedence;
+
+	bool (*modify)(string_t *in, string_t **result);
+};
+
+struct sieve_variables_modifier {
+	struct sieve_object object;
+
+	const struct sieve_variables_modifier_def *def;
+};
+
+extern const struct sieve_operand_class sieve_variables_modifier_operand_class;
+
+#define SIEVE_VARIABLES_DEFINE_MODIFIER(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_VARIABLES_DEFINE_MODIFIERS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+void sieve_variables_modifier_register
+	(const struct sieve_extension *var_ext, struct sieve_validator *valdtr,
+		const struct sieve_extension *ext,
+		const struct sieve_variables_modifier_def *smodf);
+
+/*
+ * Code dumping
+ */
+
+void sieve_ext_variables_dump_set_scope
+(const struct sieve_extension *var_ext, const struct sieve_dumptime_env *denv,
+	const struct sieve_extension *ext, struct sieve_variable_scope *scope);
+
+#endif /* __SIEVE_EXT_VARIABLES_H */
Index: b/sieve/src/lib-sieve/plugins/variables/tst-string.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/plugins/variables/tst-string.c
@@ -0,0 +1,246 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-variables-common.h"
+
+/*
+ * String test
+ *
+ * Syntax:
+ *   string [COMPARATOR] [MATCH-TYPE]
+ *     <source: string-list> <key-list: string-list>
+ */
+
+static bool tst_string_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_string_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def tst_string = {
+	"string",
+	SCT_TEST,
+	2, 0, FALSE, FALSE,
+	tst_string_registered,
+	NULL,
+	tst_string_validate,
+	tst_string_generate,
+	NULL
+};
+
+/*
+ * String operation
+ */
+
+static bool tst_string_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_string_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def tst_string_operation = {
+	"STRING",
+	&variables_extension,
+	EXT_VARIABLES_OPERATION_STRING,
+	tst_string_operation_dump,
+	tst_string_operation_execute
+};
+
+/*
+ * Optional arguments
+ */
+
+enum tst_string_optional {
+	OPT_END,
+	OPT_COMPARATOR,
+	OPT_MATCH_TYPE
+};
+
+/*
+ * Test registration
+ */
+
+static bool tst_string_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Test validation
+ */
+
+static bool tst_string_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	const struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	const struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "source", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Test generation
+ */
+
+static bool tst_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &tst_string_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_string_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "STRING-TEST");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "source") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_string_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *source;
+	struct sieve_coded_stringlist *key_list;
+	string_t *src_item;
+	bool matched;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+		return ret;
+
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read source */
+	if ( (source=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid source operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "STRING test");
+
+	mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+	/* Iterate through all requested strings to match */
+	src_item = NULL;
+	matched = FALSE;
+	while ( result && !matched &&
+		(result=sieve_coded_stringlist_next_item(source, &src_item))
+		&& src_item != NULL ) {
+		const char *src = str_len(src_item) > 0 ? str_c(src_item) : NULL;
+
+		if ( (mret=sieve_match_value
+			(mctx, src, str_len(src_item))) < 0 ) {
+			result = FALSE;
+			break;
+		}
+
+		matched = ( mret > 0 );
+	}
+
+	if ( (mret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( mret > 0 || matched );
+
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/rfc2822.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/rfc2822.c
@@ -0,0 +1,222 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* NOTE: much of the functionality implemented here should eventually appear
+ * somewhere in Dovecot itself.
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "rfc2822.h"
+
+#include "message-header-encode.h"
+
+#include <stdio.h>
+#include <ctype.h>
+
+bool rfc2822_header_field_name_verify
+(const char *field_name, unsigned int len)
+{
+	const char *p = field_name;
+	const char *pend = p + len;
+
+	/* field-name   =   1*ftext
+	 * ftext        =   %d33-57 /               ; Any character except
+	 *                  %d59-126                ;  controls, SP, and
+	 *                                          ;  ":".
+	 */
+
+	while ( p < pend ) {
+		if ( *p < 33 || *p == ':' )
+			return FALSE;
+
+		p++;
+	}
+
+	return TRUE;
+}
+
+bool rfc2822_header_field_body_verify
+(const char *field_body, unsigned int len)
+{
+	const char *p = field_body;
+	const char *pend = p + len;
+
+	/* unstructured    =       *([FWS] utext) [FWS]
+	 * FWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space
+	 *                         obs-FWS
+	 * utext           =       NO-WS-CTL /     ; Non white space controls
+	 *                         %d33-126 /      ; The rest of US-ASCII
+	 *                         obs-utext
+	 * NO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters
+	 *                         %d11 /          ;  that do not include the
+	 *                         %d12 /          ;  carriage return, line feed,
+	 *                         %d14-31 /       ;  and white space characters
+	 *                         %d127
+	 * WSP             =  SP / HTAB
+	 */
+
+	/* This verification does not allow content to be folded. This should done
+	 * automatically upon message composition.
+	 */
+
+	while ( p < pend ) {
+		if ( *p == '\0' || *p == '\r' || *p == '\n' || ((unsigned char)*p) > 127 )
+			return FALSE;
+
+		p++;
+	}
+
+	return TRUE;
+}
+
+/*
+ *
+ */
+
+const char *rfc2822_header_field_name_sanitize(const char *name)
+{
+	char *result = t_strdup_noconst(name);
+	char *p;
+
+	/* Make the whole name lower case ... */
+	result = str_lcase(result);
+
+	/* ... except for the first letter and those that follow '-' */
+	p = result;
+	*p = i_toupper(*p);
+	while ( *p != '\0' ) {
+		if ( *p == '-' ) {
+			p++;
+
+			if ( *p != '\0' )
+				*p = i_toupper(*p);
+
+			continue;
+		}
+
+		p++;
+	}
+
+	return result;
+}
+
+/*
+ * Message construction
+ */
+
+/* FIXME: This should be collected into a Dovecot API for composing internet
+ * mail messages. These functions now use FILE * output streams, but this should
+ * be changed to proper dovecot streams.
+ */
+
+static inline bool rfc2822_write(FILE *f, const char *data, size_t len)
+{
+	return ( fwrite(data, len, 1, f) == 1 );
+}
+
+int rfc2822_header_field_write
+(FILE *f, const char *name, const char *body)
+{
+	static const unsigned int max_line = 80;
+
+	const char *bp = body;  /* Pointer */
+	const char *sp = body;  /* Start pointer */
+	const char *wp = NULL;  /* Whitespace pointer */
+	const char *nlp = NULL; /* New-line pointer */
+	unsigned int line_len = strlen(name);
+	int len = 0;
+
+	/* Write header field name first */
+	if ( !rfc2822_write(f, name, line_len) || !rfc2822_write(f, ": ", 2) )
+		return -1;
+
+	line_len +=  2;
+	len += line_len;
+
+	/* Add field body; fold it if necessary and account for existing folding */
+	while ( *bp != '\0' ) {
+		while ( *bp != '\0' && nlp == NULL && (wp == NULL || line_len < max_line) ) {
+			if ( *bp == ' ' || *bp == '\t' ) {
+			 	wp = bp;
+			} else if ( *bp == '\r' || *bp == '\n' ) {
+				nlp = bp;
+				break;
+			}
+
+			bp++; line_len++;
+		}
+
+		if ( *bp == '\0' ) break;
+
+		/* Existing newline ? */
+		if ( nlp != NULL ) {
+			/* Replace any sort of newline with LF */
+			while ( *bp == '\r' || *bp == '\n' )
+				bp++;
+
+			if ( !rfc2822_write(f, sp, nlp-sp) )
+				return -1;
+			len += nlp-sp;
+
+			if ( *bp != '\0' && *bp != ' ' && *bp != '\t' ) {
+				if ( !rfc2822_write(f, "\r\n\t", 3) )
+					return -1;
+				len += 3;
+			} else {
+				if ( !rfc2822_write(f, "\r\n", 2) )
+					return -1;
+				len += 2;
+			}
+
+			sp = bp;
+		} else {
+			/* Insert newline at last whitespace within the max_line limit */
+			if ( !rfc2822_write(f, sp, wp-sp) || !rfc2822_write(f, "\r\n", 2) )
+				return -1;
+			len += (wp-sp) + 2;
+
+			sp = wp;
+		}
+
+		line_len = bp - sp;
+		wp = NULL;
+		nlp = NULL;
+	}
+
+	if ( bp != sp ) {
+		if ( !rfc2822_write(f, sp, bp-sp) || !rfc2822_write(f, "\r\n", 2) )
+			return -1;
+		len += (bp-sp) + 2;
+	}
+
+	return len;
+}
+
+int rfc2822_header_field_printf
+(FILE *f, const char *name, const char *body_fmt, ...)
+{
+	string_t *body = t_str_new(256);
+	va_list args;
+
+	va_start(args, body_fmt);
+	str_vprintfa(body, body_fmt, args);
+	va_end(args);
+
+	return rfc2822_header_field_write(f, name, str_c(body));
+}
+
+int rfc2822_header_field_utf8_printf
+(FILE *f, const char *name, const char *body_fmt, ...)
+{
+	string_t *body = t_str_new(256);
+	va_list args;
+
+	va_start(args, body_fmt);
+	message_header_encode(t_strdup_vprintf(body_fmt, args), body);
+	va_end(args);
+
+	return rfc2822_header_field_write(f, name, str_c(body));
+}
+
Index: b/sieve/src/lib-sieve/rfc2822.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/rfc2822.h
@@ -0,0 +1,39 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __RFC2822_H
+#define __RFC2822_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+/*
+ * Verification
+ */
+
+bool rfc2822_header_field_name_verify
+	(const char *field_name, unsigned int len);
+bool rfc2822_header_field_body_verify
+(const char *field_body, unsigned int len);
+
+/*
+ *
+ */
+
+const char *rfc2822_header_field_name_sanitize(const char *name);
+
+/*
+ * Message composition
+ */
+
+int rfc2822_header_field_write
+	(FILE *f, const char *name, const char *body);
+
+int rfc2822_header_field_printf
+	(FILE *f, const char *name, const char *body_fmt, ...) ATTR_FORMAT(3, 4);
+
+int rfc2822_header_field_utf8_printf
+	(FILE *f, const char *name, const char *body_fmt, ...) ATTR_FORMAT(3, 4);
+
+#endif /* __RFC2822_H */
Index: b/sieve/src/lib-sieve/sieve-actions.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-actions.c
@@ -0,0 +1,633 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "str-sanitize.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+#include "imap-utf7.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-actions.h"
+
+#include <ctype.h>
+
+/*
+ * Side-effect operand
+ */
+
+const struct sieve_operand_class sieve_side_effect_operand_class =
+	{ "SIDE-EFFECT" };
+
+bool sieve_opr_side_effect_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_side_effect *seffect)
+{
+	const struct sieve_side_effect_def *sdef;
+
+	seffect->context = NULL;
+
+	if ( !sieve_opr_object_read
+		(renv, &sieve_side_effect_operand_class, address, &seffect->object) )
+		return FALSE;
+
+	sdef = seffect->def =
+		(const struct sieve_side_effect_def *) seffect->object.def;
+
+	if ( sdef->read_context != NULL &&
+		!sdef->read_context(seffect, renv, address, &seffect->context) ) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_opr_side_effect_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	struct sieve_side_effect seffect;
+	const struct sieve_side_effect_def *sdef;
+
+	if ( !sieve_opr_object_dump
+		(denv, &sieve_side_effect_operand_class, address, &seffect.object) )
+		return FALSE;
+
+	sdef = seffect.def =
+		(const struct sieve_side_effect_def *) seffect.object.def;
+
+	if ( sdef->dump_context != NULL ) {
+		sieve_code_descend(denv);
+		if ( !sdef->dump_context(&seffect, denv, address) ) {
+			return FALSE;
+		}
+		sieve_code_ascend(denv);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Store action
+ */
+
+/* Forward declarations */
+
+static bool act_store_equals
+	(const struct sieve_script_env *senv,
+		const struct sieve_action *act1, const struct sieve_action *act2);
+
+static int act_store_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action *act,
+		const struct sieve_action *act_other);
+static void act_store_print
+	(const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, bool *keep);
+
+static bool act_store_start
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void **tr_context);
+static bool act_store_execute
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *tr_context);
+static bool act_store_commit
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+static void act_store_rollback
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+
+/* Action object */
+
+const struct sieve_action_def act_store = {
+	"store",
+	SIEVE_ACTFLAG_TRIES_DELIVER,
+	act_store_equals,
+	act_store_check_duplicate,
+	NULL,
+	act_store_print,
+	act_store_start,
+	act_store_execute,
+	act_store_commit,
+	act_store_rollback,
+};
+
+/* API */
+
+int sieve_act_store_add_to_result
+(const struct sieve_runtime_env *renv,
+	struct sieve_side_effects_list *seffects, const char *mailbox,
+	unsigned int source_line)
+{
+	pool_t pool;
+	struct act_store_context *act;
+
+	/* Add redirect action to the result */
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_store_context, 1);
+	act->mailbox = p_strdup(pool, mailbox);
+
+	return sieve_result_add_action(renv, NULL, &act_store, seffects,
+		source_line, (void *) act, 0);
+}
+
+void sieve_act_store_add_flags
+(const struct sieve_action_exec_env *aenv, void *tr_context,
+	const char *const *keywords, enum mail_flags flags)
+{
+	struct act_store_transaction *trans =
+		(struct act_store_transaction *) tr_context;
+
+	/* Assign mail keywords for subsequent mailbox_copy() */
+	if ( *keywords != NULL ) {
+		const char *const *kw;
+
+		if ( !array_is_created(&trans->keywords) ) {
+			pool_t pool = sieve_result_pool(aenv->result);
+			p_array_init(&trans->keywords, pool, 2);
+		}
+
+		kw = keywords;
+		while ( *kw != NULL ) {
+
+			const char *kw_error;
+
+			if ( trans->box != NULL ) {
+				if ( mailbox_keyword_is_valid(trans->box, *kw, &kw_error) )
+					array_append(&trans->keywords, kw, 1);
+				else {
+					char *error = "";
+					if ( kw_error != NULL && *kw_error != '\0' ) {
+						error = t_strdup_noconst(kw_error);
+						error[0] = i_tolower(error[0]);
+					}
+
+					sieve_result_warning(aenv,
+						"specified IMAP keyword '%s' is invalid (ignored): %s",
+						str_sanitize(*kw, 64), error);
+				}
+			}
+
+			kw++;
+		}
+	}
+
+	/* Assign mail flags for subsequent mailbox_copy() */
+	trans->flags |= flags;
+
+	trans->flags_altered = TRUE;
+}
+
+void sieve_act_store_get_storage_error
+(const struct sieve_action_exec_env *aenv, struct act_store_transaction *trans)
+{
+	pool_t pool = sieve_result_pool(aenv->result);
+
+	trans->error = p_strdup(pool,
+		mail_storage_get_last_error(trans->namespace->storage, &trans->error_code));
+}
+
+
+/* Equality */
+
+static bool act_store_equals
+(const struct sieve_script_env *senv,
+	const struct sieve_action *act1, const struct sieve_action *act2)
+{
+	struct act_store_context *st_ctx1 =
+		( act1 == NULL ? NULL : (struct act_store_context *) act1->context );
+	struct act_store_context *st_ctx2 =
+		( act2 == NULL ? NULL : (struct act_store_context *) act2->context );
+	const char *mailbox1, *mailbox2;
+
+	/* FIXME: consider namespace aliases */
+
+	if ( st_ctx1 == NULL && st_ctx2 == NULL )
+		return TRUE;
+
+	mailbox1 = ( st_ctx1 == NULL ?
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) : st_ctx1->mailbox );
+	mailbox2 = ( st_ctx2 == NULL ?
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) : st_ctx2->mailbox );
+
+	if ( strcmp(mailbox1, mailbox2) == 0 )
+		return TRUE;
+
+	return
+		( strcasecmp(mailbox1, "INBOX") == 0 && strcasecmp(mailbox2, "INBOX") == 0 );
+
+}
+
+/* Result verification */
+
+static int act_store_check_duplicate
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *act,
+	const struct sieve_action *act_other)
+{
+	return ( act_store_equals(renv->scriptenv, act, act_other) ? 1 : 0 );
+}
+
+/* Result printing */
+
+static void act_store_print
+(const struct sieve_action *action,
+	const struct sieve_result_print_env *rpenv, bool *keep)
+{
+	struct act_store_context *ctx = (struct act_store_context *) action->context;
+	const char *mailbox;
+
+	mailbox = ( ctx == NULL ?
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(rpenv->scriptenv) : ctx->mailbox );
+
+	sieve_result_action_printf(rpenv, "store message in folder: %s",
+		str_sanitize(mailbox, 128));
+
+	*keep = FALSE;
+}
+
+/* Action implementation */
+
+static struct mailbox *act_store_mailbox_open
+(const struct sieve_action_exec_env *aenv, const char **mailbox,
+	struct mail_namespace **ns_r, const char **folder_r)
+{
+	struct mail_storage **storage = &(aenv->exec_status->last_storage);
+	enum mailbox_open_flags open_flags =
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT |
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	string_t *mailbox_mutf7;
+	struct mailbox *box;
+	enum mail_error error;
+
+	/* Deliveries to INBOX must always succeed, regardless of ACLs */
+	if (strcasecmp(*mailbox, "INBOX") == 0) {
+		open_flags |= MAILBOX_OPEN_IGNORE_ACLS;
+	}
+
+	/* Convert utf-8 folder name to utf-7
+	 */
+	mailbox_mutf7 = t_str_new(256);
+	if ( imap_utf8_to_utf7(*mailbox, mailbox_mutf7) < 0 ) {
+		/* FIXME: check utf-8 validity at compiletime/runtime */
+		sieve_result_error(aenv, "mailbox name not utf-8: %s", *mailbox);
+		return NULL;
+	}
+
+	*folder_r = str_c(mailbox_mutf7);
+	*ns_r = mail_namespace_find(aenv->scriptenv->namespaces, folder_r);
+	if ( *ns_r == NULL) {
+		*storage = NULL;
+		return NULL;
+	}
+
+	*storage = (*ns_r)->storage;
+
+	if ( **folder_r == '\0' ) {
+		/* Delivering to a namespace prefix means we actually want to
+		 * deliver to the INBOX instead
+		 */
+		*folder_r = *mailbox = "INBOX";
+		open_flags |= MAILBOX_OPEN_IGNORE_ACLS;
+
+		*ns_r = mail_namespace_find(aenv->scriptenv->namespaces, folder_r);
+		if ( *ns_r == NULL) {
+			*storage = NULL;
+			return NULL;
+		}
+
+		*storage = (*ns_r)->storage;
+	}
+
+	box = mailbox_open(storage, *folder_r, NULL, open_flags);
+
+	if ( box == NULL && aenv->scriptenv->mailbox_autocreate ) {
+		(void)mail_storage_get_last_error(*storage, &error);
+		if ( error != MAIL_ERROR_NOTFOUND )
+			return NULL;
+
+		/* Try creating it */
+		if ( mail_storage_mailbox_create(*storage, *folder_r, FALSE) < 0 )
+			return NULL;
+
+		if ( aenv->scriptenv->mailbox_autosubscribe ) {
+			/* Subscribe to it */
+			(void)mailbox_list_set_subscribed((*ns_r)->list, *folder_r, TRUE);
+		}
+
+		/* Try opening again */
+		box = mailbox_open(storage, *folder_r, NULL, open_flags);
+
+		if (box == NULL)
+			return NULL;
+
+		if (mailbox_sync(box, 0, 0, NULL) < 0) {
+			mailbox_close(&box);
+			return NULL;
+		}
+	}
+
+	return box;
+}
+
+static bool act_store_start
+(const struct sieve_action *action,
+	const struct sieve_action_exec_env *aenv, void **tr_context)
+{
+	struct act_store_context *ctx = (struct act_store_context *) action->context;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct act_store_transaction *trans;
+	struct mail_namespace *ns = NULL;
+	struct mailbox *box = NULL;
+	const char *folder;
+	pool_t pool = sieve_result_pool(aenv->result);
+	bool disabled = FALSE, redundant = FALSE;
+
+	/* If context is NULL, the store action is the result of (implicit) keep */
+	if ( ctx == NULL ) {
+		ctx = p_new(pool, struct act_store_context, 1);
+		ctx->mailbox = p_strdup(pool, SIEVE_SCRIPT_DEFAULT_MAILBOX(senv));
+	}
+
+	/* Open the requested mailbox */
+
+	/* NOTE: The caller of the sieve library is allowed to leave namespaces set
+	 * to NULL. This implementation will then skip actually storing the message.
+	 */
+	if ( senv->namespaces != NULL ) {
+		box = act_store_mailbox_open(aenv, &ctx->mailbox, &ns, &folder);
+
+		/* Check whether we are trying to store the message in the folder it
+		 * originates from. In that case we skip actually storing it.
+	   */
+		if ( box != NULL && mailbox_backends_equal(box, msgdata->mail->box) ) {
+			mailbox_close(&box);
+			box = NULL;
+			ns = NULL;
+			redundant = TRUE;
+		}
+	} else {
+		disabled = TRUE;
+	}
+
+	/* Create transaction context */
+	trans = p_new(pool, struct act_store_transaction, 1);
+
+	trans->context = ctx;
+	trans->namespace = ns;
+	trans->folder = folder;
+	trans->box = box;
+	trans->flags = 0;
+
+	trans->disabled = disabled;
+	trans->redundant = redundant;
+
+	if ( ns != NULL && box == NULL )
+		sieve_act_store_get_storage_error(aenv, trans);
+
+	*tr_context = (void *)trans;
+
+	return ( (box != NULL)
+		|| (trans->error_code == MAIL_ERROR_NOTFOUND)
+		|| disabled || redundant );
+}
+
+static struct mail_keywords *act_store_keywords_create
+(const struct sieve_action_exec_env *aenv, ARRAY_TYPE(const_string) *keywords,
+	struct mailbox *box)
+{
+	struct mail_keywords *box_keywords = NULL;
+
+	if ( array_is_created(keywords) && array_count(keywords) > 0 )
+	{
+		const char *const *kwds;
+
+		(void)array_append_space(keywords);
+		kwds = array_idx(keywords, 0);
+
+		/* FIXME: Do we need to clear duplicates? */
+		if ( mailbox_keywords_create(box, kwds, &box_keywords) < 0) {
+			sieve_result_error(aenv, "invalid keywords set for stored message");
+			return NULL;
+		}
+	}
+
+	return box_keywords;
+}
+
+static bool act_store_execute
+(const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv, void *tr_context)
+{
+	struct act_store_transaction *trans =
+		(struct act_store_transaction *) tr_context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct mail_save_context *save_ctx;
+	struct mail_keywords *keywords = NULL;
+	bool result = TRUE;
+
+	/* Verify transaction */
+	if ( trans == NULL ) return FALSE;
+
+	/* Check whether we need to do anything */
+	if ( trans->disabled ) return TRUE;
+
+	/* If the message originates from the target mailbox, only update the flags
+	 * and keywords
+	 */
+	if ( trans->redundant ) {
+		if ( trans->flags_altered ) {
+			keywords = act_store_keywords_create
+				(aenv, &trans->keywords, msgdata->mail->box);
+
+			if ( keywords != NULL ) {
+				mail_update_keywords(msgdata->mail, MODIFY_REPLACE, keywords);
+				mailbox_keywords_free(trans->box, &keywords);
+			}
+
+			mail_update_flags(msgdata->mail, MODIFY_REPLACE, trans->flags);
+		}
+
+		return TRUE;
+	}
+
+	/* Exit early if namespace or mailbox are not available */
+	if ( trans->namespace == NULL )
+		return FALSE;
+	else if ( trans->box == NULL )
+		return FALSE;
+
+	/* Mark attempt to store in default mailbox */
+	if ( strcmp(trans->context->mailbox,
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(aenv->scriptenv)) == 0 )
+		aenv->exec_status->tried_default_save = TRUE;
+
+	/* Mark attempt to use storage. Can only get here when all previous actions
+	 * succeeded.
+	 */
+	aenv->exec_status->last_storage = trans->namespace->storage;
+
+	/* Start mail transaction */
+	trans->mail_trans = mailbox_transaction_begin
+		(trans->box, MAILBOX_TRANSACTION_FLAG_EXTERNAL);
+
+	/* Create mail object for stored message */
+	trans->dest_mail = mail_alloc(trans->mail_trans, 0, NULL);
+
+	/* Store the message */
+	save_ctx = mailbox_save_alloc(trans->mail_trans);
+	mailbox_save_set_dest_mail(save_ctx, trans->dest_mail);
+
+	/* Apply keywords and flags that side-effects may have added */
+	if ( trans->flags_altered ) {
+		keywords = act_store_keywords_create(aenv, &trans->keywords, trans->box);
+
+		mailbox_save_set_flags(save_ctx, trans->flags, keywords);
+	}
+
+	if ( mailbox_copy(&save_ctx, aenv->msgdata->mail) < 0 ) {
+		sieve_act_store_get_storage_error(aenv, trans);
+ 		result = FALSE;
+ 	}
+
+	/* Deallocate keywords */
+ 	if ( keywords != NULL ) {
+ 		mailbox_keywords_free(trans->box, &keywords);
+ 	}
+
+	return result;
+}
+
+static void act_store_log_status
+(struct act_store_transaction *trans,
+	const struct sieve_action_exec_env *aenv, bool rolled_back, bool status )
+{
+	const char *mailbox_name;
+
+	mailbox_name = str_sanitize(trans->context->mailbox, 128);
+
+	/* Store disabled? */
+	if ( trans->disabled ) {
+		sieve_result_log(aenv, "store into mailbox '%s' skipped", mailbox_name);
+
+	/* Store redundant? */
+	} else if ( trans->redundant ) {
+		sieve_result_log(aenv, "left message in mailbox '%s'", mailbox_name);
+
+	/* Namespace not set? */
+	} else if ( trans->namespace == NULL ) {
+		sieve_result_error
+			(aenv, "failed to find namespace for mailbox '%s'", mailbox_name);
+
+	/* Store failed? */
+	} else if ( !status ) {
+		const char *errstr;
+		enum mail_error error;
+
+		if ( trans->error != NULL )
+			errstr = trans->error;
+		else
+			errstr = mail_storage_get_last_error(trans->namespace->storage, &error);
+
+		sieve_result_error(aenv, "failed to store into mailbox '%s': %s",
+			mailbox_name, errstr);
+
+	/* Store aborted? */
+	} else if ( rolled_back ) {
+		sieve_result_log(aenv, "store into mailbox '%s' aborted", mailbox_name);
+
+	/* Succeeded */
+	} else {
+		sieve_result_log(aenv, "stored mail into mailbox '%s'", mailbox_name);
+
+	}
+}
+
+static bool act_store_commit
+(const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{
+	struct act_store_transaction *trans =
+		(struct act_store_transaction *) tr_context;
+	bool status = TRUE;
+
+	/* Verify transaction */
+	if ( trans == NULL ) return FALSE;
+
+	/* Check whether we need to do anything */
+	if ( trans->disabled ) {
+		act_store_log_status(trans, aenv, FALSE, status);
+		*keep = FALSE;
+		return TRUE;
+	} else if ( trans->redundant ) {
+		act_store_log_status(trans, aenv, FALSE, status);
+		aenv->exec_status->keep_original = TRUE;
+		aenv->exec_status->message_saved = TRUE;
+		return TRUE;
+	}
+
+	/* Exit early if namespace is not available */
+	if ( trans->namespace == NULL )
+		return FALSE;
+	else if ( trans->box == NULL )
+		return FALSE;
+
+	/* Mark attempt to use storage. Can only get here when all previous actions
+	 * succeeded.
+	 */
+	aenv->exec_status->last_storage = trans->namespace->storage;
+
+	/* Free mail object for stored message */
+	if ( trans->dest_mail != NULL )
+		mail_free(&trans->dest_mail);
+
+	/* Commit mailbox transaction */
+	status = ( mailbox_transaction_commit(&trans->mail_trans) == 0 );
+
+	/* Note the fact that the message was stored at least once */
+	if ( status )
+		aenv->exec_status->message_saved = TRUE;
+
+	/* Log our status */
+	act_store_log_status(trans, aenv, FALSE, status);
+
+	/* Cancel implicit keep if all went well */
+	*keep = !status;
+
+	/* Close mailbox */
+	if ( trans->box != NULL )
+		mailbox_close(&trans->box);
+
+	return status;
+}
+
+static void act_store_rollback
+(const struct sieve_action *action ATTR_UNUSED,
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool success)
+{
+	struct act_store_transaction *trans =
+		(struct act_store_transaction *) tr_context;
+
+	/* Log status */
+	act_store_log_status(trans, aenv, TRUE, success);
+
+	/* Free mailobject for stored message */
+	if ( trans->dest_mail != NULL )
+		mail_free(&trans->dest_mail);
+
+	/* Rollback mailbox transaction */
+	if ( trans->mail_trans != NULL )
+		mailbox_transaction_rollback(&trans->mail_trans);
+
+	/* Close the mailbox */
+	if ( trans->box != NULL )
+		mailbox_close(&trans->box);
+}
Index: b/sieve/src/lib-sieve/sieve-actions.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-actions.h
@@ -0,0 +1,232 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ACTIONS_H
+#define __SIEVE_ACTIONS_H
+
+#include "lib.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+#include "sieve-extensions.h"
+
+/*
+ * Action execution environment
+ */
+
+struct sieve_action_exec_env {
+	struct sieve_result *result;
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+	const struct sieve_script_env *scriptenv;
+	struct sieve_exec_status *exec_status;
+};
+
+const char *sieve_action_get_location(const struct sieve_action_exec_env *aenv);
+
+/*
+ * Action flags
+ */
+
+enum sieve_action_flags {
+	SIEVE_ACTFLAG_TRIES_DELIVER = (1 << 0),
+	SIEVE_ACTFLAG_SENDS_RESPONSE = (1 << 1)
+};
+
+/*
+ * Action definition
+ */
+
+struct sieve_action_def {
+	const char *name;
+	unsigned int flags;
+
+	bool (*equals)
+		(const struct sieve_script_env *senv, const struct sieve_action *act1,
+			const struct sieve_action *act2);
+
+	/* Result verification */
+
+	int (*check_duplicate)
+		(const struct sieve_runtime_env *renv,
+			const struct sieve_action *act,
+			const struct sieve_action *act_other);
+	int (*check_conflict)
+		(const struct sieve_runtime_env *renv,
+			const struct sieve_action *act,
+			const struct sieve_action *act_other);
+
+	/* Result printing */
+
+	void (*print)
+		(const struct sieve_action *action,
+			const struct sieve_result_print_env *penv, bool *keep);
+
+	/* Result execution */
+
+	bool (*start)
+		(const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void **tr_context);
+	bool (*execute)
+		(const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void *tr_context);
+	bool (*commit)
+		(const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+	void (*rollback)
+		(const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+};
+
+/*
+ * Action instance
+ */
+
+struct sieve_action {
+	const struct sieve_action_def *def;
+	const struct sieve_extension *ext;
+
+	const char *location;
+	void *context;
+	bool executed;
+};
+
+/*
+ * Action side effects
+ */
+
+/* Side effect object */
+
+struct sieve_side_effect_def {
+	struct sieve_object_def obj_def;
+
+	/* The action it is supposed to link to */
+
+	const struct sieve_action_def *to_action;
+
+	/* Context coding */
+
+	bool (*dump_context)
+		(const struct sieve_side_effect *seffect,
+			const struct sieve_dumptime_env *renv, sieve_size_t *address);
+	bool (*read_context)
+		(const struct sieve_side_effect *seffect,
+			const struct sieve_runtime_env *renv, sieve_size_t *address,
+			void **se_context);
+
+	/* Result verification */
+
+	int (*merge)
+		(const struct sieve_runtime_env *renv, const struct sieve_action *action,
+			const struct sieve_side_effect *old_seffect,
+			const struct sieve_side_effect *new_seffect, void **old_context);
+
+	/* Result printing */
+
+	void (*print)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+			const struct sieve_result_print_env *penv, bool *keep);
+
+	/* Result execution */
+
+	bool (*pre_execute)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void **context,
+			void *tr_context);
+	bool (*post_execute)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void *tr_context);
+	void (*post_commit)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+	void (*rollback)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+};
+
+struct sieve_side_effect {
+	struct sieve_object object;
+
+	const struct sieve_side_effect_def *def;
+
+	void *context;
+};
+
+/*
+ * Side effect operand
+ */
+
+#define SIEVE_EXT_DEFINE_SIDE_EFFECT(SEF) SIEVE_EXT_DEFINE_OBJECT(SEF)
+#define SIEVE_EXT_DEFINE_SIDE_EFFECTS(SEFS) SIEVE_EXT_DEFINE_OBJECTS(SEFS)
+
+#define SIEVE_OPT_SIDE_EFFECT (-1)
+
+extern const struct sieve_operand_class sieve_side_effect_operand_class;
+
+static inline void sieve_opr_side_effect_emit
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	const struct sieve_side_effect_def *seff)
+{
+	sieve_opr_object_emit(sbin, ext, &seff->obj_def);
+}
+
+bool sieve_opr_side_effect_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_side_effect *seffect);
+
+bool sieve_opr_side_effect_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/*
+ * Core actions
+ */
+
+extern const struct sieve_action_def act_redirect;
+extern const struct sieve_action_def act_store;
+extern const struct sieve_action_def act_discard;
+
+/*
+ * Store action
+ */
+
+struct act_store_context {
+	/* Folder name represented in utf-8 */
+	const char *mailbox;
+};
+
+struct act_store_transaction {
+	struct act_store_context *context;
+	struct mail_namespace *namespace;
+	struct mailbox *box;
+	struct mailbox_transaction_context *mail_trans;
+	struct mail *dest_mail;
+
+	const char *folder;
+	const char *folder_mutf7;
+
+	const char *error;
+	enum mail_error error_code;
+
+	enum mail_flags flags;
+	ARRAY_TYPE(const_string) keywords;
+
+	unsigned int flags_altered:1;
+	unsigned int disabled:1;
+	unsigned int redundant:1;
+};
+
+int sieve_act_store_add_to_result
+	(const struct sieve_runtime_env *renv,
+		struct sieve_side_effects_list *seffects, const char *mailbox,
+		unsigned int source_line);
+
+void sieve_act_store_add_flags
+	(const struct sieve_action_exec_env *aenv, void *tr_context,
+		const char *const *keywords, enum mail_flags flags);
+
+void sieve_act_store_get_storage_error
+	(const struct sieve_action_exec_env *aenv,
+		struct act_store_transaction *trans);
+
+#endif /* __SIEVE_ACTIONS_H */
Index: b/sieve/src/lib-sieve/sieve-address-parts.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-address-parts.c
@@ -0,0 +1,405 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+#include "message-address.h"
+
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "sieve-address-parts.h"
+
+#include <string.h>
+
+/*
+ * Default address parts
+ */
+
+const struct sieve_address_part_def *sieve_core_address_parts[] = {
+	&all_address_part, &local_address_part, &domain_address_part
+};
+
+const unsigned int sieve_core_address_parts_count =
+	N_ELEMENTS(sieve_core_address_parts);
+
+/*
+ * Address-part 'extension'
+ */
+
+static bool addrp_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def address_part_extension = {
+	"@address-parts",
+	NULL, NULL,
+	addrp_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS /* Defined as core operand */
+};
+
+/*
+ * Validator context:
+ *   name-based address-part registry.
+ */
+
+static struct sieve_validator_object_registry *_get_object_registry
+(struct sieve_validator *valdtr)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *adrp_ext;
+
+	svinst = sieve_validator_svinst(valdtr);
+	adrp_ext = sieve_get_address_part_extension(svinst);
+	return sieve_validator_object_registry_get(valdtr, adrp_ext);
+}
+
+void sieve_address_part_register
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct sieve_address_part_def *addrp_def)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+
+	sieve_validator_object_registry_add(regs, ext, &addrp_def->obj_def);
+}
+
+static bool sieve_address_part_exists
+(struct sieve_validator *valdtr, const char *identifier)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+
+	return sieve_validator_object_registry_find(regs, identifier, NULL);
+}
+
+static const struct sieve_address_part *sieve_address_part_create_instance
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const char *identifier)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+	struct sieve_object object;
+	struct sieve_address_part *addrp;
+
+	if ( !sieve_validator_object_registry_find(regs, identifier, &object) )
+		return NULL;
+
+	addrp = p_new(sieve_command_pool(cmd), struct sieve_address_part, 1);
+	addrp->object = object;
+	addrp->def = (const struct sieve_address_part_def *) object.def;
+
+  return addrp;
+}
+
+static bool addrp_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	struct sieve_validator_object_registry *regs =
+		sieve_validator_object_registry_init(valdtr, ext);
+	unsigned int i;
+
+	/* Register core address-parts */
+	for ( i = 0; i < sieve_core_address_parts_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, NULL, &(sieve_core_address_parts[i]->obj_def));
+	}
+
+	return TRUE;
+}
+
+void sieve_address_parts_link_tags
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	int id_code)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *adrp_ext;
+
+	svinst = sieve_validator_svinst(valdtr);
+	adrp_ext = sieve_get_address_part_extension(svinst);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, adrp_ext, &address_part_tag, id_code);
+}
+
+/*
+ * Address-part tagged argument
+ */
+
+/* Forward declarations */
+
+static bool tag_address_part_is_instance_of
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		const struct sieve_extension *ext, const char *identifier, void **data);
+static bool tag_address_part_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_address_part_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+/* Argument object */
+
+const struct sieve_argument_def address_part_tag = {
+	"ADDRESS-PART",
+	tag_address_part_is_instance_of,
+	tag_address_part_validate,
+	NULL, NULL,
+	tag_address_part_generate
+};
+
+/* Argument implementation */
+
+static bool tag_address_part_is_instance_of
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const struct sieve_extension *ext ATTR_UNUSED, const char *identifier,
+	void **data)
+{
+	const struct sieve_address_part *addrp;
+
+	if ( data == NULL )
+		return sieve_address_part_exists(valdtr, identifier);
+
+	if ( (addrp=sieve_address_part_create_instance
+		(valdtr, cmd, identifier)) == NULL )
+		return FALSE;
+
+	*data = (void *) addrp;
+	return TRUE;
+}
+
+static bool tag_address_part_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	/* FIXME: Currenly trivial, but might need to allow for further validation for
+	 * future extensions.
+	 */
+
+	/* Syntax:
+	 *   ":localpart" / ":domain" / ":all" (subject to extension)
+   */
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool tag_address_part_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	struct sieve_address_part *addrp =
+		(struct sieve_address_part *) arg->argument->data;
+
+	sieve_opr_address_part_emit(cgenv->sbin, addrp);
+
+	return TRUE;
+}
+
+/*
+ * Address-part operand
+ */
+
+const struct sieve_operand_class sieve_address_part_operand_class =
+	{ "address part" };
+
+static const struct sieve_extension_objects core_address_parts =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(sieve_core_address_parts);
+
+const struct sieve_operand_def address_part_operand = {
+	"address-part",
+	NULL, SIEVE_OPERAND_ADDRESS_PART,
+	&sieve_address_part_operand_class,
+	&core_address_parts
+};
+
+/*
+ * Address Matching
+ */
+
+int sieve_address_match
+(const struct sieve_address_part *addrp, struct sieve_match_context *mctx,
+	const char *data)
+{
+	int result = FALSE;
+	const struct message_address *addr;
+
+	T_BEGIN {
+		bool valid = TRUE;
+		const struct message_address *aitem;
+
+		addr = message_address_parse
+			(pool_datastack_create(), (const unsigned char *) data,
+				strlen(data), 256, FALSE);
+
+		/* Check validity of all addresses simultaneously. Unfortunately,
+		 * errorneous addresses cannot be extracted from the address list
+		 * and therefore :all will match against the whole header value
+		 * which is not entirely standard.
+		 */
+		aitem = addr;
+		while ( aitem != NULL) {
+			if ( aitem->invalid_syntax )
+				valid = FALSE;
+			aitem = aitem->next;
+		}
+
+		if ( !valid || addr == NULL ) {
+			if ( sieve_address_part_is(addrp, all_address_part) )
+				result = sieve_match_value(mctx, data, strlen(data));
+			else
+				result = FALSE;
+		} else {
+			while ( result == 0 && addr != NULL) {
+				/* mailbox@domain */
+				struct sieve_address address;
+				const char *part = NULL;
+
+				if ( addr->domain != NULL ) {
+					address.local_part = addr->mailbox;
+					address.domain = addr->domain;
+
+					if ( addrp->def != NULL && addrp->def->extract_from )
+						part = addrp->def->extract_from(addrp, &address);
+
+					if ( part != NULL )
+						result = sieve_match_value(mctx, part, strlen(part));
+				}
+				addr = addr->next;
+			}
+		}
+	} T_END;
+
+	return result;
+}
+
+/*
+ * Default ADDRESS-PART, MATCH-TYPE, COMPARATOR access
+ */
+
+bool sieve_addrmatch_default_dump_optionals
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 1;
+
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case SIEVE_AM_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_ADDRESS_PART:
+				if ( !sieve_opr_address_part_dump(denv, address) )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+bool sieve_addrmatch_default_get_optionals
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_address_part *addrp, struct sieve_match_type *mtch,
+	struct sieve_comparator *cmp)
+{
+	int opt_code = 1;
+
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case SIEVE_AM_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_read(renv, address, cmp) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_read(renv, address, mtch) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_ADDRESS_PART:
+				if ( !sieve_opr_address_part_read(renv, address, addrp) )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Core address-part modifiers
+ */
+
+static const char *addrp_all_extract_from
+(const struct sieve_address_part *addrp ATTR_UNUSED,
+	const struct sieve_address *address)
+{
+	const char *local_part = address->local_part;
+	const char *domain = address->domain;
+
+	return t_strconcat(local_part, "@", domain, NULL);
+}
+
+static const char *addrp_domain_extract_from
+(const struct sieve_address_part *addrp ATTR_UNUSED,
+	const struct sieve_address *address)
+{
+	return address->domain;
+}
+
+static const char *addrp_localpart_extract_from
+(const struct sieve_address_part *addrp ATTR_UNUSED,
+	const struct sieve_address *address)
+{
+	return address->local_part;
+}
+
+const struct sieve_address_part_def all_address_part = {
+	SIEVE_OBJECT("all", &address_part_operand, SIEVE_ADDRESS_PART_ALL),
+	addrp_all_extract_from
+};
+
+const struct sieve_address_part_def local_address_part = {
+	SIEVE_OBJECT("localpart", &address_part_operand, SIEVE_ADDRESS_PART_LOCAL),
+	addrp_localpart_extract_from
+};
+
+const struct sieve_address_part_def domain_address_part = {
+	SIEVE_OBJECT("domain", &address_part_operand,	SIEVE_ADDRESS_PART_DOMAIN),
+	addrp_domain_extract_from
+};
+
Index: b/sieve/src/lib-sieve/sieve-address-parts.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-address-parts.h
@@ -0,0 +1,132 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ADDRESS_PARTS_H
+#define __SIEVE_ADDRESS_PARTS_H
+
+#include "message-address.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-objects.h"
+
+/*
+ * Address part definition
+ */
+
+struct sieve_address_part_def {
+	struct sieve_object_def obj_def;
+
+	const char *(*extract_from)
+		(const struct sieve_address_part *addrp,
+			const struct sieve_address *address);
+};
+
+/*
+ * Address part instance
+ */
+
+struct sieve_address_part {
+	struct sieve_object object;
+
+	const struct sieve_address_part_def *def;
+};
+
+#define SIEVE_ADDRESS_PART_DEFAULT(definition) \
+	{ SIEVE_OBJECT_DEFAULT(definition), &(definition) };
+
+#define sieve_address_part_is(addrp, definition) \
+	( (addrp)->def == &(definition) )
+
+/*
+ * Core address parts
+ */
+
+enum sieve_address_part_code {
+	SIEVE_ADDRESS_PART_ALL,
+	SIEVE_ADDRESS_PART_LOCAL,
+	SIEVE_ADDRESS_PART_DOMAIN,
+	SIEVE_ADDRESS_PART_CUSTOM
+};
+
+extern const struct sieve_address_part_def all_address_part;
+extern const struct sieve_address_part_def local_address_part;
+extern const struct sieve_address_part_def domain_address_part;
+
+/*
+ * Address part tagged argument
+ */
+
+extern const struct sieve_argument_def address_part_tag;
+
+void sieve_address_parts_link_tags
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+		int id_code);
+
+/*
+ * Address part registry
+ */
+
+void sieve_address_part_register
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		const struct sieve_address_part_def *addrp);
+
+/*
+ * Address part operand
+ */
+
+extern const struct sieve_operand_def address_part_operand;
+extern const struct sieve_operand_class sieve_address_part_operand_class;
+
+#define SIEVE_EXT_DEFINE_ADDRESS_PART(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_ADDRESS_PARTS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+static inline void sieve_opr_address_part_emit
+(struct sieve_binary *sbin, const struct sieve_address_part *addrp)
+{
+	sieve_opr_object_emit(sbin, addrp->object.ext, addrp->object.def);
+}
+
+static inline bool sieve_opr_address_part_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_address_part *addrp)
+{
+	if ( !sieve_opr_object_read
+		(renv, &sieve_address_part_operand_class, address, &addrp->object) )
+		return FALSE;
+
+	addrp->def = (const struct sieve_address_part_def *) addrp->object.def;
+	return TRUE;
+}
+
+static inline bool sieve_opr_address_part_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_address_part_operand_class, address, NULL);
+}
+
+/*
+ * Match utility
+ */
+
+int sieve_address_match
+(const struct sieve_address_part *addrp, struct sieve_match_context *mctx,
+    const char *data);
+
+enum sieve_addrmatch_opt_operand {
+	SIEVE_AM_OPT_END,
+	SIEVE_AM_OPT_COMPARATOR,
+	SIEVE_AM_OPT_ADDRESS_PART,
+	SIEVE_AM_OPT_MATCH_TYPE
+};
+
+bool sieve_addrmatch_default_dump_optionals
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+bool sieve_addrmatch_default_get_optionals
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_address_part *addrp,
+		struct sieve_match_type *mtch, struct sieve_comparator *cmp);
+
+#endif /* __SIEVE_ADDRESS_PARTS_H */
Index: b/sieve/src/lib-sieve/sieve-address.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-address.c
@@ -0,0 +1,785 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "rfc822-parser.h"
+
+#include "sieve-common.h"
+#include "sieve-address.h"
+
+#include <ctype.h>
+
+/*
+ * RFC 2822 addresses
+ */
+
+/* Mail message address according to RFC 2822 and implemented in the Dovecot
+ * message address parser:
+ *
+ *   address         =       mailbox / group
+ *   mailbox         =       name-addr / addr-spec
+ *   name-addr       =       [display-name] angle-addr
+ *   angle-addr      =       [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
+ *   group           =       display-name ":" [mailbox-list / CFWS] ";" [CFWS]
+ *   display-name    =       phrase
+ *
+ *   addr-spec       =       local-part "@" domain
+ *   local-part      =       dot-atom / quoted-string / obs-local-part
+ *   domain          =       dot-atom / domain-literal / obs-domain
+ *   domain-literal  =       [CFWS] "[" *([FWS] dcontent) [FWS] "]" [CFWS]
+ *   dcontent        =       dtext / quoted-pair
+ *   dtext           =       NO-WS-CTL /     ; Non white space controls
+ *                           %d33-90 /       ; The rest of the US-ASCII
+ *                           %d94-126        ;  characters not including "[",
+ *                                           ;  "]", or "\"
+ *
+ *   atext           =       ALPHA / DIGIT / ; Any character except controls,
+ *                           "!" / "#" /     ;  SP, and specials.
+ *                           "$" / "%" /     ;  Used for atoms
+ *                           "&" / "'" /
+ *                           "*" / "+" /
+ *                           "-" / "/" /
+ *                           "=" / "?" /
+ *                           "^" / "_" /
+ *                           "`" / "{" /
+ *                           "|" / "}" /
+ *                           "~"
+ *   atom            =       [CFWS] 1*atext [CFWS]
+ *   dot-atom        =       [CFWS] dot-atom-text [CFWS]
+ *   dot-atom-text   =       1*atext *("." 1*atext)
+ *   word            =       atom / quoted-string
+ *   phrase          =       1*word / obs-phrase
+ *
+ * Message address specification as allowed bij the RFC 5228 SIEVE
+ * specification:
+ *   sieve-address   =       addr-spec                  ; simple address
+ *                           / phrase "<" addr-spec ">" ; name & addr-spec\
+ *
+ * Which concisely is about equal to:
+ *   sieve-address   =       mailbox
+ */
+
+/*
+ * Address parse context
+ */
+
+struct sieve_message_address_parser {
+	struct rfc822_parser_context parser;
+
+	string_t *str;
+	string_t *local_part;
+	string_t *domain;
+
+	string_t *error;
+};
+
+/*
+ * Error handling
+ */
+
+static inline void sieve_address_error
+	(struct sieve_message_address_parser *ctx, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+static inline void sieve_address_error
+	(struct sieve_message_address_parser *ctx, const char *fmt, ...)
+{
+	va_list args;
+
+	if ( str_len(ctx->error) == 0 ) {
+		va_start(args, fmt);
+		str_vprintfa(ctx->error, fmt, args);
+		va_end(args);
+	}
+}
+
+/*
+ * Partial RFC 2822 address parser
+ *
+ *   FIXME: lots of overlap with dovecot/src/lib-mail/message-parser.c
+ *          --> this implementation adds textual error reporting
+ *          MERGE!
+ */
+
+static int parse_local_part(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+
+	/*
+	   local-part      = dot-atom / quoted-string / obs-local-part
+	   obs-local-part  = word *("." word)
+	*/
+	if (ctx->parser.data == ctx->parser.end) {
+		sieve_address_error(ctx, "empty local part");
+		return -1;
+	}
+
+	str_truncate(ctx->local_part, 0);
+	if (*ctx->parser.data == '"')
+		ret = rfc822_parse_quoted_string(&ctx->parser, ctx->local_part);
+	else
+		ret = rfc822_parse_dot_atom(&ctx->parser, ctx->local_part);
+
+	if (ret < 0) {
+		sieve_address_error(ctx, "invalid local part");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int parse_domain(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+
+	str_truncate(ctx->domain, 0);
+	if ((ret = rfc822_parse_domain(&ctx->parser, ctx->domain)) < 0) {
+		sieve_address_error(ctx, "invalid or missing domain");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int parse_addr_spec(struct sieve_message_address_parser *ctx)
+{
+	/* addr-spec       = local-part "@" domain */
+	int ret;
+
+	if ((ret = parse_local_part(ctx)) < 0)
+		return ret;
+
+	if ( ret > 0 && *ctx->parser.data == '@') {
+		return parse_domain(ctx);
+	}
+
+	sieve_address_error(ctx, "invalid or lonely local part '%s' (expecting '@')",
+		str_sanitize(str_c(ctx->local_part), 80));
+	return -1;
+}
+
+static int parse_mailbox(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+	const unsigned char *start;
+
+	/* sieve-address   =       addr-spec                  ; simple address
+	 *                         / phrase "<" addr-spec ">" ; name & addr-spec
+	 */
+
+	/* Record parser state in case we fail at our first attempt */
+	start = ctx->parser.data;
+
+	/* First try: phrase "<" addr-spec ">" ; name & addr-spec */
+	str_truncate(ctx->str, 0);
+	if (rfc822_parse_phrase(&ctx->parser, ctx->str) <= 0 ||
+	    *ctx->parser.data != '<') {
+	  /* Failed; try just bare addr-spec */
+	  ctx->parser.data = start;
+	  return parse_addr_spec(ctx);
+	}
+
+	/* "<" addr-spec ">" */
+	ctx->parser.data++;
+
+	if ((ret = rfc822_skip_lwsp(&ctx->parser)) <= 0 ) {
+		if ( ret < 0 )
+			sieve_address_error(ctx, "invalid characters after <");
+		return ret;
+	}
+
+	if ((ret = parse_addr_spec(ctx)) < 0)
+		return -1;
+
+	if (*ctx->parser.data != '>') {
+		sieve_address_error(ctx, "missing '>'");
+		return -1;
+	}
+	ctx->parser.data++;
+
+	if ( (ret=rfc822_skip_lwsp(&ctx->parser)) < 0 )
+		sieve_address_error(ctx, "address ends with invalid characters");
+
+	return ret;
+}
+
+static bool parse_mailbox_address
+(struct sieve_message_address_parser *ctx, const unsigned char *address,
+	unsigned int addr_size)
+{
+	int ret;
+
+	/* Initialize parser */
+
+	rfc822_parser_init(&ctx->parser, address, addr_size, NULL);
+
+	/* Parse */
+
+	rfc822_skip_lwsp(&ctx->parser);
+
+	if (ctx->parser.data == ctx->parser.end) {
+		sieve_address_error(ctx, "empty address");
+		return FALSE;
+	}
+
+	if ((ret = parse_mailbox(ctx)) < 0) {
+		return FALSE;
+	}
+
+	if (ctx->parser.data != ctx->parser.end) {
+		if ( *ctx->parser.data == ',' )
+			sieve_address_error(ctx, "not a single addres (found ',')");
+		else
+			sieve_address_error(ctx, "address ends in invalid characters");
+		return FALSE;
+	}
+
+	if ( str_len(ctx->domain) == 0 ) {
+		/* Not gonna happen */
+		sieve_address_error(ctx, "missing domain");
+		return FALSE;
+	}
+
+	if ( str_len(ctx->local_part) == 0 ) {
+		sieve_address_error(ctx, "missing local part");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/* FIXME: change the names of these functions */
+bool sieve_rfc2822_mailbox_validate(const char *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	if ( address == NULL ) {
+		*error_r = "null address";
+		return FALSE;
+	}
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, (const unsigned char *) address,
+		strlen(address)) ) {
+		if ( error_r != NULL )
+			*error_r = str_c(ctx.error);
+		return FALSE;
+	}
+
+	if ( error_r != NULL )
+		*error_r = NULL;
+
+	return TRUE;
+}
+
+const char *sieve_rfc2822_mailbox_normalize
+(const char *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	if ( error_r != NULL )
+		*error_r = NULL;
+
+	if ( address == NULL ) return NULL;
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, (const unsigned char *) address,
+		strlen(address)) ) {
+		if ( error_r != NULL )
+			*error_r = str_c(ctx.error);
+		return NULL;
+	}
+
+	(void)str_lcase(str_c_modifiable(ctx.domain));
+
+	return t_strconcat(str_c(ctx.local_part), "@", str_c(ctx.domain), NULL);
+}
+
+/*
+ * Sieve address
+ */
+
+const char *sieve_address_normalize
+(string_t *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, str_data(address), str_len(address)) )
+	{
+		*error_r = str_c(ctx.error);
+		return NULL;
+	}
+
+	*error_r = NULL;
+	(void)str_lcase(str_c_modifiable(ctx.domain));
+
+	return t_strconcat(str_c(ctx.local_part), "@", str_c(ctx.domain), NULL);
+}
+
+bool sieve_address_validate
+(string_t *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	ctx.local_part = ctx.domain = ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, str_data(address), str_len(address)) )
+	{
+		*error_r = str_c(ctx.error);
+		return FALSE;
+	}
+
+	*error_r = NULL;
+	return TRUE;
+}
+
+int sieve_address_compare
+(const char *address1, const char *address2, bool normalized ATTR_UNUSED)
+{
+	/* NOTE: this deviates from RFC specification in that it compares the local
+	 * part of the address case-insensitively. This however conforms to the
+	 * consensus in mail software.
+	 */
+
+	/* FIXME: provided addresses are currently assumed to be normalized to
+	 * local_part@domain
+	 */
+
+	i_assert(address1 != NULL);
+	i_assert(address2 != NULL);
+
+	return strcasecmp(address1, address2);
+}
+
+/*
+ * RFC 2821 addresses (envelope paths)
+ */
+
+/* FIXME: Quite a bit of this will overlap with the rfc822 parser
+ * dovecot already has and the rfc2821 parser that it probably will
+ * have once it implements LMTP. For now we implement things separately.
+ */
+
+#define AB (1<<0)
+#define DB (1<<1)
+#define QB (1<<2)
+
+/* atext = ALPHA / DIGIT / "!" / "#" / "$" / "%"
+ *         / "&" / "'" / "*" / "+" / "-" / "/" / "="
+ *         / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"
+ */
+//#define IS_ATEXT(C) ((rfc2821_chars[C] & AB) != 0)
+
+/* dtext = NO-WS-CTL / %d33-90 / %d94-126
+ * NO-WS-CTL = %d1-8 / %d11 / %d12 / %d14-31 / %d127
+ */
+#define IS_DTEXT(C) ((rfc2821_chars[C] & DB) != 0)
+
+/* qtext= NO-WS-CTL  / %d33 / %d35-91 / %d93-126 */
+#define IS_QTEXT(C) ((rfc2821_chars[C] & QB) == 0)
+
+/* text	= %d1-9 / %d11 / %d12 / %d14-127 / obs-text*/
+#define IS_TEXT(C) ((C) != '\r' && (C) != '\n' && (C) < 128)
+
+static unsigned char rfc2821_chars[256] = {
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 0
+	   DB,    QB,    QB,    DB,    DB,    QB,    DB,    DB, // 8
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 16
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 24
+	   QB, DB|AB, QB|DB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 32
+	   DB,    DB, DB|AB, DB|AB,    DB, DB|AB,    DB, DB|AB, // 40
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 48
+	   DB,    DB,    DB,    DB,    DB, DB|AB,    DB, DB|AB, // 56
+	   DB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 64
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 72
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 80
+	DB|AB, DB|AB, DB|AB,     0,    QB,     0, DB|AB, DB|AB, // 88
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 96
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 104
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 112
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|QB, // 120
+
+	0, 0, 0, 0, 0, 0, 0, 0, // 128
+	0, 0, 0, 0, 0, 0, 0, 0, // 136
+	0, 0, 0, 0, 0, 0, 0, 0, // 144
+	0, 0, 0, 0, 0, 0, 0, 0, // 152
+	0, 0, 0, 0, 0, 0, 0, 0, // 160
+	0, 0, 0, 0, 0, 0, 0, 0, // 168
+	0, 0, 0, 0, 0, 0, 0, 0, // 176
+	0, 0, 0, 0, 0, 0, 0, 0, // 184
+	0, 0, 0, 0, 0, 0, 0, 0, // 192
+	0, 0, 0, 0, 0, 0, 0, 0, // 200
+	0, 0, 0, 0, 0, 0, 0, 0, // 208
+	0, 0, 0, 0, 0, 0, 0, 0, // 216
+	0, 0, 0, 0, 0, 0, 0, 0, // 224
+	0, 0, 0, 0, 0, 0, 0, 0, // 232
+	0, 0, 0, 0, 0, 0, 0, 0, // 240
+	0, 0, 0, 0, 0, 0, 0, 0, // 248
+
+};
+
+struct sieve_envelope_address_parser {
+	pool_t pool;
+
+	const unsigned char *data;
+	const unsigned char *end;
+
+	string_t *str;
+
+	struct sieve_address *address;
+};
+
+static int path_skip_white_space(struct sieve_envelope_address_parser *parser)
+{
+	/* Not mentioned anywhere in the specification, but we do it any way
+	 * (e.g. Exim does so too)
+	 */
+	while ( parser->data < parser->end &&
+		(*parser->data == ' ' || *parser->data == '\t') )
+		parser->data++;
+
+	return parser->data < parser->end;
+}
+
+static int path_skip_address_literal
+(struct sieve_envelope_address_parser *parser)
+{
+	int count = 0;
+
+	/* Currently we are oblivious to address syntax:
+	 * address-literal = "[" 1*dcontent "]"
+	 * dcontent	= dtext / quoted-pair
+	 */
+
+	i_assert ( *parser->data == '[' );
+
+	str_append_c(parser->str, *parser->data);
+	parser->data++;
+
+	while ( parser->data < parser->end ) {
+		if ( *parser->data == '\\' ) {
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			if ( parser->data < parser->end ) {
+				if ( !IS_TEXT(*parser->data) )
+					return -1;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			} else return -1;
+		} else {
+			if ( !IS_DTEXT(*parser->data) )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+		}
+
+		count++;
+	}
+
+
+	if ( count == 0 || parser->data >= parser->end || *parser->data != ']' )
+		return -1;
+
+	str_append_c(parser->str, *parser->data);
+	parser->data++;
+
+	return parser->data < parser->end;
+}
+
+static int path_parse_domain
+(struct sieve_envelope_address_parser *parser, bool skip)
+{
+	int ret;
+
+	/* Domain = (sub-domain 1*("." sub-domain)) / address-literal
+	 * sub-domain = Let-dig [Ldh-str]
+	 * Let-dig = ALPHA / DIGIT
+	 * Ldh-str = *( ALPHA / DIGIT / "-" ) Let-dig
+	 */
+
+	str_truncate(parser->str, 0);
+	if ( *parser->data == '[' ) {
+		ret = path_skip_address_literal(parser);
+
+		if ( ret < 0 ) return ret;
+	} else {
+		for (;;) {
+			if ( !i_isalnum(*parser->data) )
+				return -1;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			while ( parser->data < parser->end ) {
+				if ( !i_isalnum(*parser->data) && *parser->data != '-' )
+					break;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+
+			if ( !i_isalnum(*(parser->data-1)) )
+				return -1;
+
+			if ( (ret=path_skip_white_space(parser)) < 0 )
+				return ret;
+
+			if ( *parser->data != '.' )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+		}
+	}
+
+	if ( !skip )
+		parser->address->domain = p_strdup(parser->pool, str_c(parser->str));
+
+	return path_skip_white_space(parser);
+}
+
+static int path_skip_source_route(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+
+	/* Source-route = [ A-d-l ":" ]
+	 * A-d-l = At-domain *( "," A-d-l )
+	 * At-domain = "@" domain
+	 */
+
+	if ( *parser->data == '@' ) {
+		parser->data++;
+
+		for (;;) {
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+
+			if ( (ret=path_parse_domain(parser, TRUE)) <= 0 )
+				return -1;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return ret;
+
+			/* Next? */
+			if ( *parser->data != ',' )
+				break;
+			parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+
+			if ( *parser->data != '@' )
+				return -1;
+			parser->data++;
+		}
+
+		if ( *parser->data != ':' )
+			return -1;
+		parser->data++;
+	}
+
+	return path_skip_white_space(parser);
+}
+
+static int path_parse_local_part(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+	/* Local-part = Dot-string / Quoted-string
+	 * Dot-string = Atom *("." Atom)
+	 * Atom = 1*atext
+	 * Quoted-string = DQUOTE *qcontent DQUOTE
+	 * qcontent = qtext / quoted-pair
+	 * quoted-pair  =   ("\" text)
+	 */
+
+	str_truncate(parser->str, 0);
+	if ( *parser->data == '"' ) {
+		str_append_c(parser->str, *parser->data);
+		parser->data++;
+
+		while ( parser->data < parser->end ) {
+			if ( *parser->data == '\\' ) {
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+
+				if ( parser->data < parser->end ) {
+					if ( !IS_TEXT(*parser->data) )
+						return -1;
+
+					str_append_c(parser->str, *parser->data);
+					parser->data++;
+				} else return -1;
+			} else {
+				if ( !IS_QTEXT(*parser->data) )
+					break;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+		}
+
+		if ( *parser->data != '"' )
+			return -1;
+
+		str_append_c(parser->str, *parser->data);
+		parser->data++;
+
+		if ( (ret=path_skip_white_space(parser)) < 0 )
+			return ret;
+	} else {
+		for (;;) {
+			if ( !IS_ATEXT(*parser->data) )
+				return -1;
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			while ( parser->data < parser->end && IS_ATEXT(*parser->data)) {
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+
+			if ( (ret=path_skip_white_space(parser)) < 0 )
+				return ret;
+
+			if ( *parser->data != '.' )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+				parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+		}
+	}
+
+	parser->address->local_part = p_strdup(parser->pool, str_c(parser->str));
+	return parser->data < parser->end;
+}
+
+static int path_parse_mailbox(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+
+	/* Mailbox = Local-part "@" Domain */
+
+	if ( (ret=path_parse_local_part(parser)) <= 0 )
+		return -1;
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return -1;
+
+	if ( *parser->data != '@' )
+		return -1;
+	parser->data++;
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return -1;
+
+	return path_parse_domain(parser, FALSE);
+}
+
+static int path_parse(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+	bool brackets = FALSE;
+
+	/* Path = "<" [ A-d-l ":" ] Mailbox ">" */
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return ret;
+
+	/* We allow angle brackets to be missing */
+	if ( *parser->data == '<' ) {
+		parser->data++;
+		brackets = TRUE;
+
+		if ( (ret=path_skip_white_space(parser)) <= 0 )
+			return -1;
+
+		/* Null path? */
+		if ( *parser->data == '>' ) {
+			parser->data++;
+			return path_skip_white_space(parser);
+		}
+	}
+
+	/*  [ A-d-l ":" ] Mailbox */
+	if ( (ret=path_skip_source_route(parser)) <= 0 )
+		return -1;
+
+	if ( (ret=path_parse_mailbox(parser)) < 0 )
+		return -1;
+
+	if ( ret > 0 && (ret=path_skip_white_space(parser)) < 0 )
+		return -1;
+
+	if ( brackets ) {
+		if ( ret <= 0 ) return -1;
+
+		if ( *parser->data != '>' )
+			return -1;
+		parser->data++;
+	}
+
+	return parser->data < parser->end;
+}
+
+const struct sieve_address *sieve_address_parse_envelope_path
+(pool_t pool, const char *field_value)
+{
+	struct sieve_envelope_address_parser parser;
+	int ret;
+
+	if ( field_value == NULL ) {
+		return p_new(pool, struct sieve_address, 1);
+	}
+
+	parser.pool = pool;
+	parser.data = (const unsigned char *) field_value;
+	parser.end = (const unsigned char *) field_value + strlen(field_value);
+	parser.address = p_new(pool, struct sieve_address, 1);
+	parser.str = t_str_new(256); /* IMPORTAINT: maintain datastack level */
+
+	if ( (ret=path_parse(&parser)) < 0 )
+		return NULL;
+
+	if ( ret > 0 && path_skip_white_space(&parser) < 0 )
+		return NULL;
+
+	if ( parser.data != parser.end )
+		return NULL;
+
+	return parser.address;
+}
+
+
Index: b/sieve/src/lib-sieve/sieve-address.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-address.h
@@ -0,0 +1,52 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ADDRESS_H
+#define __SIEVE_ADDRESS_H
+
+#include "lib.h"
+#include "strfuncs.h"
+
+/*
+ * Generic address representation
+ */
+
+struct sieve_address {
+	const char *local_part;
+	const char *domain;
+};
+
+static inline const char *sieve_address_to_string(const struct sieve_address *address)
+{
+    if ( address == NULL || address->local_part == NULL || address->domain == NULL )
+        return NULL;
+
+    return t_strconcat(address->local_part, "@", address->domain, NULL);
+}
+
+/*
+ * RFC 2822 addresses
+ */
+
+bool sieve_rfc2822_mailbox_validate
+	(const char *address, const char **error_r);
+const char *sieve_rfc2822_mailbox_normalize
+	(const char *address, const char **error_r);
+
+
+const char *sieve_address_normalize
+	(string_t *address, const char **error_r);
+bool sieve_address_validate
+	(string_t *address, const char **error_r);
+
+int sieve_address_compare
+	(const char *address1, const char *address2, bool normalized);
+
+/*
+ * RFC 2821 addresses (paths)
+ */
+
+const struct sieve_address *sieve_address_parse_envelope_path
+	(pool_t pool, const char *field_value);
+
+#endif
Index: b/sieve/src/lib-sieve/sieve-ast.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-ast.c
@@ -0,0 +1,1064 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-extensions.h"
+
+#include "sieve-ast.h"
+
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static struct sieve_ast_node *sieve_ast_node_create
+	(struct sieve_ast *ast, struct sieve_ast_node *parent,
+		enum sieve_ast_type type, unsigned int source_line);
+
+/*
+ * Types
+ */
+
+/* Extensions to the AST */
+
+struct sieve_ast_extension_reg {
+	const struct sieve_extension *ext;
+	const struct sieve_ast_extension *ast_ext;
+	void *context;
+};
+
+/*
+ * AST object
+ */
+
+struct sieve_ast {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_instance *svinst;
+
+	struct sieve_script *script;
+
+	struct sieve_ast_node *root;
+
+	ARRAY_DEFINE(linked_extensions, const struct sieve_extension *);
+	ARRAY_DEFINE(extensions, struct sieve_ast_extension_reg);
+};
+
+struct sieve_ast *sieve_ast_create
+(struct sieve_script *script)
+{
+	pool_t pool;
+	struct sieve_ast *ast;
+	unsigned int ext_count;
+
+	pool = pool_alloconly_create("sieve_ast", 16384);
+	ast = p_new(pool, struct sieve_ast, 1);
+	ast->pool = pool;
+	ast->refcount = 1;
+
+	ast->script = script;
+	sieve_script_ref(script);
+	ast->svinst = sieve_script_svinst(script);
+
+	ast->root = sieve_ast_node_create(ast, NULL, SAT_ROOT, 0);
+	ast->root->identifier = "ROOT";
+
+	ext_count = sieve_extensions_get_count(ast->svinst);
+	p_array_init(&ast->linked_extensions, pool, ext_count);
+	p_array_init(&ast->extensions, pool, ext_count);
+
+	return ast;
+}
+
+void sieve_ast_ref(struct sieve_ast *ast)
+{
+	ast->refcount++;
+}
+
+void sieve_ast_unref(struct sieve_ast **ast)
+{
+	unsigned int i, ext_count;
+	const struct sieve_ast_extension_reg *extrs;
+
+	i_assert((*ast)->refcount > 0);
+
+	if (--(*ast)->refcount != 0)
+		return;
+
+	/* Release script reference */
+	sieve_script_unref(&(*ast)->script);
+
+	/* Signal registered extensions that the AST is being destroyed */
+	extrs = array_get(&(*ast)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].ast_ext != NULL &&
+			extrs[i].ast_ext->free != NULL )
+			extrs[i].ast_ext->free(extrs[i].ext, *ast, extrs[i].context);
+	}
+
+	/* Destroy AST */
+	pool_unref(&(*ast)->pool);
+
+	*ast = NULL;
+}
+
+struct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast)
+{
+	return ast->root;
+}
+
+pool_t sieve_ast_pool(struct sieve_ast *ast)
+{
+	return ast->pool;
+}
+
+struct sieve_script *sieve_ast_script(struct sieve_ast *ast)
+{
+	return ast->script;
+}
+
+/*
+ * Extension support
+ */
+
+void sieve_ast_extension_link
+(struct sieve_ast *ast, const struct sieve_extension *ext)
+{
+	unsigned int i, ext_count;
+	const struct sieve_extension *const *extensions;
+
+	if ( ext->id < 0 ) return;
+
+	/* Prevent duplicates */
+	extensions = array_get(&ast->linked_extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extensions[i] == ext )
+			return;
+	}
+
+	/* Add extension */
+	array_append(&ast->linked_extensions, &ext, 1);
+}
+
+const struct sieve_extension * const *sieve_ast_extensions_get
+(struct sieve_ast *ast, unsigned int *count_r)
+{
+	return array_get(&ast->linked_extensions, count_r);
+}
+
+void sieve_ast_extension_register
+(struct sieve_ast *ast, const struct sieve_extension *ext,
+	const struct sieve_ast_extension *ast_ext, void *context)
+{
+	struct sieve_ast_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	/* Initialize registration */
+	reg = array_idx_modifiable(&ast->extensions, (unsigned int) ext->id);
+	reg->ast_ext = ast_ext;
+	reg->ext = ext;
+	reg->context = context;
+}
+
+void *sieve_ast_extension_get_context
+(struct sieve_ast *ast, const struct sieve_extension *ext)
+{
+	const struct sieve_ast_extension_reg *reg;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&ast->extensions) )
+		return NULL;
+
+	reg = array_idx(&ast->extensions, (unsigned int) ext->id);
+
+	return reg->context;
+}
+
+/*
+ * AST list implementations
+ */
+
+/* Very simplistic linked list implementation
+ * FIXME: Move to separate file
+ */
+#define __LIST_CREATE(pool, type) { \
+		type *list = p_new(pool, type, 1); \
+		list->head = NULL; \
+		list->tail = NULL; \
+		list->len = 0;		\
+		return list; \
+	}
+
+#define __LIST_ADD(list, node) { \
+		if ( list->len + 1 < list->len ) \
+			return FALSE; \
+		\
+		node->next = NULL; \
+		if ( list->head == NULL ) { \
+			node->prev = NULL; \
+			list->head = node; \
+			list->tail = node; \
+		} else { \
+			list->tail->next = node; \
+			node->prev = list->tail; \
+			list->tail = node; \
+		} \
+		list->len++; \
+		node->list = list; \
+		return TRUE; \
+	}
+
+#define __LIST_INSERT(list, before, node) { \
+		if ( list->len + 1 < list->len ) \
+			return FALSE; \
+		\
+		node->next = before; \
+		if ( list->head == before ) { \
+			node->prev = NULL; \
+			list->head = node; \
+		} else { \
+			before->prev->next = node; \
+		} \
+		node->prev = before->prev; \
+		before->prev = node; \
+		list->len++; \
+		node->list = list; \
+		\
+		return TRUE; \
+	}
+
+#define __LIST_JOIN(list, node_type, items) { \
+		node_type *node; \
+		\
+		if ( list->len + items->len < list->len ) \
+			return FALSE; \
+		\
+		if ( items->len == 0 ) return TRUE; \
+		\
+		if ( list->head == NULL ) { \
+			list->head = items->head; \
+			list->tail = items->tail; \
+		} else { \
+			list->tail->next = items->head; \
+			items->head->prev = list->tail; \
+			list->tail = items->tail; \
+		} \
+		list->len += items->len; \
+		\
+		node = items->head; \
+		while ( node != NULL ) { \
+			node->list = list; \
+			node = node->next; \
+		} \
+		return TRUE; \
+	}
+
+#define __LIST_DETACH(first, node_type, count) { \
+		node_type *last, *result; \
+		unsigned int left; \
+		\
+		i_assert(first->list != NULL); \
+		\
+		left = count - 1; \
+		last = first; \
+		while ( left > 0 && last->next != NULL ) { \
+			left--; \
+			last = last->next; \
+		} \
+		\
+		if ( first->list->head == first ) \
+			first->list->head = last->next; \
+		if ( first->list->tail == last ) \
+			first->list->tail = first->prev; \
+		\
+		if ( first->prev != NULL ) \
+			first->prev->next = last->next;	\
+		if ( last->next != NULL ) \
+			last->next->prev = first->prev; \
+		\
+		first->list->len -= count - left; \
+		\
+		result = last->next; \
+		first->prev = NULL; \
+		last->next = NULL; \
+		\
+		return result; \
+	}
+
+/* List of AST nodes */
+
+static struct sieve_ast_list *sieve_ast_list_create(pool_t pool)
+	__LIST_CREATE(pool, struct sieve_ast_list)
+
+static bool sieve_ast_list_add
+(struct sieve_ast_list *list, struct sieve_ast_node *node)
+	__LIST_ADD(list, node)
+
+static struct sieve_ast_node *sieve_ast_list_detach
+(struct sieve_ast_node *first, unsigned int count)
+	__LIST_DETACH(first, struct sieve_ast_node, count)
+
+/* List of argument AST nodes */
+
+struct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool)
+	__LIST_CREATE(pool, struct sieve_ast_arg_list)
+
+bool sieve_ast_arg_list_add
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument)
+	__LIST_ADD(list, argument)
+
+bool sieve_ast_arg_list_insert
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,
+	struct sieve_ast_argument *argument)
+	__LIST_INSERT(list, before, argument)
+
+static bool sieve_ast_arg_list_join
+(struct sieve_ast_arg_list *list, struct sieve_ast_arg_list *items)
+	__LIST_JOIN(list, struct sieve_ast_argument, items)
+
+static struct sieve_ast_argument *sieve_ast_arg_list_detach
+(struct sieve_ast_argument *first, const unsigned int count)
+	__LIST_DETACH(first, struct sieve_ast_argument, count)
+
+void sieve_ast_arg_list_substitute
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument,
+	struct sieve_ast_argument *replacement)
+{
+	if ( list->head == argument )
+		list->head = replacement;
+	if ( list->tail == argument )
+		list->tail = replacement;
+
+	if ( argument->prev != NULL )
+		argument->prev->next = replacement;
+	if ( argument->next != NULL )
+		argument->next->prev = replacement;
+
+	replacement->prev = argument->prev;
+	replacement->next = argument->next;
+	replacement->list = argument->list;
+
+	argument->next = NULL;
+	argument->prev = NULL;
+}
+
+/*
+ * AST node
+ */
+
+static struct sieve_ast_node *sieve_ast_node_create
+(struct sieve_ast *ast, struct sieve_ast_node *parent, enum sieve_ast_type type,
+	unsigned int source_line)
+{
+	struct sieve_ast_node *node = p_new(ast->pool, struct sieve_ast_node, 1);
+
+	node->ast = ast;
+	node->parent = parent;
+	node->type = type;
+
+	node->prev = NULL;
+	node->next = NULL;
+
+	node->arguments = NULL;
+	node->tests = NULL;
+	node->commands = NULL;
+
+	node->test_list = FALSE;
+	node->block = FALSE;
+
+	node->source_line = source_line;
+
+	return node;
+}
+
+static bool sieve_ast_node_add_command
+(struct sieve_ast_node *node, struct sieve_ast_node *command)
+{
+	i_assert( command->type == SAT_COMMAND &&
+		(node->type == SAT_ROOT || node->type == SAT_COMMAND) );
+
+	if (node->commands == NULL)
+		node->commands = sieve_ast_list_create(node->ast->pool);
+
+	return sieve_ast_list_add(node->commands, command);
+}
+
+static bool sieve_ast_node_add_test
+(struct sieve_ast_node *node, struct sieve_ast_node *test)
+{
+	i_assert( test->type == SAT_TEST &&
+		(node->type == SAT_TEST || node->type == SAT_COMMAND) );
+
+	if (node->tests == NULL)
+		node->tests = sieve_ast_list_create(node->ast->pool);
+
+	return sieve_ast_list_add(node->tests, test);
+}
+
+static bool sieve_ast_node_add_argument
+(struct sieve_ast_node *node, struct sieve_ast_argument *argument)
+{
+	i_assert( node->type == SAT_TEST || node->type == SAT_COMMAND );
+
+	if (node->arguments == NULL)
+		node->arguments = sieve_ast_arg_list_create(node->ast->pool);
+
+	return sieve_ast_arg_list_add(node->arguments, argument);
+}
+
+struct sieve_ast_node *sieve_ast_node_detach
+(struct sieve_ast_node *first)
+{
+	return sieve_ast_list_detach(first, 1);
+}
+
+const char *sieve_ast_type_name
+(enum sieve_ast_type ast_type)
+{
+	switch ( ast_type ) {
+
+	case SAT_NONE: return "none";
+	case SAT_ROOT: return "ast root node";
+	case SAT_COMMAND: return "command";
+	case SAT_TEST: return "test";
+
+	default: return "??AST NODE??";
+	}
+}
+
+/*
+ * Argument AST node
+ */
+
+struct sieve_ast_argument *sieve_ast_argument_create
+(struct sieve_ast *ast, unsigned int source_line)
+{
+	struct sieve_ast_argument *arg =
+		p_new(ast->pool, struct sieve_ast_argument, 1);
+
+	arg->ast = ast;
+
+	arg->prev = NULL;
+	arg->next = NULL;
+
+	arg->source_line = source_line;
+
+	arg->argument = NULL;
+
+	return arg;
+}
+
+static void sieve_ast_argument_substitute
+(struct sieve_ast_argument *argument, struct sieve_ast_argument *replacement)
+{
+	sieve_ast_arg_list_substitute(argument->list, argument, replacement);
+}
+
+struct sieve_ast_argument *sieve_ast_argument_string_create_raw
+(struct sieve_ast *ast, string_t *str, unsigned int source_line)
+{
+	struct sieve_ast_argument *argument = sieve_ast_argument_create
+		(ast, source_line);
+
+	argument->type = SAAT_STRING;
+	argument->_value.str = str;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_string_create
+(struct sieve_ast_node *node, const string_t *str, unsigned int source_line)
+{
+	struct sieve_ast_argument *argument;
+	string_t *newstr;
+
+	/* Allocate new internal string buffer */
+	newstr = str_new(node->ast->pool, str_len(str));
+
+	/* Clone string */
+	str_append_str(newstr, str);
+
+	/* Create string argument */
+	argument = sieve_ast_argument_string_create_raw
+		(node->ast, newstr, source_line);
+
+	/* Add argument to command/test node */
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_cstring_create
+(struct sieve_ast_node *node, const char *str, unsigned int source_line)
+{
+	struct sieve_ast_argument *argument;
+	string_t *newstr;
+
+	/* Allocate new internal string buffer */
+	newstr = str_new(node->ast->pool, strlen(str));
+
+	/* Clone string */
+	str_append(newstr, str);
+
+	/* Create string argument */
+	argument = sieve_ast_argument_string_create_raw
+		(node->ast, newstr, source_line);
+
+	/* Add argument to command/test node */
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+void sieve_ast_argument_string_set
+(struct sieve_ast_argument *argument, string_t *newstr)
+{
+	i_assert( argument->type == SAAT_STRING);
+	argument->_value.str = newstr;
+}
+
+void sieve_ast_argument_string_setc
+(struct sieve_ast_argument *argument, const char *newstr)
+{
+	i_assert( argument->type == SAAT_STRING);
+
+	str_truncate(argument->_value.str, 0);
+	str_append(argument->_value.str, newstr);
+}
+
+void sieve_ast_argument_number_substitute
+(struct sieve_ast_argument *argument, unsigned int number)
+{
+	argument->type = SAAT_NUMBER;
+	argument->_value.number = number;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_create
+(struct sieve_ast_node *node, unsigned int source_line)
+{
+	struct sieve_ast_argument *argument =
+		sieve_ast_argument_create(node->ast, source_line);
+
+	argument->type = SAAT_STRING_LIST;
+	argument->_value.strlist = NULL;
+
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_substitute
+(struct sieve_ast_node *node, struct sieve_ast_argument *arg)
+{
+	struct sieve_ast_argument *argument =
+		sieve_ast_argument_create(node->ast, arg->source_line);
+
+	argument->type = SAAT_STRING_LIST;
+	argument->_value.strlist = NULL;
+
+	sieve_ast_argument_substitute(arg, argument);
+
+	return argument;
+}
+
+static inline bool _sieve_ast_stringlist_add_item
+(struct sieve_ast_argument *list, struct sieve_ast_argument *item)
+{
+	i_assert( list->type == SAAT_STRING_LIST );
+
+	if ( list->_value.strlist == NULL )
+		list->_value.strlist = sieve_ast_arg_list_create(list->ast->pool);
+
+	return sieve_ast_arg_list_add(list->_value.strlist, item);
+}
+
+static bool sieve_ast_stringlist_add_stringlist
+(struct sieve_ast_argument *list, struct sieve_ast_argument *items)
+{
+	i_assert( list->type == SAAT_STRING_LIST );
+	i_assert( items->type == SAAT_STRING_LIST );
+
+	if ( list->_value.strlist == NULL )
+		list->_value.strlist = sieve_ast_arg_list_create(list->ast->pool);
+
+	return sieve_ast_arg_list_join(list->_value.strlist, items->_value.strlist);
+}
+
+static bool _sieve_ast_stringlist_add_str
+(struct sieve_ast_argument *list, string_t *str, unsigned int source_line)
+{
+	struct sieve_ast_argument *stritem;
+
+	stritem = sieve_ast_argument_create(list->ast, source_line);
+	stritem->type = SAAT_STRING;
+	stritem->_value.str = str;
+
+	return _sieve_ast_stringlist_add_item(list, stritem);
+}
+
+bool sieve_ast_stringlist_add
+(struct sieve_ast_argument *list, const string_t *str, unsigned int source_line)
+{
+	string_t *copied_str = str_new(list->ast->pool, str_len(str));
+	str_append_str(copied_str, str);
+
+	return _sieve_ast_stringlist_add_str(list, copied_str, source_line);
+}
+
+bool sieve_ast_stringlist_add_strc
+(struct sieve_ast_argument *list, const char *str, unsigned int source_line)
+{
+	string_t *copied_str = str_new(list->ast->pool, strlen(str));
+	str_append(copied_str, str);
+
+	return _sieve_ast_stringlist_add_str(list, copied_str, source_line);
+}
+
+struct sieve_ast_argument *sieve_ast_argument_tag_create
+(struct sieve_ast_node *node, const char *tag, unsigned int source_line)
+{
+	struct sieve_ast_argument *argument =
+		sieve_ast_argument_create(node->ast, source_line);
+
+	argument->type = SAAT_TAG;
+	argument->_value.tag = p_strdup(node->ast->pool, tag);
+
+	if ( !sieve_ast_node_add_argument(node, argument) )
+		return NULL;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_tag_insert
+(struct sieve_ast_argument *before, const char *tag, unsigned int source_line)
+{
+	struct sieve_ast_argument *argument =
+		sieve_ast_argument_create(before->ast, source_line);
+
+	argument->type = SAAT_TAG;
+	argument->_value.tag = p_strdup(before->ast->pool, tag);
+
+	if ( !sieve_ast_arg_list_insert(before->list, before, argument) )
+		return NULL;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_number_create
+(struct sieve_ast_node *node, unsigned int number, unsigned int source_line)
+{
+
+	struct sieve_ast_argument *argument =
+		sieve_ast_argument_create(node->ast, source_line);
+
+	argument->type = SAAT_NUMBER;
+	argument->_value.number = number;
+
+	if ( !sieve_ast_node_add_argument(node, argument) )
+		return NULL;
+
+	return argument;
+}
+
+void sieve_ast_argument_number_set
+(struct sieve_ast_argument *argument, unsigned int newnum)
+{
+	i_assert( argument->type == SAAT_NUMBER );
+	argument->_value.number = newnum;
+}
+
+
+struct sieve_ast_argument *sieve_ast_arguments_detach
+(struct sieve_ast_argument *first, unsigned int count)
+{
+	return sieve_ast_arg_list_detach(first, count);
+}
+
+bool sieve_ast_argument_attach
+(struct sieve_ast_node *node, struct sieve_ast_argument *argument)
+{
+	return sieve_ast_node_add_argument(node, argument);
+}
+
+const char *sieve_ast_argument_type_name
+(enum sieve_ast_argument_type arg_type)
+{
+	switch ( arg_type ) {
+
+	case SAAT_NONE: return "none";
+	case SAAT_STRING_LIST: return "a string list";
+	case SAAT_STRING: return "a string";
+	case SAAT_NUMBER: return "a number";
+	case SAAT_TAG: return "a tag";
+
+	default: return "??ARGUMENT??";
+	}
+}
+
+/* Test AST node */
+
+struct sieve_ast_node *sieve_ast_test_create
+(struct sieve_ast_node *parent, const char *identifier,
+	unsigned int source_line)
+{
+	struct sieve_ast_node *test = sieve_ast_node_create
+		(parent->ast, parent, SAT_TEST, source_line);
+
+	test->identifier = p_strdup(parent->ast->pool, identifier);
+
+	if ( !sieve_ast_node_add_test(parent, test) )
+		return NULL;
+
+	return test;
+}
+
+/* Command AST node */
+
+struct sieve_ast_node *sieve_ast_command_create
+(struct sieve_ast_node *parent, const char *identifier,
+	unsigned int source_line)
+{
+
+	struct sieve_ast_node *command = sieve_ast_node_create
+		(parent->ast, parent, SAT_COMMAND, source_line);
+
+	command->identifier = p_strdup(parent->ast->pool, identifier);
+
+	if ( !sieve_ast_node_add_command(parent, command) )
+		return NULL;
+
+	return command;
+}
+
+/*
+ * Utility
+ */
+
+int sieve_ast_stringlist_map
+(struct sieve_ast_argument **listitem, void *context,
+	int (*map_function)(void *context, struct sieve_ast_argument *arg))
+{
+	if ( sieve_ast_argument_type(*listitem) == SAAT_STRING ) {
+		/* Single string */
+		return map_function(context, *listitem);
+	} else if ( sieve_ast_argument_type(*listitem) == SAAT_STRING_LIST ) {
+		int ret = 0;
+
+		/* String list */
+		*listitem = sieve_ast_strlist_first(*listitem);
+
+		while ( *listitem != NULL ) {
+
+			if ( (ret=map_function(context, *listitem)) <= 0 )
+				return ret;
+
+			*listitem = sieve_ast_strlist_next(*listitem);
+		}
+
+		return ret;
+	}
+
+	i_unreached();
+	return -1;
+}
+
+struct sieve_ast_argument *sieve_ast_stringlist_join
+(struct sieve_ast_argument *list, struct sieve_ast_argument *items)
+{
+	enum sieve_ast_argument_type list_type, items_type;
+	struct sieve_ast_argument *newlist;
+
+	list_type = sieve_ast_argument_type(list);
+	items_type = sieve_ast_argument_type(items);
+
+	switch ( list_type ) {
+
+	case SAAT_STRING:
+		switch ( items_type ) {
+
+		case SAAT_STRING:
+			newlist =
+				sieve_ast_argument_create(list->ast, list->source_line);
+			newlist->type = SAAT_STRING_LIST;
+			newlist->_value.strlist = NULL;
+
+			sieve_ast_argument_substitute(list, newlist);
+			sieve_ast_arguments_detach(items, 1);
+
+			if ( !_sieve_ast_stringlist_add_item(newlist, list) ||
+				!_sieve_ast_stringlist_add_item(newlist, items) ) {
+				return NULL;
+			}
+
+			return newlist;
+
+		case SAAT_STRING_LIST:
+			/* Adding stringlist to string; make them swith places and add one to the
+			 * other.
+			 */
+			sieve_ast_arguments_detach(items, 1);
+			sieve_ast_argument_substitute(list, items);
+			if ( !_sieve_ast_stringlist_add_item(items, list) )
+				return NULL;
+
+			return list;
+
+		default:
+			i_unreached();
+		}
+		break;
+
+	case SAAT_STRING_LIST:
+		switch ( items_type ) {
+
+		case SAAT_STRING:
+			/* Adding string to stringlist; straightforward add */
+			sieve_ast_arguments_detach(items, 1);
+			if ( !_sieve_ast_stringlist_add_item(list, items) )
+				return NULL;
+
+			return list;
+
+		case SAAT_STRING_LIST:
+			/* Adding stringlist to stringlist; perform actual join */
+			sieve_ast_arguments_detach(items, 1);
+			if ( !sieve_ast_stringlist_add_stringlist(list, items) )
+				return NULL;
+
+			return list;
+
+		default:
+			i_unreached();
+		}
+
+		break;
+	default:
+		i_unreached();
+	}
+
+	return NULL;
+}
+
+
+/* Debug */
+
+/* Unparsing, currently implemented using plain printf()s */
+
+static void sieve_ast_unparse_string(const string_t *strval)
+{
+	char *str = t_strdup_noconst(str_c((string_t *) strval));
+
+	if ( strchr(str, '\n') != NULL && str[strlen(str)-1] == '\n' ) {
+		/* Print it as a multi-line string and do required dotstuffing */
+		char *spos = str;
+		char *epos = strchr(str, '\n');
+		printf("text:\n");
+
+		while ( epos != NULL ) {
+			*epos = '\0';
+			if ( *spos == '.' )
+				printf(".");
+
+			printf("%s\n", spos);
+
+			spos = epos+1;
+			epos = strchr(spos, '\n');
+		}
+		if ( *spos == '.' )
+				printf(".");
+
+		printf("%s\n.\n", spos);
+	} else {
+		/* Print it as a quoted string and escape " */
+		char *spos = str;
+		char *epos = strchr(str, '"');
+		printf("\"");
+
+		while ( epos != NULL ) {
+			*epos = '\0';
+			printf("%s\\\"", spos);
+
+			spos = epos+1;
+			epos = strchr(spos, '"');
+		}
+
+		printf("%s\"", spos);
+	}
+}
+
+static void sieve_ast_unparse_argument
+	(struct sieve_ast_argument *argument, int level);
+
+static void sieve_ast_unparse_stringlist
+(struct sieve_ast_argument *strlist, int level)
+{
+	struct sieve_ast_argument *stritem;
+
+	if ( sieve_ast_strlist_count(strlist) > 1 ) {
+		int i;
+
+		printf("[\n");
+
+		/* Create indent */
+		for ( i = 0; i < level+2; i++ )
+			printf("  ");
+
+		stritem = sieve_ast_strlist_first(strlist);
+		sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+
+		stritem = sieve_ast_strlist_next(stritem);
+		while ( stritem != NULL ) {
+			printf(",\n");
+			for ( i = 0; i < level+2; i++ )
+				printf("  ");
+			sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+		  stritem = sieve_ast_strlist_next(stritem);
+	  }
+
+		printf(" ]");
+	} else {
+		stritem = sieve_ast_strlist_first(strlist);
+		if ( stritem != NULL )
+			sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+	}
+}
+
+static void sieve_ast_unparse_argument
+(struct sieve_ast_argument *argument, int level)
+{
+	switch ( argument->type ) {
+	case SAAT_STRING:
+		sieve_ast_unparse_string(sieve_ast_argument_str(argument));
+		break;
+	case SAAT_STRING_LIST:
+		sieve_ast_unparse_stringlist(argument, level+1);
+		break;
+	case SAAT_NUMBER:
+		printf("%d", sieve_ast_argument_number(argument));
+		break;
+	case SAAT_TAG:
+		printf(":%s", sieve_ast_argument_tag(argument));
+		break;
+	default:
+		printf("??ARGUMENT??");
+		break;
+	}
+}
+
+static void sieve_ast_unparse_test
+	(struct sieve_ast_node *node, int level);
+
+static void sieve_ast_unparse_tests
+(struct sieve_ast_node *node, int level)
+{
+	struct sieve_ast_node *test;
+
+	if ( sieve_ast_test_count(node) > 1 ) {
+		int i;
+
+		printf(" (\n");
+
+		/* Create indent */
+		for ( i = 0; i < level+2; i++ )
+			printf("  ");
+
+		test = sieve_ast_test_first(node);
+		sieve_ast_unparse_test(test, level+1);
+
+		test = sieve_ast_test_next(test);
+		while ( test != NULL ) {
+			printf(", \n");
+			for ( i = 0; i < level+2; i++ )
+				printf("  ");
+			sieve_ast_unparse_test(test, level+1);
+		  test = sieve_ast_test_next(test);
+	  }
+
+		printf(" )");
+	} else {
+		test = sieve_ast_test_first(node);
+		if ( test != NULL )
+			sieve_ast_unparse_test(test, level);
+	}
+}
+
+static void sieve_ast_unparse_test
+(struct sieve_ast_node *node, int level)
+{
+	struct sieve_ast_argument *argument;
+
+	printf(" %s", node->identifier);
+
+	argument = sieve_ast_argument_first(node);
+	while ( argument != NULL ) {
+		printf(" ");
+		sieve_ast_unparse_argument(argument, level);
+		argument = sieve_ast_argument_next(argument);
+	}
+
+	sieve_ast_unparse_tests(node, level);
+}
+
+static void sieve_ast_unparse_command
+(struct sieve_ast_node *node, int level)
+{
+	struct sieve_ast_node *command;
+	struct sieve_ast_argument *argument;
+
+	int i;
+
+	/* Create indent */
+	for ( i = 0; i < level; i++ )
+		printf("  ");
+
+	printf("%s", node->identifier);
+
+	argument = sieve_ast_argument_first(node);
+	while ( argument != NULL ) {
+		printf(" ");
+		sieve_ast_unparse_argument(argument, level);
+		argument = sieve_ast_argument_next(argument);
+	}
+
+	sieve_ast_unparse_tests(node, level);
+
+	command = sieve_ast_command_first(node);
+	if ( command != NULL ) {
+		printf(" {\n");
+
+		while ( command != NULL) {
+			sieve_ast_unparse_command(command, level+1);
+			command = sieve_ast_command_next(command);
+		}
+
+		for ( i = 0; i < level; i++ )
+			printf("  ");
+		printf("}\n");
+	} else
+		printf(";\n");
+}
+
+void sieve_ast_unparse(struct sieve_ast *ast)
+{
+	struct sieve_ast_node *command;
+
+	printf("Unparsing Abstract Syntax Tree:\n");
+
+	T_BEGIN {
+		command = sieve_ast_command_first(sieve_ast_root(ast));
+		while ( command != NULL ) {
+			sieve_ast_unparse_command(command, 0);
+			command = sieve_ast_command_next(command);
+		}
+	} T_END;
+}
+
+
Index: b/sieve/src/lib-sieve/sieve-ast.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-ast.h
@@ -0,0 +1,370 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_AST_H
+#define __SIEVE_AST_H
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+	Abstract Syntax Tree (AST) structure:
+
+	sieve_ast (root)
+	[*command]
+	 |
+	 +-- command:
+	 |   ....
+	 +-- command:
+	 |	 [identifier *argument                      *test *command]
+	 |                +-- argument:                 |     \--> as from root
+	 |                |   ....                      |
+ 	 |                +-- argument:                 V (continued below)
+	 |                |   [number | tag | *string]
+	 |                .
+	 .
+
+	 *test
+	 +-- test:
+	 |   ....
+	 +-- test:
+	 |   [identifier *argument                     *test]
+	 |               +-- argument:                 \-->  as from the top
+	 .               |   ....                              of this tree
+	                 +-- argument:
+	                 |   [number | tag | *string]
+	                 .
+
+	 Tests and commands are defined using the same structure: sieve_ast_node.
+	 However, arguments and string-lists are described using sieve_ast_argument.
+*/
+
+/* IMPORTANT NOTICE: Do not decorate the AST with objects other than those
+ * allocated on the ast's pool or static const objects. Otherwise it is possible
+ * that pointers in the tree become dangling which is highly undesirable.
+ */
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_ast_list;
+struct sieve_ast_arg_list;
+
+/*
+ * Types
+ */
+
+enum sieve_ast_argument_type {
+	SAAT_NONE,
+	SAAT_NUMBER,
+	SAAT_STRING,
+	SAAT_STRING_LIST,
+	SAAT_TAG,
+};
+
+enum sieve_ast_type {
+	SAT_NONE,
+	SAT_ROOT,
+	SAT_COMMAND,
+	SAT_TEST,
+};
+
+/*
+ * AST Nodes
+ */
+
+/* Argument node */
+
+struct sieve_ast_argument {
+	enum sieve_ast_argument_type type;
+
+	/* Back reference to the AST object */
+	struct sieve_ast *ast;
+
+	/* List related */
+	struct sieve_ast_arg_list *list;
+	struct sieve_ast_argument *next;
+	struct sieve_ast_argument *prev;
+
+	/* Parser-assigned data */
+
+	union {
+		string_t *str;
+		struct sieve_ast_arg_list *strlist;
+		const char *tag;
+		unsigned int number;
+	} _value;
+
+	unsigned int source_line;
+
+	/* Assigned during validation */
+
+	/* Argument associated with this ast element  */
+	struct sieve_argument *argument;
+
+	/* Parameters to this (tag) argument */
+	struct sieve_ast_argument *parameters;
+};
+
+struct sieve_ast_node {
+	enum sieve_ast_type type;
+
+	/* Back reference to the AST object */
+	struct sieve_ast *ast;
+
+	/* Back reference to this node's parent */
+	struct sieve_ast_node *parent;
+
+	/* Linked list references */
+	struct sieve_ast_list *list;
+	struct sieve_ast_node *next;
+	struct sieve_ast_node *prev;
+
+	/* Commands (NULL if not allocated) */
+	bool block;
+	struct sieve_ast_list *commands;
+
+	/* Tests (NULL if not allocated)*/
+	bool test_list;
+	struct sieve_ast_list *tests;
+
+	/* Arguments (NULL if not allocated) */
+	struct sieve_ast_arg_list *arguments;
+
+	/* Identifier of command or test */
+	const char *identifier;
+
+	/* The location in the file where this command was started */
+	unsigned int source_line;
+
+	/* Assigned during validation */
+
+	/* Context */
+	struct sieve_command *command;
+};
+
+/*
+ * AST node lists
+ */
+
+struct sieve_ast_list {
+	struct sieve_ast_node *head;
+	struct sieve_ast_node *tail;
+	unsigned int len;
+};
+
+struct sieve_ast_arg_list {
+	struct sieve_ast_argument *head;
+	struct sieve_ast_argument *tail;
+	unsigned int len;
+};
+
+/*
+ * AST object
+ */
+
+struct sieve_ast;
+
+struct sieve_ast *sieve_ast_create(struct sieve_script *script);
+void sieve_ast_ref(struct sieve_ast *ast);
+void sieve_ast_unref(struct sieve_ast **ast);
+
+struct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast);
+pool_t sieve_ast_pool(struct sieve_ast *ast);
+struct sieve_script *sieve_ast_script(struct sieve_ast *ast);
+
+/* Extension support */
+
+struct sieve_ast_extension {
+	const struct sieve_extension_def *ext;
+
+	void (*free)(const struct sieve_extension *ext, struct sieve_ast *ast,
+		void *context);
+};
+
+void sieve_ast_extension_link
+	(struct sieve_ast *ast, const struct sieve_extension *ext);
+const struct sieve_extension * const *sieve_ast_extensions_get
+	(struct sieve_ast *ast, unsigned int *count_r);
+
+void sieve_ast_extension_register
+	(struct sieve_ast *ast, const struct sieve_extension *ext,
+		const struct sieve_ast_extension *ast_ext, void *context);
+void *sieve_ast_extension_get_context
+	(struct sieve_ast *ast, const struct sieve_extension *ext);
+
+/*
+ * AST node manipulation
+ */
+
+/* Command nodes */
+
+struct sieve_ast_node *sieve_ast_test_create
+	(struct sieve_ast_node *parent, const char *identifier,
+		unsigned int source_line);
+struct sieve_ast_node *sieve_ast_command_create
+	(struct sieve_ast_node *parent, const char *identifier,
+		unsigned int source_line);
+
+struct sieve_ast_node *sieve_ast_node_detach
+	(struct sieve_ast_node *first);
+
+const char *sieve_ast_type_name(enum sieve_ast_type ast_type);
+
+/* Argument nodes */
+
+struct sieve_ast_argument *sieve_ast_argument_create
+	(struct sieve_ast *ast, unsigned int source_line);
+
+struct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool);
+bool sieve_ast_arg_list_add
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument);
+bool sieve_ast_arg_list_insert
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,
+		struct sieve_ast_argument *argument);
+void sieve_ast_arg_list_substitute
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument,
+		struct sieve_ast_argument *replacement);
+
+struct sieve_ast_argument *sieve_ast_argument_string_create_raw
+	(struct sieve_ast *ast, string_t *str, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_string_create
+	(struct sieve_ast_node *node, const string_t *str, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_cstring_create
+	(struct sieve_ast_node *node, const char *str, unsigned int source_line);
+
+struct sieve_ast_argument *sieve_ast_argument_tag_create
+	(struct sieve_ast_node *node, const char *tag, unsigned int source_line);
+
+struct sieve_ast_argument *sieve_ast_argument_number_create
+	(struct sieve_ast_node *node, unsigned int number, unsigned int source_line);
+
+void sieve_ast_argument_string_set
+	(struct sieve_ast_argument *argument, string_t *newstr);
+void sieve_ast_argument_string_setc
+	(struct sieve_ast_argument *argument, const char *newstr);
+
+void sieve_ast_argument_number_set
+	(struct sieve_ast_argument *argument, unsigned int newnum);
+void sieve_ast_argument_number_substitute
+	(struct sieve_ast_argument *argument, unsigned int number);
+
+struct sieve_ast_argument *sieve_ast_argument_tag_insert
+(struct sieve_ast_argument *before, const char *tag, unsigned int source_line);
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_create
+	(struct sieve_ast_node *node, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_stringlist_substitute
+	(struct sieve_ast_node *node, struct sieve_ast_argument *arg);
+
+struct sieve_ast_argument *sieve_ast_arguments_detach
+	(struct sieve_ast_argument *first, unsigned int count);
+bool sieve_ast_argument_attach
+	(struct sieve_ast_node *node, struct sieve_ast_argument *argument);
+
+const char *sieve_ast_argument_type_name(enum sieve_ast_argument_type arg_type);
+#define sieve_ast_argument_name(argument) \
+	sieve_ast_argument_type_name((argument)->type)
+
+bool sieve_ast_stringlist_add
+	(struct sieve_ast_argument *list, const string_t *str,
+		unsigned int source_line);
+bool sieve_ast_stringlist_add_strc
+	(struct sieve_ast_argument *list, const char *str,
+		unsigned int source_line);
+
+/*
+ * Utility
+ */
+
+int sieve_ast_stringlist_map
+	(struct sieve_ast_argument **listitem, void *context,
+		int (*map_function)(void *context, struct sieve_ast_argument *arg));
+struct sieve_ast_argument *sieve_ast_stringlist_join
+	(struct sieve_ast_argument *list, struct sieve_ast_argument *items);
+
+/*
+ * AST access macros
+ */
+
+/* Generic list access macros */
+#define __AST_LIST_FIRST(list) \
+	((list) == NULL ? NULL : (list)->head)
+#define __AST_LIST_LAST(list) \
+	((list) == NULL ? NULL : (list)->tail)
+#define __AST_LIST_COUNT(list) \
+	((list) == NULL || (list)->head == NULL ? 0 : (list)->len)
+#define __AST_LIST_NEXT(item) ((item)->next)
+#define __AST_LIST_PREV(item) ((item)->prev)
+
+#define __AST_NODE_LIST_FIRST(node, list) __AST_LIST_FIRST((node)->list)
+#define __AST_NODE_LIST_LAST(node, list) __AST_LIST_LAST((node)->list)
+#define __AST_NODE_LIST_COUNT(node, list) __AST_LIST_COUNT((node)->list)
+
+/* AST macros */
+
+/* AST node macros */
+#define sieve_ast_node_pool(node) (sieve_ast_pool((node)->ast))
+#define sieve_ast_node_parent(node) ((node)->parent)
+#define sieve_ast_node_prev(node) __AST_LIST_PREV(node)
+#define sieve_ast_node_next(node) __AST_LIST_NEXT(node)
+#define sieve_ast_node_type(node) ((node) == NULL ? SAT_NONE : (node)->type)
+#define sieve_ast_node_line(node) ((node) == NULL ? 0 : (node)->source_line)
+
+/* AST command node macros */
+#define sieve_ast_command_first(node) __AST_NODE_LIST_FIRST(node, commands)
+#define sieve_ast_command_count(node) __AST_NODE_LIST_COUNT(node, commands)
+#define sieve_ast_command_prev(command) __AST_LIST_PREV(command)
+#define sieve_ast_command_next(command) __AST_LIST_NEXT(command)
+
+/* Compare the identifier of the previous command */
+#define sieve_ast_prev_cmd_is(cmd, id) \
+	( (cmd)->prev == NULL ? FALSE : \
+		strncasecmp((cmd)->prev->identifier, id, sizeof(id)-1) == 0 )
+
+/* AST test macros */
+#define sieve_ast_test_count(node) __AST_NODE_LIST_COUNT(node, tests)
+#define sieve_ast_test_first(node) __AST_NODE_LIST_FIRST(node, tests)
+#define sieve_ast_test_next(test) __AST_LIST_NEXT(test)
+
+/* AST argument macros */
+#define sieve_ast_argument_pool(node) (sieve_ast_pool((node)->ast))
+#define sieve_ast_argument_first(node) __AST_NODE_LIST_FIRST(node, arguments)
+#define sieve_ast_argument_last(node) __AST_NODE_LIST_LAST(node, arguments)
+#define sieve_ast_argument_count(node) __AST_NODE_LIST_COUNT(node, arguments)
+#define sieve_ast_argument_prev(argument) __AST_LIST_PREV(argument)
+#define sieve_ast_argument_next(argument) __AST_LIST_NEXT(argument)
+#define sieve_ast_argument_type(argument) \
+	((argument) == NULL ? SAAT_NONE : (argument)->type)
+#define sieve_ast_argument_line(argument) \
+	((argument) == NULL ? 0 : (argument)->source_line)
+
+#define sieve_ast_argument_str(argument) ((argument)->_value.str)
+#define sieve_ast_argument_strc(argument) (str_c((argument)->_value.str))
+#define sieve_ast_argument_tag(argument) ((argument)->_value.tag)
+#define sieve_ast_argument_number(argument) ((argument)->_value.number)
+
+/* AST string list macros */
+// @UNSAFE: should check whether we are actually accessing a string list
+#define sieve_ast_strlist_first(list) \
+	__AST_NODE_LIST_FIRST(list, _value.strlist)
+#define sieve_ast_strlist_last(list) \
+	__AST_NODE_LIST_LAST(list, _value.strlist)
+#define sieve_ast_strlist_count(list) \
+	__AST_NODE_LIST_COUNT(list, _value.strlist)
+#define sieve_ast_strlist_next(str) __AST_LIST_NEXT(str)
+#define sieve_ast_strlist_prev(str) __AST_LIST_PREV(str)
+#define sieve_ast_strlist_str(str) sieve_ast_argument_str(str)
+#define sieve_ast_strlist_strc(str) sieve_ast_argument_strc(str)
+
+/*
+ * Debug
+ */
+
+void sieve_ast_unparse(struct sieve_ast *ast);
+
+#endif /* __SIEVE_AST_H */
Index: b/sieve/src/lib-sieve/sieve-binary-dumper.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-binary-dumper.c
@@ -0,0 +1,156 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+
+#include "sieve-dump.h"
+
+/*
+ * Binary dumper object
+ */
+
+struct sieve_binary_dumper {
+	pool_t pool;
+
+	/* Dumptime environment */
+	struct sieve_dumptime_env dumpenv;
+};
+
+struct sieve_binary_dumper *sieve_binary_dumper_create
+	(struct sieve_binary *sbin)
+{
+	pool_t pool;
+	struct sieve_binary_dumper *dumper;
+
+	pool = pool_alloconly_create("sieve_binary_dumper", 4096);
+	dumper = p_new(pool, struct sieve_binary_dumper, 1);
+	dumper->pool = pool;
+	dumper->dumpenv.dumper = dumper;
+
+	dumper->dumpenv.sbin = sbin;
+	sieve_binary_ref(sbin);
+
+	dumper->dumpenv.svinst = sieve_binary_svinst(sbin);
+
+	return dumper;
+}
+
+void sieve_binary_dumper_free(struct sieve_binary_dumper **dumper)
+{
+	sieve_binary_unref(&(*dumper)->dumpenv.sbin);
+	pool_unref(&((*dumper)->pool));
+
+	*dumper = NULL;
+}
+
+pool_t sieve_binary_dumper_pool(struct sieve_binary_dumper *dumper)
+{
+	return dumper->pool;
+}
+
+/*
+ * Formatted output
+ */
+
+void sieve_binary_dumpf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_vprintfa(outbuf, fmt, args);
+	va_end(args);
+
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_binary_dump_sectionf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_printfa(outbuf, "\n* ");
+	str_vprintfa(outbuf, fmt, args);
+	str_printfa(outbuf, ":\n\n");
+	va_end(args);
+
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+/*
+ * Dumping the binary
+ */
+
+bool sieve_binary_dumper_run
+(struct sieve_binary_dumper *dumper, struct ostream *stream)
+{
+	struct sieve_binary *sbin = dumper->dumpenv.sbin;
+	struct sieve_dumptime_env *denv = &(dumper->dumpenv);
+	int count, i;
+
+	dumper->dumpenv.stream = stream;
+
+	/* Dump list of used extensions */
+
+	count = sieve_binary_extensions_count(sbin);
+	if ( count > 0 ) {
+		sieve_binary_dump_sectionf(denv, "Required extensions");
+
+		for ( i = 0; i < count; i++ ) {
+			const struct sieve_extension *ext = sieve_binary_extension_get_by_index
+				(sbin, i);
+			sieve_binary_dumpf(denv, "%3d: %s (%d)\n", i, sieve_extension_name(ext),
+				ext->id);
+		}
+	}
+
+	/* Dump extension-specific elements of the binary */
+
+	count = sieve_binary_extensions_count(sbin);
+	if ( count > 0 ) {
+		for ( i = 0; i < count; i++ ) {
+			bool success = TRUE;
+
+			T_BEGIN {
+				const struct sieve_extension *ext = sieve_binary_extension_get_by_index
+					(sbin, i);
+
+				if ( ext->def != NULL && ext->def->binary_dump != NULL ) {
+					success = ext->def->binary_dump(ext, denv);
+				}
+			} T_END;
+
+			if ( !success ) return FALSE;
+		}
+	}
+
+	/* Dump main program */
+
+	sieve_binary_dump_sectionf(denv, "Main program (block: %d)", SBIN_SYSBLOCK_MAIN_PROGRAM);
+
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL) ) {
+        return FALSE;
+	}
+
+	dumper->dumpenv.cdumper = sieve_code_dumper_create(&(dumper->dumpenv));
+
+	if ( dumper->dumpenv.cdumper != NULL ) {
+		sieve_code_dumper_run(dumper->dumpenv.cdumper);
+
+		sieve_code_dumper_free(&dumper->dumpenv.cdumper);
+	}
+
+	/* Finish with empty line */
+	sieve_binary_dumpf(denv, "\n");
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/sieve-binary-dumper.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-binary-dumper.h
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_BINARY_DUMPER_H
+#define __SIEVE_BINARY_DUMPER_H
+
+#include "sieve-common.h"
+
+/*
+ * Binary dumper object
+ */
+
+struct sieve_binary_dumper;
+
+struct sieve_binary_dumper *sieve_binary_dumper_create
+	(struct sieve_binary *sbin);
+void sieve_binary_dumper_free
+	(struct sieve_binary_dumper **dumper);
+
+pool_t sieve_binary_dumper_pool
+	(struct sieve_binary_dumper *dumper);
+
+/*
+ * Formatted output
+ */
+
+void sieve_binary_dumpf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...);
+void sieve_binary_dump_sectionf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...);
+
+/*
+ * Dumping the binary
+ */
+
+bool sieve_binary_dumper_run
+	(struct sieve_binary_dumper *dumper, struct ostream *stream);
+
+
+#endif /* __SIEVE_BINARY_DUMPER_H */
Index: b/sieve/src/lib-sieve/sieve-binary.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-binary.c
@@ -0,0 +1,1795 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "hash.h"
+#include "array.h"
+#include "ostream.h"
+#include "eacces-error.h"
+#include "safe-mkstemp.h"
+
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-script.h"
+
+#include "sieve-binary.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+/*
+ * Config
+ */
+
+#define SIEVE_BINARY_VERSION_MAJOR     0
+#define SIEVE_BINARY_VERSION_MINOR     1
+
+/*
+ * Macros
+ */
+
+#define SIEVE_BINARY_MAGIC              0xcafebabe
+#define SIEVE_BINARY_MAGIC_OTHER_ENDIAN 0xbebafeca
+
+#define SIEVE_BINARY_ALIGN(offset) \
+	(((offset) + 3) & ~3)
+#define SIEVE_BINARY_ALIGN_PTR(ptr) \
+	((void *) SIEVE_BINARY_ALIGN(((size_t) ptr)))
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_binary_file;
+
+static bool sieve_binary_file_open
+	(struct sieve_binary_file *file, const char *path);
+static void sieve_binary_file_close(struct sieve_binary_file **file);
+
+static struct sieve_binary_block *sieve_binary_load_block
+	(struct sieve_binary *sbin, unsigned int id);
+
+static inline struct sieve_binary_extension_reg *sieve_binary_extension_get_reg
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		bool create);
+static inline int sieve_binary_extension_register
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		struct sieve_binary_extension_reg **reg);
+
+static inline sieve_size_t sieve_binary_emit_dynamic_data
+	(struct sieve_binary *binary, const void *data, size_t size);
+
+/*
+ * Internal structures
+ */
+
+/* Extension registration */
+
+struct sieve_binary_extension_reg {
+	/* The identifier of the extension within this binary */
+	int index;
+
+	/* Global extension object */
+	const struct sieve_extension *extension;
+
+	/* Extension to the binary; typically used to manage extension-specific blocks
+	 * in the binary and as a means to get a binary_free notification to release
+	 * references held by extensions.
+	 */
+	const struct sieve_binary_extension *binext;
+
+	/* Context data associated to the binary by this extension */
+	void *context;
+
+	/* Main block for this extension */
+	unsigned int block_id;
+};
+
+/* Block */
+
+struct sieve_binary_block {
+	buffer_t *buffer;
+	int ext_index;
+
+	uoff_t offset;
+};
+
+/* File */
+
+/* FIXME: In essence this is an unbuffered stream implementation. Maybe this
+ * can be merged with the generic dovecot istream interface.
+ */
+struct sieve_binary_file {
+	pool_t pool;
+	const char *path;
+
+	struct stat st;
+	int fd;
+	off_t offset;
+
+	bool (*load)(struct sieve_binary_file *file);
+	const void *(*load_data)
+		(struct sieve_binary_file *file, off_t *offset, size_t size);
+	buffer_t *(*load_buffer)
+		(struct sieve_binary_file *file, off_t *offset, size_t size);
+};
+
+/*
+ * Binary object
+ */
+
+struct sieve_binary {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_instance *svinst;
+
+	struct sieve_script *script;
+
+	struct sieve_binary_file *file;
+
+	/* When the binary is loaded into memory or when it is being constructed by
+	 * the generator, extensions can be associated to the binary. The extensions
+	 * array is a sequential list of all linked extensions. The extension_index
+	 * array is a mapping ext_id -> binary_extension. This is used to obtain the
+	 * index code associated with an extension for this particular binary. The
+	 * linked_extensions list all extensions linked to this binary object other
+	 * than the preloaded language features implemented as 'extensions'.
+	 *
+	 * All arrays refer to the same extension registration objects. Upon loading
+	 * a binary, the 'require'd extensions will sometimes need to associate
+	 * context data to the binary object in memory. This is stored in these
+	 * registration objects as well.
+	 */
+	ARRAY_DEFINE(extensions, struct sieve_binary_extension_reg *);
+	ARRAY_DEFINE(extension_index, struct sieve_binary_extension_reg *);
+	ARRAY_DEFINE(linked_extensions, struct sieve_binary_extension_reg *);
+
+	/* Attributes of a loaded binary */
+	const char *path;
+
+	/* Blocks */
+	ARRAY_DEFINE(blocks, struct sieve_binary_block *);
+	unsigned int active_block;
+
+	/* Current block buffer: all emit and read functions act upon this buffer */
+	buffer_t *data;
+	const signed char *code;
+	size_t code_size;
+};
+
+static struct sieve_binary *sieve_binary_create
+(struct sieve_instance *svinst, struct sieve_script *script)
+{
+	pool_t pool;
+	struct sieve_binary *sbin;
+	const struct sieve_extension *const *ext_preloaded;
+	unsigned int i, ext_count;
+
+	pool = pool_alloconly_create("sieve_binary", 8192);
+	sbin = p_new(pool, struct sieve_binary, 1);
+	sbin->pool = pool;
+	sbin->refcount = 1;
+	sbin->svinst = svinst;
+
+	sbin->script = script;
+	if ( script != NULL )
+		sieve_script_ref(script);
+
+	ext_count = sieve_extensions_get_count(svinst);
+
+	p_array_init(&sbin->linked_extensions, pool, ext_count);
+	p_array_init(&sbin->extensions, pool, ext_count);
+	p_array_init(&sbin->extension_index, pool, ext_count);
+
+	p_array_init(&sbin->blocks, pool, 3);
+
+	/* Pre-load core language features implemented as 'extensions' */
+	ext_preloaded = sieve_extensions_get_preloaded(svinst, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension_def *ext_def = ext_preloaded[i]->def;
+
+		if ( ext_def != NULL && ext_def->binary_load != NULL )
+			(void)ext_def->binary_load(ext_preloaded[i], sbin);
+	}
+
+	return sbin;
+}
+
+struct sieve_binary *sieve_binary_create_new(struct sieve_script *script)
+{
+	struct sieve_binary *sbin = sieve_binary_create
+		(sieve_script_svinst(script), script);
+
+	/* Extensions block */
+	(void) sieve_binary_block_create(sbin);
+
+	/* Main program block */
+	(void) sieve_binary_block_set_active
+		(sbin, sieve_binary_block_create(sbin), NULL);
+
+	return sbin;
+}
+
+void sieve_binary_ref(struct sieve_binary *sbin)
+{
+	sbin->refcount++;
+}
+
+static inline void sieve_binary_extensions_free(struct sieve_binary *sbin)
+{
+	struct sieve_binary_extension_reg *const *regs;
+	unsigned int ext_count, i;
+
+	/* Cleanup binary extensions */
+	regs = array_get(&sbin->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_binary_extension *binext = regs[i]->binext;
+
+		if ( binext != NULL && binext->binary_free != NULL )
+			binext->binary_free(regs[i]->extension, sbin, regs[i]->context);
+	}
+}
+
+void sieve_binary_unref(struct sieve_binary **sbin)
+{
+	i_assert((*sbin)->refcount > 0);
+
+	if (--(*sbin)->refcount != 0)
+		return;
+
+	sieve_binary_extensions_free(*sbin);
+
+	if ( (*sbin)->file != NULL )
+		sieve_binary_file_close(&(*sbin)->file);
+
+	if ( (*sbin)->script != NULL )
+		sieve_script_unref(&(*sbin)->script);
+
+	pool_unref(&((*sbin)->pool));
+
+	*sbin = NULL;
+}
+
+static inline sieve_size_t _sieve_binary_get_code_size
+(struct sieve_binary *sbin)
+{
+	return buffer_get_used_size(sbin->data);
+}
+
+sieve_size_t sieve_binary_get_code_size(struct sieve_binary *sbin)
+{
+	return _sieve_binary_get_code_size(sbin);
+}
+
+pool_t sieve_binary_pool(struct sieve_binary *sbin)
+{
+	return sbin->pool;
+}
+
+struct sieve_script *sieve_binary_script(struct sieve_binary *sbin)
+{
+	return sbin->script;
+}
+
+const char *sieve_binary_path(struct sieve_binary *sbin)
+{
+	return sbin->path;
+}
+
+struct sieve_instance *sieve_binary_svinst(struct sieve_binary *sbin)
+{
+	return sbin->svinst;
+}
+
+bool sieve_binary_script_newer
+(struct sieve_binary *sbin, struct sieve_script *script)
+{
+	i_assert(sbin->file != NULL);
+	return ( sieve_script_newer(script, sbin->file->st.st_mtime) );
+}
+
+const char *sieve_binary_script_name(struct sieve_binary *sbin)
+{
+	struct sieve_script *script = sieve_binary_script(sbin);
+
+	return ( script == NULL ? NULL : sieve_script_name(script) );
+}
+
+const char *sieve_binary_script_path(struct sieve_binary *sbin)
+{
+	struct sieve_script *script = sieve_binary_script(sbin);
+
+	return ( script == NULL ? NULL : sieve_script_path(script) );
+}
+
+
+/*
+ * Block management
+ */
+
+static inline struct sieve_binary_block *sieve_binary_block_get
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block * const *block;
+
+	if  ( id >= array_count(&sbin->blocks) )
+		return NULL;
+
+	block = array_idx(&sbin->blocks, id);
+
+	return *block;
+}
+
+static inline unsigned int sieve_binary_block_add
+(struct sieve_binary *sbin, struct sieve_binary_block *block)
+{
+	unsigned int id = array_count(&sbin->blocks);
+
+	array_append(&sbin->blocks, &block, 1);
+	return id;
+}
+
+static inline unsigned int sieve_binary_block_count
+(struct sieve_binary *sbin)
+{
+	return array_count(&sbin->blocks);
+}
+
+void sieve_binary_block_clear
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block = sieve_binary_block_get(sbin, id);
+
+	buffer_reset(block->buffer);
+}
+
+bool sieve_binary_block_set_active
+(struct sieve_binary *sbin, unsigned int id, unsigned *old_id_r)
+{
+	struct sieve_binary_block *block = sieve_binary_block_get(sbin, id);
+
+	if ( block == NULL ) return FALSE;
+
+	if ( block->buffer == NULL ) {
+		if ( sbin->file ) {
+			/* Try to acces the block in the binary on disk (apperently we were lazy)
+			 */
+			if ( sieve_binary_load_block(sbin, id) == NULL || block->buffer == NULL )
+				return FALSE;
+		} else {
+			/* Block buffer is missing during code generation. This is what we would
+			 * call a bug. FAIL.
+			 */
+			return FALSE;
+		}
+	}
+
+	if ( old_id_r != NULL )
+		*old_id_r = sbin->active_block;
+
+	sbin->data = block->buffer;
+	sbin->code = buffer_get_data(block->buffer, &sbin->code_size);
+	sbin->active_block = id;
+
+	return TRUE;
+}
+
+unsigned int sieve_binary_block_create(struct sieve_binary *sbin)
+{
+	struct sieve_binary_block *block;
+
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+	block->buffer = buffer_create_dynamic(sbin->pool, 64);
+
+	return sieve_binary_block_add(sbin, block);
+}
+
+static struct sieve_binary_block *sieve_binary_block_create_id
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block;
+
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+
+	if ( id >= SBIN_SYSBLOCK_LAST )
+		array_idx_set(&sbin->blocks, id, &block);
+	else
+		(void)sieve_binary_block_add(sbin, block);
+
+	return block;
+}
+
+/*
+ * Header and record structures of the binary on disk
+ */
+
+struct sieve_binary_header {
+	uint32_t magic;
+	uint16_t version_major;
+	uint16_t version_minor;
+	uint32_t blocks;
+};
+
+struct sieve_binary_block_index {
+	uint32_t id;
+	uint32_t size;
+	uint32_t offset;
+	uint32_t ext_id;
+};
+
+struct sieve_binary_block_header {
+	uint32_t id;
+	uint32_t size;
+};
+
+/*
+ * Saving the binary to a file.
+ */
+
+static inline bool _save_skip(struct ostream *stream, size_t size)
+{
+	if ( (o_stream_seek(stream, stream->offset + size)) <= 0 )
+		return FALSE;
+
+	return TRUE;
+}
+
+static inline bool _save_skip_aligned
+(struct ostream *stream, size_t size, uoff_t *offset)
+{
+	uoff_t aligned_offset = SIEVE_BINARY_ALIGN(stream->offset);
+
+	if ( (o_stream_seek(stream, aligned_offset + size)) <= 0 )
+		return FALSE;
+
+	if ( offset != NULL )
+		*offset = aligned_offset;
+
+	return TRUE;
+}
+
+/* FIXME: Is this even necessary for a file? */
+static bool _save_full(struct ostream *stream, const void *data, size_t size)
+{
+	size_t bytes_left = size;
+	const void *pdata = data;
+
+	while ( bytes_left > 0 ) {
+		ssize_t ret;
+
+		if ( (ret=o_stream_send(stream, pdata, bytes_left)) <= 0 )
+			return FALSE;
+
+		pdata = PTR_OFFSET(pdata, ret);
+		bytes_left -= ret;
+	}
+
+	return TRUE;
+}
+
+static bool _save_aligned
+(struct ostream *stream, const void *data, size_t size, uoff_t *offset)
+{
+	uoff_t aligned_offset = SIEVE_BINARY_ALIGN(stream->offset);
+
+	o_stream_cork(stream);
+
+	/* Align the data by adding zeroes to the output stream */
+	if ( stream->offset < aligned_offset ) {
+		if ( !_save_skip(stream, aligned_offset - stream->offset) )
+			return FALSE;
+	}
+
+	if ( !_save_full(stream, data, size) )
+		return FALSE;
+
+	o_stream_uncork(stream);
+
+	if ( offset != NULL )
+		*offset = aligned_offset;
+
+	return TRUE;
+}
+
+static bool _save_block
+(struct sieve_binary *sbin, struct ostream *stream, unsigned int id)
+{
+	struct sieve_binary_block_header block_header;
+	struct sieve_binary_block *block;
+	const void *data;
+	size_t size;
+
+	block = sieve_binary_block_get(sbin, id);
+	if ( block == NULL )
+		return FALSE;
+
+	data = buffer_get_data(block->buffer, &size);
+
+	block_header.id = id;
+	block_header.size = size;
+
+	if ( !_save_aligned(stream, &block_header,
+		sizeof(block_header), &block->offset) )
+		return FALSE;
+
+	return _save_aligned(stream, data, size, NULL);
+}
+
+static bool _save_block_index_record
+(struct sieve_binary *sbin, struct ostream *stream, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	struct sieve_binary_block_index header;
+
+	block = sieve_binary_block_get(sbin, id);
+	if ( block == NULL )
+		return FALSE;
+
+	header.id = id;
+	header.size = buffer_get_used_size(block->buffer);
+	header.ext_id = block->ext_index;
+	header.offset = block->offset;
+
+	if ( !_save_full(stream, &header, sizeof(header)) ) {
+		sieve_sys_error("failed to save block index header %d: %m", id);
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool _sieve_binary_save
+(struct sieve_binary *sbin, struct ostream *stream)
+{
+	struct sieve_binary_header header;
+	struct sieve_binary_extension_reg *const *regs;
+	unsigned int ext_count, blk_count, i;
+	uoff_t block_index;
+
+	blk_count = sieve_binary_block_count(sbin);
+
+	/* Signal all extensions to finish generating their blocks */
+
+	regs = array_get(&sbin->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_binary_extension *binext = regs[i]->binext;
+
+		if ( binext != NULL && binext->binary_save != NULL )
+			binext->binary_save(regs[i]->extension, sbin, regs[i]->context);
+	}
+
+	/* Create header */
+
+	header.magic = SIEVE_BINARY_MAGIC;
+	header.version_major = SIEVE_BINARY_VERSION_MAJOR;
+	header.version_minor = SIEVE_BINARY_VERSION_MINOR;
+	header.blocks = blk_count;
+
+	if ( !_save_aligned(stream, &header, sizeof(header), NULL) ) {
+		sieve_sys_error("failed to save binary header: %m");
+		return FALSE;
+	}
+
+	/* Skip block index for now */
+
+	if ( !_save_skip_aligned(stream,
+		sizeof(struct sieve_binary_block_index) * blk_count, &block_index) )
+		return FALSE;
+
+	/* Create block containing all used extensions
+	 *   FIXME: Per-extension this should also store binary version numbers.
+	 */
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_EXTENSIONS, NULL) )
+		return FALSE;
+
+	ext_count = array_count(&sbin->linked_extensions);
+	sieve_binary_emit_unsigned(sbin, ext_count);
+
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ext
+			= array_idx(&sbin->linked_extensions, i);
+
+		sieve_binary_emit_cstring(sbin, sieve_extension_name((*ext)->extension));
+		sieve_binary_emit_unsigned(sbin, (*ext)->block_id);
+	}
+
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL) )
+		return FALSE;
+
+	/* Save all blocks into the binary */
+
+	for ( i = 0; i < blk_count; i++ ) {
+		if ( !_save_block(sbin, stream, i) )
+			return FALSE;
+	}
+
+	/* Create the block index */
+	o_stream_seek(stream, block_index);
+	for ( i = 0; i < blk_count; i++ ) {
+		if ( !_save_block_index_record(sbin, stream, i) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_binary_save
+(struct sieve_binary *sbin, const char *path)
+{
+	bool result = TRUE;
+	string_t *temp_path;
+	struct ostream *stream;
+	int fd;
+	mode_t save_mode = sbin->script == NULL ? 0600 : sieve_script_permissions(sbin->script);
+
+	/* Use default path if none is specified */
+	if ( path == NULL ) {
+		if ( sbin->script == NULL ) {
+			sieve_sys_error("cannot determine default binary save path "
+				"with missing script object");
+        	return FALSE;
+		}
+		path = sieve_script_binpath(sbin->script);
+	}
+
+	/* Open it as temp file first, as not to overwrite an existing just yet */
+	temp_path = t_str_new(256);
+	str_append(temp_path, path);
+	fd = safe_mkstemp_hostpid(temp_path, save_mode, (uid_t)-1, (gid_t)-1);
+	if ( fd < 0 ) {
+		if ( errno == EACCES ) {
+			sieve_sys_error("failed to save binary: %s",
+				eacces_error_get_creating("open", str_c(temp_path)));
+		} else {
+			sieve_sys_error("failed to save binary: open(%s) failed: %m",
+				str_c(temp_path));
+		}
+		return FALSE;
+	}
+
+	stream = o_stream_create_fd(fd, 0, FALSE);
+	result = _sieve_binary_save(sbin, stream);
+	o_stream_destroy(&stream);
+
+	if (close(fd) < 0)
+		sieve_sys_error("failed to close saved binary temporary file: "
+			"close(fd=%s) failed: %m", str_c(temp_path));
+
+	/* Replace any original binary atomically */
+	if (result && (rename(str_c(temp_path), path) < 0)) {
+		if ( errno == EACCES ) {
+			sieve_sys_error("failed to replace existing binary: %s",
+				eacces_error_get_creating("rename", path));
+		} else {
+			sieve_sys_error("failed to replace existing binary: "
+				"rename(%s, %s) failed: %m", str_c(temp_path), path);
+		}
+		result = FALSE;
+	}
+
+	if ( !result ) {
+		/* Get rid of temp output (if any) */
+		(void) unlink(str_c(temp_path));
+	} else {
+		if ( sbin->path == NULL || strcmp(sbin->path, path) != 0 ) {
+			sbin->path = p_strdup(sbin->pool, path);
+		}
+	}
+
+	return result;
+}
+
+/*
+ * Binary file management
+ */
+
+static bool sieve_binary_file_open
+	(struct sieve_binary_file *file, const char *path)
+{
+	int fd;
+	struct stat st;
+
+	if ( (fd=open(path, O_RDONLY)) < 0 ) {
+		if ( errno != ENOENT ) {
+			if ( errno == EACCES ) {
+				sieve_sys_error("failed to open binary: %s",
+					eacces_error_get("open", path));
+			} else {
+				sieve_sys_error("failed to open binary: "
+					"open(%s) failed: %m", path);
+			}
+		}
+		return FALSE;
+	}
+
+	if ( fstat(fd, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_sys_error("failed to open binary: "
+				"fstat(fd=%s) failed: %m", path);
+		}
+		return FALSE;
+	}
+
+	if ( !S_ISREG(st.st_mode) ) {
+		sieve_sys_error("binary %s is not a regular file", path);
+		return FALSE;
+	}
+
+	file->fd = fd;
+	file->st = st;
+
+	return TRUE;
+}
+
+static void sieve_binary_file_close(struct sieve_binary_file **file)
+{
+	if ( (*file)->fd != -1 ) {
+		if ( close((*file)->fd) < 0 ) {
+			sieve_sys_error("failed to close opened binary: "
+				"close(fd=%s) failed: %m", (*file)->path);
+		}
+	}
+
+	pool_unref(&(*file)->pool);
+
+	*file = NULL;
+}
+
+#if 0 /* file_memory is currently unused */
+
+/* File loaded/mapped to memory */
+
+struct _file_memory {
+	struct sieve_binary_file binfile;
+
+	/* Pointer to the binary in memory */
+	const void *memory;
+	off_t memory_size;
+};
+
+static const void *_file_memory_load_data
+	(struct sieve_binary_file *file, off_t *offset, size_t size)
+{
+	struct _file_memory *fmem = (struct _file_memory *) file;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	if ( (*offset) + size <= fmem->memory_size ) {
+		const void *data = PTR_OFFSET(fmem->memory, *offset);
+		*offset += size;
+		file->offset = *offset;
+
+		return data;
+	}
+
+	return NULL;
+}
+
+static buffer_t *_file_memory_load_buffer
+	(struct sieve_binary_file *file, off_t *offset, size_t size)
+{
+	struct _file_memory *fmem = (struct _file_memory *) file;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	if ( (*offset) + size <= fmem->memory_size ) {
+		const void *data = PTR_OFFSET(fmem->memory, *offset);
+		*offset += size;
+		file->offset = *offset;
+
+		return buffer_create_const_data(file->pool, data, size);
+	}
+
+	return NULL;
+}
+
+static bool _file_memory_load(struct sieve_binary_file *file)
+{
+	struct _file_memory *fmem = (struct _file_memory *) file;
+	int ret;
+	size_t size;
+	void *indata;
+
+	i_assert(file->fd > 0);
+
+	/* Allocate memory buffer
+	 */
+	indata = p_malloc(file->pool, file->st.st_size);
+	size = file->st.st_size;
+
+	file->offset = 0;
+	fmem->memory = indata;
+	fmem->memory_size = file->st.st_size;
+
+	/* Return to beginning of the file */
+	if ( lseek(file->fd, 0, SEEK_SET) == (off_t) -1 ) {
+		sieve_sys_error("failed to seek() in binary %s: %m", file->path);
+		return FALSE;
+	}
+
+	/* Read the whole file into memory */
+	while (size > 0) {
+		if ( (ret=read(file->fd, indata, size)) <= 0 ) {
+			sieve_sys_error("failed to read from binary %s: %m", file->path);
+			break;
+		}
+
+		indata = PTR_OFFSET(indata, ret);
+		size -= ret;
+	}
+
+	if ( size != 0 ) {
+		/* Failed to read the whole file */
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static struct sieve_binary_file *_file_memory_open(const char *path)
+{
+	pool_t pool;
+	struct _file_memory *file;
+
+	pool = pool_alloconly_create("sieve_binary_file_memory", 1024);
+	file = p_new(pool, struct _file_memory, 1);
+	file->binfile.pool = pool;
+	file->binfile.path = p_strdup(pool, path);
+	file->binfile.load = _file_memory_load;
+	file->binfile.load_data = _file_memory_load_data;
+	file->binfile.load_buffer = _file_memory_load_buffer;
+
+	if ( !sieve_binary_file_open(&file->binfile, path) ) {
+		pool_unref(&pool);
+		return NULL;
+	}
+
+	return &file->binfile;
+}
+
+#endif /* file_memory is currently unused */
+
+/* File open in lazy mode (only read what is needed into memory) */
+
+static bool _file_lazy_read
+(struct sieve_binary_file *file, off_t *offset, void *buffer, size_t size)
+{
+	int ret;
+	void *indata = buffer;
+	size_t insize = size;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	/* Seek to the correct position */
+	if ( *offset != file->offset &&
+		lseek(file->fd, *offset, SEEK_SET) == (off_t) -1 ) {
+		sieve_sys_error("failed to seek(fd, %lld, SEEK_SET) in binary %s: %m",
+			(long long) *offset, file->path);
+		return FALSE;
+	}
+
+	/* Read record into memory */
+	while (insize > 0) {
+		if ( (ret=read(file->fd, indata, insize)) <= 0 ) {
+			if ( ret == 0 )
+				sieve_sys_error("binary %s is truncated (more data expected)",
+					file->path);
+			else
+				sieve_sys_error("failed to read from binary %s: %m", file->path);
+			break;
+		}
+
+		indata = PTR_OFFSET(indata, ret);
+		insize -= ret;
+	}
+
+	if ( insize != 0 ) {
+		/* Failed to read the whole requested record */
+		return FALSE;
+	}
+
+	*offset += size;
+	file->offset = *offset;
+
+	return TRUE;
+}
+
+static const void *_file_lazy_load_data
+(struct sieve_binary_file *file, off_t *offset, size_t size)
+{
+	void *data = t_malloc(size);
+
+	if ( _file_lazy_read(file, offset, data, size) ) {
+		return data;
+	}
+
+	return NULL;
+}
+
+static buffer_t *_file_lazy_load_buffer
+(struct sieve_binary_file *file, off_t *offset, size_t size)
+{
+	buffer_t *buffer = buffer_create_static_hard(file->pool, size);
+
+	if ( _file_lazy_read
+		(file, offset, buffer_get_space_unsafe(buffer, 0, size), size) ) {
+		return buffer;
+	}
+
+	return NULL;
+}
+
+static struct sieve_binary_file *_file_lazy_open(const char *path)
+{
+	pool_t pool;
+	struct sieve_binary_file *file;
+
+	pool = pool_alloconly_create("sieve_binary_file_lazy", 4096);
+	file = p_new(pool, struct sieve_binary_file, 1);
+	file->pool = pool;
+	file->path = p_strdup(pool, path);
+	file->load_data = _file_lazy_load_data;
+	file->load_buffer = _file_lazy_load_buffer;
+
+	if ( !sieve_binary_file_open(file, path) ) {
+		pool_unref(&pool);
+		return NULL;
+	}
+
+	return file;
+}
+
+/*
+ * Load binary from a file
+ */
+
+#define LOAD_HEADER(sbin, offset, header) \
+	(header *) sbin->file->load_data(sbin->file, offset, sizeof(header))
+
+static struct sieve_binary_block *_load_block
+(struct sieve_binary *sbin, off_t *offset, unsigned int id)
+{
+	const struct sieve_binary_block_header *header =
+		LOAD_HEADER(sbin, offset, const struct sieve_binary_block_header);
+	struct sieve_binary_block *block;
+
+	if ( header == NULL ) {
+		sieve_sys_error("block %d of loaded binary %s is truncated", id, sbin->path);
+		return NULL;
+	}
+
+	if ( header->id != id ) {
+		sieve_sys_error("block %d of loaded binary %s has unexpected id %d", id,
+			sbin->path, header->id);
+		return NULL;
+	}
+
+	block = sieve_binary_block_get(sbin, id);
+
+	if ( block == NULL ) {
+		sieve_sys_error("!!BUG!!: block %d missing in index (impossible) "
+			"of binary %s",	id, sbin->path);
+		return NULL;
+	}
+
+	block->buffer = sbin->file->load_buffer(sbin->file, offset, header->size);
+	if ( block->buffer == NULL ) {
+		sieve_sys_error("block %d of loaded binary %s has invalid size %d",
+			id, sbin->path, header->size);
+		return NULL;
+	}
+
+	return block;
+}
+
+static struct sieve_binary_block *sieve_binary_load_block
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	off_t offset;
+
+	block = sieve_binary_block_get(sbin, id);
+
+	if ( block == NULL ) return NULL;
+
+	offset = block->offset;
+
+	return _load_block(sbin, &offset, id);
+}
+
+static bool _load_block_index_record
+(struct sieve_binary *sbin, off_t *offset, unsigned int id)
+{
+	const struct sieve_binary_block_index *record =
+		LOAD_HEADER(sbin, offset, const struct sieve_binary_block_index);
+	struct sieve_binary_block *block;
+
+	if ( record == NULL ) {
+		sieve_sys_error("failed to read index record for block %d in binary %s",
+			id, sbin->path);
+		return FALSE;
+	}
+
+	if ( record->id != id ) {
+		sieve_sys_error("block index record %d of loaded binary %s "
+			"has unexpected id %d", id, sbin->path, record->id);
+		return FALSE;
+	}
+
+	block = sieve_binary_block_create_id(sbin, id);
+	block->ext_index = record->ext_id;
+	block->offset = record->offset;
+
+	return TRUE;
+}
+
+static bool _sieve_binary_load_extensions(struct sieve_binary *sbin)
+{
+	sieve_size_t offset = 0;
+	unsigned int i, count;
+	bool result = TRUE;
+
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_EXTENSIONS, NULL) )
+		return FALSE;
+
+	if ( !sieve_binary_read_unsigned(sbin, &offset, &count) )
+		return FALSE;
+
+	for ( i = 0; result && i < count; i++ ) {
+		T_BEGIN {
+			string_t *extension;
+			const struct sieve_extension *ext;
+
+			if ( sieve_binary_read_string(sbin, &offset, &extension) ) {
+				ext = sieve_extension_get_by_name(sbin->svinst, str_c(extension));
+
+				if ( ext == NULL ) {
+					sieve_sys_error("loaded binary %s requires unknown extension '%s'",
+						sbin->path, str_sanitize(str_c(extension), 128));
+					result = FALSE;
+				} else {
+					struct sieve_binary_extension_reg *ereg = NULL;
+
+					(void) sieve_binary_extension_register(sbin, ext, &ereg);
+					if ( !sieve_binary_read_unsigned(sbin, &offset, &ereg->block_id) )
+						result = FALSE;
+				}
+			}	else
+				result = FALSE;
+		} T_END;
+	}
+
+	return result;
+}
+
+static bool _sieve_binary_open(struct sieve_binary *sbin)
+{
+	bool result = TRUE;
+	off_t offset = 0;
+	const struct sieve_binary_header *header;
+	struct sieve_binary_block *extensions;
+	unsigned int i, blk_count;
+
+	/* Verify header */
+
+	T_BEGIN {
+		header = LOAD_HEADER(sbin, &offset, const struct sieve_binary_header);
+		if ( header == NULL ) {
+			sieve_sys_error("opened binary %s is not even large enough "
+				"to contain a header.", sbin->path);
+			result = FALSE;
+
+		} else if ( header->magic != SIEVE_BINARY_MAGIC ) {
+			if ( header->magic != SIEVE_BINARY_MAGIC_OTHER_ENDIAN )
+				sieve_sys_error("opened binary %s has corrupted header (0x%08x)",
+					sbin->path, header->magic);
+			result = FALSE;
+
+		} else if ( result && (
+		  header->version_major != SIEVE_BINARY_VERSION_MAJOR ||
+			header->version_minor != SIEVE_BINARY_VERSION_MINOR ) ) {
+
+			/* Binary is of different version. Caller will have to recompile */
+			result = FALSE;
+
+		} else if ( result && header->blocks == 0 ) {
+			sieve_sys_error("opened binary %s contains no blocks", sbin->path);
+			result = FALSE;
+
+		} else {
+			blk_count = header->blocks;
+		}
+	} T_END;
+
+	if ( !result ) return FALSE;
+
+	/* Load block index */
+
+	for ( i = 0; i < blk_count && result; i++ ) {
+		T_BEGIN {
+			if ( !_load_block_index_record(sbin, &offset, i) ) {
+				sieve_sys_error(
+					"block index record %d of opened binary %s is corrupt",
+					i, sbin->path);
+				result = FALSE;
+			}
+		} T_END;
+	}
+
+	if ( !result ) return FALSE;
+
+	/* Load extensions used by this binary */
+
+	T_BEGIN {
+		extensions =_load_block(sbin, &offset, 0);
+		if ( extensions == NULL ) {
+			result = FALSE;
+		} else if ( !_sieve_binary_load_extensions(sbin) ) {
+			sieve_sys_error("extension block of opened binary %s is corrupt",
+				sbin->path);
+			result = FALSE;
+		}
+	} T_END;
+
+	return result;
+}
+
+static bool _sieve_binary_load(struct sieve_binary *sbin)
+{
+	bool result = TRUE;
+	unsigned int i, blk_count;
+	struct sieve_binary_block *block;
+	off_t offset;
+
+	blk_count = array_count(&sbin->blocks);
+	if ( blk_count == 1 ) {
+		/* Binary is empty */
+		return TRUE;
+	}
+
+	block = sieve_binary_block_get(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM);
+	offset = block->offset;
+
+	/* Load the other blocks */
+
+	for ( i = 1; result && i < blk_count; i++ ) {
+		T_BEGIN {
+			if ( _load_block(sbin, &offset, i) == NULL ) {
+				sieve_sys_error("block %d of loaded binary %s is corrupt",
+					i, sbin->path);
+				result = FALSE;
+			}
+		} T_END;
+	}
+
+	return result;
+}
+
+struct sieve_binary *sieve_binary_open
+(struct sieve_instance *svinst, const char *path, struct sieve_script *script)
+{
+	struct sieve_binary_extension_reg *const *regs;
+	unsigned int ext_count, i;
+	struct sieve_binary *sbin;
+	struct sieve_binary_file *file;
+
+	i_assert( script == NULL || sieve_script_svinst(script) == svinst );
+
+	//file = _file_memory_open(path);
+	file = _file_lazy_open(path);
+	if ( file == NULL )
+		return NULL;
+
+	/* Create binary object */
+	sbin = sieve_binary_create(svinst, script);
+	sbin->path = p_strdup(sbin->pool, path);
+	sbin->file = file;
+
+	if ( !_sieve_binary_open(sbin) ) {
+		sieve_binary_unref(&sbin);
+		return NULL;
+	}
+
+	sieve_binary_activate(sbin);
+
+	/* Signal open event to extensions */
+	regs = array_get(&sbin->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_binary_extension *binext = regs[i]->binext;
+
+		if ( binext != NULL && binext->binary_open != NULL &&
+			!binext->binary_open(regs[i]->extension, sbin, regs[i]->context) ) {
+			/* Extension thinks its corrupt */
+			sieve_binary_unref(&sbin);
+			return NULL;
+		}
+	}
+
+	return sbin;
+}
+
+bool sieve_binary_load(struct sieve_binary *sbin)
+{
+	i_assert(sbin->file != NULL);
+
+	/*
+	if ( sbin->file->load != NULL && !sbin->file->load(sbin->file) )
+		return FALSE;	*/
+
+	if ( !_sieve_binary_load(sbin) ) {
+		/* Failed to interpret binary header and/or block structure */
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Up-to-date checking
+ */
+
+bool sieve_binary_up_to_date(struct sieve_binary *sbin)
+{
+	struct sieve_binary_extension_reg *const *regs;
+	unsigned int ext_count, i;
+
+	i_assert(sbin->file != NULL);
+
+	if ( sbin->script == NULL || sieve_script_newer
+		(sbin->script, sbin->file->st.st_mtime) )
+		return FALSE;
+
+	regs = array_get(&sbin->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_binary_extension *binext = regs[i]->binext;
+
+		if ( binext != NULL && binext->binary_up_to_date != NULL &&
+			!binext->binary_up_to_date(regs[i]->extension, sbin, regs[i]->context) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Activate the binary (after code generation)
+ */
+
+void sieve_binary_activate(struct sieve_binary *sbin)
+{
+	struct sieve_binary_extension_reg *const *regs;
+	unsigned int i, ext_count;
+
+	(void)sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL);
+
+	/* Load other extensions into binary */
+	regs = array_get(&sbin->linked_extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension *ext = regs[i]->extension;
+
+		if ( ext != NULL && ext->def != NULL && ext->def->binary_load != NULL )
+			ext->def->binary_load(ext, sbin);
+	}
+}
+
+/*
+ * Extension handling
+ */
+
+static inline struct sieve_binary_extension_reg *
+	sieve_binary_extension_create_reg
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	int index = array_count(&sbin->extensions);
+	struct sieve_binary_extension_reg *ereg;
+
+	if ( ext->id < 0 ) return NULL;
+
+	ereg = p_new(sbin->pool, struct sieve_binary_extension_reg, 1);
+	ereg->index = index;
+	ereg->extension = ext;
+
+	array_idx_set(&sbin->extensions, (unsigned int) index, &ereg);
+	array_idx_set(&sbin->extension_index, (unsigned int) ext->id, &ereg);
+
+	return ereg;
+}
+
+static inline struct sieve_binary_extension_reg *sieve_binary_extension_get_reg
+(struct sieve_binary *sbin, const struct sieve_extension *ext, bool create)
+{
+	struct sieve_binary_extension_reg *reg = NULL;
+
+	if ( ext->id >= 0 && ext->id < (int) array_count(&sbin->extension_index) ) {
+		struct sieve_binary_extension_reg * const *ereg =
+			array_idx(&sbin->extension_index, (unsigned int) ext->id);
+
+		reg = *ereg;
+	}
+
+	/* Register if not known */
+	if ( reg == NULL && create )
+		return sieve_binary_extension_create_reg(sbin, ext);
+
+	return reg;
+}
+
+void sieve_binary_extension_set_context
+(struct sieve_binary *sbin, const struct sieve_extension *ext, void *context)
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	if ( ereg != NULL )
+		ereg->context = context;
+}
+
+const void *sieve_binary_extension_get_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	if ( ereg != NULL ) {
+		return ereg->context;
+	}
+
+	return NULL;
+}
+
+void sieve_binary_extension_set
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	const struct sieve_binary_extension *bext, void *context)
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	if ( ereg != NULL ) {
+		ereg->binext = bext;
+
+		if ( context != NULL )
+			ereg->context = context;
+	}
+}
+
+unsigned int sieve_binary_extension_create_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_block *block;
+	unsigned int block_id;
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	i_assert(ereg != NULL);
+
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+	block->buffer = buffer_create_dynamic(sbin->pool, 64);
+
+	block_id = sieve_binary_block_add(sbin, block);
+
+	if ( ereg->block_id < SBIN_SYSBLOCK_LAST )
+		ereg->block_id = block_id;
+	block->ext_index = ereg->index;
+
+	return block_id;
+}
+
+unsigned int sieve_binary_extension_get_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	i_assert(ereg != NULL);
+
+	return ereg->block_id;
+}
+
+static inline int sieve_binary_extension_register
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	struct sieve_binary_extension_reg **reg_r)
+{
+	struct sieve_binary_extension_reg *ereg;
+
+	if ( (ereg=sieve_binary_extension_get_reg(sbin, ext, FALSE)) == NULL ) {
+		ereg = sieve_binary_extension_create_reg(sbin, ext);
+
+		if ( ereg == NULL ) return -1;
+
+		array_append(&sbin->linked_extensions, &ereg, 1);
+	}
+
+	if ( reg_r != NULL ) *reg_r = ereg;
+	return ereg->index;
+}
+
+int sieve_binary_extension_link
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	return sieve_binary_extension_register(sbin, ext, NULL);
+}
+
+static inline const struct sieve_extension *_sieve_binary_extension_get_by_index
+(struct sieve_binary *sbin, int index)
+{
+	struct sieve_binary_extension_reg * const *ereg;
+
+	if ( index < (int) array_count(&sbin->extensions) ) {
+		ereg = array_idx(&sbin->extensions, (unsigned int) index);
+
+		return (*ereg)->extension;
+	}
+
+	return NULL;
+}
+
+const struct sieve_extension *sieve_binary_extension_get_by_index
+(struct sieve_binary *sbin, int index)
+{
+	return _sieve_binary_extension_get_by_index(sbin, index);
+}
+
+int sieve_binary_extension_get_index
+	(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, FALSE);
+
+	return ( ereg == NULL ? -1 : ereg->index );
+}
+
+int sieve_binary_extensions_count(struct sieve_binary *sbin)
+{
+	return (int) array_count(&sbin->extensions);
+}
+
+/*
+ * Emission functions
+ */
+
+/* Low-level emission functions */
+
+static inline void _sieve_binary_emit_data
+(struct sieve_binary *sbin, const void *data, sieve_size_t size)
+{
+	buffer_append(sbin->data, data, size);
+}
+
+static inline void _sieve_binary_emit_byte
+(struct sieve_binary *sbin, unsigned char byte)
+{
+    _sieve_binary_emit_data(sbin, &byte, 1);
+}
+
+static inline void _sieve_binary_update_data
+(struct sieve_binary *sbin, sieve_size_t address, const void *data,
+	sieve_size_t size)
+{
+	buffer_write(sbin->data, address, data, size);
+}
+
+sieve_size_t sieve_binary_emit_data
+(struct sieve_binary *sbin, const void *data, sieve_size_t size)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+
+	_sieve_binary_emit_data(sbin, data, size);
+
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_byte
+(struct sieve_binary *sbin, unsigned char byte)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+
+	_sieve_binary_emit_data(sbin, &byte, 1);
+
+	return address;
+}
+
+void sieve_binary_update_data
+(struct sieve_binary *sbin, sieve_size_t address, const void *data,
+	sieve_size_t size)
+{
+	_sieve_binary_update_data(sbin, address, data, size);
+}
+
+/* Offset emission functions */
+
+sieve_size_t sieve_binary_emit_offset(struct sieve_binary *binary, int offset)
+{
+	int i;
+	sieve_size_t address = _sieve_binary_get_code_size(binary);
+
+	for ( i = 3; i >= 0; i-- ) {
+		char c = (char) (offset >> (i * 8));
+		_sieve_binary_emit_data(binary, &c, 1);
+	}
+
+	return address;
+}
+
+void sieve_binary_resolve_offset
+	(struct sieve_binary *binary, sieve_size_t address)
+{
+	int i;
+	int offset = _sieve_binary_get_code_size(binary) - address;
+
+	for ( i = 3; i >= 0; i-- ) {
+		char c = (char) (offset >> (i * 8));
+		_sieve_binary_update_data(binary, address + 3 - i, &c, 1);
+	}
+}
+
+/* Literal emission */
+
+/* FIXME: this integer format is compact, but it might be too slow.
+ */
+
+sieve_size_t sieve_binary_emit_integer
+(struct sieve_binary *binary, sieve_number_t integer)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(binary);
+	int i;
+	char buffer[sizeof(sieve_number_t) + 1];
+	int bufpos = sizeof(buffer) - 1;
+
+	buffer[bufpos] = integer & 0x7F;
+	bufpos--;
+	integer >>= 7;
+	while ( integer > 0 ) {
+		buffer[bufpos] = integer & 0x7F;
+		bufpos--;
+		integer >>= 7;
+	}
+
+	bufpos++;
+	if ( (sizeof(buffer) - bufpos) > 1 ) {
+		for ( i = bufpos; i < ((int) sizeof(buffer) - 1); i++) {
+			buffer[i] |= 0x80;
+		}
+	}
+
+	_sieve_binary_emit_data(binary, buffer + bufpos, sizeof(buffer) - bufpos);
+
+	return address;
+}
+
+static inline sieve_size_t sieve_binary_emit_dynamic_data
+	(struct sieve_binary *binary, const void *data, sieve_size_t size)
+{
+	sieve_size_t address = sieve_binary_emit_integer(binary, (sieve_number_t) size);
+
+	_sieve_binary_emit_data(binary, data, size);
+
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_cstring
+	(struct sieve_binary *binary, const char *str)
+{
+	sieve_size_t address = sieve_binary_emit_dynamic_data
+		(binary, (void *) str, (sieve_size_t) strlen(str));
+	_sieve_binary_emit_byte(binary, 0);
+
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_string
+	(struct sieve_binary *binary, const string_t *str)
+{
+	sieve_size_t address = sieve_binary_emit_dynamic_data
+		(binary, (void *) str_data(str), (sieve_size_t) str_len(str));
+	_sieve_binary_emit_byte(binary, 0);
+
+	return address;
+}
+
+/*
+ * Extension emission
+ */
+
+sieve_size_t sieve_binary_emit_extension
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	unsigned int offset)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+	struct sieve_binary_extension_reg *ereg = NULL;
+
+	(void)sieve_binary_extension_register(sbin, ext, &ereg);
+
+	i_assert(ereg != NULL);
+
+	_sieve_binary_emit_byte(sbin, offset + ereg->index);
+	return address;
+}
+
+void sieve_binary_emit_extension_object
+(struct sieve_binary *sbin, const struct sieve_extension_objects *objs,
+	unsigned int code)
+{
+	if ( objs->count > 1 )
+		_sieve_binary_emit_byte(sbin, code);
+}
+
+/*
+ * Code retrieval
+ */
+
+#define ADDR_CODE_AT(binary, address) \
+	((signed char) ((binary)->code[*address]))
+#define ADDR_DATA_AT(binary, address) \
+	((unsigned char) ((binary)->code[*address]))
+#define ADDR_POINTER(binary, address) \
+	((const char *) (&(binary)->code[*address]))
+#define ADDR_BYTES_LEFT(binary, address) \
+	((binary)->code_size - (*address))
+#define ADDR_JUMP(address, offset) \
+	(*address) += offset
+
+/* Literals */
+
+bool sieve_binary_read_byte
+	(struct sieve_binary *binary, sieve_size_t *address, unsigned int *byte_r)
+{
+	if ( ADDR_BYTES_LEFT(binary, address) >= 1 ) {
+		if ( byte_r != NULL )
+			*byte_r = ADDR_DATA_AT(binary, address);
+		ADDR_JUMP(address, 1);
+
+		return TRUE;
+	}
+
+	*byte_r = 0;
+	return FALSE;
+}
+
+bool sieve_binary_read_code
+	(struct sieve_binary *binary, sieve_size_t *address, signed int *code_r)
+{
+	if ( ADDR_BYTES_LEFT(binary, address) >= 1 ) {
+		if ( code_r != NULL )
+			*code_r = ADDR_CODE_AT(binary, address);
+		ADDR_JUMP(address, 1);
+
+		return TRUE;
+	}
+
+	*code_r = 0;
+	return FALSE;
+}
+
+
+bool sieve_binary_read_offset
+	(struct sieve_binary *binary, sieve_size_t *address, int *offset_r)
+{
+	uint32_t offs = 0;
+
+	if ( ADDR_BYTES_LEFT(binary, address) >= 4 ) {
+		int i;
+
+		for ( i = 0; i < 4; i++ ) {
+			offs = (offs << 8) + ADDR_DATA_AT(binary, address);
+			ADDR_JUMP(address, 1);
+		}
+
+		if ( offset_r != NULL )
+			*offset_r = (int) offs;
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+/* FIXME: might need negative numbers in the future */
+bool sieve_binary_read_integer
+  (struct sieve_binary *binary, sieve_size_t *address, sieve_number_t *int_r)
+{
+	int bits = sizeof(sieve_number_t) * 8;
+	*int_r = 0;
+
+	if ( ADDR_BYTES_LEFT(binary, address) == 0 )
+		return FALSE;
+
+	while ( (ADDR_DATA_AT(binary, address) & 0x80) > 0 ) {
+		if ( ADDR_BYTES_LEFT(binary, address) > 0 && bits > 0) {
+			*int_r |= ADDR_DATA_AT(binary, address) & 0x7F;
+			ADDR_JUMP(address, 1);
+
+			*int_r <<= 7;
+			bits -= 7;
+		} else {
+			/* This is an error */
+			return FALSE;
+		}
+	}
+
+	*int_r |= ADDR_DATA_AT(binary, address) & 0x7F;
+	ADDR_JUMP(address, 1);
+
+	return TRUE;
+}
+
+bool sieve_binary_read_string
+(struct sieve_binary *binary, sieve_size_t *address, string_t **str_r)
+{
+	unsigned int strlen = 0;
+
+	if ( !sieve_binary_read_unsigned(binary, address, &strlen) )
+		return FALSE;
+
+	if ( strlen > ADDR_BYTES_LEFT(binary, address) )
+		return FALSE;
+
+ 	if ( str_r != NULL )
+		*str_r = t_str_new_const(ADDR_POINTER(binary, address), strlen);
+	ADDR_JUMP(address, strlen);
+
+	if ( ADDR_CODE_AT(binary, address) != 0 )
+		return FALSE;
+
+	ADDR_JUMP(address, 1);
+
+	return TRUE;
+}
+
+bool sieve_binary_read_extension
+(struct sieve_binary *sbin, sieve_size_t *address, unsigned int *offset_r,
+	const struct sieve_extension **ext_r)
+{
+	unsigned int code;
+	unsigned int offset = *offset_r;
+	const struct sieve_extension *ext = NULL;
+
+	if ( ADDR_BYTES_LEFT(sbin, address) <= 0 )
+		return FALSE;
+
+	(*offset_r) = code = ADDR_DATA_AT(sbin, address);
+	ADDR_JUMP(address, 1);
+
+	if ( code >= offset ) {
+		ext = _sieve_binary_extension_get_by_index(sbin, code - offset);
+
+		if ( ext == NULL )
+			return FALSE;
+	}
+
+	(*ext_r) = ext;
+
+	return TRUE;
+}
+
+const void *sieve_binary_read_extension_object
+(struct sieve_binary *sbin, sieve_size_t *address,
+	const struct sieve_extension_objects *objs)
+{
+	unsigned int code;
+
+	if ( objs->count == 0 )
+		return NULL;
+
+	if ( objs->count == 1 )
+		return objs->objects;
+
+	if ( ADDR_BYTES_LEFT(sbin, address) <= 0 )
+		return NULL;
+
+	code = ADDR_DATA_AT(sbin, address);
+	ADDR_JUMP(address, 1);
+
+	if ( code >= objs->count )
+		return NULL;
+
+	return ((const void *const *) objs->objects)[code];
+}
Index: b/sieve/src/lib-sieve/sieve-binary.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-binary.h
@@ -0,0 +1,204 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_BINARY_H
+#define __SIEVE_BINARY_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+/*
+ * Binary object
+ */
+
+struct sieve_binary;
+
+struct sieve_binary *sieve_binary_create_new(struct sieve_script *script);
+void sieve_binary_ref(struct sieve_binary *sbin);
+void sieve_binary_unref(struct sieve_binary **sbin);
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_binary_pool(struct sieve_binary *sbin);
+struct sieve_script *sieve_binary_script(struct sieve_binary *sbin);
+const char *sieve_binary_path(struct sieve_binary *sbin);
+bool sieve_binary_script_newer
+	(struct sieve_binary *sbin, struct sieve_script *script);
+struct sieve_instance *sieve_binary_svinst(struct sieve_binary *sbin);
+
+const char *sieve_binary_script_name(struct sieve_binary *sbin);
+const char *sieve_binary_script_path(struct sieve_binary *sbin);
+
+/*
+ * Activation after code generation
+ */
+
+void sieve_binary_activate(struct sieve_binary *sbin);
+
+/*
+ * Saving the binary
+ */
+
+bool sieve_binary_save
+	(struct sieve_binary *sbin, const char *path);
+
+/*
+ * Loading the binary
+ */
+
+struct sieve_binary *sieve_binary_open
+	(struct sieve_instance *svinst, const char *path,
+		struct sieve_script *script);
+bool sieve_binary_up_to_date(struct sieve_binary *sbin);
+bool sieve_binary_load(struct sieve_binary *sbin);
+
+/*
+ * Block management
+ */
+
+enum sieve_binary_system_block {
+	SBIN_SYSBLOCK_EXTENSIONS,
+	SBIN_SYSBLOCK_MAIN_PROGRAM,
+	SBIN_SYSBLOCK_LAST
+};
+
+bool sieve_binary_block_set_active
+	(struct sieve_binary *sbin, unsigned int id, unsigned *old_id_r);
+unsigned int sieve_binary_block_create(struct sieve_binary *sbin);
+void sieve_binary_block_clear
+	(struct sieve_binary *sbin, unsigned int id);
+
+/*
+ * Extension support
+ */
+
+struct sieve_binary_extension {
+	const struct sieve_extension_def *extension;
+
+	bool (*binary_save)
+		(const struct sieve_extension *ext, struct sieve_binary *sbin,
+			void *context);
+	bool (*binary_open)
+		(const struct sieve_extension *ext, struct sieve_binary *sbin,
+			void *context);
+
+	void (*binary_free)
+		(const struct sieve_extension *ext, struct sieve_binary *sbin,
+			void *context);
+
+	bool (*binary_up_to_date)
+		(const struct sieve_extension *ext, struct sieve_binary *sbin,
+			void *context);
+};
+
+void sieve_binary_extension_set_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, void *context);
+const void *sieve_binary_extension_get_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+
+void sieve_binary_extension_set
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		const struct sieve_binary_extension *bext, void *context);
+
+unsigned int sieve_binary_extension_create_block
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+unsigned int sieve_binary_extension_get_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext);
+
+int sieve_binary_extension_link
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+const struct sieve_extension *sieve_binary_extension_get_by_index
+	(struct sieve_binary *sbin, int index);
+int sieve_binary_extension_get_index
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+int sieve_binary_extensions_count(struct sieve_binary *sbin);
+
+
+/*
+ * Code emission
+ */
+
+/* Low-level emission functions */
+
+sieve_size_t sieve_binary_emit_data
+	(struct sieve_binary *binary, const void *data, sieve_size_t size);
+sieve_size_t sieve_binary_emit_byte
+	(struct sieve_binary *binary, unsigned char byte);
+void sieve_binary_update_data
+	(struct sieve_binary *binary, sieve_size_t address, const void *data,
+		sieve_size_t size);
+sieve_size_t sieve_binary_get_code_size(struct sieve_binary *binary);
+
+/* Offset emission functions */
+
+sieve_size_t sieve_binary_emit_offset
+	(struct sieve_binary *binary, int offset);
+void sieve_binary_resolve_offset
+	(struct sieve_binary *binary, sieve_size_t address);
+
+/* Literal emission functions */
+
+sieve_size_t sieve_binary_emit_integer
+	(struct sieve_binary *binary, sieve_number_t integer);
+sieve_size_t sieve_binary_emit_string
+	(struct sieve_binary *binary, const string_t *str);
+sieve_size_t sieve_binary_emit_cstring
+	(struct sieve_binary *binary, const char *str);
+
+static inline sieve_size_t sieve_binary_emit_unsigned
+	(struct sieve_binary *binary, unsigned int count)
+{
+	return sieve_binary_emit_integer(binary, count);
+}
+
+
+/* Extension emission functions */
+
+sieve_size_t sieve_binary_emit_extension
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		unsigned int offset);
+void sieve_binary_emit_extension_object
+	(struct sieve_binary *sbin, const struct sieve_extension_objects *objs,
+    	unsigned int code);
+
+/*
+ * Code retrieval
+ */
+
+/* Literals */
+bool sieve_binary_read_byte
+	(struct sieve_binary *binary, sieve_size_t *address, unsigned int *byte_r);
+bool sieve_binary_read_code
+	(struct sieve_binary *binary, sieve_size_t *address, signed int *code_r);
+bool sieve_binary_read_offset
+	(struct sieve_binary *binary, sieve_size_t *address, int *offset_r);
+bool sieve_binary_read_integer
+  (struct sieve_binary *binary, sieve_size_t *address, sieve_number_t *int_r);
+bool sieve_binary_read_string
+  (struct sieve_binary *binary, sieve_size_t *address, string_t **str_r);
+
+static inline bool sieve_binary_read_unsigned
+  (struct sieve_binary *binary, sieve_size_t *address, unsigned int *count_r)
+{
+	sieve_number_t integer;
+
+	if ( !sieve_binary_read_integer(binary, address, &integer) )
+		return FALSE;
+
+	*count_r = integer;
+
+	return TRUE;
+}
+
+/* Extension */
+bool sieve_binary_read_extension
+	(struct sieve_binary *sbin, sieve_size_t *address, unsigned int *offset_r,
+		const struct sieve_extension **ext_r);
+const void *sieve_binary_read_extension_object
+	(struct sieve_binary *binary, sieve_size_t *address,
+    	const struct sieve_extension_objects *objs);
+
+#endif
Index: b/sieve/src/lib-sieve/sieve-code-dumper.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-code-dumper.c
@@ -0,0 +1,293 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-comparators.h"
+
+#include "sieve-dump.h"
+
+/*
+ * Code dumper extension
+ */
+
+struct sieve_code_dumper_extension_reg {
+	const struct sieve_code_dumper_extension *cdmpext;
+	const struct sieve_extension *ext;
+	void *context;
+};
+
+struct sieve_code_dumper {
+	pool_t pool;
+
+	/* Dump status */
+	sieve_size_t pc;          /* Program counter */
+
+	const struct sieve_operation *operation;
+	sieve_size_t mark_address;
+	unsigned int indent;
+
+	/* Dump environment */
+	struct sieve_dumptime_env *dumpenv;
+
+	ARRAY_DEFINE(extensions, struct sieve_code_dumper_extension_reg);
+};
+
+struct sieve_code_dumper *sieve_code_dumper_create
+	(struct sieve_dumptime_env *denv)
+{
+	pool_t pool;
+	struct sieve_code_dumper *dumper;
+
+	pool = pool_alloconly_create("sieve_code_dumper", 4096);
+	dumper = p_new(pool, struct sieve_code_dumper, 1);
+	dumper->pool = pool;
+	dumper->dumpenv = denv;
+	dumper->pc = 0;
+
+	/* Setup storage for extension contexts */
+	p_array_init(&dumper->extensions, pool,
+		sieve_extensions_get_count(denv->svinst));
+
+	return dumper;
+}
+
+void sieve_code_dumper_free(struct sieve_code_dumper **dumper)
+{
+	pool_unref(&((*dumper)->pool));
+
+	*dumper = NULL;
+}
+
+pool_t sieve_code_dumper_pool(struct sieve_code_dumper *dumper)
+{
+	return dumper->pool;
+}
+
+/* EXtension support */
+
+void sieve_dump_extension_register
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext,
+	const struct sieve_code_dumper_extension *cdmpext, void *context)
+{
+	struct sieve_code_dumper_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	reg = array_idx_modifiable(&dumper->extensions, (unsigned int) ext->id);
+	reg->cdmpext = cdmpext;
+	reg->ext = ext;
+	reg->context = context;
+}
+
+void sieve_dump_extension_set_context
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext,
+	void *context)
+{
+	struct sieve_code_dumper_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	reg = array_idx_modifiable(&dumper->extensions, (unsigned int) ext->id);
+	reg->context = context;
+}
+
+void *sieve_dump_extension_get_context
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext)
+{
+	const struct sieve_code_dumper_extension_reg *reg;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&dumper->extensions) )
+		return NULL;
+
+	reg = array_idx(&dumper->extensions, (unsigned int) ext->id);
+
+	return reg->context;
+}
+
+/* Dump functions */
+
+void sieve_code_dumpf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	struct sieve_code_dumper *cdumper = denv->cdumper;
+	unsigned tab = cdumper->indent;
+
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_printfa(outbuf, "%08llx: ", (unsigned long long) cdumper->mark_address);
+
+	while ( tab > 0 )	{
+		str_append(outbuf, "  ");
+		tab--;
+	}
+
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_code_mark(const struct sieve_dumptime_env *denv)
+{
+	denv->cdumper->mark_address = denv->cdumper->pc;
+}
+
+void sieve_code_mark_specific
+(const struct sieve_dumptime_env *denv, sieve_size_t location)
+{
+	denv->cdumper->mark_address = location;
+}
+
+void sieve_code_descend(const struct sieve_dumptime_env *denv)
+{
+	denv->cdumper->indent++;
+}
+
+void sieve_code_ascend(const struct sieve_dumptime_env *denv)
+{
+	if ( denv->cdumper->indent > 0 )
+		denv->cdumper->indent--;
+}
+
+/* Operations and operands */
+
+bool sieve_code_dumper_print_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = -1;
+
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) {
+				return FALSE;
+			}
+
+			if ( opt_code == SIEVE_OPT_SIDE_EFFECT ) {
+				if ( !sieve_opr_side_effect_dump(denv, address) )
+					return FALSE;
+			}
+		}
+	}
+	return TRUE;
+}
+
+/* Code Dump */
+
+static bool sieve_code_dumper_print_operation
+	(struct sieve_code_dumper *dumper)
+{
+	struct sieve_dumptime_env *denv = dumper->dumpenv;
+	struct sieve_operation *oprtn = &denv->oprtn;
+	sieve_size_t address;
+
+	/* Mark start address of operation */
+	dumper->indent = 0;
+	address = dumper->mark_address = dumper->pc;
+
+	/* Read operation */
+	if ( sieve_operation_read(denv->sbin, &(dumper->pc), oprtn) ) {
+		const struct sieve_operation_def *op = oprtn->def;
+
+		if ( op->dump != NULL )
+			return op->dump(denv, &(dumper->pc));
+		else if ( op->mnemonic != NULL )
+			sieve_code_dumpf(denv, "%s", op->mnemonic);
+		else
+			return FALSE;
+
+		return TRUE;
+	}
+
+	sieve_code_dumpf(denv, "Failed to read opcode.");
+	return FALSE;
+}
+
+void sieve_code_dumper_run(struct sieve_code_dumper *dumper)
+{
+	const struct sieve_dumptime_env *denv = dumper->dumpenv;
+	struct sieve_binary *sbin = denv->sbin;
+	unsigned int ext_count;
+	bool success = TRUE;
+
+	dumper->pc = 0;
+
+	/* Load and dump extensions listed in code */
+	sieve_code_mark(denv);
+
+	if ( sieve_binary_read_unsigned(sbin, &dumper->pc, &ext_count) ) {
+		unsigned int i;
+
+		sieve_code_dumpf(denv, "EXTENSIONS [%d]:", ext_count);
+		sieve_code_descend(denv);
+
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int code = 0;
+			const struct sieve_extension *ext;
+
+			T_BEGIN {
+				sieve_code_mark(denv);
+
+				if ( !sieve_binary_read_extension(sbin, &dumper->pc, &code, &ext) ) {
+					success = FALSE;
+					break;
+				}
+
+				sieve_code_dumpf(denv, "%s", sieve_extension_name(ext));
+
+				if ( ext->def != NULL && ext->def->code_dump != NULL ) {
+					sieve_code_descend(denv);
+					if ( !ext->def->code_dump(ext, denv, &dumper->pc) ) {
+						success = FALSE;
+						break;
+					}
+					sieve_code_ascend(denv);
+				}
+			} T_END;
+		}
+
+		sieve_code_ascend(denv);
+	}	else
+		success = FALSE;
+
+	if ( !success ) {
+		sieve_code_dumpf(denv, "Binary code header is corrupt.");
+		return;
+	}
+
+	while ( dumper->pc <
+		sieve_binary_get_code_size(sbin) ) {
+
+		T_BEGIN {
+			success = sieve_code_dumper_print_operation(dumper);
+		} T_END;
+
+		if ( !success ) {
+			sieve_code_dumpf(dumper->dumpenv, "Binary is corrupt.");
+			return;
+		}
+	}
+
+	/* Mark end of the binary */
+	dumper->indent = 0;
+	dumper->mark_address = sieve_binary_get_code_size(sbin);
+	sieve_code_dumpf(dumper->dumpenv, "[End of code]");
+}
Index: b/sieve/src/lib-sieve/sieve-code-dumper.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-code-dumper.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_CODE_DUMPER_H
+#define __SIEVE_CODE_DUMPER_H
+
+#include "sieve-common.h"
+
+struct sieve_code_dumper;
+
+struct sieve_code_dumper *sieve_code_dumper_create
+	(struct sieve_dumptime_env *denv);
+void sieve_code_dumper_free
+	(struct sieve_code_dumper **dumper);
+pool_t sieve_code_dumper_pool
+	(struct sieve_code_dumper *dumper);
+
+/*
+ * Extension support
+ */
+
+struct sieve_code_dumper_extension {
+	const struct sieve_extension_def *ext;
+
+	void (*free)(struct sieve_code_dumper *dumper, void *context);
+};
+
+void sieve_dump_extension_register
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext,
+	const struct sieve_code_dumper_extension *dump_ext, void *context);
+void sieve_dump_extension_set_context
+	(struct sieve_code_dumper *dumper, const struct sieve_extension *ext,
+		void *context);
+void *sieve_dump_extension_get_context
+	(struct sieve_code_dumper *dumper, const struct sieve_extension *ext);
+
+/* Dump functions */
+
+void sieve_code_dumpf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+void sieve_code_mark(const struct sieve_dumptime_env *denv);
+void sieve_code_mark_specific
+	(const struct sieve_dumptime_env *denv, sieve_size_t location);
+void sieve_code_descend(const struct sieve_dumptime_env *denv);
+void sieve_code_ascend(const struct sieve_dumptime_env *denv);
+
+/* Operations and operands */
+
+bool sieve_code_dumper_print_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/* Code dump (debugging purposes) */
+
+void sieve_code_dumper_run(struct sieve_code_dumper *dumper);
+
+#endif /* __SIEVE_CODE_DUMPER_H */
Index: b/sieve/src/lib-sieve/sieve-code.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-code.c
@@ -0,0 +1,1077 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-code.h"
+
+#include <stdio.h>
+
+/* 		return opr_r->def != NULL;
+ * Coded stringlist
+ */
+
+struct sieve_coded_stringlist {
+	const struct sieve_runtime_env *runenv;
+	sieve_size_t start_address;
+	sieve_size_t end_address;
+	sieve_size_t current_offset;
+	unsigned int length;
+	unsigned int index;
+};
+
+static struct sieve_coded_stringlist *sieve_coded_stringlist_create
+(const struct sieve_runtime_env *renv,
+	 sieve_size_t start_address, unsigned int length, sieve_size_t end)
+{
+	struct sieve_coded_stringlist *strlist;
+
+	if ( end > sieve_binary_get_code_size(renv->sbin) )
+  		return NULL;
+
+	strlist = t_new(struct sieve_coded_stringlist, 1);
+	strlist->runenv = renv;
+	strlist->start_address = start_address;
+	strlist->current_offset = start_address;
+	strlist->end_address = end;
+	strlist->length = length;
+	strlist->index = 0;
+
+	return strlist;
+}
+
+bool sieve_coded_stringlist_next_item
+(struct sieve_coded_stringlist *strlist, string_t **str_r)
+{
+	sieve_size_t address;
+	*str_r = NULL;
+
+	if ( strlist->index >= strlist->length )
+		return TRUE;
+	else {
+		address = strlist->current_offset;
+
+		if ( sieve_opr_string_read(strlist->runenv, &address, str_r) ) {
+			strlist->index++;
+			strlist->current_offset = address;
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+void sieve_coded_stringlist_reset(struct sieve_coded_stringlist *strlist)
+{
+	strlist->current_offset = strlist->start_address;
+	strlist->index = 0;
+}
+
+unsigned int sieve_coded_stringlist_get_length
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->length;
+}
+
+sieve_size_t sieve_coded_stringlist_get_end_address
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->end_address;
+}
+
+sieve_size_t sieve_coded_stringlist_get_current_offset
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->current_offset;
+}
+
+bool sieve_coded_stringlist_read_all
+(struct sieve_coded_stringlist *strlist, pool_t pool,
+	const char * const **list_r)
+{
+	bool result = FALSE;
+	ARRAY_DEFINE(items, const char *);
+	string_t *item;
+
+	sieve_coded_stringlist_reset(strlist);
+
+	p_array_init(&items, pool, 4);
+
+	item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(strlist, &item)) &&
+		item != NULL ) {
+		const char *stritem = p_strdup(pool, str_c(item));
+
+		array_append(&items, &stritem, 1);
+	}
+
+	(void)array_append_space(&items);
+	*list_r = array_idx(&items, 0);
+
+	return result;
+}
+
+static bool sieve_coded_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	unsigned int length, sieve_size_t end, const char *field_name)
+{
+	unsigned int i;
+
+	if ( end > sieve_binary_get_code_size(denv->sbin) )
+  		return FALSE;
+
+	if ( field_name != NULL )
+		sieve_code_dumpf(denv, "%s: STRLIST [%u] (end: %08llx)",
+			field_name, length, (unsigned long long) end);
+	else
+		sieve_code_dumpf(denv, "STRLIST [%u] (end: %08llx)",
+			length, (unsigned long long) end);
+
+	sieve_code_descend(denv);
+
+	for ( i = 0; i < length; i++ ) {
+		bool success = TRUE;
+
+		T_BEGIN {
+			success = sieve_opr_string_dump(denv, address, NULL);
+		} T_END;
+
+		if ( !success || *address > end )
+			return FALSE;
+	}
+
+	if ( *address != end ) return FALSE;
+
+	sieve_code_ascend(denv);
+
+	return TRUE;
+}
+
+/*
+ * Source line coding
+ */
+
+void sieve_code_source_line_emit
+(struct sieve_binary *sbin, unsigned int source_line)
+{
+    (void)sieve_binary_emit_unsigned(sbin, source_line);
+}
+
+bool sieve_code_source_line_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    unsigned int number = 0;
+
+	sieve_code_mark(denv);
+    if (sieve_binary_read_unsigned(denv->sbin, address, &number) ) {
+        sieve_code_dumpf(denv, "(source line: %lu)", (unsigned long) number);
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+bool sieve_code_source_line_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	unsigned int *source_line_r)
+{
+	return sieve_binary_read_unsigned(renv->sbin, address, source_line_r);
+}
+
+/*
+ * Core operands
+ */
+
+extern const struct sieve_operand_def comparator_operand;
+extern const struct sieve_operand_def match_type_operand;
+extern const struct sieve_operand_def address_part_operand;
+
+const struct sieve_operand_def *sieve_operands[] = {
+	&omitted_operand, /* SIEVE_OPERAND_OPTIONAL */
+	&number_operand,
+	&string_operand,
+	&stringlist_operand,
+	&comparator_operand,
+	&match_type_operand,
+	&address_part_operand,
+	&catenated_string_operand
+};
+
+const unsigned int sieve_operand_count =
+	N_ELEMENTS(sieve_operands);
+
+/*
+ * Operand functions
+ */
+
+sieve_size_t sieve_operand_emit
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	const struct sieve_operand_def *opr_def)
+{
+	sieve_size_t address;
+
+	if ( ext != NULL ) {
+		address = sieve_binary_emit_extension
+			(sbin, ext, sieve_operand_count);
+
+		sieve_binary_emit_extension_object
+			(sbin, &opr_def->ext_def->operands, opr_def->code);
+
+		return address;
+	}
+
+	return sieve_binary_emit_byte(sbin, opr_def->code);
+}
+
+bool sieve_operand_read
+(struct sieve_binary *sbin, sieve_size_t *address,
+	struct sieve_operand *operand)
+{
+	unsigned int code = sieve_operand_count;
+
+	operand->address = *address;
+	operand->ext = NULL;
+	operand->def = NULL;
+
+	if ( !sieve_binary_read_extension(sbin, address, &code, &operand->ext) )
+		return NULL;
+
+	if ( operand->ext == NULL ) {
+		if ( code < sieve_operand_count )
+			operand->def = sieve_operands[code];
+
+		return ( operand->def != NULL );
+	}
+
+	if ( operand->ext->def == NULL )
+		return FALSE;
+
+	operand->def = (const struct sieve_operand_def *)
+		sieve_binary_read_extension_object(sbin, address,
+			&operand->ext->def->operands);
+
+	return ( operand->def != NULL );
+}
+
+bool sieve_operand_optional_present
+(struct sieve_binary *sbin, sieve_size_t *address)
+{
+	sieve_size_t tmp_addr = *address;
+	unsigned int op = -1;
+
+	if ( sieve_binary_read_byte(sbin, &tmp_addr, &op) &&
+		(op == SIEVE_OPERAND_OPTIONAL) ) {
+		*address = tmp_addr;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+bool sieve_operand_optional_read
+(struct sieve_binary *sbin, sieve_size_t *address, signed int *id_code)
+{
+	if ( sieve_binary_read_code(sbin, address, id_code) )
+		return TRUE;
+
+	*id_code = 0;
+
+	return FALSE;
+}
+
+/*
+ * Operand definitions
+ */
+
+/* Omitted */
+
+const struct sieve_operand_class omitted_class =
+	{ "OMITTED" };
+
+const struct sieve_operand_def omitted_operand = {
+	"@OMITTED",
+	NULL, SIEVE_OPERAND_OPTIONAL,
+	&omitted_class, NULL
+};
+
+/* Number */
+
+static bool opr_number_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static bool opr_number_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		sieve_number_t *number_r);
+
+const struct sieve_opr_number_interface number_interface = {
+	opr_number_dump,
+	opr_number_read
+};
+
+const struct sieve_operand_class number_class =
+	{ "number" };
+
+const struct sieve_operand_def number_operand = {
+	"@number",
+	NULL, SIEVE_OPERAND_NUMBER,
+	&number_class,
+	&number_interface
+};
+
+/* String */
+
+static bool opr_string_dump
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *opr,
+		sieve_size_t *address, const char *field_name);
+static bool opr_string_read
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *opr,
+		sieve_size_t *address, string_t **str_r);
+
+const struct sieve_opr_string_interface string_interface ={
+	opr_string_dump,
+	opr_string_read
+};
+
+const struct sieve_operand_class string_class =
+	{ "string" };
+
+const struct sieve_operand_def string_operand = {
+	"@string",
+	NULL, SIEVE_OPERAND_STRING,
+	&string_class,
+	&string_interface
+};
+
+/* String List */
+
+static bool opr_stringlist_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static struct sieve_coded_stringlist *opr_stringlist_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_opr_stringlist_interface stringlist_interface = {
+	opr_stringlist_dump,
+	opr_stringlist_read
+};
+
+const struct sieve_operand_class stringlist_class =
+	{ "string-list" };
+
+const struct sieve_operand_def stringlist_operand =	{
+	"@string-list",
+	NULL, SIEVE_OPERAND_STRING_LIST,
+	&stringlist_class,
+	&stringlist_interface
+};
+
+/* Catenated String */
+
+static bool opr_catenated_string_read
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, string_t **str);
+static bool opr_catenated_string_dump
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name);
+
+const struct sieve_opr_string_interface catenated_string_interface = {
+	opr_catenated_string_dump,
+	opr_catenated_string_read
+};
+
+const struct sieve_operand_def catenated_string_operand = {
+	"@catenated-string",
+	NULL, SIEVE_OPERAND_CATENATED_STRING,
+	&string_class,
+	&catenated_string_interface
+};
+
+/*
+ * Operand implementations
+ */
+
+/* Omitted */
+
+void sieve_opr_omitted_emit(struct sieve_binary *sbin)
+{
+	(void) sieve_operand_emit(sbin, NULL, &omitted_operand);
+}
+
+/* Number */
+
+void sieve_opr_number_emit(struct sieve_binary *sbin, sieve_number_t number)
+{
+	(void) sieve_operand_emit(sbin, NULL, &number_operand);
+	(void) sieve_binary_emit_integer(sbin, number);
+}
+
+bool sieve_opr_number_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *opr,
+	sieve_size_t *address, const char *field_name)
+{
+	const struct sieve_opr_number_interface *intf;
+
+	if ( !sieve_operand_is_number(opr) )
+		return FALSE;
+
+	intf = (const struct sieve_opr_number_interface *) opr->def->interface;
+
+	if ( intf->dump == NULL )
+		return FALSE;
+
+	return intf->dump(denv, address, field_name);
+}
+
+bool sieve_opr_number_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name)
+{
+	struct sieve_operand operand;
+
+	sieve_code_mark(denv);
+
+	if ( !sieve_operand_read(denv->sbin, address, &operand) )
+		return FALSE;
+
+	return sieve_opr_number_dump_data(denv, &operand, address, field_name);
+}
+
+bool sieve_opr_number_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *opr,
+	sieve_size_t *address, sieve_number_t *number_r)
+{
+	const struct sieve_opr_number_interface *intf;
+
+	if ( !sieve_operand_is_number(opr) )
+		return FALSE;
+
+	intf = (const struct sieve_opr_number_interface *) opr->def->interface;
+
+	if ( intf->read == NULL )
+		return FALSE;
+
+	return intf->read(renv, address, number_r);
+}
+
+bool sieve_opr_number_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	sieve_number_t *number_r)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) )
+		return FALSE;
+
+	return sieve_opr_number_read_data(renv, &operand, address, number_r);
+}
+
+static bool opr_number_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name)
+{
+	sieve_number_t number = 0;
+
+	if (sieve_binary_read_integer(denv->sbin, address, &number) ) {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: NUM %llu", field_name,
+				(unsigned long long) number);
+		else
+			sieve_code_dumpf(denv, "NUM %llu", (unsigned long long) number);
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static bool opr_number_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	sieve_number_t *number_r)
+{
+	return sieve_binary_read_integer(renv->sbin, address, number_r);
+}
+
+/* String */
+
+void sieve_opr_string_emit(struct sieve_binary *sbin, string_t *str)
+{
+	(void) sieve_operand_emit(sbin, NULL, &string_operand);
+	(void) sieve_binary_emit_string(sbin, str);
+}
+
+bool sieve_opr_string_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *opr,
+	sieve_size_t *address, const char *field_name)
+{
+	const struct sieve_opr_string_interface *intf;
+
+	if ( !sieve_operand_is_string(opr) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID STRING OPERAND %s",
+			sieve_operand_name(opr));
+		return FALSE;
+	}
+
+	intf = (const struct sieve_opr_string_interface *) opr->def->interface;
+
+	if ( intf->dump == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: DUMP STRING OPERAND");
+		return FALSE;
+	}
+
+	return intf->dump(denv, opr, address, field_name);
+}
+
+bool sieve_opr_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name)
+{
+	struct sieve_operand operand;
+
+	sieve_code_mark(denv);
+
+	if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	return sieve_opr_string_dump_data(denv, &operand, address, field_name);
+}
+
+bool sieve_opr_string_dump_ex
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name, bool *literal_r)
+{
+	struct sieve_operand operand;
+
+	sieve_code_mark(denv);
+	if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	*literal_r = sieve_operand_is(&operand, string_operand);
+
+	return sieve_opr_string_dump_data(denv, &operand, address, field_name);
+}
+
+bool sieve_opr_string_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *opr,
+	sieve_size_t *address, string_t **str_r)
+{
+	const struct sieve_opr_string_interface *intf;
+
+	if ( opr == NULL || opr->def == NULL || opr->def->class != &string_class )
+		return FALSE;
+
+	intf = (const struct sieve_opr_string_interface *) opr->def->interface;
+
+	if ( intf->read == NULL )
+		return FALSE;
+
+	return intf->read(renv, opr, address, str_r);
+}
+
+bool sieve_opr_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+		return FALSE;
+	}
+
+	return sieve_opr_string_read_data(renv, &operand, address, str_r);
+}
+
+bool sieve_opr_string_read_ex
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r,
+	bool *literal_r)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+		return FALSE;
+	}
+
+	*literal_r = sieve_operand_is(&operand, string_operand);
+
+	return sieve_opr_string_read_data(renv, &operand, address, str_r);
+}
+
+static void _dump_string
+(const struct sieve_dumptime_env *denv, string_t *str,
+	const char *field_name)
+{
+	if ( str_len(str) > 80 ) {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: STR[%ld] \"%s",
+				field_name, (long) str_len(str), str_sanitize(str_c(str), 80));
+		else
+			sieve_code_dumpf(denv, "STR[%ld] \"%s",
+				(long) str_len(str), str_sanitize(str_c(str), 80));
+	} else {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: STR[%ld] \"%s\"",
+				field_name, (long) str_len(str), str_sanitize(str_c(str), 80));
+		else
+			sieve_code_dumpf(denv, "STR[%ld] \"%s\"",
+				(long) str_len(str), str_sanitize(str_c(str), 80));
+	}
+}
+
+bool opr_string_dump
+(const struct sieve_dumptime_env *denv,
+	const struct sieve_operand *opr ATTR_UNUSED, sieve_size_t *address,
+	const char *field_name)
+{
+	string_t *str;
+
+	if ( sieve_binary_read_string(denv->sbin, address, &str) ) {
+		_dump_string(denv, str, field_name);
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static bool opr_string_read
+(const struct sieve_runtime_env *renv,
+	const struct sieve_operand *opr ATTR_UNUSED, sieve_size_t *address,
+	string_t **str_r)
+{
+	return sieve_binary_read_string(renv->sbin, address, str_r);
+}
+
+/* String list */
+
+void sieve_opr_stringlist_emit_start
+(struct sieve_binary *sbin, unsigned int listlen, void **context)
+{
+	sieve_size_t *end_offset = t_new(sieve_size_t, 1);
+
+	/* Emit byte identifying the type of operand */
+	(void) sieve_operand_emit(sbin, NULL, &stringlist_operand);
+
+	/* Give the interpreter an easy way to skip over this string list */
+	*end_offset = sieve_binary_emit_offset(sbin, 0);
+	*context = (void *) end_offset;
+
+	/* Emit the length of the list */
+	(void) sieve_binary_emit_unsigned(sbin, listlen);
+}
+
+void sieve_opr_stringlist_emit_item
+(struct sieve_binary *sbin, void *context ATTR_UNUSED, string_t *item)
+{
+	(void) sieve_opr_string_emit(sbin, item);
+}
+
+void sieve_opr_stringlist_emit_end
+(struct sieve_binary *sbin, void *context)
+{
+	sieve_size_t *end_offset = (sieve_size_t *) context;
+
+	(void) sieve_binary_resolve_offset(sbin, *end_offset);
+}
+
+bool sieve_opr_stringlist_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *opr,
+	sieve_size_t *address, const char *field_name)
+{
+	if ( opr == NULL || opr->def == NULL )
+		return FALSE;
+
+	if ( opr->def->class == &stringlist_class ) {
+		const struct sieve_opr_stringlist_interface *intf =
+			(const struct sieve_opr_stringlist_interface *) opr->def->interface;
+
+		if ( intf->dump == NULL )
+			return FALSE;
+
+		return intf->dump(denv, address, field_name);
+	} else if ( opr->def->class == &string_class ) {
+		const struct sieve_opr_string_interface *intf =
+			(const struct sieve_opr_string_interface *) opr->def->interface;
+
+		if ( intf->dump == NULL )
+			return FALSE;
+
+		return intf->dump(denv, opr, address, field_name);
+	}
+
+	return FALSE;
+}
+
+bool sieve_opr_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name)
+{
+	struct sieve_operand operand;
+
+	sieve_code_mark(denv);
+
+	if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+		return FALSE;
+	}
+
+	return sieve_opr_stringlist_dump_data(denv, &operand, address, field_name);
+}
+
+struct sieve_coded_stringlist *sieve_opr_stringlist_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *opr,
+	sieve_size_t *address)
+{
+	if ( opr == NULL || opr->def == NULL )
+		return NULL;
+
+	if ( opr->def->class == &stringlist_class ) {
+		const struct sieve_opr_stringlist_interface *intf =
+			(const struct sieve_opr_stringlist_interface *) opr->def->interface;
+
+		if ( intf->read == NULL )
+			return NULL;
+
+		return intf->read(renv, address);
+	} else if ( opr->def->class == &string_class ) {
+		/* Special case, accept single string as string list as well. */
+		const struct sieve_opr_string_interface *intf =
+			(const struct sieve_opr_string_interface *) opr->def->interface;
+
+		if ( intf->read == NULL || !intf->read(renv, opr, address, NULL) ) {
+			return NULL;
+		}
+
+		return sieve_coded_stringlist_create(renv, opr->address, 1, *address);
+	}
+
+	return NULL;
+}
+
+struct sieve_coded_stringlist *sieve_opr_stringlist_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+		return NULL;
+	}
+
+	return sieve_opr_stringlist_read_data(renv, &operand, address);
+}
+
+static bool opr_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name)
+{
+	sieve_size_t pc = *address;
+	sieve_size_t end;
+	unsigned int length = 0;
+ 	int end_offset;
+
+	if ( !sieve_binary_read_offset(denv->sbin, address, &end_offset) )
+		return FALSE;
+
+	end = pc + end_offset;
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &length) )
+		return FALSE;
+
+	return sieve_coded_stringlist_dump(denv, address, length, end, field_name);
+}
+
+static struct sieve_coded_stringlist *opr_stringlist_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address )
+{
+	struct sieve_coded_stringlist *strlist;
+	sieve_size_t pc = *address;
+	sieve_size_t end;
+	unsigned int length = 0;
+	int end_offset;
+
+	if ( !sieve_binary_read_offset(renv->sbin, address, &end_offset) )
+		return NULL;
+
+	end = pc + end_offset;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &length) )
+	  	return NULL;
+
+	strlist = sieve_coded_stringlist_create(renv, *address, (unsigned int) length, end);
+
+	/* Skip over the string list for now */
+	*address = end;
+
+	return strlist;
+}
+
+/* Catenated String */
+
+void sieve_opr_catenated_string_emit
+(struct sieve_binary *sbin, unsigned int elements)
+{
+	(void) sieve_operand_emit(sbin, NULL, &catenated_string_operand);
+	(void) sieve_binary_emit_unsigned(sbin, elements);
+}
+
+static bool opr_catenated_string_dump
+(const struct sieve_dumptime_env *denv,
+	const struct sieve_operand *operand ATTR_UNUSED, sieve_size_t *address,
+	const char *field_name)
+{
+	unsigned int elements = 0;
+	unsigned int i;
+
+	if (!sieve_binary_read_unsigned(denv->sbin, address, &elements) )
+		return FALSE;
+
+	if ( field_name != NULL )
+		sieve_code_dumpf(denv, "%s: CAT-STR [%ld]:",
+			field_name, (long) elements);
+	else
+		sieve_code_dumpf(denv, "CAT-STR [%ld]:", (long) elements);
+
+	sieve_code_descend(denv);
+	for ( i = 0; i < (unsigned int) elements; i++ ) {
+		if ( !sieve_opr_string_dump(denv, address, NULL) )
+			return FALSE;
+	}
+	sieve_code_ascend(denv);
+
+	return TRUE;
+}
+
+static bool opr_catenated_string_read
+(const struct sieve_runtime_env *renv,
+	const struct sieve_operand *operand ATTR_UNUSED, sieve_size_t *address,
+	string_t **str)
+{
+	unsigned int elements = 0;
+	unsigned int i;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &elements) )
+		return FALSE;
+
+	/* Parameter str can be NULL if we are requested to only skip and not
+	 * actually read the argument.
+	 */
+	if ( str == NULL ) {
+		for ( i = 0; i < (unsigned int) elements; i++ ) {
+			if ( !sieve_opr_string_read(renv, address, NULL) )
+				return FALSE;
+		}
+	} else {
+		string_t *strelm;
+		string_t **elm = &strelm;
+
+		*str = t_str_new(128);
+		for ( i = 0; i < (unsigned int) elements; i++ ) {
+
+			if ( !sieve_opr_string_read(renv, address, elm) )
+				return FALSE;
+
+			if ( elm != NULL ) {
+				str_append_str(*str, strelm);
+
+				if ( str_len(*str) > SIEVE_MAX_STRING_LEN ) {
+					str_truncate(*str, SIEVE_MAX_STRING_LEN);
+					elm = NULL;
+				}
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Core operations
+ */
+
+/* Forward declarations */
+
+static bool opc_jmp_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+static int opc_jmp_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+static int opc_jmptrue_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+static int opc_jmpfalse_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Operation objects defined in this file */
+
+const struct sieve_operation_def sieve_jmp_operation = {
+	"JMP",
+	NULL,
+	SIEVE_OPERATION_JMP,
+	opc_jmp_dump,
+	opc_jmp_execute
+};
+
+const struct sieve_operation_def sieve_jmptrue_operation = {
+	"JMPTRUE",
+	NULL,
+	SIEVE_OPERATION_JMPTRUE,
+	opc_jmp_dump,
+	opc_jmptrue_execute
+};
+
+const struct sieve_operation_def sieve_jmpfalse_operation = {
+	"JMPFALSE",
+	NULL,
+	SIEVE_OPERATION_JMPFALSE,
+	opc_jmp_dump,
+	opc_jmpfalse_execute
+};
+
+/* Operation objects defined in other files */
+
+extern const struct sieve_operation_def cmd_stop_operation;
+extern const struct sieve_operation_def cmd_keep_operation;
+extern const struct sieve_operation_def cmd_discard_operation;
+extern const struct sieve_operation_def cmd_redirect_operation;
+
+extern const struct sieve_operation_def tst_address_operation;
+extern const struct sieve_operation_def tst_header_operation;
+extern const struct sieve_operation_def tst_exists_operation;
+extern const struct sieve_operation_def tst_size_over_operation;
+extern const struct sieve_operation_def tst_size_under_operation;
+
+const struct sieve_operation_def *sieve_operations[] = {
+	NULL,
+
+	&sieve_jmp_operation,
+	&sieve_jmptrue_operation,
+	&sieve_jmpfalse_operation,
+
+	&cmd_stop_operation,
+	&cmd_keep_operation,
+	&cmd_discard_operation,
+	&cmd_redirect_operation,
+
+	&tst_address_operation,
+	&tst_header_operation,
+	&tst_exists_operation,
+	&tst_size_over_operation,
+	&tst_size_under_operation
+};
+
+const unsigned int sieve_operation_count =
+	N_ELEMENTS(sieve_operations);
+
+/*
+ * Operation functions
+ */
+
+sieve_size_t sieve_operation_emit
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	const struct sieve_operation_def *op_def)
+{
+	sieve_size_t address;
+
+  if ( ext != NULL ) {
+		address = sieve_binary_emit_extension
+			(sbin, ext, sieve_operation_count);
+
+		sieve_binary_emit_extension_object
+			(sbin, &op_def->ext_def->operations, op_def->code);
+
+		return address;
+  }
+
+  return sieve_binary_emit_byte(sbin, op_def->code);
+}
+
+bool sieve_operation_read
+(struct sieve_binary *sbin, sieve_size_t *address,
+	struct sieve_operation *oprtn)
+{
+	unsigned int code = sieve_operation_count;
+
+	oprtn->address = *address;
+	oprtn->def = NULL;
+	oprtn->ext = NULL;
+
+	if ( !sieve_binary_read_extension(sbin, address, &code, &oprtn->ext) )
+		return FALSE;
+
+	if ( !oprtn->ext ) {
+		if ( code < sieve_operation_count ) {
+			oprtn->def = sieve_operations[code];
+		}
+
+		return ( oprtn->def != NULL );
+	}
+
+	oprtn->def = (const struct sieve_operation_def *)
+		sieve_binary_read_extension_object(sbin, address,
+			&oprtn->ext->def->operations);
+
+	return ( oprtn->def != NULL );
+}
+
+/*
+ * Jump operations
+ */
+
+/* Code dump */
+
+static bool opc_jmp_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &denv->oprtn;
+	unsigned int pc = *address;
+	int offset;
+
+	if ( sieve_binary_read_offset(denv->sbin, address, &offset) )
+		sieve_code_dumpf(denv, "%s %d [%08x]",
+			sieve_operation_mnemonic(op), offset, pc + offset);
+	else
+		return FALSE;
+
+	return TRUE;
+}
+
+/* Code execution */
+
+static int opc_jmp_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_runtime_trace(renv, "JMP");
+
+	return sieve_interpreter_program_jump(renv->interp, TRUE);
+}
+
+static int opc_jmptrue_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	bool result = sieve_interpreter_get_test_result(renv->interp);
+
+	sieve_runtime_trace(renv, "JMPTRUE (%s)", result ? "true" : "false");
+
+	return sieve_interpreter_program_jump(renv->interp, result);
+}
+
+static int opc_jmpfalse_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	bool result = sieve_interpreter_get_test_result(renv->interp);
+
+	sieve_runtime_trace(renv, "JMPFALSE (%s)", result ? "true" : "false" );
+
+	return sieve_interpreter_program_jump(renv->interp, !result);
+}
Index: b/sieve/src/lib-sieve/sieve-code.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-code.h
@@ -0,0 +1,324 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_CODE_H
+#define __SIEVE_CODE_H
+
+#include "lib.h"
+#include "buffer.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+/*
+ * Coded string list
+ */
+
+struct sieve_coded_stringlist;
+
+bool sieve_coded_stringlist_next_item
+	(struct sieve_coded_stringlist *strlist, string_t **str_r);
+void sieve_coded_stringlist_reset
+	(struct sieve_coded_stringlist *strlist);
+bool sieve_coded_stringlist_read_all
+	(struct sieve_coded_stringlist *strlist, pool_t pool,
+		const char * const **list_r);
+
+unsigned int sieve_coded_stringlist_get_length
+	(struct sieve_coded_stringlist *strlist);
+sieve_size_t sieve_coded_stringlist_get_end_address
+	(struct sieve_coded_stringlist *strlist);
+sieve_size_t sieve_coded_stringlist_get_current_offset
+	(struct sieve_coded_stringlist *strlist);
+
+/*
+ * Source line coding
+ */
+
+void sieve_code_source_line_emit
+	(struct sieve_binary *sbin, unsigned int source_line);
+bool sieve_code_source_line_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+bool sieve_code_source_line_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+    	unsigned int *source_line_r);
+
+/*
+ * Operand object
+ */
+
+struct sieve_operand_class {
+	const char *name;
+};
+
+struct sieve_operand_def {
+	const char *name;
+
+	const struct sieve_extension_def *ext_def;
+	unsigned int code;
+
+	const struct sieve_operand_class *class;
+	const void *interface;
+};
+
+struct sieve_operand {
+	const struct sieve_operand_def *def;
+	const struct sieve_extension *ext;
+	sieve_size_t address;
+};
+
+#define sieve_operand_name(opr) \
+	( (opr)->def == NULL ? "(NULL)" : (opr)->def->name )
+#define sieve_operand_is(opr, definition) \
+	( (opr)->def == &(definition) )
+
+sieve_size_t sieve_operand_emit
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		const struct sieve_operand_def *oprnd);
+bool sieve_operand_read
+	(struct sieve_binary *sbin, sieve_size_t *address,
+		struct sieve_operand *oprnd);
+
+bool sieve_operand_optional_present
+	(struct sieve_binary *sbin, sieve_size_t *address);
+bool sieve_operand_optional_read
+	(struct sieve_binary *sbin, sieve_size_t *address,
+		signed int *id_code);
+
+/*
+ * Core operands
+ */
+
+/* Operand codes */
+
+enum sieve_core_operand {
+	SIEVE_OPERAND_OPTIONAL = 0x00,
+	SIEVE_OPERAND_NUMBER,
+	SIEVE_OPERAND_STRING,
+	SIEVE_OPERAND_STRING_LIST,
+	SIEVE_OPERAND_COMPARATOR,
+	SIEVE_OPERAND_MATCH_TYPE,
+	SIEVE_OPERAND_ADDRESS_PART,
+	SIEVE_OPERAND_CATENATED_STRING,
+
+	SIEVE_OPERAND_CUSTOM
+};
+
+/* Operand classes */
+
+extern const struct sieve_operand_class number_class;
+extern const struct sieve_operand_class string_class;
+extern const struct sieve_operand_class stringlist_class;
+
+/* Operand objects */
+
+extern const struct sieve_operand_def omitted_operand;
+extern const struct sieve_operand_def number_operand;
+extern const struct sieve_operand_def string_operand;
+extern const struct sieve_operand_def stringlist_operand;
+extern const struct sieve_operand_def catenated_string_operand;
+
+extern const struct sieve_operand_def *sieve_operands[];
+extern const unsigned int sieve_operand_count;
+
+/* Operand object interfaces */
+
+struct sieve_opr_number_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	bool (*read)
+	  (const struct sieve_runtime_env *renv, sieve_size_t *address,
+	  	sieve_number_t *number_r);
+};
+
+struct sieve_opr_string_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+			sieve_size_t *address, const char *field_name);
+	bool (*read)
+		(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		 	sieve_size_t *address, string_t **str_r);
+};
+
+struct sieve_opr_stringlist_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	struct sieve_coded_stringlist *(*read)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address);
+};
+
+/*
+ * Core operand functions
+ */
+
+/* Omitted */
+
+void sieve_opr_omitted_emit(struct sieve_binary *sbin);
+
+static inline bool sieve_operand_is_omitted
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->def != NULL &&
+		operand->def == &omitted_operand );
+}
+
+/* Number */
+
+void sieve_opr_number_emit(struct sieve_binary *sbin, sieve_number_t number);
+bool sieve_opr_number_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name);
+bool sieve_opr_number_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+bool sieve_opr_number_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, sieve_number_t *number_r);
+bool sieve_opr_number_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		sieve_number_t *number_r);
+
+static inline bool sieve_operand_is_number
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->def != NULL &&
+		operand->def->class == &number_class );
+}
+
+/* String */
+
+void sieve_opr_string_emit(struct sieve_binary *sbin, string_t *str);
+bool sieve_opr_string_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name);
+bool sieve_opr_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+bool sieve_opr_string_dump_ex
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name, bool *literal_r);
+bool sieve_opr_string_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, string_t **str_r);
+bool sieve_opr_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r);
+bool sieve_opr_string_read_ex
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r,
+		bool *literal_r);
+
+static inline bool sieve_operand_is_string
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->def != NULL &&
+		operand->def->class == &string_class );
+}
+
+/* String list */
+
+void sieve_opr_stringlist_emit_start
+	(struct sieve_binary *sbin, unsigned int listlen, void **context);
+void sieve_opr_stringlist_emit_item
+	(struct sieve_binary *sbin, void *context ATTR_UNUSED, string_t *item);
+void sieve_opr_stringlist_emit_end
+	(struct sieve_binary *sbin, void *context);
+bool sieve_opr_stringlist_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name);
+bool sieve_opr_stringlist_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+struct sieve_coded_stringlist *sieve_opr_stringlist_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address);
+struct sieve_coded_stringlist *sieve_opr_stringlist_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+static inline bool sieve_operand_is_stringlist
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->def != NULL &&
+		(operand->def->class == &stringlist_class ||
+			operand->def->class == &string_class) );
+}
+
+/* Catenated string */
+
+void sieve_opr_catenated_string_emit
+	(struct sieve_binary *sbin, unsigned int elements);
+
+/*
+ * Operation object
+ */
+
+struct sieve_operation_def {
+	const char *mnemonic;
+
+	const struct sieve_extension_def *ext_def;
+	unsigned int code;
+
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+	int (*execute)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address);
+};
+
+struct sieve_operation {
+	const struct sieve_operation_def *def;
+	const struct sieve_extension *ext;
+
+	sieve_size_t address;
+};
+
+#define sieve_operation_is(oprtn, definition) \
+	( (oprtn)->def == &(definition) )
+#define sieve_operation_mnemonic(oprtn) \
+	( (oprtn)->def == NULL ? "(NULL)" : (oprtn)->def->mnemonic )
+
+sieve_size_t sieve_operation_emit
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		const struct sieve_operation_def *op_def);
+bool sieve_operation_read
+	(struct sieve_binary *sbin, sieve_size_t *address,
+		struct sieve_operation *oprtn);
+const char *sieve_operation_read_string
+	(struct sieve_binary *sbin, sieve_size_t *address);
+
+/*
+ * Core operations
+ */
+
+/* Opcodes */
+
+enum sieve_operation_code {
+	SIEVE_OPERATION_INVALID,
+	SIEVE_OPERATION_JMP,
+	SIEVE_OPERATION_JMPTRUE,
+	SIEVE_OPERATION_JMPFALSE,
+
+	SIEVE_OPERATION_STOP,
+	SIEVE_OPERATION_KEEP,
+	SIEVE_OPERATION_DISCARD,
+	SIEVE_OPERATION_REDIRECT,
+
+	SIEVE_OPERATION_ADDRESS,
+	SIEVE_OPERATION_HEADER,
+	SIEVE_OPERATION_EXISTS,
+	SIEVE_OPERATION_SIZE_OVER,
+	SIEVE_OPERATION_SIZE_UNDER,
+
+	SIEVE_OPERATION_CUSTOM
+};
+
+/* Operation objects */
+
+extern const struct sieve_operation_def sieve_jmp_operation;
+extern const struct sieve_operation_def sieve_jmptrue_operation;
+extern const struct sieve_operation_def sieve_jmpfalse_operation;
+
+extern const struct sieve_operation_def *sieve_operations[];
+extern const unsigned int sieve_operations_count;
+
+#endif
Index: b/sieve/src/lib-sieve/sieve-commands.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-commands.c
@@ -0,0 +1,390 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-interpreter.h"
+
+/*
+ * Literal arguments
+ */
+
+/* Forward declarations */
+
+static bool arg_number_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *context);
+static bool arg_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *context);
+static bool arg_string_list_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *context);
+static bool arg_string_list_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *context);
+
+/* Argument objects */
+
+const struct sieve_argument_def number_argument = {
+	"@number",
+	NULL, NULL, NULL, NULL,
+	arg_number_generate
+};
+
+const struct sieve_argument_def string_argument = {
+	"@string",
+	NULL, NULL, NULL, NULL,
+	arg_string_generate
+};
+
+const struct sieve_argument_def string_list_argument = {
+	"@string-list",
+	NULL,
+	arg_string_list_validate,
+	NULL, NULL,
+	arg_string_list_generate
+};
+
+/* Argument implementations */
+
+static bool arg_number_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	sieve_opr_number_emit(cgenv->sbin, sieve_ast_argument_number(arg));
+
+	return TRUE;
+}
+
+static bool arg_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	sieve_opr_string_emit(cgenv->sbin, sieve_ast_argument_str(arg));
+
+	return TRUE;
+}
+
+static bool arg_string_list_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *stritem;
+
+	stritem = sieve_ast_strlist_first(*arg);
+	while ( stritem != NULL ) {
+		if ( !sieve_validator_argument_activate(valdtr, cmd, stritem, FALSE) )
+			return FALSE;
+
+		stritem = sieve_ast_strlist_next(stritem);
+	}
+
+	return TRUE;
+}
+
+static bool emit_string_list_operand
+(const struct sieve_codegen_env *cgenv, const struct sieve_ast_argument *strlist,
+	struct sieve_command *cmd)
+{
+	void *list_context;
+	struct sieve_ast_argument *stritem;
+
+	sieve_opr_stringlist_emit_start
+		(cgenv->sbin, sieve_ast_strlist_count(strlist), &list_context);
+
+	stritem = sieve_ast_strlist_first(strlist);
+	while ( stritem != NULL ) {
+		if ( !sieve_generate_argument(cgenv, stritem, cmd) )
+			return FALSE;
+
+		stritem = sieve_ast_strlist_next(stritem);
+	}
+
+	sieve_opr_stringlist_emit_end(cgenv->sbin, list_context);
+
+	return TRUE;
+}
+
+static bool arg_string_list_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd)
+{
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		return ( sieve_generate_argument(cgenv, arg, cmd) );
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		bool result = TRUE;
+
+		if ( sieve_ast_strlist_count(arg) == 1 )
+			return ( sieve_generate_argument
+				(cgenv, sieve_ast_strlist_first(arg), cmd) );
+		else {
+			T_BEGIN {
+				result=emit_string_list_operand(cgenv, arg, cmd);
+			} T_END;
+		}
+
+		return result;
+	}
+
+	return FALSE;
+}
+
+/*
+ * Abstract arguments
+ *
+ *   (Generated by processing and not by parsing the grammar)
+ */
+
+/* Catenated string */
+
+struct sieve_arg_catenated_string {
+	struct sieve_ast_arg_list *str_parts;
+};
+
+struct sieve_arg_catenated_string *sieve_arg_catenated_string_create
+(struct sieve_ast_argument *orig_arg)
+{
+	pool_t pool = sieve_ast_pool(orig_arg->ast);
+	struct sieve_ast_arg_list *arglist;
+	struct sieve_arg_catenated_string *catstr;
+
+	arglist = sieve_ast_arg_list_create(pool);
+
+	catstr = p_new(pool, struct sieve_arg_catenated_string, 1);
+	catstr->str_parts = arglist;
+	(orig_arg)->argument->data = (void *) catstr;
+
+	return catstr;
+}
+
+void sieve_arg_catenated_string_add_element
+(struct sieve_arg_catenated_string *catstr,
+	struct sieve_ast_argument *element)
+{
+	sieve_ast_arg_list_add(catstr->str_parts, element);
+}
+
+#define _cat_string_first(catstr) __AST_LIST_FIRST((catstr)->str_parts)
+#define _cat_string_count(catstr) __AST_LIST_COUNT((catstr)->str_parts)
+#define _cat_string_next(item) __AST_LIST_NEXT(item)
+
+bool sieve_arg_catenated_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_arg_catenated_string *catstr =
+		(struct sieve_arg_catenated_string *) arg->argument->data;
+	struct sieve_ast_argument *strpart;
+
+	if ( _cat_string_count(catstr) == 1 )
+		sieve_generate_argument(cgenv, _cat_string_first(catstr), cmd);
+	else {
+		sieve_opr_catenated_string_emit(sbin, _cat_string_count(catstr));
+
+		strpart = _cat_string_first(catstr);
+		while ( strpart != NULL ) {
+			if ( !sieve_generate_argument(cgenv, strpart, cmd) )
+				return FALSE;
+
+			strpart = _cat_string_next(strpart);
+		}
+	}
+
+	return TRUE;
+}
+
+/*
+ * Argument creation
+ */
+
+struct sieve_argument *sieve_argument_create
+(struct sieve_ast *ast, const struct sieve_argument_def *def,
+	const struct sieve_extension *ext, int id_code)
+{
+	struct sieve_argument *arg;
+	pool_t pool;
+
+	pool = sieve_ast_pool(ast);
+	arg = p_new(pool, struct sieve_argument, 1);
+	arg->def = def;
+	arg->ext = ext;
+	arg->id_code = id_code;
+
+	return arg;
+}
+
+/*
+ * Core tests and commands
+ */
+
+const struct sieve_command_def *sieve_core_tests[] = {
+	&tst_false, &tst_true,
+	&tst_not, &tst_anyof, &tst_allof,
+	&tst_address, &tst_header, &tst_exists, &tst_size
+};
+
+const unsigned int sieve_core_tests_count = N_ELEMENTS(sieve_core_tests);
+
+const struct sieve_command_def *sieve_core_commands[] = {
+	&cmd_require,
+	&cmd_stop, &cmd_if, &cmd_elsif, &cmd_else,
+	&cmd_keep, &cmd_discard, &cmd_redirect
+};
+
+const unsigned int sieve_core_commands_count = N_ELEMENTS(sieve_core_commands);
+
+/*
+ * Command context
+ */
+
+struct sieve_command *sieve_command_prev
+(struct sieve_command *cmd)
+{
+	struct sieve_ast_node *node = sieve_ast_node_prev(cmd->ast_node);
+
+	if ( node != NULL ) {
+		return node->command;
+	}
+
+	return NULL;
+}
+
+struct sieve_command *sieve_command_parent
+(struct sieve_command *cmd)
+{
+	struct sieve_ast_node *node = sieve_ast_node_parent(cmd->ast_node);
+
+	return ( node != NULL ? node->command : NULL );
+}
+
+struct sieve_command *sieve_command_create
+(struct sieve_ast_node *cmd_node, const struct sieve_extension *ext,
+	const struct sieve_command_def *cmd_def,
+	struct sieve_command_registration *cmd_reg)
+{
+	struct sieve_command *cmd;
+
+	cmd = p_new(sieve_ast_node_pool(cmd_node), struct sieve_command, 1);
+
+	cmd->ast_node = cmd_node;
+	cmd->def = cmd_def;
+	cmd->ext = ext;
+	cmd->reg = cmd_reg;
+
+	cmd->block_exit_command = NULL;
+
+	return cmd;
+}
+
+const char *sieve_command_def_type_name
+(const struct sieve_command_def *cmd_def)
+{
+	switch ( cmd_def->type ) {
+	case SCT_NONE: return "command of unspecified type (bug)";
+	case SCT_TEST: return "test";
+	case SCT_COMMAND: return "command";
+	default:
+		break;
+	}
+	return "??COMMAND-TYPE??";
+}
+
+struct sieve_ast_argument *sieve_command_add_dynamic_tag
+(struct sieve_command *cmd, const struct sieve_extension *ext,
+	const struct sieve_argument_def *tag, int id_code)
+{
+	struct sieve_ast_argument *arg;
+
+	if ( cmd->first_positional != NULL )
+		arg = sieve_ast_argument_tag_insert
+			(cmd->first_positional, tag->identifier, cmd->ast_node->source_line);
+	else
+		arg = sieve_ast_argument_tag_create
+			(cmd->ast_node, tag->identifier, cmd->ast_node->source_line);
+
+	arg->argument = sieve_argument_create(cmd->ast_node->ast, tag, ext, id_code);
+
+	return arg;
+}
+
+struct sieve_ast_argument *sieve_command_find_argument
+(struct sieve_command *cmd, const struct sieve_argument_def *arg_def)
+{
+	struct sieve_ast_argument *arg = sieve_ast_argument_first(cmd->ast_node);
+
+	/* Visit tagged and optional arguments */
+	while ( arg != NULL ) {
+		if ( arg->argument != NULL && arg->argument->def == arg_def )
+			return arg;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	return arg;
+}
+
+/* Use this function with caution. The command commits to exiting the block.
+ * When it for some reason does not, the interpretation will break later on,
+ * because exiting jumps are not generated when they would otherwise be
+ * necessary.
+ */
+void sieve_command_exit_block_unconditionally
+	(struct sieve_command *cmd)
+{
+	struct sieve_command *parent = sieve_command_parent(cmd);
+
+	/* Only the first unconditional exit is of importance */
+	if ( parent != NULL && parent->block_exit_command == NULL )
+		parent->block_exit_command = cmd;
+}
+
+bool sieve_command_block_exits_unconditionally
+	(struct sieve_command *cmd)
+{
+	return ( cmd->block_exit_command != NULL );
+}
+
+/*
+ * Command utility functions
+ */
+
+/* NOTE: this may be moved */
+
+static int _verify_header_name_item
+(void *context, struct sieve_ast_argument *header)
+{
+	struct sieve_validator *valdtr = (struct sieve_validator *) context;
+	string_t *name = sieve_ast_argument_str(header);
+
+	if ( sieve_argument_is_string_literal(header) &&
+		!rfc2822_header_field_name_verify(str_c(name), str_len(name)) ) {
+		sieve_argument_validate_warning
+			(valdtr, header, "specified header field name '%s' is invalid",
+				str_sanitize(str_c(name), 80));
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_command_verify_headers_argument
+(struct sieve_validator *valdtr, struct sieve_ast_argument *headers)
+{
+	return ( sieve_ast_stringlist_map
+		(&headers, (void *) valdtr, _verify_header_name_item) >= 0 );
+}
Index: b/sieve/src/lib-sieve/sieve-commands.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-commands.h
@@ -0,0 +1,259 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMANDS_H
+#define __SIEVE_COMMANDS_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+
+/*
+ * Argument definition
+ */
+
+struct sieve_argument_def {
+	const char *identifier;
+
+	bool (*is_instance_of)
+		(struct sieve_validator *valdtr, struct sieve_command *cmd,
+			const struct sieve_extension *ext, const char *identifier, void **data);
+
+	bool (*validate)
+		(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+			struct sieve_command *cmd);
+	bool (*validate_context)
+		(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+			struct sieve_command *cmd);
+	bool (*validate_persistent)
+		(struct sieve_validator *valdtr, struct sieve_command *cmd,
+			const struct sieve_extension *ext);
+
+	bool (*generate)
+		(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+			struct sieve_command *cmd);
+};
+
+/*
+ * Argument instance
+ */
+
+struct sieve_argument {
+	const struct sieve_argument_def *def;
+	const struct sieve_extension *ext;
+	int id_code;
+
+	/* Context data */
+	void *data;
+};
+
+#define sieve_argument_is(ast_arg, definition) \
+	( (ast_arg)->argument->def == &(definition) )
+#define sieve_argument_ext(ast_arg) \
+	( (ast_arg)->argument->ext )
+
+/* Utility macros */
+
+#define sieve_argument_is_string_literal(arg) \
+	( (arg)->argument->def == &string_argument )
+
+/* Error handling */
+
+#define sieve_argument_validate_error(validator, arg_node, ...) \
+	sieve_validator_error(validator, (arg_node)->source_line, __VA_ARGS__)
+#define sieve_argument_validate_warning(validator, arg_node, ...) \
+	sieve_validator_warning(validator, (arg_node)->source_line, __VA_ARGS__)
+
+/* Argument API */
+
+struct sieve_argument *sieve_argument_create
+	(struct sieve_ast *ast, const struct sieve_argument_def *def,
+		const struct sieve_extension *ext, int id_code);
+
+/* Literal arguments */
+
+extern const struct sieve_argument_def number_argument;
+extern const struct sieve_argument_def string_argument;
+extern const struct sieve_argument_def string_list_argument;
+
+/* Catenated string argument */
+
+bool sieve_arg_catenated_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *context);
+
+struct sieve_arg_catenated_string;
+
+struct sieve_arg_catenated_string *sieve_arg_catenated_string_create
+	(struct sieve_ast_argument *orig_arg);
+void sieve_arg_catenated_string_add_element
+	(struct sieve_arg_catenated_string *strdata,
+		struct sieve_ast_argument *element);
+
+/*
+ * Command definition
+ */
+
+enum sieve_command_type {
+	SCT_NONE,
+	SCT_COMMAND,
+	SCT_TEST,
+	SCT_HYBRID
+};
+
+struct sieve_command_def {
+	const char *identifier;
+	enum sieve_command_type type;
+
+	/* High-level command syntax */
+	int positional_arguments;
+	int subtests;
+	bool block_allowed;
+	bool block_required;
+
+	bool (*registered)
+		(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+			struct sieve_command_registration *cmd_reg);
+	bool (*pre_validate)
+		(struct sieve_validator *valdtr, struct sieve_command *cmd);
+	bool (*validate)
+		(struct sieve_validator *valdtr, struct sieve_command *cmd);
+	bool (*generate)
+		(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+	bool (*control_generate)
+		(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+};
+
+/*
+ * Command instance
+ */
+
+struct sieve_command {
+	const struct sieve_command_def *def;
+	const struct sieve_extension *ext;
+
+	/* The registration of this command in the validator (sieve-validator.h) */
+	struct sieve_command_registration *reg;
+
+	/* The ast node of this command */
+	struct sieve_ast_node *ast_node;
+
+	/* First positional argument, found during argument validation */
+	struct sieve_ast_argument *first_positional;
+
+	/* The child ast node that unconditionally exits this command's block */
+	struct sieve_command *block_exit_command;
+
+	/* Context data*/
+	void *data;
+};
+
+#define sieve_command_is(cmd, definition) \
+	( (cmd)->def == &(definition) )
+#define sieve_command_identifier(cmd) \
+	( (cmd)->def->identifier )
+#define sieve_command_type_name(cmd) \
+	( sieve_command_def_type_name((cmd)->def) )
+
+#define sieve_commands_equal(cmd1, cmd2) \
+	( (cmd1)->def == (cmd2)->def )
+
+/* Context API */
+
+struct sieve_command *sieve_command_create
+	(struct sieve_ast_node *cmd_node, const struct sieve_extension *ext,
+		const struct sieve_command_def *cmd_def,
+		struct sieve_command_registration *cmd_reg);
+
+const char *sieve_command_def_type_name
+	(const struct sieve_command_def *cmd_def);
+
+struct sieve_command *sieve_command_prev
+	(struct sieve_command *cmd);
+struct sieve_command *sieve_command_parent
+	(struct sieve_command *cmd);
+
+struct sieve_ast_argument *sieve_command_add_dynamic_tag
+	(struct sieve_command *cmd, const struct sieve_extension *ext,
+		const struct sieve_argument_def *tag, int id_code);
+struct sieve_ast_argument *sieve_command_find_argument
+	(struct sieve_command *cmd, const struct sieve_argument_def *argument);
+
+void sieve_command_exit_block_unconditionally
+	(struct sieve_command *cmd);
+bool sieve_command_block_exits_unconditionally
+	(struct sieve_command *cmd);
+
+/* Error handling */
+
+#define sieve_command_validate_error(validator, context, ...) \
+	sieve_validator_error(validator, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_validate_warning(validator, context, ...) \
+	sieve_validator_warning(validator, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_validate_critical(validator, context, ...) \
+	sieve_validator_critical(validator, (context)->ast_node->source_line, __VA_ARGS__)
+
+#define sieve_command_generate_error(gentr, context, ...) \
+	sieve_generator_error(gentr, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_generate_critical(gentr, context, ...) \
+	sieve_generator_critical(gentr, (context)->ast_node->source_line, __VA_ARGS__)
+
+/* Utility macros */
+
+#define sieve_command_pool(context) \
+	sieve_ast_node_pool((context)->ast_node)
+
+#define sieve_command_source_line(context) \
+	(context)->ast_node->source_line
+
+#define sieve_command_first_argument(context) \
+	sieve_ast_argument_first((context)->ast_node)
+
+#define sieve_command_is_toplevel(context) \
+	( sieve_ast_node_type(sieve_ast_node_parent((context)->ast_node)) == SAT_ROOT )
+#define sieve_command_is_first(context) \
+	( sieve_ast_node_prev((context)->ast_node) == NULL )
+
+/*
+ * Core commands
+ */
+
+extern const struct sieve_command_def cmd_require;
+extern const struct sieve_command_def cmd_stop;
+extern const struct sieve_command_def cmd_if;
+extern const struct sieve_command_def cmd_elsif;
+extern const struct sieve_command_def cmd_else;
+extern const struct sieve_command_def cmd_redirect;
+extern const struct sieve_command_def cmd_keep;
+extern const struct sieve_command_def cmd_discard;
+
+extern const struct sieve_command_def *sieve_core_commands[];
+extern const unsigned int sieve_core_commands_count;
+
+/*
+ * Core tests
+ */
+
+extern const struct sieve_command_def tst_true;
+extern const struct sieve_command_def tst_false;
+extern const struct sieve_command_def tst_not;
+extern const struct sieve_command_def tst_anyof;
+extern const struct sieve_command_def tst_allof;
+extern const struct sieve_command_def tst_address;
+extern const struct sieve_command_def tst_header;
+extern const struct sieve_command_def tst_exists;
+extern const struct sieve_command_def tst_size;
+
+extern const struct sieve_command_def *sieve_core_tests[];
+extern const unsigned int sieve_core_tests_count;
+
+/*
+ * Command utility functions
+ */
+
+bool sieve_command_verify_headers_argument
+(struct sieve_validator *valdtr, struct sieve_ast_argument *headers);
+
+#endif /* __SIEVE_COMMANDS_H */
Index: b/sieve/src/lib-sieve/sieve-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-common.h
@@ -0,0 +1,154 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMON_H
+#define __SIEVE_COMMON_H
+
+#include "lib.h"
+
+#include "sieve-config.h"
+#include "sieve-types.h"
+
+#include <sys/types.h>
+#include <stdlib.h>
+
+/*
+ * Types
+ */
+
+typedef size_t sieve_size_t;
+typedef uint32_t sieve_offset_t;
+typedef uint32_t sieve_number_t;
+
+#define SIEVE_MAX_NUMBER ((sieve_number_t) -1)
+
+/*
+ * Forward declarations
+ */
+
+/* sieve-error.h */
+struct sieve_error_handler;
+
+/* sieve-ast.h */
+enum sieve_ast_argument_type;
+
+struct sieve_ast;
+struct sieve_ast_node;
+struct sieve_ast_argument;
+
+/* sieve-commands.h */
+struct sieve_argument;
+struct sieve_argument_def;
+struct sieve_command;
+struct sieve_command_def;
+struct sieve_command_context;
+struct sieve_command_registration;
+
+/* sieve-code.h */
+struct sieve_operation_extension;
+
+/* sieve-lexer.h */
+struct sieve_lexer;
+
+/* sieve-parser.h */
+struct sieve_parser;
+
+/* sieve-validator.h */
+struct sieve_validator;
+
+/* sieve-generator.h */
+struct sieve_jumplist;
+struct sieve_generator;
+struct sieve_codegen_env;
+
+/* sieve-interpreter.h */
+struct sieve_runtime_env;
+struct sieve_interpreter;
+
+/* sieve-binary-dumper.h */
+struct sieve_dumptime_env;
+struct sieve_binary_dumper;
+
+/* sieve-code-dumper.h */
+struct sieve_code_dumper;
+
+/* sieve-extension.h */
+struct sieve_extension;
+struct sieve_extension_def;
+struct sieve_extension_objects;
+
+/* sieve-code.h */
+struct sieve_operand;
+struct sieve_operand_def;
+struct sieve_operand_class;
+struct sieve_operation;
+struct sieve_coded_stringlist;
+
+/* sieve-binary.h */
+struct sieve_binary;
+
+/* sieve-objects.h */
+struct sieve_object_def;
+struct sieve_object;
+
+/* sieve-comparator.h */
+struct sieve_comparator;
+
+/* sieve-match-types.h */
+struct sieve_match_type;
+
+/* sieve-match.h */
+struct sieve_match_context;
+
+/* sieve-address.h */
+struct sieve_address;
+
+/* sieve-address-parts.h */
+struct sieve_address_part_def;
+struct sieve_address_part;
+
+/* sieve-result.h */
+struct sieve_result;
+struct sieve_side_effects_list;
+struct sieve_result_print_env;
+
+/* sieve-actions.h */
+struct sieve_action_exec_env;
+struct sieve_action;
+struct sieve_action_def;
+struct sieve_side_effect;
+struct sieve_side_effect_def;
+
+/* sieve-script.h */
+struct sieve_script;
+
+/* sieve-message.h */
+struct sieve_message_context;
+
+/* sieve.c */
+struct sieve_ast *sieve_parse
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+bool sieve_validate
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+
+/*
+ * Sieve engine instance
+ */
+
+struct sieve_instance {
+	/* Main engine pool */
+	pool_t pool;
+
+	/* Callbacks */
+	const struct sieve_callbacks *callbacks;
+	void *context;
+
+	/* Extension registry */
+	struct sieve_extension_registry *ext_reg;
+
+	/* Limits */
+	unsigned int max_actions;
+	unsigned int max_redirects;
+};
+
+#endif /* __SIEVE_COMMON_H */
Index: b/sieve/src/lib-sieve/sieve-comparators.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-comparators.c
@@ -0,0 +1,272 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Core comparators
+ */
+
+const struct sieve_comparator_def *sieve_core_comparators[] = {
+	&i_octet_comparator, &i_ascii_casemap_comparator
+};
+
+const unsigned int sieve_core_comparators_count =
+	N_ELEMENTS(sieve_core_comparators);
+
+/*
+ * Comparator 'extension'
+ */
+
+static bool cmp_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def comparator_extension = {
+	"@comparators",
+	NULL, NULL,
+	cmp_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS    /* Defined as core operand */
+};
+
+/*
+ * Validator context:
+ *   name-based comparator registry.
+ */
+
+static struct sieve_validator_object_registry *_get_object_registry
+(struct sieve_validator *valdtr)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *mcht_ext;
+
+	svinst = sieve_validator_svinst(valdtr);
+	mcht_ext = sieve_get_comparator_extension(svinst);
+	return sieve_validator_object_registry_get(valdtr, mcht_ext);
+}
+
+void sieve_comparator_register
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct sieve_comparator_def *cmp)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+
+	sieve_validator_object_registry_add(regs, ext, &cmp->obj_def);
+}
+
+static struct sieve_comparator *sieve_comparator_create
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const char *identifier)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+	struct sieve_object object;
+	struct sieve_comparator *cmp;
+
+	if ( !sieve_validator_object_registry_find(regs, identifier, &object) )
+		return NULL;
+
+	cmp = p_new(sieve_command_pool(cmd), struct sieve_comparator, 1);
+	cmp->object = object;
+	cmp->def = (const struct sieve_comparator_def *) object.def;
+
+  return cmp;
+}
+
+bool cmp_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	struct sieve_validator_object_registry *regs =
+		sieve_validator_object_registry_init(valdtr, ext);
+	unsigned int i;
+
+	/* Register core comparators */
+	for ( i = 0; i < sieve_core_comparators_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, NULL, &(sieve_core_comparators[i]->obj_def));
+	}
+
+	return TRUE;
+}
+
+/*
+ * Comparator tagged argument
+ */
+
+/* Forward declarations */
+
+static bool tag_comparator_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_comparator_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+/* Argument object */
+
+const struct sieve_argument_def comparator_tag = {
+	"comparator",
+	NULL,
+	tag_comparator_validate,
+	NULL, NULL,
+	tag_comparator_generate
+};
+
+/* Argument implementation */
+
+static bool tag_comparator_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	const struct sieve_comparator *cmp;
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	/* Check syntax:
+	 *   ":comparator" <comparator-name: string>
+	 */
+	if ( (*arg)->type != SAAT_STRING ) {
+		sieve_argument_validate_error(valdtr, *arg,
+			":comparator tag requires one string argument, but %s was found",
+			sieve_ast_argument_name(*arg) );
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, *arg, FALSE) )
+		return FALSE;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(*arg) ) {
+		sieve_argument_validate_error(valdtr, *arg,
+			"this Sieve implementation currently only supports "
+			"a literal string argument for the :comparator tag");
+		return FALSE;
+	}
+
+	/* Get comparator from registry */
+	cmp = sieve_comparator_create(valdtr, cmd, sieve_ast_argument_strc(*arg));
+
+	if ( cmp == NULL ) {
+		sieve_argument_validate_error(valdtr, *arg,
+			"unknown comparator '%s'",
+			str_sanitize(sieve_ast_argument_strc(*arg),80));
+
+		return FALSE;
+	}
+
+	/* String argument not needed during code generation, so detach it from
+	 * argument list
+	 */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Store comparator in context */
+	tag->argument->data = (void *) cmp;
+
+	return TRUE;
+}
+
+static bool tag_comparator_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp =
+		(const struct sieve_comparator *) arg->argument->data;
+
+	sieve_opr_comparator_emit(cgenv->sbin, cmp);
+
+	return TRUE;
+}
+
+/* Functions to enable and evaluate comparator tag for commands */
+
+void sieve_comparators_link_tag
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	int id_code)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *mcht_ext;
+
+	svinst = sieve_validator_svinst(valdtr);
+	mcht_ext = sieve_get_comparator_extension(svinst);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, mcht_ext, &comparator_tag, id_code);
+}
+
+bool sieve_comparator_tag_is
+(struct sieve_ast_argument *tag, const struct sieve_comparator_def *cmp_def)
+{
+	const struct sieve_comparator *cmp;
+
+	if ( !sieve_argument_is(tag, comparator_tag) )
+		return FALSE;
+
+	cmp = (const struct sieve_comparator *) tag->argument->data;
+
+	return ( cmp->def == cmp_def );
+}
+
+const struct sieve_comparator *sieve_comparator_tag_get
+(struct sieve_ast_argument *tag)
+{
+	if ( !sieve_argument_is(tag, comparator_tag) )
+		return NULL;
+
+
+	return (const struct sieve_comparator *) tag->argument->data;
+}
+
+/*
+ * Comparator coding
+ */
+
+const struct sieve_operand_class sieve_comparator_operand_class =
+	{ "comparator" };
+
+static const struct sieve_extension_objects core_comparators =
+	SIEVE_EXT_DEFINE_COMPARATORS(sieve_core_comparators);
+
+const struct sieve_operand_def comparator_operand = {
+	"comparator",
+	NULL,
+	SIEVE_OPERAND_COMPARATOR,
+	&sieve_comparator_operand_class,
+	&core_comparators
+};
+
+/*
+ * Trivial/Common comparator method implementations
+ */
+
+bool sieve_comparator_octet_skip
+	(const struct sieve_comparator *cmp ATTR_UNUSED,
+		const char **val, const char *val_end)
+{
+	if ( *val < val_end ) {
+		(*val)++;
+		return TRUE;
+	}
+
+	return FALSE;
+}
Index: b/sieve/src/lib-sieve/sieve-comparators.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-comparators.h
@@ -0,0 +1,154 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMPARATORS_H
+#define __SIEVE_COMPARATORS_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-objects.h"
+#include "sieve-code.h"
+
+/*
+ * Core comparators
+ */
+
+enum sieve_comparator_code {
+	SIEVE_COMPARATOR_I_OCTET,
+	SIEVE_COMPARATOR_I_ASCII_CASEMAP,
+	SIEVE_COMPARATOR_CUSTOM
+};
+
+extern const struct sieve_comparator_def i_octet_comparator;
+extern const struct sieve_comparator_def i_ascii_casemap_comparator;
+
+/*
+ * Comparator flags
+ */
+
+enum sieve_comparator_flags {
+	SIEVE_COMPARATOR_FLAG_ORDERING = (1 << 0),
+	SIEVE_COMPARATOR_FLAG_EQUALITY = (1 << 1),
+	SIEVE_COMPARATOR_FLAG_PREFIX_MATCH = (1 << 2),
+	SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH = (1 << 3),
+};
+
+/*
+ * Comparator definition
+ */
+
+struct sieve_comparator_def {
+	struct sieve_object_def obj_def;
+
+	unsigned int flags;
+
+	/* Equality and ordering */
+
+	int (*compare)(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size,
+		const char *val2, size_t val2_size);
+
+	/* Prefix and substring match */
+
+	bool (*char_match)(const struct sieve_comparator *cmp,
+		const char **val, const char *val_end,
+		const char **key, const char *key_end);
+	bool (*char_skip)(const struct sieve_comparator *cmp,
+		const char **val, const char *val_end);
+};
+
+/*
+ * Comparator instance
+ */
+
+struct sieve_comparator {
+	struct sieve_object object;
+
+	const struct sieve_comparator_def *def;
+};
+
+#define SIEVE_COMPARATOR_DEFAULT(definition) \
+	{ SIEVE_OBJECT_DEFAULT(definition), &(definition) }
+
+#define sieve_comparator_is(cmp, definition) \
+	( (cmp)->def == &(definition) )
+
+static inline const struct sieve_comparator *sieve_comparator_copy
+(pool_t pool, const struct sieve_comparator *cmp_orig)
+{
+	struct sieve_comparator *cmp = p_new(pool, struct sieve_comparator, 1);
+
+	*cmp = *cmp_orig;
+
+	return cmp;
+}
+
+/*
+ * Comparator tagged argument
+ */
+
+extern const struct sieve_argument_def comparator_tag;
+
+static inline bool sieve_argument_is_comparator
+	(struct sieve_ast_argument *arg)
+{
+	return arg->argument->def == &comparator_tag;
+}
+
+void sieve_comparators_link_tag
+	(struct sieve_validator *validator,
+		struct sieve_command_registration *cmd_reg,	int id_code);
+bool sieve_comparator_tag_is
+	(struct sieve_ast_argument *tag, const struct sieve_comparator_def *cmp);
+const struct sieve_comparator *sieve_comparator_tag_get
+	(struct sieve_ast_argument *tag);
+
+void sieve_comparator_register
+	(struct sieve_validator *validator, const struct sieve_extension *ext,
+		const struct sieve_comparator_def *cmp);
+
+/*
+ * Comparator operand
+ */
+
+#define SIEVE_EXT_DEFINE_COMPARATOR(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_COMPARATORS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+extern const struct sieve_operand_class sieve_comparator_operand_class;
+extern const struct sieve_operand_def comparator_operand;
+
+static inline void sieve_opr_comparator_emit
+(struct sieve_binary *sbin, const struct sieve_comparator *cmp)
+{
+	sieve_opr_object_emit(sbin, cmp->object.ext, cmp->object.def);
+}
+
+static inline bool sieve_opr_comparator_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_comparator *cmp)
+{
+	if ( !sieve_opr_object_read
+		(renv, &sieve_comparator_operand_class, address, &cmp->object) )
+		return FALSE;
+
+	cmp->def = (const struct sieve_comparator_def *) cmp->object.def;
+	return TRUE;
+}
+
+static inline bool sieve_opr_comparator_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_comparator_operand_class, address, NULL);
+}
+
+/*
+ * Trivial/Common comparator method implementations
+ */
+
+bool sieve_comparator_octet_skip
+	(const struct sieve_comparator *cmp ATTR_UNUSED,
+		const char **val, const char *val_end);
+
+#endif /* __SIEVE_COMPARATORS_H */
Index: b/sieve/src/lib-sieve/sieve-config.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-config.h
@@ -0,0 +1,11 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_CONFIG_H
+#define __SIEVE_CONFIG_H
+
+#include "dsieve-config.h"
+
+#define SIEVE_IMPLEMENTATION SIEVE_NAME " " SIEVE_VERSION
+
+#endif
Index: b/sieve/src/lib-sieve/sieve-dump.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-dump.h
@@ -0,0 +1,30 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_DUMP_H
+#define __SIEVE_DUMP_H
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-binary-dumper.h"
+#include "sieve-code-dumper.h"
+
+/*
+ * Dumptime environment
+ */
+
+struct sieve_dumptime_env {
+	struct sieve_binary_dumper *dumper;
+	struct sieve_code_dumper *cdumper;
+
+	struct sieve_instance *svinst;
+
+	struct sieve_binary *sbin;
+
+	struct sieve_operation oprtn;
+
+	struct ostream *stream;
+};
+
+#endif /* __SIEVE_DUMP_H */
Index: b/sieve/src/lib-sieve/sieve-error-private.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-error-private.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_PRIVATE_H
+#define __SIEVE_ERROR_PRIVATE_H
+
+#include "sieve-error.h"
+
+/*
+ * Error handler object
+ */
+
+struct sieve_error_handler {
+	pool_t pool;
+	int refcount;
+
+	unsigned int max_errors;
+
+	unsigned int errors;
+	unsigned int warnings;
+
+	/* Should we copy log to i_error, i_warning and i_info? */
+	bool log_master;
+
+	/* Should the errorhandler handle or discard info log?
+	 * (This does not influence the previous setting)
+	 */
+	bool log_info;
+
+	void (*verror)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vwarning)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vinfo)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+
+	void (*free)
+		(struct sieve_error_handler *ehandler);
+};
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors);
+
+#endif /* __SIEVE_ERROR_PRIVATE_H */
Index: b/sieve/src/lib-sieve/sieve-error.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-error.c
@@ -0,0 +1,747 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+#include "eacces-error.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error-private.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Definitions
+ */
+
+#define CRITICAL_MSG \
+	"internal error occurred: refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+/* Logfile error handler will rotate log when it exceeds 10k bytes */
+#define LOGFILE_MAX_SIZE (10 * 1024)
+
+/*
+ * Utility
+ */
+
+const char *sieve_error_script_location
+(const struct sieve_script *script, unsigned int source_line)
+{
+    const char *sname;
+
+	sname = ( script == NULL ? NULL : sieve_script_name(script) );
+
+    if ( sname == NULL || *sname == '\0' )
+        return t_strdup_printf("line %d", source_line);
+
+    return t_strdup_printf("%s: line %d", sname, source_line);
+}
+
+/*
+ * Main error functions
+ */
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_error("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	if ( sieve_errors_more_allowed(ehandler) ) {
+		if ( ehandler->verror != NULL )
+			ehandler->verror(ehandler, location, fmt, args);
+
+		if ( ehandler->pool != NULL )
+			ehandler->errors++;
+	}
+}
+
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_warning("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_warning("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	if ( ehandler->vwarning != NULL )
+		ehandler->vwarning(ehandler, location, fmt, args);
+
+	if ( ehandler->pool != NULL )
+		ehandler->warnings++;
+}
+
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_info("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_info("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	if ( ehandler->log_info && ehandler->vinfo != NULL )
+		ehandler->vinfo(ehandler, location, fmt, args);
+}
+
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args)
+{
+	char str[256];
+	struct tm *tm;
+
+	tm = localtime(&ioloop_time);
+
+	if ( location == NULL || *location == '\0' )
+		sieve_sys_error("%s", t_strdup_vprintf(fmt, args));
+	else
+		sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args));
+
+	if ( ehandler == NULL ) return;
+
+	sieve_error(ehandler, location, "%s",
+		strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+			str : CRITICAL_MSG );
+}
+
+void sieve_error
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN { sieve_verror(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN { sieve_vwarning(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+void sieve_info
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN { sieve_vinfo(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN { sieve_vcritical(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+/*
+ * Error statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return 0;
+
+	return ehandler->errors;
+}
+
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return 0;
+
+	return ehandler->errors;
+}
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL )
+		return TRUE;
+
+	return ehandler->max_errors == 0 || ehandler->errors < ehandler->max_errors;
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_info = enable;
+}
+
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_master = enable;
+}
+
+/*
+ * Error handler init
+ */
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors)
+{
+	ehandler->pool = pool;
+	ehandler->refcount = 1;
+	ehandler->max_errors = max_errors;
+
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return;
+
+	ehandler->refcount++;
+}
+
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler)
+{
+	if ( *ehandler == NULL || (*ehandler)->pool == NULL ) return;
+
+	i_assert((*ehandler)->refcount > 0);
+
+	if (--(*ehandler)->refcount != 0)
+        	return;
+
+	if ( (*ehandler)->free != NULL )
+		(*ehandler)->free(*ehandler);
+
+	pool_unref(&((*ehandler)->pool));
+
+	*ehandler = NULL;
+}
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return;
+
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+/*
+ * Master/System error handler
+ *
+ * - Output errors directly to Dovecot master log
+ */
+
+static void sieve_master_verror
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, va_list args)
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_error("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_error("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_master_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_warning("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_warning("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_master_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_info("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_info("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_master_ehandler_create
+(unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("master_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_master_verror;
+	ehandler->vwarning = sieve_master_vwarning;
+	ehandler->vinfo = sieve_master_vinfo;
+
+	return ehandler;
+}
+
+struct sieve_error_handler _sieve_system_ehandler_object = {
+	NULL, 0, 0, 0, 0,
+	FALSE,
+	TRUE,
+	sieve_master_verror,
+	sieve_master_vwarning,
+	sieve_master_vinfo,
+	NULL
+};
+
+struct sieve_error_handler *_sieve_system_ehandler = &_sieve_system_ehandler_object;
+
+void sieve_system_ehandler_set(struct sieve_error_handler *ehandler)
+{
+	sieve_error_handler_unref(&_sieve_system_ehandler);
+	_sieve_system_ehandler = ehandler;
+	sieve_error_handler_ref(_sieve_system_ehandler);
+}
+
+void sieve_system_ehandler_reset(void)
+{
+	sieve_error_handler_unref(&_sieve_system_ehandler);
+	_sieve_system_ehandler = &_sieve_system_ehandler_object;
+}
+
+/*
+ * STDERR error handler
+ *
+ * - Output errors directly to stderror
+ */
+
+static void sieve_stderr_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "error: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: error: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "warning: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: warning: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "info: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: info: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_stderr_ehandler_create
+(unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("stderr_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_stderr_verror;
+	ehandler->vwarning = sieve_stderr_vwarning;
+	ehandler->vinfo = sieve_stderr_vinfo;
+
+	return ehandler;
+}
+
+/* String buffer error handler
+ *
+ * - Output errors to a string buffer
+ */
+
+struct sieve_strbuf_ehandler {
+	struct sieve_error_handler handler;
+
+	string_t *errors;
+	bool crlf;
+};
+
+static void sieve_strbuf_verror
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_append(handler->errors, "error: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vwarning
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_printfa(handler->errors, "warning: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vinfo
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_printfa(handler->errors, "info: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+(string_t *strbuf, bool crlf, unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_strbuf_ehandler *ehandler;
+
+	pool = pool_alloconly_create("strbuf_error_handler", 256);
+	ehandler = p_new(pool, struct sieve_strbuf_ehandler, 1);
+	ehandler->errors = strbuf;
+
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_strbuf_verror;
+	ehandler->handler.vwarning = sieve_strbuf_vwarning;
+	ehandler->handler.vinfo = sieve_strbuf_vinfo;
+
+	ehandler->crlf = crlf;
+
+	return &(ehandler->handler);
+}
+
+/*
+ * Logfile error handler
+ *
+ * - Output errors to a log file
+ */
+
+struct sieve_logfile_ehandler {
+	struct sieve_error_handler handler;
+
+	const char *logfile;
+	bool started;
+	int fd;
+	struct ostream *stream;
+};
+
+static void sieve_logfile_vprintf
+(struct sieve_logfile_ehandler *ehandler, const char *location,
+	const char *prefix, const char *fmt, va_list args)
+{
+	string_t *outbuf;
+	ssize_t ret = 0, remain;
+	const char *data;
+
+	if ( ehandler->stream == NULL ) return;
+
+	T_BEGIN {
+		outbuf = t_str_new(256);
+		if ( location != NULL && *location != '\0' )
+			str_printfa(outbuf, "%s: ", location);
+		str_printfa(outbuf, "%s: ", prefix);
+		str_vprintfa(outbuf, fmt, args);
+		str_append(outbuf, ".\n");
+
+		remain = str_len(outbuf);
+		data = (const char *) str_data(outbuf);
+
+		while ( remain > 0 ) {
+			if ( (ret=o_stream_send(ehandler->stream, data, remain)) < 0 )
+				break;
+
+			remain -= ret;
+			data += ret;
+		}
+	} T_END;
+
+	if ( ret < 0 ) {
+		sieve_sys_error(
+			"o_stream_send() failed on logfile %s: %m", ehandler->logfile);
+	}
+}
+
+inline static void sieve_logfile_printf
+(struct sieve_logfile_ehandler *ehandler, const char *location, const char *prefix,
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	sieve_logfile_vprintf(ehandler, location, prefix, fmt, args);
+
+	va_end(args);
+}
+
+static void sieve_logfile_start(struct sieve_logfile_ehandler *ehandler)
+{
+	int fd;
+	struct ostream *ostream = NULL;
+	struct stat st;
+	struct tm *tm;
+	char buf[256];
+	time_t now;
+
+	/* Open the logfile */
+
+	fd = open(ehandler->logfile, O_CREAT | O_APPEND | O_WRONLY, 0600);
+	if (fd == -1) {
+		if ( errno == EACCES ) {
+			sieve_sys_error("failed to open logfile (LOGGING TO STDERR): %s",
+				eacces_error_get_creating("open", ehandler->logfile));
+		} else {
+			sieve_sys_error("failed to open logfile (LOGGING TO STDERR): "
+				"open(%s) failed: %m", ehandler->logfile);
+		}
+		fd = STDERR_FILENO;
+	} else {
+		/* fd_close_on_exec(fd, TRUE); Necessary? */
+
+		/* Stat the log file to obtain size information */
+		if ( fstat(fd, &st) != 0 ) {
+			sieve_sys_error("failed to stat logfile (logging to STDERR): "
+				"fstat(fd=%s) failed: %m", ehandler->logfile);
+
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("failed to close logfile after error: "
+					"close(fd=%s) failed: %m", ehandler->logfile);
+			}
+
+			fd = STDERR_FILENO;
+		}
+
+		/* Rotate log when it has grown too large */
+		if ( st.st_size >= LOGFILE_MAX_SIZE ) {
+			const char *rotated;
+
+			/* Close open file */
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("failed to close logfile: close(fd=%s) failed: %m",
+					ehandler->logfile);
+			}
+
+			/* Rotate logfile */
+			rotated = t_strconcat(ehandler->logfile, ".0", NULL);
+			if ( rename(ehandler->logfile, rotated) < 0 ) {
+				sieve_sys_error("failed to rotate logfile: rename(%s, %s) failed: %m",
+					ehandler->logfile, rotated);
+			}
+
+			/* Open clean logfile (overwrites existing if rename() failed earlier) */
+			fd = open(ehandler->logfile, O_CREAT | O_WRONLY | O_TRUNC, 0600);
+			if (fd == -1) {
+				if ( errno == EACCES ) {
+					sieve_sys_error("failed to open logfile (LOGGING TO STDERR): %s",
+						eacces_error_get_creating("open", ehandler->logfile));
+				} else {
+					sieve_sys_error("failed to open logfile (LOGGING TO STDERR): "
+						"open(%s) failed: %m", ehandler->logfile);
+				}
+				fd = STDERR_FILENO;
+			}
+		}
+	}
+
+	ostream = o_stream_create_fd(fd, 0, FALSE);
+	if ( ostream == NULL ) {
+		/* Can't we do anything else in this most awkward situation? */
+		sieve_sys_error("failed to open log stream on open file: "
+			"o_stream_create_fd(fd=%s) failed "
+			"(non-critical messages are not logged!)", ehandler->logfile);
+	}
+
+	ehandler->fd = fd;
+	ehandler->stream = ostream;
+	ehandler->started = TRUE;
+
+	if ( ostream != NULL ) {
+		now = time(NULL);
+		tm = localtime(&now);
+
+		if (strftime(buf, sizeof(buf), "%b %d %H:%M:%S", tm) > 0) {
+			sieve_logfile_printf(ehandler, "sieve", "info",
+				"started log at %s", buf);
+		}
+	}
+}
+
+static void sieve_logfile_verror
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, va_list args)
+{
+	struct sieve_logfile_ehandler *handler =
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);
+
+	sieve_logfile_vprintf(handler, location, "error", fmt, args);
+}
+
+static void sieve_logfile_vwarning
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, va_list args)
+{
+	struct sieve_logfile_ehandler *handler =
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);
+
+	sieve_logfile_vprintf(handler, location, "warning", fmt, args);
+}
+
+static void sieve_logfile_vinfo
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, va_list args)
+{
+	struct sieve_logfile_ehandler *handler =
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);
+
+	sieve_logfile_vprintf(handler, location, "info", fmt, args);
+}
+
+static void sieve_logfile_free
+(struct sieve_error_handler *ehandler)
+{
+	struct sieve_logfile_ehandler *handler =
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( handler->stream != NULL ) {
+		o_stream_destroy(&(handler->stream));
+		if ( handler->fd != STDERR_FILENO ){
+			if ( close(handler->fd) < 0 ) {
+				sieve_sys_error("failed to close logfile: "
+					"close(fd=%s) failed: %m", handler->logfile);
+			}
+		}
+	}
+}
+
+struct sieve_error_handler *sieve_logfile_ehandler_create
+(const char *logfile, unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_logfile_ehandler *ehandler;
+
+	pool = pool_alloconly_create("logfile_error_handler", 256);
+	ehandler = p_new(pool, struct sieve_logfile_ehandler, 1);
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_logfile_verror;
+	ehandler->handler.vwarning = sieve_logfile_vwarning;
+	ehandler->handler.vinfo = sieve_logfile_vinfo;
+	ehandler->handler.free = sieve_logfile_free;
+
+	/* Don't open logfile until something is actually logged.
+	 * Let's not pullute the sieve directory with useless logfiles.
+	 */
+	ehandler->logfile = p_strdup(pool, logfile);
+	ehandler->started = FALSE;
+	ehandler->stream = NULL;
+	ehandler->fd = -1;
+
+	return &(ehandler->handler);
+}
+
Index: b/sieve/src/lib-sieve/sieve-error.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-error.h
@@ -0,0 +1,127 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_H
+#define __SIEVE_ERROR_H
+
+#include "lib.h"
+#include "compat.h"
+
+#include <stdarg.h>
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_script;
+struct sieve_error_handler;
+
+/*
+ * Types
+ */
+
+typedef void (*sieve_error_vfunc_t)
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args);
+typedef void (*sieve_error_func_t)
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/*
+ * System errors
+ */
+
+extern struct sieve_error_handler *_sieve_system_ehandler;
+
+#define sieve_sys_error(...) sieve_error(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+#define sieve_sys_warning(...) sieve_warning(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+#define sieve_sys_info(...) sieve_info(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+
+void sieve_system_ehandler_set(struct sieve_error_handler *ehandler);
+void sieve_system_ehandler_reset(void);
+
+/*
+ * Main error functions
+ */
+
+/* For these functions it is the responsibility of the caller to
+ * manage the datastack.
+ */
+
+const char *sieve_error_script_location
+	(const struct sieve_script *script, unsigned int source_line);
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args);
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args);
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args);
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location,
+		const char *fmt, va_list args);
+
+void sieve_error
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_info
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable);
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable);
+
+/*
+ * Error handler statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler);
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler);
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler);
+
+/*
+ * Error handler object
+ */
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler);
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler);
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler);
+
+/*
+ * Error handlers
+ */
+
+/* Write errors to dovecot master log */
+struct sieve_error_handler *sieve_master_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors to stderr */
+struct sieve_error_handler *sieve_stderr_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors into a string buffer */
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+	(string_t *strbuf, bool crlf, unsigned int max_errors);
+
+/* Write errors to a logfile */
+struct sieve_error_handler *sieve_logfile_ehandler_create
+	(const char *logfile, unsigned int max_errors);
+
+#endif /* __SIEVE_ERROR_H */
Index: b/sieve/src/lib-sieve/sieve-extensions.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-extensions.c
@@ -0,0 +1,622 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+
+/*
+ * Forward declarations
+ */
+
+static void sieve_extension_registry_init(struct sieve_instance *svinst);
+static void sieve_extension_registry_deinit(struct sieve_instance *svinst);
+
+static void sieve_capability_registry_init(struct sieve_instance *svinst);
+static void sieve_capability_registry_deinit(struct sieve_instance *svinst);
+
+/*
+ * Instance global context
+ */
+
+struct sieve_extension_registry {
+	ARRAY_DEFINE(extensions, struct sieve_extension);
+	struct hash_table *extension_index;
+	struct hash_table *capabilities_index;
+
+	/* Core language 'extensions' */
+	const struct sieve_extension *comparator_extension;
+	const struct sieve_extension *match_type_extension;
+	const struct sieve_extension *address_part_extension;
+
+	/* Preloaded extensions */
+	ARRAY_DEFINE(preloaded_extensions, const struct sieve_extension *);
+};
+
+/*
+ * Pre-loaded 'extensions'
+ */
+
+extern const struct sieve_extension_def comparator_extension;
+extern const struct sieve_extension_def match_type_extension;
+extern const struct sieve_extension_def address_part_extension;
+
+/*
+ * Dummy extensions
+ */
+
+/* FIXME: This is stupid. Define a comparator-* extension and be done with it */
+
+static const struct sieve_extension_def comparator_i_octet_extension = {
+	"comparator-i;octet",
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static const struct sieve_extension_def comparator_i_ascii_casemap_extension = {
+	"comparator-i;ascii-casemap",
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/*
+ * Core extensions
+ */
+
+extern const struct sieve_extension_def fileinto_extension;
+extern const struct sieve_extension_def reject_extension;
+extern const struct sieve_extension_def envelope_extension;
+extern const struct sieve_extension_def encoded_character_extension;
+
+/*
+ * Native 'plugin' extensions
+ */
+
+extern const struct sieve_extension_def vacation_extension;
+extern const struct sieve_extension_def subaddress_extension;
+extern const struct sieve_extension_def comparator_i_ascii_numeric_extension;
+extern const struct sieve_extension_def relational_extension;
+extern const struct sieve_extension_def regex_extension;
+extern const struct sieve_extension_def imap4flags_extension;
+extern const struct sieve_extension_def copy_extension;
+extern const struct sieve_extension_def include_extension;
+extern const struct sieve_extension_def body_extension;
+extern const struct sieve_extension_def variables_extension;
+extern const struct sieve_extension_def enotify_extension;
+extern const struct sieve_extension_def environment_extension;
+extern const struct sieve_extension_def mailbox_extension;
+extern const struct sieve_extension_def date_extension;
+
+/*
+ * List of native extensions
+ */
+
+const struct sieve_extension_def *sieve_core_extensions[] = {
+	/* Dummy extensions */
+	&comparator_i_octet_extension, &comparator_i_ascii_casemap_extension,
+
+	/* Core extensions */
+	&fileinto_extension, &reject_extension, &envelope_extension,
+	&encoded_character_extension,
+
+	/* 'Plugins' */
+	&vacation_extension, &subaddress_extension,
+	&comparator_i_ascii_numeric_extension,
+	&relational_extension, &regex_extension, &imap4flags_extension,
+	&copy_extension, &include_extension, &body_extension,
+	&variables_extension, &enotify_extension, &environment_extension,
+	&mailbox_extension, &date_extension
+};
+
+const unsigned int sieve_core_extensions_count =
+	N_ELEMENTS(sieve_core_extensions);
+
+/*
+ * Deprecated extensions
+ */
+
+extern const struct sieve_extension_def imapflags_extension;
+extern const struct sieve_extension_def notify_extension;
+
+const struct sieve_extension_def *sieve_deprecated_extensions[] = {
+	&imapflags_extension,
+	&notify_extension
+};
+
+const unsigned int sieve_deprecated_extensions_count =
+	N_ELEMENTS(sieve_deprecated_extensions);
+
+/*
+ * Unfinished extensions
+ */
+
+#ifdef HAVE_SIEVE_UNFINISHED
+
+extern const struct sieve_extension_def ereject_extension;
+
+const struct sieve_extension_def *sieve_unfinished_extensions[] = {
+	&ereject_extension,
+};
+
+const unsigned int sieve_unfinished_extensions_count =
+	N_ELEMENTS(sieve_unfinished_extensions);
+
+#endif /* HAVE_SIEVE_UNFINISHED */
+
+/*
+ * Extensions init/deinit
+ */
+
+bool sieve_extensions_init(struct sieve_instance *svinst)
+{
+	unsigned int i;
+	struct sieve_extension_registry *ext_reg =
+		p_new(svinst->pool, struct sieve_extension_registry, 1);
+
+	svinst->ext_reg = ext_reg;
+
+	sieve_extension_registry_init(svinst);
+	sieve_capability_registry_init(svinst);
+
+	/* Preloaded 'extensions' */
+	ext_reg->comparator_extension =
+		sieve_extension_register(svinst, &comparator_extension, TRUE);
+	ext_reg->match_type_extension =
+		sieve_extension_register(svinst, &match_type_extension, TRUE);
+	ext_reg->address_part_extension =
+		sieve_extension_register(svinst, &address_part_extension, TRUE);
+
+	p_array_init(&ext_reg->preloaded_extensions, svinst->pool, 5);
+	array_append(&ext_reg->preloaded_extensions,
+		&ext_reg->comparator_extension, 1);
+	array_append(&ext_reg->preloaded_extensions,
+		&ext_reg->match_type_extension, 1);
+	array_append(&ext_reg->preloaded_extensions,
+		&ext_reg->address_part_extension, 1);
+
+	/* Pre-load core extensions */
+	for ( i = 0; i < sieve_core_extensions_count; i++ ) {
+		if ( sieve_extension_register
+			(svinst, sieve_core_extensions[i], TRUE) == NULL )
+			return FALSE;
+	}
+
+	/* Register deprecated extensions */
+	for ( i = 0; i < sieve_deprecated_extensions_count; i++ ) {
+		if ( sieve_extension_register
+			(svinst, sieve_deprecated_extensions[i], FALSE) == NULL )
+			return FALSE;
+	}
+
+#ifdef HAVE_SIEVE_UNFINISHED
+	/* Register unfinished extensions */
+	for ( i = 0; i < sieve_unfinished_extensions_count; i++ ) {
+		if ( sieve_extension_register
+			(svinst, sieve_unfinished_extensions[i], FALSE) == NULL )
+			return FALSE;
+	}
+#endif
+
+	/* More extensions can be added through plugins */
+
+	return TRUE;
+}
+
+void sieve_extensions_deinit(struct sieve_instance *svinst)
+{
+	sieve_extension_registry_deinit(svinst);
+	sieve_capability_registry_deinit(svinst);
+}
+
+/*
+ * Pre-loaded extensions
+ */
+
+const struct sieve_extension *const *sieve_extensions_get_preloaded
+(struct sieve_instance *svinst, unsigned int *count_r)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+
+	return array_get(&ext_reg->preloaded_extensions, count_r);
+}
+
+/*
+ * Extension registry
+ */
+
+static void sieve_extension_registry_init(struct sieve_instance *svinst)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+
+	p_array_init(&ext_reg->extensions, svinst->pool, 30);
+	ext_reg->extension_index = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+static void sieve_extension_registry_deinit(struct sieve_instance *svinst)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	struct hash_iterate_context *itx;
+	void *key;
+	void *value;
+
+	if ( ext_reg->extension_index == NULL ) return;
+
+	itx = hash_table_iterate_init(ext_reg->extension_index);
+	while ( hash_table_iterate(itx, &key, &value) ) {
+		struct sieve_extension *ext = (struct sieve_extension *) value;
+
+		if ( ext->def != NULL && ext->def->unload != NULL )
+			ext->def->unload(ext);
+	}
+
+	hash_table_iterate_deinit(&itx);
+
+	hash_table_destroy(&ext_reg->extension_index);
+}
+
+static bool _sieve_extension_load(struct sieve_extension *ext)
+{
+	/* Call load handler */
+	if ( ext->def != NULL && ext->def->load != NULL &&
+		!ext->def->load(ext, &ext->context) ) {
+		sieve_sys_error("failed to load '%s' extension support.", ext->def->name);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static struct sieve_extension *_sieve_extension_register
+(struct sieve_instance *svinst, const struct sieve_extension_def *extdef,
+	bool load, bool required)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	struct sieve_extension *ext = (struct sieve_extension *)
+		hash_table_lookup(ext_reg->extension_index, extdef->name);
+
+	/* Register extension if it is not registered already */
+	if ( ext == NULL ) {
+		int ext_id = array_count(&ext_reg->extensions);
+
+		/* Add extension to the registry */
+
+		ext = array_append_space(&ext_reg->extensions);
+		ext->id = ext_id;
+		ext->def = extdef;
+		ext->svinst = svinst;
+
+		hash_table_insert
+			(ext_reg->extension_index, (void *) extdef->name, (void *) ext);
+	}
+
+	/* Enable extension */
+	if ( load ) {
+		ext->enabled = TRUE;
+
+		/* Call load handler if extension was not loaded already */
+		if ( !ext->loaded ) {
+			if ( !_sieve_extension_load(ext) )
+				return NULL;
+		}
+
+		ext->loaded = TRUE;
+	}
+
+	ext->required = (ext->required || required );
+
+	return ext;
+}
+
+const struct sieve_extension *sieve_extension_register
+(struct sieve_instance *svinst, const struct sieve_extension_def *extdef,
+	bool load)
+{
+	return _sieve_extension_register(svinst, extdef, load, FALSE);
+}
+
+const struct sieve_extension *sieve_extension_require
+(struct sieve_instance *svinst, const struct sieve_extension_def *extdef)
+{
+  return _sieve_extension_register(svinst, extdef, TRUE, TRUE);
+}
+
+int sieve_extensions_get_count(struct sieve_instance *svinst)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+
+	return array_count(&ext_reg->extensions);
+}
+
+const struct sieve_extension *sieve_extension_get_by_id
+(struct sieve_instance *svinst, unsigned int ext_id)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	const struct sieve_extension *ext;
+
+	if ( ext_id < array_count(&ext_reg->extensions) ) {
+		ext = array_idx(&ext_reg->extensions, ext_id);
+
+		if ( ext->enabled )
+			return ext;
+	}
+
+	return NULL;
+}
+
+const struct sieve_extension *sieve_extension_get_by_name
+(struct sieve_instance *svinst, const char *name)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	const struct sieve_extension *ext;
+
+	if ( *name == '@' )
+		return NULL;
+
+	ext = (const struct sieve_extension *)
+		hash_table_lookup(ext_reg->extension_index, name);
+
+	if ( ext == NULL || !ext->enabled )
+		return NULL;
+
+	return ext;
+}
+
+const char *sieve_extensions_get_string(struct sieve_instance *svinst)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	string_t *extstr = t_str_new(256);
+	const struct sieve_extension *exts;
+	unsigned int i, ext_count;
+
+	exts = array_get(&ext_reg->extensions, &ext_count);
+
+	if ( ext_count > 0 ) {
+		i = 0;
+
+		/* Find first listable extension */
+		while ( i < ext_count &&
+			!( exts[i].enabled && *(exts[i].def->name) != '@' ) )
+			i++;
+
+		if ( i < ext_count ) {
+			/* Add first to string */
+			str_append(extstr, exts[i].def->name);
+			i++;
+
+	 		/* Add others */
+			for ( ; i < ext_count; i++ ) {
+				if ( exts[i].enabled && *(exts[i].def->name) != '@' ) {
+					str_append_c(extstr, ' ');
+					str_append(extstr, exts[i].def->name);
+				}
+			}
+		}
+	}
+
+	return str_c(extstr);
+}
+
+static void sieve_extension_enable(struct sieve_extension *ext)
+{
+	ext->enabled = TRUE;
+
+	if ( !ext->loaded ) {
+		(void)_sieve_extension_load(ext);
+	}
+
+	ext->loaded = TRUE;
+}
+
+static void sieve_extension_disable(struct sieve_extension *ext)
+{
+	ext->enabled = FALSE;
+}
+
+void sieve_extensions_set_string
+(struct sieve_instance *svinst, const char *ext_string)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	ARRAY_DEFINE(enabled_extensions, const struct sieve_extension *);
+	ARRAY_DEFINE(disabled_extensions, const struct sieve_extension *);
+	const struct sieve_extension *const *ext_enabled;
+	const struct sieve_extension *const *ext_disabled;
+	struct sieve_extension *exts;
+	const char **ext_names;
+	unsigned int i, ext_count, ena_count, dis_count;
+	bool relative = FALSE;
+
+	if ( ext_string == NULL ) {
+		/* Enable all */
+		exts = array_get_modifiable(&ext_reg->extensions, &ext_count);
+
+		for ( i = 0; i < ext_count; i++ )
+			sieve_extension_enable(&exts[i]);
+
+		return;
+	}
+
+	T_BEGIN {
+		t_array_init(&enabled_extensions, array_count(&ext_reg->extensions));
+		t_array_init(&disabled_extensions, array_count(&ext_reg->extensions));
+
+		ext_names = t_strsplit_spaces(ext_string, " \t");
+
+		while ( *ext_names != NULL ) {
+			const char *name = *ext_names;
+
+			ext_names++;
+
+			if ( *name != '\0' ) {
+				const struct sieve_extension *ext;
+				char op = '\0'; /* No add/remove operation */
+
+				if ( *name == '+' 		/* Add to existing config */
+					|| *name == '-' ) {	/* Remove from existing config */
+				 	op = *name++;
+				 	relative = TRUE;
+				}
+
+				if ( *name == '@' )
+					ext = NULL;
+				else
+					ext = (const struct sieve_extension *)
+						hash_table_lookup(ext_reg->extension_index, name);
+
+				if ( ext == NULL ) {
+					sieve_sys_warning(
+						"ignored unknown extension '%s' while configuring "
+						"available extensions", name);
+					continue;
+				}
+
+				if ( op == '-' )
+					array_append(&disabled_extensions, &ext, 1);
+				else
+					array_append(&enabled_extensions, &ext, 1);
+			}
+		}
+
+		exts = array_get_modifiable(&ext_reg->extensions, &ext_count);
+		ext_enabled = array_get(&enabled_extensions, &ena_count);
+		ext_disabled = array_get(&disabled_extensions, &dis_count);
+
+		/* Set new extension status */
+
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int j;
+			bool disabled = TRUE;
+
+			/* If extensions are specified relative to the default set,
+			 * we first need to check which ones are disabled
+			 */
+
+			if ( relative ) {
+				/* Enable if core extension */
+				for ( j = 0; j < sieve_core_extensions_count; j++ ) {
+					if ( sieve_core_extensions[j] == exts[i].def ) {
+						disabled = FALSE;
+						break;
+					}
+				}
+
+				/* Disable if explicitly disabled */
+				for ( j = 0; j < dis_count; j++ ) {
+					if ( ext_disabled[j]->def == exts[i].def ) {
+						disabled = TRUE;
+						break;
+					}
+				}
+			}
+
+			/* Enable if listed with '+' or no prefix */
+
+			for ( j = 0; j < ena_count; j++ ) {
+				if ( ext_enabled[j]->def == exts[i].def ) {
+					disabled = FALSE;
+					break;
+				}
+			}
+
+			/* Perform actual activation/deactivation */
+
+			if ( exts[i].id >= 0 && *(exts[i].def->name) != '@' ) {
+				if ( disabled && !exts[i].required )
+					sieve_extension_disable(&exts[i]);
+				else
+					sieve_extension_enable(&exts[i]);
+			}
+		}
+	} T_END;
+}
+
+const struct sieve_extension *sieve_get_match_type_extension
+	(struct sieve_instance *svinst)
+{
+	return svinst->ext_reg->match_type_extension;
+}
+
+const struct sieve_extension *sieve_get_comparator_extension
+	(struct sieve_instance *svinst)
+{
+	return svinst->ext_reg->comparator_extension;
+}
+
+const struct sieve_extension *sieve_get_address_part_extension
+	(struct sieve_instance *svinst)
+{
+	return svinst->ext_reg->address_part_extension;
+}
+
+/*
+ * Extension capabilities
+ */
+
+struct sieve_capability_registration {
+	const struct sieve_extension *ext;
+	const struct sieve_extension_capabilities *capabilities;
+};
+
+void sieve_capability_registry_init(struct sieve_instance *svinst)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+
+	ext_reg->capabilities_index = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+void sieve_capability_registry_deinit(struct sieve_instance *svinst)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+
+	if ( ext_reg->capabilities_index == NULL ) return;
+
+	hash_table_destroy(&svinst->ext_reg->capabilities_index);
+}
+
+void sieve_extension_capabilities_register
+(struct sieve_instance *svinst, const struct sieve_extension *ext,
+	const struct sieve_extension_capabilities *cap)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+	struct sieve_capability_registration *reg =
+		p_new(svinst->pool, struct sieve_capability_registration, 1);
+
+	reg->ext = ext;
+	reg->capabilities = cap;
+
+	hash_table_insert
+		(ext_reg->capabilities_index, (void *) cap->name, (void *) reg);
+}
+
+const char *sieve_extension_capabilities_get_string
+(struct sieve_instance *svinst, const char *cap_name)
+{
+	struct sieve_extension_registry *ext_reg = svinst->ext_reg;
+  const struct sieve_capability_registration *cap_reg =
+		(const struct sieve_capability_registration *)
+			hash_table_lookup(ext_reg->capabilities_index, cap_name);
+	const struct sieve_extension_capabilities *cap;
+
+	if ( cap_reg == NULL || cap_reg->capabilities == NULL )
+		return NULL;
+
+	cap = cap_reg->capabilities;
+
+	if ( cap->get_string == NULL || !cap_reg->ext->enabled )
+		return NULL;
+
+	return cap->get_string(cap_reg->ext);
+}
+
+
+
+
Index: b/sieve/src/lib-sieve/sieve-extensions.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-extensions.h
@@ -0,0 +1,151 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXTENSIONS_H
+#define __SIEVE_EXTENSIONS_H
+
+#include "lib.h"
+#include "sieve-common.h"
+
+/*
+ * Per-extension object registry
+ */
+
+struct sieve_extension_objects {
+	const void *objects;
+	unsigned int count;
+};
+
+/*
+ * Extension definition
+ */
+
+struct sieve_extension_def {
+	const char *name;
+
+	/* Registration */
+	bool (*load)(const struct sieve_extension *ext, void **);
+	void (*unload)(const struct sieve_extension *ext);
+
+	/* Compilation */
+	bool (*validator_load)
+		(const struct sieve_extension *ext, struct sieve_validator *validator);
+	bool (*generator_load)
+		(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv);
+	bool (*interpreter_load)
+		(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+			sieve_size_t *address);
+	bool (*binary_load)
+		(const struct sieve_extension *ext, struct sieve_binary *binary);
+
+	/* Code dump */
+	bool (*binary_dump)
+		(const struct sieve_extension *ext, struct sieve_dumptime_env *denv);
+	bool (*code_dump)
+		(const struct sieve_extension *ext, const struct sieve_dumptime_env *denv,
+			sieve_size_t *address);
+
+	/* Objects */
+	struct sieve_extension_objects operations;
+	struct sieve_extension_objects operands;
+};
+
+#define SIEVE_EXT_DEFINE_NO_OBJECTS \
+	{ NULL, 0 }
+#define SIEVE_EXT_DEFINE_OBJECT(OBJ) \
+	{ &OBJ, 1 }
+#define SIEVE_EXT_DEFINE_OBJECTS(OBJS) \
+	{ OBJS, N_ELEMENTS(OBJS) }
+
+#define SIEVE_EXT_GET_OBJECTS_COUNT(ext, field) \
+	ext->field->count;
+
+/*
+ * Extension instance
+ */
+
+struct sieve_extension {
+	const struct sieve_extension_def *def;
+	int id;
+
+	struct sieve_instance *svinst;
+	void *context;
+
+	unsigned int required:1;
+	unsigned int loaded:1;
+	unsigned int enabled:1;
+};
+
+#define sieve_extension_name(ext) \
+	(ext)->def->name
+
+/*
+ * Defining opcodes and operands
+ */
+
+#define SIEVE_EXT_DEFINE_NO_OPERATIONS SIEVE_EXT_DEFINE_NO_OBJECTS
+#define SIEVE_EXT_DEFINE_OPERATION(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_OPERATIONS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+#define SIEVE_EXT_DEFINE_NO_OPERANDS SIEVE_EXT_DEFINE_NO_OBJECTS
+#define SIEVE_EXT_DEFINE_OPERAND(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_OPERANDS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+/*
+ * Extensions init/deinit
+ */
+
+bool sieve_extensions_init(struct sieve_instance *svinst);
+void sieve_extensions_deinit(struct sieve_instance *svinst);
+
+/*
+ * Pre-loaded extensions
+ */
+
+const struct sieve_extension *const *sieve_extensions_get_preloaded
+	(struct sieve_instance *svinst, unsigned int *count_r);
+
+/*
+ * Extension registry
+ */
+
+const struct sieve_extension *sieve_extension_register
+	(struct sieve_instance *svinst, const struct sieve_extension_def *extension,
+		bool load);
+const struct sieve_extension *sieve_extension_require
+	(struct sieve_instance *svinst, const struct sieve_extension_def *extension);
+int sieve_extensions_get_count(struct sieve_instance *svinst);
+const struct sieve_extension *sieve_extension_get_by_id
+	(struct sieve_instance *svinst, unsigned int ext_id);
+const struct sieve_extension *sieve_extension_get_by_name
+	(struct sieve_instance *svinst, const char *name);
+
+const char *sieve_extensions_get_string
+	(struct sieve_instance *svinst);
+void sieve_extensions_set_string
+	(struct sieve_instance *svinst, const char *ext_string);
+
+const struct sieve_extension *sieve_get_match_type_extension
+	(struct sieve_instance *svinst);
+const struct sieve_extension *sieve_get_comparator_extension
+	(struct sieve_instance *svinst);
+const struct sieve_extension *sieve_get_address_part_extension
+	(struct sieve_instance *svinst);
+
+/*
+ * Capability registries
+ */
+
+struct sieve_extension_capabilities {
+	const char *name;
+
+	const char *(*get_string)(const struct sieve_extension *ext);
+};
+
+void sieve_extension_capabilities_register
+	(struct sieve_instance *svinst, const struct sieve_extension *ext,
+		const struct sieve_extension_capabilities *cap);
+const char *sieve_extension_capabilities_get_string
+	(struct sieve_instance *svinst, const char *cap_name);
+
+#endif /* __SIEVE_EXTENSIONS_H */
Index: b/sieve/src/lib-sieve/sieve-generator.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-generator.c
@@ -0,0 +1,456 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+#include "sieve-generator.h"
+
+/*
+ * Jump list
+ */
+
+struct sieve_jumplist *sieve_jumplist_create
+	(pool_t pool, struct sieve_binary *sbin)
+{
+	struct sieve_jumplist *jlist;
+
+	jlist = p_new(pool, struct sieve_jumplist, 1);
+	jlist->binary = sbin;
+	p_array_init(&jlist->jumps, pool, 4);
+
+	return jlist;
+}
+
+void sieve_jumplist_init_temp
+	(struct sieve_jumplist *jlist, struct sieve_binary *sbin)
+{
+	jlist->binary = sbin;
+	t_array_init(&jlist->jumps, 4);
+}
+
+void sieve_jumplist_reset
+	(struct sieve_jumplist *jlist)
+{
+	array_clear(&jlist->jumps);
+}
+
+void sieve_jumplist_add(struct sieve_jumplist *jlist, sieve_size_t jump)
+{
+	array_append(&jlist->jumps, &jump, 1);
+}
+
+void sieve_jumplist_resolve(struct sieve_jumplist *jlist)
+{
+	unsigned int i;
+
+	for ( i = 0; i < array_count(&jlist->jumps); i++ ) {
+		const sieve_size_t *jump = array_idx(&jlist->jumps, i);
+
+		sieve_binary_resolve_offset(jlist->binary, *jump);
+	}
+}
+
+/*
+ * Code Generator
+ */
+
+struct sieve_generator {
+	pool_t pool;
+
+	struct sieve_instance *instance;
+
+	struct sieve_error_handler *ehandler;
+
+	struct sieve_codegen_env genenv;
+
+	ARRAY_DEFINE(ext_contexts, void *);
+};
+
+struct sieve_generator *sieve_generator_create
+(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	pool_t pool;
+	struct sieve_generator *gentr;
+	struct sieve_script *script;
+	struct sieve_instance *svinst;
+
+	pool = pool_alloconly_create("sieve_generator", 4096);
+	gentr = p_new(pool, struct sieve_generator, 1);
+	gentr->pool = pool;
+
+	gentr->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	gentr->genenv.gentr = gentr;
+	gentr->genenv.ast = ast;
+	sieve_ast_ref(ast);
+
+	script = sieve_ast_script(ast);
+	svinst = sieve_script_svinst(script);
+
+	gentr->genenv.script = script;
+	gentr->genenv.svinst = svinst;
+
+	/* Setup storage for extension contexts */
+	p_array_init(&gentr->ext_contexts, pool, sieve_extensions_get_count(svinst));
+
+	return gentr;
+}
+
+void sieve_generator_free(struct sieve_generator **generator)
+{
+	sieve_ast_unref(&(*generator)->genenv.ast);
+
+	if ( (*generator)->genenv.sbin != NULL )
+		sieve_binary_unref(&(*generator)->genenv.sbin);
+
+	sieve_error_handler_unref(&(*generator)->ehandler);
+
+	pool_unref(&((*generator)->pool));
+
+	*generator = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+struct sieve_error_handler *sieve_generator_error_handler
+(struct sieve_generator *gentr)
+{
+	return gentr->ehandler;
+}
+
+pool_t sieve_generator_pool(struct sieve_generator *gentr)
+{
+	return gentr->pool;
+}
+
+struct sieve_script *sieve_generator_script
+(struct sieve_generator *gentr)
+{
+	return gentr->genenv.script;
+}
+
+struct sieve_binary *sieve_generator_get_binary
+	(struct sieve_generator *gentr)
+{
+	return gentr->genenv.sbin;
+}
+
+/*
+ * Error handling
+ */
+
+void sieve_generator_warning
+(struct sieve_generator *gentr, unsigned int source_line,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_vwarning(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+void sieve_generator_error
+(struct sieve_generator *gentr, unsigned int source_line,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_verror(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+void sieve_generator_critical
+(struct sieve_generator *gentr, unsigned int source_line,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_vwarning(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+/*
+ * Extension support
+ */
+
+void sieve_generator_extension_set_context
+(struct sieve_generator *gentr, const struct sieve_extension *ext, void *context)
+{
+	if ( ext->id < 0 ) return;
+
+	array_idx_set(&gentr->ext_contexts, (unsigned int) ext->id, &context);
+}
+
+const void *sieve_generator_extension_get_context
+(struct sieve_generator *gentr, const struct sieve_extension *ext)
+{
+	void * const *ctx;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&gentr->ext_contexts) )
+		return NULL;
+
+	ctx = array_idx(&gentr->ext_contexts, (unsigned int) ext->id);
+
+	return *ctx;
+}
+
+/*
+ * Code generation API
+ */
+
+bool sieve_generate_argument
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd)
+{
+	const struct sieve_argument_def *arg_def;
+
+	if ( arg->argument == NULL || arg->argument->def == NULL ) return FALSE;
+
+	arg_def = arg->argument->def;
+
+	return ( arg_def->generate == NULL ||
+		arg_def->generate(cgenv, arg, cmd) );
+}
+
+bool sieve_generate_arguments
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+	struct sieve_ast_argument **last_arg_r)
+{
+	enum { ARG_START, ARG_OPTIONAL, ARG_POSITIONAL } state = ARG_START;
+	struct sieve_ast_argument *arg = sieve_ast_argument_first(cmd->ast_node);
+
+	/* Generate all arguments with assigned generator function */
+
+	while ( arg != NULL ) {
+		const struct sieve_argument *argument;
+		const struct sieve_argument_def *arg_def;
+
+		if ( arg->argument == NULL || arg->argument->def == NULL )
+			return FALSE;
+
+		argument = arg->argument;
+		arg_def = argument->def;
+
+		switch ( state ) {
+		case ARG_START:
+			if ( argument->id_code == 0 )
+				state = ARG_POSITIONAL;
+			else {
+				/* Mark start of optional operands with 0 operand identifier */
+				sieve_binary_emit_byte(cgenv->sbin, SIEVE_OPERAND_OPTIONAL);
+
+				/* Emit argument id for optional operand */
+				sieve_binary_emit_byte(cgenv->sbin, (unsigned char) argument->id_code);
+
+				state = ARG_OPTIONAL;
+			}
+			break;
+		case ARG_OPTIONAL:
+			if ( argument->id_code == 0 )
+				state = ARG_POSITIONAL;
+
+			/* Emit argument id for optional operand (0 marks the end of the optionals) */
+			sieve_binary_emit_byte(cgenv->sbin, (unsigned char) argument->id_code);
+
+			break;
+		case ARG_POSITIONAL:
+			if ( argument->id_code != 0 )
+				return FALSE;
+			break;
+		}
+
+		/* Call the generation function for the argument */
+		if ( arg_def->generate != NULL ) {
+			if ( !arg_def->generate(cgenv, arg, cmd) )
+				return FALSE;
+		} else if ( state == ARG_POSITIONAL ) break;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Mark end of optional list if it is still open */
+	if ( state == ARG_OPTIONAL )
+		sieve_binary_emit_byte(cgenv->sbin, 0);
+
+	if ( last_arg_r != NULL )
+		*last_arg_r = arg;
+
+	return TRUE;
+}
+
+bool sieve_generate_argument_parameters
+(const struct sieve_codegen_env *cgenv,
+	struct sieve_command *cmd, struct sieve_ast_argument *arg)
+{
+	struct sieve_ast_argument *param = arg->parameters;
+
+	/* Generate all parameters with assigned generator function */
+
+	while ( param != NULL ) {
+		if ( param->argument != NULL && param->argument->def != NULL ) {
+			const struct sieve_argument_def *parameter = param->argument->def;
+
+			/* Call the generation function for the parameter */
+			if ( parameter->generate != NULL ) {
+				if ( !parameter->generate(cgenv, param, cmd) )
+					return FALSE;
+			}
+		}
+
+		param = sieve_ast_argument_next(param);
+	}
+
+	return TRUE;
+}
+
+bool sieve_generate_test
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *tst_node,
+	struct sieve_jumplist *jlist, bool jump_true)
+{
+	struct sieve_command *test;
+	const struct sieve_command_def *tst_def;
+
+	i_assert( tst_node->command != NULL && tst_node->command->def != NULL );
+
+	test = tst_node->command;
+	tst_def = test->def;
+
+	if ( tst_def->control_generate != NULL ) {
+		if ( tst_def->control_generate(cgenv, test, jlist, jump_true) )
+			return TRUE;
+
+		return FALSE;
+	}
+
+	if ( tst_def->generate != NULL ) {
+
+		if ( tst_def->generate(cgenv, test) ) {
+
+			if ( jump_true )
+				sieve_operation_emit(cgenv->sbin, NULL, &sieve_jmptrue_operation);
+			else
+				sieve_operation_emit(cgenv->sbin, NULL, &sieve_jmpfalse_operation);
+			sieve_jumplist_add(jlist, sieve_binary_emit_offset(cgenv->sbin, 0));
+
+			return TRUE;
+		}
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool sieve_generate_command
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *cmd_node)
+{
+	struct sieve_command *command;
+	const struct sieve_command_def *cmd_def;
+
+	i_assert( cmd_node->command != NULL && cmd_node->command->def != NULL );
+
+	command = cmd_node->command;
+	cmd_def = command->def;
+
+	if ( cmd_def->generate != NULL ) {
+		return cmd_def->generate(cgenv, command);
+	}
+
+	return TRUE;
+}
+
+bool sieve_generate_block
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *block)
+{
+	bool result = TRUE;
+	struct sieve_ast_node *cmd_node;
+
+	T_BEGIN {
+		cmd_node = sieve_ast_command_first(block);
+		while ( result && cmd_node != NULL ) {
+			result = sieve_generate_command(cgenv, cmd_node);
+			cmd_node = sieve_ast_command_next(cmd_node);
+		}
+	} T_END;
+
+	return result;
+}
+
+bool sieve_generator_run
+(struct sieve_generator *gentr, struct sieve_binary **sbin)
+{
+	bool topmost = ( *sbin == NULL );
+	bool result = TRUE;
+	const struct sieve_extension *const *extensions;
+	unsigned int i, ext_count;
+
+	/* Initialize */
+
+	if ( topmost )
+		*sbin = sieve_binary_create_new(sieve_ast_script(gentr->genenv.ast));
+
+	sieve_binary_ref(*sbin);
+
+	gentr->genenv.sbin = *sbin;
+
+	/* Load extensions linked to the AST and emit a list in code */
+	extensions = sieve_ast_extensions_get(gentr->genenv.ast, &ext_count);
+	(void) sieve_binary_emit_unsigned(*sbin, ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension *ext = extensions[i];
+
+		/* Link to binary */
+		(void)sieve_binary_extension_link(*sbin, ext);
+
+		/* Emit */
+		sieve_binary_emit_extension(*sbin, ext, 0);
+
+		/* Load */
+		if ( ext->def != NULL && ext->def->generator_load != NULL &&
+			!ext->def->generator_load(ext, &gentr->genenv) )
+			return FALSE;
+	}
+
+	/* Generate code */
+
+	if ( !sieve_generate_block
+		(&gentr->genenv, sieve_ast_root(gentr->genenv.ast)))
+		result = FALSE;
+	else if ( topmost )
+		sieve_binary_activate(*sbin);
+
+	/* Cleanup */
+
+	gentr->genenv.sbin = NULL;
+	sieve_binary_unref(sbin);
+
+	if ( topmost && !result ) {
+		sieve_binary_unref(sbin);
+		*sbin = NULL;
+	}
+
+	return result;
+}
+
+
+
Index: b/sieve/src/lib-sieve/sieve-generator.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-generator.h
@@ -0,0 +1,107 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_GENERATOR_H
+#define __SIEVE_GENERATOR_H
+
+#include "sieve-common.h"
+
+/*
+ * Code generator
+ */
+
+struct sieve_generator;
+
+struct sieve_codegen_env {
+	struct sieve_generator *gentr;
+
+	struct sieve_instance *svinst;
+	struct sieve_script *script;
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin;
+};
+
+struct sieve_generator *sieve_generator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+void sieve_generator_free(struct sieve_generator **generator);
+
+/*
+ * Accessors
+ */
+
+struct sieve_error_handler *sieve_generator_error_handler
+	(struct sieve_generator *gentr);
+pool_t sieve_generator_pool(struct sieve_generator *gentr);
+struct sieve_script *sieve_generator_script
+	(struct sieve_generator *gentr);
+struct sieve_binary *sieve_generator_get_binary
+	(struct sieve_generator *gentr);
+
+/*
+ * Error handling
+ */
+
+void sieve_generator_warning
+(struct sieve_generator *gentr, unsigned int source_line,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);;
+void sieve_generator_error
+(struct sieve_generator *gentr, unsigned int source_line,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_generator_critical
+(struct sieve_generator *gentr, unsigned int source_line,
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/*
+ * Extension support
+ */
+
+void sieve_generator_extension_set_context
+	(struct sieve_generator *gentr, const struct sieve_extension *ext,
+		void *context);
+const void *sieve_generator_extension_get_context
+	(struct sieve_generator *gentr, const struct sieve_extension *ext);
+
+/*
+ * Jump list
+ */
+
+struct sieve_jumplist {
+	pool_t pool;
+	struct sieve_binary *binary;
+	ARRAY_DEFINE(jumps, sieve_size_t);
+};
+
+struct sieve_jumplist *sieve_jumplist_create
+	(pool_t pool, struct sieve_binary *sbin);
+void sieve_jumplist_init_temp
+	(struct sieve_jumplist *jlist, struct sieve_binary *sbin);
+void sieve_jumplist_reset
+	(struct sieve_jumplist *jlist);
+void sieve_jumplist_add
+	(struct sieve_jumplist *jlist, sieve_size_t jump);
+void sieve_jumplist_resolve(struct sieve_jumplist *jlist);
+
+/*
+ * Code generation API
+ */
+
+bool sieve_generate_argument
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+bool sieve_generate_arguments
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+		struct sieve_ast_argument **last_arg_r);
+bool sieve_generate_argument_parameters
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+		struct sieve_ast_argument *arg);
+
+bool sieve_generate_block
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *block);
+bool sieve_generate_test
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *tst_node,
+		struct sieve_jumplist *jlist, bool jump_true);
+bool sieve_generator_run
+	(struct sieve_generator *gentr, struct sieve_binary **sbin);
+
+#endif /* __SIEVE_GENERATOR_H */
+
Index: b/sieve/src/lib-sieve/sieve-interpreter.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-interpreter.c
@@ -0,0 +1,529 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "mempool.h"
+#include "array.h"
+#include "hash.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-message.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-comparators.h"
+
+#include "sieve-interpreter.h"
+
+#include <string.h>
+
+/*
+ * Interpreter extension
+ */
+
+struct sieve_interpreter_extension_reg {
+	const struct sieve_interpreter_extension *intext;
+	const struct sieve_extension *ext;
+
+	void *context;
+};
+
+/*
+ * Interpreter
+ */
+
+struct sieve_interpreter {
+	pool_t pool;
+
+	struct sieve_error_handler *ehandler;
+
+	/* Runtime data for extensions */
+	ARRAY_DEFINE(extensions, struct sieve_interpreter_extension_reg);
+
+	sieve_size_t reset_vector;
+
+	/* Execution status */
+
+	sieve_size_t pc;          /* Program counter */
+	bool interrupted;         /* Interpreter interrupt requested */
+	bool test_result;         /* Result of previous test command */
+
+	/* Runtime environment */
+	struct sieve_runtime_env runenv;
+};
+
+struct sieve_interpreter *sieve_interpreter_create
+(struct sieve_binary *sbin, struct sieve_error_handler *ehandler)
+{
+	unsigned int i, ext_count;
+	struct sieve_interpreter *interp;
+	pool_t pool;
+	struct sieve_instance *svinst;
+	const struct sieve_extension *const *ext_preloaded;
+	bool success = TRUE;
+
+	pool = pool_alloconly_create("sieve_interpreter", 4096);
+	interp = p_new(pool, struct sieve_interpreter, 1);
+	interp->pool = pool;
+
+	interp->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	interp->runenv.interp = interp;
+	interp->runenv.sbin = sbin;
+	sieve_binary_ref(sbin);
+
+	svinst = sieve_binary_svinst(sbin);
+
+	interp->runenv.svinst = svinst;
+	interp->runenv.script = sieve_binary_script(sbin);
+
+	interp->pc = 0;
+
+	p_array_init(&interp->extensions, pool, sieve_extensions_get_count(svinst));
+
+	/* Pre-load core language features implemented as 'extensions' */
+	ext_preloaded = sieve_extensions_get_preloaded(svinst, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension_def *ext_def = ext_preloaded[i]->def;
+
+		if ( ext_def != NULL && ext_def->interpreter_load != NULL )
+			(void)ext_def->interpreter_load
+				(ext_preloaded[i], &interp->runenv, &interp->pc);
+	}
+
+	/* Load other extensions listed in code */
+	if ( sieve_binary_read_unsigned(sbin, &interp->pc, &ext_count) ) {
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int code = 0;
+			const struct sieve_extension *ext;
+
+			if ( !sieve_binary_read_extension(sbin, &interp->pc, &code, &ext) ) {
+				success = FALSE;
+				break;
+			}
+
+			if ( ext->def != NULL && ext->def->interpreter_load != NULL &&
+				!ext->def->interpreter_load(ext, &interp->runenv, &interp->pc) ) {
+				success = FALSE;
+				break;
+			}
+		}
+	}	else
+		success = FALSE;
+
+	if ( !success ) {
+		sieve_interpreter_free(&interp);
+	} else {
+		interp->reset_vector = interp->pc;
+	}
+
+	return interp;
+}
+
+void sieve_interpreter_free(struct sieve_interpreter **interp)
+{
+	const struct sieve_interpreter_extension_reg *eregs;
+	unsigned int ext_count, i;
+
+	sieve_binary_unref(&(*interp)->runenv.sbin);
+
+	sieve_error_handler_unref(&(*interp)->ehandler);
+
+	/* Signal registered extensions that the interpreter is being destroyed */
+	eregs = array_get(&(*interp)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( eregs[i].intext != NULL && eregs[i].intext->free != NULL )
+			eregs[i].intext->free(eregs[i].ext, *interp, eregs[i].context);
+	}
+
+	pool_unref(&((*interp)->pool));
+	*interp = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_interpreter_pool(struct sieve_interpreter *interp)
+{
+	return interp->pool;
+}
+
+struct sieve_script *sieve_interpreter_script
+(struct sieve_interpreter *interp)
+{
+	return interp->runenv.script;
+}
+
+struct sieve_error_handler *sieve_interpreter_get_error_handler
+(struct sieve_interpreter *interp)
+{
+	return interp->ehandler;
+}
+
+struct sieve_instance *sieve_interpreter_svinst
+(struct sieve_interpreter *interp)
+{
+	return interp->runenv.svinst;
+}
+
+/* Do not use this function for normal sieve extensions. This is intended for
+ * the testsuite only.
+ */
+void sieve_interpreter_set_result
+(struct sieve_interpreter *interp, struct sieve_result *result)
+{
+	sieve_result_unref(&interp->runenv.result);
+	interp->runenv.result = result;
+	sieve_result_ref(result);
+}
+
+/*
+ * Error handling
+ */
+
+/* This is not particularly user friendly, so avoid using this
+ */
+const char *sieve_runtime_location(const struct sieve_runtime_env *runenv)
+{
+	const char *op = runenv->oprtn.def == NULL ?
+		"<<NOOP>>" : runenv->oprtn.def->mnemonic;
+	return t_strdup_printf("%s: #%08llx: %s", sieve_script_name(runenv->script),
+		(unsigned long long) runenv->oprtn.address, op);
+}
+
+void sieve_runtime_error
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_verror(runenv->interp->ehandler, location, fmt, args);
+	} T_END;
+	va_end(args);
+}
+
+void sieve_runtime_warning
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_vwarning(runenv->interp->ehandler, location, fmt, args);
+	} T_END;
+	va_end(args);
+}
+
+void sieve_runtime_log
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_vinfo(runenv->interp->ehandler, location, fmt, args);
+	} T_END;
+	va_end(args);
+}
+
+/*
+ * Runtime trace
+ */
+
+#ifdef SIEVE_RUNTIME_TRACE
+void _sieve_runtime_trace
+(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_printfa(outbuf, "%08llx: ", (unsigned long long) runenv->oprtn.address);
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+
+	o_stream_send(runenv->trace_stream, str_data(outbuf), str_len(outbuf));
+}
+
+void _sieve_runtime_trace_error
+(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_printfa(outbuf, "%08llx: [[ERROR: %s: ",
+		(unsigned long long) runenv->interp->pc, runenv->oprtn.def->mnemonic);
+	str_vprintfa(outbuf, fmt, args);
+    str_append(outbuf, "]]\n");
+	va_end(args);
+
+	o_stream_send(runenv->trace_stream, str_data(outbuf), str_len(outbuf));
+}
+#endif
+
+/*
+ * Extension support
+ */
+
+void sieve_interpreter_extension_register
+(struct sieve_interpreter *interp, const struct sieve_extension *ext,
+	const struct sieve_interpreter_extension *intext, void *context)
+{
+	struct sieve_interpreter_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	reg = array_idx_modifiable(&interp->extensions, (unsigned int) ext->id);
+	reg->intext = intext;
+	reg->ext = ext;
+	reg->context = context;
+}
+
+void sieve_interpreter_extension_set_context
+(struct sieve_interpreter *interp, const struct sieve_extension *ext,
+	void *context)
+{
+	struct sieve_interpreter_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	reg = array_idx_modifiable(&interp->extensions, (unsigned int) ext->id);
+	reg->context = context;
+}
+
+void *sieve_interpreter_extension_get_context
+(struct sieve_interpreter *interp, const struct sieve_extension *ext)
+{
+	const struct sieve_interpreter_extension_reg *reg;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&interp->extensions) )
+		return NULL;
+
+	reg = array_idx(&interp->extensions, (unsigned int) ext->id);
+
+	return reg->context;
+}
+
+/*
+ * Program flow
+ */
+
+void sieve_interpreter_reset(struct sieve_interpreter *interp)
+{
+	interp->pc = interp->reset_vector;
+	interp->interrupted = FALSE;
+	interp->test_result = FALSE;
+	interp->runenv.msgdata = NULL;
+	interp->runenv.result = NULL;
+}
+
+void sieve_interpreter_interrupt(struct sieve_interpreter *interp)
+{
+	interp->interrupted = TRUE;
+}
+
+sieve_size_t sieve_interpreter_program_counter(struct sieve_interpreter *interp)
+{
+	return interp->pc;
+}
+
+int sieve_interpreter_program_jump
+(struct sieve_interpreter *interp, bool jump)
+{
+	const struct sieve_runtime_env *renv = &interp->runenv;
+	sieve_size_t pc = interp->pc;
+	int offset;
+
+	if ( !sieve_binary_read_offset(renv->sbin, &(interp->pc), &offset) )
+	{
+		sieve_runtime_trace_error(renv, "invalid jump offset");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( pc + offset <= sieve_binary_get_code_size(renv->sbin) &&
+		pc + offset > 0 )
+	{
+		if ( jump )
+			interp->pc = pc + offset;
+
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "jump offset out of range");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+/*
+ * Test results
+ */
+
+void sieve_interpreter_set_test_result
+(struct sieve_interpreter *interp, bool result)
+{
+	interp->test_result = result;
+}
+
+bool sieve_interpreter_get_test_result
+(struct sieve_interpreter *interp)
+{
+	return interp->test_result;
+}
+
+/*
+ * Operations and operands
+ */
+
+int sieve_interpreter_handle_optional_operands
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_side_effects_list **list)
+{
+	signed int opt_code = -1;
+
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			if ( opt_code == SIEVE_OPT_SIDE_EFFECT ) {
+				struct sieve_side_effect seffect;
+
+				if ( list == NULL )
+					return SIEVE_EXEC_BIN_CORRUPT;
+
+				if ( !sieve_opr_side_effect_read(renv, address, &seffect) ) {
+					sieve_runtime_trace_error(renv, "invalid side effect operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+
+				if ( *list == NULL )
+					*list = sieve_side_effects_list_create(renv->result);
+
+				sieve_side_effects_list_add(*list, &seffect);
+			}
+		}
+	}
+	return TRUE;
+}
+
+/*
+ * Code execute
+ */
+
+static int sieve_interpreter_execute_operation
+(struct sieve_interpreter *interp)
+{
+	struct sieve_operation *oprtn = &(interp->runenv.oprtn);
+
+	if ( sieve_operation_read(interp->runenv.sbin, &(interp->pc), oprtn) ) {
+		const struct sieve_operation_def *op = oprtn->def;
+
+		int result = SIEVE_EXEC_OK;
+
+		if ( op->execute != NULL ) { /* Noop ? */
+			T_BEGIN {
+				result = op->execute(&(interp->runenv), &(interp->pc));
+			} T_END;
+		} else {
+			sieve_runtime_trace(&interp->runenv, "OP: %s (NOOP)", op->mnemonic);
+		}
+
+		return result;
+	}
+
+	sieve_runtime_trace(&interp->runenv, "Encountered invalid operation");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+int sieve_interpreter_continue
+(struct sieve_interpreter *interp, bool *interrupted)
+{
+	int ret = SIEVE_EXEC_OK;
+
+	sieve_result_ref(interp->runenv.result);
+	interp->interrupted = FALSE;
+
+	if ( interrupted != NULL )
+		*interrupted = FALSE;
+
+	while ( ret == SIEVE_EXEC_OK && !interp->interrupted &&
+		interp->pc < sieve_binary_get_code_size(interp->runenv.sbin) ) {
+
+		ret = sieve_interpreter_execute_operation(interp);
+
+		if ( ret != SIEVE_EXEC_OK ) {
+			sieve_runtime_trace(&interp->runenv, "[[EXECUTION ABORTED]]");
+		}
+	}
+
+	if ( interrupted != NULL )
+		*interrupted = interp->interrupted;
+
+	sieve_result_unref(&interp->runenv.result);
+	return ret;
+}
+
+int sieve_interpreter_start
+(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_result *result,
+	bool *interrupted)
+{
+	const struct sieve_interpreter_extension_reg *eregs;
+	unsigned int ext_count, i;
+
+	interp->runenv.msgdata = msgdata;
+	interp->runenv.result = result;
+	interp->runenv.msgctx = sieve_result_get_message_context(result);
+	interp->runenv.scriptenv = senv;
+	interp->runenv.trace_stream = senv->trace_stream;
+
+	if ( senv->exec_status == NULL )
+		interp->runenv.exec_status =
+			p_new(interp->pool, struct sieve_exec_status, 1);
+	else
+		interp->runenv.exec_status = senv->exec_status;
+
+	/* Signal registered extensions that the interpreter is being run */
+	eregs = array_get(&interp->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( eregs[i].intext != NULL && eregs[i].intext->run != NULL )
+			eregs[i].intext->run(eregs[i].ext, &interp->runenv, eregs[i].context);
+	}
+
+	return sieve_interpreter_continue(interp, interrupted);
+}
+
+int sieve_interpreter_run
+(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_result *result)
+{
+	int ret = 0;
+
+	sieve_interpreter_reset(interp);
+	sieve_result_ref(result);
+
+	ret = sieve_interpreter_start(interp, msgdata, senv, result, NULL);
+
+	sieve_result_unref(&result);
+
+	return ret;
+}
+
+
Index: b/sieve/src/lib-sieve/sieve-interpreter.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-interpreter.h
@@ -0,0 +1,184 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_INTERPRETER_H
+#define __SIEVE_INTERPRETER_H
+
+#include "lib.h"
+#include "array.h"
+#include "buffer.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_interpreter;
+
+/*
+ * Runtime environment
+ */
+
+struct sieve_runtime_env {
+	struct sieve_interpreter *interp;
+	struct sieve_instance *svinst;
+
+	struct sieve_binary *sbin;
+	struct sieve_operation oprtn;
+
+	struct sieve_script *script;
+	const struct sieve_script_env *scriptenv;
+
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+
+	struct sieve_result *result;
+
+	struct sieve_exec_status *exec_status;
+	struct ostream *trace_stream;
+};
+
+/*
+ * Interpreter
+ */
+
+struct sieve_interpreter *sieve_interpreter_create
+	(struct sieve_binary *sbin, struct sieve_error_handler *ehandler);
+void sieve_interpreter_free(struct sieve_interpreter **interp);
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_interpreter_pool
+	(struct sieve_interpreter *interp);
+struct sieve_script *sieve_interpreter_script
+	(struct sieve_interpreter *interp);
+struct sieve_error_handler *sieve_interpreter_get_error_handler
+	(struct sieve_interpreter *interp);
+struct sieve_instance *sieve_interpreter_svinst
+	(struct sieve_interpreter *interp);
+
+/* Do not use this function for normal sieve extensions. This is intended for
+ * the testsuite only.
+ */
+void sieve_interpreter_set_result
+	(struct sieve_interpreter *interp, struct sieve_result *result);
+
+/*
+ * Program flow
+ */
+
+void sieve_interpreter_reset
+	(struct sieve_interpreter *interp);
+void sieve_interpreter_interrupt
+	(struct sieve_interpreter *interp);
+sieve_size_t sieve_interpreter_program_counter
+	(struct sieve_interpreter *interp);
+
+int sieve_interpreter_program_jump
+	(struct sieve_interpreter *interp, bool jump);
+
+/*
+ * Test results
+ */
+
+void sieve_interpreter_set_test_result
+	(struct sieve_interpreter *interp, bool result);
+bool sieve_interpreter_get_test_result
+	(struct sieve_interpreter *interp);
+
+/*
+ * Error handling
+ */
+
+/* This is not particularly user-friendly, so avoid using this.. */
+const char *sieve_runtime_location(const struct sieve_runtime_env *runenv);
+
+void sieve_runtime_error
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_runtime_warning
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_runtime_log
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/*
+ * Runtime Trace
+ */
+
+#ifdef SIEVE_RUNTIME_TRACE
+
+void _sieve_runtime_trace
+	(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void _sieve_runtime_trace_error
+	(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+# define sieve_runtime_trace(runenv, ...) STMT_START { \
+		if ( (runenv)->trace_stream != NULL ) \
+			_sieve_runtime_trace((runenv), __VA_ARGS__); \
+	} STMT_END
+# define sieve_runtime_trace_error(runenv, ...) STMT_START { \
+		if ( (runenv)->trace_stream != NULL ) \
+			_sieve_runtime_trace_error((runenv), __VA_ARGS__); \
+		} STMT_END
+
+#else
+# define sieve_runtime_trace(runenv, ...)
+# define sieve_runtime_trace_error(runenv, ...)
+#endif
+
+/*
+ * Extension support
+ */
+
+struct sieve_interpreter_extension {
+	const struct sieve_extension_def *ext_def;
+
+	void (*run)
+		(const struct sieve_extension *ext, const struct sieve_runtime_env *renv,
+			void *context);
+	void (*free)
+		(const struct sieve_extension *ext, struct sieve_interpreter *interp,
+			void *context);
+};
+
+void sieve_interpreter_extension_register
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext,
+		const struct sieve_interpreter_extension *intext, void *context);
+void sieve_interpreter_extension_set_context
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext,
+		void *context);
+void *sieve_interpreter_extension_get_context
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext);
+
+/*
+ * Opcodes and operands
+ */
+
+int sieve_interpreter_handle_optional_operands
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_side_effects_list **list);
+
+/*
+ * Code execute
+ */
+
+int sieve_interpreter_continue
+	(struct sieve_interpreter *interp, bool *interrupted);
+int sieve_interpreter_start
+	(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_result *result,
+		bool *interrupted);
+int sieve_interpreter_run
+	(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_result *result);
+
+#endif /* __SIEVE_INTERPRETER_H */
Index: b/sieve/src/lib-sieve/sieve-lexer.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-lexer.c
@@ -0,0 +1,805 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "istream.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+
+#include "sieve-lexer.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+
+/*
+ * Useful macros
+ */
+
+#define DIGIT_VAL(c) ( c - '0' )
+
+/*
+ * Forward declarations
+ */
+
+inline static void sieve_lexer_error
+	(struct sieve_lexer *lexer, const char *fmt, ...) ATTR_FORMAT(2, 3);
+inline static void sieve_lexer_warning
+	(struct sieve_lexer *lexer, const char *fmt, ...) ATTR_FORMAT(2, 3);
+
+/*
+ * Lexer object
+ */
+
+struct sieve_lexer {
+	pool_t pool;
+
+	struct sieve_script *script;
+	struct istream *input;
+
+	int current_line;
+
+	enum sieve_token_type token_type;
+	string_t *token_str_value;
+	int token_int_value;
+
+	struct sieve_error_handler *ehandler;
+
+	/* Currently scanned data */
+	const unsigned char *buffer;
+	size_t buffer_size;
+	size_t buffer_pos;
+};
+
+struct sieve_lexer *sieve_lexer_create
+(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	pool_t pool;
+	struct sieve_lexer *lexer;
+	struct istream *stream;
+
+	stream = sieve_script_open(script, NULL);
+	if ( stream == NULL )
+		return NULL;
+
+	pool = pool_alloconly_create("sieve_lexer", 1024);
+	lexer = p_new(pool, struct sieve_lexer, 1);
+	lexer->pool = pool;
+
+	lexer->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	lexer->input = stream;
+	i_stream_ref(lexer->input);
+
+	lexer->script = script;
+	sieve_script_ref(script);
+
+	lexer->buffer = NULL;
+	lexer->buffer_size = 0;
+	lexer->buffer_pos = 0;
+
+	lexer->current_line = 1;
+	lexer->token_type = STT_NONE;
+	lexer->token_str_value = str_new(pool, 256);
+	lexer->token_int_value = 0;
+
+	return lexer;
+}
+
+void sieve_lexer_free(struct sieve_lexer **lexer)
+{
+	i_stream_unref(&(*lexer)->input);
+
+	sieve_script_close((*lexer)->script);
+	sieve_script_unref(&(*lexer)->script);
+
+	sieve_error_handler_unref(&(*lexer)->ehandler);
+
+	pool_unref(&(*lexer)->pool);
+
+	*lexer = NULL;
+}
+
+/*
+ * Internal error handling
+ */
+
+inline static void sieve_lexer_error
+(struct sieve_lexer *lexer, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN {
+		sieve_verror(lexer->ehandler,
+			sieve_error_script_location(lexer->script, lexer->current_line),
+			fmt, args);
+	} T_END;
+
+	va_end(args);
+}
+
+inline static void sieve_lexer_warning
+(struct sieve_lexer *lexer, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN {
+		sieve_vwarning(lexer->ehandler,
+			sieve_error_script_location(lexer->script, lexer->current_line),
+			fmt, args);
+	} T_END;
+
+	va_end(args);
+}
+
+const char *sieve_lexer_token_string(struct sieve_lexer *lexer)
+{
+	switch ( lexer->token_type ) {
+		case STT_NONE: return "no token (bug)";
+		case STT_WHITESPACE: return "whitespace (bug)";
+		case STT_EOF: return "end of file";
+
+		case STT_NUMBER: return "number";
+		case STT_IDENTIFIER: return "identifier";
+		case STT_TAG: return "tag";
+		case STT_STRING: return "string";
+
+		case STT_RBRACKET: return "')'";
+		case STT_LBRACKET: return "'('";
+		case STT_RCURLY: return "'}'";
+		case STT_LCURLY: return "'{'";
+		case STT_RSQUARE: return "']'";
+		case STT_LSQUARE: return "'['";
+		case STT_SEMICOLON: return "';'";
+		case STT_COMMA: return "','";
+
+		case STT_SLASH: return "'/'";
+		case STT_COLON: return "':'";
+
+		case STT_GARBAGE: return "unknown characters";
+		case STT_ERROR: return "error token (bug)";
+	}
+
+	return "unknown token (bug)";
+}
+
+/*
+ * Debug
+ */
+
+void sieve_lexer_print_token(struct sieve_lexer *lexer)
+{
+	switch ( lexer->token_type ) {
+		case STT_NONE: printf("??NONE?? "); break;
+		case STT_WHITESPACE: printf("??WHITESPACE?? "); break;
+		case STT_EOF: printf("EOF\n"); break;
+
+		case STT_NUMBER: printf("NUMBER "); break;
+		case STT_IDENTIFIER: printf("IDENTIFIER "); break;
+		case STT_TAG: printf("TAG "); break;
+		case STT_STRING: printf("STRING "); break;
+
+		case STT_RBRACKET: printf(") "); break;
+		case STT_LBRACKET: printf("( "); break;
+		case STT_RCURLY: printf("}\n"); break;
+		case STT_LCURLY: printf("{\n"); break;
+		case STT_RSQUARE: printf("] "); break;
+		case STT_LSQUARE: printf("[ "); break;
+		case STT_SEMICOLON: printf(";\n"); break;
+		case STT_COMMA: printf(", "); break;
+
+		case STT_SLASH: printf("/ "); break;
+		case STT_COLON: printf(": "); break;
+
+		case STT_GARBAGE: printf(">>GARBAGE<<"); break;
+		case STT_ERROR: printf(">>ERROR<<"); break;
+	default:
+		printf("UNKNOWN ");
+		break;
+	}
+}
+
+/*
+ * Token access
+ */
+
+enum sieve_token_type sieve_lexer_current_token(struct sieve_lexer *lexer)
+{
+	return lexer->token_type;
+}
+
+const string_t *sieve_lexer_token_str(struct sieve_lexer *lexer)
+{
+	i_assert(	lexer->token_type == STT_STRING );
+
+	return lexer->token_str_value;
+}
+
+const char *sieve_lexer_token_ident(struct sieve_lexer *lexer)
+{
+	i_assert(
+		lexer->token_type == STT_TAG ||
+		lexer->token_type == STT_IDENTIFIER);
+
+	return str_c(lexer->token_str_value);
+}
+
+int sieve_lexer_token_int(struct sieve_lexer *lexer)
+{
+	i_assert(lexer->token_type == STT_NUMBER);
+
+	return lexer->token_int_value;
+}
+
+bool sieve_lexer_eof(struct sieve_lexer *lexer)
+{
+	return lexer->token_type == STT_EOF;
+}
+
+int sieve_lexer_current_line(struct sieve_lexer *lexer)
+{
+	return lexer->current_line;
+}
+
+/*
+ * Lexical scanning
+ */
+
+static void sieve_lexer_shift(struct sieve_lexer *lexer)
+{
+	if ( lexer->buffer != NULL && lexer->buffer[lexer->buffer_pos] == '\n' )
+		lexer->current_line++;
+
+	if ( lexer->buffer != NULL && lexer->buffer_pos + 1 < lexer->buffer_size )
+		lexer->buffer_pos++;
+	else {
+		if ( lexer->buffer != NULL )
+			i_stream_skip(lexer->input, lexer->buffer_size);
+
+		lexer->buffer = i_stream_get_data(lexer->input, &lexer->buffer_size);
+
+		if ( lexer->buffer == NULL && i_stream_read(lexer->input) > 0 )
+	  		lexer->buffer = i_stream_get_data(lexer->input, &lexer->buffer_size);
+
+		lexer->buffer_pos = 0;
+	}
+}
+
+static inline int sieve_lexer_curchar(struct sieve_lexer *lexer)
+{
+	if ( lexer->buffer == NULL )
+		return -1;
+
+	return lexer->buffer[lexer->buffer_pos];
+}
+
+static inline const char *_char_sanitize(int ch)
+{
+	if ( ch > 31 && ch < 127 )
+		return t_strdup_printf("'%c'", ch);
+
+	return t_strdup_printf("0x%02x", ch);
+}
+
+/* sieve_lexer_scan_raw_token:
+ *   Scans valid tokens and whitespace
+ */
+static bool sieve_lexer_scan_raw_token(struct sieve_lexer *lexer)
+{
+	sieve_number_t start_line;
+	string_t *str;
+
+	/* Read first character */
+	if ( lexer->token_type == STT_NONE ) {
+		i_stream_read(lexer->input);
+		sieve_lexer_shift(lexer);
+	}
+
+	switch ( sieve_lexer_curchar(lexer) ) {
+
+	/* whitespace */
+
+	// hash-comment = ( "#" *CHAR-NOT-CRLF CRLF )
+	case '#':
+		sieve_lexer_shift(lexer);
+		while ( sieve_lexer_curchar(lexer) != '\n' ) {
+			switch( sieve_lexer_curchar(lexer) ) {
+			case -1:
+				sieve_lexer_warning(lexer, "no newline (CRLF) at end of hash comment at end of file");
+				lexer->token_type = STT_WHITESPACE;
+				return TRUE;
+			case '\0':
+				sieve_lexer_error(lexer, "encountered NUL character in hash comment");
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			default:
+				break;
+			}
+
+			/* Stray CR is ignored */
+
+			sieve_lexer_shift(lexer);
+		}
+
+		sieve_lexer_shift(lexer);
+
+		lexer->token_type = STT_WHITESPACE;
+		return TRUE;
+
+	// bracket-comment = "/*" *(CHAR-NOT-STAR / ("*" CHAR-NOT-SLASH)) "*/"
+	//        ;; No */ allowed inside a comment.
+	//        ;; (No * is allowed unless it is the last character,
+	//        ;; or unless it is followed by a character that isn't a
+	//        ;; slash.)
+	case '/':
+		start_line = lexer->current_line;
+		sieve_lexer_shift(lexer);
+
+		if ( sieve_lexer_curchar(lexer) == '*' ) {
+			sieve_lexer_shift(lexer);
+
+			while ( TRUE ) {
+				switch ( sieve_lexer_curchar(lexer) ) {
+				case -1:
+					sieve_lexer_error(lexer,
+						"end of file before end of bracket comment ('/* ... */') "
+						"started at line %d", start_line);
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				case '*':
+					sieve_lexer_shift(lexer);
+
+					if ( sieve_lexer_curchar(lexer) == '/' ) {
+						sieve_lexer_shift(lexer);
+
+						lexer->token_type = STT_WHITESPACE;
+						return TRUE;
+
+					} else if ( sieve_lexer_curchar(lexer) == -1 ) {
+						sieve_lexer_error(lexer,
+							"end of file before end of bracket comment ('/* ... */') "
+							"started at line %d", start_line);
+						lexer->token_type = STT_ERROR;
+						return FALSE;
+					}
+					break;
+				case '\0':
+					sieve_lexer_error(lexer,
+						"encountered NUL character in bracket comment");
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				default:
+					sieve_lexer_shift(lexer);
+				}
+			}
+
+			i_unreached();
+			return FALSE;
+		}
+
+		lexer->token_type = STT_SLASH;
+		return TRUE;
+
+	// comment = bracket-comment / hash-comment
+  	// white-space = 1*(SP / CRLF / HTAB) / comment
+	case '\t':
+	case '\r':
+	case '\n':
+	case ' ':
+		sieve_lexer_shift(lexer);
+
+		while ( sieve_lexer_curchar(lexer) == '\t' ||
+			sieve_lexer_curchar(lexer) == '\r' ||
+			sieve_lexer_curchar(lexer) == '\n' ||
+			sieve_lexer_curchar(lexer) == ' ' ) {
+
+			sieve_lexer_shift(lexer);
+		}
+
+		lexer->token_type = STT_WHITESPACE;
+		return TRUE;
+
+	/* quoted-string */
+	case '"':
+		start_line = lexer->current_line;
+		sieve_lexer_shift(lexer);
+		str_truncate(lexer->token_str_value, 0);
+		str = lexer->token_str_value;
+
+		while ( sieve_lexer_curchar(lexer) != '"' ) {
+			if ( sieve_lexer_curchar(lexer) == '\\' ) {
+				sieve_lexer_shift(lexer);
+			}
+
+			switch ( sieve_lexer_curchar(lexer) ) {
+
+			/* End of file */
+			case -1:
+				sieve_lexer_error(lexer,
+					"end of file before end of quoted string "
+					"started at line %d", start_line);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+
+			/* NUL character */
+			case '\0':
+				sieve_lexer_error(lexer,
+					"encountered NUL character in quoted string "
+					"started at line %d", start_line);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+
+			/* CR .. check for LF */
+			case '\r':
+				sieve_lexer_shift(lexer);
+
+				if ( sieve_lexer_curchar(lexer) != '\n' ) {
+					sieve_lexer_error(lexer,
+						"found stray carriage-return (CR) character "
+						"in quoted string started at line %d", start_line);
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				}
+
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN )
+					str_append(str, "\r\n");
+				break;
+
+			/* Loose LF is allowed (non-standard) and converted to CRLF */
+			case '\n':
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN )
+					str_append(str, "\r\n");
+				break;
+
+			/* Other characters */
+			default:
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN )
+					str_append_c(str, sieve_lexer_curchar(lexer));
+			}
+
+			sieve_lexer_shift(lexer);
+		}
+
+		sieve_lexer_shift(lexer);
+
+		if ( str_len(str) > SIEVE_MAX_STRING_LEN ) {
+			sieve_lexer_error(lexer,
+				"quoted string started at line %d is too long "
+				"(longer than %llu bytes)", start_line,
+				(long long) SIEVE_MAX_STRING_LEN);
+			lexer->token_type = STT_ERROR;
+			return FALSE;
+		}
+
+		lexer->token_type = STT_STRING;
+		return TRUE;
+
+	/* single character tokens */
+	case ']':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RSQUARE;
+		return TRUE;
+	case '[':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LSQUARE;
+		return TRUE;
+	case '}':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RCURLY;
+		return TRUE;
+	case '{':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LCURLY;
+		return TRUE;
+	case ')':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RBRACKET;
+		return TRUE;
+	case '(':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LBRACKET;
+		return TRUE;
+	case ';':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_SEMICOLON;
+		return TRUE;
+	case ',':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_COMMA;
+		return TRUE;
+
+	/* EOF */
+	case -1:
+	  lexer->token_type = STT_EOF;
+		return TRUE;
+
+	default:
+		/* number */
+		if ( i_isdigit(sieve_lexer_curchar(lexer)) ) {
+			sieve_number_t value = DIGIT_VAL(sieve_lexer_curchar(lexer));
+			bool overflow = FALSE;
+
+			sieve_lexer_shift(lexer);
+
+			while ( i_isdigit(sieve_lexer_curchar(lexer)) ) {
+				sieve_number_t valnew =
+					value * 10 + DIGIT_VAL(sieve_lexer_curchar(lexer));
+
+				/* Check for integer wrap */
+				if ( valnew < value )
+					overflow = TRUE;
+
+				value = valnew;
+				sieve_lexer_shift(lexer);
+ 			}
+
+			switch ( sieve_lexer_curchar(lexer) ) {
+			case 'k':
+			case 'K': /* Kilo */
+				if ( value > (SIEVE_MAX_NUMBER >> 10) )
+					overflow = TRUE;
+				else
+					value = value << 10;
+				sieve_lexer_shift(lexer);
+				break;
+			case 'm':
+			case 'M': /* Mega */
+				if ( value > (SIEVE_MAX_NUMBER >> 20) )
+					overflow = TRUE;
+				else
+					value = value << 20;
+				sieve_lexer_shift(lexer);
+				break;
+			case 'g':
+			case 'G': /* Giga */
+				if ( value > (SIEVE_MAX_NUMBER >> 30) )
+					overflow = TRUE;
+				else
+					value = value << 30;
+				sieve_lexer_shift(lexer);
+				break;
+			default:
+				/* Next token */
+				break;
+			}
+
+			/* Check for integer wrap */
+			if ( overflow ) {
+				sieve_lexer_error(lexer,
+					"number exceeds integer limits (max %llu)",
+					(long long) SIEVE_MAX_NUMBER);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+
+			lexer->token_type = STT_NUMBER;
+			lexer->token_int_value = value;
+			return TRUE;
+
+		/* identifier / tag */
+		} else if ( i_isalpha(sieve_lexer_curchar(lexer)) ||
+			sieve_lexer_curchar(lexer) == '_' ||
+			sieve_lexer_curchar(lexer) == ':' ) {
+
+			enum sieve_token_type type = STT_IDENTIFIER;
+			str_truncate(lexer->token_str_value,0);
+			str = lexer->token_str_value;
+
+			/* If it starts with a ':' it is a tag and not an identifier */
+ 			if ( sieve_lexer_curchar(lexer) == ':' ) {
+				sieve_lexer_shift(lexer); // discard colon
+				type = STT_TAG;
+
+				/* First character still can't be a DIGIT */
+ 				if ( i_isalpha(sieve_lexer_curchar(lexer)) ||
+					sieve_lexer_curchar(lexer) == '_' ) {
+					str_append_c(str, sieve_lexer_curchar(lexer));
+					sieve_lexer_shift(lexer);
+				} else {
+					/* Hmm, otherwise it is just a spurious colon */
+					lexer->token_type = STT_COLON;
+					return TRUE;
+				}
+			} else {
+				str_append_c(str, sieve_lexer_curchar(lexer));
+				sieve_lexer_shift(lexer);
+			}
+
+			/* Scan the rest of the identifier */
+			while ( i_isalnum(sieve_lexer_curchar(lexer)) ||
+				sieve_lexer_curchar(lexer) == '_' ) {
+
+				if ( str_len(str) <= SIEVE_MAX_IDENTIFIER_LEN ) {
+	 				str_append_c(str, sieve_lexer_curchar(lexer));
+				}
+				sieve_lexer_shift(lexer);
+			}
+
+			/* Is this in fact a multiline text string ? */
+			if ( sieve_lexer_curchar(lexer) == ':' &&
+				type == STT_IDENTIFIER && str_len(str) == 4 &&
+				strncasecmp(str_c(str), "text", 4) == 0 ) {
+				sieve_lexer_shift(lexer); // discard colon
+
+				start_line = lexer->current_line;
+
+				/* Discard SP and HTAB whitespace */
+				while ( sieve_lexer_curchar(lexer) == ' ' ||
+					sieve_lexer_curchar(lexer) == '\t' )
+ 					sieve_lexer_shift(lexer);
+
+				/* Discard hash comment or handle single CRLF */
+				switch ( sieve_lexer_curchar(lexer) ) {
+				case '#':
+					while ( sieve_lexer_curchar(lexer) != '\n' )
+						sieve_lexer_shift(lexer);
+					break;
+				case '\r':
+					sieve_lexer_shift(lexer);
+					break;
+				}
+
+				/* Terminating LF required */
+ 				switch ( sieve_lexer_curchar(lexer) ) {
+				case '\n':
+					sieve_lexer_shift(lexer);
+					break;
+				case -1:
+					sieve_lexer_error(lexer,
+						"end of file before end of multi-line string");
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				default:
+ 					sieve_lexer_error(lexer,
+ 						"invalid character %s after 'text:' in multiline string",
+						_char_sanitize(sieve_lexer_curchar(lexer)));
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				}
+
+				/* Start over */
+				str_truncate(str, 0);
+
+ 				/* Parse literal lines */
+				while ( TRUE ) {
+					bool cr_shifted = FALSE;
+
+					/* Remove dot-stuffing or detect end of text */
+					if ( sieve_lexer_curchar(lexer) == '.' ) {
+						sieve_lexer_shift(lexer);
+
+						/* Check for CR.. */
+						if ( sieve_lexer_curchar(lexer) == '\r' ) {
+							sieve_lexer_shift(lexer);
+							cr_shifted = TRUE;
+						}
+
+						/* ..LF */
+						if ( sieve_lexer_curchar(lexer) == '\n' ) {
+							sieve_lexer_shift(lexer);
+
+							/* End of multi-line string */
+
+							/* Check whether length limit was violated */
+							if ( str_len(str) > SIEVE_MAX_STRING_LEN ) {
+								sieve_lexer_error(lexer,
+									"multi-line string started at line %d is too long "
+									"(longer than %llu bytes)", start_line,
+									(long long) SIEVE_MAX_STRING_LEN);
+									lexer->token_type = STT_ERROR;
+									return FALSE;
+							}
+
+							lexer->token_type = STT_STRING;
+							return TRUE;
+						} else if ( cr_shifted ) {
+							/* Seen CR, but no LF */
+							sieve_lexer_error(lexer,
+								"found stray carriage-return (CR) character "
+								"in multi-line string started at line %d", start_line);
+							lexer->token_type = STT_ERROR;
+							return FALSE;
+						}
+
+						/* Handle dot-stuffing */
+						if ( str_len(str) <= SIEVE_MAX_STRING_LEN )
+							str_append_c(str, '.');
+						if ( sieve_lexer_curchar(lexer) == '.' )
+							sieve_lexer_shift(lexer);
+					}
+
+					/* Scan the rest of the line */
+					while ( sieve_lexer_curchar(lexer) != '\n' &&
+						sieve_lexer_curchar(lexer) != '\r' ) {
+
+						switch ( sieve_lexer_curchar(lexer) ) {
+						case -1:
+							sieve_lexer_error(lexer,
+								"end of file before end of multi-line string");
+ 							lexer->token_type = STT_ERROR;
+ 							return FALSE;
+						case '\0':
+							sieve_lexer_error(lexer,
+								"encountered NUL character in quoted string "
+								"started at line %d", start_line);
+							lexer->token_type = STT_ERROR;
+							return FALSE;
+						default:
+							if ( str_len(str) <= SIEVE_MAX_STRING_LEN )
+  								str_append_c(str, sieve_lexer_curchar(lexer));
+						}
+
+						sieve_lexer_shift(lexer);
+					}
+
+					/* If exited loop due to CR, skip it */
+					if ( sieve_lexer_curchar(lexer) == '\r' ) {
+						sieve_lexer_shift(lexer);
+					}
+
+					/* Now we must see an LF */
+					if ( sieve_lexer_curchar(lexer) != '\n' ) {
+						sieve_lexer_error(lexer,
+							"found stray carriage-return (CR) character "
+							"in multi-line string started at line %d", start_line);
+ 						lexer->token_type = STT_ERROR;
+ 						return FALSE;
+					}
+
+					if ( str_len(str) <= SIEVE_MAX_STRING_LEN )
+						str_append(str, "\r\n");
+
+					sieve_lexer_shift(lexer);
+				}
+
+ 				i_unreached();
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+
+			if ( str_len(str) > SIEVE_MAX_IDENTIFIER_LEN ) {
+				sieve_lexer_error(lexer,
+					"encountered impossibly long %s%s'",
+					(type == STT_TAG ? "tag identifier ':" : "identifier '"),
+					str_sanitize(str_c(str), SIEVE_MAX_IDENTIFIER_LEN));
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+
+			lexer->token_type = type;
+			return TRUE;
+		}
+
+		/* Error (unknown character and EOF handled already) */
+		if ( lexer->token_type != STT_GARBAGE )
+			sieve_lexer_error(lexer, "unexpected character(s) starting with %s",
+				_char_sanitize(sieve_lexer_curchar(lexer)));
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_GARBAGE;
+		return FALSE;
+	}
+}
+
+bool sieve_lexer_skip_token(struct sieve_lexer *lexer)
+{
+	/* Scan token while skipping whitespace */
+	do {
+		if ( !sieve_lexer_scan_raw_token(lexer) ) return FALSE;
+	} while ( lexer->token_type == STT_WHITESPACE );
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/sieve-lexer.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-lexer.h
@@ -0,0 +1,62 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_LEXER_H
+#define __SIEVE_LEXER_H
+
+#include "sieve-common.h"
+
+enum sieve_token_type {
+	STT_NONE,
+	STT_WHITESPACE,
+	STT_EOF,
+
+	STT_NUMBER,
+	STT_IDENTIFIER,
+	STT_TAG,
+	STT_STRING,
+
+	STT_RBRACKET,
+	STT_LBRACKET,
+	STT_RCURLY,
+	STT_LCURLY,
+	STT_RSQUARE,
+	STT_LSQUARE,
+	STT_SEMICOLON,
+	STT_COMMA,
+
+	/* These are currently not used in the lexical specification, but a token
+	 * is assigned to these to generate proper error messages (these are
+	 * technically not garbage and possibly part of mistyped but otherwise
+	 * valid tokens).
+	 */
+	STT_SLASH,
+	STT_COLON,
+
+	/* Error tokens */
+	STT_GARBAGE, /* Error reporting deferred to parser */
+	STT_ERROR    /* Lexer is responsible for error, parser won't report additional
+	                errors */
+};
+
+struct sieve_lexer;
+
+/* Lexer object */
+struct sieve_lexer *sieve_lexer_create
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+void sieve_lexer_free(struct sieve_lexer **lexer);
+
+/* Scanning */
+bool sieve_lexer_skip_token(struct sieve_lexer *lexer);
+const char *sieve_lexer_token_string(struct sieve_lexer *lexer);
+void sieve_lexer_print_token(struct sieve_lexer *lexer);
+
+/* Token access */
+enum sieve_token_type sieve_lexer_current_token(struct sieve_lexer *lexer);
+const string_t *sieve_lexer_token_str(struct sieve_lexer *lexer);
+const char *sieve_lexer_token_ident(struct sieve_lexer *lexer);
+int sieve_lexer_token_int(struct sieve_lexer *lexer);
+int sieve_lexer_current_line(struct sieve_lexer *lexer);
+bool sieve_lexer_eof(struct sieve_lexer *lexer);
+
+#endif /* __SIEVE_LEXER_H */
Index: b/sieve/src/lib-sieve/sieve-limits.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-limits.h
@@ -0,0 +1,35 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_LIMITS_H
+#define __SIEVE_LIMITS_H
+
+/*
+ * Lexer
+ */
+
+#define SIEVE_MAX_STRING_LEN        (1 << 20)
+#define SIEVE_MAX_IDENTIFIER_LEN    32
+
+/*
+ * AST
+ */
+
+#define SIEVE_MAX_COMMAND_ARGUMENTS 32
+#define SIEVE_MAX_BLOCK_NESTING     32
+#define SIEVE_MAX_TEST_NESTING      32
+
+/*
+ * Runtime
+ */
+
+#define SIEVE_MAX_MATCH_VALUES      32
+
+/*
+ * Actions
+ */
+
+#define SIEVE_DEFAULT_MAX_ACTIONS   32
+#define SIEVE_DEFAULT_MAX_REDIRECTS 4
+
+#endif /* __SIEVE_LIMITS_H */
Index: b/sieve/src/lib-sieve/sieve-match-types.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-match-types.c
@@ -0,0 +1,553 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+
+#include "lib.h"
+#include "compat.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-comparators.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-match-types.h"
+
+#include <string.h>
+
+/*
+ * Types
+ */
+
+struct sieve_match_values {
+	pool_t pool;
+	ARRAY_DEFINE(values, string_t *);
+	unsigned count;
+};
+
+/*
+ * Default match types
+ */
+
+const struct sieve_match_type_def *sieve_core_match_types[] = {
+	&is_match_type, &contains_match_type, &matches_match_type
+};
+
+const unsigned int sieve_core_match_types_count =
+	N_ELEMENTS(sieve_core_match_types);
+
+/*
+ * Match-type 'extension'
+ */
+
+static bool mtch_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+
+const struct sieve_extension_def match_type_extension = {
+	"@match-types",
+	NULL, NULL,
+	mtch_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/*
+ * Validator context:
+ *   name-based match-type registry.
+ */
+
+static struct sieve_validator_object_registry *_get_object_registry
+(struct sieve_validator *valdtr)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *mcht_ext;
+
+	svinst = sieve_validator_svinst(valdtr);
+	mcht_ext = sieve_get_match_type_extension(svinst);
+	return sieve_validator_object_registry_get(valdtr, mcht_ext);
+}
+
+void sieve_match_type_register
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct sieve_match_type_def *mcht_def)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+
+	sieve_validator_object_registry_add(regs, ext, &mcht_def->obj_def);
+}
+
+static bool sieve_match_type_exists
+(struct sieve_validator *valdtr, const char *identifier)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+
+	return sieve_validator_object_registry_find(regs, identifier, NULL);
+}
+
+static const struct sieve_match_type *sieve_match_type_create_instance
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const char *identifier)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+	struct sieve_object object;
+	struct sieve_match_type *mcht;
+
+	if ( !sieve_validator_object_registry_find(regs, identifier, &object) )
+		return NULL;
+
+	mcht = p_new(sieve_command_pool(cmd), struct sieve_match_type, 1);
+	mcht->object = object;
+	mcht->def = (const struct sieve_match_type_def *) object.def;
+
+  return mcht;
+}
+
+bool mtch_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	struct sieve_validator_object_registry *regs =
+		sieve_validator_object_registry_init(valdtr, ext);
+	unsigned int i;
+
+	/* Register core match-types */
+	for ( i = 0; i < sieve_core_match_types_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, NULL, &(sieve_core_match_types[i]->obj_def));
+	}
+
+	return TRUE;
+}
+
+/*
+ * Interpreter context
+ */
+
+struct mtch_interpreter_context {
+	struct sieve_match_values *match_values;
+	bool match_values_enabled;
+};
+
+static void mtch_interpreter_free
+(const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_interpreter *interp ATTR_UNUSED, void *context)
+{
+	struct mtch_interpreter_context *mctx =
+		(struct mtch_interpreter_context *) context;
+
+	if ( mctx->match_values != NULL ) {
+		pool_unref(&mctx->match_values->pool);
+	}
+}
+
+struct sieve_interpreter_extension mtch_interpreter_extension = {
+	&match_type_extension,
+	NULL,
+	mtch_interpreter_free
+};
+
+static inline struct mtch_interpreter_context *get_interpreter_context
+(struct sieve_interpreter *interp, bool create)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *mcht_ext;
+	struct mtch_interpreter_context *ctx;
+
+	svinst = sieve_interpreter_svinst(interp);
+	mcht_ext = sieve_get_match_type_extension(svinst);
+
+	ctx = (struct mtch_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, mcht_ext);
+
+	if ( ctx == NULL && create ) {
+		pool_t pool = sieve_interpreter_pool(interp);
+		ctx = p_new(pool, struct mtch_interpreter_context, 1);
+
+		sieve_interpreter_extension_register
+			(interp, mcht_ext, &mtch_interpreter_extension, (void *) ctx);
+	}
+
+	return ctx;
+}
+
+/*
+ * Match values
+ */
+
+bool sieve_match_values_set_enabled
+(struct sieve_interpreter *interp, bool enable)
+{
+	struct mtch_interpreter_context *ctx =
+		get_interpreter_context(interp, enable);
+
+	if ( ctx != NULL ) {
+		bool previous = ctx->match_values_enabled;
+
+		ctx->match_values_enabled = enable;
+		return previous;
+	}
+
+	return FALSE;
+}
+
+bool sieve_match_values_are_enabled
+(struct sieve_interpreter *interp)
+{
+	struct mtch_interpreter_context *ctx =
+		get_interpreter_context(interp, FALSE);
+
+	return ( ctx == NULL ? FALSE : ctx->match_values_enabled );
+}
+
+struct sieve_match_values *sieve_match_values_start
+(struct sieve_interpreter *interp)
+{
+	struct mtch_interpreter_context *ctx =
+		get_interpreter_context(interp, FALSE);
+	struct sieve_match_values *match_values;
+
+	if ( ctx == NULL || !ctx->match_values_enabled )
+		return NULL;
+
+	pool_t pool = pool_alloconly_create("sieve_match_values", 1024);
+
+	match_values = p_new(pool, struct sieve_match_values, 1);
+	match_values->pool = pool;
+	match_values->count = 0;
+
+	p_array_init(&match_values->values, pool, 4);
+
+	return match_values;
+}
+
+static string_t *sieve_match_values_add_entry
+(struct sieve_match_values *mvalues)
+{
+	string_t *entry;
+
+	if ( mvalues == NULL ) return NULL;
+
+	if ( mvalues->count >= SIEVE_MAX_MATCH_VALUES ) return NULL;
+
+	if ( mvalues->count >= array_count(&mvalues->values) ) {
+		entry = str_new(mvalues->pool, 64);
+		array_append(&mvalues->values, &entry, 1);	} else {
+		string_t * const *ep = array_idx(&mvalues->values, mvalues->count);
+		entry = *ep;
+		str_truncate(entry, 0);
+	}
+
+	mvalues->count++;
+
+	return entry;
+}
+
+void sieve_match_values_set
+(struct sieve_match_values *mvalues, unsigned int index, string_t *value)
+{
+	if ( mvalues != NULL && index < array_count(&mvalues->values) ) {
+		string_t * const *ep = array_idx(&mvalues->values, index);
+    	string_t *entry = *ep;
+
+	    if ( entry != NULL && value != NULL ) {
+			str_truncate(entry, 0);
+        	str_append_str(entry, value);
+		}
+	}
+}
+
+void sieve_match_values_add
+(struct sieve_match_values *mvalues, string_t *value)
+{
+	string_t *entry = sieve_match_values_add_entry(mvalues);
+
+	if ( entry != NULL && value != NULL )
+		str_append_str(entry, value);
+}
+
+void sieve_match_values_add_char
+(struct sieve_match_values *mvalues, char c)
+{
+	string_t *entry = sieve_match_values_add_entry(mvalues);
+
+	if ( entry != NULL )
+		str_append_c(entry, c);
+}
+
+void sieve_match_values_skip
+(struct sieve_match_values *mvalues, int num)
+{
+	int i;
+
+	for ( i = 0; i < num; i++ )
+		(void) sieve_match_values_add_entry(mvalues);
+}
+
+void sieve_match_values_commit
+(struct sieve_interpreter *interp, struct sieve_match_values **mvalues)
+{
+	struct mtch_interpreter_context *ctx;
+
+	if ( (*mvalues) == NULL ) return;
+
+	ctx = get_interpreter_context(interp, FALSE);
+	if ( ctx == NULL || !ctx->match_values_enabled )
+		return;
+
+	if ( ctx->match_values != NULL ) {
+		pool_unref(&ctx->match_values->pool);
+		ctx->match_values = NULL;
+	}
+
+	ctx->match_values = *mvalues;
+	*mvalues = NULL;
+}
+
+void sieve_match_values_abort
+(struct sieve_match_values **mvalues)
+{
+	if ( (*mvalues) == NULL ) return;
+
+	pool_unref(&(*mvalues)->pool);
+	*mvalues = NULL;
+}
+
+void sieve_match_values_get
+(struct sieve_interpreter *interp, unsigned int index, string_t **value_r)
+{
+	struct mtch_interpreter_context *ctx =
+		get_interpreter_context(interp, FALSE);
+	struct sieve_match_values *mvalues;
+
+	if ( ctx == NULL || ctx->match_values == NULL ) {
+		*value_r = NULL;
+		return;
+	}
+
+	mvalues = ctx->match_values;
+	if ( index < array_count(&mvalues->values) && index < mvalues->count ) {
+		string_t * const *entry = array_idx(&mvalues->values, index);
+
+		*value_r = *entry;
+		return;
+	}
+
+	*value_r = NULL;
+}
+
+/*
+ * Match-type tagged argument
+ */
+
+/* Forward declarations */
+
+static bool tag_match_type_is_instance_of
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		const struct sieve_extension *ext, const char *identifier, void **data);
+static bool tag_match_type_validate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool tag_match_type_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+/* Argument object */
+
+const struct sieve_argument_def match_type_tag = {
+	"MATCH-TYPE",
+	tag_match_type_is_instance_of,
+	tag_match_type_validate,
+	NULL,	NULL,
+	tag_match_type_generate
+};
+
+/* Argument implementation */
+
+static bool tag_match_type_is_instance_of
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const struct sieve_extension *ext ATTR_UNUSED, const char *identifier,
+	void **data)
+{
+	const struct sieve_match_type *mcht;
+
+	if ( data == NULL )
+		return sieve_match_type_exists(valdtr, identifier);
+
+	if ( (mcht=sieve_match_type_create_instance
+		(valdtr, cmd, identifier)) == NULL )
+		return FALSE;
+
+	*data = (void *) mcht;
+	return TRUE;
+}
+
+static bool tag_match_type_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	const struct sieve_match_type *mcht =
+		(const struct sieve_match_type *) (*arg)->argument->data;
+	struct sieve_match_type_context *mtctx;
+
+	mtctx = p_new(sieve_command_pool(cmd), struct sieve_match_type_context, 1);
+	mtctx->match_type = mcht;
+	mtctx->argument = *arg;
+	mtctx->comparator = NULL; /* Can be filled in later */
+
+	(*arg)->argument->data = mtctx;
+
+	/* Syntax:
+	 *   ":is" / ":contains" / ":matches" (subject to extension)
+	 */
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	/* Check whether this match type requires additional validation.
+	 * Additional validation can override the match type recorded in the context
+	 * for later code generation.
+	 */
+	if ( mcht->def != NULL && mcht->def->validate != NULL ) {
+		return mcht->def->validate(valdtr, arg, mtctx);
+	}
+
+	return TRUE;
+}
+
+static bool tag_match_type_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	struct sieve_match_type_context *mtctx =
+		(struct sieve_match_type_context *) arg->argument->data;
+
+	(void) sieve_opr_match_type_emit(cgenv->sbin, mtctx->match_type);
+
+	return TRUE;
+}
+
+void sieve_match_types_link_tags
+(struct sieve_validator *valdtr,
+	struct sieve_command_registration *cmd_reg, int id_code)
+{
+	struct sieve_instance *svinst;
+	const struct sieve_extension *mcht_ext;
+
+	svinst = sieve_validator_svinst(valdtr);
+	mcht_ext = sieve_get_comparator_extension(svinst);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, mcht_ext, &match_type_tag, id_code);
+}
+
+/*
+ * Validation
+ */
+
+bool sieve_match_type_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *key_arg,
+	const struct sieve_match_type *mcht_default,
+	const struct sieve_comparator *cmp_default)
+{
+	struct sieve_ast_argument *arg = sieve_command_first_argument(cmd);
+	struct sieve_ast_argument *mt_arg = NULL;
+	struct sieve_match_type_context *mtctx;
+	const struct sieve_match_type *mcht = NULL;
+	const struct sieve_comparator *cmp = NULL;
+
+	/* Find match type and comparator among the arguments */
+	while ( arg != NULL && arg != cmd->first_positional ) {
+		if ( sieve_argument_is_comparator(arg) ) {
+			cmp = sieve_comparator_tag_get(arg);
+			if ( mt_arg != NULL ) break;
+		}
+
+		if ( sieve_argument_is_match_type(arg) ) {
+			mt_arg = arg;
+			if ( cmp != NULL ) break;
+		}
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Verify using the default comparator if none is specified explicitly */
+	if ( cmp == NULL ) {
+		cmp = sieve_comparator_copy(sieve_command_pool(cmd), cmp_default);
+	}
+
+	/* Verify the default match type if none is specified explicitly */
+	if ( mt_arg == NULL || mt_arg->argument == NULL ||
+		mt_arg->argument->data == NULL ) {
+		mtctx = NULL;
+		mcht = sieve_match_type_copy(sieve_command_pool(cmd), mcht_default);
+	} else {
+		mtctx = (struct sieve_match_type_context *) mt_arg->argument->data;
+		mcht = mtctx->match_type;
+		mtctx->comparator = cmp;
+	}
+
+	/* Check whether this match type requires additional validation.
+	 * Additional validation can override the match type recorded in the context
+	 * for later code generation.
+	 */
+	if ( mcht != NULL && mcht->def != NULL &&
+		mcht->def->validate_context != NULL ) {
+		return mcht->def->validate_context(valdtr, mt_arg, mtctx, key_arg);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Match-type operand
+ */
+
+const struct sieve_operand_class sieve_match_type_operand_class =
+	{ "match type" };
+
+static const struct sieve_extension_objects core_match_types =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(sieve_core_match_types);
+
+const struct sieve_operand_def match_type_operand = {
+	"match-type",
+	NULL,
+	SIEVE_OPERAND_MATCH_TYPE,
+	&sieve_match_type_operand_class,
+	&core_match_types
+};
+
+/*
+ * Common validation implementation
+ */
+
+bool sieve_match_substring_validate_context
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	struct sieve_match_type_context *ctx,
+	struct sieve_ast_argument *key_arg ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = ctx->comparator;
+
+	if ( cmp == NULL || cmp->def == NULL )
+		return TRUE;
+
+	if ( (cmp->def->flags & SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH) == 0 ) {
+		sieve_argument_validate_error(valdtr, arg,
+			"the specified %s comparator does not support "
+			"sub-string matching as required by the :%s match type",
+			cmp->object.def->identifier, ctx->match_type->object.def->identifier );
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/sieve-match-types.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-match-types.h
@@ -0,0 +1,235 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_MATCH_TYPES_H
+#define __SIEVE_MATCH_TYPES_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-objects.h"
+
+/*
+ * Types
+ */
+
+struct sieve_match_type_context;
+
+/*
+ * Core match types
+ */
+
+enum sieve_match_type_code {
+	SIEVE_MATCH_TYPE_IS,
+	SIEVE_MATCH_TYPE_CONTAINS,
+	SIEVE_MATCH_TYPE_MATCHES,
+	SIEVE_MATCH_TYPE_CUSTOM
+};
+
+extern const struct sieve_match_type_def is_match_type;
+extern const struct sieve_match_type_def contains_match_type;
+extern const struct sieve_match_type_def matches_match_type;
+
+/*
+ * Match type definition
+ */
+
+struct sieve_match_type_def {
+	struct sieve_object_def obj_def;
+
+	/* Match function called for every key value or should it be called once
+	 * for every tested value? (TRUE = first alternative)
+	 */
+	bool is_iterative;
+
+	/* Is the key value allowed to contain formatting to extract multiple keys
+	 * out of the same string?
+	 */
+	bool allow_key_extract;
+
+	bool (*validate)
+		(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+			struct sieve_match_type_context *ctx);
+	bool (*validate_context)
+		(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+			struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg);
+
+	/*
+	 * Matching
+ 	 */
+
+	void (*match_init)(struct sieve_match_context *mctx);
+
+	/* WARNING: some tests may pass a val == NULL parameter indicating that the
+	 * passed value has no significance. For string-type matches this should map
+	 * to the empty string "", but for match types that consider the passed values
+	 * as objects rather than strings (e.g. :count) this means that the passed
+	 * value should be skipped.
+	 */
+	int (*match)
+		(struct sieve_match_context *mctx, const char *val, size_t val_size,
+			const char *key, size_t key_size, int key_index);
+	int (*match_deinit)(struct sieve_match_context *mctx);
+};
+
+/*
+ * Match type instance
+ */
+
+struct sieve_match_type {
+	struct sieve_object object;
+
+	const struct sieve_match_type_def *def;
+};
+
+#define SIEVE_MATCH_TYPE_DEFAULT(definition) \
+	{ SIEVE_OBJECT_DEFAULT(definition), &(definition) }
+
+#define sieve_match_type_name(mcht) \
+	( (mcht)->object.def->identifier )
+
+static inline const struct sieve_match_type *sieve_match_type_copy
+(pool_t pool, const struct sieve_match_type *cmp_orig)
+{
+	struct sieve_match_type *cmp = p_new(pool, struct sieve_match_type, 1);
+
+	*cmp = *cmp_orig;
+
+	return cmp;
+}
+
+/*
+ * Match type context
+ */
+
+struct sieve_match_type_context {
+	struct sieve_command *command;
+	struct sieve_ast_argument *argument;
+
+	const struct sieve_match_type *match_type;
+
+	/* Only filled in when match_type->validate_context() is called */
+	const struct sieve_comparator *comparator;
+
+	/* Context data could be used in the future to pass data between validator and
+	 * generator in match types that use extra parameters. Currently not
+	 * necessary, not even for the relational extension.
+	 */
+	void *ctx_data;
+};
+
+/*
+ * Match type registration
+ */
+
+void sieve_match_type_register
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		const struct sieve_match_type_def *mcht);
+
+/*
+ * Match values
+ */
+
+struct sieve_match_values;
+
+bool sieve_match_values_set_enabled
+	(struct sieve_interpreter *interp, bool enable);
+bool sieve_match_values_are_enabled
+	(struct sieve_interpreter *interp);
+
+struct sieve_match_values *sieve_match_values_start
+	(struct sieve_interpreter *interp);
+void sieve_match_values_set
+	(struct sieve_match_values *mvalues, unsigned int index, string_t *value);
+void sieve_match_values_add
+	(struct sieve_match_values *mvalues, string_t *value);
+void sieve_match_values_add_char
+	(struct sieve_match_values *mvalues, char c);
+void sieve_match_values_skip
+	(struct sieve_match_values *mvalues, int num);
+
+void sieve_match_values_commit
+	(struct sieve_interpreter *interp, struct sieve_match_values **mvalues);
+void sieve_match_values_abort
+	(struct sieve_match_values **mvalues);
+
+void sieve_match_values_get
+	(struct sieve_interpreter *interp, unsigned int index, string_t **value_r);
+
+/*
+ * Match type tagged argument
+ */
+
+extern const struct sieve_argument_def match_type_tag;
+
+static inline bool sieve_argument_is_match_type
+	(struct sieve_ast_argument *arg)
+{
+	return ( arg->argument->def == &match_type_tag );
+}
+
+void sieve_match_types_link_tags
+	(struct sieve_validator *valdtr,
+		struct sieve_command_registration *cmd_reg, int id_code);
+
+/*
+ * Validation
+ */
+
+bool sieve_match_type_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		struct sieve_ast_argument *key_arg,
+		const struct sieve_match_type *mcht_default,
+		const struct sieve_comparator *cmp_default);
+
+/*
+ * Match type operand
+ */
+
+extern const struct sieve_operand_def match_type_operand;
+extern const struct sieve_operand_class sieve_match_type_operand_class;
+
+#define SIEVE_EXT_DEFINE_MATCH_TYPE(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_MATCH_TYPES(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+static inline bool sieve_operand_is_match_type
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->def != NULL &&
+		operand->def->class == &sieve_match_type_operand_class );
+}
+
+static inline void sieve_opr_match_type_emit
+(struct sieve_binary *sbin, const struct sieve_match_type *mcht)
+{
+	sieve_opr_object_emit(sbin, mcht->object.ext, mcht->object.def);
+}
+
+static inline bool sieve_opr_match_type_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_match_type *mcht)
+{
+	if ( !sieve_opr_object_read
+		(renv, &sieve_match_type_operand_class, address, &mcht->object) )
+		return FALSE;
+
+	mcht->def = (const struct sieve_match_type_def *) mcht->object.def;
+	return TRUE;
+}
+
+static inline bool sieve_opr_match_type_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_match_type_operand_class, address, NULL);
+}
+
+/* Common validation implementation */
+
+bool sieve_match_substring_validate_context
+	(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+		struct sieve_match_type_context *ctx,
+		struct sieve_ast_argument *key_arg);
+
+#endif /* __SIEVE_MATCH_TYPES_H */
Index: b/sieve/src/lib-sieve/sieve-match.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-match.c
@@ -0,0 +1,204 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+
+#include "sieve-match.h"
+
+/*
+ * Matching implementation
+ */
+
+struct sieve_match_context *sieve_match_begin
+(struct sieve_interpreter *interp, const struct sieve_match_type *mcht,
+	const struct sieve_comparator *cmp,
+	const struct sieve_match_key_extractor *kextract,
+	struct sieve_coded_stringlist *key_list)
+{
+	struct sieve_match_context *mctx;
+	pool_t pool;
+
+	pool = pool_alloconly_create("sieve_match_context", 1024);
+	mctx = p_new(pool, struct sieve_match_context, 1);
+
+	mctx->pool = pool;
+	mctx->interp = interp;
+	mctx->match_type = mcht;
+	mctx->comparator = cmp;
+	mctx->kextract = kextract;
+	mctx->key_list = key_list;
+
+	if ( mcht->def != NULL && mcht->def->match_init != NULL ) {
+		mcht->def->match_init(mctx);
+	}
+
+	return mctx;
+}
+
+int sieve_match_value
+	(struct sieve_match_context *mctx, const char *value, size_t val_size)
+{
+	const struct sieve_match_type *mcht = mctx->match_type;
+	sieve_coded_stringlist_reset(mctx->key_list);
+	bool ok = TRUE;
+
+	/* Reject unimplemented match-type */
+	if ( mcht->def == NULL || mcht->def->match == NULL )
+		return FALSE;
+
+	/* Match to all key values */
+	if ( mcht->def->is_iterative ) {
+		unsigned int key_index = 0;
+		string_t *key_item = NULL;
+		int ret = 0;
+
+		while ( (ok=sieve_coded_stringlist_next_item(mctx->key_list, &key_item))
+			&& key_item != NULL ) {
+			T_BEGIN {
+				if ( mctx->kextract != NULL && mcht->def->allow_key_extract ) {
+					const struct sieve_match_key_extractor *kext = mctx->kextract;
+					void *kctx;
+
+					if ( (ret=kext->init(&kctx, key_item)) > 0 ) {
+						const char *key;
+						size_t key_size;
+
+						while ( (ret=kext->extract_key(kctx, &key, &key_size)) > 0 ) {
+							ret = mcht->def->match
+								(mctx, value, val_size, key, key_size, key_index);
+
+							if ( ret != 0 ) break;
+						}
+					}
+				} else {
+					ret = mcht->def->match(mctx, value, val_size, str_c(key_item),
+							str_len(key_item), key_index);
+				}
+			} T_END;
+
+			if ( ret != 0 )
+				break;
+
+			key_index++;
+		}
+
+		if ( !ok )
+			return -1;
+
+		if ( ret < 0 )
+			return ret;
+		if ( ret > 0 )
+			return TRUE;
+
+	} else {
+		bool result;
+
+		T_BEGIN {
+			result = mcht->def->match(mctx, value, val_size, NULL, 0, -1);
+		} T_END;
+
+		return result;
+	}
+
+	return FALSE;
+}
+
+int sieve_match_end(struct sieve_match_context **mctx)
+{
+	const struct sieve_match_type *mcht = (*mctx)->match_type;
+	int ret = FALSE;
+
+	if ( mcht->def != NULL && mcht->def->match_deinit != NULL ) {
+		ret = mcht->def->match_deinit(*mctx);
+	}
+
+	pool_unref(&(*mctx)->pool);
+	*mctx = NULL;
+
+	return ret;
+}
+
+/*
+ * Reading match operands
+ */
+
+bool sieve_match_dump_optional_operands
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, int *opt_code)
+{
+	if ( *opt_code != SIEVE_MATCH_OPT_END ||
+		sieve_operand_optional_present(denv->sbin, address) ) {
+		do {
+			if ( !sieve_operand_optional_read(denv->sbin, address, opt_code) )
+				return FALSE;
+
+			switch ( *opt_code ) {
+			case SIEVE_MATCH_OPT_END:
+				break;
+			case SIEVE_MATCH_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_MATCH_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			default:
+				return TRUE;
+			}
+ 		} while ( *opt_code != SIEVE_MATCH_OPT_END );
+	}
+
+	return TRUE;
+}
+
+int sieve_match_read_optional_operands
+(const struct sieve_runtime_env *renv, sieve_size_t *address, int *opt_code,
+	struct sieve_comparator *cmp, struct sieve_match_type *mcht)
+{
+	/* Handle any optional arguments */
+	if ( *opt_code != SIEVE_MATCH_OPT_END ||
+		sieve_operand_optional_present(renv->sbin, address) ) {
+		do {
+			if ( !sieve_operand_optional_read(renv->sbin, address, opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( *opt_code ) {
+			case SIEVE_MATCH_OPT_END:
+				break;
+			case SIEVE_MATCH_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_read(renv, address, cmp) ) {
+					sieve_runtime_trace_error(renv, "invalid comparator operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case SIEVE_MATCH_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_read(renv, address, mcht) ) {
+					sieve_runtime_trace_error(renv, "invalid match type operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				return SIEVE_EXEC_OK;
+			}
+		} while ( *opt_code != SIEVE_MATCH_OPT_END );
+	}
+
+	return SIEVE_EXEC_OK;
+}
+
Index: b/sieve/src/lib-sieve/sieve-match.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-match.h
@@ -0,0 +1,63 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_MATCH_H
+#define __SIEVE_MATCH_H
+
+#include "sieve-common.h"
+
+/*
+ * Matching context
+ */
+
+struct sieve_match_key_extractor {
+	int (*init)(void **context, string_t *raw_key);
+	int (*extract_key)(void *context, const char **key, size_t *size);
+};
+
+struct sieve_match_context {
+	pool_t pool;
+
+	struct sieve_interpreter *interp;
+	const struct sieve_match_type *match_type;
+	const struct sieve_comparator *comparator;
+	const struct sieve_match_key_extractor *kextract;
+
+	struct sieve_coded_stringlist *key_list;
+
+
+	void *data;
+};
+
+/*
+ * Matching implementation
+ */
+
+struct sieve_match_context *sieve_match_begin
+	(struct sieve_interpreter *interp, const struct sieve_match_type *mtch,
+		const struct sieve_comparator *cmp,
+		const struct sieve_match_key_extractor *kextract,
+		struct sieve_coded_stringlist *key_list);
+int sieve_match_value
+	(struct sieve_match_context *mctx, const char *value, size_t val_size);
+int sieve_match_end(struct sieve_match_context **mctx);
+
+/*
+ * Read matching operands
+ */
+
+enum sieve_match_opt_operand {
+	SIEVE_MATCH_OPT_END,
+	SIEVE_MATCH_OPT_COMPARATOR,
+	SIEVE_MATCH_OPT_MATCH_TYPE,
+	SIEVE_MATCH_OPT_LAST
+};
+
+bool sieve_match_dump_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *addres, int *opt_code);
+
+int sieve_match_read_optional_operands
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, int *opt_code,
+		struct sieve_comparator *cmp, struct sieve_match_type *mcht);
+
+#endif /* __SIEVE_MATCH_H */
Index: b/sieve/src/lib-sieve/sieve-message.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-message.c
@@ -0,0 +1,195 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-address.h"
+
+#include "sieve-message.h"
+
+/*
+ * Message transmission
+ */
+
+const char *sieve_message_get_new_id
+(const struct sieve_script_env *senv)
+{
+	static int count = 0;
+
+	return t_strdup_printf("<dovecot-sieve-%s-%s-%d@%s>",
+		dec2str(ioloop_timeval.tv_sec), dec2str(ioloop_timeval.tv_usec),
+    count++, senv->hostname);
+}
+
+/*
+ * Message context
+ */
+
+struct sieve_message_context {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_instance *svinst;
+
+	const struct sieve_message_data *msgdata;
+
+	/* Normalized envelope addresses */
+
+	bool envelope_parsed;
+
+	const struct sieve_address *envelope_sender;
+	const struct sieve_address *envelope_recipient;
+
+	/* Context data for extensions */
+	ARRAY_DEFINE(ext_contexts, void *);
+};
+
+struct sieve_message_context *sieve_message_context_create
+(struct sieve_instance *svinst, const struct sieve_message_data *msgdata)
+{
+	struct sieve_message_context *msgctx;
+
+	msgctx = i_new(struct sieve_message_context, 1);
+	msgctx->refcount = 1;
+	msgctx->svinst = svinst;
+
+	msgctx->msgdata = msgdata;
+
+	sieve_message_context_flush(msgctx);
+
+	return msgctx;
+}
+
+void sieve_message_context_ref(struct sieve_message_context *msgctx)
+{
+	msgctx->refcount++;
+}
+
+void sieve_message_context_unref(struct sieve_message_context **msgctx)
+{
+	i_assert((*msgctx)->refcount > 0);
+
+	if (--(*msgctx)->refcount != 0)
+		return;
+
+	pool_unref(&((*msgctx)->pool));
+
+	i_free(*msgctx);
+	*msgctx = NULL;
+}
+
+void sieve_message_context_flush(struct sieve_message_context *msgctx)
+{
+	pool_t pool;
+
+	if ( msgctx->pool != NULL ) {
+		pool_unref(&msgctx->pool);
+	}
+
+	pool = pool_alloconly_create("sieve_message_context", 1024);
+	msgctx->pool = pool;
+
+	msgctx->envelope_recipient = NULL;
+	msgctx->envelope_sender = NULL;
+	msgctx->envelope_parsed = FALSE;
+
+	p_array_init(&msgctx->ext_contexts, pool,
+		sieve_extensions_get_count(msgctx->svinst));
+}
+
+pool_t sieve_message_context_pool(struct sieve_message_context *msgctx)
+{
+	return msgctx->pool;
+}
+
+/* Extension support */
+
+void sieve_message_context_extension_set
+(struct sieve_message_context *msgctx, const struct sieve_extension *ext,
+	void *context)
+{
+	if ( ext->id < 0 ) return;
+
+	array_idx_set(&msgctx->ext_contexts, (unsigned int) ext->id, &context);
+}
+
+const void *sieve_message_context_extension_get
+(struct sieve_message_context *msgctx, const struct sieve_extension *ext)
+{
+	void * const *ctx;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&msgctx->ext_contexts) )
+		return NULL;
+
+	ctx = array_idx(&msgctx->ext_contexts, (unsigned int) ext->id);
+
+	return *ctx;
+}
+
+/* Envelope */
+
+static void sieve_message_envelope_parse(struct sieve_message_context *msgctx)
+{
+	/* FIXME: log parse problems properly; logs only 'failure' now */
+
+	msgctx->envelope_recipient = sieve_address_parse_envelope_path
+		(msgctx->pool, msgctx->msgdata->to_address);
+
+	if ( msgctx->envelope_recipient == NULL )
+		sieve_sys_error("envelope recipient address '%s' is unparseable", msgctx->msgdata->to_address);
+	else if ( msgctx->envelope_recipient->local_part == NULL )
+		sieve_sys_error("envelope recipient address '%s' is a null path", msgctx->msgdata->to_address);
+
+	msgctx->envelope_sender = sieve_address_parse_envelope_path
+		(msgctx->pool, msgctx->msgdata->return_path);
+
+	if ( msgctx->envelope_sender == NULL )
+		sieve_sys_error("envelope sender address '%s' is unparseable", msgctx->msgdata->return_path);
+
+	msgctx->envelope_parsed = TRUE;
+}
+
+const struct sieve_address *sieve_message_get_recipient_address
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed )
+		sieve_message_envelope_parse(msgctx);
+
+	return msgctx->envelope_recipient;
+}
+
+const struct sieve_address *sieve_message_get_sender_address
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed )
+		sieve_message_envelope_parse(msgctx);
+
+	return msgctx->envelope_sender;
+}
+
+const char *sieve_message_get_recipient
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed )
+		sieve_message_envelope_parse(msgctx);
+
+	return sieve_address_to_string(msgctx->envelope_recipient);
+}
+
+const char *sieve_message_get_sender
+(struct sieve_message_context *msgctx)
+{
+	if ( !msgctx->envelope_parsed )
+		sieve_message_envelope_parse(msgctx);
+
+	return sieve_address_to_string(msgctx->envelope_sender);
+}
+
+
+
Index: b/sieve/src/lib-sieve/sieve-message.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-message.h
@@ -0,0 +1,52 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_MESSAGE_H
+#define __SIEVE_MESSAGE_H
+
+/*
+ * Message transmission
+ */
+
+const char *sieve_message_get_new_id
+	(const struct sieve_script_env *senv);
+
+/*
+ * Message context
+ */
+
+struct sieve_message_context;
+
+struct sieve_message_context *sieve_message_context_create
+	(struct sieve_instance *svinst, const struct sieve_message_data *msgdata);
+void sieve_message_context_ref(struct sieve_message_context *msgctx);
+void sieve_message_context_unref(struct sieve_message_context **msgctx);
+
+void sieve_message_context_flush(struct sieve_message_context *msgctx);
+
+pool_t sieve_message_context_pool
+	(struct sieve_message_context *msgctx);
+
+/* Extension support */
+
+void sieve_message_context_extension_set
+	(struct sieve_message_context *msgctx, const struct sieve_extension *ext,
+		void *context);
+const void *sieve_message_context_extension_get
+	(struct sieve_message_context *msgctx, const struct sieve_extension *ext);
+
+/* Envelope */
+
+const struct sieve_address *sieve_message_get_recipient_address
+	(struct sieve_message_context *msgctx);
+
+const struct sieve_address *sieve_message_get_sender_address
+	(struct sieve_message_context *msgctx);
+
+const char *sieve_message_get_recipient
+	(struct sieve_message_context *msgctx);
+
+const char *sieve_message_get_sender
+	(struct sieve_message_context *msgctx);
+
+#endif /* __SIEVE_MESSAGE_H */
Index: b/sieve/src/lib-sieve/sieve-objects.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-objects.c
@@ -0,0 +1,111 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-objects.h"
+
+/*
+ * Object coding
+ */
+
+void sieve_opr_object_emit
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	const struct sieve_object_def *obj_def)
+{
+	struct sieve_extension_objects *objs =
+		(struct sieve_extension_objects *) obj_def->operand->interface;
+
+	(void) sieve_operand_emit(sbin, ext, obj_def->operand);
+
+	if ( objs->count > 1 ) {
+		(void) sieve_binary_emit_byte(sbin, obj_def->code);
+	}
+}
+
+bool sieve_opr_object_read_data
+(struct sieve_binary *sbin, const struct sieve_operand *operand,
+	const struct sieve_operand_class *opclass, sieve_size_t *address,
+	struct sieve_object *obj)
+{
+	const struct sieve_extension_objects *objs;
+	unsigned int obj_code;
+
+	if ( operand == NULL || operand->def->class != opclass )
+		return FALSE;
+
+	objs = (struct sieve_extension_objects *) operand->def->interface;
+	if ( objs == NULL )
+		return FALSE;
+
+	if ( objs->count > 1 ) {
+		if ( !sieve_binary_read_byte(sbin, address, &obj_code) )
+			return FALSE;
+
+		if ( obj_code < objs->count ) {
+			const struct sieve_object_def *const *objects =
+				(const struct sieve_object_def *const *) objs->objects;
+
+			obj->def = objects[obj_code];
+			obj->ext = operand->ext;
+			return TRUE;
+		}
+	}
+
+	obj->def = (const struct sieve_object_def *) objs->objects;
+	obj->ext = operand->ext;
+	return TRUE;
+}
+
+bool sieve_opr_object_read
+(const struct sieve_runtime_env *renv,
+	const struct sieve_operand_class *opclass, sieve_size_t *address,
+	struct sieve_object *obj)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(renv->sbin, address, &operand) ) {
+		return FALSE;
+	}
+
+	return sieve_opr_object_read_data
+		(renv->sbin, &operand, opclass, address, obj);
+}
+
+bool sieve_opr_object_dump
+(const struct sieve_dumptime_env *denv,
+	const struct sieve_operand_class *opclass, sieve_size_t *address,
+	struct sieve_object *obj)
+{
+	struct sieve_operand operand;
+	struct sieve_object obj_i;
+	const char *class;
+
+	if ( obj == NULL )
+		obj = &obj_i;
+
+	sieve_code_mark(denv);
+
+	if ( !sieve_operand_read(denv->sbin, address, &operand) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_opr_object_read_data
+		(denv->sbin, &operand, opclass, address, obj) )
+		return FALSE;
+
+	if ( operand.def->class == NULL )
+		class = "OBJECT";
+	else
+		class = operand.def->class->name;
+
+	sieve_code_dumpf(denv, "%s: %s", class, obj->def->identifier);
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/sieve-objects.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-objects.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_OBJECTS_H
+#define __SIEVE_OBJECTS_H
+
+/*
+ * Object definition
+ */
+
+struct sieve_object_def {
+	const char *identifier;
+	const struct sieve_operand_def *operand;
+	unsigned int code;
+};
+
+#define SIEVE_OBJECT(identifier, operand, code) \
+	{ identifier, operand, code }
+
+/*
+ * Object instance
+ */
+
+struct sieve_object {
+	const struct sieve_object_def *def;
+	const struct sieve_extension *ext;
+};
+
+#define SIEVE_OBJECT_DEFAULT(_obj) \
+	{ &((_obj).obj_def), NULL }
+
+#define SIEVE_OBJECT_EXTENSION(_obj) \
+	(_obj->object.ext)
+
+#define SIEVE_OBJECT_SET_DEF(_obj, def_value) \
+	STMT_START { \
+			(_obj)->def = def_value;	\
+			(_obj)->object.def = &(_obj)->def->obj_def; \
+	} STMT_END
+
+
+/*
+ * Object coding
+ */
+
+void sieve_opr_object_emit
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		const struct sieve_object_def *obj_def);
+
+bool sieve_opr_object_read_data
+	(struct sieve_binary *sbin, const struct sieve_operand *operand,
+		const struct sieve_operand_class *opclass, sieve_size_t *address,
+		struct sieve_object *obj);
+
+bool sieve_opr_object_read
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_operand_class *opclass, sieve_size_t *address,
+		struct sieve_object *obj);
+
+bool sieve_opr_object_dump
+	(const struct sieve_dumptime_env *denv,
+		const struct sieve_operand_class *opclass, sieve_size_t *address,
+		struct sieve_object *obj);
+
+
+#endif /* __SIEVE_OBJECTS_H */
Index: b/sieve/src/lib-sieve/sieve-parser.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-parser.c
@@ -0,0 +1,655 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+
+#include "lib.h"
+#include "istream.h"
+#include "failures.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-script.h"
+#include "sieve-lexer.h"
+#include "sieve-parser.h"
+#include "sieve-error.h"
+#include "sieve-ast.h"
+
+/*
+ * Forward declarations
+ */
+
+inline static void sieve_parser_error
+	(struct sieve_parser *parser, const char *fmt, ...) ATTR_FORMAT(2, 3);
+inline static void sieve_parser_warning
+	(struct sieve_parser *parser, const char *fmt, ...) ATTR_FORMAT(2, 3);
+
+static int sieve_parser_recover
+	(struct sieve_parser *parser, enum sieve_token_type end_token);
+
+/*
+ * Parser object
+ */
+
+struct sieve_parser {
+	pool_t pool;
+
+	bool valid;
+
+	struct sieve_script *script;
+
+	struct sieve_error_handler *ehandler;
+
+	struct sieve_lexer *lexer;
+	struct sieve_ast *ast;
+};
+
+struct sieve_parser *sieve_parser_create
+(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_parser *parser;
+	struct sieve_lexer *lexer;
+
+	lexer = sieve_lexer_create(script, ehandler);
+
+	if ( lexer != NULL ) {
+		pool_t pool = pool_alloconly_create("sieve_parser", 4096);
+
+		parser = p_new(pool, struct sieve_parser, 1);
+		parser->pool = pool;
+		parser->valid = TRUE;
+
+		parser->ehandler = ehandler;
+		sieve_error_handler_ref(ehandler);
+
+		parser->script = script;
+		sieve_script_ref(script);
+
+		parser->lexer = lexer;
+		parser->ast = NULL;
+
+		return parser;
+	}
+
+	return NULL;
+}
+
+void sieve_parser_free(struct sieve_parser **parser)
+{
+	if ((*parser)->ast != NULL)
+		sieve_ast_unref(&(*parser)->ast);
+
+	sieve_lexer_free(&(*parser)->lexer);
+	sieve_script_unref(&(*parser)->script);
+
+	sieve_error_handler_unref(&(*parser)->ehandler);
+
+	pool_unref(&(*parser)->pool);
+
+	*parser = NULL;
+}
+
+/*
+ * Internal error handling
+ */
+
+inline static void sieve_parser_error
+(struct sieve_parser *parser, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	/* Don't report a parse error if the lexer complained already */
+	if ( sieve_lexer_current_token(parser->lexer) != STT_ERROR )
+	{
+		T_BEGIN {
+			sieve_verror(parser->ehandler,
+				sieve_error_script_location(parser->script,
+					sieve_lexer_current_line(parser->lexer)),
+				fmt, args);
+		} T_END;
+	}
+
+	parser->valid = FALSE;
+
+	va_end(args);
+}
+
+inline static void sieve_parser_warning
+(struct sieve_parser *parser, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN	{
+		sieve_vwarning(parser->ehandler,
+			sieve_error_script_location(parser->script,
+				sieve_lexer_current_line(parser->lexer)),
+			fmt, args);
+	} T_END;
+
+	va_end(args);
+}
+
+/*
+ * Sieve grammar parsing
+ */
+
+/* sieve_parse_arguments():
+ *
+ * Parses both command arguments and sub-tests:
+ *   arguments = *argument [test / test-list]
+ *   argument = string-list / number / tag
+ *   string = quoted-string / multi-line   [[implicitly handled in lexer]]
+ *   string-list = "[" string *("," string) "]" / string         ;; if
+ *     there is only a single string, the brackets are optional
+ *   test-list = "(" test *("," test) ")"
+ *   test = identifier arguments
+ */
+static int sieve_parse_arguments
+(struct sieve_parser *parser, struct sieve_ast_node *node, unsigned int depth)
+{
+	struct sieve_lexer *lexer = parser->lexer;
+	struct sieve_ast_node *test = NULL;
+	bool test_present = TRUE;
+	bool arg_present = TRUE;
+	int result = TRUE; /* Indicates whether the parser is in a defined, not
+	                       necessarily error-free state */
+
+	/* Parse arguments */
+	while ( arg_present && result > 0 &&
+		(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+		struct sieve_ast_argument *arg;
+
+		switch ( sieve_lexer_current_token(lexer) ) {
+
+		/* String list */
+		case STT_LSQUARE:
+			/* Create stinglist object */
+			arg = sieve_ast_argument_stringlist_create
+				(node, sieve_lexer_current_line(parser->lexer));
+
+			if ( arg == NULL ) break;
+
+			sieve_lexer_skip_token(lexer);
+
+			if ( sieve_lexer_current_token(lexer) == STT_STRING ) {
+				bool add_failed = FALSE;
+
+				/* Add the string to the list */
+				if ( !sieve_ast_stringlist_add
+					(arg, sieve_lexer_token_str(lexer),
+						sieve_lexer_current_line(parser->lexer)) )
+					add_failed = TRUE;
+
+				sieve_lexer_skip_token(lexer);
+
+				while ( !add_failed && sieve_lexer_current_token(lexer) == STT_COMMA &&
+					(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+
+					sieve_lexer_skip_token(lexer);
+
+					if ( sieve_lexer_current_token(lexer) == STT_STRING ) {
+						/* Add the string to the list */
+						if ( !sieve_ast_stringlist_add
+							(arg, sieve_lexer_token_str(lexer),
+								sieve_lexer_current_line(parser->lexer)) )
+							add_failed = TRUE;
+
+						sieve_lexer_skip_token(lexer);
+					} else {
+						sieve_parser_error(parser,
+							"expecting string after ',' in string list, but found %s",
+							sieve_lexer_token_string(lexer));
+
+						result = sieve_parser_recover(parser, STT_RSQUARE);
+						break;
+					}
+				}
+
+				if ( add_failed ) {
+					sieve_parser_error(parser,
+						"failed to accept more items in string list");
+					return -1;
+				}
+			} else {
+				sieve_parser_error(parser,
+					"expecting string after '[' in string list, but found %s",
+					sieve_lexer_token_string(lexer));
+
+				result = sieve_parser_recover(parser, STT_RSQUARE);
+			}
+
+			/* Finish the string list */
+			if ( sieve_lexer_current_token(lexer) == STT_RSQUARE ) {
+				sieve_lexer_skip_token(lexer);
+			} else {
+				sieve_parser_error(parser,
+					"expecting ',' or end of string list ']', but found %s",
+					sieve_lexer_token_string(lexer));
+
+				if ( (result=sieve_parser_recover(parser, STT_RSQUARE)) == TRUE )
+					sieve_lexer_skip_token(lexer);
+			}
+
+			break;
+
+		/* Single string */
+		case STT_STRING:
+			arg = sieve_ast_argument_string_create
+				(node, sieve_lexer_token_str(lexer),
+					sieve_lexer_current_line(parser->lexer));
+
+			sieve_lexer_skip_token(lexer);
+			break;
+
+		/* Number */
+		case STT_NUMBER:
+			arg = sieve_ast_argument_number_create
+				(node, sieve_lexer_token_int(lexer),
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+			break;
+
+		/* Tag */
+		case STT_TAG:
+			arg = sieve_ast_argument_tag_create
+				(node, sieve_lexer_token_ident(lexer),
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+			break;
+
+		/* End of argument list, continue with tests */
+		default:
+			arg_present = FALSE;
+			break;
+		}
+
+		if ( arg_present && arg == NULL ) {
+			sieve_parser_error(parser,
+				"failed to accept more arguments for command '%s'", node->identifier);
+			return -1;
+		}
+
+		if ( sieve_ast_argument_count(node) > SIEVE_MAX_COMMAND_ARGUMENTS ) {
+			sieve_parser_error(parser,
+				"too many arguments for command '%s'", node->identifier);
+			return FALSE;
+		}
+	}
+
+	if ( result <= 0 ) return result; /* Defer recovery to caller */
+
+	/* --> [ test / test-list ]
+ 	 * test-list = "(" test *("," test) ")"
+	 * test = identifier arguments
+	 */
+	switch ( sieve_lexer_current_token(lexer) ) {
+
+	/* Single test */
+	case STT_IDENTIFIER:
+		if ( depth+1 > SIEVE_MAX_TEST_NESTING ) {
+			sieve_parser_error(parser,
+				"cannot nest tests deeper than %u levels",
+				SIEVE_MAX_TEST_NESTING);
+			return FALSE;
+		}
+
+		test = sieve_ast_test_create
+			(node, sieve_lexer_token_ident(lexer),
+				sieve_lexer_current_line(parser->lexer));
+		sieve_lexer_skip_token(lexer);
+
+		/* Theoretically, test can be NULL */
+		if ( test == NULL ) break;
+
+		/* Parse test arguments, which may include more tests (recurse) */
+		if ( !sieve_parse_arguments(parser, test, depth+1) ) {
+			return FALSE; /* Defer recovery to caller */
+		}
+
+		break;
+
+	/* Test list */
+	case STT_LBRACKET:
+		sieve_lexer_skip_token(lexer);
+
+		if ( depth+1 > SIEVE_MAX_TEST_NESTING ) {
+			sieve_parser_error(parser,
+				"cannot nest tests deeper than %u levels",
+				SIEVE_MAX_TEST_NESTING);
+			result = sieve_parser_recover(parser, STT_RBRACKET);
+
+			if ( result ) sieve_lexer_skip_token(lexer);
+			return result;
+		}
+
+		node->test_list = TRUE;
+
+		/* Test starts with identifier */
+		if ( sieve_lexer_current_token(lexer) == STT_IDENTIFIER ) {
+			test = sieve_ast_test_create
+				(node, sieve_lexer_token_ident(lexer),
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+
+			if ( test == NULL ) break;
+
+			/* Parse test arguments, which may include more tests (recurse) */
+			if ( (result=sieve_parse_arguments(parser, test, depth+1)) > 0 ) {
+
+				/* More tests ? */
+				while ( sieve_lexer_current_token(lexer) == STT_COMMA &&
+					(parser->valid && sieve_errors_more_allowed(parser->ehandler)) ) {
+					sieve_lexer_skip_token(lexer);
+
+					/* Test starts with identifier */
+					if ( sieve_lexer_current_token(lexer) == STT_IDENTIFIER ) {
+						test = sieve_ast_test_create
+							(node, sieve_lexer_token_ident(lexer),
+								sieve_lexer_current_line(parser->lexer));
+						sieve_lexer_skip_token(lexer);
+
+						if ( test == NULL ) break;
+
+						/* Parse test arguments, which may include more tests (recurse) */
+						if ( (result=sieve_parse_arguments(parser, test, depth+1)) <= 0 ) {
+							if ( result < 0 ) return result;
+
+							result = sieve_parser_recover(parser, STT_RBRACKET);
+							break;
+						}
+					} else {
+						sieve_parser_error(parser,
+							"expecting test identifier after ',' in test list, but found %s",
+							sieve_lexer_token_string(lexer));
+
+						result = sieve_parser_recover(parser, STT_RBRACKET);
+						break;
+					}
+				}
+
+				if ( test == NULL ) break;
+			} else {
+				if ( result < 0 ) return result;
+
+				result = sieve_parser_recover(parser, STT_RBRACKET);
+			}
+		} else {
+			sieve_parser_error(parser,
+				"expecting test identifier after '(' in test list, but found %s",
+				sieve_lexer_token_string(lexer));
+
+			result = sieve_parser_recover(parser, STT_RBRACKET);
+		}
+
+		/* The next token should be a ')', indicating the end of the test list
+		 *   --> previous sieve_parser_recover calls try to restore this situation
+		 *       after parse errors.
+		 */
+ 		if ( sieve_lexer_current_token(lexer) == STT_RBRACKET ) {
+			sieve_lexer_skip_token(lexer);
+		} else {
+			sieve_parser_error(parser,
+				"expecting ',' or end of test list ')', but found %s",
+				sieve_lexer_token_string(lexer));
+
+			/* Recover function tries to make next token equal to ')'. If it succeeds
+			 * we need to skip it.
+			 */
+			if ( (result=sieve_parser_recover(parser, STT_RBRACKET)) == TRUE )
+				sieve_lexer_skip_token(lexer);
+		}
+		break;
+
+	default:
+		/* Not an error: test / test-list is optional
+		 *   --> any errors are detected by the caller
+		 */
+		test_present = FALSE;
+		break;
+	}
+
+	if ( test_present && test == NULL ) {
+		sieve_parser_error(parser,
+			"failed to accept more tests for command '%s'", node->identifier);
+		return -1;
+	}
+
+	return result;
+}
+
+/* commands = *command
+ * command = identifier arguments ( ";" / block )
+ * block = "{" commands "}"
+ */
+static int sieve_parse_commands
+(struct sieve_parser *parser, struct sieve_ast_node *block, unsigned int depth)
+{
+	struct sieve_lexer *lexer = parser->lexer;
+	int result = TRUE;
+
+	while ( result > 0 &&
+		sieve_lexer_current_token(lexer) == STT_IDENTIFIER &&
+		(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+		struct sieve_ast_node *command =
+			sieve_ast_command_create
+				(block, sieve_lexer_token_ident(lexer),
+					sieve_lexer_current_line(parser->lexer));
+
+		if ( command == NULL ) {
+			sieve_parser_error(parser,
+				"failed to accept more commands inside the block of command '%s'",
+				block->identifier);
+			return -1;
+		}
+
+		/* Defined state */
+		result = TRUE;
+
+		sieve_lexer_skip_token(lexer);
+
+		result = sieve_parse_arguments(parser, command, 1);
+
+		/* Check whether the command is properly terminated
+		 * (i.e. with ; or a new block)
+		 */
+		if ( result > 0 &&
+			sieve_lexer_current_token(lexer) != STT_SEMICOLON &&
+			sieve_lexer_current_token(lexer) != STT_LCURLY ) {
+
+			sieve_parser_error(parser,
+				"expected end of command ';' or the beginning of a compound block '{', "
+				"but found %s",
+				sieve_lexer_token_string(lexer));
+			result = FALSE;
+		}
+
+		/* Try to recover from parse errors to reacquire a defined state */
+		if ( result == 0 ) {
+			result = sieve_parser_recover(parser, STT_SEMICOLON);
+		}
+
+		/* Don't bother to continue if we are not in a defined state */
+		if ( result <= 0 ) return result;
+
+		switch ( sieve_lexer_current_token(lexer) ) {
+
+		/* End of the command */
+		case STT_SEMICOLON:
+			sieve_lexer_skip_token(lexer);
+			break;
+
+		/* Command has a block {...} */
+		case STT_LCURLY:
+			sieve_lexer_skip_token(lexer);
+
+			/* Check current depth first */
+			if ( depth+1 > SIEVE_MAX_BLOCK_NESTING ) {
+				sieve_parser_error(parser,
+					"cannot nest command blocks deeper than %u levels",
+					SIEVE_MAX_BLOCK_NESTING);
+				result = sieve_parser_recover(parser, STT_RCURLY);
+
+				if ( result > 0 )
+					sieve_lexer_skip_token(lexer);
+				break;
+			}
+
+			command->block = TRUE;
+
+			if ( (result=sieve_parse_commands(parser, command, depth+1)) > 0 ) {
+
+				if ( sieve_lexer_current_token(lexer) != STT_RCURLY ) {
+					sieve_parser_error(parser,
+						"expected end of compound block '}', but found %s",
+						sieve_lexer_token_string(lexer));
+					result = sieve_parser_recover(parser, STT_RCURLY);
+				} else
+					sieve_lexer_skip_token(lexer);
+			} else {
+				if ( result < 0 ) return result;
+
+				if ( (result=sieve_parser_recover(parser, STT_RCURLY)) == 0 )
+					sieve_lexer_skip_token(lexer);
+			}
+
+			break;
+
+		default:
+			/* Recovered previously, so this cannot happen */
+			i_unreached();
+		}
+	}
+
+	return result;
+}
+
+bool sieve_parser_run
+(struct sieve_parser *parser, struct sieve_ast **ast)
+{
+	if ( parser->ast != NULL )
+		sieve_ast_unref(&parser->ast);
+
+	/* Create AST object if none is provided */
+	if ( *ast == NULL )
+		*ast = sieve_ast_create(parser->script);
+	else
+		sieve_ast_ref(*ast);
+
+	parser->ast = *ast;
+
+	/* Scan first token */
+	sieve_lexer_skip_token(parser->lexer);
+
+	/* Parse */
+	if ( sieve_parse_commands(parser, sieve_ast_root(parser->ast), 1) > 0 &&
+		parser->valid ) {
+
+		/* Parsed right to EOF ? */
+		if ( sieve_lexer_current_token(parser->lexer) != STT_EOF ) {
+			sieve_parser_error(parser,
+				"unexpected %s found at (the presumed) end of file",
+				sieve_lexer_token_string(parser->lexer));
+			parser->valid = FALSE;
+		}
+	} else parser->valid = FALSE;
+
+	/* Clean up AST if parse failed */
+	if ( !parser->valid ) {
+		parser->ast = NULL;
+		sieve_ast_unref(ast);
+	}
+
+	return parser->valid;
+}
+
+/* Error recovery:
+ *   To continue parsing after an error it is important to find the next
+ *   parsible item in the stream. The recover function skips over the remaining
+ *   garbage after an error. It tries  to find the end of the failed syntax
+ *   structure and takes nesting of structures into account.
+ */
+
+/* Assign useful names to priorities for readability */
+enum sieve_grammatical_prio {
+	SGP_BLOCK = 3,
+	SGP_COMMAND = 2,
+	SGP_TEST_LIST = 1,
+	SGP_STRING_LIST = 0,
+
+	SGP_OTHER = -1
+};
+
+static inline enum sieve_grammatical_prio __get_token_priority
+(enum sieve_token_type token)
+{
+	switch ( token ) {
+	case STT_LCURLY:
+	case STT_RCURLY:
+		return SGP_BLOCK;
+	case STT_SEMICOLON:
+		return SGP_COMMAND;
+	case STT_LBRACKET:
+	case STT_RBRACKET:
+		return SGP_TEST_LIST;
+	case STT_LSQUARE:
+	case STT_RSQUARE:
+		return SGP_STRING_LIST;
+	default:
+		break;
+	}
+
+	return SGP_OTHER;
+}
+
+static int sieve_parser_recover
+(struct sieve_parser *parser, enum sieve_token_type end_token)
+{
+	/* The tokens that begin/end a specific block/command/list in order
+ 	 * of ascending grammatical priority.
+ 	 */
+ 	static const enum sieve_token_type begin_tokens[4] =
+ 		{ STT_LSQUARE, STT_LBRACKET, STT_NONE, STT_LCURLY };
+	static const enum sieve_token_type end_tokens[4] =
+		{ STT_RSQUARE, STT_RBRACKET, STT_SEMICOLON, STT_RCURLY};
+
+	struct sieve_lexer *lexer = parser->lexer;
+	int nesting = 1;
+	enum sieve_grammatical_prio end_priority = __get_token_priority(end_token);
+
+	i_assert( end_priority != SGP_OTHER );
+
+	while ( sieve_lexer_current_token(lexer) != STT_EOF &&
+		__get_token_priority(sieve_lexer_current_token(lexer)) <= end_priority ) {
+
+		if ( sieve_lexer_current_token(lexer) == begin_tokens[end_priority] ) {
+			nesting++;
+			sieve_lexer_skip_token(lexer);
+			continue;
+		}
+
+		if ( sieve_lexer_current_token(lexer) == end_tokens[end_priority] ) {
+			nesting--;
+
+			if ( nesting == 0 ) {
+				/* Next character is the end */
+				return TRUE;
+			}
+		}
+
+		sieve_lexer_skip_token(lexer);
+	}
+
+	/* Special case: COMMAND */
+	if (end_token == STT_SEMICOLON &&
+		sieve_lexer_current_token(lexer) == STT_LCURLY)
+		return TRUE;
+
+	/* End not found before eof or end of surrounding grammatical structure
+	 */
+	return FALSE;
+}
+
+
+
Index: b/sieve/src/lib-sieve/sieve-parser.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-parser.h
@@ -0,0 +1,18 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_PARSER_H
+#define __SIEVE_PARSER_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+struct sieve_parser;
+
+struct sieve_parser *sieve_parser_create
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+void sieve_parser_free(struct sieve_parser **parser);
+bool sieve_parser_run(struct sieve_parser *parser, struct sieve_ast **ast);
+
+#endif /* __SIEVE_PARSER_H */
Index: b/sieve/src/lib-sieve/sieve-result.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-result.c
@@ -0,0 +1,1325 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "ostream.h"
+#include "hash.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "str-sanitize.h"
+#include "var-expand.h"
+#include "message-address.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-script.h"
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+#include "sieve-actions.h"
+#include "sieve-message.h"
+
+#include "sieve-result.h"
+
+#include <stdio.h>
+
+/*
+ * Types
+ */
+
+struct sieve_result_action {
+	struct sieve_action action;
+
+	void *tr_context;
+	bool success;
+
+	bool keep;
+
+	struct sieve_side_effects_list *seffects;
+
+	struct sieve_result_action *prev, *next;
+};
+
+struct sieve_side_effects_list {
+	struct sieve_result *result;
+
+	struct sieve_result_side_effect *first_effect;
+	struct sieve_result_side_effect *last_effect;
+};
+
+struct sieve_result_side_effect {
+	struct sieve_side_effect seffect;
+
+	struct sieve_result_side_effect *prev, *next;
+};
+
+struct sieve_result_action_context {
+	const struct sieve_action_def *action;
+	struct sieve_side_effects_list *seffects;
+};
+
+/*
+ * Result object
+ */
+
+struct sieve_result {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_instance *svinst;
+
+	/* Context data for extensions */
+	ARRAY_DEFINE(ext_contexts, void *);
+
+	struct sieve_error_handler *ehandler;
+
+	struct sieve_action_exec_env action_env;
+
+	struct sieve_action keep_action;
+	struct sieve_action failure_action;
+
+	unsigned int action_count;
+	struct sieve_result_action *first_action;
+	struct sieve_result_action *last_action;
+
+	struct sieve_result_action *last_attempted_action;
+
+	struct hash_table *action_contexts;
+};
+
+struct sieve_result *sieve_result_create
+(struct sieve_instance *svinst, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler)
+{
+	pool_t pool;
+	struct sieve_result *result;
+
+	pool = pool_alloconly_create("sieve_result", 4096);
+	result = p_new(pool, struct sieve_result, 1);
+	result->refcount = 1;
+	result->pool = pool;
+	result->svinst = svinst;
+
+	p_array_init(&result->ext_contexts, pool, 4);
+
+	if ( ehandler != NULL )
+		sieve_error_handler_ref(ehandler);
+	result->ehandler = ehandler;
+
+	result->action_env.result = result;
+	result->action_env.scriptenv = senv;
+	result->action_env.msgdata = msgdata;
+	result->action_env.msgctx = sieve_message_context_create(svinst, msgdata);
+
+	result->keep_action.def = &act_store;
+	result->keep_action.ext = NULL;
+	result->failure_action.def = &act_store;
+	result->failure_action.ext = NULL;
+
+	result->action_count = 0;
+	result->first_action = NULL;
+	result->last_action = NULL;
+
+	result->action_contexts = NULL;
+	return result;
+}
+
+void sieve_result_ref(struct sieve_result *result)
+{
+	result->refcount++;
+}
+
+void sieve_result_unref(struct sieve_result **result)
+{
+	i_assert((*result)->refcount > 0);
+
+	if (--(*result)->refcount != 0)
+		return;
+
+	sieve_message_context_unref(&(*result)->action_env.msgctx);
+
+	if ( (*result)->action_contexts != NULL )
+        hash_table_destroy(&(*result)->action_contexts);
+
+	if ( (*result)->ehandler != NULL )
+		sieve_error_handler_unref(&(*result)->ehandler);
+
+	pool_unref(&(*result)->pool);
+
+ 	*result = NULL;
+}
+
+pool_t sieve_result_pool(struct sieve_result *result)
+{
+	return result->pool;
+}
+
+/*
+ * Getters/Setters
+ */
+
+struct sieve_error_handler *sieve_result_get_error_handler
+(struct sieve_result *result)
+{
+	return result->ehandler;
+}
+const struct sieve_script_env *sieve_result_get_script_env
+(struct sieve_result *result)
+{
+    return result->action_env.scriptenv;
+}
+
+const struct sieve_message_data *sieve_result_get_message_data
+(struct sieve_result *result)
+{
+	return result->action_env.msgdata;
+}
+
+struct sieve_message_context *sieve_result_get_message_context
+(struct sieve_result *result)
+{
+	return result->action_env.msgctx;
+}
+
+void sieve_result_set_error_handler
+(struct sieve_result *result, struct sieve_error_handler *ehandler)
+{
+	if ( result->ehandler != ehandler ) {
+		sieve_error_handler_ref(ehandler);
+		sieve_error_handler_unref(&result->ehandler);
+		result->ehandler = ehandler;
+	}
+}
+
+/*
+ * Extension support
+ */
+
+void sieve_result_extension_set_context
+(struct sieve_result *result, const struct sieve_extension *ext, void *context)
+{
+	if ( ext->id < 0 ) return;
+
+	array_idx_set(&result->ext_contexts, (unsigned int) ext->id, &context);
+}
+
+const void *sieve_result_extension_get_context
+(struct sieve_result *result, const struct sieve_extension *ext)
+{
+	void * const *ctx;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&result->ext_contexts) )
+		return NULL;
+
+	ctx = array_idx(&result->ext_contexts, (unsigned int) ext->id);
+
+	return *ctx;
+}
+
+/*
+ * Error handling
+ */
+
+static const char *_get_from_address(struct mail *mail)
+{
+	struct message_address *addr;
+	const char *str;
+
+	if ( mail_get_first_header(mail, "from", &str) <= 0 )
+		return NULL;
+
+	addr = message_address_parse
+		(pool_datastack_create(), (const unsigned char *)str, strlen(str), 1,
+			FALSE);
+
+	return addr == NULL || addr->mailbox == NULL || addr->domain == NULL ||
+		*addr->mailbox == '\0' || *addr->domain == '\0' ?
+		NULL : t_strconcat(addr->mailbox, "@", addr->domain, NULL);
+}
+
+void sieve_result_vlog_message
+(const struct sieve_action_exec_env *aenv, sieve_error_func_t log_func,
+	const char *fmt, va_list args)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	string_t *str;
+	const char *msgid, *msg;
+
+	if ( aenv->result->ehandler == NULL ) return;
+
+	msg = t_strdup_vprintf(fmt, args);
+
+	msgid = msgdata->id;
+	msgid = ( msgid == NULL ? "unspecified" : str_sanitize(msgid, 80) );
+
+	if ( aenv->scriptenv->action_log_format == NULL ) {
+		log_func(aenv->result->ehandler, NULL, "msgid=%s: %s", msgid, msg);
+
+	} else {
+		static struct var_expand_table static_tab[] = {
+			{ '$', NULL, NULL },
+			{ 'm', NULL, "msgid" },
+			{ 's', NULL, "subject" },
+			{ 'f', NULL, "from" },
+			{ 'l', NULL, "location" },
+			{ '\0', NULL, NULL }
+		};
+		struct var_expand_table *tab;
+		unsigned int i;
+
+		tab = t_malloc(sizeof(static_tab));
+		memcpy(tab, static_tab, sizeof(static_tab));
+
+		/* Fill in substitution items */
+		tab[0].value = msg;
+		tab[1].value = msgid;
+		(void)mail_get_first_header_utf8(msgdata->mail, "Subject", &tab[2].value);
+		tab[3].value = _get_from_address(msgdata->mail);
+		tab[4].value = "";
+
+		/* Sanitize substitution items */
+		for (i = 1; tab[i].key != '\0'; i++)
+			tab[i].value = str_sanitize(tab[i].value, 80);
+
+		/* Expand variables */
+		str = t_str_new(256);
+		var_expand(str, aenv->scriptenv->action_log_format, tab);
+
+		/* Log message */
+		log_func(aenv->result->ehandler, NULL, "%s", str_c(str));
+	}
+}
+
+void sieve_result_log_message
+(const struct sieve_action_exec_env *aenv, sieve_error_func_t log_func,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_result_vlog_message(aenv, log_func, fmt, args);
+	va_end(args);
+}
+
+void sieve_result_error
+(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_result_vlog_message(aenv, sieve_error, fmt, args);
+	va_end(args);
+}
+
+void sieve_result_warning
+(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_result_vlog_message(aenv, sieve_warning, fmt, args);
+	va_end(args);
+}
+
+void sieve_result_log
+(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_result_vlog_message(aenv, sieve_info, fmt, args);
+	va_end(args);
+}
+
+/*
+ * Result composition
+ */
+
+void sieve_result_add_implicit_side_effect
+(struct sieve_result *result, const struct sieve_action_def *to_action,
+	bool to_keep, const struct sieve_extension *ext,
+	const struct sieve_side_effect_def *seff_def, void *context)
+{
+	struct sieve_result_action_context *actctx = NULL;
+	struct sieve_side_effect seffect;
+
+	to_action = to_keep ? &act_store : to_action;
+
+	if ( result->action_contexts == NULL ) {
+		result->action_contexts = hash_table_create
+			(default_pool, result->pool, 0, NULL, NULL);
+	} else {
+		actctx = (struct sieve_result_action_context *)
+			hash_table_lookup(result->action_contexts, to_action);
+	}
+
+	if ( actctx == NULL ) {
+		actctx = p_new
+			(result->pool, struct sieve_result_action_context, 1);
+		actctx->action = to_action;
+		actctx->seffects = sieve_side_effects_list_create(result);
+
+		hash_table_insert(result->action_contexts, (void *) to_action,
+			(void *) actctx);
+	}
+
+	seffect.object.def = &seff_def->obj_def;
+	seffect.object.ext = ext;
+	seffect.def = seff_def;
+	seffect.context = context;
+
+	sieve_side_effects_list_add(actctx->seffects, &seffect);
+}
+
+static int sieve_result_side_effects_merge
+(const struct sieve_runtime_env *renv, const struct sieve_action *action,
+	struct sieve_result_action *old_action,
+	struct sieve_side_effects_list *new_seffects)
+{
+	struct sieve_side_effects_list *old_seffects = old_action->seffects;
+	int ret;
+	struct sieve_result_side_effect *rsef, *nrsef;
+
+	/* Allow side-effects to merge with existing copy */
+
+	/* Merge existing side effects */
+	rsef = old_seffects != NULL ? old_seffects->first_effect : NULL;
+	while ( rsef != NULL ) {
+		struct sieve_side_effect *seffect = &rsef->seffect;
+		bool found = FALSE;
+
+		if ( seffect->def != NULL && seffect->def->merge != NULL ) {
+
+			/* Try to find it among the new */
+			nrsef = new_seffects != NULL ? new_seffects->first_effect : NULL;
+			while ( nrsef != NULL ) {
+				struct sieve_side_effect *nseffect = &nrsef->seffect;
+
+				if ( nseffect->def == seffect->def ) {
+					if ( seffect->def->merge
+						(renv, action, seffect, nseffect, &seffect->context) < 0 )
+						return -1;
+
+					found = TRUE;
+					break;
+				}
+
+				nrsef = nrsef->next;
+			}
+
+			/* Not found? */
+			if ( !found && seffect->def->merge
+				(renv, action, seffect, NULL, &rsef->seffect.context) < 0 )
+				return -1;
+		}
+
+		rsef = rsef->next;
+	}
+
+	/* Merge new Side effects */
+	nrsef = new_seffects != NULL ? new_seffects->first_effect : NULL;
+	while ( nrsef != NULL ) {
+		struct sieve_side_effect *nseffect = &nrsef->seffect;
+		bool found = FALSE;
+
+		if ( nseffect->def != NULL && nseffect->def->merge != NULL ) {
+
+			/* Try to find it among the exising */
+			rsef = old_seffects != NULL ? old_seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				if ( rsef->seffect.def == nseffect->def ) {
+					found = TRUE;
+					break;
+				}
+				rsef = rsef->next;
+			}
+
+			/* Not found? */
+			if ( !found ) {
+				void *new_context = NULL;
+
+				if ( (ret=nseffect->def->merge
+					(renv, action, nseffect, nseffect, &new_context)) < 0 )
+					return -1;
+
+				if ( ret != 0 ) {
+					if ( old_action->seffects == NULL )
+						old_action->seffects = old_seffects =
+							sieve_side_effects_list_create(renv->result);
+
+					nseffect->context = new_context;
+
+					/* Add side effect */
+					sieve_side_effects_list_add(old_seffects, nseffect);
+				}
+			}
+		}
+
+		nrsef = nrsef->next;
+	}
+
+	return 1;
+}
+
+static void sieve_result_action_detach
+(struct sieve_result *result, struct sieve_result_action *raction)
+{
+	if ( result->first_action == raction )
+		result->first_action = raction->next;
+
+	if ( result->last_action == raction )
+		result->last_action = raction->prev;
+
+	if ( result->last_attempted_action == raction )
+		result->last_attempted_action = raction->prev;
+
+	if ( raction->next != NULL ) raction->next->prev = raction->prev;
+	if ( raction->prev != NULL ) raction->prev->next = raction->next;
+
+	raction->next = NULL;
+	raction->prev = NULL;
+
+	if ( result->action_count > 0 )
+		result->action_count--;
+}
+
+static int _sieve_result_add_action
+(const struct sieve_runtime_env *renv, const struct sieve_extension *ext,
+	const struct sieve_action_def *act_def,
+	struct sieve_side_effects_list *seffects, unsigned int source_line,
+	void *context, unsigned int instance_limit, bool keep)
+{
+	int ret = 0;
+	unsigned int instance_count = 0;
+	struct sieve_instance *svinst = renv->svinst;
+	struct sieve_result *result = renv->result;
+	struct sieve_result_action *raction = NULL, *kaction = NULL;
+	struct sieve_action action;
+
+	action.def = act_def;
+	action.ext = ext;
+	action.location = sieve_error_script_location(renv->script, source_line);
+	action.context = context;
+	action.executed = FALSE;
+
+	/* First, check for duplicates or conflicts */
+	raction = result->first_action;
+	while ( raction != NULL ) {
+		const struct sieve_action *oact = &raction->action;
+
+		if ( keep && raction->keep ) {
+
+			/* Duplicate keep */
+			if ( raction->action.def == NULL || raction->action.executed ) {
+				/* Keep action from preceeding execution */
+
+				/* Detach existing keep action */
+				sieve_result_action_detach(result, raction);
+
+				/* Merge existing side-effects with new keep action */
+				if ( kaction == NULL )
+					kaction = raction;
+
+				if ( (ret=sieve_result_side_effects_merge
+					(renv, &action, kaction, seffects)) <= 0 )
+					return ret;
+			} else {
+				/* True duplicate */
+				return sieve_result_side_effects_merge
+					(renv, &action, raction, seffects);
+			}
+
+		} if ( act_def != NULL && raction->action.def == act_def ) {
+			instance_count++;
+
+			/* Possible duplicate */
+			if ( act_def->check_duplicate != NULL ) {
+				if ( (ret=act_def->check_duplicate(renv, &action, &raction->action))
+					< 0 )
+					return ret;
+
+				/* Duplicate */
+				if ( ret == 1 ) {
+					if ( keep && !raction->keep ) {
+						/* New keep has higher precedence than existing duplicate non-keep
+						 * action. So, take over the result action object and transform it
+						 * into a keep.
+						 */
+
+						if ( (ret=sieve_result_side_effects_merge
+							(renv, &action, raction, seffects)) < 0 )
+							return ret;
+
+						if ( kaction == NULL ) {
+							raction->action.context = NULL;
+							raction->action.location =
+								p_strdup(result->pool, action.location);
+
+							/* Note that existing execution status is retained, making sure
+							 * that keep is not executed multiple times.
+							 */
+
+							kaction = raction;
+
+						} else {
+							sieve_result_action_detach(result, raction);
+
+							if ( (ret=sieve_result_side_effects_merge
+								(renv, &action, kaction, raction->seffects)) < 0 )
+								return ret;
+						}
+					} else {
+						/* Merge side-effects, but don't add new action */
+						return sieve_result_side_effects_merge
+							(renv, &action, raction, seffects);
+					}
+				}
+			}
+		} else {
+			if ( act_def != NULL && oact->def != NULL ) {
+				/* Check conflict */
+				if ( act_def->check_conflict != NULL &&
+					(ret=act_def->check_conflict(renv, &action, &raction->action)) != 0 )
+					return ret;
+
+				if ( !raction->action.executed && oact->def->check_conflict != NULL &&
+					(ret=oact->def->check_conflict
+						(renv, &raction->action, &action)) != 0 )
+					return ret;
+			}
+		}
+		raction = raction->next;
+	}
+
+	/* Check policy limit on total number of actions */
+	if ( svinst->max_actions > 0 && result->action_count >= svinst->max_actions )
+		{
+		sieve_runtime_error(renv, action.location,
+			"total number of actions exceeds policy limit");
+		return -1;
+	}
+
+	/* Check policy limit on number of this class of actions */
+	if ( instance_limit > 0 && instance_count >= instance_limit ) {
+		sieve_runtime_error(renv, action.location,
+			"number of %s actions exceeds policy limit", act_def->name);
+		return -1;
+	}
+
+	if ( kaction != NULL ) {
+		/* Use existing keep action to define new one */
+		raction = kaction;
+	} else {
+		/* Create new action object */
+		raction = p_new(result->pool, struct sieve_result_action, 1);
+		raction->action.executed = FALSE;
+		raction->seffects = seffects;
+		raction->tr_context = NULL;
+		raction->success = FALSE;
+	}
+
+	raction->action.context = context;
+	raction->action.def = act_def;
+	raction->action.ext = ext;
+	raction->action.location = p_strdup(result->pool, action.location);
+	raction->keep = keep;
+
+	if ( raction->prev == NULL ) {
+		/* Add */
+		if ( result->first_action == NULL ) {
+			result->first_action = raction;
+			result->last_action = raction;
+			raction->prev = NULL;
+			raction->next = NULL;
+		} else {
+			result->last_action->next = raction;
+			raction->prev = result->last_action;
+			result->last_action = raction;
+			raction->next = NULL;
+		}
+		result->action_count++;
+
+		/* Apply any implicit side effects */
+		if ( result->action_contexts != NULL ) {
+			struct sieve_result_action_context *actctx;
+
+			/* Check for implicit side effects to this particular action */
+			actctx = (struct sieve_result_action_context *)
+				hash_table_lookup(result->action_contexts,
+					( keep ? &act_store : act_def ));
+
+			if ( actctx != NULL ) {
+				struct sieve_result_side_effect *iseff;
+
+				/* Iterate through all implicit side effects and add those that are
+				 * missing.
+				 */
+				iseff = actctx->seffects->first_effect;
+				while ( iseff != NULL ) {
+					struct sieve_result_side_effect *seff;
+					bool exists = FALSE;
+
+					/* Scan for presence */
+					if ( seffects != NULL ) {
+						seff = seffects->first_effect;
+						while ( seff != NULL ) {
+							if ( seff->seffect.def == iseff->seffect.def ) {
+								exists = TRUE;
+								break;
+							}
+
+							seff = seff->next;
+						}
+					} else {
+						raction->seffects = seffects =
+							sieve_side_effects_list_create(result);
+					}
+
+					/* If not present, add it */
+					if ( !exists ) {
+						sieve_side_effects_list_add(seffects, &iseff->seffect);
+					}
+
+					iseff = iseff->next;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+int sieve_result_add_action
+(const struct sieve_runtime_env *renv, const struct sieve_extension *ext,
+	const struct sieve_action_def *act_def,
+	struct sieve_side_effects_list *seffects, unsigned int source_line,
+	void *context, unsigned int instance_limit)
+{
+	return _sieve_result_add_action
+		(renv, ext, act_def, seffects, source_line, context, instance_limit, FALSE);
+}
+
+int sieve_result_add_keep
+(const struct sieve_runtime_env *renv, struct sieve_side_effects_list *seffects,
+	unsigned int source_line)
+{
+	return _sieve_result_add_action
+		(renv, renv->result->keep_action.ext, renv->result->keep_action.def,
+			seffects, source_line, NULL, 0, TRUE);
+}
+
+void sieve_result_set_keep_action
+(struct sieve_result *result, const struct sieve_extension *ext,
+	const struct sieve_action_def *act_def)
+{
+	result->keep_action.def = act_def;
+	result->keep_action.ext = ext;
+}
+
+void sieve_result_set_failure_action
+(struct sieve_result *result, const struct sieve_extension *ext,
+	const struct sieve_action_def *act_def)
+{
+	result->failure_action.def = act_def;
+	result->failure_action.ext = ext;
+}
+
+/*
+ * Result printing
+ */
+
+void sieve_result_vprintf
+(const struct sieve_result_print_env *penv, const char *fmt, va_list args)
+{
+	string_t *outbuf = t_str_new(128);
+
+	str_vprintfa(outbuf, fmt, args);
+
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_result_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_result_vprintf(penv, fmt, args);
+	va_end(args);
+}
+
+void sieve_result_action_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_append(outbuf, " * ");
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_result_seffect_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_append(outbuf, "        + ");
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+static void sieve_result_print_side_effects
+(struct sieve_result_print_env *rpenv, const struct sieve_action *action,
+	struct sieve_side_effects_list *slist, bool *implicit_keep)
+{
+	struct sieve_result_side_effect *rsef;
+
+	/* Print side effects */
+	rsef = slist != NULL ? slist->first_effect : NULL;
+	while ( rsef != NULL ) {
+		if ( rsef->seffect.def != NULL ) {
+			const struct sieve_side_effect *sef = &rsef->seffect;
+
+			if ( sef->def->print != NULL )
+				sef->def->print(sef, action, rpenv, implicit_keep);
+		}
+		rsef = rsef->next;
+	}
+}
+
+static void sieve_result_print_implicit_side_effects
+(struct sieve_result_print_env *rpenv)
+{
+	struct sieve_result *result = rpenv->result;
+	bool dummy = TRUE;
+
+	/* Print any implicit side effects if applicable */
+	if ( result->action_contexts != NULL ) {
+		struct sieve_result_action_context *actctx;
+
+		/* Check for implicit side effects to keep action */
+		actctx = (struct sieve_result_action_context *)
+			hash_table_lookup(rpenv->result->action_contexts, &act_store);
+
+		if ( actctx != NULL && actctx->seffects != NULL )
+			sieve_result_print_side_effects
+				(rpenv, &result->keep_action, actctx->seffects, &dummy);
+	}
+}
+
+bool sieve_result_print
+(struct sieve_result *result, const struct sieve_script_env *senv,
+	struct ostream *stream, bool *keep)
+{
+	struct sieve_action act_keep = result->keep_action;
+	struct sieve_result_print_env penv;
+	bool implicit_keep = TRUE;
+	struct sieve_result_action *rac, *first_action;
+
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+
+	if ( keep != NULL ) *keep = FALSE;
+
+	/* Prepare environment */
+
+	penv.result = result;
+	penv.stream = stream;
+	penv.scriptenv = senv;
+
+	sieve_result_printf(&penv, "\nPerformed actions:\n\n");
+
+	if ( first_action == NULL ) {
+		sieve_result_printf(&penv, "  (none)\n");
+	} else {
+		rac = first_action;
+		while ( rac != NULL ) {
+			bool impl_keep = TRUE;
+			const struct sieve_action *act = &rac->action;
+
+			if ( rac->keep && keep != NULL ) *keep = TRUE;
+
+			if ( act->def != NULL ) {
+				if ( act->def->print != NULL )
+					act->def->print(act, &penv, &impl_keep);
+				else
+					sieve_result_action_printf(&penv, "%s", act->def->name);
+			} else {
+				if ( rac->keep ) {
+					sieve_result_action_printf(&penv, "keep");
+					impl_keep = FALSE;
+				} else {
+					sieve_result_action_printf(&penv, "[NULL]");
+				}
+			}
+
+			/* Print side effects */
+			sieve_result_print_side_effects
+				(&penv, &rac->action, rac->seffects, &impl_keep);
+
+			implicit_keep = implicit_keep && impl_keep;
+
+			rac = rac->next;
+		}
+	}
+
+	if ( implicit_keep && keep != NULL ) *keep = TRUE;
+
+	sieve_result_printf(&penv, "\nImplicit keep:\n\n");
+
+	if ( implicit_keep ) {
+		bool dummy = TRUE;
+
+		if ( act_keep.def == NULL ) {
+			sieve_result_action_printf(&penv, "keep");
+
+			sieve_result_print_implicit_side_effects(&penv);
+		} else {
+			/* Scan for execution of keep-equal actions */
+			rac = result->first_action;
+			while ( act_keep.def != NULL && rac != NULL ) {
+				if ( rac->action.def == act_keep.def && act_keep.def->equals != NULL
+					&& act_keep.def->equals(senv, NULL, &rac->action)
+						&& rac->action.executed ) {
+					act_keep.def = NULL;
+				}
+
+				rac = rac->next;
+			}
+
+			if ( act_keep.def == NULL ) {
+				sieve_result_printf(&penv,
+					"  (none; keep or equivalent action executed earlier)\n");
+			} else {
+				act_keep.def->print(&act_keep, &penv, &dummy);
+
+				sieve_result_print_implicit_side_effects(&penv);
+			}
+		}
+	} else
+		sieve_result_printf(&penv, "  (none)\n");
+
+	sieve_result_printf(&penv, "\n");
+
+	return TRUE;
+}
+
+/*
+ * Result execution
+ */
+
+static bool _sieve_result_implicit_keep
+	(struct sieve_result *result, bool rollback)
+{
+	struct sieve_result_action *rac;
+	bool success = TRUE;
+	struct sieve_result_side_effect *rsef, *rsef_first = NULL;
+	void *tr_context = NULL;
+	struct sieve_action act_keep;
+
+	if ( rollback )
+		act_keep = result->failure_action;
+	else
+		act_keep = result->keep_action;
+
+	/* If keep is a non-action, return right away */
+	if ( act_keep.def == NULL ) return TRUE;
+
+	/* Scan for execution of keep-equal actions */
+	rac = result->first_action;
+	while ( rac != NULL ) {
+		if ( rac->action.def == act_keep.def && act_keep.def->equals != NULL &&
+			act_keep.def->equals
+				(result->action_env.scriptenv, NULL, &rac->action) &&
+					rac->action.executed )
+			return TRUE;
+
+		rac = rac->next;
+	}
+
+	/* Apply any implicit side effects if applicable */
+	if ( !rollback && result->action_contexts != NULL ) {
+		struct sieve_result_action_context *actctx;
+
+		/* Check for implicit side effects to keep action */
+		actctx = (struct sieve_result_action_context *)
+				hash_table_lookup(result->action_contexts, act_keep.def);
+
+		if ( actctx != NULL && actctx->seffects != NULL )
+			rsef_first = actctx->seffects->first_effect;
+	}
+
+	/* Start keep action */
+	if ( act_keep.def->start != NULL )
+		success = act_keep.def->start
+			(&act_keep, &result->action_env,  &tr_context);
+
+	/* Execute keep action */
+	if ( success ) {
+		rsef = rsef_first;
+		while ( success && rsef != NULL ) {
+			struct sieve_side_effect *sef = &rsef->seffect;
+
+			if ( sef->def->pre_execute != NULL )
+				success = success && sef->def->pre_execute
+					(sef, &act_keep, &result->action_env, &sef->context, tr_context);
+			rsef = rsef->next;
+		}
+
+		if ( act_keep.def->execute != NULL )
+			success = success && act_keep.def->execute
+				(&act_keep, &result->action_env, tr_context);
+
+		rsef = rsef_first;
+		while ( success && rsef != NULL ) {
+			struct sieve_side_effect *sef = &rsef->seffect;
+
+			if ( sef->def->post_execute != NULL )
+				success = success && sef->def->post_execute
+					(sef, &act_keep, &result->action_env, tr_context);
+			rsef = rsef->next;
+		}
+	}
+
+	/* Finish keep action */
+	if ( success ) {
+		bool dummy = TRUE;
+
+		if ( act_keep.def->commit != NULL )
+			success = act_keep.def->commit
+				(&act_keep, &result->action_env, tr_context, &dummy);
+
+		rsef = rsef_first;
+		while ( rsef != NULL ) {
+			struct sieve_side_effect *sef = &rsef->seffect;
+			bool keep = TRUE;
+
+			if ( sef->def->post_commit != NULL )
+				sef->def->post_commit
+					(sef, &act_keep, &result->action_env, tr_context, &keep);
+			rsef = rsef->next;
+		}
+
+		return success;
+	}
+
+	/* Failed, rollback */
+	if ( act_keep.def->rollback != NULL )
+		act_keep.def->rollback
+			(&act_keep, &result->action_env, tr_context, success);
+
+	return FALSE;
+}
+
+bool sieve_result_implicit_keep
+(struct sieve_result *result)
+{
+	const struct sieve_script_env *senv = result->action_env.scriptenv;
+	struct sieve_exec_status dummy_status;
+
+	result->action_env.exec_status =
+		( senv->exec_status == NULL ? &dummy_status : senv->exec_status );
+
+	return _sieve_result_implicit_keep(result, TRUE);
+}
+
+void sieve_result_mark_executed(struct sieve_result *result)
+{
+	struct sieve_result_action *first_action, *rac;
+
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	result->last_attempted_action = result->last_action;
+
+	rac = first_action;
+	while ( rac != NULL ) {
+		if ( rac->action.def != NULL )
+			rac->action.executed = TRUE;
+
+		rac = rac->next;
+	}
+}
+
+int sieve_result_execute
+(struct sieve_result *result, bool *keep)
+{
+	const struct sieve_script_env *senv = result->action_env.scriptenv;
+	struct sieve_exec_status dummy_status;
+	bool implicit_keep = TRUE;
+	bool success = TRUE, commit_ok;
+	struct sieve_result_action *rac, *first_action;
+	struct sieve_result_action *last_attempted;
+
+	if ( keep != NULL ) *keep = FALSE;
+
+	/* Prepare environment */
+
+	result->action_env.exec_status =
+		( senv->exec_status == NULL ? &dummy_status : senv->exec_status );
+
+	/* Make notice of this attempt */
+
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	result->last_attempted_action = result->last_action;
+
+	/*
+	 * Transaction start
+	 */
+
+	rac = first_action;
+	while ( success && rac != NULL ) {
+		struct sieve_action *act = &rac->action;
+
+		/* Skip non-actions (inactive keep) and executed ones */
+		if ( act->def == NULL || act->executed ) {
+			rac = rac->next;
+			continue;
+		}
+
+		if ( act->def->start != NULL ) {
+			rac->success = act->def->start
+				(act, &result->action_env, &rac->tr_context);
+			success = success && rac->success;
+		}
+
+		rac = rac->next;
+	}
+
+	/*
+	 * Transaction execute
+	 */
+
+	last_attempted = rac;
+	rac = first_action;
+	while ( success && rac != NULL ) {
+		struct sieve_action *act = &rac->action;
+		struct sieve_result_side_effect *rsef;
+		struct sieve_side_effect *sef;
+
+		/* Skip non-actions (inactive keep) and executed ones */
+		if ( act->def == NULL || act->executed ) {
+			rac = rac->next;
+			continue;
+		}
+
+		/* Execute pre-execute event of side effects */
+		rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+		while ( success && rsef != NULL ) {
+			sef = &rsef->seffect;
+			if ( sef->def != NULL && sef->def->pre_execute != NULL )
+				success = success & sef->def->pre_execute
+					(sef, act, &result->action_env, &sef->context, rac->tr_context);
+			rsef = rsef->next;
+		}
+
+		/* Execute the action itself */
+		if ( success && act->def != NULL && act->def->execute != NULL ) {
+			rac->success = act->def->execute
+				(act, &result->action_env, rac->tr_context);
+			success = success && rac->success;
+		}
+
+		/* Execute post-execute event of side effects */
+		rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+		while ( success && rsef != NULL ) {
+			sef = &rsef->seffect;
+			if ( sef->def != NULL && sef->def->post_execute != NULL )
+				success = success && sef->def->post_execute
+					(sef, act, &result->action_env, rac->tr_context);
+			rsef = rsef->next;
+		}
+
+		rac = rac->next;
+	}
+
+	/*
+	 * Transaction commit/rollback
+	 */
+
+	commit_ok = success;
+	rac = first_action;
+	while ( rac != NULL && rac != last_attempted ) {
+		struct sieve_action *act = &rac->action;
+		struct sieve_result_side_effect *rsef;
+		struct sieve_side_effect *sef;
+
+		if ( success ) {
+			bool impl_keep = TRUE;
+
+			if ( rac->keep && keep != NULL ) *keep = TRUE;
+
+			/* Skip non-actions (inactive keep) and executed ones */
+			if ( act->def == NULL || act->executed ) {
+				rac = rac->next;
+				continue;
+			}
+
+			if ( act->def->commit != NULL ) {
+				act->executed = act->def->commit
+					(act, &result->action_env, rac->tr_context, &impl_keep);
+				commit_ok = act->executed && commit_ok;
+			}
+
+			/* Execute post_commit event of side effects */
+			rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				sef = &rsef->seffect;
+				if ( sef->def->post_commit != NULL )
+					sef->def->post_commit
+						(sef, act, &result->action_env, rac->tr_context, &impl_keep);
+				rsef = rsef->next;
+			}
+
+			implicit_keep = implicit_keep && impl_keep;
+		} else {
+			/* Skip non-actions (inactive keep) and executed ones */
+			if ( act->def == NULL || act->executed ) {
+				rac = rac->next;
+				continue;
+			}
+
+			if ( act->def->rollback != NULL )
+				act->def->rollback
+					(act, &result->action_env, rac->tr_context, rac->success);
+
+			/* Rollback side effects */
+			rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				sef = &rsef->seffect;
+				if ( sef->def && sef->def->rollback != NULL )
+					sef->def->rollback
+						(sef, act, &result->action_env, rac->tr_context, rac->success);
+				rsef = rsef->next;
+			}
+		}
+
+		rac = rac->next;
+	}
+
+	if ( implicit_keep && keep != NULL ) *keep = TRUE;
+
+	/* Return value indicates whether the caller should attempt an implicit keep
+	 * of its own. So, if the above transaction fails, but the implicit keep below
+	 * succeeds, the return value is still true. An error is/should be logged
+	 * though.
+	 */
+
+	/* Execute implicit keep if the transaction failed or when the implicit keep
+	 * was not canceled during transaction.
+	 */
+	if ( !commit_ok || implicit_keep ) {
+		if ( !_sieve_result_implicit_keep(result, !commit_ok) )
+			return SIEVE_EXEC_KEEP_FAILED;
+
+		return ( commit_ok ?
+			SIEVE_EXEC_OK            /* Success */ :
+			SIEVE_EXEC_FAILURE       /* Implicit keep executed */ );
+	}
+
+	/* Unconditional success */
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Result evaluation
+ */
+
+struct sieve_result_iterate_context {
+	struct sieve_result *result;
+	struct sieve_result_action *action;
+};
+
+struct sieve_result_iterate_context *sieve_result_iterate_init
+(struct sieve_result *result)
+{
+	struct sieve_result_iterate_context *rictx =
+		t_new(struct sieve_result_iterate_context, 1);
+
+	rictx->result = result;
+	rictx->action = result->first_action;
+
+	return rictx;
+}
+
+const struct sieve_action *sieve_result_iterate_next
+(struct sieve_result_iterate_context *rictx, bool *keep)
+{
+	struct sieve_result_action *rac;
+
+	if ( rictx == NULL )
+		return  NULL;
+
+	rac = rictx->action;
+	if ( rac != NULL ) {
+		rictx->action = rac->next;
+
+		if ( keep != NULL )
+			*keep = rac->keep;
+
+		return &rac->action;
+	}
+
+	return NULL;
+}
+
+/*
+ * Side effects list
+ */
+
+struct sieve_side_effects_list *sieve_side_effects_list_create
+	(struct sieve_result *result)
+{
+	struct sieve_side_effects_list *list =
+		p_new(result->pool, struct sieve_side_effects_list, 1);
+
+	list->result = result;
+	list->first_effect = NULL;
+	list->last_effect = NULL;
+
+	return list;
+};
+
+void sieve_side_effects_list_add
+(struct sieve_side_effects_list *list, const struct sieve_side_effect *seffect)
+{
+	struct sieve_result_side_effect *reffect;
+
+	/* Prevent duplicates */
+	reffect = list->first_effect;
+	while ( reffect != NULL ) {
+		if ( reffect->seffect.def == seffect->def ) return;
+
+		reffect = reffect->next;
+	}
+
+	/* Create new side effect object */
+	reffect = p_new(list->result->pool, struct sieve_result_side_effect, 1);
+	reffect->seffect = *seffect;
+
+	/* Add */
+	if ( list->first_effect == NULL ) {
+		list->first_effect = reffect;
+		list->last_effect = reffect;
+		reffect->prev = NULL;
+		reffect->next = NULL;
+	} else {
+		list->last_effect->next = reffect;
+		reffect->prev = list->last_effect;
+		list->last_effect = reffect;
+		reffect->next = NULL;
+	}
+}
+
+
+
Index: b/sieve/src/lib-sieve/sieve-result.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-result.h
@@ -0,0 +1,162 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_RESULT_H
+#define __SIEVE_RESULT_H
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+ * Types
+ */
+
+struct sieve_side_effects_list;
+
+/*
+ * Result object
+ */
+
+struct sieve_result;
+
+struct sieve_result *sieve_result_create
+	(struct sieve_instance *svinst, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv,
+		struct sieve_error_handler *ehandler);
+
+void sieve_result_ref(struct sieve_result *result);
+
+void sieve_result_unref(struct sieve_result **result);
+
+pool_t sieve_result_pool(struct sieve_result *result);
+
+/*
+ * Getters/Setters
+ */
+
+struct sieve_error_handler *sieve_result_get_error_handler
+	(struct sieve_result *result);
+void sieve_result_set_error_handler
+	(struct sieve_result *result, struct sieve_error_handler *ehandler);
+
+const struct sieve_script_env *sieve_result_get_script_env
+	(struct sieve_result *result);
+const struct sieve_message_data *sieve_result_get_message_data
+	(struct sieve_result *result);
+struct sieve_message_context *sieve_result_get_message_context
+	(struct sieve_result *result);
+
+/*
+ * Extension support
+ */
+
+void sieve_result_extension_set_context
+	(struct sieve_result *result, const struct sieve_extension *ext,
+		void *context);
+const void *sieve_result_extension_get_context
+	(struct sieve_result *result, const struct sieve_extension *ext);
+
+/*
+ * Result printing
+ */
+
+struct sieve_result_print_env {
+	struct sieve_result *result;
+	const struct sieve_script_env *scriptenv;
+	struct ostream *stream;
+};
+
+void sieve_result_vprintf
+	(const struct sieve_result_print_env *penv, const char *fmt, va_list args);
+void sieve_result_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_action_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_seffect_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+bool sieve_result_print
+	(struct sieve_result *result, const struct sieve_script_env *senv,
+		struct ostream *stream, bool *keep);
+
+/*
+ * Error handling
+ */
+
+void sieve_result_vlog_message
+	(const struct sieve_action_exec_env *aenv, sieve_error_func_t log_func,
+		const char *fmt, va_list args);
+void sieve_result_log_message
+	(const struct sieve_action_exec_env *aenv, sieve_error_func_t log_func,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+void sieve_result_log
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_warning
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_error
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+/*
+ * Result composition
+ */
+
+void sieve_result_add_implicit_side_effect
+(struct sieve_result *result, const struct sieve_action_def *to_action,
+	bool to_keep, const struct sieve_extension *ext,
+	const struct sieve_side_effect_def *seffect, void *context);
+
+int sieve_result_add_action
+	(const struct sieve_runtime_env *renv, const struct sieve_extension *ext,
+		const struct sieve_action_def *act_def,
+		struct sieve_side_effects_list *seffects, unsigned int source_line,
+		void *context, unsigned int instance_limit);
+int sieve_result_add_keep
+	(const struct sieve_runtime_env *renv,
+		struct sieve_side_effects_list *seffects, unsigned int source_line);
+
+void sieve_result_set_keep_action
+	(struct sieve_result *result, const struct sieve_extension *ext,
+		const struct sieve_action_def *act_def);
+void sieve_result_set_failure_action
+	(struct sieve_result *result, const struct sieve_extension *ext,
+		const struct sieve_action_def *act_def);
+
+/*
+ * Result execution
+ */
+
+bool sieve_result_implicit_keep(struct sieve_result *result);
+
+void sieve_result_mark_executed(struct sieve_result *result);
+
+int sieve_result_execute(struct sieve_result *result, bool *keep);
+
+/*
+ * Result evaluation
+ */
+
+struct sieve_result_iterate_context;
+
+struct sieve_result_iterate_context *sieve_result_iterate_init
+	(struct sieve_result *result);
+const struct sieve_action *sieve_result_iterate_next
+	(struct sieve_result_iterate_context *rictx, bool *keep);
+
+/*
+ * Side effects list
+ */
+
+struct sieve_side_effects_list *sieve_side_effects_list_create
+	(struct sieve_result *result);
+void sieve_side_effects_list_add
+	(struct sieve_side_effects_list *list,
+		const struct sieve_side_effect *seffect);
+
+#endif
Index: b/sieve/src/lib-sieve/sieve-script-private.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-script-private.h
@@ -0,0 +1,43 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_PRIVATE_H
+#define __SIEVE_SCRIPT_PRIVATE_H
+
+#include "sieve-script.h"
+
+/*
+ * Script object
+ */
+
+struct sieve_script {
+	pool_t pool;
+	unsigned int refcount;
+
+	struct sieve_instance *svinst;
+
+	struct stat st;
+	struct stat lnk_st;
+	time_t mtime;
+
+	struct sieve_error_handler *ehandler;
+
+	/* Parameters */
+	const char *name;
+	const char *basename;
+	const char *filename;
+	const char *path;
+	const char *dirpath;
+	const char *binpath;
+
+	/* Stream */
+	int fd; /* FIXME: we could use the stream's autoclose facility */
+	struct istream *stream;
+};
+
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, struct sieve_instance *svinst,
+	const char *path, const char *name, struct sieve_error_handler *ehandler,
+	bool *exists_r);
+
+#endif /* __SIEVE_SCRIPT_PRIVATE_H */
Index: b/sieve/src/lib-sieve/sieve-script.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-script.c
@@ -0,0 +1,361 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "istream.h"
+#include "eacces-error.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+#include "sieve-script-private.h"
+
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/*
+ * Configuration
+ */
+
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+/*
+ * Filename to name/name to filename
+ */
+
+static inline const char *_sieve_scriptfile_get_basename(const char *filename)
+{
+	const char *ext;
+
+	/* Extract the script name */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return filename;
+
+	return t_strdup_until(filename, ext);
+}
+
+bool sieve_script_file_has_extension(const char *filename)
+{
+	const char *ext;
+
+ 	/* See if it ends in .sieve already */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return FALSE;
+
+	return TRUE;
+}
+
+static inline const char *_sieve_scriptfile_from_name(const char *name)
+{
+	if ( !sieve_script_file_has_extension(name) )
+		return t_strconcat(name, ".sieve", NULL);
+
+	return name;
+}
+
+
+/*
+ * Script object
+ */
+
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, struct sieve_instance *svinst,
+	const char *path, const char *name, struct sieve_error_handler *ehandler,
+	bool *exists_r)
+{
+	int ret;
+	pool_t pool;
+	struct stat st;
+	struct stat lnk_st;
+	const char *filename, *dirpath, *basename, *binpath;
+
+	if ( exists_r != NULL )
+		*exists_r = TRUE;
+
+	T_BEGIN {
+
+		/* Extract filename from path */
+
+		filename = strrchr(path, '/');
+		if ( filename == NULL ) {
+			dirpath = "";
+			filename = path;
+		} else {
+			dirpath = t_strdup_until(path, filename);
+			filename++;
+		}
+
+		basename = _sieve_scriptfile_get_basename(filename);
+
+		if ( *dirpath == '\0' )
+			binpath = t_strconcat(basename, ".svbin", NULL);
+		else
+			binpath = t_strconcat(dirpath, "/", basename, ".svbin", NULL);
+
+		if ( name == NULL ) {
+			name = basename;
+		} else if ( *name == '\0' ) {
+			name = NULL;
+		} else {
+			basename = name;
+		}
+
+		/* First obtain stat data from the system */
+
+		if ( (ret=lstat(path, &st)) < 0 ) {
+			if ( errno == ENOENT ) {
+				if ( exists_r == NULL )
+					sieve_error(ehandler, basename, "sieve script does not exist");
+				else
+					*exists_r = FALSE;
+			} else
+				sieve_critical(ehandler, basename,
+					"failed to stat sieve script: lstat(%s) failed: %m", path);
+
+			script = NULL;
+			ret = 1;
+
+		} else {
+			/* Record stat information from the symlink */
+			lnk_st = st;
+
+			/* Only create/init the object if it stat()s without problems */
+			if (S_ISLNK(st.st_mode)) {
+				if ( (ret=stat(path, &st)) < 0 ) {
+					if ( errno == ENOENT ) {
+						if ( exists_r == NULL )
+							sieve_error(ehandler, basename, "sieve script does not exist");
+						else
+							*exists_r = FALSE;
+					} else
+						sieve_critical(ehandler, basename,
+							"failed to stat sieve script: stat(%s) failed: %m", path);
+
+					script = NULL;
+					ret = 1;
+				}
+			}
+
+			if ( ret == 0 && !S_ISREG(st.st_mode) ) {
+				sieve_critical(ehandler, basename,
+					"sieve script file '%s' is not a regular file.", path);
+				script = NULL;
+				ret = 1;
+			}
+		}
+
+		if ( ret <= 0 ) {
+			if ( script == NULL ) {
+				pool = pool_alloconly_create("sieve_script", 1024);
+				script = p_new(pool, struct sieve_script, 1);
+				script->pool = pool;
+			} else
+				pool = script->pool;
+
+			script->refcount = 1;
+			script->svinst = svinst;
+
+			script->ehandler = ehandler;
+			sieve_error_handler_ref(ehandler);
+
+			script->st = st;
+			script->lnk_st = lnk_st;
+			script->path = p_strdup(pool, path);
+			script->filename = p_strdup(pool, filename);
+			script->dirpath = p_strdup(pool, dirpath);
+			script->binpath = p_strdup(pool, binpath);
+			script->basename = p_strdup(pool, basename);
+
+			if ( name != NULL )
+				script->name = p_strdup(pool, name);
+			else
+				script->name = NULL;
+		}
+	} T_END;
+
+	return script;
+}
+
+struct sieve_script *sieve_script_create
+(struct sieve_instance *svinst, const char *path, const char *name,
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	return sieve_script_init(NULL, svinst, path, name, ehandler, exists_r);
+}
+
+struct sieve_script *sieve_script_create_in_directory
+(struct sieve_instance *svinst, const char *dirpath, const char *name,
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	const char *path;
+
+	if ( dirpath[strlen(dirpath)-1] == '/' )
+		path = t_strconcat(dirpath,
+			_sieve_scriptfile_from_name(name), NULL);
+	else
+		path = t_strconcat(dirpath, "/",
+			_sieve_scriptfile_from_name(name), NULL);
+
+	return sieve_script_init(NULL, svinst, path, name, ehandler, exists_r);
+}
+
+void sieve_script_ref(struct sieve_script *script)
+{
+	script->refcount++;
+}
+
+void sieve_script_unref(struct sieve_script **script)
+{
+	i_assert((*script)->refcount > 0);
+
+	if (--(*script)->refcount != 0)
+		return;
+
+	if ( (*script)->stream != NULL )
+		i_stream_destroy(&(*script)->stream);
+
+	sieve_error_handler_unref(&(*script)->ehandler);
+
+	pool_unref(&(*script)->pool);
+
+	*script = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+const char *sieve_script_name(const struct sieve_script *script)
+{
+	return script->name;
+}
+
+const char *sieve_script_filename(const struct sieve_script *script)
+{
+	return script->filename;
+}
+
+const char *sieve_script_path(const struct sieve_script *script)
+{
+	return script->path;
+}
+
+const char *sieve_script_dirpath(const struct sieve_script *script)
+{
+	return script->dirpath;
+}
+
+const char *sieve_script_binpath(const struct sieve_script *script)
+{
+	return script->binpath;
+}
+
+mode_t sieve_script_permissions(const struct sieve_script *script)
+{
+	return script->st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO);
+}
+
+struct sieve_instance *sieve_script_svinst(const struct sieve_script *script)
+{
+	return script->svinst;
+}
+
+/*
+ * Stream manageement
+ */
+
+struct istream *sieve_script_open
+(struct sieve_script *script, bool *deleted_r)
+{
+	int fd;
+	struct stat st;
+	struct istream *result;
+
+	if ( deleted_r != NULL )
+		*deleted_r = FALSE;
+
+	if ( (fd=open(script->path, O_RDONLY)) < 0 ) {
+		if ( errno == ENOENT ) {
+			if ( deleted_r == NULL )
+				/* Not supposed to occur, create() does stat already */
+				sieve_error(script->ehandler, script->basename,
+					"sieve script does not exist");
+			else
+				*deleted_r = TRUE;
+		} else if ( errno == EACCES ) {
+			sieve_critical(script->ehandler, script->path,
+				"failed to open sieve script: %s",
+				eacces_error_get("open", script->path));
+		} else {
+			sieve_critical(script->ehandler, script->path,
+				"failed to open sieve script: open(%s) failed: %m", script->path);
+		}
+		return NULL;
+	}
+
+	if ( fstat(fd, &st) != 0 ) {
+		sieve_critical(script->ehandler, script->path,
+			"failed to open sieve script: fstat(fd=%s) failed: %m", script->path);
+		result = NULL;
+	} else {
+		/* Re-check the file type just to be sure */
+		if ( !S_ISREG(st.st_mode) ) {
+			sieve_critical(script->ehandler, script->path,
+				"sieve script file '%s' is not a regular file", script->path);
+			result = NULL;
+		} else {
+			result = script->stream =
+				i_stream_create_fd(fd, SIEVE_READ_BLOCK_SIZE, TRUE);
+			script->st = script->lnk_st = st;
+		}
+	}
+
+	if ( result == NULL ) {
+		/* Something went wrong, close the fd */
+		if ( close(fd) != 0 ) {
+			sieve_sys_error(
+				"failed to close sieve script: close(fd=%s) failed: %m",
+				script->path);
+		}
+	}
+
+	return result;
+}
+
+void sieve_script_close(struct sieve_script *script)
+{
+	i_stream_destroy(&script->stream);
+}
+
+uoff_t sieve_script_get_size(const struct sieve_script *script)
+{
+	return script->st.st_size;
+}
+
+/*
+ * Comparison
+ */
+
+int sieve_script_cmp
+(const struct sieve_script *script1, const struct sieve_script *script2)
+{
+	if ( script1 == NULL || script2 == NULL )
+		return -1;
+
+	return ( script1->st.st_ino == script2->st.st_ino ) ? 0 : -1;
+}
+
+unsigned int sieve_script_hash(const struct sieve_script *script)
+{
+	return (unsigned int) script->st.st_ino;
+}
+
+bool sieve_script_newer
+(const struct sieve_script *script, time_t time)
+{
+	return ( script->st.st_mtime > time || script->lnk_st.st_mtime > time );
+}
Index: b/sieve/src/lib-sieve/sieve-script.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-script.h
@@ -0,0 +1,72 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_H
+#define __SIEVE_SCRIPT_H
+
+#include "sieve-common.h"
+
+#include <sys/types.h>
+
+/*
+ * Sieve script object
+ */
+
+struct sieve_script;
+
+struct sieve_script *sieve_script_create
+	(struct sieve_instance *svinst, const char *path, const char *name,
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+struct sieve_script *sieve_script_create_in_directory
+	(struct sieve_instance *svinst, const char *dirpath, const char *name,
+    	struct sieve_error_handler *ehandler, bool *exists_r);
+
+void sieve_script_ref(struct sieve_script *script);
+void sieve_script_unref(struct sieve_script **script);
+
+/*
+ * Filename filter
+ */
+
+bool sieve_script_file_has_extension(const char *filename);
+
+/*
+ * Accessors
+ */
+
+const char *sieve_script_name(const struct sieve_script *script);
+const char *sieve_script_filename(const struct sieve_script *script);
+const char *sieve_script_path(const struct sieve_script *script);
+const char *sieve_script_binpath(const struct sieve_script *script);
+const char *sieve_script_dirpath(const struct sieve_script *script);
+
+mode_t sieve_script_permissions(const struct sieve_script *script);
+
+struct sieve_instance *sieve_script_svinst(const struct sieve_script *script);
+
+/*
+ * Stream management
+ */
+
+struct istream *sieve_script_open(struct sieve_script *script, bool *deleted_r);
+void sieve_script_close(struct sieve_script *script);
+
+uoff_t sieve_script_get_size(const struct sieve_script *script);
+
+/*
+ * Comparison
+ */
+
+int sieve_script_cmp
+	(const struct sieve_script *script1, const struct sieve_script *script2);
+unsigned int sieve_script_hash(const struct sieve_script *script);
+bool sieve_script_newer(const struct sieve_script *script, time_t time);
+
+static inline bool sieve_script_equals
+	(const struct sieve_script *script1, const struct sieve_script *script2)
+{
+	return ( sieve_script_cmp(script1, script2) == 0 );
+}
+
+#endif /* __SIEVE_SCRIPT_H */
Index: b/sieve/src/lib-sieve/sieve-settings.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-settings.c
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-settings.h"
+
+#include <stdlib.h>
+
+bool sieve_get_uint_setting
+(struct sieve_instance *svinst, const char *identifier,
+	unsigned long long int *value_r)
+{
+	const char *str_value;
+	char *endp;
+
+	str_value = sieve_get_setting(svinst, identifier);
+
+	if ( str_value == NULL || *str_value == '\0' )
+		return FALSE;
+
+	*value_r = strtoull(str_value, &endp, 10);
+
+	if ( *endp != '\0' ) {
+		sieve_sys_warning("invalid unsigned integer value for setting '%s': '%s'",
+			identifier, str_value);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_get_int_setting
+(struct sieve_instance *svinst, const char *identifier,
+	long long int *value_r)
+{
+	const char *str_value;
+	char *endp;
+
+	str_value = sieve_get_setting(svinst, identifier);
+
+	if ( str_value == NULL || *str_value == '\0' )
+		return FALSE;
+
+	*value_r = strtoll(str_value, &endp, 10);
+
+	if ( *endp != '\0' ) {
+		sieve_sys_warning("invalid integer value for setting '%s': '%s'",
+			identifier, str_value);
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/sieve-settings.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-settings.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SETTINGS_H
+#define __SIEVE_SETTINGS_H
+
+#include "sieve-common.h"
+
+/*
+ * Settings
+ */
+
+static inline const char *sieve_get_setting
+(struct sieve_instance *svinst, const char *identifier)
+{
+	const struct sieve_callbacks *callbacks = svinst->callbacks;
+
+	if ( callbacks == NULL || callbacks->get_setting == NULL )
+		return NULL;
+
+	return callbacks->get_setting(svinst->context, identifier);
+}
+
+bool sieve_get_uint_setting
+(struct sieve_instance *svinst, const char *identifier,
+	unsigned long long int *value_r);
+
+bool sieve_get_int_setting
+(struct sieve_instance *svinst, const char *identifier,
+	long long int *value_r);
+
+/*
+ * Home directory
+ */
+
+static inline const char *sieve_get_homedir
+(struct sieve_instance *svinst)
+{
+	const struct sieve_callbacks *callbacks = svinst->callbacks;
+
+	if ( callbacks == NULL || callbacks->get_homedir == NULL )
+		return NULL;
+
+	return callbacks->get_homedir(svinst->context);
+}
+
+#endif /* __SIEVE_SETTINGS_H */
Index: b/sieve/src/lib-sieve/sieve-types.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-types.h
@@ -0,0 +1,118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_TYPES_H
+#define __SIEVE_TYPES_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+/* Enable runtime trace functionality */
+#define SIEVE_RUNTIME_TRACE
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_instance;
+struct sieve_callbacks;
+
+struct sieve_script;
+struct sieve_binary;
+
+struct sieve_message_data;
+struct sieve_script_env;
+struct sieve_exec_status;
+
+/*
+ * Callbacks
+ */
+
+struct sieve_callbacks {
+	const char *(*get_homedir)(void *context);
+	const char *(*get_setting)(void *context, const char *identifier);
+};
+
+/*
+ * Message data
+ *
+ * - The mail message + envelope data
+ */
+
+struct sieve_message_data {
+	struct mail *mail;
+	const char *return_path;
+	const char *to_address;
+	const char *auth_user;
+	const char *id;
+};
+
+/*
+ * Script environment
+ *
+ * - Environment for currently executing script
+ */
+
+struct sieve_script_env {
+	/* Logging related */
+	const char *action_log_format;
+
+	/* Mail-related */
+	struct mail_namespace *namespaces;
+	const char *default_mailbox;
+	bool mailbox_autocreate;
+	bool mailbox_autosubscribe;
+
+	/* System-related */
+	const char *username;
+	const char *hostname;
+	const char *postmaster_address;
+
+	/* Callbacks */
+
+	/* Interface for sending mail */
+	void *(*smtp_open)
+		(const char *destination, const char *return_path, FILE **file_r);
+	bool (*smtp_close)(void *handle);
+
+	/* Interface for marking and checking duplicates */
+	int (*duplicate_check)
+		(const void *id, size_t id_size, const char *user);
+	void (*duplicate_mark)
+		(const void *id, size_t id_size, const char *user, time_t time);
+
+	/* Execution status record */
+	struct sieve_exec_status *exec_status;
+
+	/* Trace stream */
+	struct ostream *trace_stream;
+};
+
+#define SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) \
+	(senv->default_mailbox == NULL ? "INBOX" : senv->default_mailbox )
+
+/*
+ * Script executionstatus
+ */
+
+struct sieve_exec_status {
+	bool message_saved;
+	bool message_forwarded;
+	bool tried_default_save;
+	bool keep_original;
+	struct mail_storage *last_storage;
+};
+
+/*
+ * Execution exit codes
+ */
+
+enum sieve_execution_exitcode {
+	SIEVE_EXEC_OK          = 1,
+	SIEVE_EXEC_FAILURE     = 0,
+	SIEVE_EXEC_BIN_CORRUPT = -1,
+	SIEVE_EXEC_KEEP_FAILED = -2
+};
+
+#endif /* __SIEVE_TYPES_H */
Index: b/sieve/src/lib-sieve/sieve-validator.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-validator.c
@@ -0,0 +1,1394 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+#include "buffer.h"
+#include "mempool.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+
+#include "sieve-comparators.h"
+#include "sieve-address-parts.h"
+
+/*
+ * Forward declarations
+ */
+
+static void sieve_validator_register_core_commands
+	(struct sieve_validator *valdtr);
+static void sieve_validator_register_core_tests
+	(struct sieve_validator *valdtr);
+
+/*
+ * Types
+ */
+
+/* Tag registration */
+
+struct sieve_tag_registration {
+	const struct sieve_argument_def *tag_def;
+	const struct sieve_extension *ext;
+
+	const char *identifier;
+	int id_code;
+};
+
+/* Command registration */
+
+struct sieve_command_registration {
+	const struct sieve_command_def *cmd_def;
+	const struct sieve_extension *ext;
+
+	ARRAY_DEFINE(normal_tags, struct sieve_tag_registration *);
+	ARRAY_DEFINE(instanced_tags, struct sieve_tag_registration *);
+	ARRAY_DEFINE(persistent_tags, struct sieve_tag_registration *);
+};
+
+/* Default (literal) arguments */
+
+struct sieve_default_argument {
+	const struct sieve_argument_def *arg_def;
+	const struct sieve_extension *ext;
+
+	struct sieve_default_argument *overrides;
+};
+
+/*
+ * Validator extension
+ */
+
+struct sieve_validator_extension_reg {
+	const struct sieve_validator_extension *valext;
+	const struct sieve_extension *ext;
+	struct sieve_ast_argument *arg;
+	void *context;
+
+	bool loaded;
+};
+
+/*
+ * Validator
+ */
+
+struct sieve_validator {
+	pool_t pool;
+
+	struct sieve_instance *svinst;
+	struct sieve_ast *ast;
+	struct sieve_script *script;
+
+	struct sieve_error_handler *ehandler;
+
+	bool finished_require;
+
+	/* Registries */
+
+	struct hash_table *commands;
+
+	ARRAY_DEFINE(extensions, struct sieve_validator_extension_reg);
+
+	/* This is currently a wee bit ugly and needs more thought */
+	struct sieve_default_argument default_arguments[SAT_COUNT];
+
+	/* Default argument processing state (FIXME: ugly) */
+	struct sieve_default_argument *current_defarg;
+	enum sieve_argument_type current_defarg_type;
+	bool current_defarg_constant;
+};
+
+/*
+ * Error handling
+ */
+
+void sieve_validator_warning
+(struct sieve_validator *valdtr, unsigned int source_line,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_vwarning(valdtr->ehandler,
+		sieve_error_script_location(valdtr->script, source_line),
+		fmt, args);
+	va_end(args);
+
+}
+
+void sieve_validator_error
+(struct sieve_validator *valdtr, unsigned int source_line,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_verror(valdtr->ehandler,
+		sieve_error_script_location(valdtr->script, source_line),
+		fmt, args);
+	va_end(args);
+}
+
+void sieve_validator_critical
+(struct sieve_validator *valdtr, unsigned int source_line,
+	const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	sieve_vcritical(valdtr->ehandler,
+		sieve_error_script_location(valdtr->script, source_line),
+		fmt, args);
+	va_end(args);
+}
+
+/*
+ * Validator object
+ */
+
+struct sieve_validator *sieve_validator_create
+(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	pool_t pool;
+	struct sieve_validator *valdtr;
+	const struct sieve_extension *const *ext_preloaded;
+	unsigned int i, ext_count;
+
+	pool = pool_alloconly_create("sieve_validator", 8192);
+	valdtr = p_new(pool, struct sieve_validator, 1);
+	valdtr->pool = pool;
+
+	valdtr->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	valdtr->ast = ast;
+	sieve_ast_ref(ast);
+
+	valdtr->script = sieve_ast_script(ast);
+	valdtr->svinst = sieve_script_svinst(valdtr->script);
+
+	/* Setup default arguments */
+	valdtr->default_arguments[SAT_NUMBER].arg_def = &number_argument;
+	valdtr->default_arguments[SAT_NUMBER].ext = NULL;
+	valdtr->default_arguments[SAT_VAR_STRING].arg_def = &string_argument;
+	valdtr->default_arguments[SAT_VAR_STRING].ext = NULL;
+	valdtr->default_arguments[SAT_CONST_STRING].arg_def = &string_argument;
+	valdtr->default_arguments[SAT_CONST_STRING].ext = NULL;
+	valdtr->default_arguments[SAT_STRING_LIST].arg_def = &string_list_argument;
+	valdtr->default_arguments[SAT_STRING_LIST].ext = NULL;
+
+	/* Setup storage for extension contexts */
+	p_array_init(&valdtr->extensions, pool,
+		sieve_extensions_get_count(valdtr->svinst));
+
+	/* Setup command registry */
+	valdtr->commands = hash_table_create
+		(default_pool, pool, 0, strcase_hash, (hash_cmp_callback_t *)strcasecmp);
+	sieve_validator_register_core_commands(valdtr);
+	sieve_validator_register_core_tests(valdtr);
+
+	/* Pre-load core language features implemented as 'extensions' */
+	ext_preloaded = sieve_extensions_get_preloaded(valdtr->svinst, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension_def *ext_def = ext_preloaded[i]->def;
+
+		if ( ext_def != NULL && ext_def->validator_load != NULL )
+			(void)ext_def->validator_load(ext_preloaded[i], valdtr);
+	}
+
+	return valdtr;
+}
+
+void sieve_validator_free(struct sieve_validator **valdtr)
+{
+	const struct sieve_validator_extension_reg *extrs;
+	unsigned int ext_count, i;
+
+	hash_table_destroy(&(*valdtr)->commands);
+	sieve_ast_unref(&(*valdtr)->ast);
+
+	sieve_error_handler_unref(&(*valdtr)->ehandler);
+
+	/* Signal registered extensions that the validator is being destroyed */
+	extrs = array_get(&(*valdtr)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].valext != NULL && extrs[i].valext->free != NULL )
+			extrs[i].valext->free(extrs[i].ext, *valdtr, extrs[i].context);
+	}
+
+	pool_unref(&(*valdtr)->pool);
+
+	*valdtr = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_validator_pool(struct sieve_validator *valdtr)
+{
+	return valdtr->pool;
+}
+
+struct sieve_error_handler *sieve_validator_error_handler
+(struct sieve_validator *valdtr)
+{
+	return valdtr->ehandler;
+}
+
+struct sieve_ast *sieve_validator_ast
+(struct sieve_validator *valdtr)
+{
+	return valdtr->ast;
+}
+
+struct sieve_script *sieve_validator_script
+(struct sieve_validator *valdtr)
+{
+	return valdtr->script;
+}
+
+struct sieve_instance *sieve_validator_svinst
+(struct sieve_validator *valdtr)
+{
+	return valdtr->svinst;
+}
+
+/*
+ * Command registry
+ */
+
+/* Dummy command object to mark unknown commands in the registry */
+
+static bool _cmd_unknown_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	i_unreached();
+	return FALSE;
+}
+
+static const struct sieve_command_def unknown_command = {
+	"", SCT_NONE, 0, 0, FALSE, FALSE ,
+	NULL, NULL, _cmd_unknown_validate, NULL, NULL
+};
+
+/* Registration of the core commands of the language */
+
+static void sieve_validator_register_core_tests
+(struct sieve_validator *valdtr)
+{
+	unsigned int i;
+
+	for ( i = 0; i < sieve_core_tests_count; i++ ) {
+		sieve_validator_register_command(valdtr, NULL, sieve_core_tests[i]);
+	}
+}
+
+static void sieve_validator_register_core_commands
+(struct sieve_validator *valdtr)
+{
+	unsigned int i;
+
+	for ( i = 0; i < sieve_core_commands_count; i++ ) {
+		sieve_validator_register_command(valdtr, NULL, sieve_core_commands[i]);
+	}
+}
+
+/* Registry functions */
+
+static struct sieve_command_registration *
+sieve_validator_find_command_registration
+(struct sieve_validator *valdtr, const char *command)
+{
+	return (struct sieve_command_registration *)
+		hash_table_lookup(valdtr->commands, command);
+}
+
+static struct sieve_command_registration *_sieve_validator_register_command
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct sieve_command_def *cmd_def, const char *identifier)
+{
+	struct sieve_command_registration *cmd_reg =
+		p_new(valdtr->pool, struct sieve_command_registration, 1);
+
+	cmd_reg->cmd_def = cmd_def;
+	cmd_reg->ext = ext;
+
+	hash_table_insert(valdtr->commands, (void *) identifier, (void *) cmd_reg);
+
+	return cmd_reg;
+}
+
+void sieve_validator_register_command
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct sieve_command_def *cmd_def)
+{
+	struct sieve_command_registration *cmd_reg =
+		sieve_validator_find_command_registration(valdtr, cmd_def->identifier);
+
+	if ( cmd_reg == NULL )
+		cmd_reg = _sieve_validator_register_command
+			(valdtr, ext, cmd_def, cmd_def->identifier);
+	else {
+		cmd_reg->cmd_def = cmd_def;
+		cmd_reg->ext = ext;
+	}
+
+	if ( cmd_def->registered != NULL )
+		cmd_def->registered(valdtr, ext, cmd_reg);
+}
+
+static void sieve_validator_register_unknown_command
+(struct sieve_validator *valdtr, const char *command)
+{
+	(void)_sieve_validator_register_command
+		(valdtr, NULL, &unknown_command, command);
+}
+
+/*const struct sieve_command *sieve_validator_find_command
+(struct sieve_validator *valdtr, const char *command)
+{
+  struct sieve_command_registration *cmd_reg =
+  	sieve_validator_find_command_registration(valdtr, command);
+
+  return ( record == NULL ? NULL : record->command );
+}*/
+
+/*
+ * Per-command tagged argument registry
+ */
+
+/* Dummy argument object to mark unknown arguments in the registry */
+
+static bool _unknown_tag_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_ast_argument **arg ATTR_UNUSED,
+	struct sieve_command *tst ATTR_UNUSED)
+{
+	i_unreached();
+	return FALSE;
+}
+
+static const struct sieve_argument_def _unknown_tag = {
+	"",
+	NULL,
+	_unknown_tag_validate,
+	NULL, NULL, NULL
+};
+
+static inline bool _tag_registration_is_unknown
+(struct sieve_tag_registration *tag_reg)
+{
+	return ( tag_reg != NULL && tag_reg->tag_def == &_unknown_tag );
+}
+
+/* Registry functions */
+
+static void _sieve_validator_register_tag
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	const struct sieve_extension *ext, const struct sieve_argument_def *tag_def,
+	const char *identifier, int id_code)
+{
+	struct sieve_tag_registration *reg;
+
+	reg = p_new(valdtr->pool, struct sieve_tag_registration, 1);
+	reg->ext = ext;
+	reg->tag_def = tag_def;
+	reg->id_code = id_code;
+	if ( identifier == NULL )
+		reg->identifier = tag_def->identifier;
+	else
+		reg->identifier = p_strdup(valdtr->pool, identifier);
+
+	if ( !array_is_created(&cmd_reg->normal_tags) )
+		p_array_init(&cmd_reg->normal_tags, valdtr->pool, 4);
+
+	array_append(&cmd_reg->normal_tags, &reg, 1);
+}
+
+void sieve_validator_register_persistent_tag
+(struct sieve_validator *valdtr, const char *command,
+	const struct sieve_extension *ext, const struct sieve_argument_def *tag_def)
+{
+	/* Add the tag to the persistent tags list if necessary */
+	if ( tag_def->validate_persistent != NULL ) {
+		struct sieve_command_registration *cmd_reg =
+			sieve_validator_find_command_registration(valdtr, command);
+
+		if ( cmd_reg == NULL ) {
+			cmd_reg = _sieve_validator_register_command(valdtr, NULL, NULL, command);
+		}
+
+		struct sieve_tag_registration *reg;
+
+		reg = p_new(valdtr->pool, struct sieve_tag_registration, 1);
+		reg->ext = ext;
+		reg->tag_def = tag_def;
+		reg->id_code = -1;
+
+		if ( !array_is_created(&cmd_reg->persistent_tags) )
+			p_array_init(&cmd_reg->persistent_tags, valdtr->pool, 4);
+
+		array_append(&cmd_reg->persistent_tags, &reg, 1);
+	}
+}
+
+void sieve_validator_register_external_tag
+(struct sieve_validator *valdtr, const char *command,
+	const struct sieve_extension *ext, const struct sieve_argument_def *tag_def,
+	int id_code)
+{
+	struct sieve_command_registration *cmd_reg =
+		sieve_validator_find_command_registration(valdtr, command);
+
+	if ( cmd_reg == NULL ) {
+		cmd_reg = _sieve_validator_register_command(valdtr, NULL, NULL, command);
+	}
+
+	_sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, tag_def, NULL, id_code);
+}
+
+void sieve_validator_register_tag
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	const struct sieve_extension *ext, const struct sieve_argument_def *tag_def,
+	int id_code)
+{
+	if ( tag_def->is_instance_of == NULL )
+		_sieve_validator_register_tag(valdtr, cmd_reg, ext, tag_def, NULL, id_code);
+	else {
+		struct sieve_tag_registration *reg =
+			p_new(valdtr->pool, struct sieve_tag_registration, 1);
+		reg->ext = ext;
+		reg->tag_def = tag_def;
+		reg->id_code = id_code;
+
+		if ( !array_is_created(&cmd_reg->instanced_tags) )
+				p_array_init(&cmd_reg->instanced_tags, valdtr->pool, 4);
+
+		array_append(&cmd_reg->instanced_tags, &reg, 1);
+	}
+}
+
+static void sieve_validator_register_unknown_tag
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+	const char *tag)
+{
+	_sieve_validator_register_tag(valdtr, cmd_reg, NULL, &_unknown_tag, tag, 0);
+}
+
+static struct sieve_tag_registration *_sieve_validator_command_tag_get
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const char *tag, void **data)
+{
+	struct sieve_command_registration *cmd_reg = cmd->reg;
+	struct sieve_tag_registration * const *regs;
+	unsigned int i, reg_count;
+
+	/* First check normal tags */
+	if ( array_is_created(&cmd_reg->normal_tags) ) {
+		regs = array_get(&cmd_reg->normal_tags, &reg_count);
+
+		for ( i = 0; i < reg_count; i++ ) {
+			if ( regs[i]->tag_def != NULL &&
+				strcasecmp(regs[i]->identifier, tag) == 0) {
+
+				return regs[i];
+			}
+		}
+	}
+
+	/* Not found so far, try the instanced tags */
+	if ( array_is_created(&cmd_reg->instanced_tags) ) {
+		regs = array_get(&cmd_reg->instanced_tags, &reg_count);
+
+		for ( i = 0; i < reg_count; i++ ) {
+			if ( regs[i]->tag_def != NULL ) {
+				if ( regs[i]->tag_def->is_instance_of
+					(valdtr, cmd, regs[i]->ext, tag, data) )
+					return regs[i];
+			}
+		}
+	}
+
+	return NULL;
+}
+
+static bool sieve_validator_command_tag_exists
+(struct sieve_validator *valdtr, struct sieve_command *cmd, const char *tag)
+{
+	return ( _sieve_validator_command_tag_get(valdtr, cmd, tag, NULL) != NULL );
+}
+
+static struct sieve_tag_registration *sieve_validator_command_tag_get
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *arg, void **data)
+{
+	const char *tag = sieve_ast_argument_tag(arg);
+
+	return _sieve_validator_command_tag_get(valdtr, cmd, tag, data);
+}
+
+/*
+ * Extension support
+ */
+
+const struct sieve_extension *sieve_validator_extension_load
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *ext_arg, string_t *ext_name)
+{
+	struct sieve_validator_extension_reg *reg;
+	const struct sieve_extension *ext;
+	const struct sieve_extension_def *extdef;
+	const char *name = str_c(ext_name);
+
+	if ( str_len(ext_name) > 128 ) {
+		sieve_argument_validate_error(valdtr, ext_arg,
+			"%s %s: unknown Sieve capability '%s' (name is impossibly long)",
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			str_sanitize(name, 128));
+		return NULL;
+	}
+
+	ext = sieve_extension_get_by_name(valdtr->svinst, name);
+
+	if ( ext == NULL || ext->def == NULL ) {
+		unsigned int i;
+		bool core_test = FALSE;
+		bool core_command = FALSE;
+
+		for ( i = 0; !core_command && i < sieve_core_commands_count; i++ ) {
+			if ( strcasecmp(sieve_core_commands[i]->identifier, name) == 0 )
+				core_command = TRUE;
+		}
+
+		for ( i = 0; !core_test && i < sieve_core_tests_count; i++ ) {
+			if ( strcasecmp(sieve_core_tests[i]->identifier, name) == 0 )
+				core_test = TRUE;
+		}
+
+		if ( core_test || core_command ) {
+			sieve_argument_validate_error(valdtr, ext_arg,
+				"%s %s: '%s' is not known as a Sieve capability, "
+				"but it is known as a Sieve %s that is always available",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+				name, ( core_test ? "test" : "command" ));
+		} else {
+			sieve_argument_validate_error(valdtr, ext_arg,
+				"%s %s: unknown Sieve capability '%s'",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+				name);
+		}
+		return NULL;
+	}
+
+	sieve_ast_extension_link(valdtr->ast, ext);
+
+	extdef = ext->def;
+
+	if ( extdef->validator_load != NULL &&
+		!extdef->validator_load(ext, valdtr) ) {
+		sieve_argument_validate_error(valdtr, ext_arg,
+			"%s %s: failed to load Sieve capability '%s'",
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			sieve_extension_name(ext));
+		return NULL;
+	}
+
+	/* Register extension no matter what and store the AST argument registering it
+	 */
+	if ( ext->id >= 0 ) {
+		reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext->id);
+		reg->arg = ext_arg;
+		reg->loaded = TRUE;
+	}
+
+	return ext;
+}
+
+void sieve_validator_extension_register
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct sieve_validator_extension *valext, void *context)
+{
+	struct sieve_validator_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext->id);
+	reg->valext = valext;
+	reg->ext = ext;
+	reg->context = context;
+}
+
+bool sieve_validator_extension_loaded
+(struct sieve_validator *valdtr, const struct sieve_extension *ext)
+{
+	const struct sieve_validator_extension_reg *reg;
+
+	if ( ext->id < 0 || ext->id >= (int) array_count(&valdtr->extensions))
+		return FALSE;
+
+	reg = array_idx(&valdtr->extensions, (unsigned int) ext->id);
+
+	return ( reg->loaded );
+}
+
+void sieve_validator_extension_set_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	void *context)
+{
+	struct sieve_validator_extension_reg *reg;
+
+	if ( ext->id < 0 ) return;
+
+	reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext->id);
+	reg->context = context;
+}
+
+void *sieve_validator_extension_get_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext)
+{
+	const struct sieve_validator_extension_reg *reg;
+
+	if  ( ext->id < 0 || ext->id >= (int) array_count(&valdtr->extensions) )
+		return NULL;
+
+	reg = array_idx(&valdtr->extensions, (unsigned int) ext->id);
+
+	return reg->context;
+}
+
+/*
+ * Overriding the default literal arguments
+ */
+
+void sieve_validator_argument_override
+(struct sieve_validator *valdtr, enum sieve_argument_type type,
+	const struct sieve_extension *ext, const struct sieve_argument_def *arg_def)
+{
+	struct sieve_default_argument *arg;
+
+	if ( valdtr->default_arguments[type].arg_def != NULL ) {
+		arg = p_new(valdtr->pool, struct sieve_default_argument, 1);
+		*arg = valdtr->default_arguments[type];
+
+		valdtr->default_arguments[type].overrides = arg;
+	}
+
+	valdtr->default_arguments[type].arg_def = arg_def;
+	valdtr->default_arguments[type].ext = ext;
+}
+
+static bool sieve_validator_argument_default_activate
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_default_argument *defarg, struct sieve_ast_argument *arg)
+{
+	bool result = TRUE;
+	struct sieve_default_argument *prev_defarg;
+
+	prev_defarg = valdtr->current_defarg;
+	valdtr->current_defarg = defarg;
+
+	if ( arg->argument == NULL ) {
+		arg->argument = sieve_argument_create
+			(arg->ast, defarg->arg_def, defarg->ext, 0);
+	} else {
+		arg->argument->def = defarg->arg_def;
+		arg->argument->ext = defarg->ext;
+	}
+
+	if (defarg->arg_def != NULL && defarg->arg_def->validate != NULL )
+		result = defarg->arg_def->validate(valdtr, &arg, cmd);
+
+	valdtr->current_defarg = prev_defarg;
+
+	return result;
+}
+
+bool sieve_validator_argument_activate_super
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *arg, bool constant ATTR_UNUSED)
+{
+	struct sieve_default_argument *defarg;
+
+	if ( valdtr->current_defarg == NULL ||
+		valdtr->current_defarg->overrides == NULL )
+		return FALSE;
+
+	if ( valdtr->current_defarg->overrides->arg_def == &string_argument ) {
+		switch ( valdtr->current_defarg_type) {
+		case SAT_CONST_STRING:
+			if ( !valdtr->current_defarg_constant ) {
+				valdtr->current_defarg_type = SAT_VAR_STRING;
+				defarg = &valdtr->default_arguments[SAT_VAR_STRING];
+			} else
+				defarg = valdtr->current_defarg->overrides;
+			break;
+		case SAT_VAR_STRING:
+			defarg = valdtr->current_defarg->overrides;
+			break;
+		default:
+			return FALSE;
+		}
+	} else
+		defarg = valdtr->current_defarg->overrides;
+
+	return sieve_validator_argument_default_activate
+		(valdtr, cmd, defarg, arg);
+}
+
+/*
+ * Argument Validation API
+ */
+
+bool sieve_validator_argument_activate
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *arg, bool constant)
+{
+	struct sieve_default_argument *defarg;
+
+	switch ( sieve_ast_argument_type(arg) ) {
+	case SAAT_NUMBER:
+		valdtr->current_defarg_type = SAT_NUMBER;
+		break;
+	case SAAT_STRING:
+		valdtr->current_defarg_type = SAT_CONST_STRING;
+		break;
+	case SAAT_STRING_LIST:
+		valdtr->current_defarg_type = SAT_STRING_LIST;
+		break;
+	default:
+		return FALSE;
+	}
+
+	valdtr->current_defarg_constant = constant;
+	defarg = &valdtr->default_arguments[valdtr->current_defarg_type];
+
+	if ( !constant && defarg->arg_def == &string_argument ) {
+		valdtr->current_defarg_type = SAT_VAR_STRING;
+		defarg = &valdtr->default_arguments[SAT_VAR_STRING];
+	}
+
+	return sieve_validator_argument_default_activate(valdtr, cmd, defarg, arg);
+}
+
+bool sieve_validate_positional_argument
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *arg, const char *arg_name, unsigned int arg_pos,
+	enum sieve_ast_argument_type req_type)
+{
+	if ( sieve_ast_argument_type(arg) != req_type &&
+		(sieve_ast_argument_type(arg) != SAAT_STRING ||
+			req_type != SAAT_STRING_LIST) )
+	{
+		sieve_argument_validate_error(valdtr, arg,
+			"the %s %s expects %s as argument %d (%s), but %s was found",
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			sieve_ast_argument_type_name(req_type),
+			arg_pos, arg_name, sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_validate_tag_parameter
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *tag, struct sieve_ast_argument *param,
+	enum sieve_ast_argument_type req_type)
+{
+	if ( param == NULL ) {
+		sieve_argument_validate_error(valdtr, tag,
+			"the :%s tag for the %s %s requires %s as parameter, "
+			"but no more arguments were found", sieve_ast_argument_tag(tag),
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			sieve_ast_argument_type_name(req_type));
+		return FALSE;
+	}
+
+	if ( sieve_ast_argument_type(param) != req_type &&
+		(sieve_ast_argument_type(param) != SAAT_STRING ||
+			req_type != SAAT_STRING_LIST) )
+	{
+		sieve_argument_validate_error(valdtr, param,
+			"the :%s tag for the %s %s requires %s as parameter, "
+			"but %s was found", sieve_ast_argument_tag(tag),
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			sieve_ast_argument_type_name(req_type),	sieve_ast_argument_name(param));
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, param, FALSE) )
+		return FALSE;
+
+	param->argument->id_code = tag->argument->id_code;
+
+	return TRUE;
+}
+
+/*
+ * Command argument validation
+ */
+
+static bool sieve_validate_command_arguments
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	int arg_count = cmd->def->positional_arguments;
+	int real_count = 0;
+	struct sieve_ast_argument *arg;
+	struct sieve_command_registration *cmd_reg = cmd->reg;
+
+	/* Validate any tags that might be present */
+	arg = sieve_ast_argument_first(cmd->ast_node);
+
+	/* Visit tagged and optional arguments */
+	while ( sieve_ast_argument_type(arg) == SAAT_TAG ) {
+		struct sieve_ast_argument *parg;
+		void *arg_data = NULL;
+		struct sieve_tag_registration *tag_reg =
+			sieve_validator_command_tag_get(valdtr, cmd, arg, &arg_data);
+		const struct sieve_argument_def *tag_def;
+
+		if ( tag_reg == NULL ) {
+			sieve_argument_validate_error(valdtr, arg,
+				"unknown tagged argument ':%s' for the %s %s "
+				"(reported only once at first occurence)",
+				sieve_ast_argument_tag(arg), sieve_command_identifier(cmd),
+				sieve_command_type_name(cmd));
+			sieve_validator_register_unknown_tag
+				(valdtr, cmd_reg, sieve_ast_argument_tag(arg));
+			return FALSE;
+		}
+
+		/* Check whether previously tagged as unknown */
+		if ( _tag_registration_is_unknown(tag_reg) )
+			return FALSE;
+
+		tag_def = tag_reg->tag_def;
+
+		/* Assign the tagged argument type to the ast for later reference */
+		arg->argument = sieve_argument_create
+			(arg->ast, tag_def, tag_reg->ext, tag_reg->id_code);
+		arg->argument->data = arg_data;
+
+		/* Scan backwards for any duplicates */
+		parg = sieve_ast_argument_prev(arg);
+		while ( parg != NULL ) {
+			if ( (sieve_ast_argument_type(parg) == SAAT_TAG &&
+					parg->argument->def == tag_reg->tag_def)
+				|| (tag_reg->id_code > 0 && parg->argument != NULL &&
+					parg->argument->id_code == tag_reg->id_code) )
+			{
+				const char *tag_id = sieve_ast_argument_tag(arg);
+				const char *tag_desc =
+					strcmp(tag_def->identifier, tag_id) != 0 ?
+					t_strdup_printf("%s argument (:%s)", tag_def->identifier, tag_id) :
+					t_strdup_printf(":%s argument", tag_def->identifier);
+
+				sieve_argument_validate_error(valdtr, arg,
+					"encountered duplicate %s for the %s %s",
+					tag_desc, sieve_command_identifier(cmd),
+					sieve_command_type_name(cmd));
+
+				return FALSE;
+			}
+
+			parg = sieve_ast_argument_prev(parg);
+		}
+
+		/* Call the validation function for the tag (if present)
+		 *   Fail if the validation fails:
+		 *     Let's not whine multiple	times about a single command having multiple
+		 *     bad arguments...
+		 */
+		if ( tag_def->validate != NULL ) {
+			if ( !tag_def->validate(valdtr, &arg, cmd) )
+				return FALSE;
+		} else {
+			arg = sieve_ast_argument_next(arg);
+		}
+	}
+
+	/* Remaining arguments should be positional (tags are not allowed here) */
+	cmd->first_positional = arg;
+
+	while ( arg != NULL ) {
+		if ( sieve_ast_argument_type(arg) == SAAT_TAG ) {
+			sieve_argument_validate_error(valdtr, arg,
+				"encountered an unexpected tagged argument ':%s' "
+				"while validating positional arguments for the %s %s",
+				sieve_ast_argument_tag(arg), sieve_command_identifier(cmd),
+				sieve_command_type_name(cmd));
+			return FALSE;
+		}
+
+		real_count++;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Check the required count versus the real number of arguments */
+	if ( arg_count >= 0 && real_count != arg_count ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"the %s %s requires %d positional argument(s), but %d is/are specified",
+			sieve_command_identifier(cmd), sieve_command_type_name(cmd),
+			arg_count, real_count);
+		return FALSE;
+	}
+
+	/* Call initial validation for persistent arguments */
+	if ( array_is_created(&cmd_reg->persistent_tags) ) {
+		struct sieve_tag_registration * const *regs;
+		unsigned int i, reg_count;
+
+  	regs = array_get(&cmd_reg->persistent_tags, &reg_count);
+		for ( i = 0; i < reg_count; i++ ) {
+
+			const struct sieve_argument_def *tag_def = regs[i]->tag_def;
+
+			if ( tag_def != NULL && tag_def->validate_persistent != NULL ) {
+				/* To be sure */
+				if ( !tag_def->validate_persistent(valdtr, cmd, regs[i]->ext) )
+	  				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_arguments_context
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg =
+		sieve_command_first_argument(cmd);
+
+	while ( arg != NULL ) {
+		const struct sieve_argument *argument = arg->argument;
+
+		if ( argument != NULL && argument->def != NULL &&
+			argument->def->validate_context != NULL ) {
+
+			if ( !argument->def->validate_context(valdtr, arg, cmd) )
+				return FALSE;
+		}
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Command Validation API
+ */
+
+static bool sieve_validate_command_subtests
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const unsigned int count)
+{
+	switch ( count ) {
+
+	case 0:
+	 	if ( sieve_ast_test_count(cmd->ast_node) > 0 ) {
+			/* Unexpected command specified */
+			enum sieve_command_type ctype = SCT_NONE;
+			struct sieve_command_registration *cmd_reg;
+			struct sieve_ast_node *test = sieve_ast_test_first(cmd->ast_node);
+
+			cmd_reg = sieve_validator_find_command_registration
+				(valdtr, test->identifier);
+
+			/* First check what we are dealing with */
+			if ( cmd_reg != NULL && cmd_reg->cmd_def != NULL )
+				ctype = cmd_reg->cmd_def->type;
+
+			switch ( ctype ) {
+			case SCT_TEST: /* Spurious test */
+			case SCT_HYBRID:
+				sieve_command_validate_error(valdtr, cmd,
+					"the %s %s accepts no sub-tests, but tests are specified",
+					sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+				break;
+
+			case SCT_NONE: /* Unknown command */
+
+				/* Is it perhaps a tag for which the ':' was omitted ? */
+				if ( sieve_validator_command_tag_exists
+					(valdtr, cmd, test->identifier) ) {
+					sieve_command_validate_error(valdtr, cmd,
+						"missing colon ':' before ':%s' tag in %s %s", test->identifier,
+						sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+					break;
+				}
+				/* Fall through */
+
+			case SCT_COMMAND:
+				sieve_command_validate_error(valdtr, cmd,
+					"missing semicolon ';' after %s %s",
+					sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+				break;
+			}
+			return FALSE;
+		}
+		break;
+	case 1:
+		if ( sieve_ast_test_count(cmd->ast_node) == 0 ) {
+			sieve_command_validate_error(valdtr, cmd,
+				"the %s %s requires one sub-test, but none is specified",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+
+			return FALSE;
+
+		} else if ( sieve_ast_test_count(cmd->ast_node) > 1 ||
+			cmd->ast_node->test_list ) {
+
+			sieve_command_validate_error(valdtr, cmd,
+				"the %s %s requires one sub-test, but a list of tests is specified",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+
+			return FALSE;
+		}
+		break;
+
+	default:
+		if ( sieve_ast_test_count(cmd->ast_node) == 0 ) {
+			sieve_command_validate_error(valdtr, cmd,
+				"the %s %s requires a list of sub-tests, but none is specified",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd));
+
+			return FALSE;
+
+		} else if ( sieve_ast_test_count(cmd->ast_node) == 1 &&
+			!cmd->ast_node->test_list ) {
+
+			sieve_command_validate_error(valdtr, cmd,
+				"the %s %s requires a list of sub-tests, "
+				"but a single test is specified",
+				sieve_command_identifier(cmd), sieve_command_type_name(cmd) );
+
+			return FALSE;
+		}
+		break;
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_command_block
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	bool block_allowed, bool block_required)
+{
+	i_assert( cmd->ast_node->type == SAT_COMMAND );
+
+	if ( block_required ) {
+		if ( !cmd->ast_node->block ) {
+			sieve_command_validate_error(valdtr, cmd,
+				"the %s command requires a command block, but it is missing",
+				sieve_command_identifier(cmd));
+
+			return FALSE;
+		}
+	} else if ( !block_allowed && cmd->ast_node->block ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"the %s command does not accept a command block, "
+			"but one is specified anyway",
+			sieve_command_identifier(cmd) );
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * AST Validation
+ */
+
+static bool sieve_validate_test_list
+	(struct sieve_validator *valdtr, struct sieve_ast_node *test_list);
+static bool sieve_validate_block
+	(struct sieve_validator *valdtr, struct sieve_ast_node *block);
+static bool sieve_validate_command
+	(struct sieve_validator *valdtr, struct sieve_ast_node *cmd_node);
+
+static bool sieve_validate_command_context
+(struct sieve_validator *valdtr, struct sieve_ast_node *cmd_node)
+{
+	enum sieve_ast_type ast_type = sieve_ast_node_type(cmd_node);
+	struct sieve_command_registration *cmd_reg;
+
+	i_assert( ast_type == SAT_TEST || ast_type == SAT_COMMAND );
+
+	/* Verify the command specified by this node */
+
+	cmd_reg = sieve_validator_find_command_registration
+		(valdtr, cmd_node->identifier);
+
+	if ( cmd_reg != NULL && cmd_reg->cmd_def != NULL ) {
+		const struct sieve_command_def *cmd_def = cmd_reg->cmd_def;
+
+		/* Identifier = "" when the command was previously marked as unknown */
+		if ( *(cmd_def->identifier) != '\0' ) {
+			struct sieve_command *cmd;
+
+			if ( (cmd_def->type == SCT_COMMAND && ast_type == SAT_TEST)
+				|| (cmd_def->type == SCT_TEST && ast_type == SAT_COMMAND) ) {
+				sieve_validator_error(
+					valdtr, cmd_node->source_line, "attempted to use %s '%s' as %s",
+					sieve_command_def_type_name(cmd_def), cmd_node->identifier,
+					sieve_ast_type_name(ast_type));
+
+			 	return FALSE;
+			}
+
+			cmd_node->command = cmd =
+				sieve_command_create(cmd_node, cmd_reg->ext, cmd_def, cmd_reg);
+		} else {
+			return FALSE;
+		}
+
+	}	else {
+		sieve_validator_error(
+			valdtr, cmd_node->source_line,
+			"unknown %s '%s' (only reported once at first occurence)",
+			sieve_ast_type_name(ast_type), cmd_node->identifier);
+
+		sieve_validator_register_unknown_command(valdtr, cmd_node->identifier);
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_command
+(struct sieve_validator *valdtr, struct sieve_ast_node *cmd_node)
+{
+	enum sieve_ast_type ast_type = sieve_ast_node_type(cmd_node);
+	struct sieve_command *cmd = cmd_node->command;
+	const struct sieve_command_def *cmd_def = ( cmd != NULL ? cmd->def : NULL );
+	bool result = TRUE;
+
+	i_assert( ast_type == SAT_TEST || ast_type == SAT_COMMAND );
+
+	if ( cmd_def != NULL && *(cmd_def->identifier) != '\0' ) {
+
+		if ( cmd_def->pre_validate == NULL
+			|| cmd_def->pre_validate(valdtr, cmd) ) {
+
+			/* Check argument syntax */
+			if ( !sieve_validate_command_arguments(valdtr, cmd) ) {
+				result = FALSE;
+
+				/* A missing ':' causes a tag to become a test. This can be the cause
+				 * of the arguments validation failing. Therefore we must produce an
+				 * error for the sub-tests as well if appropriate.
+				 */
+				(void)sieve_validate_command_subtests(valdtr, cmd, cmd_def->subtests);
+
+			} else if (
+				!sieve_validate_command_subtests(valdtr, cmd, cmd_def->subtests) ||
+				(ast_type == SAT_COMMAND && !sieve_validate_command_block
+					(valdtr, cmd, cmd_def->block_allowed, cmd_def->block_required)) ) {
+
+				result = FALSE;
+
+			} else {
+				/* Call command validation function if specified */
+				if ( cmd_def->validate != NULL )
+					result = cmd_def->validate(valdtr, cmd) && result;
+			}
+		} else {
+			/* If pre-validation fails, don't bother to validate further
+			 * as context might be missing and doing so is not very useful for
+			 * further error reporting anyway
+			 */
+			return FALSE;
+		}
+
+		result = result && sieve_validate_arguments_context(valdtr, cmd);
+
+	}
+
+	/*
+	 * Descend further into the AST
+	 */
+
+	if ( cmd_def != NULL ) {
+		/* Tests */
+		if ( cmd_def->subtests > 0 &&
+			(result || sieve_errors_more_allowed(valdtr->ehandler)) )
+			result = sieve_validate_test_list(valdtr, cmd_node) && result;
+
+		/* Command block */
+		if ( cmd_def->block_allowed && ast_type == SAT_COMMAND &&
+			(result || sieve_errors_more_allowed(valdtr->ehandler)) )
+			result = sieve_validate_block(valdtr, cmd_node) && result;
+	}
+
+	return result;
+}
+
+static bool sieve_validate_test_list
+(struct sieve_validator *valdtr, struct sieve_ast_node *test_list)
+{
+	bool result = TRUE;
+	struct sieve_ast_node *test;
+
+	test = sieve_ast_test_first(test_list);
+	while ( test != NULL
+		&& (result || sieve_errors_more_allowed(valdtr->ehandler)) ) {
+
+		result =
+			sieve_validate_command_context(valdtr, test) &&
+			sieve_validate_command(valdtr, test) &&
+			result;
+
+		test = sieve_ast_test_next(test);
+	}
+
+	return result;
+}
+
+static bool sieve_validate_block
+(struct sieve_validator *valdtr, struct sieve_ast_node *block)
+{
+	bool result = TRUE, fatal = FALSE;
+	struct sieve_ast_node *cmd_node, *next;
+
+	T_BEGIN {
+		cmd_node = sieve_ast_command_first(block);
+		while ( !fatal && cmd_node != NULL
+			&& (result || sieve_errors_more_allowed(valdtr->ehandler)) ) {
+			bool command_success;
+
+			next = sieve_ast_command_next(cmd_node);
+			command_success = sieve_validate_command_context(valdtr, cmd_node);
+			result = command_success && result;
+
+	 		/* Check if this is the first non-require command */
+			if ( command_success && sieve_ast_node_type(block) == SAT_ROOT
+				&& !valdtr->finished_require && cmd_node->command != NULL
+				&& !sieve_command_is(cmd_node->command, cmd_require) ) {
+				const struct sieve_validator_extension_reg *extrs;
+				unsigned int ext_count, i;
+
+				valdtr->finished_require = TRUE;
+
+				/* Validate all 'require'd extensions */
+				extrs = array_get(&valdtr->extensions, &ext_count);
+				for ( i = 0; i < ext_count; i++ ) {
+					if ( extrs[i].valext != NULL
+						&& extrs[i].valext->validate != NULL ) {
+
+						if ( !extrs[i].valext->validate
+							(extrs[i].ext, valdtr, extrs[i].context, extrs[i].arg) )
+						fatal = TRUE;
+						break;
+					}
+				}
+			}
+
+			result = !fatal && sieve_validate_command(valdtr, cmd_node) && result;
+
+			cmd_node = next;
+		}
+	} T_END;
+
+	return result && !fatal;
+}
+
+bool sieve_validator_run(struct sieve_validator *valdtr)
+{
+	return sieve_validate_block(valdtr, sieve_ast_root(valdtr->ast));
+}
+
+/*
+ * Validator object registry
+ */
+
+struct sieve_validator_object_reg {
+	const struct sieve_object_def *obj_def;
+	const struct sieve_extension *ext;
+};
+
+struct sieve_validator_object_registry {
+	struct sieve_validator *valdtr;
+	ARRAY_DEFINE(registrations, struct sieve_validator_object_reg);
+};
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_get
+(struct sieve_validator *valdtr, const struct sieve_extension *ext)
+{
+	return (struct sieve_validator_object_registry *)
+		sieve_validator_extension_get_context(valdtr, ext);
+}
+
+void sieve_validator_object_registry_add
+(struct sieve_validator_object_registry *regs,
+	const struct sieve_extension *ext, const struct sieve_object_def *obj_def)
+{
+	struct sieve_validator_object_reg *reg;
+
+	reg = array_append_space(&regs->registrations);
+	reg->ext = ext;
+	reg->obj_def = obj_def;
+}
+
+bool sieve_validator_object_registry_find
+(struct sieve_validator_object_registry *regs, const char *identifier,
+	struct sieve_object *obj)
+{
+	unsigned int i;
+
+	for ( i = 0; i < array_count(&regs->registrations); i++ ) {
+		const struct sieve_validator_object_reg *reg =
+			array_idx(&regs->registrations, i);
+
+		if ( strcasecmp(reg->obj_def->identifier, identifier) == 0) {
+			if ( obj != NULL ) {
+				obj->def = reg->obj_def;
+				obj->ext = reg->ext;
+			}
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_create
+(struct sieve_validator *valdtr)
+{
+	pool_t pool = valdtr->pool;
+	struct sieve_validator_object_registry *regs =
+		p_new(pool, struct sieve_validator_object_registry, 1);
+
+	/* Setup registry */
+	p_array_init(&regs->registrations, valdtr->pool, 4);
+
+	regs->valdtr = valdtr;
+
+	return regs;
+}
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_init
+(struct sieve_validator *valdtr, const struct sieve_extension *ext)
+{
+	struct sieve_validator_object_registry *regs =
+		sieve_validator_object_registry_create(valdtr);
+
+	sieve_validator_extension_set_context(valdtr, ext, regs);
+	return regs;
+}
+
+
Index: b/sieve/src/lib-sieve/sieve-validator.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve-validator.h
@@ -0,0 +1,170 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_VALIDATOR_H
+#define __SIEVE_VALIDATOR_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+/*
+ * Types
+ */
+
+enum sieve_argument_type {
+	SAT_NUMBER,
+	SAT_CONST_STRING,
+	SAT_VAR_STRING,
+	SAT_STRING_LIST,
+
+	SAT_COUNT
+};
+
+struct sieve_command_registration;
+
+/*
+ * Validator
+ */
+
+struct sieve_validator;
+
+struct sieve_validator *sieve_validator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+void sieve_validator_free(struct sieve_validator **valdtr);
+pool_t sieve_validator_pool(struct sieve_validator *valdtr);
+
+bool sieve_validator_run(struct sieve_validator *valdtr);
+
+/*
+ * Accessors
+ */
+
+struct sieve_error_handler *sieve_validator_error_handler
+	(struct sieve_validator *valdtr);
+struct sieve_ast *sieve_validator_ast
+	(struct sieve_validator *valdtr);
+struct sieve_script *sieve_validator_script
+	(struct sieve_validator *valdtr);
+struct sieve_instance *sieve_validator_svinst
+	(struct sieve_validator *valdtr);
+
+/*
+ * Error handling
+ */
+
+void sieve_validator_warning
+	(struct sieve_validator *valdtr, unsigned int source_line,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_validator_error
+	(struct sieve_validator *valdtr, unsigned int source_line,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_validator_critical
+	(struct sieve_validator *valdtr, unsigned int source_line,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/*
+ * Command/Test registry
+ */
+
+void sieve_validator_register_command
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		const struct sieve_command_def *command);
+
+/*
+ * Per-command tagged argument registry
+ */
+
+void sieve_validator_register_tag
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg,
+		const struct sieve_extension *ext, const struct sieve_argument_def *tag_def,
+		int id_code);
+void sieve_validator_register_external_tag
+	(struct sieve_validator *valdtr, const char *command,
+		const struct sieve_extension *ext, const struct sieve_argument_def *tag_def,
+		int id_code);
+void sieve_validator_register_persistent_tag
+	(struct sieve_validator *valdtr, const char *command,
+		const struct sieve_extension *ext,
+		const struct sieve_argument_def *tag_def);
+
+/*
+ * Overriding the default literal arguments
+ */
+
+void sieve_validator_argument_override
+(struct sieve_validator *valdtr, enum sieve_argument_type type,
+	const struct sieve_extension *ext, const struct sieve_argument_def *arg_def);
+bool sieve_validator_argument_activate_super
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	struct sieve_ast_argument *arg, bool constant);
+
+/*
+ * Argument validation API
+ */
+
+bool sieve_validate_positional_argument
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		struct sieve_ast_argument *arg, const char *arg_name, unsigned int arg_pos,
+		enum sieve_ast_argument_type req_type);
+bool sieve_validator_argument_activate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		struct sieve_ast_argument *arg, bool constant);
+
+bool sieve_validate_tag_parameter
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		struct sieve_ast_argument *tag, struct sieve_ast_argument *param,
+		enum sieve_ast_argument_type req_type);
+
+/*
+ * Extension support
+ */
+
+struct sieve_validator_extension {
+	const struct sieve_extension_def *ext;
+
+	bool (*validate)
+		(const struct sieve_extension *ext, struct sieve_validator *valdtr,
+			void *context, struct sieve_ast_argument *require_arg);
+
+	void (*free)
+		(const struct sieve_extension *ext, struct sieve_validator *valdtr,
+			void *context);
+};
+
+const struct sieve_extension *sieve_validator_extension_load
+	(struct sieve_validator *valdtr, struct sieve_command *cmd,
+		struct sieve_ast_argument *ext_arg, string_t *ext_name);
+
+void sieve_validator_extension_register
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		const struct sieve_validator_extension *valext, void *context);
+bool sieve_validator_extension_loaded
+    (struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+void sieve_validator_extension_set_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	void *context);
+void *sieve_validator_extension_get_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+/*
+ * Validator object registry
+ */
+
+struct sieve_validator_object_registry;
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_get
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext);
+void sieve_validator_object_registry_add
+	(struct sieve_validator_object_registry *regs,
+		const struct sieve_extension *ext, const struct sieve_object_def *obj_def);
+bool sieve_validator_object_registry_find
+	(struct sieve_validator_object_registry *regs, const char *identifier,
+		struct sieve_object *obj);
+struct sieve_validator_object_registry *sieve_validator_object_registry_create
+	(struct sieve_validator *valdtr);
+struct sieve_validator_object_registry *sieve_validator_object_registry_init
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+#endif /* __SIEVE_VALIDATOR_H */
Index: b/sieve/src/lib-sieve/sieve.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve.c
@@ -0,0 +1,655 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "istream.h"
+#include "buffer.h"
+
+#include "sieve-limits.h"
+#include "sieve-settings.h"
+#include "sieve-extensions.h"
+
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-actions.h"
+#include "sieve-result.h"
+
+#include "sieve-parser.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-binary-dumper.h"
+
+#include "sieve.h"
+#include "sieve-common.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <dirent.h>
+
+/*
+ * Main Sieve library interface
+ */
+
+struct sieve_instance *sieve_init
+(const struct sieve_callbacks *callbacks, void *context)
+{
+	struct sieve_instance *svinst;
+	unsigned long long int uint_setting;
+	pool_t pool;
+
+	/* Create Sieve engine instance */
+	pool = pool_alloconly_create("sieve", 8192);
+	svinst = p_new(pool, struct sieve_instance, 1);
+	svinst->pool = pool;
+	svinst->callbacks = callbacks;
+	svinst->context = context;
+
+	/* Read limits from configuration */
+
+	svinst->max_actions = SIEVE_DEFAULT_MAX_ACTIONS;
+	svinst->max_redirects = SIEVE_DEFAULT_MAX_REDIRECTS;
+
+	if ( sieve_get_uint_setting
+		(svinst, "sieve_max_actions", &uint_setting) ) {
+		svinst->max_actions = (unsigned int) uint_setting;
+	}
+
+	if ( sieve_get_uint_setting
+		(svinst, "sieve_max_redirects", &uint_setting) ) {
+		svinst->max_redirects = (unsigned int) uint_setting;
+	}
+
+	/* Initialize extensions */
+	if ( !sieve_extensions_init(svinst) ) {
+		sieve_deinit(&svinst);
+		return NULL;
+	}
+
+	return svinst;
+}
+
+void sieve_deinit(struct sieve_instance **svinst)
+{
+	sieve_extensions_deinit(*svinst);
+
+	pool_unref(&(*svinst)->pool);
+
+	*svinst = NULL;
+}
+
+void sieve_set_extensions
+(struct sieve_instance *svinst, const char *extensions)
+{
+	sieve_extensions_set_string(svinst, extensions);
+}
+
+const char *sieve_get_capabilities
+(struct sieve_instance *svinst, const char *name)
+{
+	if ( name == NULL || *name == '\0' )
+		return sieve_extensions_get_string(svinst);
+
+	return sieve_extension_capabilities_get_string(svinst, name);
+}
+
+/*
+ * Low-level compiler functions
+ */
+
+struct sieve_ast *sieve_parse
+(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_parser *parser;
+	struct sieve_ast *ast = NULL;
+
+	/* Parse */
+	if ( (parser = sieve_parser_create(script, ehandler)) == NULL )
+		return NULL;
+
+ 	if ( !sieve_parser_run(parser, &ast) || sieve_get_errors(ehandler) > 0 ) {
+ 		ast = NULL;
+ 	} else
+		sieve_ast_ref(ast);
+
+	sieve_parser_free(&parser);
+
+	return ast;
+}
+
+bool sieve_validate
+(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	bool result = TRUE;
+	struct sieve_validator *validator = sieve_validator_create(ast, ehandler);
+
+	if ( !sieve_validator_run(validator) || sieve_get_errors(ehandler) > 0 )
+		result = FALSE;
+
+	sieve_validator_free(&validator);
+
+	return result;
+}
+
+static struct sieve_binary *sieve_generate
+(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	struct sieve_generator *generator = sieve_generator_create(ast, ehandler);
+	struct sieve_binary *sbin = NULL;
+
+	(void) sieve_generator_run(generator, &sbin);
+
+	sieve_generator_free(&generator);
+
+	return sbin;
+}
+
+/*
+ * Sieve compilation
+ */
+
+struct sieve_binary *sieve_compile_script
+(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin;
+
+	/* Parse */
+	if ( (ast = sieve_parse(script, ehandler)) == NULL ) {
+ 		sieve_error(ehandler, sieve_script_name(script), "parse failed");
+		return NULL;
+	}
+
+	/* Validate */
+	if ( !sieve_validate(ast, ehandler) ) {
+		sieve_error(ehandler, sieve_script_name(script), "validation failed");
+
+ 		sieve_ast_unref(&ast);
+ 		return NULL;
+ 	}
+
+	/* Generate */
+	if ( (sbin=sieve_generate(ast, ehandler)) == NULL ) {
+		sieve_error(ehandler, sieve_script_name(script), "code generation failed");
+
+		sieve_ast_unref(&ast);
+		return NULL;
+	}
+
+	/* Cleanup */
+	sieve_ast_unref(&ast);
+
+	return sbin;
+}
+
+struct sieve_binary *sieve_compile
+(struct sieve_instance *svinst, const char *script_path,
+	const char *script_name, struct sieve_error_handler *ehandler)
+{
+	struct sieve_script *script;
+	struct sieve_binary *sbin;
+
+	if ( (script = sieve_script_create
+		(svinst, script_path, script_name, ehandler, NULL)) == NULL )
+		return NULL;
+
+	sbin = sieve_compile_script(script, ehandler);
+
+	sieve_script_unref(&script);
+
+	return sbin;
+}
+
+/*
+ * Sieve runtime
+ */
+
+static int sieve_run
+(struct sieve_binary *sbin, struct sieve_result **result,
+	const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+	struct sieve_error_handler *ehandler)
+{
+	struct sieve_interpreter *interp;
+	int ret = 0;
+
+	/* Create the interpreter */
+	if ( (interp=sieve_interpreter_create(sbin, ehandler)) == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+
+	/* Reset execution status */
+	if ( senv->exec_status != NULL )
+		memset(senv->exec_status, 0, sizeof(*senv->exec_status));
+
+	/* Create result object */
+	if ( *result == NULL )
+		*result = sieve_result_create
+			(sieve_binary_svinst(sbin), msgdata, senv, ehandler);
+	else {
+		sieve_result_set_error_handler(*result, ehandler);
+	}
+
+	/* Run the interpreter */
+	ret = sieve_interpreter_run(interp, msgdata, senv, *result);
+
+	/* Free the interpreter */
+	sieve_interpreter_free(&interp);
+
+	return ret;
+}
+
+/*
+ * Reading/writing sieve binaries
+ */
+
+struct sieve_binary *sieve_open
+(struct sieve_instance *svinst, const char *script_path,
+	const char *script_name, struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	struct sieve_script *script;
+	struct sieve_binary *sbin;
+	const char *binpath;
+
+	/* First open the scriptfile itself */
+	script = sieve_script_create
+		(svinst, script_path, script_name, ehandler, exists_r);
+
+	if ( script == NULL ) {
+		/* Failed */
+		return NULL;
+	}
+
+	T_BEGIN {
+		/* Then try to open the matching binary */
+		binpath = sieve_script_binpath(script);
+		sbin = sieve_binary_open(svinst, binpath, script);
+
+		if (sbin != NULL) {
+			/* Ok, it exists; now let's see if it is up to date */
+			if ( !sieve_binary_up_to_date(sbin) ) {
+				/* Not up to date */
+				sieve_binary_unref(&sbin);
+				sbin = NULL;
+			} else if ( !sieve_binary_load(sbin) ) {
+				/* Failed to load */
+				sieve_binary_unref(&sbin);
+				sbin = NULL;
+			}
+		}
+
+		/* If the binary does not exist, is not up-to-date or fails to load, we need
+		 * to (re-)compile.
+		 */
+		if ( sbin == NULL ) {
+			sbin = sieve_compile_script(script, ehandler);
+
+			/* Save the binary if compile was successful */
+			if ( sbin != NULL )
+				(void) sieve_binary_save(sbin, binpath);
+		}
+	} T_END;
+
+	/* Drop script reference, if sbin != NULL it holds a reference of its own.
+	 * Otherwise the script object is freed here.
+	 */
+	sieve_script_unref(&script);
+
+	return sbin;
+}
+
+bool sieve_save
+(struct sieve_binary *sbin, const char *bin_path)
+{
+	return sieve_binary_save(sbin, bin_path);
+}
+
+struct sieve_binary *sieve_load
+(struct sieve_instance *svinst, const char *bin_path)
+{
+	struct sieve_binary *sbin = sieve_binary_open(svinst, bin_path, NULL);
+
+    if ( sbin != NULL && !sieve_binary_load(sbin) ) {
+        sieve_binary_unref(&sbin);
+        sbin = NULL;
+    }
+
+	return sbin;
+}
+
+void sieve_close(struct sieve_binary **sbin)
+{
+	sieve_binary_unref(sbin);
+}
+
+/*
+ * Debugging
+ */
+
+void sieve_dump(struct sieve_binary *sbin, struct ostream *stream)
+{
+	struct sieve_binary_dumper *dumpr = sieve_binary_dumper_create(sbin);
+
+	sieve_binary_dumper_run(dumpr, stream);
+
+	sieve_binary_dumper_free(&dumpr);
+}
+
+int sieve_test
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct ostream *stream, bool *keep)
+{
+	struct sieve_result *result = NULL;
+	int ret;
+
+	if ( keep != NULL ) *keep = FALSE;
+
+	/* Run the script */
+	ret = sieve_run(sbin, &result, msgdata, senv, ehandler);
+
+	/* Print result if successful */
+	if ( ret > 0 ) {
+		ret = sieve_result_print(result, senv, stream, keep);
+	} else if ( ret == 0 ) {
+		if ( keep != NULL ) *keep = TRUE;
+	}
+
+	/* Cleanup */
+	sieve_result_unref(&result);
+
+	return ret;
+}
+
+/*
+ * Script execution
+ */
+
+int sieve_execute
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	bool *keep)
+{
+	struct sieve_result *result = NULL;
+	int ret;
+
+	if ( keep != NULL ) *keep = FALSE;
+
+	/* Run the script */
+	ret = sieve_run(sbin, &result, msgdata, senv, ehandler);
+
+	/* Evaluate status and execute the result:
+	 *   Strange situations, e.g. currupt binaries, must be handled by the caller.
+	 *   In that case no implicit keep is attempted, because the situation may be
+	 *   resolved.
+	 */
+	if ( ret > 0 ) {
+		/* Execute result */
+		ret = sieve_result_execute(result, keep);
+	} else if ( ret == 0 ) {
+		/* Perform implicit keep if script failed with a normal runtime error */
+		if ( !sieve_result_implicit_keep(result) ) {
+			ret = SIEVE_EXEC_KEEP_FAILED;
+		} else {
+			if ( keep != NULL ) *keep = TRUE;
+		}
+	}
+
+	/* Cleanup */
+	sieve_result_unref(&result);
+
+	return ret;
+}
+
+/*
+ * Multiscript support
+ */
+
+struct sieve_multiscript {
+	struct sieve_instance *svinst;
+	struct sieve_result *result;
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+
+	int status;
+	bool active;
+	bool ended;
+	bool keep;
+
+	struct ostream *teststream;
+};
+
+struct sieve_multiscript *sieve_multiscript_start_execute
+(struct sieve_instance *svinst,	const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv)
+{
+	pool_t pool;
+	struct sieve_result *result;
+	struct sieve_multiscript *mscript;
+
+	result = sieve_result_create(svinst, msgdata, senv, NULL);
+	pool = sieve_result_pool(result);
+
+	sieve_result_set_keep_action(result, NULL, NULL);
+
+	mscript = p_new(pool, struct sieve_multiscript, 1);
+	mscript->svinst = svinst;
+	mscript->result = result;
+	mscript->msgdata = msgdata;
+	mscript->scriptenv = senv;
+	mscript->status = SIEVE_EXEC_OK;
+	mscript->active = TRUE;
+	mscript->keep = TRUE;
+
+	return mscript;
+}
+
+struct sieve_multiscript *sieve_multiscript_start_test
+(struct sieve_instance *svinst, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct ostream *stream)
+{
+	struct sieve_multiscript *mscript =
+		sieve_multiscript_start_execute(svinst, msgdata, senv);
+
+	mscript->teststream = stream;
+
+	return mscript;
+}
+
+static void sieve_multiscript_test
+(struct sieve_multiscript *mscript, struct sieve_error_handler *ehandler,
+	bool *keep)
+{
+	sieve_result_set_error_handler(mscript->result, ehandler);
+
+	if ( mscript->status > 0 ) {
+		mscript->status = sieve_result_print
+			(mscript->result, mscript->scriptenv, mscript->teststream, keep);
+	} else {
+		if ( keep != NULL ) *keep = TRUE;
+	}
+
+	mscript->active = ( mscript->active && *keep );
+
+	sieve_result_mark_executed(mscript->result);
+}
+
+static void sieve_multiscript_execute
+(struct sieve_multiscript *mscript, struct sieve_error_handler *ehandler,
+	bool *keep)
+{
+	sieve_result_set_error_handler(mscript->result, ehandler);
+
+	if ( mscript->status > 0 ) {
+		mscript->status = sieve_result_execute(mscript->result, keep);
+	} else {
+		if ( !sieve_result_implicit_keep(mscript->result) )
+			mscript->status = SIEVE_EXEC_KEEP_FAILED;
+		else
+			if ( keep != NULL ) *keep = TRUE;
+	}
+
+	mscript->active = ( mscript->active && *keep );
+}
+
+bool sieve_multiscript_run
+(struct sieve_multiscript *mscript, struct sieve_binary *sbin,
+	struct sieve_error_handler *ehandler, bool final)
+{
+	if ( !mscript->active ) return FALSE;
+
+	if ( final )
+		sieve_result_set_keep_action(mscript->result, NULL, &act_store);
+
+	/* Run the script */
+	mscript->status = sieve_run(sbin, &mscript->result, mscript->msgdata,
+		mscript->scriptenv, ehandler);
+
+	if ( mscript->status >= 0 ) {
+		mscript->keep = FALSE;
+
+		if ( mscript->teststream != NULL )
+			sieve_multiscript_test(mscript, ehandler, &mscript->keep);
+		else
+			sieve_multiscript_execute(mscript, ehandler, &mscript->keep);
+
+		if ( final ) mscript->active = FALSE;
+	}
+
+	if ( mscript->status <= 0 )
+		return FALSE;
+
+	return mscript->active;
+}
+
+int sieve_multiscript_status(struct sieve_multiscript *mscript)
+{
+	return mscript->status;
+}
+
+int sieve_multiscript_finish(struct sieve_multiscript **mscript,
+	struct sieve_error_handler *ehandler, bool *keep)
+{
+	struct sieve_result *result = (*mscript)->result;
+	int ret = (*mscript)->status;
+
+	if ( ehandler != NULL )
+		sieve_result_set_error_handler((*mscript)->result, ehandler);
+
+	if ( (*mscript)->active ) {
+		ret = SIEVE_EXEC_FAILURE;
+
+		if ( (*mscript)->teststream ) {
+			(*mscript)->keep = TRUE;
+		} else {
+			if ( !sieve_result_implicit_keep((*mscript)->result) )
+				ret = SIEVE_EXEC_KEEP_FAILED;
+			else
+				(*mscript)->keep = TRUE;
+		}
+	}
+
+	if ( keep != NULL ) *keep = (*mscript)->keep;
+
+	/* Cleanup */
+	sieve_result_unref(&result);
+	*mscript = NULL;
+
+	return ret;
+}
+
+/*
+ * Script directory
+ */
+
+struct sieve_directory {
+		DIR *dirp;
+
+		const char *path;
+};
+
+struct sieve_directory *sieve_directory_open(const char *path)
+{
+	struct sieve_directory *sdir = NULL;
+	DIR *dirp;
+	struct stat st;
+
+	/* Specified path can either be a regular file or a directory */
+	if ( stat(path, &st) != 0 )
+		return NULL;
+
+	if ( S_ISDIR(st.st_mode) ) {
+
+		/* Open the directory */
+		if ( (dirp = opendir(path)) == NULL ) {
+			sieve_sys_error("opendir(%s) failed: %m", path);
+			return NULL;
+		}
+
+		/* Create object */
+		sdir = t_new(struct sieve_directory, 1);
+		sdir->path = path;
+		sdir->dirp = dirp;
+	} else {
+		sdir = t_new(struct sieve_directory, 1);
+		sdir->path = path;
+		sdir->dirp = NULL;
+	}
+
+	return sdir;
+}
+
+const char *sieve_directory_get_scriptfile(struct sieve_directory *sdir)
+{
+	const char *script = NULL;
+	struct dirent *dp;
+
+	if ( sdir->dirp != NULL ) {
+		while ( script == NULL ) {
+			const char *file;
+			struct stat st;
+
+			errno = 0;
+			if ( (dp = readdir(sdir->dirp)) == NULL ) {
+				if ( errno != 0 ) {
+					sieve_sys_error("readdir(%s) failed: %m", sdir->path);
+					continue;
+				} else
+					return NULL;
+			}
+
+			if ( !sieve_script_file_has_extension(dp->d_name) )
+				continue;
+
+			if ( sdir->path[strlen(sdir->path)-1] == '/' )
+				file = t_strconcat(sdir->path, dp->d_name, NULL);
+			else
+				file = t_strconcat(sdir->path, "/", dp->d_name, NULL);
+
+			if ( stat(file, &st) != 0 || !S_ISREG(st.st_mode) )
+				continue;
+
+			script = file;
+		}
+	} else {
+		script = sdir->path;
+		sdir->path = NULL;
+	}
+
+	return script;
+}
+
+void sieve_directory_close(struct sieve_directory **sdir)
+{
+	/* Close the directory */
+	if ( (*sdir)->dirp != NULL && closedir((*sdir)->dirp) < 0 )
+		sieve_sys_error("closedir(%s) failed: %m", (*sdir)->path);
+
+	*sdir = NULL;
+}
+
+
Index: b/sieve/src/lib-sieve/sieve.h
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/sieve.h
@@ -0,0 +1,165 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_H
+#define __SIEVE_H
+
+#include <stdio.h>
+
+struct sieve_script;
+struct sieve_binary;
+
+#include "sieve-config.h"
+#include "sieve-types.h"
+#include "sieve-error.h"
+
+/*
+ * Main Sieve library interface
+ */
+
+/* sieve_init():
+ *   Initializes the sieve engine. Must be called before any sieve functionality
+ *   is used.
+ */
+struct sieve_instance *sieve_init
+	(const struct sieve_callbacks *callbacks, void *context);
+
+/* sieve_deinit():
+ *   Frees all memory allocated by the sieve engine.
+ */
+void sieve_deinit(struct sieve_instance **svinst);
+
+/* sieve_get_capabilities():
+ *
+ */
+const char *sieve_get_capabilities
+	(struct sieve_instance *svinst, const char *name);
+
+/* sieve_set_extensions():
+ *
+ */
+void sieve_set_extensions
+	(struct sieve_instance *svinst, const char *extensions);
+
+/*
+ * Script compilation
+ */
+
+/* sieve_compile_script:
+ */
+struct sieve_binary *sieve_compile_script
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+
+/* sieve_compile:
+ *
+ *   Compiles the script into a binary.
+ */
+struct sieve_binary *sieve_compile
+	(struct sieve_instance *svinst, const char *script_path,
+		const char *script_name, struct sieve_error_handler *ehandler);
+
+/*
+ * Reading/writing Sieve binaries
+ */
+
+/* sieve_open:
+ *
+ *   First tries to open the binary version of the specified script and
+ *   if it does not exist or if it contains errors, the script is
+ *   (re-)compiled. The binary is updated if the script is recompiled.
+ *   Note that errors in the bytecode are not caught here.
+ *
+ */
+struct sieve_binary *sieve_open
+	(struct sieve_instance *svinst, const char *script_path,
+		const char *script_name, struct sieve_error_handler *ehandler,
+		bool *exists_r);
+
+/* sieve_save:
+ *
+ *  Saves the binary as the file indicated by the path parameter. If
+ *  path is NULL, it chooses the default path relative to the original
+ *  script.
+ */
+bool sieve_save
+    (struct sieve_binary *sbin, const char *bin_path);
+
+/* sieve_load:
+ *
+ *  Loads the sieve binary indicated by the provided path.
+ */
+struct sieve_binary *sieve_load
+	(struct sieve_instance *svinst, const char *bin_path);
+
+/* sieve_close:
+ *
+ *   Closes a compiled/opened sieve binary.
+ */
+void sieve_close(struct sieve_binary **sbin);
+
+/*
+ * Debugging
+ */
+
+/* sieve_dump:
+ *
+ *   Dumps the byte code in human-readable form to the specified ostream.
+ */
+void sieve_dump(struct sieve_binary *sbin, struct ostream *stream);
+
+/* sieve_test:
+ *
+ *   Executes the bytecode, but only prints the result to the given stream.
+ */
+int sieve_test
+	(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+		struct ostream *stream, bool *keep);
+
+/*
+ * Script execution
+ */
+
+/* sieve_execute:
+ *
+ *   Executes the binary, including the result.
+ */
+int sieve_execute
+	(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+		bool *keep);
+
+/*
+ * Multiscript support
+ */
+
+struct sieve_multiscript;
+
+struct sieve_multiscript *sieve_multiscript_start_execute
+	(struct sieve_instance *svinst, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv);
+struct sieve_multiscript *sieve_multiscript_start_test
+	(struct sieve_instance *svinst, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct ostream *stream);
+
+bool sieve_multiscript_run
+	(struct sieve_multiscript *mscript, struct sieve_binary *sbin,
+		struct sieve_error_handler *ehandler, bool final);
+
+int sieve_multiscript_status(struct sieve_multiscript *mscript);
+
+int sieve_multiscript_finish
+	(struct sieve_multiscript **mscript, struct sieve_error_handler *ehandler,
+		bool *keep);
+
+/*
+ * Script directory
+ */
+
+struct sieve_directory;
+
+struct sieve_directory *sieve_directory_open(const char *path);
+const char *sieve_directory_get_scriptfile(struct sieve_directory *sdir);
+void sieve_directory_close(struct sieve_directory **sdir);
+
+#endif
Index: b/sieve/src/lib-sieve/tst-address.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-address.c
@@ -0,0 +1,300 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include <stdio.h>
+
+/*
+ * Address test
+ *
+ * Syntax:
+ *    address [ADDRESS-PART] [COMPARATOR] [MATCH-TYPE]
+ *       <header-list: string-list> <key-list: string-list>
+ */
+
+static bool tst_address_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_address_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_address_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def tst_address = {
+	"address",
+	SCT_TEST,
+	2, 0, FALSE, FALSE,
+	tst_address_registered,
+	NULL,
+	tst_address_validate,
+	tst_address_generate,
+	NULL
+};
+
+/*
+ * Address operation
+ */
+
+static bool tst_address_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_address_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def tst_address_operation = {
+	"ADDRESS",
+	NULL,
+	SIEVE_OPERATION_ADDRESS,
+	tst_address_operation_dump,
+	tst_address_operation_execute
+};
+
+/*
+ * Test registration
+ */
+
+static bool tst_address_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_AM_OPT_COMPARATOR );
+	sieve_address_parts_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_ADDRESS_PART);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+/* List of valid headers:
+ *   Implementations MUST restrict the address test to headers that
+ *   contain addresses, but MUST include at least From, To, Cc, Bcc,
+ *   Sender, Resent-From, and Resent-To, and it SHOULD include any other
+ *   header that utilizes an "address-list" structured header body.
+ *
+ * This list explicitly does not contain the envelope-to and return-path
+ * headers. The envelope test must be used to test against these addresses.
+ *
+ * FIXME: this restriction is somewhat odd. Sieve list advises to allow
+ *        any other header as long as its content matches the address-list
+ *        grammar.
+ */
+static const char * const _allowed_headers[] = {
+	/* Required */
+	"from", "to", "cc", "bcc", "sender", "resent-from", "resent-to",
+
+	/* Additional (RFC 822 / RFC 2822) */
+	"reply-to", "resent-reply-to", "resent-sender", "resent-cc", "resent-bcc",
+
+	/* Non-standard (RFC 2076, draft-palme-mailext-headers-08.txt) */
+	"for-approval", "for-handling", "for-comment", "apparently-to", "errors-to",
+	"delivered-to", "return-receipt-to", "x-admin", "read-receipt-to",
+	"x-confirm-reading-to", "return-receipt-requested",
+	"registered-mail-reply-requested-by", "mail-followup-to", "mail-reply-to",
+	"abuse-reports-to", "x-complaints-to", "x-report-abuse-to",
+
+	/* Undocumented */
+	"x-beenthere",
+
+	NULL
+};
+
+static int _header_is_allowed
+(void *context ATTR_UNUSED, struct sieve_ast_argument *arg)
+{
+	if ( sieve_argument_is_string_literal(arg) ) {
+		const char *header = sieve_ast_strlist_strc(arg);
+
+		const char * const *hdsp = _allowed_headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp( *hdsp, header ) == 0 )
+				return TRUE;
+
+			hdsp++;
+		}
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool tst_address_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_ast_argument *header;
+	struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mcht_default =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header list", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+        return FALSE;
+
+	/* Check if supplied header names are allowed
+	 *   FIXME: verify dynamic header names at runtime
+	 */
+	header = arg;
+	if ( !sieve_ast_stringlist_map(&header, NULL, _header_is_allowed) ) {
+		sieve_argument_validate_error(valdtr, header,
+			"specified header '%s' is not allowed for the address test",
+			str_sanitize(sieve_ast_strlist_strc(header), 64));
+		return FALSE;
+	}
+
+	/* Check key list */
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_address_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, NULL, &tst_address_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_address_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "ADDRESS");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_addrmatch_default_dump_optionals(denv, address) )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "header list") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_address_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mcht =
+		SIEVE_MATCH_TYPE_DEFAULT(is_match_type);
+	struct sieve_address_part addrp =
+		SIEVE_ADDRESS_PART_DEFAULT(all_address_part);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *hdr_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *hdr_item;
+	bool matched;
+	int ret;
+
+	/* Read optional operands */
+	if ( (ret=sieve_addrmatch_default_get_optionals
+		(renv, address, &addrp, &mcht, &cmp)) <= 0 )
+		return ret;
+
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "ADDRESS test");
+
+	/* Initialize match context */
+	mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+	/* Iterate through all requested headers to match */
+	hdr_item = NULL;
+	matched = FALSE;
+	while ( result && !matched &&
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item))
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+
+		if ( mail_get_headers_utf8
+			(renv->msgdata->mail, str_c(hdr_item), &headers) >= 0 ) {
+			int i;
+
+			for ( i = 0; !matched && headers[i] != NULL; i++ ) {
+				if ( (ret=sieve_address_match(&addrp, mctx, headers[i])) < 0 ) {
+					result = FALSE;
+					break;
+				}
+
+				matched = ret > 0;
+			}
+		}
+	}
+
+	/* Finish match */
+
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/tst-allof.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-allof.c
@@ -0,0 +1,84 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/*
+ * Allof test
+ *
+ * Syntax
+ *   allof <tests: test-list>
+ */
+
+static bool tst_allof_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command_def tst_allof = {
+	"allof",
+	SCT_TEST,
+	0, 2, FALSE, FALSE,
+	NULL, NULL, NULL, NULL,
+	tst_allof_generate
+};
+
+/*
+ * Code generation
+ */
+
+static bool tst_allof_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist false_jumps;
+
+	if ( sieve_ast_test_count(ctx->ast_node) > 1 ) {
+		if ( jump_true ) {
+			/* Prepare jumplist */
+			sieve_jumplist_init_temp(&false_jumps, sbin);
+		}
+
+		test = sieve_ast_test_first(ctx->ast_node);
+		while ( test != NULL ) {
+			bool result;
+
+			/* If this test list must jump on false, all sub-tests can simply add their jumps
+			 * to the caller's jump list, otherwise this test redirects all false jumps to the
+			 * end of the currently generated code. This is just after a final jump to the true
+			 * case
+			 */
+			if ( jump_true )
+				result = sieve_generate_test(cgenv, test, &false_jumps, FALSE);
+			else
+				result = sieve_generate_test(cgenv, test, jumps, FALSE);
+
+			if ( !result ) return FALSE;
+
+			test = sieve_ast_test_next(test);
+		}
+
+		if ( jump_true ) {
+			/* All tests succeeded, jump to case TRUE */
+			sieve_operation_emit(cgenv->sbin, NULL, &sieve_jmp_operation);
+			sieve_jumplist_add(jumps, sieve_binary_emit_offset(sbin, 0));
+
+			/* All false exits jump here */
+			sieve_jumplist_resolve(&false_jumps);
+		}
+	} else {
+		/* Script author is being inefficient; we can optimize the allof test away */
+		test = sieve_ast_test_first(ctx->ast_node);
+		sieve_generate_test(cgenv, test, jumps, jump_true);
+	}
+
+	return TRUE;
+}
+
Index: b/sieve/src/lib-sieve/tst-anyof.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-anyof.c
@@ -0,0 +1,83 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-generator.h"
+#include "sieve-validator.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/*
+ * Anyof test
+ *
+ * Syntax
+ *   anyof <tests: test-list>
+ */
+
+static bool tst_anyof_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command_def tst_anyof = {
+	"anyof",
+	SCT_TEST,
+	0, 2, FALSE, FALSE,
+	NULL, NULL, NULL, NULL,
+	tst_anyof_generate
+};
+
+/*
+ * Code generation
+ */
+
+static bool tst_anyof_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx,
+		struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist true_jumps;
+
+	if ( sieve_ast_test_count(ctx->ast_node) > 1 ) {
+		if ( !jump_true ) {
+			/* Prepare jumplist */
+			sieve_jumplist_init_temp(&true_jumps, sbin);
+		}
+
+		test = sieve_ast_test_first(ctx->ast_node);
+		while ( test != NULL ) {
+			bool result;
+
+			/* If this test list must jump on true, all sub-tests can simply add their jumps
+			 * to the caller's jump list, otherwise this test redirects all true jumps to the
+			 * end of the currently generated code. This is just after a final jump to the false
+			 * case
+			 */
+			if ( !jump_true )
+				result = sieve_generate_test(cgenv, test, &true_jumps, TRUE);
+			else
+				result = sieve_generate_test(cgenv, test, jumps, TRUE);
+
+			if ( !result ) return FALSE;
+
+			test = sieve_ast_test_next(test);
+		}
+
+		if ( !jump_true ) {
+			/* All tests failed, jump to case FALSE */
+			sieve_operation_emit(sbin, NULL, &sieve_jmp_operation);
+			sieve_jumplist_add(jumps, sieve_binary_emit_offset(sbin, 0));
+
+			/* All true exits jump here */
+			sieve_jumplist_resolve(&true_jumps);
+		}
+	} else {
+		/* Script author is being inefficient; we can optimize the allof test away */
+        test = sieve_ast_test_first(ctx->ast_node);
+        sieve_generate_test(cgenv, test, jumps, jump_true);
+    }
+
+	return TRUE;
+}
Index: b/sieve/src/lib-sieve/tst-exists.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-exists.c
@@ -0,0 +1,141 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+
+/*
+ * Exists test
+ *
+ * Syntax:
+ *    exists <header-names: string-list>
+ */
+
+static bool tst_exists_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_exists_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *tst);
+
+const struct sieve_command_def tst_exists = {
+	"exists",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	NULL,
+	NULL,
+	tst_exists_validate,
+	tst_exists_generate,
+	NULL
+};
+
+/*
+ * Exists operation
+ */
+
+static bool tst_exists_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_exists_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def tst_exists_operation = {
+	"EXISTS",
+	NULL,
+	SIEVE_OPERATION_EXISTS,
+	tst_exists_operation_dump,
+	tst_exists_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool tst_exists_validate
+  (struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	return sieve_command_verify_headers_argument(valdtr, arg);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_exists_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, NULL, &tst_exists_operation);
+
+ 	/* Generate arguments */
+    return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_exists_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "EXISTS");
+	sieve_code_descend(denv);
+
+	return sieve_opr_stringlist_dump(denv, address, "header names");
+}
+
+/*
+ * Code execution
+ */
+
+static int tst_exists_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	struct sieve_coded_stringlist *hdr_list;
+	string_t *hdr_item;
+	bool matched;
+
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "EXISTS test");
+
+	/* Iterate through all requested headers to match (must find all specified) */
+	hdr_item = NULL;
+	matched = TRUE;
+	while ( matched &&
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item))
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+
+		if ( mail_get_headers
+			(renv->msgdata->mail, str_c(hdr_item), &headers) < 0 ||
+			headers[0] == NULL ) {
+			matched = FALSE;
+		}
+	}
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid header-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/tst-header.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-header.c
@@ -0,0 +1,253 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+/*
+ * Header test
+ *
+ * Syntax:
+ *   header [COMPARATOR] [MATCH-TYPE]
+ *     <header-names: string-list> <key-list: string-list>
+ */
+
+static bool tst_header_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_header_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_header_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *tst);
+
+const struct sieve_command_def tst_header = {
+	"header",
+	SCT_TEST,
+	2, 0, FALSE, FALSE,
+	tst_header_registered,
+	NULL,
+	tst_header_validate,
+	tst_header_generate,
+	NULL
+};
+
+/*
+ * Header operation
+ */
+
+static bool tst_header_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_header_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def tst_header_operation = {
+	"HEADER",
+	NULL,
+	SIEVE_OPERATION_HEADER,
+	tst_header_operation_dump,
+	tst_header_operation_execute
+};
+
+/*
+ * Test registration
+ */
+
+static bool tst_header_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool tst_header_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mcht_default =
+		SIEVE_COMPARATOR_DEFAULT(is_match_type);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_header_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, NULL, &tst_header_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_header_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "HEADER");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "header names") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Code execution
+ */
+
+static inline string_t *_header_right_trim(const char *raw)
+{
+	string_t *result;
+	int i;
+
+	for ( i = strlen(raw)-1; i >= 0; i-- ) {
+		if ( raw[i] != ' ' && raw[i] != '\t' ) break;
+	}
+
+	result = t_str_new(i+1);
+	str_append_n(result, raw, i + 1);
+	return result;
+}
+
+static int tst_header_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	int opt_code = 0;
+	struct sieve_comparator cmp =
+		SIEVE_COMPARATOR_DEFAULT(i_ascii_casemap_comparator);
+	struct sieve_match_type mcht =
+		SIEVE_COMPARATOR_DEFAULT(is_match_type);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *hdr_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *hdr_item;
+	bool matched;
+	int ret;
+
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+		return ret;
+
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "HEADER test");
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+	/* Iterate through all requested headers to match */
+	hdr_item = NULL;
+	matched = FALSE;
+	while ( result && !matched &&
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item))
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+
+		if ( mail_get_headers_utf8
+			(renv->msgdata->mail, str_c(hdr_item), &headers) >= 0 ) {
+			int i;
+
+			for ( i = 0; !matched && headers[i] != NULL; i++ ) {
+				string_t *theader = _header_right_trim(headers[i]);
+
+				if ( (ret=sieve_match_value(mctx, str_c(theader), str_len(theader)))
+					< 0 )
+				{
+					result = FALSE;
+					break;
+				}
+
+				matched = ret > 0;
+			}
+		}
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
Index: b/sieve/src/lib-sieve/tst-not.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-not.c
@@ -0,0 +1,43 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+
+/*
+ * Not test
+ *
+ * Syntax:
+ *   not <tests: test-list>
+ */
+
+static bool tst_not_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command_def tst_not = {
+	"not",
+	SCT_TEST,
+	0, 1, FALSE, FALSE,
+	NULL, NULL, NULL, NULL,
+	tst_not_generate
+};
+
+/*
+ * Code generation
+ */
+
+static bool tst_not_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_ast_node *test;
+
+	/* Validator verified the existance of the single test already */
+	test = sieve_ast_test_first(ctx->ast_node);
+
+	return sieve_generate_test(cgenv, test, jumps, !jump_true);
+}
+
Index: b/sieve/src/lib-sieve/tst-size.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-size.c
@@ -0,0 +1,275 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+/*
+ * Size test
+ *
+ * Syntax:
+ *    size <":over" / ":under"> <limit: number>
+ */
+
+static bool tst_size_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_size_pre_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_size_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool tst_size_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def tst_size = {
+	"size",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	tst_size_registered,
+	tst_size_pre_validate,
+	tst_size_validate,
+	tst_size_generate,
+	NULL
+};
+
+/*
+ * Size operations
+ */
+
+static bool tst_size_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_size_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def tst_size_over_operation = {
+	"SIZE-OVER",
+	NULL,
+	SIEVE_OPERATION_SIZE_OVER,
+	tst_size_operation_dump,
+	tst_size_operation_execute
+};
+
+const struct sieve_operation_def tst_size_under_operation = {
+	"SIZE-UNDER",
+	NULL,
+	SIEVE_OPERATION_SIZE_UNDER,
+	tst_size_operation_dump,
+	tst_size_operation_execute
+};
+
+/*
+ * Context data
+ */
+
+struct tst_size_context_data {
+	enum { SIZE_UNASSIGNED, SIZE_UNDER, SIZE_OVER } type;
+};
+
+#define TST_SIZE_ERROR_DUP_TAG \
+	"exactly one of the ':under' or ':over' tags must be specified " \
+	"for the size test, but more were found"
+
+/*
+ * Tag validation
+ */
+
+static bool tst_size_validate_over_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *tst)
+{
+	struct tst_size_context_data *ctx_data =
+		(struct tst_size_context_data *) tst->data;
+
+	if ( ctx_data->type != SIZE_UNASSIGNED ) {
+		sieve_argument_validate_error(valdtr, *arg, TST_SIZE_ERROR_DUP_TAG);
+		return FALSE;
+	}
+
+	ctx_data->type = SIZE_OVER;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+static bool tst_size_validate_under_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg ATTR_UNUSED,
+	struct sieve_command *tst)
+{
+	struct tst_size_context_data *ctx_data =
+		(struct tst_size_context_data *) tst->data;
+
+	if ( ctx_data->type != SIZE_UNASSIGNED ) {
+		sieve_argument_validate_error(valdtr, *arg, TST_SIZE_ERROR_DUP_TAG);
+		return FALSE;
+	}
+
+	ctx_data->type = SIZE_UNDER;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/*
+ * Test registration
+ */
+
+static const struct sieve_argument_def size_over_tag = {
+	"over",
+	NULL,
+	tst_size_validate_over_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def size_under_tag = {
+	"under",
+	NULL,
+	tst_size_validate_under_tag,
+	NULL, NULL,  NULL
+};
+
+static bool tst_size_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* Register our tags */
+	sieve_validator_register_tag(valdtr, cmd_reg, NULL, &size_over_tag, 0);
+	sieve_validator_register_tag(valdtr, cmd_reg, NULL, &size_under_tag, 0);
+
+	return TRUE;
+}
+
+/*
+ * Test validation
+ */
+
+static bool tst_size_pre_validate
+(struct sieve_validator *valdtr ATTR_UNUSED,
+	struct sieve_command *tst)
+{
+	struct tst_size_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(tst), struct tst_size_context_data, 1);
+	ctx_data->type = SIZE_UNASSIGNED;
+	tst->data = ctx_data;
+
+	return TRUE;
+}
+
+static bool tst_size_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct tst_size_context_data *ctx_data =
+		(struct tst_size_context_data *) tst->data;
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( ctx_data->type == SIZE_UNASSIGNED ) {
+		sieve_command_validate_error(valdtr, tst,
+			"the size test requires either the :under or the :over tag "
+			"to be specified");
+		return FALSE;
+	}
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "limit", 1, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+bool tst_size_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	struct tst_size_context_data *ctx_data =
+		(struct tst_size_context_data *) tst->data;
+
+	if ( ctx_data->type == SIZE_OVER )
+		sieve_operation_emit(cgenv->sbin, NULL, &tst_size_over_operation);
+	else
+		sieve_operation_emit(cgenv->sbin, NULL, &tst_size_under_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, tst, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_size_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &denv->oprtn;
+	sieve_code_dumpf(denv, "%s", sieve_operation_mnemonic(op));
+	sieve_code_descend(denv);
+
+	return
+		sieve_opr_number_dump(denv, address, "limit");
+}
+
+/*
+ * Code execution
+ */
+
+static inline bool tst_size_get
+(const struct sieve_runtime_env *renv, sieve_number_t *size)
+{
+	uoff_t psize;
+
+	if ( mail_get_physical_size(renv->msgdata->mail, &psize) < 0 )
+		return FALSE;
+
+	*size = psize;
+
+	return TRUE;
+}
+
+static int tst_size_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &renv->oprtn;
+	sieve_number_t mail_size, limit;
+
+	/* Read size limit */
+	if ( !sieve_opr_number_read(renv, address, &limit) ) {
+		sieve_runtime_trace_error(renv, "invalid limit operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "%s test", sieve_operation_mnemonic(op));
+
+	/* Get the size of the message */
+	if ( !tst_size_get(renv, &mail_size) ) {
+		/* FIXME: improve this error */
+		sieve_sys_error("failed to assess message size");
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	/* Perform the test */
+	if ( sieve_operation_is(op, tst_size_over_operation) )
+		sieve_interpreter_set_test_result(renv->interp, (mail_size > limit));
+	else
+		sieve_interpreter_set_test_result(renv->interp, (mail_size < limit));
+
+	return SIEVE_EXEC_OK;
+}
+
Index: b/sieve/src/lib-sieve/tst-truefalse.c
===================================================================
--- /dev/null
+++ b/sieve/src/lib-sieve/tst-truefalse.c
@@ -0,0 +1,65 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-ast.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-interpreter.h"
+
+/*
+ * True/False test command
+ */
+
+static bool tst_false_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+static bool tst_true_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command_def tst_false = {
+	"false",
+	SCT_TEST,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, NULL,
+	tst_false_generate
+};
+
+const struct sieve_command_def tst_true = {
+	"true",
+	SCT_TEST,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, NULL,
+	tst_true_generate
+};
+
+static bool tst_false_generate
+(const struct sieve_codegen_env *cgenv,
+	struct sieve_command *cmd ATTR_UNUSED,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	if ( !jump_true ) {
+		sieve_operation_emit(cgenv->sbin, NULL, &sieve_jmp_operation);
+		sieve_jumplist_add(jumps, sieve_binary_emit_offset(cgenv->sbin, 0));
+	}
+
+	return TRUE;
+}
+
+static bool tst_true_generate
+(const struct sieve_codegen_env *cgenv,
+	struct sieve_command *cmd ATTR_UNUSED,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	if ( jump_true ) {
+		sieve_operation_emit(cgenv->sbin, NULL, &sieve_jmp_operation);
+		sieve_jumplist_add(jumps, sieve_binary_emit_offset(cgenv->sbin, 0));
+	}
+
+	return TRUE;
+}
+
Index: b/sieve/src/plugins/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/plugins/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS = lda-sieve
Index: b/sieve/src/plugins/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/plugins/Makefile.in
@@ -0,0 +1,559 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/plugins
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = lda-sieve
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/plugins/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/plugins/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
+	install-am install-strip tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/plugins/lda-sieve/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/plugins/lda-sieve/Makefile.am
@@ -0,0 +1,24 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-imap \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+lda_moduledir = $(moduledir)/lda
+
+lib90_sieve_plugin_la_LDFLAGS = -module -avoid-version
+
+lda_module_LTLIBRARIES = lib90_sieve_plugin.la
+
+lib90_sieve_plugin_la_LIBADD = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+
+lib90_sieve_plugin_la_SOURCES = \
+	lda-sieve-plugin.c
+
+noinst_HEADERS = \
+	lda-sieve-plugin.h
Index: b/sieve/src/plugins/lda-sieve/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/plugins/lda-sieve/Makefile.in
@@ -0,0 +1,547 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/plugins/lda-sieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(lda_moduledir)"
+LTLIBRARIES = $(lda_module_LTLIBRARIES)
+lib90_sieve_plugin_la_DEPENDENCIES =  \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+am_lib90_sieve_plugin_la_OBJECTS = lda-sieve-plugin.lo
+lib90_sieve_plugin_la_OBJECTS = $(am_lib90_sieve_plugin_la_OBJECTS)
+lib90_sieve_plugin_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(lib90_sieve_plugin_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(lib90_sieve_plugin_la_SOURCES)
+DIST_SOURCES = $(lib90_sieve_plugin_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-imap \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+lda_moduledir = $(moduledir)/lda
+lib90_sieve_plugin_la_LDFLAGS = -module -avoid-version
+lda_module_LTLIBRARIES = lib90_sieve_plugin.la
+lib90_sieve_plugin_la_LIBADD = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+
+lib90_sieve_plugin_la_SOURCES = \
+	lda-sieve-plugin.c
+
+noinst_HEADERS = \
+	lda-sieve-plugin.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/plugins/lda-sieve/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/plugins/lda-sieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-lda_moduleLTLIBRARIES: $(lda_module_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(lda_moduledir)" || $(MKDIR_P) "$(DESTDIR)$(lda_moduledir)"
+	@list='$(lda_module_LTLIBRARIES)'; test -n "$(lda_moduledir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(lda_moduledir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(lda_moduledir)"; \
+	}
+
+uninstall-lda_moduleLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lda_module_LTLIBRARIES)'; test -n "$(lda_moduledir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(lda_moduledir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(lda_moduledir)/$$f"; \
+	done
+
+clean-lda_moduleLTLIBRARIES:
+	-test -z "$(lda_module_LTLIBRARIES)" || rm -f $(lda_module_LTLIBRARIES)
+	@list='$(lda_module_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+lib90_sieve_plugin.la: $(lib90_sieve_plugin_la_OBJECTS) $(lib90_sieve_plugin_la_DEPENDENCIES)
+	$(lib90_sieve_plugin_la_LINK) -rpath $(lda_moduledir) $(lib90_sieve_plugin_la_OBJECTS) $(lib90_sieve_plugin_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lda-sieve-plugin.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(lda_moduledir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-lda_moduleLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-lda_moduleLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-lda_moduleLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-lda_moduleLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-lda_moduleLTLIBRARIES install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-lda_moduleLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/plugins/lda-sieve/lda-sieve-plugin.c
===================================================================
--- /dev/null
+++ b/sieve/src/plugins/lda-sieve/lda-sieve-plugin.c
@@ -0,0 +1,707 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+#include "home-expand.h"
+#include "deliver.h"
+#include "duplicate.h"
+#include "smtp-client.h"
+#include "imap-utf7.h"
+
+#include "sieve.h"
+
+#include "lda-sieve-plugin.h"
+
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+/*
+ * Configuration
+ */
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define LDA_SIEVE_MAX_USER_ERRORS 10
+#define LDA_SIEVE_MAX_SYSTEM_ERRORS 100
+
+/*
+ * Global variables
+ */
+
+static deliver_mail_func_t *next_deliver_mail;
+
+static bool lda_sieve_debug = FALSE;
+
+/*
+ * Settings management
+ */
+
+static const char *lda_sieve_get_homedir
+(void *context ATTR_UNUSED)
+{
+	return getenv("HOME");
+}
+
+static const char *lda_sieve_get_setting
+(void *context ATTR_UNUSED, const char *identifier)
+{
+	return getenv(t_str_ucase(identifier));
+}
+
+static const struct sieve_callbacks lda_sieve_callbacks = {
+	lda_sieve_get_homedir,
+	lda_sieve_get_setting
+};
+
+/*
+ * Mail transmission
+ */
+
+static void *lda_sieve_smtp_open(const char *destination,
+	const char *return_path, FILE **file_r)
+{
+	return (void *) smtp_client_open(destination, return_path, file_r);
+}
+
+static bool lda_sieve_smtp_close(void *handle)
+{
+	struct smtp_client *smtp_client = (struct smtp_client *) handle;
+
+	return ( smtp_client_close(smtp_client) == 0 );
+}
+
+/*
+ * Plugin implementation
+ */
+
+struct lda_sieve_run_context {
+	struct sieve_instance *svinst;
+
+	const char *const *script_files;
+	unsigned int script_count;
+
+	const char *user_script;
+	const char *main_script;
+
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+
+	struct sieve_error_handler *user_ehandler;
+	struct sieve_error_handler *master_ehandler;
+	const char *userlog;
+};
+
+static const char *lda_sieve_get_personal_path(void)
+{
+	const char *script_path, *home;
+
+	home = getenv("HOME");
+
+	/* userdb may specify Sieve path */
+	script_path = getenv("SIEVE");
+	if (script_path != NULL) {
+		if (*script_path == '\0') {
+			/* disabled */
+			if ( lda_sieve_debug )
+				sieve_sys_info("empty script path, disabled");
+			return NULL;
+		}
+
+		script_path = home_expand(script_path);
+
+		if (*script_path != '/' && *script_path != '\0') {
+			/* relative path. change to absolute. */
+			script_path = t_strconcat(getenv("HOME"), "/",
+						  script_path, NULL);
+		}
+	} else {
+		if (home == NULL) {
+			sieve_sys_error(
+				"path to user's main active personal script is unknown. "
+				"See http://wiki.dovecot.org/LDA/Sieve/Dovecot#configuration");
+			return NULL;
+		}
+
+		script_path = home_expand(SIEVE_SCRIPT_PATH);
+	}
+
+	return script_path;
+}
+
+static const char *lda_sieve_get_default_path(void)
+{
+	const char *script_path;
+
+	/* Use global script path, if one exists */
+	script_path = getenv("SIEVE_GLOBAL_PATH");
+	if (script_path == NULL) {
+		/* For backwards compatibility */
+		script_path = getenv("GLOBAL_SCRIPT_PATH");
+	}
+
+	return script_path;
+}
+
+static void lda_sieve_multiscript_get_scriptfiles
+(const char *script_path, ARRAY_TYPE(const_string) *scriptfiles)
+{
+	struct sieve_directory *sdir = sieve_directory_open(script_path);
+
+	if ( sdir != NULL ) {
+		const char *file;
+
+		while ( (file=sieve_directory_get_scriptfile(sdir)) != NULL ) {
+			const char *const *scripts;
+			unsigned int count, i;
+
+			/* Insert into sorted array */
+
+			scripts = array_get(scriptfiles, &count);
+			for ( i = 0; i < count; i++ ) {
+				if ( strcmp(file, scripts[i]) < 0 )
+					break;
+			}
+
+			if ( i == count )
+				array_append(scriptfiles, &file, 1);
+			else
+				array_insert(scriptfiles, i, &file, 1);
+		}
+
+		sieve_directory_close(&sdir);
+	}
+}
+
+static int lda_sieve_open
+(struct lda_sieve_run_context *srctx, unsigned int script_index,
+	struct sieve_binary **sbin)
+{
+	struct sieve_instance *svinst = srctx->svinst;
+	const char *script_path = srctx->script_files[script_index];
+	const char *script_name =
+		( script_path == srctx->main_script ? "main_script" : NULL );
+	struct sieve_error_handler *ehandler;
+	bool exists = TRUE;
+	int ret = 0;
+
+	if ( script_path == srctx->user_script )
+		ehandler = srctx->user_ehandler;
+	else
+		ehandler = srctx->master_ehandler;
+
+	if ( lda_sieve_debug )
+		sieve_sys_info("opening script %s", script_path);
+
+	sieve_error_handler_reset(ehandler);
+
+	if ( (*sbin=sieve_open(svinst, script_path, script_name, ehandler, &exists))
+		== NULL ) {
+
+		ret = sieve_get_errors(ehandler) > 0 ? -1 : 0;
+
+		if ( !exists && ret == 0 ) {
+			if ( lda_sieve_debug )
+				sieve_sys_info("script file %s is missing", script_path);
+		} else {
+			if ( script_path == srctx->user_script && srctx->userlog != NULL ) {
+				sieve_sys_error
+					("failed to open script %s "
+						"(view logfile %s for more information)",
+						script_path, srctx->userlog);
+			} else {
+				sieve_sys_error
+					("failed to open script %s",
+						script_path);
+			}
+		}
+
+		return ret;
+	}
+
+	return 1;
+}
+
+static struct sieve_binary *lda_sieve_recompile
+(struct lda_sieve_run_context *srctx, unsigned int script_index)
+{
+	struct sieve_instance *svinst = srctx->svinst;
+	const char *script_path = srctx->script_files[script_index];
+    const char *script_name =
+		( script_path == srctx->main_script ? "main_script" : NULL );
+    struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+
+	/* Warn */
+
+	sieve_sys_warning("encountered corrupt binary: recompiling script %s",
+		script_path);
+
+	/* Recompile */
+
+	if ( script_path == srctx->user_script )
+		ehandler = srctx->user_ehandler;
+	else
+		ehandler = srctx->master_ehandler;
+
+	if ( (sbin=sieve_compile
+		(svinst, script_path, script_name, ehandler)) == NULL ) {
+
+		if ( script_path == srctx->user_script && srctx->userlog != NULL ) {
+			sieve_sys_error
+				("failed to re-compile script %s "
+					"(view logfile %s for more information)",
+					script_path, srctx->userlog);
+		} else {
+			sieve_sys_error
+				("failed to re-compile script %s", script_path);
+		}
+
+		return NULL;
+	}
+
+	return sbin;
+}
+
+static int lda_sieve_handle_exec_status(const char *script_path, int status)
+{
+	int ret;
+
+	switch ( status ) {
+	case SIEVE_EXEC_FAILURE:
+		sieve_sys_error
+			("execution of script %s failed, but implicit keep was successful",
+				script_path);
+		ret = 1;
+		break;
+	case SIEVE_EXEC_BIN_CORRUPT:
+		sieve_sys_error
+			("!!BUG!!: binary compiled from %s is still corrupt; "
+				"bailing out and reverting to default delivery",
+				script_path);
+		ret = -1;
+		break;
+	case SIEVE_EXEC_KEEP_FAILED:
+		sieve_sys_error
+			("script %s failed with unsuccessful implicit keep", script_path);
+		ret = -1;
+		break;
+	default:
+		ret = status > 0 ? 1 : -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int lda_sieve_singlescript_execute
+(struct lda_sieve_run_context *srctx)
+{
+	const char *script_file = srctx->script_files[0];
+	bool user_script = ( script_file == srctx->user_script );
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	int ret;
+
+	/* Open the script */
+
+	if ( (ret=lda_sieve_open(srctx, 0, &sbin)) <= 0 )
+		return ret;
+
+	/* Execute */
+
+	if ( lda_sieve_debug )
+		sieve_sys_info("executing compiled script %s", script_file);
+
+	if ( user_script ) {
+		ehandler = srctx->user_ehandler;
+		sieve_error_handler_copy_masterlog(ehandler, TRUE);
+	} else {
+		ehandler = srctx->master_ehandler;
+	}
+
+	ret = sieve_execute(sbin, srctx->msgdata, srctx->scriptenv, ehandler, NULL);
+
+	sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+	/* Recompile if corrupt binary */
+
+	if ( ret == SIEVE_EXEC_BIN_CORRUPT ) {
+		/* Close corrupt script */
+
+		sieve_close(&sbin);
+
+		/* Recompile */
+
+		if ( (sbin=lda_sieve_recompile(srctx, 0)) == NULL ) {
+			return -1;
+		}
+
+		/* Execute again */
+
+		if ( user_script )
+        	sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+		ret = sieve_execute(sbin, srctx->msgdata, srctx->scriptenv, ehandler, NULL);
+
+		sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+		/* Save new version */
+
+		if ( ret != SIEVE_EXEC_BIN_CORRUPT )
+			sieve_save(sbin, NULL);
+	}
+
+	sieve_close(&sbin);
+
+	/* Report status */
+	return lda_sieve_handle_exec_status(script_file, ret);
+}
+
+static int lda_sieve_multiscript_execute
+(struct lda_sieve_run_context *srctx)
+{
+	struct sieve_instance *svinst = srctx->svinst;
+	const char *const *scripts = srctx->script_files;
+	unsigned int count = srctx->script_count;
+	struct sieve_multiscript *mscript;
+	struct sieve_error_handler *ehandler = srctx->master_ehandler;
+	const char *last_script = NULL;
+	bool user_script = FALSE;
+	unsigned int i;
+	int ret = 1;
+	bool more = TRUE;
+
+	/* Start execution */
+
+	mscript = sieve_multiscript_start_execute
+		(svinst, srctx->msgdata, srctx->scriptenv);
+
+	/* Execute scripts before main script */
+
+	for ( i = 0; i < count && more; i++ ) {
+		struct sieve_binary *sbin = NULL;
+		const char *script_file = scripts[i];
+		bool final = ( i == count - 1 );
+
+		user_script = ( script_file == srctx->user_script );
+		last_script = script_file;
+
+		if ( user_script )
+			ehandler = srctx->user_ehandler;
+		else
+			ehandler = srctx->master_ehandler;
+
+		/* Open */
+
+		if ( (ret=lda_sieve_open(srctx, i, &sbin)) <= 0 )
+			break;
+
+		/* Execute */
+
+		if ( user_script )
+			sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+		more = sieve_multiscript_run(mscript, sbin, ehandler, final);
+
+		sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+		if ( !more ) {
+			if ( sieve_multiscript_status(mscript) == SIEVE_EXEC_BIN_CORRUPT ) {
+				/* Close corrupt script */
+
+				sieve_close(&sbin);
+
+				/* Recompile */
+
+				if ( (sbin=lda_sieve_recompile(srctx, i))
+					== NULL ) {
+					ret = -1;
+					break;
+				}
+
+				/* Execute again */
+
+				if ( user_script )
+					sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+				more = sieve_multiscript_run(mscript, sbin, ehandler, final);
+
+				sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+				/* Save new version */
+
+				if ( more &&
+					sieve_multiscript_status(mscript) != SIEVE_EXEC_BIN_CORRUPT )
+					sieve_save(sbin, NULL);
+			}
+		}
+
+		sieve_close(&sbin);
+	}
+
+	/* Finish execution */
+
+	if ( user_script )
+		sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+	ret = sieve_multiscript_finish(&mscript, ehandler, NULL);
+
+	sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+	return lda_sieve_handle_exec_status(last_script, ret);
+}
+
+static int lda_sieve_run
+(struct mail_namespace *namespaces, struct mail *mail,
+	const char *user_script, const char *default_script,
+	const ARRAY_TYPE (const_string) *scripts_before,
+	const ARRAY_TYPE (const_string) *scripts_after,
+	const char *destaddr, const char *username, const char *mailbox,
+	struct mail_storage **storage_r)
+{
+	ARRAY_TYPE (const_string) scripts;
+	struct sieve_instance *svinst;
+	struct lda_sieve_run_context srctx;
+	struct sieve_message_data msgdata;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	const char *extensions = NULL;
+        string_t *mailbox_utf8;
+	int ret = 0;
+
+	*storage_r = NULL;
+
+	/* Initialize Sieve engine */
+	svinst = sieve_init(&lda_sieve_callbacks, NULL);
+
+	extensions = getenv("SIEVE_EXTENSIONS");
+	if ( extensions != NULL ) {
+		sieve_set_extensions(svinst, extensions);
+	}
+
+	/* Initialize */
+
+	memset(&srctx, 0, sizeof(srctx));
+	srctx.svinst = svinst;
+
+	/* Compose execution sequence */
+
+	t_array_init(&scripts, 32);
+
+	array_append_array(&scripts, scripts_before);
+
+	if ( user_script != NULL ) {
+		array_append(&scripts, &user_script, 1);
+		srctx.user_script = user_script;
+		srctx.main_script = user_script;
+	} else if ( default_script != NULL ) {
+		array_append(&scripts, &default_script, 1);
+		srctx.user_script = NULL;
+		srctx.main_script = default_script;
+	} else {
+		srctx.user_script = NULL;
+        srctx.main_script = NULL;
+	}
+
+	array_append_array(&scripts, scripts_after);
+
+	/* Create error handlers */
+
+	if ( user_script != NULL ) {
+		srctx.userlog = t_strconcat(user_script, ".log", NULL);
+		srctx.user_ehandler = sieve_logfile_ehandler_create
+			(srctx.userlog, LDA_SIEVE_MAX_USER_ERRORS);
+	}
+
+	srctx.master_ehandler =
+		sieve_master_ehandler_create(LDA_SIEVE_MAX_SYSTEM_ERRORS);
+	sieve_error_handler_accept_infolog(srctx.master_ehandler, TRUE);
+
+	/* Collect necessary message data */
+
+	memset(&msgdata, 0, sizeof(msgdata));
+
+	msgdata.mail = mail;
+	msgdata.return_path = deliver_get_return_address(mail);
+	msgdata.to_address = destaddr;
+	msgdata.auth_user = username;
+	(void)mail_get_first_header(mail, "Message-ID", &msgdata.id);
+
+	srctx.msgdata = &msgdata;
+
+	/* Convert mutf7 mailbox name to UTF-8 */
+
+        mailbox_utf8 = t_str_new(128);
+        if (imap_utf7_to_utf8(mailbox, mailbox_utf8) < 0) {
+                str_truncate(mailbox_utf8, 0);
+                str_append(mailbox_utf8, mailbox);
+        }
+
+	/* Compose script execution environment */
+
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	memset(&estatus, 0, sizeof(estatus));
+
+	scriptenv.action_log_format = deliver_set->log_format;
+	scriptenv.default_mailbox = str_c(mailbox_utf8);
+	scriptenv.mailbox_autocreate = deliver_set->mailbox_autocreate;
+	scriptenv.mailbox_autosubscribe = deliver_set->mailbox_autosubscribe;
+	scriptenv.namespaces = namespaces;
+	scriptenv.username = username;
+	scriptenv.hostname = deliver_set->hostname;
+	scriptenv.postmaster_address = deliver_set->postmaster_address;
+	scriptenv.smtp_open = lda_sieve_smtp_open;
+	scriptenv.smtp_close = lda_sieve_smtp_close;
+	scriptenv.duplicate_mark = duplicate_mark;
+	scriptenv.duplicate_check = duplicate_check;
+	scriptenv.exec_status = &estatus;
+
+	srctx.scriptenv = &scriptenv;
+
+	/* Assign script sequence */
+
+	srctx.script_files = array_get(&scripts, &srctx.script_count);
+
+	/* Execute script(s) */
+
+	if ( srctx.script_count == 1 )
+		ret = lda_sieve_singlescript_execute(&srctx);
+	else
+		ret = lda_sieve_multiscript_execute(&srctx);
+
+	/* Record status */
+
+	tried_default_save = estatus.tried_default_save;
+	*storage_r = estatus.last_storage;
+
+	/* Clean up */
+
+	if ( srctx.user_ehandler != NULL )
+		sieve_error_handler_unref(&srctx.user_ehandler);
+	sieve_error_handler_unref(&srctx.master_ehandler);
+
+	/* Deinitialize Sieve engine */
+	sieve_deinit(&svinst);
+
+	return ret;
+}
+
+static int lda_sieve_deliver_mail
+(struct mail_namespace *namespaces, struct mail_storage **storage_r,
+	struct mail *mail, const char *destaddr, const char *mailbox)
+{
+	const char *user_script, *default_script, *sieve_before, *sieve_after;
+	ARRAY_TYPE (const_string) scripts_before;
+	ARRAY_TYPE (const_string) scripts_after;
+	int ret = 0;
+
+	*storage_r = NULL;
+
+	T_BEGIN {
+		struct stat st;
+
+		/* Find the personal script to execute */
+
+		user_script = lda_sieve_get_personal_path();
+		default_script = lda_sieve_get_default_path();
+
+		if ( user_script != NULL && stat(user_script, &st) < 0 ) {
+			if (errno != ENOENT)
+				sieve_sys_error("stat(%s) failed: %m "
+					"(using global script path in stead)", user_script);
+			else if (getenv("DEBUG") != NULL)
+				sieve_sys_info("local script path %s doesn't exist "
+					"(using global script path in stead)", user_script);
+
+			user_script = NULL;
+		}
+
+		if ( lda_sieve_debug ) {
+			const char *script = user_script == NULL ? default_script : user_script;
+
+			if ( script == NULL )
+				sieve_sys_info("user has no valid personal script");
+			else
+				sieve_sys_info("using sieve path for user's script: %s", script);
+		}
+
+		/* Check for multiscript */
+
+		t_array_init(&scripts_before, 16);
+		t_array_init(&scripts_after, 16);
+
+		sieve_before = getenv("SIEVE_BEFORE");
+		sieve_after = getenv("SIEVE_AFTER");
+
+		if ( sieve_before != NULL && *sieve_before != '\0' ) {
+			lda_sieve_multiscript_get_scriptfiles(sieve_before, &scripts_before);
+		}
+
+		if ( sieve_after != NULL && *sieve_after != '\0' ) {
+			lda_sieve_multiscript_get_scriptfiles(sieve_after, &scripts_after);
+		}
+
+		if ( lda_sieve_debug ) {
+			const char *const *scriptfiles;
+			unsigned int count, i;
+
+			scriptfiles = array_get(&scripts_before, &count);
+			for ( i = 0; i < count; i ++ ) {
+				sieve_sys_info("executed before user's script(%d): %s", i+1, scriptfiles[i]);
+			}
+
+			scriptfiles = array_get(&scripts_after, &count);
+			for ( i = 0; i < count; i ++ ) {
+				sieve_sys_info("executed after user's script(%d): %s", i+1, scriptfiles[i]);
+			}
+		}
+
+		/* Check whether there are any scripts to execute */
+
+		if ( array_count(&scripts_before) == 0 && array_count(&scripts_after) == 0 &&
+			user_script == NULL && default_script == NULL ) {
+			if ( lda_sieve_debug )
+				sieve_sys_info("no scripts to execute: reverting to default delivery.");
+
+			/* No error, but no delivery by this plugin either. A return value of <= 0 for a
+			 * deliver plugin is is considered a failure. In deliver itself, saved_mail and
+			 * tried_default_save remain unset, meaning that deliver will then attempt the
+			 * default delivery. We return 0 to signify the lack of a real error.
+			 */
+			ret = 0;
+		} else {
+			/* Run the script(s) */
+
+			ret = lda_sieve_run
+				(namespaces, mail, user_script,	default_script,
+					&scripts_before, &scripts_after,
+					destaddr, getenv("USER"), mailbox, storage_r);
+		}
+
+	} T_END;
+
+	return ret;
+}
+
+/*
+ * Plugin interface
+ */
+
+void sieve_plugin_init(void)
+{
+	/* Debug mode */
+	lda_sieve_debug = getenv("DEBUG");
+
+	/* Hook into the delivery process */
+	next_deliver_mail = deliver_mail;
+	deliver_mail = lda_sieve_deliver_mail;
+}
+
+void sieve_plugin_deinit(void)
+{
+	/* Remove hook */
+	deliver_mail = next_deliver_mail;
+}
Index: b/sieve/src/plugins/lda-sieve/lda-sieve-plugin.h
===================================================================
--- /dev/null
+++ b/sieve/src/plugins/lda-sieve/lda-sieve-plugin.h
@@ -0,0 +1,14 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __LDA_SIEVE_PLUGIN_H
+#define __LDA_SIEVE_PLUGIN_H
+
+/*
+ * Plugin interface
+ */
+
+void sieve_plugin_init(void);
+void sieve_plugin_deinit(void);
+
+#endif /* __LDA_SIEVE_PLUGIN_H */
Index: b/sieve/src/sieve-tools/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/Makefile.am
@@ -0,0 +1,72 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+SUBDIRS = debug
+
+bin_PROGRAMS = sievec sieved sieve-test
+
+if BUILD_UNFINISHED
+bin_PROGRAMS += sieve-filter
+endif
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(top_srcdir)/src/lib-sieve-tool \
+	-I./debug \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la \
+	$(STORAGE_LIBS)
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+# Sieve Compile Tool
+
+sievec_LDFLAGS = -export-dynamic
+sievec_LDADD = $(ldadd)
+sievec_DEPENDENCIES = $(libs)
+
+sievec_SOURCES = \
+	sievec.c
+
+# Sieve Dump Tool
+
+sieved_LDFLAGS = -export-dynamic
+sieved_LDADD = $(ldadd)
+sieved_DEPENDENCIES = $(libs)
+
+sieved_SOURCES = \
+	sieved.c
+
+# Sieve Test Tool
+
+sieve_test_LDFLAGS = -export-dynamic
+sieve_test_LDADD = $(ldadd)
+sieve_test_DEPENDENCIES = $(libs)
+
+sieve_test_SOURCES = \
+	sieve-test.c
+
+## Unfinished tools
+
+# Sieve Filter Tool
+
+sieve_filter_LDFLAGS = -export-dynamic
+sieve_filter_LDADD = $(ldadd)
+sieve_filter_DEPENDENCIES = $(libs)
+
+sieve_filter_SOURCES = \
+	sieve-filter.c
+
+noinst_HEADERS =
Index: b/sieve/src/sieve-tools/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/Makefile.in
@@ -0,0 +1,763 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+bin_PROGRAMS = sievec$(EXEEXT) sieved$(EXEEXT) sieve-test$(EXEEXT) \
+	$(am__EXEEXT_1)
+@BUILD_UNFINISHED_TRUE@am__append_1 = sieve-filter
+subdir = src/sieve-tools
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+@BUILD_UNFINISHED_TRUE@am__EXEEXT_1 = sieve-filter$(EXEEXT)
+am__installdirs = "$(DESTDIR)$(bindir)"
+PROGRAMS = $(bin_PROGRAMS)
+am_sieve_filter_OBJECTS = sieve-filter.$(OBJEXT)
+sieve_filter_OBJECTS = $(am_sieve_filter_OBJECTS)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = $(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la $(am__DEPENDENCIES_1)
+am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+sieve_filter_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(sieve_filter_LDFLAGS) $(LDFLAGS) -o $@
+am_sieve_test_OBJECTS = sieve-test.$(OBJEXT)
+sieve_test_OBJECTS = $(am_sieve_test_OBJECTS)
+sieve_test_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(sieve_test_LDFLAGS) $(LDFLAGS) -o $@
+am_sievec_OBJECTS = sievec.$(OBJEXT)
+sievec_OBJECTS = $(am_sievec_OBJECTS)
+sievec_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(sievec_LDFLAGS) \
+	$(LDFLAGS) -o $@
+am_sieved_OBJECTS = sieved.$(OBJEXT)
+sieved_OBJECTS = $(am_sieved_OBJECTS)
+sieved_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(sieved_LDFLAGS) \
+	$(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(sieve_filter_SOURCES) $(sieve_test_SOURCES) \
+	$(sievec_SOURCES) $(sieved_SOURCES)
+DIST_SOURCES = $(sieve_filter_SOURCES) $(sieve_test_SOURCES) \
+	$(sievec_SOURCES) $(sieved_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+HEADERS = $(noinst_HEADERS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \
+	distdir
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+pkglibexecdir = $(libexecdir)/dovecot
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = debug
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(top_srcdir)/src/lib-sieve-tool \
+	-I./debug \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la \
+	$(STORAGE_LIBS)
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+
+# Sieve Compile Tool
+sievec_LDFLAGS = -export-dynamic
+sievec_LDADD = $(ldadd)
+sievec_DEPENDENCIES = $(libs)
+sievec_SOURCES = \
+	sievec.c
+
+
+# Sieve Dump Tool
+sieved_LDFLAGS = -export-dynamic
+sieved_LDADD = $(ldadd)
+sieved_DEPENDENCIES = $(libs)
+sieved_SOURCES = \
+	sieved.c
+
+
+# Sieve Test Tool
+sieve_test_LDFLAGS = -export-dynamic
+sieve_test_LDADD = $(ldadd)
+sieve_test_DEPENDENCIES = $(libs)
+sieve_test_SOURCES = \
+	sieve-test.c
+
+
+# Sieve Filter Tool
+sieve_filter_LDFLAGS = -export-dynamic
+sieve_filter_LDADD = $(ldadd)
+sieve_filter_DEPENDENCIES = $(libs)
+sieve_filter_SOURCES = \
+	sieve-filter.c
+
+noinst_HEADERS =
+all: all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/sieve-tools/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/sieve-tools/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	for p in $$list; do echo "$$p $$p"; done | \
+	sed 's/$(EXEEXT)$$//' | \
+	while read p p1; do if test -f $$p || test -f $$p1; \
+	  then echo "$$p"; echo "$$p"; else :; fi; \
+	done | \
+	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
+	sed 'N;N;N;s,\n, ,g' | \
+	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
+	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
+	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
+	    else { print "f", $$3 "/" $$4, $$1; } } \
+	  END { for (d in files) print "f", d, files[d] }' | \
+	while read type dir files; do \
+	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
+	    test -z "$$files" || { \
+	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
+	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
+	    } \
+	; done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	files=`for p in $$list; do echo "$$p"; done | \
+	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
+	      -e 's/$$/$(EXEEXT)/' `; \
+	test -n "$$list" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(bindir)" && rm -f $$files
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+sieve-filter$(EXEEXT): $(sieve_filter_OBJECTS) $(sieve_filter_DEPENDENCIES)
+	@rm -f sieve-filter$(EXEEXT)
+	$(sieve_filter_LINK) $(sieve_filter_OBJECTS) $(sieve_filter_LDADD) $(LIBS)
+sieve-test$(EXEEXT): $(sieve_test_OBJECTS) $(sieve_test_DEPENDENCIES)
+	@rm -f sieve-test$(EXEEXT)
+	$(sieve_test_LINK) $(sieve_test_OBJECTS) $(sieve_test_LDADD) $(LIBS)
+sievec$(EXEEXT): $(sievec_OBJECTS) $(sievec_DEPENDENCIES)
+	@rm -f sievec$(EXEEXT)
+	$(sievec_LINK) $(sievec_OBJECTS) $(sievec_LDADD) $(LIBS)
+sieved$(EXEEXT): $(sieved_OBJECTS) $(sieved_DEPENDENCIES)
+	@rm -f sieved$(EXEEXT)
+	$(sieved_LINK) $(sieved_OBJECTS) $(sieved_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-filter.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-test.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sievec.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieved.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am: install-binPROGRAMS
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) ctags-recursive \
+	install-am install-strip tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic clean-libtool ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-binPROGRAMS install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am \
+	uninstall-binPROGRAMS
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/sieve-tools/debug/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/debug/Makefile.am
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_debug.la
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-debug-print.c
+
+libsieve_ext_debug_la_SOURCES = \
+	$(commands) \
+	ext-debug.c
+
+noinst_HEADERS = \
+	sieve-ext-debug.h \
+	ext-debug-common.h
Index: b/sieve/src/sieve-tools/debug/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/debug/Makefile.in
@@ -0,0 +1,494 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/sieve-tools/debug
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libsieve_ext_debug_la_LIBADD =
+am__objects_1 = cmd-debug-print.lo
+am_libsieve_ext_debug_la_OBJECTS = $(am__objects_1) ext-debug.lo
+libsieve_ext_debug_la_OBJECTS = $(am_libsieve_ext_debug_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_ext_debug_la_SOURCES)
+DIST_SOURCES = $(libsieve_ext_debug_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_ext_debug.la
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+commands = \
+	cmd-debug-print.c
+
+libsieve_ext_debug_la_SOURCES = \
+	$(commands) \
+	ext-debug.c
+
+noinst_HEADERS = \
+	sieve-ext-debug.h \
+	ext-debug-common.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/sieve-tools/debug/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/sieve-tools/debug/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_ext_debug.la: $(libsieve_ext_debug_la_OBJECTS) $(libsieve_ext_debug_la_DEPENDENCIES)
+	$(LINK)  $(libsieve_ext_debug_la_OBJECTS) $(libsieve_ext_debug_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-debug-print.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-debug.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/sieve-tools/debug/cmd-debug-print.c
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/debug/cmd-debug-print.c
@@ -0,0 +1,129 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-debug-common.h"
+
+/*
+ * Debug_print command
+ *
+ * Syntax
+ *   debug_print <message: string>
+ */
+
+static bool cmd_debug_print_validate
+	(struct sieve_validator *valdtr, struct sieve_command *tst);
+static bool cmd_debug_print_generate
+	(const struct sieve_codegen_env *cgenv,	struct sieve_command *ctx);
+
+const struct sieve_command_def debug_print_command = {
+	"debug_print",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_debug_print_validate,
+	cmd_debug_print_generate,
+	NULL
+};
+
+/*
+ * Body operation
+ */
+
+static bool cmd_debug_print_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_debug_print_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def debug_print_operation = {
+	"debug_print",
+	&debug_extension,
+	0,
+	cmd_debug_print_operation_dump,
+	cmd_debug_print_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_debug_print_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "message", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_debug_print_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	(void)sieve_operation_emit(cgenv->sbin, cmd->ext, &debug_print_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_debug_print_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "DEBUG_PRINT");
+	sieve_code_descend(denv);
+
+	return sieve_opr_string_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_debug_print_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *message;
+	int ret = SIEVE_EXEC_OK;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Read message */
+
+	if ( sieve_opr_string_read(renv, address, &message) < 0 ) {
+		sieve_runtime_trace_error(renv, "invalid message operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "DEBUG_PRINT");
+
+	/* FIXME: give this proper source location */
+	sieve_runtime_log(renv, "DEBUG", "%s", str_c(message));
+
+	return ret;
+}
Index: b/sieve/src/sieve-tools/debug/ext-debug-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/debug/ext-debug-common.h
@@ -0,0 +1,21 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_DEBUG_COMMON_H
+#define __EXT_DEBUG_COMMON_H
+
+#include "sieve-ext-debug.h"
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def debug_print_command;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation_def debug_print_operation;
+
+#endif /* __EXT_DEBUG_COMMON_H */
Index: b/sieve/src/sieve-tools/debug/ext-debug.c
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/debug/ext-debug.c
@@ -0,0 +1,56 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension debug
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: vendor-defined
+ * Implementation: full
+ * Status: experimental
+ *
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-debug-common.h"
+
+/*
+ * Extension
+ */
+
+static bool ext_debug_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator);
+
+const struct sieve_extension_def debug_extension = {
+	"vnd.dovecot.debug",
+	NULL, NULL,
+	ext_debug_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(debug_print_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_debug_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, ext, &debug_print_command);
+
+	return TRUE;
+}
+
+
Index: b/sieve/src/sieve-tools/debug/sieve-ext-debug.h
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/debug/sieve-ext-debug.h
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXT_DEBUG_H
+#define __SIEVE_EXT_DEBUG_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension_def debug_extension;
+
+#endif /* __SIEVE_EXT_DEBUG_H */
Index: b/sieve/src/sieve-tools/sieve-filter.c
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/sieve-filter.c
@@ -0,0 +1,390 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "array.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+#include "mail-search-build.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieve-filter [-m <mailbox>] [-x <extensions>] [-s <script-file>] [-c]\n"
+"                    <script-file> <src-mail-store> [<dest-mail-store>]\n"
+	);
+}
+
+enum discard_action_type {
+	DISCARD_ACTION_KEEP,            /* Always keep messages in source folder */
+	DISCARD_ACTION_DELETE,          /* Flag discarded messages as \DELETED */
+	DISCARD_ACTION_TRASH_FOLDER,    /* Move discarded messages to Trash folder */
+	DISCARD_ACTION_EXPUNGE          /* Expunge discarded messages */
+};
+
+struct discard_action {
+	enum discard_action_type type;
+	const char *trash_folder;
+};
+
+static int filter_message
+(struct mail *mail, struct sieve_binary *main_sbin,
+	struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct discard_action discard_action)
+{
+	struct sieve_exec_status estatus;
+	struct sieve_binary *sbin;
+	struct sieve_message_data msgdata;
+	const char *recipient, *sender;
+	int ret;
+
+	sieve_tool_get_envelope_data(mail, &recipient, &sender);
+
+	/* Initialize execution status */
+	memset(&estatus, 0, sizeof(estatus));
+	senv->exec_status = &estatus;
+
+	/* Collect necessary message data */
+	memset(&msgdata, 0, sizeof(msgdata));
+	msgdata.mail = mail;
+	msgdata.return_path = sender;
+	msgdata.to_address = recipient;
+	msgdata.auth_user = senv->username;
+	(void)mail_get_first_header(mail, "Message-ID", &msgdata.id);
+
+	/* Single script */
+	sbin = main_sbin;
+	main_sbin = NULL;
+
+	/* Execute script */
+	ret = sieve_execute(sbin, &msgdata, senv, ehandler, NULL);
+
+	/* Handle message in source folder */
+	if ( ret > 0 && !estatus.keep_original ) {
+		switch ( discard_action.type ) {
+		/* Leave it there */
+		case DISCARD_ACTION_KEEP:
+			sieve_info(ehandler, NULL, "message left in source folder");
+			break;
+		/* Flag message as \DELETED */
+		case DISCARD_ACTION_DELETE:
+			sieve_info(ehandler, NULL, "message flagged as deleted in source folder");
+			mail_update_flags(mail, MODIFY_ADD, MAIL_DELETED);
+			break;
+		/* Move message to Trash folder */
+		case DISCARD_ACTION_TRASH_FOLDER:
+			sieve_info(ehandler, NULL,
+				"message in source folder moved to folder '%s'",
+				discard_action.trash_folder);
+			break;
+		/* Expunge the message immediately */
+		case DISCARD_ACTION_EXPUNGE:
+			sieve_info(ehandler, NULL, "message removed from source folder");
+			mail_expunge(mail);
+			break;
+		/* Unknown */
+		default:
+			i_unreached();
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* FIXME: introduce this into Dovecot */
+static void mail_search_build_add_flags
+(struct mail_search_args *args, enum mail_flags flags, bool not)
+{
+	struct mail_search_arg *arg;
+
+	arg = p_new(args->pool, struct mail_search_arg, 1);
+	arg->type = SEARCH_FLAGS;
+	arg->value.flags = flags;
+	arg->not = not;
+
+	arg->next = args->args;
+	args->args = arg;
+}
+
+static int filter_mailbox
+(struct mailbox *box, struct sieve_binary *main_sbin,
+	struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct discard_action discard_action)
+{
+	struct mail_search_args *search_args;
+	struct mailbox_transaction_context *t;
+	struct mail_search_context *search_ctx;
+	struct mail *mail;
+	int ret = 1;
+
+	/* Sync mailbox */
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_READ, 0, NULL) < 0 ) {
+		return -1;
+	}
+
+	/* Search non-deleted messages in the source folder */
+
+	search_args = mail_search_build_init();
+	mail_search_build_add_flags(search_args, MAIL_DELETED, TRUE);
+
+	/* Iterate through all requested messages */
+
+	t = mailbox_transaction_begin(box, 0);
+	search_ctx = mailbox_search_init(t, search_args, NULL);
+	mail_search_args_unref(&search_args);
+
+	mail = mail_alloc(t, 0, NULL);
+	while ( ret > 0 && mailbox_search_next(search_ctx, mail) > 0 ) {
+		const char *subject, *date;
+		uoff_t size = 0;
+
+		/* Request message size */
+
+		if ( mail_get_virtual_size(mail, &size) < 0 ) {
+			if ( mail->expunged )
+				continue;
+
+			sieve_error(ehandler, NULL, "failed to obtain message size");
+			continue;
+		}
+
+		if ( mail_get_first_header(mail, "date", &date) <= 0 )
+			date = "";
+		if ( mail_get_first_header(mail, "subject", &subject) <= 0 )
+			subject = "";
+
+		sieve_info(ehandler, NULL,
+			"filtering: [%s; %"PRIuUOFF_T" bytes] %s", date, size, subject);
+
+		ret = filter_message(mail, main_sbin, senv, ehandler, discard_action);
+	}
+	mail_free(&mail);
+
+	/* Cleanup */
+
+	if ( mailbox_search_deinit(&search_ctx) < 0 ) {
+		ret = -1;
+	}
+
+	if ( ret < 0 ) {
+		mailbox_transaction_rollback(&t);
+		return -1;
+	} else {
+		if ( mailbox_transaction_commit(&t) < 0 ) {
+			return -1;
+		}
+	}
+
+	/* Sync mailbox */
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_WRITE, 0, NULL) < 0 ) {
+		return -1;
+	}
+
+	return ret;
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv)
+{
+	const char *scriptfile, *recipient, *sender, *extensions,
+		*src_mailbox, *dst_mailbox, *src_mailstore, *dst_mailstore;
+	bool force_compile;
+	struct mail_namespace *src_ns = NULL, *dst_ns = NULL;
+	struct mail_user *mail_user = NULL;
+	struct sieve_binary *main_sbin;
+	struct sieve_script_env scriptenv;
+	struct sieve_error_handler *ehandler;
+	struct mail_storage *dst_storage, *src_storage;
+	struct discard_action discard_action =
+		{ DISCARD_ACTION_KEEP, "Trash" };
+	struct mailbox *src_box;
+	enum mail_error error;
+	enum mailbox_open_flags open_flags =
+		MAILBOX_OPEN_KEEP_RECENT | MAILBOX_OPEN_IGNORE_ACLS;
+	const char *user, *home, *folder;
+	int i;
+
+	sieve_tool_init(NULL);
+
+	/* Parse arguments */
+	scriptfile = recipient = sender = extensions = src_mailstore = dst_mailstore
+		= NULL;
+	src_mailbox = dst_mailbox = "INBOX";
+	force_compile = FALSE;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-m") == 0) {
+			/* default mailbox (keep box) */
+			i++;
+			if (i == argc)
+				i_fatal("Missing -m argument");
+			dst_mailbox = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc)
+				i_fatal("Missing -x argument");
+			extensions = argv[i];
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* force compile */
+			force_compile = TRUE;
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( src_mailstore == NULL ) {
+			src_mailstore = argv[i];
+		} else if ( dst_mailstore == NULL ) {
+			dst_mailstore = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <scriptfile> argument");
+	}
+
+	if ( src_mailstore == NULL ) {
+		print_help();
+		i_fatal("Missing <mailstore> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(sieve_instance, extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(sieve_instance, &debug_extension, TRUE);
+
+	/* Create error handler */
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_system_ehandler_set(ehandler);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	/* Compile main sieve script */
+	if ( force_compile ) {
+		main_sbin = sieve_tool_script_compile(scriptfile, NULL);
+		(void) sieve_save(main_sbin, NULL);
+	} else {
+		main_sbin = sieve_tool_script_open(scriptfile);
+	}
+
+	user = sieve_tool_get_user();
+	home = getenv("HOME");
+
+	/* Initialize mail storages */
+	mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+	mail_storage_init();
+	mail_storage_register_all();
+	mailbox_list_register_all();
+
+	/* Build namespaces environment (ugly!) */
+	env_put(t_strdup_printf("NAMESPACE_1=%s", src_mailstore));
+	env_put("NAMESPACE_1_INBOX=1");
+	env_put("NAMESPACE_1_LIST=1");
+	env_put("NAMESPACE_1_SEP=/");
+	env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+	if ( dst_mailstore != NULL ) {
+		env_put(t_strdup_printf("NAMESPACE_2=%s", dst_mailstore));
+		env_put("NAMESPACE_2_LIST=1");
+		env_put("NAMESPACE_2_SEP=/");
+		env_put("NAMESPACE_2_SUBSCRIPTIONS=1");
+
+		env_put("NAMESPACE_1_PREFIX=#src/");
+	}
+
+	/* Initialize namespaces */
+	mail_user = mail_user_init(user);
+	mail_user_set_home(mail_user, home);
+	if (mail_namespaces_init(mail_user) < 0)
+		i_fatal("Namespace initialization failed");
+
+	if ( dst_mailstore != NULL ) {
+		folder = "#src/";
+		src_ns = mail_namespace_find(mail_user->namespaces, &folder);
+
+		folder = "/";
+		dst_ns = mail_namespace_find(mail_user->namespaces, &folder);
+
+		discard_action.type = DISCARD_ACTION_KEEP;
+	} else {
+		dst_ns = src_ns = mail_user->namespaces;
+		discard_action.type = DISCARD_ACTION_DELETE;
+	}
+
+	src_storage = src_ns->storage;
+	dst_storage = dst_ns->storage;
+
+	/* Open the source mailbox */
+	src_box = mailbox_open(&src_storage, src_mailbox, NULL, open_flags);
+	if ( src_box == NULL ) {
+		i_fatal("Couldn't open mailbox '%s': %s",
+			src_mailbox, mail_storage_get_last_error(src_storage, &error));
+	}
+
+	/* Compose script environment */
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	scriptenv.mailbox_autocreate = TRUE;
+	scriptenv.default_mailbox = dst_mailbox;
+	scriptenv.namespaces = dst_ns;
+	scriptenv.username = user;
+	scriptenv.hostname = "host.example.com";
+	scriptenv.postmaster_address = "postmaster@example.com";
+	scriptenv.smtp_open = NULL;
+	scriptenv.smtp_close = NULL;
+	scriptenv.duplicate_mark = NULL;
+	scriptenv.duplicate_check = NULL;
+	scriptenv.trace_stream = NULL;
+
+	/* Apply Sieve filter to all messages found */
+	(void) filter_mailbox
+		(src_box, main_sbin, &scriptenv, ehandler, discard_action);
+
+	/* Close the mailbox */
+	if ( src_box != NULL )
+		mailbox_close(&src_box);
+
+	/* Cleanup error handler */
+	sieve_error_handler_unref(&ehandler);
+	sieve_system_ehandler_reset();
+
+	/* De-initialize mail user object */
+	if ( mail_user != NULL )
+		mail_user_unref(&mail_user);
+
+	/* De-initialize mail storages */
+	mail_storage_deinit();
+	mail_users_deinit();
+
+	sieve_tool_deinit();
+
+	return 0;
+}
Index: b/sieve/src/sieve-tools/sieve-test.c
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/sieve-test.c
@@ -0,0 +1,421 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "array.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-binary.h"
+#include "sieve-extensions.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Configuration
+ */
+
+#define DEFAULT_SENDMAIL_PATH "/usr/lib/sendmail"
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieve-test [-c] [-d <dump-filename>] [-e] [-f <envelope-sender>]\n"
+"                  [-l <mail-location>] [-m <default-mailbox>]\n"
+"                  [-r <recipient-address>] [-s <script-file>]\n"
+"                  [-t] [-x <extensions>] <script-file> <mail-file>\n"
+	);
+}
+
+/*
+ * Dummy SMTP session
+ */
+
+static void *sieve_smtp_open(const char *destination,
+	const char *return_path, FILE **file_r)
+{
+	i_info("sending message from <%s> to <%s>:",
+		( return_path == NULL ? "" : return_path ), destination);
+	printf("\nSTART MESSAGE:\n");
+
+	*file_r = stdout;
+
+	return NULL;
+}
+
+static bool sieve_smtp_close(void *handle ATTR_UNUSED)
+{
+	printf("END MESSAGE\n\n");
+	return TRUE;
+}
+
+/*
+ * Dummy duplicate check implementation
+ */
+
+static int duplicate_check(const void *id ATTR_UNUSED, size_t id_size ATTR_UNUSED,
+	const char *user)
+{
+	i_info("checked duplicate for user %s.\n", user);
+	return 0;
+}
+
+static void duplicate_mark
+(const void *id ATTR_UNUSED, size_t id_size ATTR_UNUSED, const char *user,
+	time_t time ATTR_UNUSED)
+{
+	i_info("marked duplicate for user %s.\n", user);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv)
+{
+	ARRAY_DEFINE(scriptfiles, const char *);
+	const char *scriptfile, *recipient, *sender, *mailbox, *dumpfile, *mailfile,
+		*mailloc, *extensions;
+	const char *user, *home;
+	int i;
+	struct mail_raw *mailr;
+	struct mail_namespace *ns = NULL;
+	struct mail_user *mail_user = NULL;
+	struct sieve_binary *main_sbin, *sbin = NULL;
+	struct sieve_message_data msgdata;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	struct sieve_error_handler *ehandler;
+	struct ostream *teststream = NULL;
+	bool force_compile = FALSE, execute = FALSE;
+	bool trace = FALSE;
+	int ret;
+
+	sieve_tool_init(NULL);
+
+	t_array_init(&scriptfiles, 16);
+
+	/* Parse arguments (ugly) */
+	scriptfile = recipient = sender = mailbox = dumpfile = mailfile = mailloc =
+		extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-r") == 0) {
+			/* recipient address */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -r argument");
+			}
+			recipient = argv[i];
+		} else if (strcmp(argv[i], "-f") == 0) {
+			/* envelope sender */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -f argument");
+			}
+			sender = argv[i];
+		} else if (strcmp(argv[i], "-m") == 0) {
+			/* default mailbox (keep box) */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -m argument");
+			}
+			mailbox = argv[i];
+		} else if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -d argument");
+			}
+			dumpfile = argv[i];
+		} else if (strcmp(argv[i], "-l") == 0) {
+			/* mail location */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -l argument");
+			}
+			mailloc = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if (strcmp(argv[i], "-s") == 0) {
+			const char *file;
+
+			/* scriptfile executed before main script */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -s argument");
+			}
+
+			file = t_strdup(argv[i]);
+			array_append(&scriptfiles, &file, 1);
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* force compile */
+			force_compile = TRUE;
+		} else if (strcmp(argv[i], "-e") == 0) {
+			/* execute */
+			execute = TRUE;
+#ifdef SIEVE_RUNTIME_TRACE
+		} else if (strcmp(argv[i], "-t") == 0) {
+			/* runtime trace */
+			trace = TRUE;
+#endif
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( mailfile == NULL ) {
+			mailfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <script-file> argument");
+	}
+
+	if ( mailfile == NULL ) {
+		print_help();
+		i_fatal("Missing <mail-file> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(sieve_instance, extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(sieve_instance, &debug_extension, TRUE);
+
+	/* Create error handler */
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_system_ehandler_set(ehandler);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	/* Compile main sieve script */
+	if ( force_compile ) {
+		main_sbin = sieve_tool_script_compile(scriptfile, NULL);
+		if ( main_sbin != NULL )
+			(void) sieve_save(main_sbin, NULL);
+	} else {
+		main_sbin = sieve_tool_script_open(scriptfile);
+	}
+
+	if ( main_sbin != NULL ) {
+		/* Dump script */
+		sieve_tool_dump_binary_to(main_sbin, dumpfile);
+
+		user = sieve_tool_get_user();
+		home = getenv("HOME");
+
+		/* Initialize mail storages */
+		mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+		mail_storage_init();
+		mail_storage_register_all();
+		mailbox_list_register_all();
+
+		/* Obtain mail namespaces from -l argument */
+		if ( mailloc != NULL ) {
+			env_put(t_strdup_printf("NAMESPACE_1=%s", mailloc));
+			env_put("NAMESPACE_1_INBOX=1");
+			env_put("NAMESPACE_1_LIST=1");
+			env_put("NAMESPACE_1_SEP=.");
+			env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+			mail_user = mail_user_init(user);
+			mail_user_set_home(mail_user, home);
+			if (mail_namespaces_init(mail_user) < 0)
+				i_fatal("Namespace initialization failed");
+
+			ns = mail_user->namespaces;
+		}
+
+		/* Initialize raw mail object */
+		mail_raw_init(user);
+		mailr = mail_raw_open_file(mailfile);
+
+		sieve_tool_get_envelope_data(mailr->mail, &recipient, &sender);
+
+		if ( mailbox == NULL )
+			mailbox = "INBOX";
+
+		/* Collect necessary message data */
+		memset(&msgdata, 0, sizeof(msgdata));
+		msgdata.mail = mailr->mail;
+		msgdata.return_path = sender;
+		msgdata.to_address = recipient;
+		msgdata.auth_user = user;
+		(void)mail_get_first_header(mailr->mail, "Message-ID", &msgdata.id);
+
+		/* Create stream for test and trace output */
+		if ( !execute || trace )
+			teststream = o_stream_create_fd(1, 0, FALSE);
+
+		/* Compose script environment */
+		memset(&scriptenv, 0, sizeof(scriptenv));
+		scriptenv.default_mailbox = "INBOX";
+		scriptenv.namespaces = ns;
+		scriptenv.username = user;
+		scriptenv.hostname = "host.example.com";
+		scriptenv.postmaster_address = "postmaster@example.com";
+		scriptenv.smtp_open = sieve_smtp_open;
+		scriptenv.smtp_close = sieve_smtp_close;
+		scriptenv.duplicate_mark = duplicate_mark;
+		scriptenv.duplicate_check = duplicate_check;
+		scriptenv.trace_stream = ( trace ? teststream : NULL );
+		scriptenv.exec_status = &estatus;
+
+		/* Run the test */
+		ret = 1;
+		if ( array_count(&scriptfiles) == 0 ) {
+			/* Single script */
+			sbin = main_sbin;
+			main_sbin = NULL;
+
+			/* Execute/Test script */
+			if ( execute )
+				ret = sieve_execute
+					(sbin, &msgdata, &scriptenv, ehandler, NULL);
+			else
+				ret = sieve_test
+					(sbin, &msgdata, &scriptenv, ehandler, teststream, NULL);
+		} else {
+			/* Multiple scripts */
+			const char *const *sfiles;
+			unsigned int i, count;
+			struct sieve_multiscript *mscript;
+			bool more = TRUE;
+			int result;
+
+			if ( execute )
+				mscript = sieve_multiscript_start_execute
+					(sieve_instance, &msgdata, &scriptenv);
+			else
+				mscript = sieve_multiscript_start_test
+					(sieve_instance, &msgdata, &scriptenv, teststream);
+
+			/* Execute scripts sequentially */
+			sfiles = array_get(&scriptfiles, &count);
+			for ( i = 0; i < count && more; i++ ) {
+				if ( teststream != NULL )
+					o_stream_send_str(teststream,
+						t_strdup_printf("\n## Executing script: %s\n", sfiles[i]));
+
+				/* Close previous script */
+				if ( sbin != NULL )
+					sieve_close(&sbin);
+
+				/* Compile sieve script */
+				if ( force_compile ) {
+					sbin = sieve_tool_script_compile(sfiles[i], sfiles[i]);
+					if ( sbin != NULL )
+						(void) sieve_save(sbin, NULL);
+				} else {
+					sbin = sieve_tool_script_open(sfiles[i]);
+				}
+
+				if ( sbin == NULL ) {
+					ret = SIEVE_EXEC_FAILURE;
+					break;
+				}
+
+				/* Execute/Test script */
+				more = sieve_multiscript_run(mscript, sbin, ehandler, FALSE);
+			}
+
+			/* Execute/Test main script */
+			if ( more && ret > 0 ) {
+				if ( teststream != NULL )
+					o_stream_send_str(teststream,
+						t_strdup_printf("## Executing script: %s\n", scriptfile));
+
+				/* Close previous script */
+				if ( sbin != NULL )
+					sieve_close(&sbin);
+
+				sbin = main_sbin;
+				main_sbin = NULL;
+
+				sieve_multiscript_run(mscript, sbin, ehandler, TRUE);
+			}
+
+			result = sieve_multiscript_finish(&mscript, ehandler, NULL);
+
+			ret = ret > 0 ? result : ret;
+		}
+
+		/* Run */
+		switch ( ret ) {
+		case SIEVE_EXEC_OK:
+			i_info("final result: success");
+			break;
+		case SIEVE_EXEC_BIN_CORRUPT:
+			i_info("corrupt binary deleted.");
+			(void) unlink(sieve_binary_path(sbin));
+		case SIEVE_EXEC_FAILURE:
+			i_info("final result: failed; resolved with successful implicit keep");
+			break;
+		case SIEVE_EXEC_KEEP_FAILED:
+			i_info("final result: utter failure");
+			break;
+		default:
+			i_info("final result: unrecognized return value?!");
+		}
+
+		if ( teststream != NULL )
+			o_stream_destroy(&teststream);
+
+		/* Cleanup remaining binaries */
+		if ( sbin != NULL )
+			sieve_close(&sbin);
+		if ( main_sbin != NULL )
+			sieve_close(&main_sbin);
+
+		/* De-initialize raw mail object */
+		mail_raw_close(mailr);
+		mail_raw_deinit();
+
+		/* De-initialize mail user object */
+		if ( mail_user != NULL )
+			mail_user_unref(&mail_user);
+
+		/* De-initialize mail storages */
+		mail_storage_deinit();
+		mail_users_deinit();
+	}
+
+	/* Cleanup error handler */
+	sieve_error_handler_unref(&ehandler);
+	sieve_system_ehandler_reset();
+
+	sieve_tool_deinit();
+
+	return 0;
+}
Index: b/sieve/src/sieve-tools/sievec.c
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/sievec.c
@@ -0,0 +1,153 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <dirent.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sievec [-d] [-x <extensions>] <script-file> [<out-file>]\n"
+	);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) {
+	int i;
+	struct stat st;
+	struct sieve_binary *sbin;
+	bool dump = FALSE;
+	const char *scriptfile, *outfile, *extensions;
+
+	sieve_tool_init(NULL);
+
+	scriptfile = outfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			dump = TRUE;
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( outfile == NULL ) {
+			outfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <script-file> argument");
+	}
+
+	if ( outfile == NULL && dump )
+		outfile = "-";
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(sieve_instance, extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(sieve_instance, &debug_extension, TRUE);
+
+	if ( stat(scriptfile, &st) == 0 && S_ISDIR(st.st_mode) ) {
+		/* Script directory */
+		DIR *dirp;
+		struct dirent *dp;
+
+		/* Sanity checks on some of the arguments */
+
+		if ( dump )
+			i_fatal("the -d option is not allowed when scriptfile is a directory.");
+
+		if ( outfile != NULL )
+			i_fatal("the outfile argument is not allowed when scriptfile is a "
+				"directory.");
+
+		/* Open the directory */
+		if ( (dirp = opendir(scriptfile)) == NULL )
+			i_fatal("opendir(%s) failed: %m", scriptfile);
+
+		/* Compile each sieve file */
+		for (;;) {
+
+			errno = 0;
+			if ( (dp = readdir(dirp)) == NULL ) {
+				if ( errno != 0 )
+					i_fatal("readdir(%s) failed: %m", scriptfile);
+				break;
+			}
+
+			if ( sieve_script_file_has_extension(dp->d_name) ) {
+				const char *file;
+
+				if ( scriptfile[strlen(scriptfile)-1] == '/' )
+					file = t_strconcat(scriptfile, dp->d_name, NULL);
+				else
+					file = t_strconcat(scriptfile, "/", dp->d_name, NULL);
+
+				sbin = sieve_tool_script_compile(file, dp->d_name);
+
+				if ( sbin != NULL ) {
+					sieve_save(sbin, NULL);
+
+					sieve_close(&sbin);
+				}
+			}
+		}
+
+		/* Close the directory */
+		if ( closedir(dirp) < 0 )
+			i_fatal("closedir(%s) failed: %m", scriptfile);
+
+	} else {
+		/* Script file (i.e. not a directory)
+		 *
+		 *   NOTE: For consistency, stat errors are handled here as well
+		 */
+		sbin = sieve_tool_script_compile(scriptfile, NULL);
+
+		if ( sbin != NULL ) {
+			if ( dump )
+				sieve_tool_dump_binary_to(sbin, outfile);
+			else {
+				sieve_save(sbin, outfile);
+			}
+
+			sieve_close(&sbin);
+		}
+	}
+
+	sieve_tool_deinit();
+}
Index: b/sieve/src/sieve-tools/sieved.c
===================================================================
--- /dev/null
+++ b/sieve/src/sieve-tools/sieved.c
@@ -0,0 +1,85 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieved [-x <extensions>] <sieve-binary> [<out-file>]\n"
+	);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) {
+	int i;
+	struct sieve_binary *sbin;
+	const char *binfile, *outfile, *extensions;
+
+	sieve_tool_init(NULL);
+
+	binfile = outfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if ( binfile == NULL ) {
+			binfile = argv[i];
+		} else if ( outfile == NULL ) {
+			outfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("unknown argument: %s", argv[i]);
+		}
+	}
+
+	if ( binfile == NULL ) {
+		print_help();
+		i_fatal("missing <sieve-binary> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(sieve_instance, extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(sieve_instance, &debug_extension, TRUE);
+
+	sbin = sieve_load(sieve_instance, binfile);
+
+	if ( sbin != NULL ) {
+		sieve_tool_dump_binary_to(sbin, outfile == NULL ? "-" : outfile);
+
+		sieve_close(&sbin);
+	} else
+		i_error("failed to load binary: %s", binfile);
+
+	sieve_tool_deinit();
+}
+
Index: b/sieve/src/testsuite/Makefile.am
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/Makefile.am
@@ -0,0 +1,77 @@
+noinst_PROGRAMS = testsuite
+
+AM_CPPFLAGS = \
+	-I../lib-sieve \
+	-I../lib-sieve-tool \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage
+
+testsuite_LDFLAGS = -export-dynamic
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	$(STORAGE_LIBS)
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+testsuite_LDADD = $(ldadd)
+testsuite_DEPENDENCIES = $(libs)
+
+commands = \
+	cmd-test.c \
+	cmd-test-fail.c \
+	cmd-test-set.c \
+	cmd-test-result-reset.c \
+	cmd-test-result-print.c \
+	cmd-test-message.c \
+	cmd-test-mailbox.c \
+	cmd-test-binary.c
+
+tests = \
+	tst-test-script-compile.c \
+	tst-test-script-run.c \
+	tst-test-multiscript.c \
+	tst-test-error.c \
+	tst-test-result.c \
+	tst-test-result-execute.c
+
+testsuite_SOURCES = \
+	testsuite-common.c \
+	testsuite-objects.c \
+	testsuite-substitutions.c \
+	testsuite-arguments.c \
+	testsuite-message.c \
+	testsuite-log.c \
+	testsuite-script.c \
+	testsuite-result.c \
+	testsuite-smtp.c \
+	testsuite-mailstore.c \
+	testsuite-binary.c \
+	testsuite-settings.c \
+	$(commands) \
+	$(tests) \
+	ext-testsuite.c \
+	testsuite.c
+
+noinst_HEADERS = \
+	testsuite-common.h \
+	testsuite-objects.h \
+	testsuite-substitutions.h \
+	testsuite-arguments.h \
+	testsuite-message.h \
+	testsuite-log.h \
+	testsuite-script.h \
+	testsuite-result.h \
+	testsuite-smtp.h \
+	testsuite-mailstore.h \
+	testsuite-binary.h \
+	testsuite-settings.h
+
Index: b/sieve/src/testsuite/Makefile.in
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/Makefile.in
@@ -0,0 +1,598 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+noinst_PROGRAMS = testsuite$(EXEEXT)
+subdir = src/testsuite
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dsieve-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+PROGRAMS = $(noinst_PROGRAMS)
+am__objects_1 = cmd-test.$(OBJEXT) cmd-test-fail.$(OBJEXT) \
+	cmd-test-set.$(OBJEXT) cmd-test-result-reset.$(OBJEXT) \
+	cmd-test-result-print.$(OBJEXT) cmd-test-message.$(OBJEXT) \
+	cmd-test-mailbox.$(OBJEXT) cmd-test-binary.$(OBJEXT)
+am__objects_2 = tst-test-script-compile.$(OBJEXT) \
+	tst-test-script-run.$(OBJEXT) tst-test-multiscript.$(OBJEXT) \
+	tst-test-error.$(OBJEXT) tst-test-result.$(OBJEXT) \
+	tst-test-result-execute.$(OBJEXT)
+am_testsuite_OBJECTS = testsuite-common.$(OBJEXT) \
+	testsuite-objects.$(OBJEXT) testsuite-substitutions.$(OBJEXT) \
+	testsuite-arguments.$(OBJEXT) testsuite-message.$(OBJEXT) \
+	testsuite-log.$(OBJEXT) testsuite-script.$(OBJEXT) \
+	testsuite-result.$(OBJEXT) testsuite-smtp.$(OBJEXT) \
+	testsuite-mailstore.$(OBJEXT) testsuite-binary.$(OBJEXT) \
+	testsuite-settings.$(OBJEXT) $(am__objects_1) $(am__objects_2) \
+	ext-testsuite.$(OBJEXT) testsuite.$(OBJEXT)
+testsuite_OBJECTS = $(am_testsuite_OBJECTS)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 = $(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	$(am__DEPENDENCIES_1)
+am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
+	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
+testsuite_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(testsuite_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(testsuite_SOURCES)
+DIST_SOURCES = $(testsuite_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AM_CPPFLAGS = \
+	-I../lib-sieve \
+	-I../lib-sieve-tool \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage
+
+testsuite_LDFLAGS = -export-dynamic
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	$(STORAGE_LIBS)
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+testsuite_LDADD = $(ldadd)
+testsuite_DEPENDENCIES = $(libs)
+commands = \
+	cmd-test.c \
+	cmd-test-fail.c \
+	cmd-test-set.c \
+	cmd-test-result-reset.c \
+	cmd-test-result-print.c \
+	cmd-test-message.c \
+	cmd-test-mailbox.c \
+	cmd-test-binary.c
+
+tests = \
+	tst-test-script-compile.c \
+	tst-test-script-run.c \
+	tst-test-multiscript.c \
+	tst-test-error.c \
+	tst-test-result.c \
+	tst-test-result-execute.c
+
+testsuite_SOURCES = \
+	testsuite-common.c \
+	testsuite-objects.c \
+	testsuite-substitutions.c \
+	testsuite-arguments.c \
+	testsuite-message.c \
+	testsuite-log.c \
+	testsuite-script.c \
+	testsuite-result.c \
+	testsuite-smtp.c \
+	testsuite-mailstore.c \
+	testsuite-binary.c \
+	testsuite-settings.c \
+	$(commands) \
+	$(tests) \
+	ext-testsuite.c \
+	testsuite.c
+
+noinst_HEADERS = \
+	testsuite-common.h \
+	testsuite-objects.h \
+	testsuite-substitutions.h \
+	testsuite-arguments.h \
+	testsuite-message.h \
+	testsuite-log.h \
+	testsuite-script.h \
+	testsuite-result.h \
+	testsuite-smtp.h \
+	testsuite-mailstore.h \
+	testsuite-binary.h \
+	testsuite-settings.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/testsuite/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign src/testsuite/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstPROGRAMS:
+	@list='$(noinst_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+testsuite$(EXEEXT): $(testsuite_OBJECTS) $(testsuite_DEPENDENCIES)
+	@rm -f testsuite$(EXEEXT)
+	$(testsuite_LINK) $(testsuite_OBJECTS) $(testsuite_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-binary.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-fail.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-mailbox.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-message.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-result-print.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-result-reset.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test-set.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-test.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ext-testsuite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-arguments.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-binary.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-common.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-log.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-mailstore.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-message.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-objects.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-result.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-script.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-settings.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-smtp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite-substitutions.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testsuite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-error.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-multiscript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-result-execute.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-result.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-script-compile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tst-test-script-run.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstPROGRAMS ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: b/sieve/src/testsuite/cmd-test-binary.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-binary.c
@@ -0,0 +1,272 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-binary.h"
+#include "testsuite-script.h"
+
+/*
+ * Test_binary command
+ *
+ * Syntax:
+ *   test_binary ( :load / :save ) <mailbox: string>
+ */
+
+static bool cmd_test_binary_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_test_binary_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_test_binary_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_test_binary = {
+	"test_binary",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	cmd_test_binary_registered,
+	NULL,
+	cmd_test_binary_validate,
+	cmd_test_binary_generate,
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+static bool cmd_test_binary_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_binary_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* test_binary_create operation */
+
+const struct sieve_operation_def test_binary_load_operation = {
+	"TEST_BINARY_LOAD",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_BINARY_LOAD,
+	cmd_test_binary_operation_dump,
+	cmd_test_binary_operation_execute
+};
+
+/* test_binary_delete operation */
+
+const struct sieve_operation_def test_binary_save_operation = {
+	"TEST_BINARY_SAVE",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_BINARY_SAVE,
+	cmd_test_binary_operation_dump,
+	cmd_test_binary_operation_execute
+};
+
+/*
+ * Compiler context data
+ */
+
+enum test_binary_operation {
+	BINARY_OP_LOAD,
+	BINARY_OP_SAVE,
+	BINARY_OP_LAST
+};
+
+const struct sieve_operation_def *test_binary_operations[] = {
+	&test_binary_load_operation,
+	&test_binary_save_operation
+};
+
+struct cmd_test_binary_context_data {
+	enum test_binary_operation binary_op;
+	const char *folder;
+};
+
+/*
+ * Command tags
+ */
+
+static bool cmd_test_binary_validate_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def test_binary_load_tag = {
+	"load",
+	NULL,
+	cmd_test_binary_validate_tag,
+	NULL, NULL, NULL,
+};
+
+static const struct sieve_argument_def test_binary_save_tag = {
+	"save",
+	NULL,
+	cmd_test_binary_validate_tag,
+	NULL, NULL, NULL,
+};
+
+static bool cmd_test_binary_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* Register our tags */
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &test_binary_load_tag, 0);
+	sieve_validator_register_tag(valdtr, cmd_reg, ext, &test_binary_save_tag, 0);
+
+	return TRUE;
+}
+
+static bool cmd_test_binary_validate_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_test_binary_context_data *ctx_data =
+		(struct cmd_test_binary_context_data *) cmd->data;
+
+	if ( ctx_data != NULL ) {
+		sieve_argument_validate_error
+			(valdtr, *arg, "exactly one of the ':load' or ':save' tags must be "
+				"specified for the test_binary command, but more were found");
+		return NULL;
+	}
+
+	ctx_data = p_new
+		(sieve_command_pool(cmd), struct cmd_test_binary_context_data, 1);
+	cmd->data = ctx_data;
+
+	if ( sieve_argument_is(*arg, test_binary_load_tag) )
+		ctx_data->binary_op = BINARY_OP_LOAD;
+	else
+		ctx_data->binary_op = BINARY_OP_SAVE;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool cmd_test_binary_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( cmd->data == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"the test_binary command requires either the :load or the :save tag "
+			"to be specified");
+		return FALSE;
+	}
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "binary-name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_test_binary_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct cmd_test_binary_context_data *ctx_data =
+		(struct cmd_test_binary_context_data *) cmd->data;
+
+	i_assert( ctx_data->binary_op < BINARY_OP_LAST );
+
+	/* Emit operation */
+	sieve_operation_emit(cgenv->sbin, cmd->ext,
+		test_binary_operations[ctx_data->binary_op]);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_test_binary_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &denv->oprtn;
+
+	sieve_code_dumpf(denv, "%s:", sieve_operation_mnemonic(op));
+
+	sieve_code_descend(denv);
+
+	return sieve_opr_string_dump(denv, address, "binary-name");
+}
+
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_binary_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &renv->oprtn;
+	string_t *binary_name = NULL;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Binary Name */
+
+	if ( !sieve_opr_string_read(renv, address, &binary_name) ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace
+		(renv, "%s %s:", sieve_operation_mnemonic(op), str_c(binary_name));
+
+	if ( sieve_operation_is(op, test_binary_load_operation) ) {
+		struct sieve_binary *sbin = testsuite_binary_load(str_c(binary_name));
+
+		if ( sbin != NULL ) {
+			testsuite_script_set_binary(sbin);
+
+			sieve_binary_unref(&sbin);
+		} else {
+			sieve_sys_error("failed to load binary %s", str_c(binary_name));
+			return SIEVE_EXEC_FAILURE;
+		}
+
+	} else if ( sieve_operation_is(op, test_binary_save_operation) ) {
+		struct sieve_binary *sbin = testsuite_script_get_binary();
+
+		if ( sbin != NULL )
+			testsuite_binary_save(sbin, str_c(binary_name));
+		else {
+			sieve_sys_error("no compiled binary to save as %s", str_c(binary_name));
+			return SIEVE_EXEC_FAILURE;
+		}
+	} else {
+		i_unreached();
+	}
+
+	return SIEVE_EXEC_OK;
+}
Index: b/sieve/src/testsuite/cmd-test-fail.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-fail.c
@@ -0,0 +1,148 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+
+/*
+ * Test_fail command
+ *
+ * Syntax:
+ *   test_fail <reason: string>
+ */
+
+static bool cmd_test_fail_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_test_fail_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_test_fail = {
+	"test_fail",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_test_fail_validate,
+	cmd_test_fail_generate,
+	NULL
+};
+
+/*
+ * Test operation
+ */
+
+static bool cmd_test_fail_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_fail_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_fail_operation = {
+	"TEST_FAIL",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_FAIL,
+	cmd_test_fail_operation_dump,
+	cmd_test_fail_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_test_fail_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static inline struct testsuite_generator_context *
+	_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *)
+		sieve_generator_extension_get_context(gentr, testsuite_ext);
+}
+
+static bool cmd_test_fail_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct testsuite_generator_context *genctx =
+		_get_generator_context(cgenv->gentr);
+
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &test_fail_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	sieve_jumplist_add(genctx->exit_jumps,
+		sieve_binary_emit_offset(cgenv->sbin, 0));
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_test_fail_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int pc;
+	int offset;
+
+	sieve_code_dumpf(denv, "TEST_FAIL:");
+	sieve_code_descend(denv);
+
+	if ( !sieve_opr_string_dump(denv, address, "reason") )
+		return FALSE;
+
+	sieve_code_mark(denv);
+	pc = *address;
+	if ( sieve_binary_read_offset(denv->sbin, address, &offset) )
+		sieve_code_dumpf(denv, "offset: %d [%08x]", offset, pc + offset);
+	else
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_fail_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *reason;
+
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "TEST FAIL");
+	testsuite_test_fail(reason);
+
+	return sieve_interpreter_program_jump(renv->interp, TRUE);
+}
+
+
+
+
Index: b/sieve/src/testsuite/cmd-test-mailbox.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-mailbox.c
@@ -0,0 +1,251 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-mailstore.h"
+
+/*
+ * Test_mailbox command
+ *
+ * Syntax:
+ *   test_mailbox ( :create / :delete ) <mailbox: string>
+ */
+
+static bool cmd_test_mailbox_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_test_mailbox_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_test_mailbox_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_test_mailbox = {
+	"test_mailbox",
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE,
+	cmd_test_mailbox_registered,
+	NULL,
+	cmd_test_mailbox_validate,
+	cmd_test_mailbox_generate,
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+static bool cmd_test_mailbox_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_mailbox_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Test_mailbox_create operation */
+
+const struct sieve_operation_def test_mailbox_create_operation = {
+	"TEST_MAILBOX_CREATE",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_MAILBOX_CREATE,
+	cmd_test_mailbox_operation_dump,
+	cmd_test_mailbox_operation_execute
+};
+
+/* Test_mailbox_delete operation */
+
+const struct sieve_operation_def test_mailbox_delete_operation = {
+	"TEST_MAILBOX_DELETE",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_MAILBOX_DELETE,
+	cmd_test_mailbox_operation_dump,
+	cmd_test_mailbox_operation_execute
+};
+
+/*
+ * Compiler context data
+ */
+
+enum test_mailbox_operation {
+	MAILBOX_OP_CREATE,
+	MAILBOX_OP_DELETE,
+	MAILBOX_OP_LAST
+};
+
+const struct sieve_operation_def *test_mailbox_operations[] = {
+	&test_mailbox_create_operation,
+	&test_mailbox_delete_operation
+};
+
+struct cmd_test_mailbox_context_data {
+	enum test_mailbox_operation mailbox_op;
+	const char *folder;
+};
+
+/*
+ * Command tags
+ */
+
+static bool cmd_test_mailbox_validate_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def test_mailbox_create_tag = {
+	"create",
+	NULL,
+	cmd_test_mailbox_validate_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def test_mailbox_delete_tag = {
+	"delete",
+	NULL,
+	cmd_test_mailbox_validate_tag,
+	NULL, NULL, NULL
+};
+
+static bool cmd_test_mailbox_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* Register our tags */
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &test_mailbox_create_tag, 0);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &test_mailbox_delete_tag, 0);
+
+	return TRUE;
+}
+
+static bool cmd_test_mailbox_validate_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_test_mailbox_context_data *ctx_data =
+		(struct cmd_test_mailbox_context_data *) cmd->data;
+
+	if ( ctx_data != NULL ) {
+		sieve_argument_validate_error
+			(valdtr, *arg, "exactly one of the ':create' or ':delete' tags must be "
+				"specified for the test_mailbox command, but more were found");
+		return NULL;
+	}
+
+	ctx_data = p_new
+		(sieve_command_pool(cmd), struct cmd_test_mailbox_context_data, 1);
+	cmd->data = ctx_data;
+
+	if ( sieve_argument_is(*arg, test_mailbox_create_tag) )
+		ctx_data->mailbox_op = MAILBOX_OP_CREATE;
+	else
+		ctx_data->mailbox_op = MAILBOX_OP_DELETE;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool cmd_test_mailbox_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( cmd->data == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"the test_mailbox command requires either the :create or the :delete tag "
+			"to be specified");
+		return FALSE;
+	}
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "mailbox", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_test_mailbox_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct cmd_test_mailbox_context_data *ctx_data =
+		(struct cmd_test_mailbox_context_data *) cmd->data;
+
+	i_assert( ctx_data->mailbox_op < MAILBOX_OP_LAST );
+
+	/* Emit operation */
+	sieve_operation_emit(cgenv->sbin, cmd->ext,
+		test_mailbox_operations[ctx_data->mailbox_op]);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_test_mailbox_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &denv->oprtn;
+
+	sieve_code_dumpf(denv, "%s:", sieve_operation_mnemonic(op));
+
+	sieve_code_descend(denv);
+
+	return sieve_opr_string_dump(denv, address, "mailbox");
+}
+
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_mailbox_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operation *op = &renv->oprtn;
+	string_t *mailbox = NULL;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Index */
+
+	if ( !sieve_opr_string_read(renv, address, &mailbox) ) {
+		sieve_runtime_trace_error(renv, "invalid mailbox operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace
+		(renv, "%s %s:", sieve_operation_mnemonic(op), str_c(mailbox));
+
+	if ( sieve_operation_is(op, test_mailbox_create_operation) )
+		testsuite_mailstore_mailbox_create(renv, str_c(mailbox));
+
+	return SIEVE_EXEC_OK;
+}
Index: b/sieve/src/testsuite/cmd-test-message.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-message.c
@@ -0,0 +1,397 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-smtp.h"
+#include "testsuite-mailstore.h"
+
+/*
+ * Test_message command
+ *
+ * Syntax:
+ *   test_message ( :smtp / :mailbox <mailbox: string> ) <index: number>
+ */
+
+static bool cmd_test_message_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_test_message_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_test_message_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def cmd_test_message = {
+	"test_message",
+	SCT_HYBRID,
+	1, 0, FALSE, FALSE,
+	cmd_test_message_registered,
+	NULL,
+	cmd_test_message_validate,
+	cmd_test_message_generate,
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+/* Test_message_smtp operation */
+
+static bool cmd_test_message_smtp_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_message_smtp_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_message_smtp_operation = {
+	"TEST_MESSAGE_SMTP",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_MESSAGE_SMTP,
+	cmd_test_message_smtp_operation_dump,
+	cmd_test_message_smtp_operation_execute
+};
+
+/* Test_message_mailbox operation */
+
+static bool cmd_test_message_mailbox_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_message_mailbox_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_message_mailbox_operation = {
+	"TEST_MESSAGE_MAILBOX",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_MESSAGE_MAILBOX,
+	cmd_test_message_mailbox_operation_dump,
+	cmd_test_message_mailbox_operation_execute
+};
+
+/*
+ * Compiler context data
+ */
+
+enum test_message_source {
+	MSG_SOURCE_SMTP,
+	MSG_SOURCE_MAILBOX,
+	MSG_SOURCE_LAST
+};
+
+const struct sieve_operation_def *test_message_operations[] = {
+	&test_message_smtp_operation,
+	&test_message_mailbox_operation
+};
+
+struct cmd_test_message_context_data {
+	enum test_message_source msg_source;
+	const char *folder;
+};
+
+#define CMD_TEST_MESSAGE_ERROR_DUP_TAG \
+	"exactly one of the ':smtp' or ':folder' tags must be specified " \
+	"for the test_message command, but more were found"
+
+/*
+ * Command tags
+ */
+
+static bool cmd_test_message_validate_smtp_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+static bool cmd_test_message_validate_folder_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def test_message_smtp_tag = {
+	"smtp",
+	NULL,
+	cmd_test_message_validate_smtp_tag,
+	NULL, NULL, NULL
+};
+
+static const struct sieve_argument_def test_message_folder_tag = {
+	"folder",
+	NULL,
+	cmd_test_message_validate_folder_tag,
+	NULL, NULL, NULL
+};
+
+static bool cmd_test_message_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* Register our tags */
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &test_message_folder_tag, 0);
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &test_message_smtp_tag, 0);
+
+	return TRUE;
+}
+
+static struct cmd_test_message_context_data *cmd_test_message_validate_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_test_message_context_data *ctx_data =
+		(struct cmd_test_message_context_data *) cmd->data;
+
+	if ( ctx_data != NULL ) {
+		sieve_argument_validate_error
+			(valdtr, *arg, CMD_TEST_MESSAGE_ERROR_DUP_TAG);
+		return NULL;
+	}
+
+	ctx_data = p_new
+		(sieve_command_pool(cmd), struct cmd_test_message_context_data, 1);
+	cmd->data = ctx_data;
+
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return ctx_data;
+}
+
+static bool cmd_test_message_validate_smtp_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct cmd_test_message_context_data *ctx_data =
+		cmd_test_message_validate_tag(valdtr, arg, cmd);
+
+	/* Return value is NULL on error */
+	if ( ctx_data == NULL ) return FALSE;
+
+	/* Assign chosen message source */
+	ctx_data->msg_source = MSG_SOURCE_SMTP;
+
+	return TRUE;
+}
+
+static bool cmd_test_message_validate_folder_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_test_message_context_data *ctx_data =
+		cmd_test_message_validate_tag(valdtr, arg, cmd);
+
+	/* Return value is NULL on error */
+	if ( ctx_data == NULL ) return FALSE;
+
+	/* Assign chose message source */
+	ctx_data->msg_source = MSG_SOURCE_MAILBOX;
+
+	/* Check syntax:
+	 *   :folder string
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool cmd_test_message_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	if ( cmd->data == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"the test_message command requires either the :smtp or the :mailbox tag "
+			"to be specified");
+		return FALSE;
+	}
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "index", 1, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_test_message_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct cmd_test_message_context_data *ctx_data =
+		(struct cmd_test_message_context_data *) cmd->data;
+
+	i_assert( ctx_data->msg_source < MSG_SOURCE_LAST );
+
+	/* Emit operation */
+	sieve_operation_emit(cgenv->sbin, cmd->ext,
+		test_message_operations[ctx_data->msg_source]);
+
+	/* Emit is_test flag */
+	sieve_binary_emit_byte(cgenv->sbin, ( cmd->ast_node->type == SAT_TEST ));
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_test_message_smtp_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int is_test;
+
+	if ( !sieve_binary_read_byte(denv->sbin, address, &is_test) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "TEST_MESSAGE_SMTP (%s):",
+		( is_test ? "TEST" : "COMMAND" ));
+
+	sieve_code_descend(denv);
+
+	return sieve_opr_number_dump(denv, address, "index");
+}
+
+static bool cmd_test_message_mailbox_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int is_test;
+
+	if ( !sieve_binary_read_byte(denv->sbin, address, &is_test) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "TEST_MESSAGE_MAILBOX (%s):",
+		( is_test ? "TEST" : "COMMAND" ));
+
+	sieve_code_descend(denv);
+
+	return
+		sieve_opr_string_dump(denv, address, "folder") &&
+		sieve_opr_number_dump(denv, address, "index");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_message_smtp_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	sieve_number_t msg_index;
+	unsigned int is_test = -1;
+	bool result;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Is test */
+
+	if ( !sieve_binary_read_byte(renv->sbin, address, &is_test) ) {
+		sieve_runtime_trace_error(renv, "invalid is_test flag");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Index */
+
+	if ( !sieve_opr_number_read(renv, address, &msg_index) ) {
+		sieve_runtime_trace_error(renv, "invalid index operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST_MESSAGE_SMTP (%s) [%d]",
+		( is_test ? "TEST" : "COMMAND" ), msg_index);
+
+	result = testsuite_smtp_get(renv, msg_index);
+
+	if ( is_test ) {
+		sieve_interpreter_set_test_result(renv->interp, result);
+		return SIEVE_EXEC_OK;
+	}
+
+	if ( !result )
+		testsuite_test_failf("no outgoing SMTP message with index %d", msg_index);
+
+	return SIEVE_EXEC_OK;
+}
+
+static int cmd_test_message_mailbox_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *folder;
+	sieve_number_t msg_index;
+	unsigned int is_test = -1;
+	bool result;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Is test */
+	if ( !sieve_binary_read_byte(renv->sbin, address, &is_test) ) {
+		sieve_runtime_trace_error(renv, "invalid is_test flag");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Folder */
+	if ( !sieve_opr_string_read(renv, address, &folder) ) {
+		sieve_runtime_trace_error(renv, "invalid folder operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Index */
+	if ( !sieve_opr_number_read(renv, address, &msg_index) ) {
+		sieve_runtime_trace_error(renv, "invalid index operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST_MESSAGE_MAILBOX (%s) \"%s\" [%d]",
+		( is_test ? "TEST" : "COMMAND" ), str_c(folder), msg_index);
+
+	result = testsuite_mailstore_mail_index(renv, str_c(folder), msg_index);
+
+	if ( is_test ) {
+		sieve_interpreter_set_test_result(renv->interp, result);
+		return SIEVE_EXEC_OK;
+	}
+
+	if ( !result )
+		testsuite_test_failf("no message in folder '%s' with index %d",
+			str_c(folder), msg_index);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
+
Index: b/sieve/src/testsuite/cmd-test-result-print.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-result-print.c
@@ -0,0 +1,78 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+
+/*
+ * Test_result_execute command
+ *
+ * Syntax:
+ *   test_result_execute
+ */
+
+static bool cmd_test_result_print_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_test_result_print = {
+	"test_result_print",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_test_result_print_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static int cmd_test_result_print_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_result_print_operation = {
+	"TEST_RESULT_PRINT",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_RESULT_PRINT,
+	NULL,
+	cmd_test_result_print_operation_execute
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_test_result_print_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &test_result_print_operation);
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_result_print_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	testsuite_result_print(renv);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
Index: b/sieve/src/testsuite/cmd-test-result-reset.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-result-reset.c
@@ -0,0 +1,80 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+#include "testsuite-smtp.h"
+
+/*
+ * Test_result_execute command
+ *
+ * Syntax:
+ *   test_result_execute
+ */
+
+static bool cmd_test_result_reset_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_test_result_reset = {
+	"test_result_reset",
+	SCT_COMMAND,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	cmd_test_result_reset_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static int cmd_test_result_reset_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_result_reset_operation = {
+	"TEST_RESULT_RESET",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_RESULT_RESET,
+	NULL,
+	cmd_test_result_reset_operation_execute
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_test_result_reset_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_result_reset_operation);
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_result_reset_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	testsuite_result_reset(renv);
+	testsuite_smtp_reset();
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
Index: b/sieve/src/testsuite/cmd-test-set.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test-set.c
@@ -0,0 +1,156 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "istream-header-filter.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-objects.h"
+
+#include <stdio.h>
+
+/*
+ * Test_set command
+ *
+ * Syntax
+ *   test_set <testsuite object (member): string> <value: string>
+ */
+
+static bool cmd_test_set_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_test_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def cmd_test_set = {
+	"test_set",
+	SCT_COMMAND,
+	2, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_test_set_validate,
+	cmd_test_set_generate,
+	NULL
+};
+
+/*
+ * Test_set operation
+ */
+
+static bool cmd_test_set_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_set_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_set_operation = {
+	"TEST_SET",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_SET,
+	cmd_test_set_operation_dump,
+	cmd_test_set_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_test_set_validate
+(struct sieve_validator *valdtr, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	/* Check arguments */
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "object", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !testsuite_object_argument_activate(valdtr, arg, cmd) )
+		return FALSE;
+
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "value", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_test_set_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &test_set_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, cmd, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_test_set_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST SET:");
+	sieve_code_descend(denv);
+
+	return
+		testsuite_object_dump(denv, address) &&
+		sieve_opr_string_dump(denv, address, "value");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_set_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct testsuite_object tobj;
+	string_t *value;
+	int member_id;
+
+	if ( !testsuite_object_read_member
+		(renv->sbin, address, &tobj, &member_id) ) {
+		sieve_runtime_trace_error(renv, "invalid testsuite object member");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( !sieve_opr_string_read(renv, address, &value) ) {
+		sieve_runtime_trace_error(renv, "invalid string operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "TEST SET command (%s = \"%s\")",
+		testsuite_object_member_name(&tobj, member_id), str_c(value));
+
+	if ( tobj.def == NULL || tobj.def->set_member == NULL ) {
+		sieve_runtime_trace_error(renv, "unimplemented testsuite object");
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	tobj.def->set_member(renv, member_id, value);
+	return SIEVE_EXEC_OK;
+}
+
+
+
Index: b/sieve/src/testsuite/cmd-test.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/cmd-test.c
@@ -0,0 +1,179 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+
+/*
+ * Test command
+ *
+ * Syntax:
+ *   test <test-name: string> <block>
+ */
+
+static bool cmd_test_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool cmd_test_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *md);
+
+const struct sieve_command_def cmd_test = {
+	"test",
+	SCT_COMMAND,
+	1, 0, TRUE, TRUE,
+	NULL, NULL,
+	cmd_test_validate,
+	cmd_test_generate,
+	NULL
+};
+
+/*
+ * Test operations
+ */
+
+/* Test operation */
+
+static bool cmd_test_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_test_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_operation = {
+	"TEST",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST,
+	cmd_test_operation_dump,
+	cmd_test_operation_execute
+};
+
+/* Test_finish operation */
+
+static int cmd_test_finish_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_finish_operation = {
+	"TEST-FINISH",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_FINISH,
+	NULL,
+	cmd_test_finish_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_test_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+ 	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) )
+	{
+		sieve_command_validate_error(valdtr, cmd,
+			"tests cannot be nested: test command must be issued at top-level");
+		return FALSE;
+	}
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "test-name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static inline struct testsuite_generator_context *
+_get_generator_context(struct sieve_generator *gentr)
+{
+	return (struct testsuite_generator_context *)
+		sieve_generator_extension_get_context(gentr, testsuite_ext);
+}
+
+static bool cmd_test_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd)
+{
+	struct testsuite_generator_context *genctx =
+		_get_generator_context(cgenv->gentr);
+
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &test_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, cmd, NULL) )
+		return FALSE;
+
+	/* Prepare jumplist */
+	sieve_jumplist_reset(genctx->exit_jumps);
+
+	/* Test body */
+	if ( !sieve_generate_block(cgenv, cmd->ast_node) )
+		return FALSE;
+
+	sieve_operation_emit(cgenv->sbin, cmd->ext, &test_finish_operation);
+
+	/* Resolve exit jumps to this point */
+	sieve_jumplist_resolve(genctx->exit_jumps);
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+static bool cmd_test_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST:");
+	sieve_code_descend(denv);
+
+	return
+		sieve_opr_string_dump(denv, address, "test name");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_test_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *test_name;
+
+	if ( !sieve_opr_string_read(renv, address, &test_name) ) {
+		sieve_runtime_trace_error(renv, "invalid test name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "TEST \"%s\"", str_c(test_name));
+
+	testsuite_test_start(test_name);
+	return SIEVE_EXEC_OK;
+}
+
+static int cmd_test_finish_operation_execute
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_runtime_trace(renv, "TEST FINISHED");
+
+	testsuite_test_succeed(NULL);
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
+
Index: b/sieve/src/testsuite/ext-testsuite.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/ext-testsuite.c
@@ -0,0 +1,152 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension testsuite
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: vendor-specific
+ *   (FIXME: provide specification for test authors)
+ * Implementation: very basic
+ * Status: under development
+ * Purpose: This custom extension is used to add sieve commands and tests that
+ *          act the Sieve engine and on the test suite itself. This practically
+ *          provides the means to completely control and thereby test the Sieve
+ *          compiler and interpreter. This extension transforms the basic Sieve
+ *          language into something much more powerful and suitable to perform
+ *          complex self-test operations. Of course, this extension is only
+ *          available (as vnd.dovecot.testsuite) when the sieve engine is used
+ *          from within the testsuite commandline tool. Test scripts have the
+ *          extension .svtest by convention to distinguish them from any normal
+ *          sieve scripts that may reside in the same directory.
+ *
+ * WARNING: Although this code can serve as an example on how to write
+ *          extensions to the Sieve interpreter, it is generally _NOT_ to be
+ *          used as a source for ideas on new Sieve extensions. Many of the
+ *          commands and tests that this extension introduces conflict with the
+ *          goal and the implied restrictions of the Sieve language. These
+ *          restrictions were put in  place with good reason. Therefore, do
+ *          _NOT_ export functionality provided by this testsuite extension to
+ *          your custom extensions that are to be put to general use.
+ *
+ *          Thank you.
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-arguments.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation_def *testsuite_operations[] = {
+	&test_operation,
+	&test_finish_operation,
+	&test_fail_operation,
+	&test_set_operation,
+	&test_script_compile_operation,
+	&test_script_run_operation,
+	&test_multiscript_operation,
+	&test_error_operation,
+	&test_result_operation,
+	&test_result_execute_operation,
+	&test_result_reset_operation,
+	&test_result_print_operation,
+	&test_message_smtp_operation,
+	&test_message_mailbox_operation,
+	&test_mailbox_create_operation,
+	&test_mailbox_delete_operation,
+	&test_binary_load_operation,
+	&test_binary_save_operation
+};
+
+/*
+ * Operands
+ */
+
+const struct sieve_operand_def *testsuite_operands[] = {
+	&testsuite_object_operand,
+	&testsuite_substitution_operand
+};
+
+/*
+ * Extension
+ */
+
+/* Forward declarations */
+
+static bool ext_testsuite_validator_load
+	(const struct sieve_extension *ext, struct sieve_validator *valdtr);
+static bool ext_testsuite_generator_load
+	(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv);
+static bool ext_testsuite_binary_load
+	(const struct sieve_extension *ext, struct sieve_binary *sbin);
+
+/* Extension object */
+
+const struct sieve_extension_def testsuite_extension = {
+	"vnd.dovecot.testsuite",
+	NULL, NULL,
+	ext_testsuite_validator_load,
+	ext_testsuite_generator_load,
+	NULL,
+	ext_testsuite_binary_load,
+	NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(testsuite_operations),
+	SIEVE_EXT_DEFINE_OPERANDS(testsuite_operands)
+};
+
+/* Extension implementation */
+
+static bool ext_testsuite_validator_load
+(const struct sieve_extension *ext, struct sieve_validator *valdtr)
+{
+	sieve_validator_register_command(valdtr, ext, &cmd_test);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_fail);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_set);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_result_print);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_result_reset);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_message);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_mailbox);
+	sieve_validator_register_command(valdtr, ext, &cmd_test_binary);
+
+	sieve_validator_register_command(valdtr, ext, &tst_test_script_compile);
+	sieve_validator_register_command(valdtr, ext, &tst_test_script_run);
+	sieve_validator_register_command(valdtr, ext, &tst_test_multiscript);
+	sieve_validator_register_command(valdtr, ext, &tst_test_error);
+	sieve_validator_register_command(valdtr, ext, &tst_test_result);
+	sieve_validator_register_command(valdtr, ext, &tst_test_result_execute);
+
+/*	sieve_validator_argument_override(valdtr, SAT_VAR_STRING, ext,
+		&testsuite_string_argument);*/
+
+	return testsuite_validator_context_initialize(valdtr);
+}
+
+static bool ext_testsuite_generator_load
+(const struct sieve_extension *ext, const struct sieve_codegen_env *cgenv)
+{
+	return testsuite_generator_context_initialize(cgenv->gentr, ext);
+}
+
+static bool ext_testsuite_binary_load
+(const struct sieve_extension *ext ATTR_UNUSED,
+	struct sieve_binary *sbin ATTR_UNUSED)
+{
+	return TRUE;
+}
+
+
+
Index: b/sieve/src/testsuite/testsuite-arguments.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-arguments.c
@@ -0,0 +1,192 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-substitutions.h"
+#include "testsuite-arguments.h"
+
+#include <ctype.h>
+
+/*
+ * Testsuite string argument
+ */
+
+static bool arg_testsuite_string_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command *context);
+
+const struct sieve_argument_def testsuite_string_argument = {
+	"@testsuite-string",
+	NULL,
+	arg_testsuite_string_validate,
+	NULL, NULL,
+	sieve_arg_catenated_string_generate,
+};
+
+static bool arg_testsuite_string_validate
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	enum { ST_NONE, ST_OPEN, ST_SUBSTITUTION, ST_PARAM, ST_CLOSE } state =
+		ST_NONE;
+	pool_t pool = sieve_ast_pool((*arg)->ast);
+	struct sieve_arg_catenated_string *catstr = NULL;
+	string_t *str = sieve_ast_argument_str(*arg);
+	const char *p, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	bool result = TRUE;
+	string_t *subs_name = t_str_new(256);
+	string_t *subs_param = t_str_new(256);
+
+	T_BEGIN {
+		/* Initialize substitution structure */
+
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+
+			/* Nothing found yet */
+			case ST_NONE:
+				if ( *p == '%' ) {
+					substart = p;
+					state = ST_OPEN;
+					str_truncate(subs_name, 0);
+					str_truncate(subs_param, 0);
+				}
+				p++;
+				break;
+
+			/* Got '%' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_SUBSTITUTION;
+					p++;
+				} else
+					state = ST_NONE;
+				break;
+
+			/* Got '%{' */
+			case ST_SUBSTITUTION:
+				state = ST_PARAM;
+
+				while ( *p != '}' && *p != ':' ) {
+					if ( !i_isalnum(*p) ) {
+						state = ST_NONE;
+						break;
+					}
+					str_append_c(subs_name, *p);
+					p++;
+				}
+				break;
+
+			/* Got '%{name' */
+			case ST_PARAM:
+				if ( *p == ':' ) {
+					p++;
+					while ( *p != '}' ) {
+						str_append_c(subs_param, *p);
+						p++;
+					}
+				}
+				state = ST_CLOSE;
+				break;
+
+			/* Finished parsing param, expecting '}' */
+			case ST_CLOSE:
+				if ( *p == '}' ) {
+					struct sieve_ast_argument *strarg;
+
+					/* We now know that the substitution is valid */
+
+					if ( catstr == NULL ) {
+						catstr = sieve_arg_catenated_string_create(*arg);
+					}
+
+					/* Add the substring that is before the substitution to the
+					 * variable-string AST.
+					 */
+					if ( substart > strstart ) {
+						string_t *newstr = str_new(pool, substart - strstart);
+						str_append_n(newstr, strstart, substart - strstart);
+
+						strarg = sieve_ast_argument_string_create_raw
+							((*arg)->ast, newstr, (*arg)->source_line);
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+
+						/* Give other substitution extensions a chance to do their work */
+						if ( !sieve_validator_argument_activate_super
+							(valdtr, cmd, strarg, FALSE) ) {
+							result = FALSE;
+							break;
+						}
+					}
+
+					strarg = testsuite_substitution_argument_create
+						(valdtr, (*arg)->ast, (*arg)->source_line, str_c(subs_name),
+							str_c(subs_param));
+
+					if ( strarg != NULL )
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+					else {
+						sieve_argument_validate_error(valdtr, *arg,
+							"unknown testsuite substitution type '%s'", str_c(subs_name));
+					}
+
+					strstart = p + 1;
+					substart = strstart;
+
+					p++;
+				}
+
+				/* Finished, reset for the next substitution */
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	/* Bail out early if substitution is invalid */
+	if ( !result ) return FALSE;
+
+	/* Check whether any substitutions were found */
+	if ( catstr == NULL ) {
+		/* No substitutions in this string, pass it on to any other substution
+		 * extension.
+		 */
+		return sieve_validator_argument_activate_super(valdtr, cmd, *arg, TRUE);
+	}
+
+	/* Add the final substring that comes after the last substitution to the
+	 * variable-string AST.
+	 */
+	if ( strend > strstart ) {
+		struct sieve_ast_argument *strarg;
+		string_t *newstr = str_new(pool, strend - strstart);
+		str_append_n(newstr, strstart, strend - strstart);
+
+		strarg = sieve_ast_argument_string_create_raw
+			((*arg)->ast, newstr, (*arg)->source_line);
+		sieve_arg_catenated_string_add_element(catstr, strarg);
+
+		/* Give other substitution extensions a chance to do their work */
+		if ( !sieve_validator_argument_activate_super
+			(valdtr, cmd, strarg, FALSE) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
Index: b/sieve/src/testsuite/testsuite-arguments.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-arguments.h
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_ARGUMENTS_H
+#define __TESTSUITE_ARGUMENTS_H
+
+extern const struct sieve_argument_def testsuite_string_argument;
+
+#endif
Index: b/sieve/src/testsuite/testsuite-binary.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-binary.c
@@ -0,0 +1,75 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "imem.h"
+#include "array.h"
+#include "strfuncs.h"
+#include "unlink-directory.h"
+
+#include "sieve.h"
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+#include "testsuite-common.h"
+#include "testsuite-binary.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/*
+ * State
+ */
+
+static char *testsuite_binary_tmp = NULL;
+
+/*
+ * Initialization
+ */
+
+void testsuite_binary_init(void)
+{
+	testsuite_binary_tmp = i_strconcat
+		(testsuite_tmp_dir_get(), "/binaries", NULL);
+
+	if ( mkdir(testsuite_binary_tmp, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.",
+			testsuite_binary_tmp);
+	}
+}
+
+void testsuite_binary_deinit(void)
+{
+	if ( unlink_directory(testsuite_binary_tmp, TRUE) < 0 ) {
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_binary_tmp);
+	}
+
+	i_free(testsuite_binary_tmp);
+}
+
+void testsuite_binary_reset(void)
+{
+	testsuite_binary_init();
+	testsuite_binary_deinit();
+}
+
+/*
+ * Binary Access
+ */
+
+bool testsuite_binary_save(struct sieve_binary *sbin, const char *name)
+{
+	return sieve_save
+    (sbin, t_strdup_printf("%s/%s.svbin", testsuite_binary_tmp, name));
+}
+
+struct sieve_binary *testsuite_binary_load(const char *name)
+{
+	return sieve_load(sieve_instance,
+		t_strdup_printf("%s/%s.svbin", testsuite_binary_tmp, name));
+}
+
+
+
Index: b/sieve/src/testsuite/testsuite-binary.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-binary.h
@@ -0,0 +1,20 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_BINARY_H
+#define __TESTSUITE_BINARY_H
+
+#include "sieve-common.h"
+
+void testsuite_binary_init(void);
+void testsuite_binary_deinit(void);
+void testsuite_binary_reset(void);
+
+/*
+ * Binary Access
+ */
+
+bool testsuite_binary_save(struct sieve_binary *sbin, const char *name);
+struct sieve_binary *testsuite_binary_load(const char *name);
+
+#endif /* __TESTSUITE_BINARY_H */
Index: b/sieve/src/testsuite/testsuite-common.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-common.c
@@ -0,0 +1,259 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "string.h"
+#include "ostream.h"
+#include "hash.h"
+#include "mail-storage.h"
+#include "env-util.h"
+#include "unlink-directory.h"
+
+#include "mail-raw.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-message.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-settings.h"
+#include "testsuite-objects.h"
+#include "testsuite-log.h"
+#include "testsuite-script.h"
+#include "testsuite-binary.h"
+#include "testsuite-result.h"
+#include "testsuite-smtp.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/*
+ * Global data
+ */
+
+/* Test context */
+
+static string_t *test_name;
+unsigned int test_index;
+unsigned int test_failures;
+
+/* Extension */
+
+const struct sieve_extension *testsuite_ext;
+
+/*
+ * Validator context
+ */
+
+bool testsuite_validator_context_initialize(struct sieve_validator *valdtr)
+{
+	pool_t pool = sieve_validator_pool(valdtr);
+	struct testsuite_validator_context *ctx =
+		p_new(pool, struct testsuite_validator_context, 1);
+
+	/* Setup object registry */
+	ctx->object_registrations = sieve_validator_object_registry_create(valdtr);
+	testsuite_register_core_objects(ctx);
+
+	sieve_validator_extension_set_context(valdtr, testsuite_ext, ctx);
+
+	return TRUE;
+}
+
+struct testsuite_validator_context *testsuite_validator_context_get
+(struct sieve_validator *valdtr)
+{
+	return (struct testsuite_validator_context *)
+		sieve_validator_extension_get_context(valdtr, testsuite_ext);
+}
+
+/*
+ * Generator context
+ */
+
+bool testsuite_generator_context_initialize
+(struct sieve_generator *gentr, const struct sieve_extension *this_ext)
+{
+	pool_t pool = sieve_generator_pool(gentr);
+	struct sieve_binary *sbin = sieve_generator_get_binary(gentr);
+	struct testsuite_generator_context *ctx =
+		p_new(pool, struct testsuite_generator_context, 1);
+
+	/* Setup exit jumplist */
+	ctx->exit_jumps = sieve_jumplist_create(pool, sbin);
+
+	sieve_generator_extension_set_context(gentr, this_ext, ctx);
+
+	return TRUE;
+}
+
+/*
+ * Test context
+ */
+
+static void testsuite_test_context_init(void)
+{
+	test_name = str_new(default_pool, 128);
+	test_index = 0;
+	test_failures = 0;
+}
+
+void testsuite_test_start(string_t *name)
+{
+	str_truncate(test_name, 0);
+	str_append_str(test_name, name);
+
+	test_index++;
+}
+
+void testsuite_test_fail(string_t *reason)
+{
+	testsuite_test_fail_cstr(str_c(reason));
+}
+
+void testsuite_test_failf(const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	testsuite_test_fail_cstr(t_strdup_vprintf(fmt, args));
+
+	va_end(args);
+}
+
+void testsuite_test_fail_cstr(const char *reason)
+{
+	if ( str_len(test_name) == 0 ) {
+		if ( reason == NULL || *reason == '\0' )
+			printf("%2d: Test FAILED\n", test_index);
+		else
+			printf("%2d: Test FAILED: %s\n", test_index, reason);
+	} else {
+		if ( reason == NULL || *reason == '\0' )
+			printf("%2d: Test '%s' FAILED\n", test_index, str_c(test_name));
+		else
+			printf("%2d: Test '%s' FAILED: %s\n", test_index,
+				str_c(test_name), reason);
+	}
+
+	str_truncate(test_name, 0);
+
+	test_failures++;
+}
+
+void testsuite_testcase_fail(const char *reason)
+{
+	if ( reason == NULL || *reason == '\0' )
+		printf("XX: Test CASE FAILED\n");
+	else
+		printf("XX: Test CASE FAILED: %s\n", reason);
+
+	test_failures++;
+}
+
+void testsuite_test_succeed(string_t *reason)
+{
+	if ( str_len(test_name) == 0 ) {
+		if ( reason == NULL || str_len(reason) == 0 )
+			printf("%2d: Test SUCCEEDED\n", test_index);
+		else
+			printf("%2d: Test SUCCEEDED: %s\n", test_index, str_c(reason));
+	} else {
+		if ( reason == NULL || str_len(reason) == 0 )
+			printf("%2d: Test '%s' SUCCEEDED\n", test_index, str_c(test_name));
+		else
+			printf("%2d: Test '%s' SUCCEEDED: %s\n", test_index,
+				str_c(test_name), str_c(reason));
+	}
+	str_truncate(test_name, 0);
+}
+
+static void testsuite_test_context_deinit(void)
+{
+	str_free(&test_name);
+}
+
+int testsuite_testcase_result(void)
+{
+	if ( test_failures > 0 ) {
+		printf("\nFAIL: %d of %d tests failed.\n\n", test_failures, test_index);
+		return 1;
+	}
+
+	printf("\nPASS: %d tests succeeded.\n\n", test_index);
+	return 0;
+}
+
+/*
+ * Testsuite temporary directory
+ */
+
+static char *testsuite_tmp_dir;
+
+static void testsuite_tmp_dir_init(void)
+{
+	testsuite_tmp_dir = i_strdup_printf
+		("/tmp/dsieve-testsuite.%s.%s", dec2str(time(NULL)), dec2str(getpid()));
+
+	if ( mkdir(testsuite_tmp_dir, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.",
+			testsuite_tmp_dir);
+	}
+}
+
+static void testsuite_tmp_dir_deinit(void)
+{
+	if ( unlink_directory(testsuite_tmp_dir, TRUE) < 0 )
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_tmp_dir);
+
+	i_free(testsuite_tmp_dir);
+}
+
+const char *testsuite_tmp_dir_get(void)
+{
+	return testsuite_tmp_dir;
+}
+
+/*
+ * Main testsuite init/deinit
+ */
+
+void testsuite_init(struct sieve_instance *svinst)
+{
+	testsuite_test_context_init();
+	testsuite_log_init();
+	testsuite_tmp_dir_init();
+
+	testsuite_script_init();
+	testsuite_binary_init();
+	testsuite_smtp_init();
+
+	testsuite_ext = sieve_extension_register
+		(svinst, &testsuite_extension, TRUE);
+}
+
+void testsuite_deinit(void)
+{
+	testsuite_smtp_deinit();
+	testsuite_binary_deinit();
+	testsuite_script_deinit();
+
+	testsuite_tmp_dir_deinit();
+	testsuite_log_deinit();
+	testsuite_test_context_deinit();
+}
+
Index: b/sieve/src/testsuite/testsuite-common.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-common.h
@@ -0,0 +1,153 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_COMMON_H
+#define __TESTSUITE_COMMON_H
+
+#include "sieve-common.h"
+
+#include "sieve-tool.h"
+
+/*
+ * Extension
+ */
+
+/* Extension */
+
+extern const struct sieve_extension_def testsuite_extension;
+
+extern const struct sieve_extension *testsuite_ext;
+
+extern const struct sieve_script_env *testsuite_scriptenv;
+
+/*
+ * Validator context
+ */
+
+struct testsuite_validator_context {
+	struct sieve_validator_object_registry *object_registrations;
+};
+
+bool testsuite_validator_context_initialize(struct sieve_validator *valdtr);
+struct testsuite_validator_context *testsuite_validator_context_get
+	(struct sieve_validator *valdtr);
+
+/*
+ * Generator context
+ */
+
+struct testsuite_generator_context {
+	struct sieve_jumplist *exit_jumps;
+};
+
+bool testsuite_generator_context_initialize
+	(struct sieve_generator *gentr, const struct sieve_extension *this_ext);
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command_def cmd_test;
+extern const struct sieve_command_def cmd_test_fail;
+extern const struct sieve_command_def cmd_test_set;
+extern const struct sieve_command_def cmd_test_result_reset;
+extern const struct sieve_command_def cmd_test_result_print;
+extern const struct sieve_command_def cmd_test_message;
+extern const struct sieve_command_def cmd_test_mailbox;
+extern const struct sieve_command_def cmd_test_binary;
+
+/*
+ * Tests
+ */
+
+extern const struct sieve_command_def tst_test_script_compile;
+extern const struct sieve_command_def tst_test_script_run;
+extern const struct sieve_command_def tst_test_multiscript;
+extern const struct sieve_command_def tst_test_error;
+extern const struct sieve_command_def tst_test_result;
+extern const struct sieve_command_def tst_test_result_execute;
+
+/*
+ * Operations
+ */
+
+enum testsuite_operation_code {
+	TESTSUITE_OPERATION_TEST,
+	TESTSUITE_OPERATION_TEST_FINISH,
+	TESTSUITE_OPERATION_TEST_FAIL,
+	TESTSUITE_OPERATION_TEST_SET,
+	TESTSUITE_OPERATION_TEST_SCRIPT_COMPILE,
+	TESTSUITE_OPERATION_TEST_SCRIPT_RUN,
+	TESTSUITE_OPERATION_TEST_MULTISCRIPT,
+	TESTSUITE_OPERATION_TEST_ERROR,
+	TESTSUITE_OPERATION_TEST_RESULT,
+	TESTSUITE_OPERATION_TEST_RESULT_EXECUTE,
+	TESTSUITE_OPERATION_TEST_RESULT_RESET,
+	TESTSUITE_OPERATION_TEST_RESULT_PRINT,
+	TESTSUITE_OPERATION_TEST_MESSAGE_SMTP,
+	TESTSUITE_OPERATION_TEST_MESSAGE_MAILBOX,
+	TESTSUITE_OPERATION_TEST_MAILBOX_CREATE,
+	TESTSUITE_OPERATION_TEST_MAILBOX_DELETE,
+	TESTSUITE_OPERATION_TEST_BINARY_LOAD,
+	TESTSUITE_OPERATION_TEST_BINARY_SAVE,
+};
+
+extern const struct sieve_operation_def test_operation;
+extern const struct sieve_operation_def test_finish_operation;
+extern const struct sieve_operation_def test_fail_operation;
+extern const struct sieve_operation_def test_set_operation;
+extern const struct sieve_operation_def test_script_compile_operation;
+extern const struct sieve_operation_def test_script_run_operation;
+extern const struct sieve_operation_def test_multiscript_operation;
+extern const struct sieve_operation_def test_error_operation;
+extern const struct sieve_operation_def test_result_operation;
+extern const struct sieve_operation_def test_result_execute_operation;
+extern const struct sieve_operation_def test_result_reset_operation;
+extern const struct sieve_operation_def test_result_print_operation;
+extern const struct sieve_operation_def test_message_smtp_operation;
+extern const struct sieve_operation_def test_message_mailbox_operation;
+extern const struct sieve_operation_def test_mailbox_create_operation;
+extern const struct sieve_operation_def test_mailbox_delete_operation;
+extern const struct sieve_operation_def test_binary_load_operation;
+extern const struct sieve_operation_def test_binary_save_operation;
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand_def testsuite_object_operand;
+extern const struct sieve_operand_def testsuite_substitution_operand;
+
+enum testsuite_operand_code {
+	TESTSUITE_OPERAND_OBJECT,
+	TESTSUITE_OPERAND_SUBSTITUTION
+};
+
+/*
+ * Test context
+ */
+
+void testsuite_test_start(string_t *name);
+void testsuite_test_fail(string_t *reason);
+void testsuite_test_failf(const char *fmt, ...) ATTR_FORMAT(1, 2);
+void testsuite_test_fail_cstr(const char *reason);
+
+void testsuite_test_succeed(string_t *reason);
+
+void testsuite_testcase_fail(const char *reason);
+int testsuite_testcase_result(void);
+
+/*
+ * Testsuite temporary directory
+ */
+
+const char *testsuite_tmp_dir_get(void);
+
+/*
+ * Testsuite init/deinit
+ */
+
+void testsuite_init(struct sieve_instance *svinst);
+void testsuite_deinit(void);
+
+#endif /* __TESTSUITE_COMMON_H */
Index: b/sieve/src/testsuite/testsuite-log.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-log.c
@@ -0,0 +1,125 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-error-private.h"
+
+#include "testsuite-log.h"
+
+/*
+ * Testsuite error handler
+ */
+
+struct sieve_error_handler *testsuite_log_ehandler = NULL;
+
+struct _testsuite_log_message {
+	const char *location;
+	const char *message;
+};
+
+bool _testsuite_log_stdout = FALSE;
+
+unsigned int _testsuite_log_error_index = 0;
+
+static pool_t _testsuite_logmsg_pool = NULL;
+ARRAY_DEFINE(_testsuite_log_errors, struct _testsuite_log_message);
+
+static void _testsuite_log_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location,
+	const char *fmt, va_list args)
+{
+	pool_t pool = _testsuite_logmsg_pool;
+	struct _testsuite_log_message msg;
+
+	if ( _testsuite_log_stdout )
+	{
+		va_list args_copy;
+		VA_COPY(args_copy, args);
+		printf("error: %s: %s.\n", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	msg.location = p_strdup(pool, location);
+	msg.message = p_strdup_vprintf(pool, fmt, args);
+
+	array_append(&_testsuite_log_errors, &msg, 1);
+}
+
+static struct sieve_error_handler *_testsuite_log_ehandler_create(void)
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("testsuite_log_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, 0);
+
+	ehandler->verror = _testsuite_log_verror;
+
+	return ehandler;
+}
+
+void testsuite_log_clear_messages(void)
+{
+	if ( _testsuite_logmsg_pool != NULL ) {
+		if ( array_count(&_testsuite_log_errors) == 0 )
+			return;
+		pool_unref(&_testsuite_logmsg_pool);
+	}
+
+	_testsuite_logmsg_pool = pool_alloconly_create
+		("testsuite_log_messages", 8192);
+
+	p_array_init(&_testsuite_log_errors, _testsuite_logmsg_pool, 128);
+
+	sieve_error_handler_reset(testsuite_log_ehandler);
+}
+
+void testsuite_log_get_error_init(void)
+{
+	_testsuite_log_error_index = 0;
+}
+
+const char *testsuite_log_get_error_next(bool location)
+{
+	const struct _testsuite_log_message *msg;
+
+	if ( _testsuite_log_error_index >= array_count(&_testsuite_log_errors) )
+		return NULL;
+
+	msg = array_idx(&_testsuite_log_errors, _testsuite_log_error_index++);
+
+	if ( location )
+		return msg->location;
+
+	return msg->message;
+}
+
+void testsuite_log_init(void)
+{
+	testsuite_log_ehandler = _testsuite_log_ehandler_create();
+	sieve_error_handler_accept_infolog(testsuite_log_ehandler, TRUE);
+
+	sieve_system_ehandler_set(testsuite_log_ehandler);
+
+	testsuite_log_clear_messages();
+}
+
+void testsuite_log_deinit(void)
+{
+	sieve_system_ehandler_reset();
+
+	sieve_error_handler_unref(&testsuite_log_ehandler);
+
+	pool_unref(&_testsuite_logmsg_pool);
+}
+
+
+
+
Index: b/sieve/src/testsuite/testsuite-log.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-log.h
@@ -0,0 +1,18 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_LOG_H
+#define __TESTSUITE_LOG_H
+
+#include "sieve-common.h"
+
+extern struct sieve_error_handler *testsuite_log_ehandler;
+
+void testsuite_log_init(void);
+void testsuite_log_deinit(void);
+
+void testsuite_log_clear_messages(void);
+void testsuite_log_get_error_init(void);
+const char *testsuite_log_get_error_next(bool location);
+
+#endif /* __TESTSUITE_LOG_H */
Index: b/sieve/src/testsuite/testsuite-mailstore.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-mailstore.c
@@ -0,0 +1,181 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "imem.h"
+#include "array.h"
+#include "unlink-directory.h"
+#include "env-util.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+
+#include "testsuite-message.h"
+#include "testsuite-common.h"
+#include "testsuite-smtp.h"
+
+#include "testsuite-mailstore.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+/*
+ * Forward declarations
+ */
+
+static void testsuite_mailstore_close(void);
+
+/*
+ * State
+ */
+
+static char *testsuite_mailstore_tmp = NULL;
+static struct mail_user *testsuite_mailstore_user = NULL;
+
+static char *testsuite_mailstore_folder = NULL;
+static struct mailbox *testsuite_mailstore_box = NULL;
+static struct mailbox_transaction_context *testsuite_mailstore_trans = NULL;
+static struct mail *testsuite_mailstore_mail = NULL;
+
+/*
+ * Initialization
+ */
+
+void testsuite_mailstore_init(const char *user, const char *home)
+{
+	testsuite_mailstore_tmp = i_strconcat
+		(testsuite_tmp_dir_get(), "/mailstore", NULL);
+
+	if ( mkdir(testsuite_mailstore_tmp, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.",
+			testsuite_mailstore_tmp);
+	}
+
+	env_put(t_strdup_printf("NAMESPACE_1=maildir:%s", testsuite_mailstore_tmp));
+	env_put("NAMESPACE_1_INBOX=1");
+	env_put("NAMESPACE_1_LIST=1");
+	env_put("NAMESPACE_1_SEP=.");
+	env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+	testsuite_mailstore_user = mail_user_init(user);
+	mail_user_set_home(testsuite_mailstore_user, home);
+	if (mail_namespaces_init(testsuite_mailstore_user) < 0)
+		i_fatal("Namespace initialization failed");
+}
+
+void testsuite_mailstore_deinit(void)
+{
+	testsuite_mailstore_close();
+
+	/* De-initialize mail user object */
+	if ( testsuite_mailstore_user != NULL )
+		mail_user_unref(&testsuite_mailstore_user);
+
+	if ( unlink_directory(testsuite_mailstore_tmp, TRUE) < 0 ) {
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_mailstore_tmp);
+	}
+
+	i_free(testsuite_mailstore_tmp);
+}
+
+void testsuite_mailstore_reset(void)
+{
+}
+
+/*
+ * Mailbox Access
+ */
+
+struct mail_namespace *testsuite_mailstore_get_namespace(void)
+{
+	return testsuite_mailstore_user->namespaces;
+}
+
+bool testsuite_mailstore_mailbox_create
+(const struct sieve_runtime_env *renv ATTR_UNUSED, const char *folder)
+{
+	struct mail_storage *storage = testsuite_mailstore_user->namespaces->storage;
+
+	/* Try creating it */
+	if ( mail_storage_mailbox_create(storage, folder, FALSE) < 0 )
+		return FALSE;
+
+	return TRUE;
+}
+
+static void testsuite_mailstore_close(void)
+{
+	if ( testsuite_mailstore_mail != NULL )
+		mail_free(&testsuite_mailstore_mail);
+
+	if ( testsuite_mailstore_trans != NULL )
+		mailbox_transaction_rollback(&testsuite_mailstore_trans);
+
+	if ( testsuite_mailstore_box != NULL )
+		mailbox_close(&testsuite_mailstore_box);
+
+	if ( testsuite_mailstore_folder != NULL )
+		i_free(testsuite_mailstore_folder);
+}
+
+static struct mail *testsuite_mailstore_open(const char *folder)
+{
+	enum mailbox_open_flags open_flags =
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT |
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	struct mail_storage *storage = testsuite_mailstore_user->namespaces->storage;
+	struct mailbox *box;
+	struct mailbox_transaction_context *t;
+
+	if ( testsuite_mailstore_mail == NULL ) {
+		testsuite_mailstore_close();
+	} else if ( testsuite_mailstore_folder != NULL
+		&& strcmp(folder, testsuite_mailstore_folder) != 0  ) {
+		testsuite_mailstore_close();
+	} else {
+		return testsuite_mailstore_mail;
+	}
+
+	box = mailbox_open(&storage, folder, NULL, open_flags);
+	if ( box == NULL ) {
+		sieve_sys_error("testsuite: failed to open mailbox '%s'", folder);
+		return NULL;
+	}
+
+	/* Sync mailbox */
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FULL_READ, 0, NULL) < 0 ) {
+		sieve_sys_error("testsuite: failed to sync mailbox '%s'", folder);
+		return NULL;
+	}
+
+	/* Start transaction */
+
+	t = mailbox_transaction_begin(box, 0);
+
+	testsuite_mailstore_folder = i_strdup(folder);
+	testsuite_mailstore_box = box;
+	testsuite_mailstore_trans = t;
+	testsuite_mailstore_mail = mail_alloc(t, 0, NULL);
+
+	return testsuite_mailstore_mail;
+}
+
+bool testsuite_mailstore_mail_index
+(const struct sieve_runtime_env *renv, const char *folder, unsigned int index)
+{
+	struct mail *mail = testsuite_mailstore_open(folder);
+
+	if ( mail == NULL )
+		return FALSE;
+
+	mail_set_seq(mail, index+1);
+	testsuite_message_set_mail(renv, mail);
+
+	return TRUE;
+}
Index: b/sieve/src/testsuite/testsuite-mailstore.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-mailstore.h
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_MAILSTORE_H
+#define __TESTSUITE_MAILSTORE_H
+
+#include "sieve-common.h"
+
+/*
+ * Initialization
+ */
+
+void testsuite_mailstore_init(const char *user, const char *home);
+void testsuite_mailstore_deinit(void);
+void testsuite_mailstore_reset(void);
+
+/*
+ * Namespace
+ */
+
+struct mail_namespace *testsuite_mailstore_get_namespace(void);
+
+/*
+ * Mailbox Access
+ */
+
+bool testsuite_mailstore_mailbox_create
+	(const struct sieve_runtime_env *renv ATTR_UNUSED, const char *folder);
+
+bool testsuite_mailstore_mail_index
+	(const struct sieve_runtime_env *renv, const char *folder,
+		unsigned int index);
+
+#endif /* __TESTSUITE_MAILSTORE */
Index: b/sieve/src/testsuite/testsuite-message.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-message.c
@@ -0,0 +1,184 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "istream.h"
+#include "mail-storage.h"
+
+#include "mail-raw.h"
+
+#include "sieve-common.h"
+#include "sieve-message.h"
+#include "sieve-interpreter.h"
+
+#include "testsuite-common.h"
+#include "testsuite-message.h"
+
+/*
+ * Testsuite message environment
+ */
+
+struct sieve_message_data testsuite_msgdata;
+
+static const char *testsuite_user;
+static struct mail_raw *_raw_message;
+
+static const char *_default_message_data =
+"From: stephan@rename-it.nl\n"
+"To: sirius@drunksnipers.com\n"
+"Subject: Frop!\n"
+"\n"
+"Friep!\n";
+
+static string_t *envelope_from;
+static string_t *envelope_to;
+static string_t *envelope_auth;
+
+pool_t message_pool;
+
+static void _testsuite_message_set_data(struct mail *mail)
+{
+	const char *recipient = NULL, *sender = NULL;
+
+	/*
+	 * Collect necessary message data
+	 */
+
+	/* Get recipient address */
+	(void)mail_get_first_header(mail, "Envelope-To", &recipient);
+	if ( recipient == NULL )
+		(void)mail_get_first_header(mail, "To", &recipient);
+	if ( recipient == NULL )
+		recipient = "recipient@example.com";
+
+	/* Get sender address */
+	(void)mail_get_first_header(mail, "Return-path", &sender);
+	if ( sender == NULL )
+		(void)mail_get_first_header(mail, "Sender", &sender);
+	if ( sender == NULL )
+		(void)mail_get_first_header(mail, "From", &sender);
+	if ( sender == NULL )
+		sender = "sender@example.com";
+
+	memset(&testsuite_msgdata, 0, sizeof(testsuite_msgdata));
+	testsuite_msgdata.mail = mail;
+	testsuite_msgdata.auth_user = testsuite_user;
+	testsuite_msgdata.return_path = sender;
+	testsuite_msgdata.to_address = recipient;
+
+	(void)mail_get_first_header(mail, "Message-ID", &testsuite_msgdata.id);
+}
+
+void testsuite_message_init(const char *user)
+{
+	message_pool = pool_alloconly_create("testsuite_message", 6096);
+
+	string_t *default_message = str_new(message_pool, 1024);
+	str_append(default_message, _default_message_data);
+
+	testsuite_user = user;
+	mail_raw_init(user);
+	_raw_message = mail_raw_open_data(default_message);
+	_testsuite_message_set_data(_raw_message->mail);
+
+	envelope_to = str_new(message_pool, 256);
+	envelope_from = str_new(message_pool, 256);
+	envelope_auth = str_new(message_pool, 256);
+}
+
+void testsuite_message_set_string
+(const struct sieve_runtime_env *renv, string_t *message)
+{
+	mail_raw_close(_raw_message);
+
+	_raw_message = mail_raw_open_data(message);
+
+	_testsuite_message_set_data(_raw_message->mail);
+
+	sieve_message_context_flush(renv->msgctx);
+
+	/*{
+		const unsigned char *data;
+		struct istream *input;
+		size_t size;
+		int ret;
+
+		if (mail_get_stream(_raw_message->mail, NULL, NULL, &input) < 0)
+        	return;
+
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			if (write(1, data, size) == 0)
+				break;
+			i_stream_skip(input, size);
+		}
+    }*/
+}
+
+void testsuite_message_set_file
+(const struct sieve_runtime_env *renv, const char *file_path)
+{
+	mail_raw_close(_raw_message);
+
+	_raw_message = mail_raw_open_file(file_path);
+
+	_testsuite_message_set_data(_raw_message->mail);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_message_set_mail
+(const struct sieve_runtime_env *renv, struct mail *mail)
+{
+	_testsuite_message_set_data(mail);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_message_deinit(void)
+{
+	mail_raw_close(_raw_message);
+	mail_raw_deinit();
+
+	pool_unref(&message_pool);
+}
+
+void testsuite_envelope_set_sender
+(const struct sieve_runtime_env *renv, const char *value)
+{
+	str_truncate(envelope_from, 0);
+
+	if ( value != NULL )
+		str_append(envelope_from, value);
+
+	testsuite_msgdata.return_path = str_c(envelope_from);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_envelope_set_recipient
+(const struct sieve_runtime_env *renv, const char *value)
+{
+	str_truncate(envelope_to, 0);
+
+	if ( value != NULL )
+		str_append(envelope_to, value);
+
+	testsuite_msgdata.to_address = str_c(envelope_to);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
+void testsuite_envelope_set_auth_user
+(const struct sieve_runtime_env *renv, const char *value)
+{
+	str_truncate(envelope_auth, 0);
+
+	if ( value != NULL )
+		str_append(envelope_auth, value);
+
+	testsuite_msgdata.auth_user = str_c(envelope_auth);
+
+	sieve_message_context_flush(renv->msgctx);
+}
+
Index: b/sieve/src/testsuite/testsuite-message.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-message.h
@@ -0,0 +1,28 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_MESSAGE_H
+#define __TESTSUITE_MESSAGE_H
+
+#include "sieve-common.h"
+
+extern struct sieve_message_data testsuite_msgdata;
+
+void testsuite_message_init(const char *user);
+void testsuite_message_deinit(void);
+
+void testsuite_message_set_string
+	(const struct sieve_runtime_env *renv, string_t *message);
+void testsuite_message_set_file
+	(const struct sieve_runtime_env *renv, const char *file_path);
+void testsuite_message_set_mail
+	(const struct sieve_runtime_env *renv, struct mail *mail);
+
+void testsuite_envelope_set_sender
+	(const struct sieve_runtime_env *renv, const char *value);
+void testsuite_envelope_set_recipient
+	(const struct sieve_runtime_env *renv, const char *value);
+void testsuite_envelope_set_auth_user
+	(const struct sieve_runtime_env *renv, const char *value);
+
+#endif /* __TESTSUITE_MESSAGE_H */
Index: b/sieve/src/testsuite/testsuite-objects.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-objects.c
@@ -0,0 +1,361 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "string.h"
+#include "ostream.h"
+#include "hash.h"
+#include "mail-storage.h"
+
+#include "sieve.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-objects.h"
+#include "testsuite-message.h"
+
+/*
+ * Testsuite core objects
+ */
+
+enum testsuite_object_code {
+	TESTSUITE_OBJECT_MESSAGE,
+	TESTSUITE_OBJECT_ENVELOPE
+};
+
+const struct testsuite_object_def *testsuite_core_objects[] = {
+	&message_testsuite_object, &envelope_testsuite_object
+};
+
+const unsigned int testsuite_core_objects_count =
+	N_ELEMENTS(testsuite_core_objects);
+
+/*
+ * Testsuite object registry
+ */
+
+static inline struct sieve_validator_object_registry *_get_object_registry
+(struct sieve_validator *valdtr)
+{
+	struct testsuite_validator_context *ctx =
+		testsuite_validator_context_get(valdtr);
+
+	return ctx->object_registrations;
+}
+
+void testsuite_object_register
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	const struct testsuite_object_def *tobj_def)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+
+	sieve_validator_object_registry_add(regs, ext, &tobj_def->obj_def);
+}
+
+static const struct testsuite_object *testsuite_object_create
+(struct sieve_validator *valdtr, struct sieve_command *cmd,
+	const char *identifier)
+{
+	struct sieve_validator_object_registry *regs = _get_object_registry(valdtr);
+	struct sieve_object object;
+	struct testsuite_object *tobj;
+
+	if ( !sieve_validator_object_registry_find(regs, identifier, &object) )
+		return NULL;
+
+	tobj = p_new(sieve_command_pool(cmd), struct testsuite_object, 1);
+	tobj->object = object;
+	tobj->def = (const struct testsuite_object_def *) object.def;
+
+  return tobj;
+}
+
+void testsuite_register_core_objects
+(struct testsuite_validator_context *ctx)
+{
+	struct sieve_validator_object_registry *regs = ctx->object_registrations;
+	unsigned int i;
+
+	/* Register core testsuite objects */
+	for ( i = 0; i < testsuite_core_objects_count; i++ ) {
+		const struct testsuite_object_def *tobj_def = testsuite_core_objects[i];
+
+		sieve_validator_object_registry_add
+			(regs, testsuite_ext, &tobj_def->obj_def);
+	}
+}
+
+/*
+ * Testsuite object code
+ */
+
+const struct sieve_operand_class sieve_testsuite_object_operand_class =
+	{ "testsuite object" };
+
+static const struct sieve_extension_objects core_testsuite_objects =
+	SIEVE_EXT_DEFINE_OBJECTS(testsuite_core_objects);
+
+const struct sieve_operand_def testsuite_object_operand = {
+	"testsuite-object",
+	&testsuite_extension,
+	TESTSUITE_OPERAND_OBJECT,
+	&sieve_testsuite_object_operand_class,
+	&core_testsuite_objects
+};
+
+static void testsuite_object_emit
+(struct sieve_binary *sbin,	const struct testsuite_object *tobj, int member_id)
+{
+	sieve_opr_object_emit(sbin, tobj->object.ext, tobj->object.def);
+
+	if ( tobj->def != NULL && tobj->def->get_member_id != NULL ) {
+		(void) sieve_binary_emit_byte(sbin, (unsigned char) member_id);
+	}
+}
+
+bool testsuite_object_read
+(struct sieve_binary *sbin, sieve_size_t *address,
+	struct testsuite_object *tobj)
+{
+	struct sieve_operand operand;
+
+	if ( !sieve_operand_read(sbin, address, &operand) )
+		return FALSE;
+
+	if ( !sieve_opr_object_read_data
+		(sbin, &operand, &sieve_testsuite_object_operand_class, address,
+			&tobj->object) )
+		return FALSE;
+
+	tobj->def = (const struct testsuite_object_def *) tobj->object.def;
+
+	return TRUE;
+}
+
+bool testsuite_object_read_member
+(struct sieve_binary *sbin, sieve_size_t *address,
+	struct testsuite_object *tobj, int *member_id_r)
+{
+	if ( !testsuite_object_read(sbin, address, tobj) )
+		return FALSE;
+
+	*member_id_r = -1;
+	if ( tobj->def != NULL && tobj->def->get_member_id != NULL ) {
+		if ( !sieve_binary_read_code(sbin, address, member_id_r) )
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+const char *testsuite_object_member_name
+(const struct testsuite_object *object, int member_id)
+{
+	const struct testsuite_object_def *obj_def = object->def;
+	const char *member = NULL;
+
+	if ( obj_def->get_member_id != NULL ) {
+		if ( obj_def->get_member_name != NULL )
+			member = obj_def->get_member_name(member_id);
+	} else
+		return obj_def->obj_def.identifier;
+
+	if ( member == NULL )
+		return t_strdup_printf("%s.%d", obj_def->obj_def.identifier, member_id);
+
+	return t_strdup_printf("%s.%s", obj_def->obj_def.identifier, member);
+}
+
+bool testsuite_object_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	struct testsuite_object object;
+	int member_id;
+
+	sieve_code_mark(denv);
+
+	if ( !testsuite_object_read_member(denv->sbin, address, &object, &member_id) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "%s: %s",
+		sieve_testsuite_object_operand_class.name,
+		testsuite_object_member_name(&object, member_id));
+
+	return TRUE;
+}
+
+/*
+ * Testsuite object argument
+ */
+
+static bool arg_testsuite_object_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+const struct sieve_argument_def testsuite_object_argument = {
+	"testsuite-object",
+	NULL, NULL, NULL, NULL,
+	arg_testsuite_object_generate
+};
+
+struct testsuite_object_argctx {
+	const struct testsuite_object *object;
+	int member;
+};
+
+bool testsuite_object_argument_activate
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd)
+{
+	const char *objname = sieve_ast_argument_strc(arg);
+	const struct testsuite_object *tobj;
+	int member_id;
+	const char *member;
+	struct testsuite_object_argctx *ctx;
+
+	/* Parse the object specifier */
+
+	member = strchr(objname, '.');
+	if ( member != NULL ) {
+		objname = t_strdup_until(objname, member);
+		member++;
+	}
+
+	/* Find the object */
+
+	tobj = testsuite_object_create(valdtr, cmd, objname);
+	if ( tobj == NULL ) {
+		sieve_argument_validate_error(valdtr, arg,
+			"unknown testsuite object '%s'", objname);
+		return FALSE;
+	}
+
+	/* Find the object member */
+
+	member_id = -1;
+	if ( member != NULL ) {
+		if ( tobj->def == NULL || tobj->def->get_member_id == NULL ||
+			(member_id=tobj->def->get_member_id(member)) == -1 ) {
+			sieve_argument_validate_error(valdtr, arg,
+				"member '%s' does not exist for testsuite object '%s'", member, objname);
+			return FALSE;
+		}
+	}
+
+	/* Assign argument context */
+
+	ctx = p_new(sieve_command_pool(cmd), struct testsuite_object_argctx, 1);
+	ctx->object = tobj;
+	ctx->member = member_id;
+
+	arg->argument = sieve_argument_create
+		(arg->ast, &testsuite_object_argument, testsuite_ext, 0);
+	arg->argument->data = (void *) ctx;
+
+	return TRUE;
+}
+
+static bool arg_testsuite_object_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *cmd ATTR_UNUSED)
+{
+	struct testsuite_object_argctx *ctx =
+		(struct testsuite_object_argctx *) arg->argument->data;
+
+	testsuite_object_emit(cgenv->sbin, ctx->object, ctx->member);
+
+	return TRUE;
+}
+
+/*
+ * Testsuite core object implementation
+ */
+
+static bool tsto_message_set_member
+	(const struct sieve_runtime_env *renv, int id, string_t *value);
+
+static int tsto_envelope_get_member_id(const char *identifier);
+static const char *tsto_envelope_get_member_name(int id);
+static bool tsto_envelope_set_member
+	(const struct sieve_runtime_env *renv, int id, string_t *value);
+
+const struct testsuite_object_def message_testsuite_object = {
+	SIEVE_OBJECT("message",	&testsuite_object_operand, TESTSUITE_OBJECT_MESSAGE),
+	NULL, NULL,
+	tsto_message_set_member,
+	NULL
+};
+
+const struct testsuite_object_def envelope_testsuite_object = {
+	SIEVE_OBJECT("envelope", &testsuite_object_operand, TESTSUITE_OBJECT_ENVELOPE),
+	tsto_envelope_get_member_id,
+	tsto_envelope_get_member_name,
+	tsto_envelope_set_member,
+	NULL
+};
+
+enum testsuite_object_envelope_field {
+	TESTSUITE_OBJECT_ENVELOPE_FROM,
+	TESTSUITE_OBJECT_ENVELOPE_TO,
+	TESTSUITE_OBJECT_ENVELOPE_AUTH_USER
+};
+
+static bool tsto_message_set_member
+(const struct sieve_runtime_env *renv, int id, string_t *value)
+{
+	if ( id != -1 ) return FALSE;
+
+	testsuite_message_set_string(renv, value);
+
+	return TRUE;
+}
+
+static int tsto_envelope_get_member_id(const char *identifier)
+{
+	if ( strcasecmp(identifier, "from") == 0 )
+		return TESTSUITE_OBJECT_ENVELOPE_FROM;
+	if ( strcasecmp(identifier, "to") == 0 )
+		return TESTSUITE_OBJECT_ENVELOPE_TO;
+	if ( strcasecmp(identifier, "auth") == 0 )
+		return TESTSUITE_OBJECT_ENVELOPE_AUTH_USER;
+
+	return -1;
+}
+
+static const char *tsto_envelope_get_member_name(int id)
+{
+	switch ( id ) {
+	case TESTSUITE_OBJECT_ENVELOPE_FROM:
+		return "from";
+	case TESTSUITE_OBJECT_ENVELOPE_TO:
+		return "to";
+	case TESTSUITE_OBJECT_ENVELOPE_AUTH_USER:
+		return "auth";
+	}
+
+	return NULL;
+}
+
+static bool tsto_envelope_set_member
+(const struct sieve_runtime_env *renv, int id, string_t *value)
+{
+	switch ( id ) {
+	case TESTSUITE_OBJECT_ENVELOPE_FROM:
+		testsuite_envelope_set_sender(renv, str_c(value));
+		return TRUE;
+	case TESTSUITE_OBJECT_ENVELOPE_TO:
+		testsuite_envelope_set_recipient(renv, str_c(value));
+		return TRUE;
+	case TESTSUITE_OBJECT_ENVELOPE_AUTH_USER:
+		testsuite_envelope_set_auth_user(renv, str_c(value));
+		return TRUE;
+	}
+
+	return FALSE;
+}
Index: b/sieve/src/testsuite/testsuite-objects.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-objects.h
@@ -0,0 +1,86 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_OBJECTS_H
+#define __TESTSUITE_OBJECTS_H
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+
+#include "testsuite-common.h"
+
+/*
+ * Testsuite object operand
+ */
+
+struct testsuite_object_operand_interface {
+	struct sieve_extension_objects testsuite_objects;
+};
+
+extern const struct sieve_operand_class testsuite_object_oprclass;
+
+/*
+ * Testsuite object access
+ */
+
+struct testsuite_object_def {
+	struct sieve_object_def obj_def;
+
+	int (*get_member_id)(const char *identifier);
+	const char *(*get_member_name)(int id);
+
+	bool (*set_member)
+		(const struct sieve_runtime_env *renv, int id, string_t *value);
+	string_t *(*get_member)
+		(const struct sieve_runtime_env *renv, int id);
+};
+
+struct testsuite_object {
+	struct sieve_object object;
+
+	const struct testsuite_object_def *def;
+};
+
+/*
+ * Testsuite object registration
+ */
+
+void testsuite_register_core_objects
+	(struct testsuite_validator_context *ctx);
+void testsuite_object_register
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		const struct testsuite_object_def *tobj_def);
+
+/*
+ * Testsuite object argument
+ */
+
+bool testsuite_object_argument_activate
+	(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+		struct sieve_command *cmd);
+
+/*
+ * Testsuite object code
+ */
+
+bool testsuite_object_read
+  (struct sieve_binary *sbin, sieve_size_t *address,
+		struct testsuite_object *tobj);
+bool testsuite_object_read_member
+  (struct sieve_binary *sbin, sieve_size_t *address,
+		struct testsuite_object *tobj, int *member_id_r);
+
+bool testsuite_object_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+const char *testsuite_object_member_name
+	(const struct testsuite_object *object, int member_id);
+
+/*
+ * Testsuite core objects
+ */
+
+extern const struct testsuite_object_def message_testsuite_object;
+extern const struct testsuite_object_def envelope_testsuite_object;
+
+#endif /* __TESTSUITE_OBJECTS_H */
Index: b/sieve/src/testsuite/testsuite-result.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-result.c
@@ -0,0 +1,93 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-actions.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-log.h"
+#include "testsuite-message.h"
+
+#include "testsuite-result.h"
+
+static struct sieve_result *_testsuite_result;
+
+void testsuite_result_init(void)
+{
+	_testsuite_result = sieve_result_create
+		(sieve_instance, &testsuite_msgdata, testsuite_scriptenv,
+			testsuite_log_ehandler);
+}
+
+void testsuite_result_deinit(void)
+{
+	if ( _testsuite_result != NULL ) {
+		sieve_result_unref(&_testsuite_result);
+	}
+}
+
+void testsuite_result_reset
+(const struct sieve_runtime_env *renv)
+{
+	if ( _testsuite_result != NULL ) {
+		sieve_result_unref(&_testsuite_result);
+	}
+
+	_testsuite_result = sieve_result_create
+		(sieve_instance, &testsuite_msgdata, testsuite_scriptenv,
+		testsuite_log_ehandler);
+	sieve_interpreter_set_result(renv->interp, _testsuite_result);
+}
+
+struct sieve_result *testsuite_result_get(void)
+{
+	return _testsuite_result;
+}
+
+struct sieve_result_iterate_context *testsuite_result_iterate_init(void)
+{
+	if ( _testsuite_result == NULL )
+		return NULL;
+
+	return sieve_result_iterate_init(_testsuite_result);
+}
+
+bool testsuite_result_execute(const struct sieve_runtime_env *renv)
+{
+	int ret;
+
+	if ( _testsuite_result == NULL ) {
+		sieve_runtime_error(renv, sieve_error_script_location(renv->script,0),
+			"testsuite: no result evaluated yet");
+		return FALSE;
+	}
+
+	testsuite_log_clear_messages();
+
+	/* Execute the result */
+	ret=sieve_result_execute(_testsuite_result, NULL);
+
+	return ( ret > 0 );
+}
+
+void testsuite_result_print
+(const struct sieve_runtime_env *renv)
+{
+	struct ostream *out;
+
+	out = o_stream_create_fd(1, 0, FALSE);
+
+	o_stream_send_str(out, "\n--");
+	sieve_result_print(_testsuite_result, renv->scriptenv, out, NULL);
+	o_stream_send_str(out, "--\n\n");
+
+	o_stream_destroy(&out);
+}
+
+
Index: b/sieve/src/testsuite/testsuite-result.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-result.h
@@ -0,0 +1,22 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_RESULT_H
+#define __TESTSUITE_RESULT_H
+
+void testsuite_result_init(void);
+void testsuite_result_deinit(void);
+
+void testsuite_result_reset
+	(const struct sieve_runtime_env *renv);
+
+struct sieve_result *testsuite_result_get(void);
+
+struct sieve_result_iterate_context *testsuite_result_iterate_init(void);
+
+bool testsuite_result_execute(const struct sieve_runtime_env *renv);
+
+void testsuite_result_print
+	(const struct sieve_runtime_env *renv ATTR_UNUSED);
+
+#endif /* __TESTSUITE_RESULT_H */
Index: b/sieve/src/testsuite/testsuite-script.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-script.c
@@ -0,0 +1,201 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "testsuite-common.h"
+#include "testsuite-settings.h"
+#include "testsuite-log.h"
+#include "testsuite-result.h"
+
+#include "testsuite-script.h"
+
+/*
+ * Tested script environment
+ */
+
+struct sieve_binary *_testsuite_compiled_script;
+
+void testsuite_script_init(void)
+{
+	_testsuite_compiled_script = NULL;
+}
+
+void testsuite_script_deinit(void)
+{
+	if ( _testsuite_compiled_script != NULL ) {
+		sieve_binary_unref(&_testsuite_compiled_script);
+	}
+}
+
+static struct sieve_binary *_testsuite_script_compile(const char *script_path)
+{
+	struct sieve_binary *sbin;
+	const char *sieve_dir;
+
+	/* Initialize environment */
+	sieve_dir = strrchr(script_path, '/');
+	if ( sieve_dir == NULL )
+		sieve_dir= "./";
+	else
+		sieve_dir = t_strdup_until(script_path, sieve_dir+1);
+
+	/* Currently needed for include (FIXME) */
+	testsuite_setting_set("sieve_dir",
+		t_strconcat(sieve_dir, "included", NULL));
+	testsuite_setting_set("sieve_global_dir",
+		t_strconcat(sieve_dir, "included-global", NULL));
+
+	if ( (sbin = sieve_compile
+		(sieve_instance, script_path, NULL, testsuite_log_ehandler)) == NULL )
+		return NULL;
+
+	return sbin;
+}
+
+bool testsuite_script_compile(const char *script_path)
+{
+	struct sieve_binary *sbin;
+
+	testsuite_log_clear_messages();
+
+	if ( (sbin=_testsuite_script_compile(script_path)) == NULL )
+		return FALSE;
+
+	if ( _testsuite_compiled_script != NULL ) {
+		sieve_binary_unref(&_testsuite_compiled_script);
+	}
+
+	_testsuite_compiled_script = sbin;
+
+	return TRUE;
+}
+
+bool testsuite_script_run(const struct sieve_runtime_env *renv)
+{
+	struct sieve_script_env scriptenv;
+	struct sieve_result *result;
+	struct sieve_interpreter *interp;
+	int ret;
+
+	if ( _testsuite_compiled_script == NULL ) {
+		sieve_runtime_error(renv, sieve_error_script_location(renv->script,0),
+			"testsuite: no script compiled yet");
+		return FALSE;
+	}
+
+	testsuite_log_clear_messages();
+
+	/* Compose script execution environment */
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	scriptenv.default_mailbox = "INBOX";
+	scriptenv.username = "user";
+	scriptenv.hostname = "host.example.com";
+	scriptenv.postmaster_address = "postmaster@example.com";
+	scriptenv.smtp_open = NULL;
+	scriptenv.smtp_close = NULL;
+	scriptenv.duplicate_mark = NULL;
+	scriptenv.duplicate_check = NULL;
+	scriptenv.namespaces = renv->scriptenv->namespaces;
+	scriptenv.trace_stream = renv->scriptenv->trace_stream;
+
+	result = testsuite_result_get();
+
+	/* Execute the script */
+	interp=sieve_interpreter_create
+		(_testsuite_compiled_script, testsuite_log_ehandler);
+
+	if ( interp == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+
+	ret = sieve_interpreter_run
+		(interp, renv->msgdata, &scriptenv, result);
+
+	sieve_interpreter_free(&interp);
+
+	return ( ret > 0 );
+}
+
+struct sieve_binary *testsuite_script_get_binary(void)
+{
+	return _testsuite_compiled_script;
+}
+
+void testsuite_script_set_binary(struct sieve_binary *sbin)
+{
+	if ( _testsuite_compiled_script != NULL ) {
+		sieve_binary_unref(&_testsuite_compiled_script);
+	}
+
+	_testsuite_compiled_script = sbin;
+	sieve_binary_ref(sbin);
+}
+
+/*
+ * Multiscript
+ */
+
+bool testsuite_script_multiscript
+(const struct sieve_runtime_env *renv, ARRAY_TYPE (const_string) *scriptfiles)
+{
+	struct sieve_script_env scriptenv;
+	struct sieve_multiscript *mscript;
+	const char *const *scripts;
+	unsigned int count, i;
+	bool more = TRUE;
+	int ret;
+
+	testsuite_log_clear_messages();
+
+	/* Compose script execution environment */
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	scriptenv.default_mailbox = "INBOX";
+	scriptenv.namespaces = NULL;
+	scriptenv.username = "user";
+	scriptenv.hostname = "host.example.com";
+	scriptenv.postmaster_address = "postmaster@example.com";
+	scriptenv.smtp_open = NULL;
+	scriptenv.smtp_close = NULL;
+	scriptenv.duplicate_mark = NULL;
+	scriptenv.duplicate_check = NULL;
+	scriptenv.namespaces = renv->scriptenv->namespaces;
+	scriptenv.trace_stream = renv->scriptenv->trace_stream;
+
+	/* Start execution */
+
+	mscript = sieve_multiscript_start_execute
+		(sieve_instance, renv->msgdata, &scriptenv);
+
+	/* Execute scripts before main script */
+
+	scripts = array_get(scriptfiles, &count);
+
+	for ( i = 0; i < count && more; i++ ) {
+		struct sieve_binary *sbin = NULL;
+		const char *script_path = scripts[i];
+		bool final = ( i == count - 1 );
+
+		/* Open */
+
+		if ( (sbin=_testsuite_script_compile(script_path)) == NULL )
+			break;
+
+		/* Execute */
+
+		more = sieve_multiscript_run(mscript, sbin, testsuite_log_ehandler, final);
+
+		sieve_close(&sbin);
+	}
+
+	ret = sieve_multiscript_finish(&mscript, testsuite_log_ehandler, NULL);
+
+	return ( ret > 0 );
+}
Index: b/sieve/src/testsuite/testsuite-script.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-script.h
@@ -0,0 +1,20 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_SCRIPT_H
+#define __TESTSUITE_SCRIPT_H
+
+#include "sieve-common.h"
+
+void testsuite_script_init(void);
+void testsuite_script_deinit(void);
+
+bool testsuite_script_compile(const char *script_path);
+bool testsuite_script_run(const struct sieve_runtime_env *renv);
+bool testsuite_script_multiscript
+(const struct sieve_runtime_env *renv, ARRAY_TYPE (const_string) *scriptfiles);
+
+struct sieve_binary *testsuite_script_get_binary(void);
+void testsuite_script_set_binary(struct sieve_binary *sbin);
+
+#endif /* __TESTSUITE_SCRIPT_H */
Index: b/sieve/src/testsuite/testsuite-settings.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-settings.c
@@ -0,0 +1,75 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "imem.h"
+#include "strfuncs.h"
+
+#include "sieve-common.h"
+
+#include "testsuite-common.h"
+#include "testsuite-settings.h"
+
+struct testsuite_setting {
+	char *identifier;
+	char *value;
+};
+
+static struct hash_table *settings;
+
+void testsuite_settings_init(void)
+{
+	settings = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+void testsuite_settings_deinit(void)
+{
+	struct hash_iterate_context *itx =
+		hash_table_iterate_init(settings);
+	void *key;
+	void *value;
+
+	while ( hash_table_iterate(itx, &key, &value) ) {
+		struct testsuite_setting *setting = (struct testsuite_setting *) value;
+
+		i_free(setting->identifier);
+		i_free(setting->value);
+		i_free(setting);
+	}
+
+	hash_table_iterate_deinit(&itx);
+
+	hash_table_destroy(&settings);
+}
+
+const char *testsuite_setting_get
+(void *context ATTR_UNUSED, const char *identifier)
+{
+	struct testsuite_setting *setting = (struct testsuite_setting *)
+		hash_table_lookup(settings, identifier);
+
+	if ( setting == NULL ) {
+		return NULL;
+	}
+
+	return setting->value;
+}
+
+void testsuite_setting_set(const char *identifier, const char *value)
+{
+	struct testsuite_setting *setting = (struct testsuite_setting *)
+		hash_table_lookup(settings, identifier);
+
+	if ( setting != NULL ) {
+		i_free(setting->value);
+		setting->value = i_strdup(value);
+	} else {
+		setting = i_new(struct testsuite_setting, 1);
+		setting->identifier = i_strdup(identifier);
+		setting->value = i_strdup(value);
+
+		hash_table_insert(settings, (void *) identifier, (void *) setting);
+	}
+}
Index: b/sieve/src/testsuite/testsuite-settings.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-settings.h
@@ -0,0 +1,15 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_SETTINGS_H
+#define __TESTSUITE_SETTINGS_H
+
+#include "sieve-common.h"
+
+void testsuite_settings_init(void);
+void testsuite_settings_deinit(void);
+
+const char *testsuite_setting_get(void *context, const char *identifier);
+void testsuite_setting_set(const char *identifier, const char *value);
+
+#endif /* __TESTSUITE_SETTINGS_H */
Index: b/sieve/src/testsuite/testsuite-smtp.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-smtp.c
@@ -0,0 +1,129 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "unlink-directory.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+
+#include "testsuite-message.h"
+#include "testsuite-common.h"
+#include "testsuite-smtp.h"
+
+#include <sys/stat.h>
+#include <sys/types.h>
+
+struct testsuite_smtp_message {
+	const char *envelope_from;
+	const char *envelope_to;
+	const char *file;
+};
+
+static pool_t testsuite_smtp_pool;
+static const char *testsuite_smtp_tmp;
+static ARRAY_DEFINE(testsuite_smtp_messages, struct testsuite_smtp_message);
+
+/*
+ * Initialize
+ */
+
+void testsuite_smtp_init(void)
+{
+	pool_t pool;
+
+	testsuite_smtp_pool = pool = pool_alloconly_create("testsuite_smtp", 8192);
+
+	testsuite_smtp_tmp = p_strconcat
+		(pool, testsuite_tmp_dir_get(), "/smtp", NULL);
+
+	if ( mkdir(testsuite_smtp_tmp, 0700) < 0 ) {
+		i_fatal("failed to create temporary directory '%s': %m.",
+			testsuite_smtp_tmp);
+	}
+
+	p_array_init(&testsuite_smtp_messages, pool, 16);
+}
+
+void testsuite_smtp_deinit(void)
+{
+	if ( unlink_directory(testsuite_smtp_tmp, TRUE) < 0 )
+		i_warning("failed to remove temporary directory '%s': %m.",
+			testsuite_smtp_tmp);
+
+	pool_unref(&testsuite_smtp_pool);
+}
+
+void testsuite_smtp_reset(void)
+{
+	testsuite_smtp_deinit();
+	testsuite_smtp_init();
+}
+
+/*
+ * Simulated SMTP out
+ */
+
+struct testsuite_smtp {
+	const char *tmp_path;
+	FILE *mfile;
+};
+
+void *testsuite_smtp_open
+	(const char *destination, const char *return_path, FILE **file_r)
+{
+	struct testsuite_smtp_message smtp_msg;
+	struct testsuite_smtp *smtp;
+	unsigned int smtp_count = array_count(&testsuite_smtp_messages);
+
+	smtp_msg.file = p_strdup_printf(testsuite_smtp_pool,
+		"%s/%d.eml", testsuite_smtp_tmp, smtp_count);
+	smtp_msg.envelope_from =
+		( return_path != NULL ? p_strdup(testsuite_smtp_pool, return_path) : NULL );
+	smtp_msg.envelope_to = p_strdup(testsuite_smtp_pool, destination);
+
+	array_append(&testsuite_smtp_messages, &smtp_msg, 1);
+
+	smtp = t_new(struct testsuite_smtp, 1);
+	smtp->tmp_path = smtp_msg.file;
+	smtp->mfile = fopen(smtp->tmp_path, "w");
+
+	if ( smtp->mfile == NULL )
+		i_fatal("failed to open tmp file for SMTP simulation.");
+
+	*file_r = smtp->mfile;
+
+	return (void *) smtp;
+}
+
+bool testsuite_smtp_close(void *handle)
+{
+	struct testsuite_smtp *smtp = (struct testsuite_smtp *) handle;
+
+	fclose(smtp->mfile);
+
+	return TRUE;
+}
+
+/*
+ * Access
+ */
+
+bool testsuite_smtp_get
+(const struct sieve_runtime_env *renv, unsigned int index)
+{
+	const struct testsuite_smtp_message *smtp_msg;
+
+	if ( index >= array_count(&testsuite_smtp_messages) )
+		return FALSE;
+
+	smtp_msg = array_idx(&testsuite_smtp_messages, index);
+
+	testsuite_message_set_file(renv, smtp_msg->file);
+	testsuite_envelope_set_sender(renv, smtp_msg->envelope_from);
+	testsuite_envelope_set_recipient(renv, smtp_msg->envelope_to);
+
+	return TRUE;
+}
Index: b/sieve/src/testsuite/testsuite-smtp.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-smtp.h
@@ -0,0 +1,26 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_SMTP_H
+#define __TESTSUITE_SMTP_H
+
+void testsuite_smtp_init(void);
+void testsuite_smtp_deinit(void);
+void testsuite_smtp_reset(void);
+
+/*
+ * Simulated SMTP out
+ */
+
+void *testsuite_smtp_open
+	(const char *destination, const char *return_path, FILE **file_r);
+bool testsuite_smtp_close(void *handle);
+
+/*
+ * Access
+ */
+
+bool testsuite_smtp_get
+	(const struct sieve_runtime_env *renv, unsigned int index);
+
+#endif /* __TESTSUITE_SMTP_H */
Index: b/sieve/src/testsuite/testsuite-substitutions.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-substitutions.c
@@ -0,0 +1,249 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "testsuite-common.h"
+#include "testsuite-substitutions.h"
+
+/*
+ * Forward declarations
+ */
+
+void testsuite_opr_substitution_emit
+	(struct sieve_binary *sbin, const struct testsuite_substitution *tsub,
+		const char *param);
+
+/*
+ * Testsuite substitutions
+ */
+
+/* FIXME: make this extendible */
+
+enum {
+	TESTSUITE_SUBSTITUTION_FILE,
+};
+
+static const struct testsuite_substitution_def testsuite_file_substitution;
+
+static const struct testsuite_substitution_def *substitutions[] = {
+	&testsuite_file_substitution,
+};
+
+static const unsigned int substitutions_count = N_ELEMENTS(substitutions);
+
+static inline const struct testsuite_substitution_def *
+testsuite_substitution_get
+(unsigned int code)
+{
+	if ( code > substitutions_count )
+		return NULL;
+
+	return substitutions[code];
+}
+
+static const struct testsuite_substitution *testsuite_substitution_create
+(struct sieve_ast *ast, const char *identifier)
+{
+	unsigned int i;
+
+	for ( i = 0; i < substitutions_count; i++ ) {
+		if ( strcasecmp(substitutions[i]->obj_def.identifier, identifier) == 0 ) {
+			const struct testsuite_substitution_def *tsub_def = substitutions[i];
+			struct testsuite_substitution *tsub;
+
+			tsub = p_new(sieve_ast_pool(ast), struct testsuite_substitution, 1);
+			tsub->object.def = &tsub_def->obj_def;
+			tsub->object.ext = testsuite_ext;
+			tsub->def = tsub_def;
+
+			return tsub;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * Substitution argument
+ */
+
+static bool arg_testsuite_substitution_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command *context);
+
+struct _testsuite_substitution_context {
+	const struct testsuite_substitution *tsub;
+	const char *param;
+};
+
+const struct sieve_argument_def testsuite_substitution_argument = {
+	"@testsuite-substitution",
+	NULL, NULL, NULL, NULL,
+	arg_testsuite_substitution_generate
+};
+
+struct sieve_ast_argument *testsuite_substitution_argument_create
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_ast *ast,
+	unsigned int source_line, const char *substitution, const char *param)
+{
+	const struct testsuite_substitution *tsub;
+	struct _testsuite_substitution_context *tsctx;
+	struct sieve_ast_argument *arg;
+	pool_t pool;
+
+	tsub = testsuite_substitution_create(ast, substitution);
+	if ( tsub == NULL )
+		return NULL;
+
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+
+	pool = sieve_ast_pool(ast);
+	tsctx = p_new(pool, struct _testsuite_substitution_context, 1);
+	tsctx->tsub = tsub;
+	tsctx->param = p_strdup(pool, param);
+
+	arg->argument = sieve_argument_create
+		(ast, &testsuite_substitution_argument, testsuite_ext, 0);
+	arg->argument->data = (void *) tsctx;
+
+	return arg;
+}
+
+static bool arg_testsuite_substitution_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command *context ATTR_UNUSED)
+{
+	struct _testsuite_substitution_context *tsctx =
+		(struct _testsuite_substitution_context *) arg->argument->data;
+
+	testsuite_opr_substitution_emit(cgenv->sbin, tsctx->tsub, tsctx->param);
+
+	return TRUE;
+}
+
+/*
+ * Substitution operand
+ */
+
+static bool opr_substitution_dump
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *opr,
+		sieve_size_t *address, const char *field_name);
+static bool opr_substitution_read_value
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *opr,
+		sieve_size_t *address, string_t **str);
+
+const struct sieve_opr_string_interface testsuite_substitution_interface = {
+	opr_substitution_dump,
+	opr_substitution_read_value
+};
+
+const struct sieve_operand_def testsuite_substitution_operand = {
+	"test-substitution",
+	&testsuite_extension,
+	TESTSUITE_OPERAND_SUBSTITUTION,
+	&string_class,
+	&testsuite_substitution_interface
+};
+
+void testsuite_opr_substitution_emit
+(struct sieve_binary *sbin, const struct testsuite_substitution *tsub,
+	const char *param)
+{
+	/* Default variable storage */
+	(void) sieve_operand_emit
+		(sbin, testsuite_ext, &testsuite_substitution_operand);
+	(void) sieve_binary_emit_unsigned(sbin, tsub->object.def->code);
+	(void) sieve_binary_emit_cstring(sbin, param);
+}
+
+static bool opr_substitution_dump
+(const struct sieve_dumptime_env *denv,
+	const struct sieve_operand *opr ATTR_UNUSED, sieve_size_t *address,
+	const char *field_name)
+{
+	unsigned int code = 0;
+	const struct testsuite_substitution_def *tsub;
+	string_t *param;
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &code) )
+		return FALSE;
+
+	tsub = testsuite_substitution_get(code);
+	if ( tsub == NULL )
+		return FALSE;
+
+	if ( !sieve_binary_read_string(denv->sbin, address, &param) )
+		return FALSE;
+
+	if ( field_name != NULL )
+		sieve_code_dumpf(denv, "%s: TEST_SUBS %%{%s:%s}",
+			field_name, tsub->obj_def.identifier, str_c(param));
+	else
+		sieve_code_dumpf(denv, "TEST_SUBS %%{%s:%s}",
+			tsub->obj_def.identifier, str_c(param));
+	return TRUE;
+}
+
+static bool opr_substitution_read_value
+(const struct sieve_runtime_env *renv,
+	const struct sieve_operand *opr ATTR_UNUSED, sieve_size_t *address,
+	string_t **str)
+{
+	const struct testsuite_substitution_def *tsub;
+	unsigned int code = 0;
+	string_t *param;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &code) )
+		return FALSE;
+
+	tsub = testsuite_substitution_get(code);
+	if ( tsub == NULL )
+		return FALSE;
+
+	/* Parameter str can be NULL if we are requested to only skip and not
+	 * actually read the argument.
+	 */
+	if ( str == NULL )
+		return sieve_binary_read_string(renv->sbin, address, NULL);
+
+	if ( !sieve_binary_read_string(renv->sbin, address, &param) )
+		return FALSE;
+
+	return tsub->get_value(str_c(param), str);
+}
+
+/*
+ * Testsuite substitution definitions
+ */
+
+static bool testsuite_file_substitution_get_value
+	(const char *param, string_t **result);
+
+static const struct testsuite_substitution_def testsuite_file_substitution = {
+	SIEVE_OBJECT(
+		"file",
+		&testsuite_substitution_operand,
+		TESTSUITE_SUBSTITUTION_FILE
+	),
+	testsuite_file_substitution_get_value
+};
+
+static bool testsuite_file_substitution_get_value
+	(const char *param, string_t **result)
+{
+	*result = t_str_new(256);
+
+	str_printfa(*result, "[FILE: %s]", param);
+	return TRUE;
+}
+
Index: b/sieve/src/testsuite/testsuite-substitutions.h
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite-substitutions.h
@@ -0,0 +1,26 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __TESTSUITE_SUBSTITUTIONS_H
+#define __TESTSUITE_SUBSTITUTIONS_H
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+
+struct testsuite_substitution_def {
+	struct sieve_object_def obj_def;
+
+	bool (*get_value)(const char *param, string_t **result);
+};
+
+struct testsuite_substitution {
+	struct sieve_object object;
+
+	const struct testsuite_substitution_def *def;
+};
+
+struct sieve_ast_argument *testsuite_substitution_argument_create
+	(struct sieve_validator *valdtr, struct sieve_ast *ast,
+		unsigned int source_line, const char *substitution, const char *param);
+
+#endif /* __TESTSUITE_SUBSTITUTIONS_H */
Index: b/sieve/src/testsuite/testsuite.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/testsuite.c
@@ -0,0 +1,249 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "lib-signals.h"
+#include "ioloop.h"
+#include "ostream.h"
+#include "hostpid.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-interpreter.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "testsuite-common.h"
+#include "testsuite-settings.h"
+#include "testsuite-result.h"
+#include "testsuite-message.h"
+#include "testsuite-smtp.h"
+#include "testsuite-mailstore.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+const struct sieve_script_env *testsuite_scriptenv;
+
+/*
+ * Configuration
+ */
+
+#define DEFAULT_SENDMAIL_PATH "/usr/lib/sendmail"
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/*
+ * Testsuite initialization
+ */
+
+static const struct sieve_callbacks testsuite_sieve_callbacks = {
+	sieve_tool_get_homedir,
+	testsuite_setting_get
+};
+
+static void testsuite_tool_init(const char *extensions)
+{
+	testsuite_settings_init();
+
+	sieve_tool_init(&testsuite_sieve_callbacks);
+
+	sieve_extensions_set_string(sieve_instance, extensions);
+
+	testsuite_init(sieve_instance);
+}
+
+static void testsuite_tool_deinit(void)
+{
+	testsuite_deinit();
+
+	sieve_tool_deinit();
+
+	testsuite_settings_deinit();
+}
+
+/*
+ * Testsuite execution
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: testsuite [-d <dump filename>] <scriptfile>\n"
+	);
+}
+
+static int testsuite_run
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler)
+{
+	struct sieve_interpreter *interp;
+	struct sieve_result *result;
+	int ret = 0;
+
+	/* Create the interpreter */
+	if ( (interp=sieve_interpreter_create(sbin, ehandler)) == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+
+	/* Reset execution status */
+	if ( senv->exec_status != NULL )
+		memset(senv->exec_status, 0, sizeof(*senv->exec_status));
+
+	/* Run the interpreter */
+	result = testsuite_result_get();
+	sieve_result_ref(result);
+	ret = sieve_interpreter_run(interp, msgdata, senv, result);
+	sieve_result_unref(&result);
+
+	/* Free the interpreter */
+	sieve_interpreter_free(&interp);
+
+	return ret;
+}
+
+int main(int argc, char **argv)
+{
+	const char *scriptfile, *dumpfile, *extensions;
+	const char *user;
+	int i, ret;
+	struct sieve_binary *sbin;
+	const char *sieve_dir;
+	bool trace = FALSE;
+
+	/* Parse arguments */
+	scriptfile = dumpfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			i++;
+			if (i == argc)
+				i_fatal("Missing -d argument");
+			dumpfile = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+            /* extensions */
+            i++;
+            if (i == argc) {
+                print_help();
+                i_fatal("Missing -x argument");
+            }
+            extensions = argv[i];
+#ifdef SIEVE_RUNTIME_TRACE
+		} else if (strcmp(argv[i], "-t") == 0) {
+			/* runtime trace */
+			trace = TRUE;
+#endif
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <scriptfile> argument");
+	}
+
+	printf("Test case: %s:\n\n", scriptfile);
+
+	/* Initialize testsuite */
+	testsuite_tool_init(extensions);
+
+	/* Settings */
+
+	sieve_dir = strrchr(scriptfile, '/');
+	if ( sieve_dir == NULL )
+		sieve_dir= "./";
+	else
+		sieve_dir = t_strdup_until(scriptfile, sieve_dir+1);
+
+	testsuite_setting_set
+		("sieve_dir", t_strconcat(sieve_dir, "included", NULL));
+	testsuite_setting_set
+		("sieve_global_dir", t_strconcat(sieve_dir, "included-global", NULL));
+
+	/* Compile sieve script */
+	if ( (sbin = sieve_tool_script_compile(scriptfile, NULL)) != NULL ) {
+		struct sieve_error_handler *ehandler;
+		struct sieve_script_env scriptenv;
+		const char *home = getenv("HOME");
+
+		/* Dump script */
+		sieve_tool_dump_binary_to(sbin, dumpfile);
+
+		/* Initialize mail storages */
+		mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+		mail_storage_init();
+		mail_storage_register_all();
+		mailbox_list_register_all();
+
+		/* Initialize message environment */
+		user = sieve_tool_get_user();
+		testsuite_mailstore_init(user, home);
+		testsuite_message_init(user);
+
+		memset(&scriptenv, 0, sizeof(scriptenv));
+		scriptenv.namespaces = testsuite_mailstore_get_namespace();
+		scriptenv.default_mailbox = "INBOX";
+		scriptenv.hostname = "testsuite.example.com";
+		scriptenv.postmaster_address = "postmaster@example.com";
+		scriptenv.username = user;
+		scriptenv.smtp_open = testsuite_smtp_open;
+		scriptenv.smtp_close = testsuite_smtp_close;
+		scriptenv.trace_stream = ( trace ? o_stream_create_fd(1, 0, FALSE) : NULL );
+
+		testsuite_scriptenv = &scriptenv;
+
+		testsuite_result_init();
+
+		/* Run the test */
+		ehandler = sieve_stderr_ehandler_create(0);
+		ret = testsuite_run(sbin, &testsuite_msgdata, &scriptenv, ehandler);
+		sieve_error_handler_unref(&ehandler);
+
+		switch ( ret ) {
+		case SIEVE_EXEC_OK:
+			break;
+		case SIEVE_EXEC_FAILURE:
+		case SIEVE_EXEC_KEEP_FAILED:
+			testsuite_testcase_fail("execution aborted");
+			break;
+		case SIEVE_EXEC_BIN_CORRUPT:
+			testsuite_testcase_fail("binary corrupt");
+			break;
+		default:
+			testsuite_testcase_fail("unknown execution exit code");
+		}
+
+		sieve_close(&sbin);
+
+		if ( scriptenv.trace_stream != NULL )
+			o_stream_unref(&scriptenv.trace_stream);
+
+		/* De-initialize message environment */
+		testsuite_message_deinit();
+		testsuite_mailstore_deinit();
+		testsuite_result_deinit();
+
+		/* De-initialize mail storages */
+		mail_storage_deinit();
+		mail_users_deinit();
+	} else {
+		testsuite_testcase_fail("failed to compile testcase script");
+	}
+
+	/* De-initialize testsuite */
+	testsuite_tool_deinit();
+
+	return testsuite_testcase_result();
+}
Index: b/sieve/src/testsuite/tst-test-error.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/tst-test-error.c
@@ -0,0 +1,304 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "testsuite-common.h"
+#include "testsuite-log.h"
+
+/*
+ * Test_error command
+ *
+ * Syntax:
+ *   test [MATCH-TYPE] [COMPARATOR] [:index number] <key-list: string-list>
+ */
+
+static bool tst_test_error_registered
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_test_error_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool tst_test_error_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def tst_test_error = {
+	"test_error",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	tst_test_error_registered,
+	NULL,
+	tst_test_error_validate,
+	tst_test_error_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static bool tst_test_error_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_error_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_error_operation = {
+	"TEST_ERROR",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_ERROR,
+	tst_test_error_operation_dump,
+	tst_test_error_operation_execute
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* NOTE: This will be merged with the date-index extension when it is
+ * implemented.
+ */
+
+static bool tst_test_error_validate_index_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def test_error_index_tag = {
+	"index",
+	NULL,
+	tst_test_error_validate_index_tag,
+	NULL, NULL, NULL
+};
+
+enum tst_test_error_optional {
+	OPT_INDEX = SIEVE_MATCH_OPT_LAST,
+};
+
+
+/*
+ * Argument implementation
+ */
+
+static bool tst_test_error_validate_index_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :index number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(valdtr, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+	return TRUE;
+}
+
+
+/*
+ * Command registration
+ */
+
+static bool tst_test_error_registered
+(struct sieve_validator *valdtr, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, ext, &test_error_index_tag, OPT_INDEX);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool tst_test_error_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+	struct sieve_match_type mcht_default =
+		SIEVE_COMPARATOR_DEFAULT(is_match_type);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_test_error_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_error_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_test_error_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "TEST_ERROR:");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_dump(denv, address, "index") )
+				return FALSE;
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_error_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int opt_code = 0;
+	bool result = TRUE;
+	struct sieve_comparator cmp = SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+	struct sieve_match_type mcht = SIEVE_COMPARATOR_DEFAULT(is_match_type);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *key_list;
+	bool matched;
+	const char *error;
+	int cur_index = 0, index = 0;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle optional operands */
+	do {
+		sieve_number_t number;
+
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+ 			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_read(renv, address, &number) ) {
+				sieve_runtime_trace_error(renv, "invalid index operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			index = (int) number;
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END);
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST_ERROR test (index: %d)", index);
+
+	testsuite_log_get_error_init();
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+	/* Iterate through all errors to match */
+	error = NULL;
+	matched = FALSE;
+	cur_index = 1;
+	ret = 0;
+	while ( result && !matched &&
+		(error=testsuite_log_get_error_next(FALSE)) != NULL ) {
+
+		if ( index == 0 || index == cur_index ) {
+			if ( (ret=sieve_match_value(mctx, error, strlen(error))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+		}
+
+		matched = ret > 0;
+		cur_index++;
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
+
+
Index: b/sieve/src/testsuite/tst-test-multiscript.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/tst-test-multiscript.c
@@ -0,0 +1,159 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-script.h"
+
+/*
+ * Test_multiscript command
+ *
+ * Syntax:
+ *   test_multiscript <scripts: string-list>
+ */
+
+static bool tst_test_multiscript_validate
+	(struct sieve_validator *validator, struct sieve_command *cmd);
+static bool tst_test_multiscript_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *tst);
+
+const struct sieve_command_def tst_test_multiscript = {
+	"test_multiscript",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_test_multiscript_validate,
+	tst_test_multiscript_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static bool tst_test_multiscript_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_multiscript_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_multiscript_operation = {
+	"TEST_MULTISCRIPT",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_MULTISCRIPT,
+	tst_test_multiscript_operation_dump,
+	tst_test_multiscript_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool tst_test_multiscript_validate
+(struct sieve_validator *valdtr, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "scripts", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_test_multiscript_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_multiscript_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_test_multiscript_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST_MULTISCRIPT:");
+	sieve_code_descend(denv);
+
+	if ( !sieve_opr_stringlist_dump(denv, address, "scripts") )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_multiscript_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_coded_stringlist *scripts_list;
+	string_t *script_name;
+	const char *script_path;
+	ARRAY_TYPE (const_string) scriptfiles;
+	bool result = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+  if ( (scripts_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid scripts operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST MULTISCRIPT");
+
+	t_array_init(&scriptfiles, 16);
+
+	script_path = sieve_script_dirpath(renv->script);
+	if ( script_path == NULL )
+		return SIEVE_EXEC_FAILURE;
+
+	script_name = NULL;
+	while ( result &&
+		(result=sieve_coded_stringlist_next_item(scripts_list, &script_name))
+		&& script_name != NULL ) {
+
+		const char *path =
+			t_strconcat(script_path, "/", str_c(script_name), NULL);
+
+		/* Attempt script compile */
+		array_append(&scriptfiles, &path, 1);
+	}
+
+	result = result && testsuite_script_multiscript(renv, &scriptfiles);
+
+	/* Set result */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
Index: b/sieve/src/testsuite/tst-test-result-execute.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/tst-test-result-execute.c
@@ -0,0 +1,89 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+
+/*
+ * Test_result_execute command
+ *
+ * Syntax:
+ *   test_result_execute
+ */
+
+static bool tst_test_result_execute_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def tst_test_result_execute = {
+	"test_result_execute",
+	SCT_TEST,
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL,
+	tst_test_result_execute_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static int tst_test_result_execute_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_result_execute_operation = {
+	"TEST_RESULT_EXECUTE",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_RESULT_EXECUTE,
+	NULL,
+	tst_test_result_execute_operation_execute
+};
+
+/*
+ * Code generation
+ */
+
+static bool tst_test_result_execute_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_result_execute_operation);
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_result_execute_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	bool result = TRUE;
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST_RESULT_EXECUTE test");
+
+	result = testsuite_result_execute(renv);
+
+	/* Set result */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
Index: b/sieve/src/testsuite/tst-test-result.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/tst-test-result.c
@@ -0,0 +1,317 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: this file is very similar to tst-test-error.c. Maybe it is best to
+ * implement errors and actions as testsuite-objects and implement a common
+ * interface to test these.
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "testsuite-common.h"
+#include "testsuite-result.h"
+
+/*
+ * test_result command
+ *
+ * Syntax:
+ *   test_result [MATCH-TYPE] [COMPARATOR] [:index number]
+ *     <key-list: string-list>
+ */
+
+static bool tst_test_result_registered
+	(struct sieve_validator *validator, const struct sieve_extension *ext,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_test_result_validate
+	(struct sieve_validator *validator, struct sieve_command *cmd);
+static bool tst_test_result_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *ctx);
+
+const struct sieve_command_def tst_test_result = {
+	"test_result",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	tst_test_result_registered,
+	NULL,
+	tst_test_result_validate,
+	tst_test_result_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static bool tst_test_result_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_result_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_result_operation = {
+	"test_result",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_RESULT,
+	tst_test_result_operation_dump,
+	tst_test_result_operation_execute
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* FIXME: merge this with the test_error version of this tag */
+
+static bool tst_test_result_validate_index_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+		struct sieve_command *cmd);
+
+static const struct sieve_argument_def test_result_index_tag = {
+    "index",
+    NULL,
+    tst_test_result_validate_index_tag,
+    NULL, NULL, NULL
+};
+
+enum tst_test_result_optional {
+	OPT_INDEX = SIEVE_MATCH_OPT_LAST,
+};
+
+/*
+ * Argument implementation
+ */
+
+static bool tst_test_result_validate_index_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg,
+	struct sieve_command *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax:
+	 *   :index number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+	return TRUE;
+}
+
+
+/*
+ * Command registration
+ */
+
+static bool tst_test_result_registered
+(struct sieve_validator *validator, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	sieve_validator_register_tag
+		(validator, cmd_reg, ext, &test_result_index_tag, OPT_INDEX);
+
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool tst_test_result_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_comparator cmp_default =
+		SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+	struct sieve_match_type mcht_default =
+		SIEVE_COMPARATOR_DEFAULT(is_match_type);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &mcht_default, &cmp_default);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_test_result_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_result_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_test_result_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "TEST_RESULT:");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_dump(denv, address, "index") )
+				return FALSE;
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_result_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int opt_code = 0;
+	bool result = TRUE;
+	struct sieve_comparator cmp = SIEVE_COMPARATOR_DEFAULT(i_octet_comparator);
+	struct sieve_match_type mcht = SIEVE_COMPARATOR_DEFAULT(is_match_type);
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *key_list;
+	bool matched;
+	struct sieve_result_iterate_context *rictx;
+	const struct sieve_action *action;
+	bool keep;
+	int cur_index = 0, index = 0;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Handle optional operands */
+	do {
+		sieve_number_t number;
+
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mcht)) <= 0 )
+ 			return ret;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_INDEX:
+			if ( !sieve_opr_number_read(renv, address, &number) ) {
+				sieve_runtime_trace_error(renv, "invalid index operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			index = (int) number;
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END);
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST_RESULT test (index: %d)", index);
+
+	rictx = testsuite_result_iterate_init();
+
+  /* Initialize match */
+  mctx = sieve_match_begin(renv->interp, &mcht, &cmp, NULL, key_list);
+
+  /* Iterate through all errors to match */
+	matched = FALSE;
+	cur_index = 1;
+	ret = 0;
+	while ( result && !matched &&
+		(action=sieve_result_iterate_next(rictx, &keep)) != NULL ) {
+		const char *act_name;
+
+		if ( keep )
+			act_name = "keep";
+		else
+			act_name = ( action == NULL || action->def == NULL ||
+				action->def->name == NULL ) ? "" : action->def->name;
+
+		if ( index == 0 || index == cur_index ) {
+			if ( (ret=sieve_match_value(mctx, act_name, strlen(act_name))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+		}
+
+		matched = ret > 0;
+		cur_index++;
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(&mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
+
+
Index: b/sieve/src/testsuite/tst-test-script-compile.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/tst-test-script-compile.c
@@ -0,0 +1,147 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-script.h"
+
+/*
+ * Test_script_compile command
+ *
+ * Syntax:
+ *   test_script_compile <scriptpath: string>
+ */
+
+static bool tst_test_script_compile_validate
+	(struct sieve_validator *valdtr, struct sieve_command *cmd);
+static bool tst_test_script_compile_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def tst_test_script_compile = {
+	"test_script_compile",
+	SCT_TEST,
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_test_script_compile_validate,
+	tst_test_script_compile_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static bool tst_test_script_compile_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_script_compile_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_script_compile_operation = {
+	"TEST_SCRIPT_COMPILE",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_SCRIPT_COMPILE,
+	tst_test_script_compile_operation_dump,
+	tst_test_script_compile_operation_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool tst_test_script_compile_validate
+(struct sieve_validator *valdtr ATTR_UNUSED, struct sieve_command *tst)
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "script", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(valdtr, tst, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+
+static bool tst_test_script_compile_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_script_compile_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_test_script_compile_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "TEST_SCRIPT_COMPILE:");
+	sieve_code_descend(denv);
+
+	if ( !sieve_opr_string_dump(denv, address, "script") )
+		return FALSE;
+
+	return TRUE;
+}
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_script_compile_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *script_name;
+	const char *script_path;
+	bool result = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+	if ( !sieve_opr_string_read(renv, address, &script_name) ) {
+		sieve_runtime_trace_error(renv, "invalid script name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "TEST COMPILE: %s", str_c(script_name));
+
+	script_path = sieve_script_dirpath(renv->script);
+	if ( script_path == NULL )
+		return SIEVE_EXEC_FAILURE;
+
+	script_path = t_strconcat(script_path, "/", str_c(script_name), NULL);
+
+	/* Attempt script compile */
+
+	result = testsuite_script_compile(script_path);
+
+	/* Set result */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
Index: b/sieve/src/testsuite/tst-test-script-run.c
===================================================================
--- /dev/null
+++ b/sieve/src/testsuite/tst-test-script-run.c
@@ -0,0 +1,193 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve.h"
+
+#include "testsuite-common.h"
+#include "testsuite-script.h"
+#include "testsuite-result.h"
+
+/*
+ * Test_script_run command
+ *
+ * Syntax:
+ *   test_script_run
+ */
+
+static bool tst_test_script_run_registered
+(struct sieve_validator *validator, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg);
+static bool tst_test_script_run_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command *cmd);
+
+const struct sieve_command_def tst_test_script_run = {
+	"test_script_run",
+	SCT_TEST,
+	0, 0, FALSE, FALSE,
+	tst_test_script_run_registered,
+	NULL, NULL,
+	tst_test_script_run_generate,
+	NULL
+};
+
+/*
+ * Operation
+ */
+
+static bool tst_test_script_run_operation_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_test_script_run_operation_execute
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation_def test_script_run_operation = {
+	"test_script_run",
+	&testsuite_extension,
+	TESTSUITE_OPERATION_TEST_SCRIPT_RUN,
+	tst_test_script_run_operation_dump,
+	tst_test_script_run_operation_execute
+};
+
+/*
+ * Tagged arguments
+ */
+
+/* Codes for optional arguments */
+
+enum cmd_vacation_optional {
+	OPT_END,
+	OPT_APPEND_RESULT
+};
+
+/* Tags */
+
+static const struct sieve_argument_def append_result_tag = {
+	"append_result",
+	NULL, NULL, NULL, NULL, NULL
+};
+
+static bool tst_test_script_run_registered
+(struct sieve_validator *validator, const struct sieve_extension *ext,
+	struct sieve_command_registration *cmd_reg)
+{
+	sieve_validator_register_tag
+		(validator, cmd_reg, ext, &append_result_tag, OPT_APPEND_RESULT);
+
+	return TRUE;
+}
+
+
+/*
+ * Code generation
+ */
+
+static bool tst_test_script_run_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command *tst)
+{
+	sieve_operation_emit(cgenv->sbin, tst->ext, &test_script_run_operation);
+
+	return sieve_generate_arguments(cgenv, tst, NULL);
+}
+
+/*
+ * Code dump
+ */
+
+static bool tst_test_script_run_operation_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 1;
+
+	sieve_code_dumpf(denv, "TEST_SCRIPT_RUN");
+	sieve_code_descend(denv);
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) )
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_APPEND_RESULT:
+				sieve_code_dumpf(denv, "append_result");
+				break;
+
+			default:
+				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+
+/*
+ * Intepretation
+ */
+
+static int tst_test_script_run_operation_execute
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool append_result = FALSE;
+	int opt_code = 1;
+	bool result = TRUE;
+
+	/*
+	 * Read operands
+	 */
+
+	/* Optional operands */
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_APPEND_RESULT:
+				append_result = TRUE;
+				break;
+			default:
+				sieve_runtime_trace_error(renv,
+					"unknown optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	/* Reset result object */
+	if ( !append_result )
+		testsuite_result_reset(renv);
+
+	/* Run script */
+	result = testsuite_script_run(renv);
+
+	/* Indicate test status */
+	sieve_interpreter_set_test_result(renv->interp, result);
+
+	return SIEVE_EXEC_OK;
+}
+
+
+
+
Index: b/sieve/stamp.h.in
===================================================================
--- /dev/null
+++ b/sieve/stamp.h.in
@@ -0,0 +1 @@
+
Index: b/sieve/tests/address.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/address.svtest
@@ -0,0 +1,111 @@
+require "vnd.dovecot.testsuite";
+
+/*
+ * If an address is not syntactically valid, then it will not be matched
+ * by tests specifying ":localpart" or ":domain".
+ */
+
+test_set "message" text:
+From: stephan@
+To: @rename-it.nl
+Cc: nonsense
+Resent-To:
+Subject: Invalid addresses
+
+Test.
+.
+;
+
+test "Invalid single addresses" {
+	if address :localpart "from" "stephan" {
+		test_fail ":localpart matched invalid address";
+	}
+
+	if address :domain "to" "rename-it.nl" {
+		test_fail ":domain matched invalid address";
+	}
+
+	if not address :is :all "resent-to" "" {
+		test_fail ":all failed to match empty address";
+	}
+
+	if not address :is :all "cc" "nonsense" {
+		test_fail ":all failed to match invalid address";
+	}
+}
+
+/*
+ * Errors in address lists
+ */
+
+test_set "message" text:
+From: stephan@
+To: nico@vestingbar.nl, @rename-it.nl
+Cc: stephan@rename-it.nl, nonsense
+Subject: Invalid addresses
+
+Test.
+.
+;
+
+test "Invalid address list" {
+	if address :is :localpart "to" "" {
+		test_fail ":localpart matched invalid address";
+	}
+
+	if address :is :domain "to" "rename-it.nl" {
+		test_fail ":domain matched invalid address";
+	}
+}
+
+/*
+ * Undisclosed recipients
+ */
+
+test_set "message" text:
+From: stephan@
+To: undisclosed-recipients:;
+Subject: Invalid addresses
+
+Test.
+.
+;
+
+test "Undisclosed recipients" {
+    if address :is :domain "to" "undisclosed-recipients:;" {
+        test_fail ":domain matched group name";
+    }
+
+    if address :is :localpart "to" "undisclosed-recipients:;" {
+        test_fail ":localpart matched group name";
+    }
+}
+
+/*
+ * Strange
+ */
+
+test_set "message" text:
+From: SPAM@MYDOMAIN
+To: stephan@renane-it.nl
+Subject: Spam
+
+Spam!
+.
+;
+
+test "Questionable address" {
+	if address :domain :is "from" "MYDOMAIN" {
+		if address :localpart :is "from" "SPAM" {
+
+		} elsif header :contains "subject" "Cron" {
+			test_fail "message erroneously recognized as cron";
+		} else {
+			test_fail "message erroneously recognized as normal";
+		}
+	} else {
+		test_fail "message domain not recognized";
+	}
+}
+
+
Index: b/sieve/tests/comparators/core.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/comparators/core.svtest
@@ -0,0 +1,65 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Cc: frop@example.com
+To: test@dovecot.org
+X-A: This is a TEST header
+Subject: Test Message
+
+Test!
+.
+;
+
+# Comparator Tests
+
+test "CMP-octet-CONTAINS" {
+	if not header :contains :comparator "i;octet" "X-A" "TEST" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-octet-NOTCONTAINS" {
+	if header :contains :comparator "i;octet" "X-A" "test" {
+		test_fail "should not have matched";
+	}
+}
+
+test "CMP-octet-MATCH" {
+	if not header :matches :comparator "i;octet" "X-A" "This*TEST*r" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-octet-NOTMATCH" {
+	if header :matches :comparator "i;octet" "X-A" "ThIs*tEsT*R" {
+		test_fail "should not have matched";
+	}
+}
+
+test "CMP-ascii-casemap-CONTAINS-1" {
+	if not header :contains :comparator "i;ascii-casemap" "X-A" "TEST" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-ascii-casemap-CONTAINS-2" {
+	if not header :contains :comparator "i;ascii-casemap" "X-A" "test" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-ascii-casemap-MATCH-1" {
+	if not header :matches :comparator "i;ascii-casemap" "X-A" "This*TEST*r" {
+		test_fail "should have matched";
+	}
+}
+
+test "CMP-ascii-casemap-MATCH-2" {
+	if not header :matches :comparator "i;ascii-casemap" "X-A" "ThIs*tEsT*R" {
+		test_fail "should have matched";
+	}
+}
+
+
+
Index: b/sieve/tests/compile/compile.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/compile.svtest
@@ -0,0 +1,16 @@
+require "vnd.dovecot.testsuite";
+
+# Just test whether valid scripts will compile without problems
+
+test "Trivial" {
+	if not test_script_compile "trivial.sieve" {
+		test_fail "could not compile";
+	}
+}
+
+test "Redirect" {
+	if not test_script_compile "redirect.sieve" {
+		test_fail "could not compile";
+	}
+}
+
Index: b/sieve/tests/compile/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors.svtest
@@ -0,0 +1,368 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Errors triggered in the compiled scripts are pretty reduntant over the
+ * tested commands, but we want to be thorough.
+ */
+
+/*
+ * Lexer errors
+ */
+
+test "Lexer errors (FIXME: count only)" {
+    if test_script_compile "errors/lexer.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "10" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Parser errors
+ */
+
+test "Parser errors (FIXME: count only)" {
+    if test_script_compile "errors/parser.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "9" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Header test
+ */
+
+test "Header errors" {
+	if test_script_compile "errors/header.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "10" {
+		test_fail "wrong number of errors reported";
+	}
+
+	if not test_error :index 1 :matches
+		"unknown * ':all' for * header test *" {
+		test_fail "error 1 is invalid";
+	}
+
+	if not test_error :index 2 :matches
+		"*header test * string list * 1 (header names), but * number *" {
+		test_fail "error 2 is invalid";
+	}
+
+	if not test_error :index 3 :matches
+		"*header test * string list * 2 (key list), * number *" {
+		test_fail "error 3 is invalid";
+	}
+
+	if not test_error :index 4 :matches
+		"* unexpected tagged argument ':tag' while *" {
+		test_fail "error 4 is invalid";
+	}
+
+	if not test_error :index 5 :matches
+		"* header test requires 2 *, but 1 *" {
+		test_fail "error 5 is invalid";
+	}
+
+	if not test_error :index 6 :matches
+		"* header test requires 2 *, but 0 *" {
+		test_fail "error 6 is invalid";
+	}
+
+	if not test_error :index 7 :matches
+		"*header test accepts no sub-tests* specified*" {
+		test_fail "error 7 is invalid";
+	}
+
+	if not test_error :index 8 :matches
+		"* use test 'header' * command*" {
+		test_fail "error 8 is invalid";
+	}
+
+	if not test_error :index 9 :matches
+		"* use test 'header' * command*" {
+		test_fail "error 9 is invalid";
+	}
+
+	if test_error :index 4 :contains "radish" {
+		test_fail "error test matched nonsense";
+	}
+}
+
+/*
+ * Address test
+ */
+
+
+test "Address errors" {
+	if test_script_compile "errors/address.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "9" {
+		test_fail "wrong number of errors reported";
+	}
+
+	if not test_error :index 1 :matches
+		"*unknown * ':nonsense' * address test*" {
+		test_fail "error 1 is invalid";
+	}
+
+	if not test_error :index 2 :matches
+		"*address test expects *string list * 1 (header list),* number * found*" {
+		test_fail "error 2 is invalid";
+	}
+
+	if not test_error :index 3 :matches
+		"*address test expects *string list * 2 (key list),* number * found*" {
+		test_fail "error 3 is invalid";
+	}
+
+	if not test_error :index 4 :matches
+		"*unexpected *':is' * address test*" {
+		test_fail "error 4 is invalid";
+	}
+
+	if not test_error :index 5 :matches
+		"*address test * 2 positional arg*, but 1*" {
+		test_fail "error 5 is invalid";
+	}
+
+	if not test_error :index 6 :matches
+		"*address test * 2 positional arg*, but 0*" {
+		test_fail "error 6 is invalid";
+	}
+
+	if not test_error :index 7 :matches
+		"*'frop' *not allowed *address test*" {
+		test_fail "error 7 is invalid";
+	}
+
+	if not test_error :index 8 :matches
+		"*'frop' *not allowed *address test*" {
+		test_fail "error 8 is invalid";
+	}
+
+	if test_error :index 23 :contains "radish" {
+		test_fail "error test matched nonsense";
+	}
+}
+
+/*
+ * If command
+ */
+
+test "If errors (FIXME: count only)" {
+	if test_script_compile "errors/if.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "12" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+/*
+ * Require command
+ */
+
+test "Require errors (FIXME: count only)" {
+	if test_script_compile "errors/require.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "15" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+/*
+ * Size test
+ */
+
+test "Size errors (FIXME: count only)" {
+    if test_script_compile "errors/size.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "7" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Envelope test
+ */
+
+test "Envelope errors (FIXME: count only)" {
+    if test_script_compile "errors/envelope.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Stop command
+ */
+
+test "Stop errors (FIXME: count only)" {
+    if test_script_compile "errors/stop.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "9" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Keep command
+ */
+
+test "Keep errors (FIXME: count only)" {
+    if test_script_compile "errors/keep.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * ADDRESS-PART errors
+ */
+
+test "ADDRESS-PART errors (FIXME: count only)" {
+    if test_script_compile "errors/address-part.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * MATCH-TYPE errors
+ */
+
+test "MATCH-TYPE errors (FIXME: count only)" {
+    if test_script_compile "errors/match-type.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Encoded-character errors
+ */
+
+test "Encoded-character errors (FIXME: count only)" {
+    if test_script_compile "errors/encoded-character.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Outgoing address errors
+ */
+
+test "Outgoing address errors (FIXME: count only)" {
+    if test_script_compile "errors/out-address.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "15" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+
+/*
+ * Tagged argument errors
+ */
+
+test "Tagged argument errors (FIXME: count only)" {
+    if test_script_compile "errors/tag.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+        test_fail "wrong number of errors reported";
+    }
+}
+
+/*
+ * Typos
+ */
+
+test "Typos" {
+	if test_script_compile "errors/typos.sieve" {
+		test_fail "compile should have failed.";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "6" {
+		test_fail "wrong number of errors reported";
+	}
+
+	if not test_error :index 1 :matches
+		"missing semicolon * fileinto *" {
+		test_fail "error 1 is invalid";
+	}
+
+	if not test_error :index 2 :matches
+		"*fileinto command * no *tests* specified*" {
+		test_fail "error 2 is invalid";
+	}
+
+	if not test_error :index 3 :matches
+		"missing semicolon * fileinto *" {
+		test_fail "error 3 is invalid";
+	}
+
+	if not test_error :index 4 :matches
+		"*address test requires 2 * 0 * specified" {
+		test_fail "error 4 is invalid";
+	}
+
+	if not test_error :index 5 :matches
+		"missing colon *matches* tag * address test" {
+		test_fail "error 5 is invalid";
+	}
+}
+
+
+/*
+ * Unsupported language features
+ */
+
+test "Unsupported language features (FIXME: count only)" {
+    if test_script_compile "errors/unsupported.sieve" {
+        test_fail "compile should have failed.";
+    }
+
+    if not test_error :count "eq" :comparator "i;ascii-numeric" "4" {
+        test_fail "wrong number of errors reported";
+    }
+}
Index: b/sieve/tests/compile/errors/address-part.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/address-part.sieve
@@ -0,0 +1,17 @@
+/*
+ * Address part errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+# Duplicate address part (1)
+if address :all :comparator "i;octet" :domain "from" "STEPHAN" {
+
+	# Duplicate address part (2)
+	if address :domain :localpart :comparator "i;octet" "from" "drunksnipers.com" {
+		keep;
+	}
+
+	stop;
+}
+
Index: b/sieve/tests/compile/errors/address.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/address.sieve
@@ -0,0 +1,71 @@
+require "comparator-i;ascii-numeric";
+
+/*
+ * Address test errors
+ *
+ * Total count: 8 (+1 = 9)
+ */
+
+/*
+ * Command structure
+ */
+
+# Invalid tag
+if address :nonsense :comparator "i;ascii-casemap" :localpart "From" "nico" {
+	discard;
+}
+
+# Invalid first argument
+if address :is :comparator "i;ascii-numeric" :localpart 45 "nico" {
+	discard;
+}
+
+# Invalid second argument
+if address :is :comparator "i;ascii-numeric" :localpart "From" 45 {
+	discard;
+}
+
+# Invalid second argument
+if address :comparator "i;ascii-numeric" :localpart "From" :is {
+	discard;
+}
+
+# Missing second argument
+if address :is :comparator "i;ascii-numeric" :localpart "From" {
+	discard;
+}
+
+# Missing arguments
+if address :is :comparator "i;ascii-numeric" :localpart {
+	discard;
+}
+
+# Not an error
+if address :localpart :is :comparator "i;ascii-casemap" "from" ["frop", "frop"] {
+	discard;
+}
+
+/*
+ * Specified headers must contain addresses
+ */
+
+# Invalid header
+if address :is "frop" "frml" {
+	keep;
+}
+
+# Not an error
+if address :is "reply-to" "frml" {
+	keep;
+}
+
+# Invalid header (#2)
+if address :is ["to", "frop"] "frml" {
+	keep;
+}
+
+# Not an error
+if address :is ["to", "reply-to"] "frml" {
+	keep;
+}
+
Index: b/sieve/tests/compile/errors/encoded-character.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/encoded-character.sieve
@@ -0,0 +1,23 @@
+/*
+ * Encoded-character errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+require "encoded-character";
+require "fileinto";
+
+# Invalid unicode character (1)
+fileinto "INBOX.${unicode:200000}";
+
+# Not an error
+fileinto "INBOX.${unicode:200000";
+
+# Invalid unicode character (2)
+fileinto "INBOX.${Unicode:DF01}";
+
+# Not an error
+fileinto "INBOX.${Unicode:DF01";
+
+
+
Index: b/sieve/tests/compile/errors/envelope.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/envelope.sieve
@@ -0,0 +1,23 @@
+/*
+ * Envelope test errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+require "envelope";
+
+# Not an error
+if envelope :is "to" "frop@rename-it.nl" {
+}
+
+# Unknown envelope part (1)
+if envelope :is "frop" "frop@rename-it.nl" {
+}
+
+# Not an error
+if envelope :is ["to","from"] "frop@rename-it.nl" {
+}
+
+# Unknown envelope part (2)
+if envelope :is ["to","frop"] "frop@rename-it.nl" {
+}
Index: b/sieve/tests/compile/errors/header.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/header.sieve
@@ -0,0 +1,57 @@
+require "comparator-i;ascii-numeric";
+
+/*
+ * Compile errors for the header test
+ *
+ * Total errors: 9 (+1 validation failed msg = 10)
+ */
+
+# Unknown tagged argument
+if header :all :comparator "i;ascii-casemap" "From" "nico" {
+	keep;
+}
+
+# Wrong first argument
+if header :is :comparator "i;ascii-numeric" 45 "nico" {
+	keep;
+}
+
+# Wrong second argument
+if header :is :comparator "i;ascii-numeric" "From" 45 {
+	discard;
+}
+
+# Wrong second argument
+if header :is :comparator "i;ascii-numeric" "From" :tag {
+	stop;
+}
+
+# Missing second argument
+if header :is :comparator "i;ascii-numeric" "From" {
+	stop;
+}
+
+# Missing arguments
+if header :is :comparator "i;ascii-numeric" {
+	keep;
+}
+
+# Not an error
+if header :is :comparator "i;ascii-casemap" "frop" ["frop", "frop"] {
+	discard;
+}
+
+# Spurious sub-test
+if header "frop" "frop" true {
+	discard;
+}
+
+# Test used as command with block
+header "frop" "frop" {
+    discard;
+}
+
+# Test used as command
+header "frop" "frop";
+
+
Index: b/sieve/tests/compile/errors/if.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/if.sieve
@@ -0,0 +1,78 @@
+/*
+ * If command errors
+ *
+ * Total errors: 11 (+1 = 12)
+ */
+
+# Spurious argument
+if "frop" true {}
+
+# Spurious argument
+elsif "frop" true {}
+
+# Spurious string list
+if [ "false", "false", "false" ] false {
+	stop;
+}
+
+# No block
+if true;
+
+# No test
+if {
+	keep;
+}
+
+# Spurious test list
+if ( false, false, true ) {
+	keep;
+}
+
+stop;
+
+# If-less else
+else {
+	keep;
+}
+
+# Not an error
+if true {
+	keep;
+}
+
+stop;
+
+# If-less if structure (should produce only one error)
+elsif true {
+	keep;
+}
+elsif true {
+	keep;
+}
+else {
+}
+
+# Elsif after else
+if true {
+	keep;
+} else {
+	stop;
+} elsif true {
+	stop;
+}
+
+# If used as test
+if if true {
+}
+
+# Else if in stead of elsif
+
+if true {
+	stop;
+} else if false {
+	keep;
+}
+
+
+
+
Index: b/sieve/tests/compile/errors/keep.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/keep.sieve
@@ -0,0 +1,14 @@
+/*
+ * Keep errors
+ *
+ * Total erors: 2 (+1 = 3)
+ */
+
+# Spurious string argument
+keep "frop";
+
+# Spurious test
+keep true;
+
+# Not an error
+keep;
Index: b/sieve/tests/compile/errors/lexer.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/lexer.sieve
@@ -0,0 +1,71 @@
+/*
+ * Lexer tests
+ *
+ * Total errors: 7 (+1 = 8)
+ */
+
+/*
+ * Number limits
+ */
+
+# Number too large
+if size :under 4294967300 {
+	stop;
+}
+
+# Number too large
+if size :under 4294967296 {
+	stop;
+}
+
+# Number too large
+if size :over 35651584k {
+	stop;
+}
+
+# Number too large
+if size :over 34816M {
+	stop;
+}
+
+# Number too large
+if size :over 34G {
+	stop;
+}
+
+# Number too large
+if size :over 4G {
+	stop;
+}
+
+# Number far too large
+if size :over 49834598293485814273947921734981723971293741923 {
+	stop;
+}
+
+# Not an error
+if size :under 4294967295 {
+	stop;
+}
+
+# Not an error
+if size :under 4294967294 {
+	stop;
+}
+
+# Not an error
+if size :under 1G {
+	stop;
+}
+
+/*
+ * Identifier limits
+ */
+
+if this_is_a_rediculously_long_test_name {
+	stop;
+}
+
+if test :this_is_an_even_more_rediculously_long_tagged_argument_name {
+	stop;
+}
Index: b/sieve/tests/compile/errors/match-type.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/match-type.sieve
@@ -0,0 +1,7 @@
+require "comparator-i;ascii-numeric";
+
+if header :contains :comparator "i;ascii-numeric" "from" "drunksnipers.com" {
+    keep;
+}
+
+keep;
Index: b/sieve/tests/compile/errors/out-address.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/out-address.sieve
@@ -0,0 +1,27 @@
+require "vacation";
+
+# Error
+
+redirect "@wrong.example.com";
+redirect "error";
+redirect "error@";
+redirect "Stephan Bosch error@rename-it.nl";
+redirect "Stephan Bosch <error@rename-it.nl";
+redirect " more error @  example.com  ";
+redirect "@";
+redirect "<>";
+redirect "Error <";
+redirect "Error <stephan";
+redirect "Error <stephan@";
+redirect "stephan@rename-it.nl,tss@iki.fi";
+redirect "stephan@rename-it.nl,%&^&!!~";
+
+vacation :from "Error" "Ik ben er niet.";
+
+# Ok
+
+redirect "Ok Good <stephan@rename-it.nl>";
+redirect "ok@example.com";
+redirect " more  @  example.com  ";
+
+vacation :from "good@voorbeeld.nl" "Ik ben weg!";
Index: b/sieve/tests/compile/errors/parser.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/parser.sieve
@@ -0,0 +1,78 @@
+/*
+ * Parser errors
+ *
+ * Total errors: 8 (+1 = 9)
+ */
+
+# Too many arguments (1)
+frop :this "is" "a" 2 :long "argument" "list" :and :it :should "fail" :during "parsing" :but "it" "should" "be"
+	"recoverable" "." :this "is" "a" 2 :long "argument" "list" :and :it :should "fail" :during "parsing" :but
+	"it" "should" "be" "recoverable" {
+	stop;
+}
+
+# Garbage argument (2)
+friep $$$;
+
+# Deep block nesting (1)
+if true { if true { if true { if true { if true { if true { if true { if true {
+	if true { if true { if true { if true { if true { if true { if true { if true {
+		if true { if true { if true { if true { if true { if true { if true { if true {
+			if true { if true {	if true { if true {	if true { if true { if true { if true {
+				if true { if true { if true { if true { if true { if true { if true { if true {
+					stop;
+				} } } } } } } }
+			} } } } } } } }
+		} } } } } } } }
+	} } } } } } } }
+} } } } } } } }
+
+# Deepest block and too deep test (list) nesting (1)
+if true { if true { if true { if true { if true { if true { if true { if true {
+	if true { if true { if true { if true { if true { if true { if true { if true {
+		if true { if true { if true { if true { if true { if true { if true { if true {
+			if true { if true {	if true { if true {	if true { if true {
+				if
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof (
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof (
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof (
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof (
+					anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof ( anyof (
+						true
+					))))))))
+					))))))))
+					))))))))
+					))))))))
+					))))))))
+				{
+					stop;
+				}
+			} } } } } }
+		} } } } } } } }
+	} } } } } } } }
+} } } } } } } }
+
+# Deepest block and too deep test nesting (1)
+if true { if true { if true { if true { if true { if true { if true { if true {
+	if true { if true { if true { if true { if true { if true { if true { if true {
+		if true { if true { if true { if true { if true { if true { if true { if true {
+			if true { if true {	if true { if true {	if true { if true {
+				if
+					not not not not not not not not
+					not not not not not not not not
+					not not not not not not not not
+					not not not not not not not not
+					not not not not not not not not false
+				{
+					stop;
+				}
+			} } } } } }
+		} } } } } } } }
+	} } } } } } } }
+} } } } } } } }
+
+
+# Garbage command; test wether previous errors were resolved (2)
+frop $$$$;
+
+
Index: b/sieve/tests/compile/errors/require.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/require.sieve
@@ -0,0 +1,42 @@
+/*
+ * Require errors
+ *
+ * Total errors: 11 (+1 = 12)
+ */
+
+# Not an error
+require "fileinto";
+
+# Missing argument
+require;
+
+# Too many arguments
+require "fileinto" "vacation";
+
+# Invalid argument
+require 45;
+
+# Invalid extensions (3 errors)
+require ["_frop", "_friep", "_frml"];
+
+# Core commands required
+require ["redirect", "keep", "discard"];
+
+# Invalid arguments
+require "dovecot.test" true;
+
+# Invalid extension
+require "_frop";
+
+# Spurious command block
+require "fileinto" {
+  keep;
+}
+
+# Nested require
+if true {
+  require "relional";
+}
+
+# Require after other command than require
+require "copy";
Index: b/sieve/tests/compile/errors/size.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/size.sieve
@@ -0,0 +1,47 @@
+/*
+ * Size test errors
+ *
+ * Total errors: 6 (+1 = 7)
+ */
+
+# Used as command (1)
+size :under 23;
+
+# Missing argument (2)
+if size {
+}
+
+# Missing :over/:under (3)
+if size 45 {
+	discard;
+}
+
+# No error
+if size :over 34K {
+	stop;
+}
+
+# No error
+if size :under 34M {
+	stop;
+}
+
+# Conflicting tags (4)
+if size :under :over 34 {
+	keep;
+}
+
+# Duplicate tags (5)
+if size :over :over 45M {
+	stop;
+}
+
+# Wrong argument order (6)
+if size 34M :over {
+	stop;
+}
+
+# No error; but worthy of a warning
+if size :under 0 {
+	stop;
+}
Index: b/sieve/tests/compile/errors/stop.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/stop.sieve
@@ -0,0 +1,33 @@
+/*
+ * Stop command errors
+ *
+ * Total errors: 7 (+1 = 8)
+ */
+
+# Spurious string argument
+stop "frop";
+
+# Spurious number argument
+stop 13;
+
+# Spurious string list argument
+stop [ "frop", "frop" ];
+
+# Spurious test
+stop true;
+
+# Spurious test list
+stop ( true, false );
+
+# Spurious command block
+stop {
+  keep;
+}
+
+# Spurious argument and test
+stop "frop" true {
+  stop;
+}
+
+# Not an error
+stop;
Index: b/sieve/tests/compile/errors/tag.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/tag.sieve
@@ -0,0 +1,16 @@
+/*
+ * Tag errors
+ *
+ * Total errors: 2 (+1 = 3)
+ */
+
+# Unknown tag (1)
+if envelope :isnot :comparator "i;ascii-casemap" :localpart "From" "nico" {
+	discard;
+}
+
+# Spurious tag (1)
+if true :comparator "i;ascii-numeric" {
+  	keep;
+}
+
Index: b/sieve/tests/compile/errors/typos.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/typos.sieve
@@ -0,0 +1,29 @@
+/*
+ * This test is primarily meant to check the compiler's handling of typos
+ * at various locations.
+ */
+
+require "fileinto";
+
+/*
+ * Missing semicolon
+ */
+
+fileinto "frop"
+keep;
+
+/* Other situations */
+
+fileinto "frup"
+true;
+
+fileinto "friep"
+snot;
+
+/*
+ * Forgot tag colon
+ */
+
+if address matches "from" "*frop*" {
+	stop;
+}
Index: b/sieve/tests/compile/errors/unsupported.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/errors/unsupported.sieve
@@ -0,0 +1,39 @@
+/*
+ * Handling of unsupported language features.
+ *
+ *   Total errors: 3 (+1 = 4)
+ */
+
+require "variables";
+require "include";
+require "regex";
+
+/*
+ * Unsupported use of variables
+ */
+
+/* Comparator argument */
+
+set "comp" "i;ascii-numeric";
+
+if address :comparator "${comp}" "from" "stephan@rename-it.nl" {
+	stop;
+}
+
+/* Included script */
+
+set "script" "blacklist";
+
+include "${blacklist}";
+
+/* Variable regexp */
+
+set "match" "(.*)rename-it(.*)";
+
+if address :regex "from" "${match}" {
+	stop;
+}
+
+
+
+
Index: b/sieve/tests/compile/redirect.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/redirect.sieve
@@ -0,0 +1,23 @@
+# Test various white space occurences
+redirect "stephan@rename-it.nl";
+redirect " stephan@rename-it.nl";
+redirect "stephan @rename-it.nl";
+redirect "stephan@ rename-it.nl";
+redirect "stephan@rename-it.nl ";
+redirect " stephan @ rename-it.nl ";
+redirect "Stephan Bosch<stephan@rename-it.nl>";
+redirect " Stephan Bosch<stephan@rename-it.nl>";
+redirect "Stephan Bosch <stephan@rename-it.nl>";
+redirect "Stephan Bosch< stephan@rename-it.nl>";
+redirect "Stephan Bosch<stephan @rename-it.nl>";
+redirect "Stephan Bosch<stephan@ rename-it.nl>";
+redirect "Stephan Bosch<stephan@rename-it.nl >";
+redirect "Stephan Bosch<stephan@rename-it.nl> ";
+redirect "  Stephan Bosch  <  stephan  @  rename-it.nl  > ";
+
+# Test address syntax
+redirect "\"Stephan Bosch\"@rename-it.nl";
+redirect "Stephan.Bosch@rename-it.nl";
+redirect "Stephan.Bosch@ReNaMe-It.Nl";
+redirect "Stephan Bosch <stephan@rename-it.nl>";
+
Index: b/sieve/tests/compile/trivial.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/trivial.sieve
@@ -0,0 +1,17 @@
+# Commands must be case-insensitive
+keep;
+Keep;
+KEEP;
+discard;
+DisCaRD;
+
+# Tags must be case-insensitive
+if size :UNDER 34 {
+}
+
+if header :Is "from" "tukker@rename-it.n" {
+}
+
+# Numbers must be case-insensitive
+if anyof( size :UNDER 34m, size :oVeR 50M ) {
+}
Index: b/sieve/tests/compile/warnings.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/warnings.svtest
@@ -0,0 +1,8 @@
+require "vnd.dovecot.testsuite";
+
+test "EOF Warnings" {
+    if not test_script_compile "warnings/eof.sieve" {
+        test_fail "compile should have succeeded.";
+    }
+}
+
Index: b/sieve/tests/compile/warnings/eof.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/warnings/eof.sieve
@@ -0,0 +1,2 @@
+keep;
+# Kept
\ No newline at end of file
Index: b/sieve/tests/compile/warnings/invalid-headers.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/compile/warnings/invalid-headers.sieve
@@ -0,0 +1,11 @@
+if header "from:" "frop@rename-it.nl" {
+	stop;
+}
+
+if address "from:" "frop@rename-it.nl" {
+	stop;
+}
+
+if exists "from:" {
+	stop;
+}
Index: b/sieve/tests/control-structures.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/control-structures.svtest
@@ -0,0 +1,149 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: test@dovecot.org
+Subject: Test
+
+Test!
+.
+;
+
+test "IF-true" {
+	if true {
+	} else {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "IF-false" {
+	if false {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "ELSEIF-true" {
+	if false {
+		test_fail "executed wrong alternative (if)";
+	} elsif true {
+	} else {
+		test_fail "executed wrong alternative (else)";
+	}
+}
+
+test "ELSEIF-false" {
+	if false {
+		test_fail "executed wrong alternative (if)";
+	} elsif false {
+		test_fail "executed wrong alternative (elsif)";
+	} else {
+	}
+}
+
+test "IF-address-true" {
+	if address :is "from" "stephan@rename-it.nl" {
+	} else {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "IF-address-false" {
+	if address :is "from" "tss@iki.fi" {
+		test_fail "executed wrong alternative";
+	}
+}
+
+test "ELSEIF-address-true" {
+	if address :is "from" "tss@iki.fi" {
+		test_fail "executed wrong alternative (if)";
+	} elsif address :is "from" "stephan@rename-it.nl" {
+	} else {
+		test_fail "executed wrong alternative (else)";
+	}
+}
+
+test "ELSEIF-address-false" {
+	if address :is "from" "tss@iki.fi" {
+		test_fail "executed wrong alternative (if)";
+	} elsif address :is "to" "stephan@rename-it.nl" {
+		test_fail "executed wrong alternative (elsif)";
+	} else {
+	}
+}
+
+test "IF-nesting-static" {
+	if true {
+		if true {
+			if false {
+				test_fail "chose wrong outcome: true->true->false";
+			} else {
+			}
+		} else {
+			test_fail "chose wrong outcome: true->false";
+		}
+	} elsif true {
+		if false {
+			test_fail "chose wrong outcome: false->true->false";
+		} elsif true {
+			test_fail "chose wrong outcome: false->true->true";
+		}
+	} else {
+		test_fail "chose wrong outcome: false->false";
+	}
+}
+
+test "ALLOF-ANYOF-static" {
+	if allof ( true, true, true, true, anyof (false, false, true, false) ) {
+		if anyof( allof(false, false), allof(false, true), allof(true, false) ) {
+			test_fail "chose wrong outcome: true->true";
+		} elsif allof( anyof(false, true), true, anyof(true, false), anyof(true, true)) {
+
+		} else {
+			test_fail "chose wrong outcome: true->false->false";
+		}
+	} else {
+		test_fail "chose wrong outcome: false";
+	}
+}
+
+test "ALLOF-ANYOF-single" {
+	# Static
+	if not allof ( true ) {
+		test_fail "allof ( true ) evaluates to false";
+	}
+
+	if allof ( false ) {
+		test_fail "allof ( false ) evaluates to true";
+	}
+
+	if not anyof ( true ) {
+		test_fail "anyof ( true ) evaluates to false";
+	}
+
+	if anyof ( false ) {
+		test_fail "anyof ( false ) evaluates to true";
+	}
+
+	# Dynamic
+	if not allof ( exists "subject" ) {
+        test_fail "allof ( 'true' ) evaluates to false";
+    }
+
+    if allof ( exists "x-nonsense" ) {
+        test_fail "allof ( 'false' ) evaluates to true";
+    }
+
+    if not anyof ( exists "subject" ) {
+        test_fail "anyof ( 'true' ) evaluates to false";
+    }
+
+    if anyof ( exists "x-nonsense" ) {
+        test_fail "anyof ( 'false' ) evaluates to true";
+    }
+}
+
+test "STOP" {
+	stop;
+	test_fail "continued after stop";
+}
+
Index: b/sieve/tests/deprecated/notify/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/deprecated/notify/basic.svtest
@@ -0,0 +1,11 @@
+require "vnd.dovecot.testsuite";
+require "notify";
+
+test "Execute" {
+	/* Test to catch runtime segfaults */
+	notify
+		:message "This is probably very important"
+		:low
+		:method "mailto"
+		:options ["stephan@example.com", "stephan@rename-it.nl"];
+}
Index: b/sieve/tests/deprecated/notify/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/deprecated/notify/errors.svtest
@@ -0,0 +1,13 @@
+require "vnd.dovecot.testsuite";
+require "comparator-i;ascii-numeric";
+require "relational";
+
+test "Invalid :options argument (FIXME: count only)" {
+	if test_script_compile "errors/options.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
Index: b/sieve/tests/deprecated/notify/errors/options.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/deprecated/notify/errors/options.sieve
@@ -0,0 +1,11 @@
+require "notify";
+
+# 1: empty option
+notify :options "";
+
+# 2: invalid address syntax
+notify :options "frop#vestingbar.nl";
+
+# Valid
+notify :options "frop@vestingbar.nl";
+
Index: b/sieve/tests/deprecated/notify/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/deprecated/notify/execute.svtest
@@ -0,0 +1,25 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+
+
+/*
+ * Execution testing (currently just meant to trigger any segfaults)
+ */
+
+test "Duplicate recipients" {
+	if not test_script_compile "execute/duplicates.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if test_result :count "ne" "2" {
+		test_fail "second notify action was discarded entirely";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
Index: b/sieve/tests/deprecated/notify/execute/duplicates.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/deprecated/notify/execute/duplicates.sieve
@@ -0,0 +1,4 @@
+require "notify";
+
+notify :message "Incoming stupidity." :options ["stephan@rename-it.nl", "stephan@drunksnipers.com", "idiot@rename-it.nl"];
+notify :message "There it is." :options ["tss@iki.fi", "stephan@rename-it.nl", "idiot@rename-it.nl", "nico@vestingbar.nl", "stephan@drunksnipers.com"];
Index: b/sieve/tests/deprecated/notify/mailto.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/deprecated/notify/mailto.svtest
@@ -0,0 +1,317 @@
+require "vnd.dovecot.testsuite";
+
+require "notify";
+require "body";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Simple test
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Simple" {
+	notify :method "mailto" :options "stephan@rename-it.nl";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not header :matches "Auto-Submitted" "auto-generated*" {
+		test_fail "auto-submitted header set inappropriately";
+	}
+
+	if not exists "X-Sieve" {
+		test_fail "x-sieve header missing from outgoing message";
+	}
+}
+
+/*
+ * Multiple recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Multiple recipients" {
+	notify :options ["timo@example.com","stephan@dovecot.org","postmaster@vestingbar.nl"];
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not address :is "to" "timo@example.com" {
+		test_fail "first To address missing";
+	}
+
+	test_message :smtp 1;
+
+	if not address :is "to" "stephan@dovecot.org" {
+		test_fail "second To address missing";
+	}
+
+	if not header :matches "Auto-Submitted" "auto-generated*" {
+		test_fail "auto-submitted header not found for second message";
+	}
+
+	test_message :smtp 2;
+
+	if not address :is "to" "postmaster@vestingbar.nl" {
+		test_fail "third To address missing";
+	}
+
+	if not header :matches "Auto-Submitted" "auto-generated*" {
+		test_fail "auto-submitted header not found for third message";
+	}
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "to" "1" {
+		test_fail "too many recipients in To header";
+	}
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "cc" "0" {
+		test_fail "too many recipients in Cc header";
+	}
+}
+
+/*
+ * Duplicate recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Duplicate recipients" {
+	notify :options ["timo@example.com", "stephan@dovecot.org", "stephan@dovecot.org"];
+	notify :options ["timo@example.com", "stephan@rename-it.nl"];
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 2;
+
+	if address "To" "stephan@dovecot.org" {
+		test_fail "duplicate recipient not removed from first message";
+	}
+
+	if address "To" "timo@example.com" {
+		test_fail "duplicate recipient not removed from second message";
+	}
+}
+
+/*
+ * Notifying on automated messages
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Auto-submitted: auto-notify
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Notifying on automated messages" {
+	notify :options "stephan@rename-it.nl";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "notified of auto-submitted message";
+	}
+}
+
+test_result_reset;
+
+test_set "message" text:
+To: nico@vestingbar.nl
+From: stephan@rename-it.nl
+Subject: Test
+
+Test. Test
+Frop!
+.
+;
+
+test "Body; Singular Message" {
+	notify :low :id "frop" :options "stephan@rename-it.nl"
+    	:message text:
+Received interesting message:
+
+$text$
+
+You have been notified.
+.
+;
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not body :raw :contains "Received interesting message" {
+		test_fail "notification has no heading";
+	}
+
+	if not body :raw :contains "You have been notified" {
+		test_fail "notification has no footer";
+	}
+
+	if not allof(
+		body :raw :contains "Test. Test",
+		body :raw :contains "Frop" ) {
+		test_fail "notification has no original message";
+	}
+}
+
+test_result_reset;
+
+test_set "message" text:
+To: nico@vestingbar.nl
+From: stephan@rename-it.nl
+Subject: Test
+
+Test. Test
+Frop!
+.
+;
+
+test "Body; $text[maxsize]$" {
+	notify :low :id "frop" :options "sirius@rename-it.nl"
+    	:message text:
+Received interesting message:
+
+$text[5]$
+
+You have been notified.
+.
+;
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not body :raw :contains "Received interesting message" {
+		test_fail "notification has no heading";
+	}
+
+	if not body :raw :contains "You have been notified" {
+		test_fail "notification has no footer";
+	}
+
+	if anyof(
+		body :raw :contains "Test. Test",
+		body :raw :contains "Frop" ) {
+		test_fail "original message in notification is not truncated";
+	}
+
+	if not body :raw :contains "Test." {
+		test_fail "notification does not contain the required message";
+	}
+}
+
+test_result_reset;
+
+test_set "message" text:
+From: Whomever <whoever@example.com>
+To: Someone <someone@example.com>
+Date: Sat, 10 Oct 2009 00:30:04 +0200
+Subject: whatever
+Content-Type: multipart/mixed; boundary=outer
+
+This is a multi-part message in MIME format.
+
+--outer
+Content-Type: multipart/alternative; boundary=inner
+
+This is a nested multi-part message in MIME format.
+
+--inner
+Content-Type: application/sieve; charset="us-ascii"
+
+keep;
+
+--inner
+Content-Type: text/plain; charset="us-ascii"
+
+Friep!
+
+--inner--
+
+This is the end of the inner MIME multipart.
+
+--outer
+Content-Type: message/rfc822
+
+From: Someone Else
+Subject: hello request
+
+Please say Hello
+
+--outer--
+
+This is the end of the outer MIME multipart.
+.
+;
+
+test "Body; Multipart Message" {
+	notify :low :id "frop" :options "stephan@rename-it.nl"
+    	:message text:
+Received interesting message:
+
+$text$
+
+You have been notified.
+.
+;
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not body :raw :contains "Friep!" {
+		test_fail "notification has incorrect content";
+	}
+}
+
+
+
Index: b/sieve/tests/execute/actions.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/actions.svtest
@@ -0,0 +1,80 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test_set "message" text:
+To: nico@vestingbar.nl
+From: stephan@rename-it.nl
+Subject: Test
+
+Test.
+.
+;
+
+test_mailbox :create "INBOX.VB";
+test_mailbox :create "INBOX.backup";
+
+test "Fileinto" {
+	if not test_script_compile "actions/fileinto.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of actions in result";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if not test_result :index 2 "store" {
+		test_fail "second action is not 'store'";
+	}
+
+	if not test_result :index 3 "keep" {
+		test_fail "third action is not 'keep'";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "Redirect" {
+	if not test_script_compile "actions/redirect.sieve" {
+		test_fail "compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "execute failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "4" {
+		test_fail "wrong number of actions in result";
+	}
+
+	if not test_result :index 1 "redirect" {
+		test_fail "first action is not 'redirect'";
+	}
+
+	if not test_result :index 2 "keep" {
+		test_fail "second action is not 'keep'";
+	}
+
+	if not test_result :index 3 "redirect" {
+		test_fail "third action is not 'redirect'";
+	}
+
+	if not test_result :index 4 "redirect" {
+		test_fail "fourth action is not 'redirect'";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
Index: b/sieve/tests/execute/actions/fileinto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/actions/fileinto.sieve
@@ -0,0 +1,17 @@
+require "fileinto";
+
+/* Three store actions */
+
+if address :contains "to" "vestingbar" {
+	/* #1 */
+	fileinto "INBOX.VB";
+}
+
+/* #2 */
+fileinto "INBOX.backup";
+
+/* #3 */
+keep;
+
+/* Duplicate of keep */
+fileinto "INBOX";
Index: b/sieve/tests/execute/actions/redirect.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/actions/redirect.sieve
@@ -0,0 +1,17 @@
+if address :contains "to" "vestingbar" {
+	/* #1 */
+	redirect "stephan@example.com";
+
+	/* #2 */
+	keep;
+}
+
+/* #3 */
+redirect "stephan@rename-it.nl";
+
+/* #4 */
+redirect "nico@example.nl";
+
+/* Duplicates */
+redirect "Stephan Bosch <stephan@example.com>";
+keep;
Index: b/sieve/tests/execute/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors.svtest
@@ -0,0 +1,82 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Action conflicts: reject <-> fileinto" {
+	if not test_script_compile "errors/conflict-reject-fileinto.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
+test "Action conflicts: reject <-> keep" {
+	if not test_script_compile "errors/conflict-reject-keep.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
+test "Action conflicts: reject <-> redirect" {
+	if not test_script_compile "errors/conflict-reject-redirect.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
+test "Action limit" {
+	if not test_script_compile "errors/actions-limit.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+
+	if not test_error :index 1 :contains "total number of actions exceeds policy limit"{
+		test_fail "unexpected error reported";
+	}
+}
+
+test "Redirect limit" {
+	if not test_script_compile "errors/redirect-limit.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+
+	if not test_error :index 1 :contains "number of redirect actions exceeds policy limit"{
+		test_fail "unexpected error reported";
+	}
+}
Index: b/sieve/tests/execute/errors/action-duplicates.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors/action-duplicates.sieve
@@ -0,0 +1,4 @@
+require "reject";
+
+reject "Message is not appreciated.";
+reject "No, really, it is not appreciated.";
Index: b/sieve/tests/execute/errors/actions-limit.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors/actions-limit.sieve
@@ -0,0 +1,35 @@
+require "fileinto";
+
+fileinto "box1";
+fileinto "box2";
+fileinto "box3";
+fileinto "box4";
+fileinto "box5";
+fileinto "box6";
+fileinto "box7";
+fileinto "box8";
+fileinto "box9";
+fileinto "box10";
+fileinto "box11";
+fileinto "box12";
+fileinto "box13";
+fileinto "box14";
+fileinto "box15";
+fileinto "box16";
+fileinto "box17";
+fileinto "box18";
+fileinto "box19";
+fileinto "box20";
+fileinto "box21";
+fileinto "box22";
+fileinto "box23";
+fileinto "box24";
+fileinto "box25";
+fileinto "box26";
+fileinto "box27";
+fileinto "box28";
+redirect "address1@example.com";
+redirect "address2@example.com";
+redirect "address3@example.com";
+redirect "address4@example.com";
+keep;
Index: b/sieve/tests/execute/errors/conflict-reject-fileinto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors/conflict-reject-fileinto.sieve
@@ -0,0 +1,5 @@
+require "reject";
+require "fileinto";
+
+reject "No nonsense in my mailbox.";
+fileinto "Spam";
Index: b/sieve/tests/execute/errors/conflict-reject-keep.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors/conflict-reject-keep.sieve
@@ -0,0 +1,4 @@
+require "reject";
+
+reject "I am not interested in your nonsense.";
+keep;
Index: b/sieve/tests/execute/errors/conflict-reject-redirect.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors/conflict-reject-redirect.sieve
@@ -0,0 +1,4 @@
+require "reject";
+
+reject "I am not interested in your nonsense.";
+redirect "frop@example.com";
Index: b/sieve/tests/execute/errors/redirect-limit.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/errors/redirect-limit.sieve
@@ -0,0 +1,5 @@
+redirect "address1@example.com";
+redirect "address2@example.com";
+redirect "address3@example.com";
+redirect "address4@example.com";
+redirect "address5@example.com";
Index: b/sieve/tests/execute/examples.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/examples.svtest
@@ -0,0 +1,115 @@
+require "vnd.dovecot.testsuite";
+
+/* Compile and execute all example scripts to trigger
+ * any Segfaults. No message is set and no results are checked.
+ */
+
+test "Elvey example" {
+	if not test_script_compile "../../examples/elvey.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "elvey";
+	test_binary :load "elvey";
+
+	if not test_script_run { }
+}
+
+test "M. Johnson example" {
+	if not test_script_compile "../../examples/mjohnson.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "mjohnson";
+	test_binary :load "mjohnson";
+
+	if not test_script_run { }
+}
+
+test "RFC 3028 example" {
+	if not test_script_compile "../../examples/rfc3028.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "rfc3028";
+	test_binary :load "rfc3028";
+
+	if not test_script_run { }
+}
+
+test "Sieve examples" {
+	if not test_script_compile "../../examples/sieve_examples.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "sieve_examples";
+	test_binary :load "sieve_examples";
+
+	if not test_script_run { }
+}
+
+test "Vivil example" {
+	if not test_script_compile "../../examples/vivil.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "vivil";
+	test_binary :load "vivil";
+
+	if not test_script_run { }
+}
+
+test "Jerry example" {
+	if not test_script_compile "../../examples/jerry.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "jerry";
+	test_binary :load "jerry";
+
+	if not test_script_run { }
+}
+
+test "M. Klose example" {
+	if not test_script_compile "../../examples/mklose.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "mklose";
+	test_binary :load "mklose";
+
+	if not test_script_run { }
+}
+
+test "Sanjay example" {
+	if not test_script_compile "../../examples/sanjay.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "sanjay";
+	test_binary :load "sanjay";
+
+	if not test_script_run { }
+}
+
+test "Relational (RFC5231) example" {
+	if not test_script_compile "../../examples/relational.rfc5231.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "relational";
+	test_binary :load "relational";
+
+	if not test_script_run { }
+}
+
+test "Subaddress (RFC5233) example" {
+	if not test_script_compile "../../examples/subaddress.rfc5233.sieve" {
+		test_fail "could not compile";
+	}
+
+	test_binary :save "subaddress";
+	test_binary :load "subaddress";
+
+	if not test_script_run { }
+}
Index: b/sieve/tests/execute/mailstore.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/mailstore.svtest
@@ -0,0 +1,84 @@
+require "vnd.dovecot.testsuite";
+require "fileinto";
+require "variables";
+require "mailbox";
+
+set "message1" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: First message
+
+Frop
+.
+;
+
+set "message2" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Second message
+
+Frop
+.
+;
+
+set "message3" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Third message
+
+Frop
+.
+;
+
+test "Duplicates" {
+	test_set "message" "${message1}";
+
+	fileinto :create "Folder";
+	fileinto :create "Folder";
+
+	if not test_result_execute {
+		test_fail "failed to execute first result";
+	}
+
+	test_result_reset;
+
+	test_set "message" "${message2}";
+
+	fileinto :create "Folder";
+	fileinto :create "Folder";
+
+	if not test_result_execute {
+		test_fail "failed to execute second result";
+	}
+
+	test_result_reset;
+
+	test_set "message" "${message3}";
+
+	fileinto :create "Folder";
+	fileinto :create "Folder";
+
+	if not test_result_execute {
+		test_fail "failed to execute third result";
+	}
+
+	test_message :folder "Folder" 0;
+
+	if not header :is "subject" "First message" {
+		test_fail "first message incorrect";
+	}
+
+	test_message :folder "Folder" 1;
+
+	if not header :is "subject" "Second message" {
+		test_fail "first message incorrect";
+	}
+
+	test_message :folder "Folder" 2;
+
+	if not header :is "subject" "Third message" {
+		test_fail "first message incorrect";
+	}
+}
+
+
Index: b/sieve/tests/execute/smtp.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/execute/smtp.svtest
@@ -0,0 +1,61 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Frop!
+
+Frop!
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "timo@iki.fi";
+
+test "Redirect" {
+	redirect "cras@iki.fi";
+
+	if not test_result_execute {
+        test_fail "failed to execute redirect";
+    }
+
+    test_message :smtp 0;
+
+    if not address :is "to" "tss@iki.fi" {
+        test_fail "to address incorrect (strange forward)";
+    }
+
+    if not address :is "from" "stephan@rename-it.nl" {
+        test_fail "from address incorrect (strange forward)";
+    }
+
+	if not envelope :is "to" "cras@iki.fi" {
+		test_fail "envelope recipient incorrect";
+	}
+
+	if not envelope :is "from" "sirius@rename-it.nl" {
+		test_fail "envelope sender incorrect";
+	}
+}
+
+test_result_reset;
+
+test "Redirect from <>" {
+
+	test_set "envelope.from" "<>";
+
+	redirect "cras@iki.fi";
+
+	if not test_result_execute {
+        test_fail "failed to execute redirect";
+    }
+
+	if envelope :is "from" "sirius@rename-it.nl" {
+        test_fail "envelope sender incorrect (not changed)";
+    }
+
+	if not envelope :is "from" "" {
+        test_fail "envelope sender incorrect";
+    }
+}
Index: b/sieve/tests/exists.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/exists.svtest
@@ -0,0 +1,42 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.bl
+Subject: Test message
+X-Spam-Status: Not Spam
+Resent-To: nico@vestingbar.nl
+
+Test!
+.
+;
+
+test "EXISTS-one" {
+	if not exists "from" {
+		test_fail "exists test missed from header";
+	}
+
+	if exists "x-nonsense" {
+        test_fail "exists test found non-existant header";
+    }
+}
+
+test "EXISTS-two" {
+    if not exists ["from","to"] {
+        test_fail "exists test missed from or to header";
+    }
+
+    if exists ["from","to","x-nonsense"] {
+        test_fail "exists test found non-existant header";
+    }
+}
+
+test "EXISTS-three" {
+    if not exists ["Subject","X-spam-STATUS","resent-to"] {
+        test_fail "exists test missed from or to header";
+    }
+
+    if exists ["x-spam", "sub", "resent"] {
+        test_fail "exists test found non-existant header";
+    }
+}
Index: b/sieve/tests/extensions/body/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/body/basic.svtest
@@ -0,0 +1,97 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+require "body";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Test message.
+
+Test!
+
+.
+;
+
+/* Empty line
+ *
+ *  RFC 5173:
+ *    'The body test matches content in the body of an email message, that
+ *     is, anything following the first empty line after the header.  (The
+ *     empty line itself, if present, is not considered to be part of the
+ *     body.)'
+ */
+test "The empty line" {
+
+	if not body :raw :is text:
+Test!
+
+.
+	{
+		test_fail "invalid message body extracted (1)";
+	}
+
+	if body :raw :is text:
+
+Test!
+
+.
+	{
+		test_fail "invalid message body extracted (2)";
+	}
+
+	if body :raw :is "Test"
+	{
+		test_fail "body test matches nonsense (3)";
+	}
+}
+
+/* Default comparator and match type
+ *
+ *  RFC 5173:
+ *    'The COMPARATOR and MATCH-TYPE keyword parameters are defined in
+ *     [SIEVE].  As specified in Sections 2.7.1 and 2.7.3 of [SIEVE], the
+ *     default COMPARATOR is "i;ascii-casemap" and the default MATCH-TYPE is
+ *     ":is".'
+ */
+
+test "Defaults" {
+	if anyof ( body :raw "Test", body :raw "*Test*" ) {
+		test_fail "default match type is not :is as is required";
+	}
+
+	if allof( not body :raw :contains "tesT", body :raw :contains "Test" ) {
+		test_fail "default comparator is not i;ascii-casemap as is required";
+	}
+}
+
+/* No body
+ *
+ *  RFC 5173:
+ *    'If a message consists of a header only, not followed by an empty line,
+ *     then that set is empty and all "body" tests return false, including
+ *     those that test for an empty string.  (This is similar to how the
+ *     "header" test always fails when the named header fields aren't present.)'
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: No body is here!
+.
+;
+
+test "No body" {
+	if body :raw :contains "" {
+		test_fail "matched against non-existant body (:contains \"\")";
+	}
+
+	if body :raw :is "" {
+		test_fail "matched against non-existant body (:is \"\")";
+	}
+
+	if body :raw :matches "*" {
+		test_fail "matched against non-existant body (:matches \"*\")";
+	}
+}
Index: b/sieve/tests/extensions/body/content.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/body/content.svtest
@@ -0,0 +1,318 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+require "body";
+
+/*
+ *
+ */
+
+test_set "message" text:
+From: justin@example.com
+To: carl@example.nl
+Subject: Frop
+Content-Type: multipart/mixed; boundary=donkey
+
+This is a multi-part message in MIME format.
+
+--donkey
+Content-Type: text/plain
+
+Plain Text
+
+--donkey
+Content-Type: text/stupid
+
+Stupid Text
+
+--donkey
+Content-Type: text/plain/stupid
+
+Plain Stupid Text
+
+--donkey--
+.
+;
+
+/*
+ * RFC5173, Section 5.2:
+ *  If an individual content type begins or ends with a '/' (slash) or
+ *  contains multiple slashes, then it matches no content types.
+ *  ...
+ */
+
+test "Basic Match" {
+	if not body :content "text/plain" :matches "Plain Text*" {
+		test_fail "failed to match (1)";
+	}
+
+	if not body :content "text/plain" :contains "" {
+		test_fail "failed to match (2)";
+	}
+
+	if not body :content "text/stupid" :contains "" {
+		test_fail "failed to match (3)";
+	}
+}
+
+test "Begin Slash" {
+	if body :content "/plain" :contains "" {
+		test_fail "matched :content \"/plain\"";
+	}
+}
+
+test "End Slash" {
+	if body :content "text/" :contains "" {
+		test_fail "matched :content \"text/\"";
+	}
+}
+
+test "Double Slash" {
+	if body :content "text/plain/stupid" :contains "" {
+		test_fail "matched :content \"text/plain/stupid\"";
+	}
+}
+
+/*
+ *
+ */
+
+test_set "message" text:
+From: justin@example.com
+To: carl@example.nl
+Subject: Frop
+Content-Type: multipart/mixed; boundary=limit
+
+This is a multi-part message in MIME format.
+
+--limit
+Content-Type: text/plain
+
+This is a text message.
+
+--limit
+Content-Type: text/html
+
+<html><body>This is HTML</body></html>
+
+--limit
+Content-Type: application/sieve
+
+keep;
+
+--limit--
+.
+;
+
+/* RFC5173, Section 5.2:
+ *  ...
+ *  Otherwise, if it contains a slash, then it specifies a full
+ *  <type>/<subtype> pair, and matches only that specific content type.
+ *  If it is the empty string, all MIME content types are matched.
+ *  Otherwise, it specifies a <type> only, and any subtype of that type
+ *  matches it.
+ */
+
+test "Full Content Type" {
+	if not body :content "text/plain" :matches "This is a text message.*" {
+		test_fail "failed to match text/plain content";
+	}
+
+	if body :content "text/plain" :matches "<html><body>This is HTML</body></html>*" {
+		test_fail "erroneously matched text/html content";
+	}
+
+	if not body :content "text/html" :matches "<html><body>This is HTML</body></html>*" {
+		test_fail "failed to match text/html content";
+	}
+
+	if body :content "text/html" :matches "This is a text message.*" {
+		test_fail "erroneously matched text/plain content";
+	}
+
+	if body :content "text/html" :matches "This is HTML*" {
+		test_fail "body :content test matched plain text";
+	}
+}
+
+test "Empty Content Type" {
+	if not body :content "" :matches "This is a text message.*" {
+		test_fail "failed to match text/plain content";
+	}
+
+	if not body :content "" :matches "<html><body>This is HTML</body></html>*" {
+		test_fail "failed to match text/html content";
+	}
+
+	if not body :content "" :matches "keep;*" {
+		test_fail "failed to match application/sieve content";
+	}
+
+	if body :content "" :matches "*blurdybloop*" {
+		test_fail "body :content \"\" test matches nonsense";
+	}
+}
+
+test "Main Content Type" {
+	if not body :content "text" :matches "This is a text message.*" {
+		test_fail "failed to match text/plain content";
+	}
+
+	if not body :content "text" :matches "<html><body>This is HTML</body></html>*" {
+		test_fail "failed to match text/html content";
+	}
+
+	if body :content "text" :matches "keep;*" {
+		test_fail "erroneously matched application/sieve content";
+	}
+}
+
+/*
+ *
+ */
+
+test_set "message" text:
+From: Whomever <whoever@example.com>
+To: Someone <someone@example.com>
+Date: Sat, 10 Oct 2009 00:30:04 +0200
+Subject: whatever
+Content-Type: multipart/mixed; boundary=outer
+
+This is a multi-part message in MIME format.
+
+--outer
+Content-Type: multipart/alternative; boundary=inner
+
+This is a nested multi-part message in MIME format.
+
+--inner
+Content-Type: text/plain; charset="us-ascii"
+
+Hello
+
+--inner
+Content-Type: text/html; charset="us-ascii"
+
+<html><body>Hello</body></html>
+
+--inner--
+
+This is the end of the inner MIME multipart.
+
+--outer
+Content-Type: message/rfc822
+
+From: Someone Else
+Subject: hello request
+
+Please say Hello
+
+--outer--
+
+This is the end of the outer MIME multipart.
+.
+;
+
+/* RFC5173, Section 5.2:
+ *
+ *  The search for MIME parts matching the :content specification is
+ *  recursive and automatically descends into multipart and
+ *  message/rfc822 MIME parts.  All MIME parts with matching types are
+ *  searched for the key strings.  The test returns true if any
+ *  combination of a searched MIME part and key-list argument match.
+ */
+
+test "Nested Search" {
+	if not body :content "text/plain" :matches "Hello*" {
+		test_fail "failed to match text/plain content";
+	}
+
+	if body :content "text/plain" :matches "<html><body>Hello</body></html>*" {
+		test_fail "erroneously matched text/html content";
+	}
+
+	if not body :content "text/html" :matches "<html><body>Hello</body></html>*" {
+		test_fail "failed to match text/html content";
+	}
+
+	if body :content "text/html" :matches "Hello*" {
+		test_fail "erroneously matched text/plain content";
+	}
+
+	if not body :content "text" :contains "html" {
+		test_fail "failed match text content (1)";
+	}
+
+	if not body :content "text" :contains "hello" {
+		test_fail "failed match text content (2)";
+	}
+
+	if not body :content "text/plain" :contains "please say hello" {
+		test_fail "failed match nested message content as text/plain";
+	}
+
+	if not body :content "text" :contains "please say hello" {
+		test_fail "failed match nested message content as text/*";
+	}
+
+	if not body :content "text" :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "matched wrong number of \"text/*\" body parts";
+	}
+}
+
+/* RFC5173, Section 5.2:
+ *
+ *  If the :content specification matches a multipart MIME part, only the
+ *  prologue and epilogue sections of the part will be searched for the
+ *  key strings, treating the entire prologue and the entire epilogue as
+ *  separate strings; the contents of nested parts are only searched if
+ *  their respective types match the :content specification.
+ *
+ */
+
+test "Multipart Content" {
+	if not body :content "multipart" :contains
+		"This is a multi-part message in MIME format" {
+		test_fail "missed first multipart body part";
+	}
+
+	if not body :content "multipart" :contains
+		"This is a nested multi-part message in MIME format" {
+		test_fail "missed second multipart body part";
+	}
+
+/* FIXME: FAILS
+
+	if not body :content "multipart" :contains
+		"This is the end of the inner MIME multipart" {
+		test_fail "missed third multipart body part";
+	}
+
+	if not body :content "multipart" :contains
+		"This is the end of the outer MIME multipart." {
+		test_fail "missed fourth multipart body part";
+	}
+
+	if body :content "multipart" :contains "--inner" {
+		test_fail "inner boundary is part of match";
+	}
+
+	if body :content "multipart" :contains "--outer" {
+		test_fail "outer boundary is part of match";
+	}
+*/
+}
+
+/* RFC5173, Section 5.2:
+ *
+ *  If the :content specification matches a message/rfc822 MIME part,
+ *  only the header of the nested message will be searched for the key
+ *  strings, treating the header as a single string; the contents of the
+ *  nested message body parts are only searched if their content type
+ *  matches the :content specification.
+ */
+
+/* FIXME */
+
+
Index: b/sieve/tests/extensions/body/match-values.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/body/match-values.svtest
@@ -0,0 +1,55 @@
+require "vnd.dovecot.testsuite";
+
+require "body";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: s.bosch@utwente.nl
+Subject: Body test
+
+The big bad body test.
+.
+;
+
+# Test whether body test ignores match values
+test "Match values disabled" {
+	if not body :raw :matches "The * bad * test*" {
+		test_fail "should have matched";
+	}
+
+	if anyof (
+		string :is "${1}" "big",
+		string :is "${2}" "body",
+		not string :is "${0}" "",
+		not string :is "${1}" "",
+		not string :is "${2}" "") {
+		test_fail "match values not disabled";
+	}
+}
+
+test "Match values re-enabled" {
+	if not header :matches "from" "*@*" {
+		test_fail "should have matched";
+	}
+
+	if anyof (
+		not string :is "${0}" "stephan@rename-it.nl",
+		not string :is "${1}" "stephan",
+		not string :is "${2}" "rename-it.nl" ) {
+		test_fail "match values not re-enabled properly.";
+	}
+}
+
+test "Match values retained" {
+	if not body :raw :matches "The * bad * test*" {
+		test_fail "should have matched";
+	}
+
+	if anyof (
+		not string :is "${0}" "stephan@rename-it.nl",
+		not string :is "${1}" "stephan",
+		not string :is "${2}" "rename-it.nl" ) {
+		test_fail "match values not retained after body test.";
+	}
+}
Index: b/sieve/tests/extensions/body/raw.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/body/raw.svtest
@@ -0,0 +1,85 @@
+require "vnd.dovecot.testsuite";
+require "body";
+
+test_set "message" text:
+From: Whomever <whoever@example.com>
+To: Someone <someone@example.com>
+Date: Sat, 10 Oct 2009 00:30:04 +0200
+Subject: whatever
+Content-Type: multipart/mixed; boundary=outer
+
+This is a multi-part message in MIME format.
+
+--outer
+Content-Type: multipart/alternative; boundary=inner
+
+This is a nested multi-part message in MIME format.
+
+--inner
+Content-Type: text/plain; charset="us-ascii"
+
+Hello
+
+--inner
+Content-Type: text/html; charset="us-ascii"
+
+<html><body>Hello</body></html>
+
+--inner--
+
+This is the end of the inner MIME multipart.
+
+--outer
+Content-Type: message/rfc822
+
+From: Someone Else
+Subject: hello request
+
+Please say Hello
+
+--outer--
+
+This is the end of the outer MIME multipart.
+.
+;
+
+/*
+ *
+ * RFC 5173:
+ *  The ":raw" transform matches against the entire undecoded body of a
+ *  message as a single item.
+ *
+ *  If the specified body-transform is ":raw", the [MIME] structure of
+ *  the body is irrelevant.  The implementation MUST NOT remove any
+ *  transfer encoding from the message, MUST NOT refuse to filter
+ *  messages with syntactic errors (unless the environment it is part of
+ *  rejects them outright), and MUST treat multipart boundaries or the
+ *  MIME headers of enclosed body parts as part of the content being
+ *  matched against, instead of MIME structures to interpret.
+ */
+
+test "Multipart Boundaries" {
+	if not body :raw :contains "--inner" {
+		test_fail "Raw body does not contain '--inner'";
+	}
+
+	if not body :raw :contains "--outer" {
+		test_fail "Raw body does not contain '--outer'";
+	}
+}
+
+test "Multipart Headers" {
+	if not body :raw :contains "boundary=inner" {
+		test_fail "Raw body does not contain 'boundary=inner'";
+	}
+
+	if not body :raw :contains "rfc822" {
+		test_fail "Raw body does not contain 'rfc822'";
+	}
+}
+
+test "Multipart Content" {
+	if not body :raw :contains "<html><body>Hello</body></html>" {
+		test_fail "Raw body does not contain '<html><body>Hello</body></html>'";
+	}
+}
Index: b/sieve/tests/extensions/date/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/date/basic.svtest
@@ -0,0 +1,41 @@
+require "vnd.dovecot.testsuite";
+require "date";
+require "variables";
+require "relational";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 22 Jul 2009 23:30:14 +0300
+Invalid-Date: Moo, 34 Juul 3060 25:30:42 +6600
+Wanna date?
+.
+;
+
+test "Defaults" {
+	if not date :originalzone "date" "std11" "mon, 20 jul 2009 21:44:43 +0300" {
+		test_fail "default comparator is not i;ascii-casemap";
+	}
+
+	if anyof ( date "date" "std11" "Mon", date "date" "std11" "*") {
+		test_fail "default match type appears to be :contains or :matches";
+	}
+}
+
+test "Count" {
+	if not date :count "eq" "date" "date" "1" {
+		test_fail "count of existing date header field is not 1";
+	}
+
+	if not date :count "eq" "resent-date" "date" "0" {
+		test_fail "count of non-existent date header field is not 0";
+	}
+}
+
+test "Invalid" {
+	if date :matches "invalid-date" "std11" "*" {
+		test_fail "matched invalid date: ${0}";
+	}
+}
Index: b/sieve/tests/extensions/date/date-parts.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/date/date-parts.svtest
@@ -0,0 +1,120 @@
+require "vnd.dovecot.testsuite";
+require "date";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 22 Jul 2009 23:30:14 +0300
+
+Wanna date?
+.
+;
+
+/* "year"      => the year, "0000" .. "9999". */
+test "Year" {
+	if not date :originalzone "date" "year" "2009" {
+		test_fail "failed to extract year part";
+	}
+}
+
+/* "month"     => the month, "01" .. "12". */
+test "Month" {
+	if not date :originalzone "date" "month" "07" {
+		test_fail "failed to extract month part";
+	}
+}
+
+/* "day"       => the day, "01" .. "31". */
+test "Day" {
+	if not date :originalzone "date" "day" "20" {
+		test_fail "failed to extract day part";
+	}
+}
+
+/* "date"      => the date in "yyyy-mm-dd" format. */
+test "Date" {
+	if not date :originalzone "date" "date" "2009-07-20" {
+		test_fail "failed to extract date part";
+	}
+}
+
+/* "julian"    => the Modified Julian Day, that is, the date
+              expressed as an integer number of days since
+              00:00 UTC on November 17, 1858 (using the Gregorian
+              calendar).  This corresponds to the regular
+              Julian Day minus 2400000.5.  */
+test "Julian" {
+	if not date :originalzone "date" "julian" "55032" {
+		if date :matches :originalzone "date" "julian" "*" { }
+		test_fail "failed to extract julian part: ${0}";
+	}
+	if not date :originalzone "delivery-date" "julian" "55034" {
+		if date :matches :originalzone "delivery-date" "julian" "*" { }
+		test_fail "failed to extract julian part: ${0}";
+	}
+}
+
+/* "hour"      => the hour, "00" .. "23". */
+test "Hour" {
+	if not date :originalzone "date" "hour" "21" {
+		test_fail "failed to extract hour part";
+	}
+}
+
+/* "minute"    => the minute, "00" .. "59". */
+test "Minute" {
+	if not date :originalzone "date" "minute" "44" {
+		test_fail "failed to extract minute part";
+	}
+}
+
+/* "second"    => the second, "00" .. "60". */
+test "Second" {
+	if not date :originalzone "date" "second" "43" {
+		test_fail "failed to extract second part";
+	}
+}
+
+/* "time"      => the time in "hh:mm:ss" format. */
+test "Time" {
+	if not date :originalzone "date" "time" "21:44:43" {
+		test_fail "failed to extract time part";
+	}
+}
+
+/* "iso8601"   => the date and time in restricted ISO 8601 format. */
+test "ISO8601" {
+	if not date :originalzone "date" "iso8601" "2009-07-20T21:44:43+03:00" {
+		test_fail "failed to extract iso8601 part";
+	}
+}
+
+/* "std11"     => the date and time in a format appropriate
+                  for use in a Date: header field [RFC2822]. */
+test "STD11" {
+	if not date :originalzone "date" "std11" "Mon, 20 Jul 2009 21:44:43 +0300" {
+		test_fail "failed to extract std11 part";
+	}
+}
+
+/* "zone"      => the time zone in use.  */
+test "zone" {
+	if not date :originalzone "date" "zone" "+0300" {
+		test_fail "failed to extract zone part";
+	}
+
+	if not date :zone "+0200" "date" "zone" "+0200" {
+		test_fail "failed to extract zone part";
+	}
+}
+
+/* "weekday"   => the day of the week expressed as an integer between
+                  "0" and "6". "0" is Sunday, "1" is Monday, etc. */
+test "Weekday" {
+	if not date :originalzone "date" "weekday" "1" {
+		test_fail "failed to extract weekday part";
+	}
+}
Index: b/sieve/tests/extensions/date/zones.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/date/zones.svtest
@@ -0,0 +1,76 @@
+require "vnd.dovecot.testsuite";
+require "date";
+require "variables";
+
+/* Extract local timezone first */
+test "Local-Zone" {
+	if not currentdate :matches "zone" "*" {
+		test_fail "matches '*' failed for zone part.";
+	}
+	set "local_zone" "${0}";
+}
+
+/* FIXME: using variables somehow fails here */
+if string "${local_zone}" "+0200" {
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 23 Jul 2009 05:30:14 +0800
+
+Wanna date?
+.
+;
+} else {
+test_set "message" text:
+From: stephan@rename-it.nl
+To: sirius@drunksnipers.com
+Subject: Frop!
+Date: Mon, 20 Jul 2009 21:44:43 +0300
+Delivery-Date: Mon, 22 Jul 2009 23:30:14 +0200
+
+Wanna date?
+.
+;
+}
+
+test "Specified Zone" {
+	if not date :zone "+0200" "date" "zone" "+0200" {
+		if date :matches :zone "+0200" "date" "zone" "*" {}
+		test_fail "zone is incorrect: ${0}";
+	}
+
+	if not date :zone "+0200" "date" "time" "20:44:43" {
+		test_fail "zone is not applied";
+	}
+}
+
+test "Original Zone" {
+	if not date :originalzone "date" "zone" "+0300" {
+		if date :matches :originalzone "date" "zone" "*" {}
+		test_fail "zone is incorrect: ${0}";
+	}
+
+	if not date :originalzone "date" "time" "21:44:43" {
+		test_fail "time should be left untouched";
+	}
+}
+
+test "Local Zone Shift" {
+	if anyof (
+			allof (
+				string "${local_zone}" "+0200",
+				date "delivery-date" "iso8601" "2009-07-23T05:30:14+08:00"),
+			allof (
+				not string "${local_zone}" "+0200",
+				date "delivery-date" "iso8601" "2009-07-22T23:30:14+02:00")) {
+
+		if date :matches "delivery-date" "iso8601" "*"
+			{ set "a" "${0}"; }
+		if date :originalzone :matches "delivery-date" "iso8601" "*"
+			{ set "b" "${0}"; }
+
+		test_fail "time not shifted to local zone: ${b} => ${a}";
+	}
+}
Index: b/sieve/tests/extensions/encoded-character.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/encoded-character.svtest
@@ -0,0 +1,180 @@
+require "vnd.dovecot.testsuite";
+
+require "encoded-character";
+require "variables";
+
+test "HEX equality one" {
+	if not string "${hex:42}" "B" {
+		test_fail "failed to match the string 'B'";
+	}
+
+	if string "${hex:42}" "b" {
+		test_fail "matched nonsense";
+	}
+
+	if string "${hex:42}" "" {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality one middle" {
+	if not string " ${hex:42} " " B " {
+		test_fail "failed to match the string ' B '";
+	}
+
+	if string " ${hex:42} " " b " {
+		test_fail "matched nonsense";
+	}
+
+	if string " ${hex:42} " "  " {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality one begin" {
+	if not string "${hex:42} " "B " {
+		test_fail "failed to match the string 'B '";
+	}
+
+	if string "${hex:42} " " b" {
+		test_fail "matched nonsense";
+	}
+
+	if string "${hex:42} " " " {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality one end" {
+	if not string " ${hex:42}" " B" {
+		test_fail "failed to match the string ' B'";
+	}
+
+	if string " ${hex:42}" " b " {
+		test_fail "matched nonsense";
+	}
+
+	if string " ${hex:42}" " " {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality two triple" {
+	if not string "${hex:42 61 64}${hex: 61 73 73}" "Badass" {
+		test_fail "failed to match the string 'Badass'";
+	}
+
+	if string "${hex:42 61 64}${hex: 61 73 73}" "Sadass" {
+		test_fail "matched nonsense";
+	}
+
+	if string "${hex:42 61 64}${hex: 61 73 73}" "" {
+		test_fail "substitution failed";
+	}
+}
+
+test "HEX equality braindead" {
+	if not string "${hex:42 72 61 69 6E 64 65 61 64}" "Braindead" {
+		test_fail "failed to match the string 'Braindead'";
+	}
+
+	if string "${hex:42 72 61 69 6E 64 65 61 64}" "Brian Nut" {
+		test_fail "matched nonsense";
+	}
+}
+
+test "Syntax errors" {
+	if anyof( not string "$" "${hex:24}", not string "$ " "${hex:24} ", not string " $" " ${hex:24}" ) {
+        test_fail "loose $ handled inappropriately";
+    }
+
+	if anyof( not string "${" "${hex:24}{", not string "a${" "a${hex:24}{", not string "${a" "${hex:24}{a" ) {
+        test_fail "loose ${ handled inappropriately";
+    }
+
+	if anyof( not string "${}" "${hex:24}{}", not string "b${}" "b${hex:24}{}", not string "${}b" "${hex:24}{}b" ) {
+		test_fail "entirely missing content handled inappropriately";
+	}
+
+	if not string "${:}" "${hex:24}{:}" {
+        test_fail "missing content handled inappropriately";
+    }
+
+	if not string "${hex:}" "${hex:24}{hex:}" {
+        test_fail "missing hex content handled inappropriately";
+    }
+
+	if not string "${unicode:}" "${hex:24}{unicode:}" {
+        test_fail "missing unicode content handled inappropriately";
+    }
+
+	if not string "${hex:sss}" "${hex:24}{hex:sss}" {
+        test_fail "erroneous hex content handled inappropriately";
+    }
+
+    if not string "${unicode:ttt}" "${hex:24}{unicode:ttt}" {
+        test_fail "erroneous unicode content handled inappropriately";
+    }
+
+	if not string "${hex:aa aa" "${hex:24}{hex:aa aa" {
+        test_fail "unterminated hex content handled inappropriately";
+    }
+
+    if not string "${unicode: aaaa aaaa" "${hex:24}{unicode: aaaa aaaa" {
+        test_fail "unterminated unicode content handled inappropriately";
+    }
+}
+
+/*
+ * RFC Examples
+ */
+
+test "RFC Examples" {
+	if not string "$${hex:40}" "$@" {
+		test_fail "failed RFC example 1";
+	}
+
+	if not string "${hex: 40 }" "@" {
+		test_fail "failed RFC example 2";
+	}
+
+	if not string "${HEX: 40}" "@" {
+		test_fail "failed RFC example 3";
+	}
+
+	if not string "${hex:40" "${hex:40" {
+		test_fail "failed RFC example 4";
+	}
+
+	if not string "${hex:400}" "${hex:400}" {
+		test_fail "failed RFC example 5";
+	}
+
+	if not string "${hex:4${hex:30}}" "${hex: 24}{hex:40}" {
+		test_fail "failed RFC example 6";
+	}
+
+	if not string "${unicode:40}" "@" {
+		test_fail "failed RFC example 7";
+	}
+
+	if not string "${ unicode:40}" "${ unicode:40}" {
+		test_fail "failed RFC example 8";
+	}
+
+	if not string "${UNICODE:40}" "@" {
+		test_fail "failed RFC example 9";
+	}
+
+	if not string "${UnICoDE:0000040}" "@" {
+		test_fail "failed RFC example 10";
+	}
+
+	if not string "${Unicode:40}" "@" {
+		test_fail "failed RFC example 11";
+	}
+
+	if not string "${Unicode:Cool}" "${Unicode:Cool}" {
+		test_fail "failed RFC example 12";
+	}
+}
Index: b/sieve/tests/extensions/enotify/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/basic.svtest
@@ -0,0 +1,15 @@
+require "vnd.dovecot.testsuite";
+require "enotify";
+
+test "Execute" {
+	/* Test to catch runtime segfaults */
+	if valid_notify_method
+		"mailto:stephan@example.com" {
+
+		/* Test to catch runtime segfaults */
+		notify
+			:message "This is probably very important"
+			:importance "1"
+			"mailto:stephan@example.com%2cstephan@rename-it.nl?subject=Important%20message%20received";
+	}
+}
Index: b/sieve/tests/extensions/enotify/encodeurl.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/encodeurl.svtest
@@ -0,0 +1,11 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+require "enotify";
+
+test "Encode Simple" {
+	set :encodeurl "url_data" "\\frop\\&fruts/^@";
+
+	if not string :is :comparator "i;octet" "${url_data}" "%5Cfrop%5C%26fruts%2F%5E%40" {
+		test_fail "url data encoded incorrectly '${url_data}'";
+	}
+}
Index: b/sieve/tests/extensions/enotify/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/errors.svtest
@@ -0,0 +1,45 @@
+require "vnd.dovecot.testsuite";
+require "comparator-i;ascii-numeric";
+require "relational";
+
+require "enotify";
+
+test "Invalid URI (FIXME: count only)" {
+	if test_script_compile "errors/uri.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid mailto URI (FIXME: count only)" {
+	if test_script_compile "errors/uri-mailto.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "7" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid mailto :from address (FIXME: count only)" {
+	if test_script_compile "errors/from-mailto.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid :options argument (FIXME: count only)" {
+	if test_script_compile "errors/options.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "6" {
+		test_fail "wrong number of errors reported";
+	}
+}
Index: b/sieve/tests/extensions/enotify/errors/from-mailto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/errors/from-mailto.sieve
@@ -0,0 +1,7 @@
+require "enotify";
+
+# 1: Invalid from address
+notify :from "stephan#rename-it.nl" "mailto:stephan@example.com";
+
+# 2: Empty from address
+notify :from "" "mailto:stephan@example.com";
Index: b/sieve/tests/extensions/enotify/errors/options.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/errors/options.sieve
@@ -0,0 +1,18 @@
+require "enotify";
+
+# 1: empty option
+notify :options "" "mailto:stephan@rename-it.nl";
+
+# 2: invalid option name syntax
+notify :options "frop" "mailto:stephan@rename-it.nl";
+
+# 3: invalid option name syntax
+notify :options "_frop=" "mailto:stephan@rename-it.nl";
+
+# 4: invalid option name syntax
+notify :options "=frop" "mailto:stephan@rename-it.nl";
+
+# 5: invalid value
+notify :options "frop=frml
+frop" "mailto:stephan@rename-it.nl";
+
Index: b/sieve/tests/extensions/enotify/errors/uri-mailto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/errors/uri-mailto.sieve
@@ -0,0 +1,20 @@
+require "enotify";
+
+# 1: Invalid character in to part
+notify "mailto:stephan@rename-it.nl;?header=frop";
+
+# 2: Invalid character in hname
+notify "mailto:stephan@rename-it.nl?header<=frop";
+
+# 3: Invalid character in hvalue
+notify "mailto:stephan@rename-it.nl?header=fr>op";
+
+# 4: Invalid header name
+notify "mailto:stephan@rename-it.nl?header:=frop";
+
+# 5: Invalid recipient
+notify "mailto:stephan%23rename-it.nl";
+
+# 6: Invalid to header recipient
+notify "mailto:stephan@rename-it.nl?to=nico%23vestingbar.nl";
+
Index: b/sieve/tests/extensions/enotify/errors/uri.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/errors/uri.sieve
@@ -0,0 +1,5 @@
+require "enotify";
+
+# 1: Invalid url scheme
+notify "snailto:stephan@rename-it.nl";
+
Index: b/sieve/tests/extensions/enotify/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute.svtest
@@ -0,0 +1,99 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+
+
+/*
+ * Execution testing (currently just meant to trigger any segfaults)
+ */
+
+test "RFC Example 1" {
+	if not test_script_compile "execute/draft-rfc-ex1.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "RFC Example 2" {
+	if not test_script_compile "execute/draft-rfc-ex2.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+/* tel: not supported
+test "RFC Example 3" {
+	if not test_script_compile "execute/draft-rfc-ex3.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+*/
+
+/* tel: and xmmp: not supported
+test "RFC Example 5" {
+	if not test_script_compile "execute/draft-rfc-ex5.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+*/
+
+test "RFC Example 6" {
+	if not test_script_compile "execute/draft-rfc-ex6.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "Duplicate recipients" {
+	if not test_script_compile "execute/duplicates.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if test_result :count "ne" "2" {
+		test_fail "second notify action was discarded entirely";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
Index: b/sieve/tests/extensions/enotify/execute/draft-rfc-ex1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute/draft-rfc-ex1.sieve
@@ -0,0 +1,26 @@
+require ["enotify", "fileinto", "variables"];
+
+if header :contains "from" "boss@example.org" {
+	notify :importance "1"
+		:message "This is probably very important"
+		"mailto:alm@example.com";
+	# Don't send any further notifications
+	stop;
+}
+
+if header :contains "to" "sievemailinglist@example.org" {
+	# :matches is used to get the value of the Subject header
+	if header :matches "Subject" "*" {
+		set "subject" "${1}";
+	}
+
+	# :matches is used to get the value of the From header
+	if header :matches "From" "*" {
+		set "from" "${1}";
+	}
+
+	notify :importance "3"
+		:message "[SIEVE] ${from}: ${subject}"
+		"mailto:alm@example.com";
+	fileinto "INBOX.sieve";
+}
Index: b/sieve/tests/extensions/enotify/execute/draft-rfc-ex2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute/draft-rfc-ex2.sieve
@@ -0,0 +1,22 @@
+require ["enotify", "fileinto", "variables", "envelope"];
+
+if header :matches "from" "*@*.example.org" {
+	# :matches is used to get the MAIL FROM address
+	if envelope :all :matches "from" "*" {
+		set "env_from" " [really: ${1}]";
+	}
+
+	# :matches is used to get the value of the Subject header
+	if header :matches "Subject" "*" {
+		set "subject" "${1}";
+	}
+
+	# :matches is used to get the address from the From header
+	if address :matches :all "from" "*" {
+		set "from_addr" "${1}";
+	}
+
+	notify :message "${from_addr}${env_from}: ${subject}"
+		"mailto:alm@example.com";
+}
+
Index: b/sieve/tests/extensions/enotify/execute/draft-rfc-ex3.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute/draft-rfc-ex3.sieve
@@ -0,0 +1,31 @@
+require ["enotify", "variables"];
+
+set "notif_method"
+	"xmpp:tim@example.com?message;subject=SIEVE;body=You%20got%20mail";
+
+if header :contains "subject" "Your dog" {
+	set "notif_method" "tel:+14085551212";
+}
+
+if header :contains "to" "sievemailinglist@example.org" {
+	set "notif_method" "";
+}
+
+if not string :is "${notif_method}" "" {
+	notify "${notif_method}";
+}
+
+if header :contains "from" "boss@example.org" {
+	# :matches is used to get the value of the Subject header
+	if header :matches "Subject" "*" {
+		set "subject" "${1}";
+	}
+
+	# don't need high importance notification for
+	# a 'for your information'
+	if not header :contains "subject" "FYI:" {
+		notify :importance "1" :message "BOSS: ${subject}"
+			"tel:+14085551212";
+	}
+}
+
Index: b/sieve/tests/extensions/enotify/execute/draft-rfc-ex5.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute/draft-rfc-ex5.sieve
@@ -0,0 +1,11 @@
+require ["enotify"];
+
+if notify_method_capability
+	"xmpp:tim@example.com?message;subject=SIEVE"
+	"Online"
+	"yes" {
+	notify :importance "1" :message "You got mail"
+		"xmpp:tim@example.com?message;subject=SIEVE";
+} else {
+	notify :message "You got mail" "tel:+14085551212";
+}
Index: b/sieve/tests/extensions/enotify/execute/draft-rfc-ex6.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute/draft-rfc-ex6.sieve
@@ -0,0 +1,5 @@
+require ["enotify", "variables"];
+
+set :encodeurl "body_param" "Safe body&evil=evilbody";
+
+notify "mailto:tim@example.com?body=${body_param}";
Index: b/sieve/tests/extensions/enotify/execute/duplicates.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/execute/duplicates.sieve
@@ -0,0 +1,4 @@
+require "enotify";
+
+notify :message "Incoming stupidity." "mailto:stephan@rename-it.nl%2cstephan@drunksnipers.com%2cidiot@rename-it.nl";
+notify :message "There it is." "mailto:tss@iki.fi%2cstephan@rename-it.nl%2cidiot@rename-it.nl%2cnico@vestingbar.nl%2cstephan@drunksnipers.com";
Index: b/sieve/tests/extensions/enotify/mailto.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/mailto.svtest
@@ -0,0 +1,302 @@
+require "vnd.dovecot.testsuite";
+require "enotify";
+require "relational";
+require "envelope";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Simple test
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Simple" {
+	notify "mailto:stephan@rename-it.nl";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not header :matches "Auto-Submitted" "auto-notified*" {
+		test_fail "auto-submitted header set inappropriately";
+	}
+
+	if not exists "X-Sieve" {
+		test_fail "x-sieve header missing from outgoing message";
+	}
+}
+
+/*
+ * Multiple recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Multiple recipients" {
+	notify "mailto:timo@example.com%2cstephan@dovecot.org?cc=postmaster@vestingbar.nl&subject=Frop%20received";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not address :is "to" "timo@example.com" {
+		test_fail "first To address missing";
+	}
+
+	if not address :is "to" "stephan@dovecot.org" {
+		test_fail "second To address missing";
+	}
+
+	if not address :is "cc" "postmaster@vestingbar.nl" {
+		test_fail "first Cc address missing";
+	}
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "to" "2" {
+		test_fail "too many recipients in To header";
+	}
+
+	if not address :count "eq" :comparator "i;ascii-numeric" "cc" "1" {
+		test_fail "too many recipients in Cc header";
+	}
+
+	if not header "subject" "Frop received" {
+		test_fail "subject header set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not header :matches "Auto-Submitted" "auto-notified*" {
+		test_fail "auto-submitted header not found for second message";
+	}
+
+	test_message :smtp 2;
+
+	if not header :matches "Auto-Submitted" "auto-notified*" {
+		test_fail "auto-submitted header not found for third message";
+	}
+}
+
+/*
+ * Duplicate recipients
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Duplicate recipients" {
+	notify "mailto:timo@example.com%2cstephan@dovecot.org?cc=stephan@dovecot.org";
+	notify "mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if address "Cc" "stephan@dovecot.org" {
+		test_fail "duplicate recipient not removed from first message";
+	}
+
+	test_message :smtp 1;
+
+	if address "Cc" "timo@example.com" {
+		test_fail "duplicate recipient not removed from second message";
+	}
+}
+
+
+/*
+ * Notifying on automated messages
+ */
+
+test_result_reset;
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Auto-submitted: auto-notify
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test "Notifying on automated messages" {
+	notify "mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "notified of auto-submitted message";
+	}
+}
+
+/*
+ * Envelope
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test_result_reset;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "bertus@vestingbar.nl";
+
+test "Envelope" {
+	notify "mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not envelope :localpart :is "from" "postmaster" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "stephan@rename-it.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not envelope :localpart :is "from" "postmaster" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "timo@example.com" {
+		test_fail "envelope sender set incorrectly";
+	}
+}
+
+/*
+ * Envelope :from
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "bertus@vestingbar.nl";
+
+test_result_reset;
+
+test "Envelope :from" {
+	notify :from "nico@vestingbar.nl"
+		"mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not envelope :is "from" "nico@vestingbar.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "stephan@rename-it.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not envelope :is "from" "nico@vestingbar.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "timo@example.com" {
+		test_fail "envelope sender set incorrectly";
+	}
+}
+
+/*
+ * Envelope <>
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Klutsefluts.
+.
+;
+
+test_set "envelope.from" "<>";
+test_set "envelope.to" "bertus@vestingbar.nl";
+
+test_result_reset;
+
+test "Envelope <>" {
+	notify :from "nico@vestingbar.nl"
+		"mailto:stephan@rename-it.nl?cc=timo@example.com";
+
+	if not test_result_execute {
+		test_fail "failed to execute notify";
+	}
+
+	test_message :smtp 0;
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "stephan@rename-it.nl" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	test_message :smtp 1;
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender set incorrectly";
+	}
+
+	if not envelope :is "to" "timo@example.com" {
+		test_fail "envelope sender set incorrectly";
+	}
+}
Index: b/sieve/tests/extensions/enotify/notify_method_capability.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/notify_method_capability.svtest
@@ -0,0 +1,12 @@
+require "vnd.dovecot.testsuite";
+require "enotify";
+
+test "Mailto" {
+	if not notify_method_capability :is "mailto:stephan@rename-it.nl" "online" "maybe" {
+		test_fail "test should have matched";
+	}
+
+	if notify_method_capability :is "mailto:stephan@rename-it.nl" "online" "yes" {
+		test_fail "test should not have matched";
+	}
+}
Index: b/sieve/tests/extensions/enotify/valid_notify_method.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/enotify/valid_notify_method.svtest
@@ -0,0 +1,31 @@
+require "vnd.dovecot.testsuite";
+
+require "enotify";
+
+test "Mailto: invalid header name" {
+	if valid_notify_method
+		"mailto:stephan@rename-it.nl?header:=frop" {
+		test_fail "invalid uri accepted";
+	}
+}
+
+test "Mailto: invalid recipient" {
+	if valid_notify_method
+		"mailto:stephan%23rename-it.nl" {
+		test_fail "invalid uri accepted";
+	}
+}
+
+test "Mailto: invalid to header recipient" {
+	if valid_notify_method
+		"mailto:stephan@rename-it.nl?to=nico%23vestingbar.nl" {
+		test_fail "invalid uri accepted";
+	}
+}
+
+test "Mailto: valid URI" {
+	if not valid_notify_method
+		"mailto:stephan@rename-it.nl" {
+		test_fail "valid uri denied";
+	}
+}
Index: b/sieve/tests/extensions/envelope.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/envelope.svtest
@@ -0,0 +1,218 @@
+require "vnd.dovecot.testsuite";
+
+require "envelope";
+
+/*
+ * Empty envelope addresses
+ */
+
+test "Envelope - from empty" {
+	/* Return_path: "" */
+
+	test_set "envelope.from" "";
+
+	if not envelope :all :is "from" "" {
+		test_fail "failed to (:all :is)-match a \"\" return path";
+	}
+
+	if not envelope :all :contains "from" "" {
+		test_fail "failed to (:all :contains)-match a \"\" return path";
+	}
+
+	if not envelope :domain :is "from" "" {
+		test_fail "failed to (:domain :is)-match a \"\" return path";
+	}
+
+	if not envelope :domain :contains "from" "" {
+		test_fail "failed to (:domain :contains)-match a \"\" return path";
+	}
+
+	/* Return path: <> */
+
+	test_set "envelope.from" "<>";
+
+	if not envelope :all :is "from" "" {
+		test_fail "failed to (:all :is)-match a <> return path";
+	}
+
+	if not envelope :all :contains "from" "" {
+		test_fail "failed to (:all :contains)-match a <> return path";
+	}
+
+	if not envelope :domain :is "from" "" {
+		test_fail "failed to (:domain :is)-match a <> return path";
+	}
+
+	if not envelope :domain :contains "from" "" {
+		test_fail "failed to (:domain :contains)-match a <> return path";
+	}
+
+	if envelope :all :is "from" "nico@vestingbar.nl" {
+		test_fail "envelope test matches nonsense";
+	}
+
+	/* Forward path: <> */
+
+    test_set "envelope.to" "<>";
+
+    if envelope :all :is "to" "" {
+        test_fail "successfully matched a <> forward path, which is wrong";
+    }
+}
+
+/*
+ * Invalid envelope addresses
+ */
+
+test "Envelope - invalid paths" {
+    /* Return_path: "hutsefluts" */
+
+	test_set "envelope.from" "hutsefluts";
+	test_set "envelope.to" "knurft";
+
+	if not envelope :all :is "from" "hutsefluts" {
+		test_fail ":all address part mangled syntactically incorrect reverse path";
+	}
+
+	if envelope :localpart :is "from" "hutsefluts" {
+        test_fail ":localpart address part matched syntactically incorrect reverse path";
+    }
+
+	if envelope :domain :contains "from" "" {
+        test_fail ":domain address part matched syntactically incorrect reverse path";
+    }
+
+	if not envelope :all :is "to" "knurft" {
+		test_fail ":all address part mangled syntactically incorrect forward path";
+	}
+
+	if envelope :localpart :is "to" "knurft" {
+        test_fail ":localpart address part matched syntactically incorrect forward path";
+    }
+
+	if envelope :domain :contains "to" "" {
+        test_fail ":domain address part matched syntactically incorrect forward path";
+    }
+}
+
+/*
+ * Syntax errors
+ */
+
+test "Envelope - syntax errors" {
+	/* Control */
+	test_set "envelope.from" "<stephan@rename-it.nl>";
+	if not envelope :all :is "from" "stephan@rename-it.nl" {
+		test_fail "correct control test failed";
+	}
+
+	# Duplicate <
+	test_set "envelope.from" "<<stephan@rename-it.nl>";
+    if envelope :all :is "from" "stephan@rename-it.nl" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# Spurious >
+	test_set "envelope.from" "stephan@rename-it.nl>";
+    if envelope :all :is "from" "stephan@rename-it.nl" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# Missing >
+	test_set "envelope.from" "<stephan@rename-it.nl";
+    if envelope :all :is "from" "stephan@rename-it.nl" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# No @
+	test_set "envelope.from" "<stephan rename-it.nl>";
+    if envelope :domain :contains "from" "" {
+        test_fail "failed to recognize syntax error";
+    }
+
+	# Duplicate @
+	test_set "envelope.from" "<stephan@@rename-it.nl>";
+    if envelope :domain :contains "from" "" {
+        test_fail "failed to recognize syntax error";
+    }
+}
+
+/*
+ * Ignoring source routes
+ */
+
+test "Envelope - source route" {
+	/* Single */
+	test_set "envelope.from" "<@cola.rename-it.nl:stephan@rename-it.nl>";
+	if not envelope :localpart :is "from" "stephan" {
+		test_fail "parsing path with source route (single) failed";
+
+	}
+
+	/* Dual */
+	test_set "envelope.from" "<@cola.rename-it.nl,@mx.utwente.nl:stephan@rename-it.nl>";
+	if not envelope :localpart :is "from" "stephan" {
+		test_fail "parsing path with source route (dual) failed";
+
+	}
+
+	/* Multiple */
+	test_set "envelope.from" "<@cola.rename-it.nl,@mx.utwente.nl,@smtp.iki.fi:stephan@rename-it.nl>";
+	if not envelope :localpart :is "from" "stephan" {
+		test_fail "parsing path with source route (multiple) failed";
+
+	}
+
+	/* Bare */
+	test_set "envelope.from" "@cola.rename-it.nl,@mx.utwente.nl,@smtp.iki.fi:stephan@rename-it.nl";
+	if not envelope :domain :is "from" "rename-it.nl" {
+		test_fail "parsing path with source route (bare) failed";
+	}
+
+	/* Whitespace */
+	test_set "envelope.from" "   < @ cola . rename-it . nl , @ mx . utwente .   nl , 	@ smtp  .  iki  . fi	:   stephan		@     rename-it   .		nl >  ";
+    if not envelope :domain :is "from" "rename-it.nl" {
+        test_fail "parsing path with source route (whitespace) failed";
+    }
+}
+
+test "Envelope - source route errors" {
+	test_set "envelope.to" "<cola.rename-it.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (1)";
+	}
+
+	test_set "envelope.to" "<@.rename-it.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (2)";
+	}
+
+	test_set "envelope.to" "<@cola..nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (3)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nlstephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (4)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nl@mx.utwente.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (5)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nl,mx.utwente.nl:stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (6)";
+	}
+
+	test_set "envelope.to" "<@cola.rename-it.nl,@mx.utwente.nl,stephan@rename-it.nl>";
+	if envelope :domain :contains "to" "" {
+		test_fail "parsing syntactically incorrect path should have failed (7)";
+	}
+
+	if not envelope :all :is "to" "<@cola.rename-it.nl,@mx.utwente.nl,stephan@rename-it.nl>" {
+		test_fail ":all address part mangled syntactically incorrect path";
+	}
+}
Index: b/sieve/tests/extensions/environment/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/environment/basic.svtest
@@ -0,0 +1,31 @@
+require "vnd.dovecot.testsuite";
+require "environment";
+require "variables";
+
+test "Name" {
+	if not environment :contains "name" "dovecot" {
+		if environment :matches "name" "*" { set "env_name" "${1}"; }
+
+		test_fail "name environment returned invalid value(1): ${env_name}";
+	}
+
+	if not environment :contains "name" "sieve" {
+		if environment :matches "name" "*" { set "env_name" "${1}"; }
+
+		test_fail "name environment returned invalid value(2): ${env_name}";
+	}
+
+	if environment :contains "name" "cyrus" {
+		test_fail "something is definitely wrong here";
+	}
+
+	if not environment :is :comparator "i;octet" "name" "Dovecot Sieve" {
+		test_fail "name environment does not match exactly with what is expected";
+	}
+}
+
+test "Host" {
+	if not environment "host" "testsuite.example.com" {
+		test_fail "wrong testsuite hostname";
+	}
+}
Index: b/sieve/tests/extensions/environment/rfc.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/environment/rfc.svtest
@@ -0,0 +1,28 @@
+require "vnd.dovecot.testsuite";
+require "environment";
+require "relational";
+
+test "Non-existant" {
+	if environment :contains "nonsense" "" {
+		test_fail "matched unknown environment item";
+	}
+}
+
+test "Exists" {
+	if not environment :contains "version" "" {
+		test_fail "failed to match known environment item";
+	}
+}
+
+test "Count" {
+	if anyof (
+			environment :count "eq" "nonsense" "0",
+			environment :count "eq" "nonsense" "1"
+		) {
+		test_fail "count should not match unknown environment item";
+	}
+
+	if not environment :count "eq" "host" "1" {
+		test_fail "count of non-empty environment should be 1";
+	}
+}
Index: b/sieve/tests/extensions/imap4flags/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/basic.svtest
@@ -0,0 +1,108 @@
+require "vnd.dovecot.testsuite";
+
+require "imap4flags";
+require "relational";
+require "variables";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Basic functionality tests
+ */
+
+test "Hasflag empty" {
+	if hasflag "\\Seen" {
+		test_fail "hasflag sees initial \\seen flag were there should be none";
+	}
+	if hasflag "\\draft" {
+		test_fail "hasflag sees initial \\draft flag were there should be none";
+	}
+	if hasflag "\\recent" {
+		test_fail "hasflag sees initial \\recent flag were there should be none";
+	}
+	if hasflag "\\flagged" {
+		test_fail "hasflag sees initial \\flagged flag were there should be none";
+	}
+	if hasflag "\\answered" {
+		test_fail "hasflag sees initial \\answered flag were there should be none";
+	}
+	if hasflag "\\deleted" {
+		test_fail "hasflag sees initial \\deleted flag were there should be none";
+	}
+
+	if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+		test_fail "hasflag sees initial flags were there should be none";
+	}
+}
+
+test "Setflag; Hasflag one" {
+	setflag "\\seen";
+
+	if not hasflag "\\Seen" {
+		test_fail "flag not set of hasflag fails to see it";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "1" {
+		test_fail "flag not set of hasflag fails to see it";
+	}
+
+	if hasflag "$Nonsense" {
+		test_fail "hasflag sees other flag that the one set";
+	}
+}
+
+test "Hasflag; duplicates" {
+	set "Flags" "A B C D E F A B C D E F";
+
+	if hasflag :comparator "i;ascii-numeric" :count "gt" "Flags" "6" {
+		test_fail "hasflag must ignore duplicates";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "Flags" "6" {
+		test_fail "hasflag :count gives strange results";
+	}
+}
+
+test "Flag operations" {
+	setflag "A";
+
+	if not hasflag "A" {
+		test_fail "hasflag misses set flag";
+	}
+
+	if hasflag :comparator "i;ascii-numeric" :count "gt" "1" {
+		test_fail "hasflag sees more than one flag";
+	}
+
+	addflag "B";
+
+	if not hasflag "B" {
+		test_fail "flag \"B\" not added";
+	}
+
+	if not hasflag "A" {
+		test_fail "flag \"A\" not retained";
+	}
+
+	if hasflag :comparator "i;ascii-numeric" :count "gt" "2" {
+                test_fail "hasflag sees more than two flags";
+        }
+
+	addflag ["C", "D", "E F"];
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "6" {
+                test_fail "hasflag sees more than two flags";
+        }
+
+	removeflag ["D"];
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "5" {
+                test_fail "hasflag sees more than two flags";
+        }
+
+	if hasflag "D" {
+		test_fail "removed flag still present";
+	}
+}
+
+
+
Index: b/sieve/tests/extensions/imap4flags/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/errors.svtest
@@ -0,0 +1,14 @@
+require "vnd.dovecot.testsuite";
+
+require "comparator-i;ascii-numeric";
+require "relational";
+
+test "Depricated imapflags extension used with imap4flags" {
+	if test_script_compile "errors/imapflags.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "wrong number of errors reported";
+	}
+}
Index: b/sieve/tests/extensions/imap4flags/errors/imapflags.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/errors/imapflags.sieve
@@ -0,0 +1,4 @@
+require "imapflags";
+require "imap4flags";
+
+addflag "\\flagged";
Index: b/sieve/tests/extensions/imap4flags/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/execute.svtest
@@ -0,0 +1,22 @@
+require "vnd.dovecot.testsuite";
+
+/*
+ * Execution testing (currently just meant to trigger any segfaults)
+ */
+
+test_mailbox :create "INBOX.Junk";
+test_mailbox :create "INBOX.Nonsense";
+
+test "Flags Side Effect" {
+	if not test_script_compile "execute/flags-side-effect.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
Index: b/sieve/tests/extensions/imap4flags/execute/flags-side-effect.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/execute/flags-side-effect.sieve
@@ -0,0 +1,18 @@
+require "imap4flags";
+require "fileinto";
+
+/*
+ * When keep/fileinto is used multiple times in a script and duplicate
+ * message elimination is performed, the last flag list value MUST win.
+ */
+
+setflag "IMPLICIT";
+
+fileinto :flags "\\Seen \\Draft" "INBOX.Junk";
+fileinto :flags "NONSENSE" "INBOX.Junk";
+
+keep;
+keep :flags "\\Seen";
+
+fileinto :flags "\\Seen" "Inbox.Nonsense";
+fileinto "Inbox.Nonsense";
Index: b/sieve/tests/extensions/imap4flags/execute/imapflags.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/execute/imapflags.sieve
@@ -0,0 +1,7 @@
+require "imapflags";
+
+mark;
+unmark;
+mark;
+
+addflag "$label1";
Index: b/sieve/tests/extensions/imap4flags/flagstore.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/flagstore.svtest
@@ -0,0 +1,146 @@
+require "vnd.dovecot.testsuite";
+require "fileinto";
+require "imap4flags";
+require "relational";
+require "comparator-i;ascii-numeric";
+require "mailbox";
+
+test_set "message" text:
+From: Henry von Flockenstoffen <henry@example.com>
+To: Dieter von Ausburg <dieter@example.com>
+Subject: Test message.
+
+Test message.
+.
+;
+
+test "Basic" {
+    if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+        test_fail "some flags or keywords are already set";
+    }
+
+	setflag "$label1 \\answered";
+
+	fileinto :create "Uninteresting";
+
+	if not test_result_execute {
+		test_fail "failed to execute first result";
+	}
+
+	test_result_reset;
+
+	setflag "\\draft \\seen Junk";
+
+	fileinto "Uninteresting";
+
+	if not test_result_execute {
+		test_fail "failed to execute second result";
+	}
+
+	test_result_reset;
+
+	fileinto :flags "\\flagged" "Uninteresting";
+
+    if not test_result_execute {
+        test_fail "failed to execute third result";
+    }
+
+    test_result_reset;
+
+	test_message :folder "Uninteresting" 0;
+
+	if not hasflag "$label1 \\answered" {
+		test_fail "flags not stored for first message";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "2" {
+        test_fail "invalid number of flags set for first message";
+    }
+
+    test_result_reset;
+
+	test_message :folder "Uninteresting" 1;
+
+    if not hasflag "\\draft \\seen Junk" {
+        test_fail "flags not stored for second message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "3" {
+        test_fail "invalid number of flags set for second message";
+    }
+
+    test_result_reset;
+
+	test_message :folder "Uninteresting" 2;
+
+    if not hasflag "\\flagged" {
+        test_fail "flags not stored for third message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "1" {
+        test_fail "invalid number of flags set for third message";
+    }
+}
+
+test_result_reset;
+test_set "message" text:
+From: Henry von Flockenstoffen <henry@example.com>
+To: Dieter von Ausburg <dieter@example.com>
+Subject: Test message.
+
+Test message.
+.
+;
+
+test "Flag changes between stores" {
+    if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+        test_fail "some flags or keywords are already set";
+    }
+
+	setflag "$label1 \\answered";
+	fileinto :create "FolderA";
+
+	setflag "$label2";
+	fileinto :create "FolderB";
+
+	fileinto :create :flags "\\seen \\draft \\flagged" "FolderC";
+
+	if not test_result_execute {
+		test_fail "failed to execute first result";
+	}
+
+	test_result_reset;
+	test_message :folder "FolderA" 0;
+
+	if not hasflag "\\answered $label1" {
+		test_fail "flags not stored for first message";
+	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "2" {
+        test_fail "invalid number of flags set for first message";
+    }
+
+    test_result_reset;
+	test_message :folder "FolderB" 0;
+
+    if not hasflag "$label2" {
+        test_fail "flag not stored for second message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "1" {
+        test_fail "invalid number of flags set for second message";
+    }
+
+    test_result_reset;
+	test_message :folder "FolderC" 0;
+
+    if not hasflag "\\seen \\flagged \\draft" {
+        test_fail "flags not stored for third message";
+    }
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "3" {
+        test_fail "invalid number of flags set for third message";
+    }
+}
+
+
Index: b/sieve/tests/extensions/imap4flags/hasflag.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/hasflag.svtest
@@ -0,0 +1,91 @@
+require "vnd.dovecot.testsuite";
+
+require "imap4flags";
+require "relational";
+require "variables";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Generic tests
+ */
+
+test "Ignoring \"\"" {
+	setflag "";
+
+	if hasflag "" {
+		test_fail "hasflag fails to ignore empty string";
+	}
+}
+
+/*
+ * Variables
+ */
+
+test "Multiple variables" {
+	setflag "A" "Aflag";
+	setflag "B" "Bflag";
+	setflag "C" "Cflag";
+
+	if not hasflag ["a", "b", "c"] ["Bflag"] {
+		test_fail "hasflag failed to match multiple flags variables";
+	}
+}
+
+/*
+ * RFC examples
+ */
+
+test "RFC hasflag example - :is" {
+	setflag "A B";
+
+	if not hasflag ["b","A"] {
+		test_fail "list representation did not match";
+	}
+
+	if not hasflag :is "b A" {
+		test_fail "string representation did not match";
+	}
+}
+
+test "RFC hasflag example - :contains variable" {
+	set "MyVar" "NonJunk Junk gnus-forward $Forwarded NotJunk JunkRecorded $Junk $NotJunk";
+
+	if not hasflag :contains "MyVar" "Junk" {
+		test_fail "failed true example 1";
+	}
+
+	if not hasflag :contains "MyVar" "forward" {
+		test_fail "failed true example 2";
+	}
+
+	if not hasflag :contains "MyVar" ["label", "forward"] {
+		test_fail "failed true example 3";
+	}
+
+	if not hasflag :contains "MyVar" ["junk", "forward"] {
+		test_fail "failed true example 4";
+	}
+
+	if not hasflag :contains "MyVar" "junk forward" {
+		test_fail "failed true example 4 (rewrite 1)";
+	}
+
+	if not hasflag :contains "MyVar" "forward junk" {
+		test_fail "failed true example 4 (rewrite 2)";
+	}
+
+	if hasflag :contains "MyVar" "label" {
+		test_fail "failed false example 1";
+	}
+
+	if hasflag :contains "MyVar" ["label1", "label2"] {
+		test_fail "failed false example 2";
+	}
+}
+
+test "RFC hasflag example - :count variable" {
+	set "MyFlags" "A B";
+	if not hasflag :count "ge" :comparator "i;ascii-numeric" "MyFlags" "2" {
+		test_fail "failed count \"ge\" comparison";
+	}
+}
Index: b/sieve/tests/extensions/imap4flags/multiscript.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/multiscript.svtest
@@ -0,0 +1,55 @@
+require "vnd.dovecot.testsuite";
+require "imap4flags";
+require "relational";
+require "comparator-i;ascii-numeric";
+require "mailbox";
+require "fileinto";
+
+test "Segfault Trigger 1" {
+
+	if not test_multiscript [
+		"multiscript/group-spam.sieve",
+		"multiscript/spam.sieve",
+		"multiscript/sent-store.sieve"]
+	{
+		test_fail "failed multiscript execution";
+	}
+}
+
+test_set "message" text:
+From: Henry von Flockenstoffen <henry@example.com>
+To: Dieter von Ausburg <dieter@example.com>
+Subject: Test message.
+
+Test message.
+.
+;
+
+test "Internal Flags" {
+	if hasflag :comparator "i;ascii-numeric" :count "ge" "1" {
+ 		test_fail "some flags or keywords are already set";
+	}
+
+	if not test_multiscript [
+		"multiscript/setflag.sieve",
+		"multiscript/fileinto.sieve"]
+	{
+		test_fail "failed multiscript execution";
+	}
+
+	test_result_reset;
+	test_message :folder "folder" 0;
+
+	if not hasflag "\\answered" {
+        	test_fail "\\answered flag not stored for message";
+	}
+
+	if not hasflag "$label1" {
+		test_fail "$label1 keyword not stored for message";
+ 	}
+
+	if not hasflag :comparator "i;ascii-numeric" :count "eq" "2" {
+		test_fail "invalid number of flags set for message";
+	}
+}
+
Index: b/sieve/tests/extensions/imap4flags/multiscript/fileinto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/multiscript/fileinto.sieve
@@ -0,0 +1,4 @@
+require "fileinto";
+require "mailbox";
+
+fileinto :create "folder";
Index: b/sieve/tests/extensions/imap4flags/multiscript/group-spam.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/multiscript/group-spam.sieve
@@ -0,0 +1,14 @@
+require ["fileinto", "variables", "envelope"];
+
+if header :contains "X-Group-Mail" ["Yes", "YES", "1"] {
+  if header :contains "X-Spam-Flag" ["Yes", "YES", "1"] {
+        if envelope :matches :localpart "to" "*" {
+		fileinto "group/${1}/SPAM"; stop;
+	}
+  }
+  if address :is ["To"] "sales@florist.ru" {
+  	fileinto "group/info/Orders";
+  }
+  stop;
+}
+keep;
Index: b/sieve/tests/extensions/imap4flags/multiscript/sent-store.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/multiscript/sent-store.sieve
@@ -0,0 +1,7 @@
+require ["imap4flags"];
+
+if header :contains "X-Set-Seen" ["Yes", "YES", "1"] {
+  	setflag "\\Seen";
+}
+
+keep;
Index: b/sieve/tests/extensions/imap4flags/multiscript/setflag.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/multiscript/setflag.sieve
@@ -0,0 +1,3 @@
+require "imap4flags";
+
+setflag "$label1 \\answered";
Index: b/sieve/tests/extensions/imap4flags/multiscript/spam.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/imap4flags/multiscript/spam.sieve
@@ -0,0 +1,8 @@
+require ["fileinto"];
+
+if header :contains "X-Spam-Flag" ["Yes", "YES", "1"] {
+  fileinto "SPAM";
+}
+keep;
+
+
Index: b/sieve/tests/extensions/include/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors.svtest
@@ -0,0 +1,77 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Generic include errors
+ */
+
+test "Generic" {
+	if test_script_compile "errors/generic.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Circular - direct" {
+	if test_script_compile "errors/circular-1.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Circular - one intermittent" {
+	if test_script_compile "errors/circular-2.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "4" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Circular - two intermittent" {
+	if test_script_compile "errors/circular-3.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "5" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+/*
+ * Using global without variables required
+ */
+
+test "Variables inactive" {
+	if test_script_compile "errors/variables-inactive.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+/*
+ * Generic variables errors
+ */
+
+test "Variables" {
+	if test_script_compile "errors/variables.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
Index: b/sieve/tests/extensions/include/errors/action-conflicts.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/action-conflicts.sieve
@@ -0,0 +1,4 @@
+require "include";
+
+include "action-fileinto";
+include "action-reject";
Index: b/sieve/tests/extensions/include/errors/circular-1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/circular-1.sieve
@@ -0,0 +1,5 @@
+require "include";
+
+discard;
+
+include "circular-one.sieve";
Index: b/sieve/tests/extensions/include/errors/circular-2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/circular-2.sieve
@@ -0,0 +1,5 @@
+require "include";
+
+discard;
+
+include "circular-two.sieve";
Index: b/sieve/tests/extensions/include/errors/circular-3.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/circular-3.sieve
@@ -0,0 +1,5 @@
+require "include";
+
+discard;
+
+include "circular-three";
Index: b/sieve/tests/extensions/include/errors/generic.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/generic.sieve
@@ -0,0 +1,7 @@
+require "include";
+
+# Non-existant sieve script
+include "frop.sieve";
+
+# Use of / in script names
+include "../frop.sieve";
Index: b/sieve/tests/extensions/include/errors/included/action-fileinto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/action-fileinto.sieve
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "frop";
Index: b/sieve/tests/extensions/include/errors/included/action-reject.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/action-reject.sieve
@@ -0,0 +1,3 @@
+require "reject";
+
+reject "Ik heb geen zin in die rommel.";
Index: b/sieve/tests/extensions/include/errors/included/circular-one.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/circular-one.sieve
@@ -0,0 +1,5 @@
+require "include";
+
+keep;
+
+include "circular-one.sieve";
Index: b/sieve/tests/extensions/include/errors/included/circular-three-2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/circular-three-2.sieve
@@ -0,0 +1,3 @@
+require "include";
+
+include "circular-three-3.sieve";
Index: b/sieve/tests/extensions/include/errors/included/circular-three-3.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/circular-three-3.sieve
@@ -0,0 +1,3 @@
+require "include";
+
+include "circular-three.sieve";
Index: b/sieve/tests/extensions/include/errors/included/circular-three.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/circular-three.sieve
@@ -0,0 +1,7 @@
+require "include";
+
+keep;
+
+include "circular-three-2.sieve";
+
+
Index: b/sieve/tests/extensions/include/errors/included/circular-two-2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/circular-two-2.sieve
@@ -0,0 +1,3 @@
+require "include";
+
+include "circular-two.sieve";
Index: b/sieve/tests/extensions/include/errors/included/circular-two.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/included/circular-two.sieve
@@ -0,0 +1,7 @@
+require "include";
+
+keep;
+
+include "circular-two-2.sieve";
+
+
Index: b/sieve/tests/extensions/include/errors/variables-inactive.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/variables-inactive.sieve
@@ -0,0 +1,7 @@
+require "include";
+require "fileinto";
+
+global "friep";
+global "frop";
+
+fileinto "Frop";
Index: b/sieve/tests/extensions/include/errors/variables.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/errors/variables.sieve
@@ -0,0 +1,8 @@
+require "include";
+require "variables";
+
+keep;
+
+# Global after command not being require or global
+global "friep";
+
Index: b/sieve/tests/extensions/include/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/execute.svtest
@@ -0,0 +1,42 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: idiot@example.com
+To: idiot@rename-it.nl
+Subject: Frop!
+
+Frop.
+.
+;
+
+test "Actions Fileinto" {
+	test_mailbox :create "aaaa";
+	test_mailbox :create "bbbb";
+
+	if not test_script_compile "execute/actions-fileinto.sieve" {
+		test_fail "failed to compile sieve script";
+	}
+
+	test_binary :save "actions-fileinto";
+	test_binary :load "actions-fileinto";
+
+	if not test_script_run {
+		test_fail "failed to execute sieve script";
+	}
+
+	if not test_result_execute {
+		test_fail "failed to execute result";
+	}
+
+	test_message :folder "aaaa" 0;
+
+	if not header "subject" "Frop!" {
+		test_fail "fileinto \"aaaa\" not executed.";
+	}
+
+	test_message :folder "aaaa" 0;
+
+	if not header "subject" "Frop!" {
+		test_fail "fileinto \"bbbb\" not executed.";
+	}
+}
Index: b/sieve/tests/extensions/include/execute/actions-fileinto.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/execute/actions-fileinto.sieve
@@ -0,0 +1,5 @@
+require "include";
+
+include "actions-fileinto1";
+include "actions-fileinto2";
+include "actions-fileinto3";
Index: b/sieve/tests/extensions/include/execute/included/actions-fileinto1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/execute/included/actions-fileinto1.sieve
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "aaaa";
Index: b/sieve/tests/extensions/include/execute/included/actions-fileinto2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/execute/included/actions-fileinto2.sieve
@@ -0,0 +1,4 @@
+require "fileinto";
+
+fileinto "bbbb";
+
Index: b/sieve/tests/extensions/include/execute/included/actions-fileinto3.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/execute/included/actions-fileinto3.sieve
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "aaaa";
Index: b/sieve/tests/extensions/include/included-global/rfc-ex1-spam_tests.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included-global/rfc-ex1-spam_tests.sieve
@@ -0,0 +1,7 @@
+require ["reject"];
+
+if anyof (header :contains "Subject" "$$",
+	header :contains "Subject" "Make money")
+{
+	reject "Not wanted";
+}
Index: b/sieve/tests/extensions/include/included/once-1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/once-1.sieve
@@ -0,0 +1,9 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} ONE";
+
+return;
+
Index: b/sieve/tests/extensions/include/included/once-2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/once-2.sieve
@@ -0,0 +1,12 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} TWO";
+
+keep;
+
+include :once "once-1.sieve";
+
+return;
Index: b/sieve/tests/extensions/include/included/once-3.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/once-3.sieve
@@ -0,0 +1,3 @@
+require "include";
+
+include "once-4";
Index: b/sieve/tests/extensions/include/included/once-4.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/once-4.sieve
@@ -0,0 +1,3 @@
+require "include";
+
+include :once "once-3";
Index: b/sieve/tests/extensions/include/included/rfc-ex1-always_allow.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/rfc-ex1-always_allow.sieve
@@ -0,0 +1,8 @@
+if header :is "From" "boss@example.com"
+{
+     keep;
+}
+elsif header :is "From" "ceo@example.com"
+{
+     keep;
+}
Index: b/sieve/tests/extensions/include/included/rfc-ex1-mailing_lists.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/rfc-ex1-mailing_lists.sieve
@@ -0,0 +1,10 @@
+require ["fileinto"];
+
+if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+{
+     fileinto "lists.sieve";
+}
+elsif header :is "Sender" "owner-ietf-imapext@imc.org"
+{
+     fileinto "lists.imapext";
+}
Index: b/sieve/tests/extensions/include/included/rfc-ex1-spam_tests.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/rfc-ex1-spam_tests.sieve
@@ -0,0 +1,10 @@
+require ["reject"];
+
+if header :contains "Subject" "XXXX"
+{
+	reject "Not wanted";
+}
+elsif header :is "From" "money@example.com"
+{
+	reject "Not wanted";
+}
Index: b/sieve/tests/extensions/include/included/rfc-ex2-spam_filter_script.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/rfc-ex2-spam_filter_script.sieve
@@ -0,0 +1,8 @@
+require ["variables", "include"];
+global ["test", "test_mailbox"];
+
+if header :contains "Subject" "${test}"
+{
+	set "test_mailbox" "spam-${test}";
+}
+
Index: b/sieve/tests/extensions/include/included/twice-1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/twice-1.sieve
@@ -0,0 +1,7 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} TWO";
+
Index: b/sieve/tests/extensions/include/included/twice-2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/twice-2.sieve
@@ -0,0 +1,8 @@
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "${result} THREE";
+
+include "twice-1.sieve";
Index: b/sieve/tests/extensions/include/included/variables-included1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/variables-included1.sieve
@@ -0,0 +1,7 @@
+require "include";
+require "variables";
+
+global ["value1", "value2"];
+global ["result1"];
+
+set "result1" "${value1} ${value2}";
Index: b/sieve/tests/extensions/include/included/variables-included2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/variables-included2.sieve
@@ -0,0 +1,6 @@
+require "include";
+require "variables";
+
+global ["value3", "value4", "result2"];
+
+set "result2" "${value3} ${value4}";
Index: b/sieve/tests/extensions/include/included/variables-included3.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/included/variables-included3.sieve
@@ -0,0 +1,8 @@
+require "include";
+require "variables";
+
+global "result1";
+global "result2";
+global "result";
+
+set "result" "${result1} ${result2}";
Index: b/sieve/tests/extensions/include/once.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/once.svtest
@@ -0,0 +1,24 @@
+require "vnd.dovecot.testsuite";
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "";
+
+test "Included Once" {
+	include "once-1";
+	include "once-2";
+
+	if string "${result}" " ONE TWO ONE" {
+		test_fail "duplicate included :once script";
+	}
+
+	if not string "${result}" " ONE TWO" {
+		test_fail "unexpected result value: ${result}";
+	}
+}
+
+test "Included Once recursive" {
+	include "once-3";
+}
Index: b/sieve/tests/extensions/include/rfc-ex1-default.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/rfc-ex1-default.sieve
@@ -0,0 +1,6 @@
+require ["include"];
+
+include :personal "rfc-ex1-always_allow";
+include :global "rfc-ex1-spam_tests";
+include :personal "rfc-ex1-spam_tests";
+include :personal "rfc-ex1-mailing_lists";
Index: b/sieve/tests/extensions/include/rfc-ex2-default.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/rfc-ex2-default.sieve
@@ -0,0 +1,21 @@
+require ["variables", "include", "relational", "fileinto"];
+global "test";
+global "test-mailbox";
+
+# The included script may contain repetitive code that is
+# effectively a subroutine that can be factored out.
+set "test" "$$";
+include "rfc-ex2-spam_filter_script";
+
+set "test" "Make money";
+include "rfc-ex2-spam_filter_script";
+
+# Message will be filed according to the test that matched last.
+if string :count "eq" "${test_mailbox}" "1"
+{
+	fileinto "INBOX${test_mailbox}";
+	stop;
+}
+
+# If nothing matched, the message is implicitly kept.
+
Index: b/sieve/tests/extensions/include/rfc.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/rfc.svtest
@@ -0,0 +1,13 @@
+require "vnd.dovecot.testsuite";
+
+test "RFC example 1" {
+	if not test_script_compile "rfc-ex1-default.sieve" {
+		test_fail "failed to compile sieve script";
+	}
+}
+
+test "RFC example 2" {
+	if not test_script_compile "rfc-ex2-default.sieve" {
+		test_fail "failed to compile sieve script";
+	}
+}
Index: b/sieve/tests/extensions/include/twice.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/twice.svtest
@@ -0,0 +1,20 @@
+require "vnd.dovecot.testsuite";
+require "include";
+require "variables";
+
+global "result";
+
+set "result" "ONE";
+
+test "Twice included" {
+	include "twice-1";
+	include "twice-2";
+
+	if string "${result}" "ONE TWO THREE" {
+		test_fail "duplicate include failed";
+	}
+
+	if not string "${result}" "ONE TWO THREE TWO" {
+		test_fail "unexpected result: ${result}";
+	}
+}
Index: b/sieve/tests/extensions/include/variables.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/include/variables.svtest
@@ -0,0 +1,28 @@
+require "vnd.dovecot.testsuite";
+
+require "include";
+require "variables";
+
+global ["value1", "value2"];
+global ["value3", "value4"];
+global "result";
+
+set "value1" "Works";
+set "value2" "fine.";
+set "value3" "Yeah";
+set "value4" "it does.";
+
+include "variables-included1";
+include "variables-included2";
+include "variables-included3";
+
+test "Basic" {
+	if not string :is "${result}" "Works fine. Yeah it does." {
+		test_fail "invalid result: ${result}";
+	}
+
+	if string :is "${result}" "nonsense" {
+		test_fail "string test succeeds inappropriately";
+	}
+}
+
Index: b/sieve/tests/extensions/mailbox/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/mailbox/execute.svtest
@@ -0,0 +1,80 @@
+require "vnd.dovecot.testsuite";
+require "mailbox";
+require "fileinto";
+
+test "MailboxExists - None exist" {
+	if mailboxexists "frop" {
+		test_fail "mailboxexists confirms existance of unknown folder";
+	}
+}
+
+test_mailbox :create "frop";
+test_mailbox :create "friep";
+
+test "MailboxExists - Not all exist" {
+	if mailboxexists ["frop", "friep", "frml"] {
+		test_fail "mailboxexists confirms existance of unknown folder";
+	}
+}
+
+test_mailbox :create "frml";
+
+test "MailboxExists - One exists" {
+	if not mailboxexists ["frop"] {
+		test_fail "mailboxexists fails to recognize folder";
+	}
+}
+
+test "MailboxExists - All exist" {
+	if not mailboxexists ["frop", "friep", "frml"] {
+		test_fail "mailboxexists fails to recognize folders";
+	}
+}
+
+test ":Create" {
+	if mailboxexists "created" {
+		test_fail "mailbox exists already";
+	}
+
+	test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop 1
+
+Frop!
+.
+	;
+
+	fileinto :create "created";
+
+	if not test_result_execute {
+		test_fail "execution of result failed";
+	}
+
+	if not mailboxexists "created" {
+		test_fail "mailbox somehow not created";
+	}
+
+	test_result_reset;
+
+	test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop 2
+
+Frop!
+.
+	;
+
+	fileinto "created";
+
+	if not test_result_execute {
+		test_fail "execution of result failed second time";
+	}
+
+	test_message :folder "created" 0;
+
+	if not header :is "subject" "Frop 1" {
+		test_fail "incorrect message read back from mail store";
+	}
+}
Index: b/sieve/tests/extensions/regex/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/regex/basic.svtest
@@ -0,0 +1,21 @@
+require "vnd.dovecot.testsuite";
+
+require "regex";
+
+test_set "message" text:
+From: stephan+sieve@drunksnipers.com
+To: tss@iki.fi
+Subject: Test
+
+Test message.
+.
+;
+
+test "Basic example" {
+	if not address :regex :comparator "i;ascii-casemap" "from" [
+		"stephan(\\+.*)?@rename-it\\.com",
+		"stephan(\\+.*)?@drunksnipers\\.com"
+		] {
+		test_fail "failed to match";
+	}
+}
Index: b/sieve/tests/extensions/regex/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/regex/errors.svtest
@@ -0,0 +1,14 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Compile errors" {
+	if test_script_compile "errors/compile.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "5" {
+		test_fail "wrong number of errors reported";
+	}
+}
Index: b/sieve/tests/extensions/regex/errors/compile.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/regex/errors/compile.sieve
@@ -0,0 +1,25 @@
+require "regex";
+require "comparator-i;ascii-numeric";
+require "envelope";
+
+if address :regex :comparator "i;ascii-numeric" "from" "sirius(\\+.*)?@drunksnipers\\.com" {
+	keep;
+	stop;
+}
+
+if address :regex "from" "sirius(+\\+.*)?@drunksnipers\\.com" {
+	keep;
+	stop;
+}
+
+if header :regex "from" "sirius(\\+.*)?@drunk[]snipers.com" {
+    keep;
+    stop;
+}
+
+if envelope :regex "from" "sirius(\\+.*)?@drunksni[]pers.com" {
+    keep;
+    stop;
+}
+
+discard;
Index: b/sieve/tests/extensions/regex/match-values.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/regex/match-values.svtest
@@ -0,0 +1,68 @@
+require "vnd.dovecot.testsuite";
+
+require "regex";
+require "variables";
+
+test_set "message" text:
+From: Andy Howell <AndyHowell@example.com>
+Sender: antlr-interest-bounces@antlr.org
+To: Stephan Bosch <stephan@rename-it.nl>
+Subject: [Dovecot] Sieve regex match problem
+
+Hi,
+
+I is broken.
+.
+;
+
+test "Basic match values 1" {
+	if header :regex ["Sender"] ["([^-@]*)-([^-@]*)(-bounces)?@antlr.org"] {
+
+		if not string :is "${1}" "antlr" {
+			test_fail "first match value is not correct";
+		}
+
+		if not string :is "${2}" "interest" {
+			test_fail "second match value is not correct";
+		}
+
+		if not string :is "${3}" "-bounces" {
+			test_fail "third match value is not correct";
+		}
+
+		if string :is "${4}" "-bounces" {
+			test_fail "fourth match contains third value";
+		}
+	}
+}
+
+test "Basic match values 2" {
+	if header :regex ["Sender"] ["(.*>[ \\t]*,?[ \\t]*)?([^-@]*)-([^-@]*)(-bounces)?@antlr.org"] {
+
+		if not string :is "${1}" "" {
+            test_fail "first match value is not correct: ${1}";
+        }
+
+		if not string :is "${2}" "antlr" {
+			test_fail "second match value is not correct: ${2}";
+		}
+
+		if not string :is "${3}" "interest" {
+			test_fail "third match value is not correct: ${3}";
+		}
+
+		if not string :is "${4}" "-bounces" {
+			test_fail "fourth match value is not correct: ${4}";
+		}
+
+		if string :is "${5}" "-bounces" {
+			test_fail "fifth match contains fourth value: ${5}";
+		}
+	}
+}
+
+
+
+
+
+
Index: b/sieve/tests/extensions/reject/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/reject/execute.svtest
@@ -0,0 +1,34 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test_set "message" text:
+To: nico@vestingbar.nl
+From: stephan@rename-it.nl
+Subject: Test
+
+Test.
+.
+;
+
+test "Execute" {
+	if not test_script_compile "execute/basic.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "1" {
+		test_fail "invalid number of actions in result";
+	}
+
+	if not test_result :index 1 "reject" {
+		test_fail "reject action missing from result";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
Index: b/sieve/tests/extensions/reject/execute/basic.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/reject/execute/basic.sieve
@@ -0,0 +1,8 @@
+require "reject";
+
+if address :contains "to" "vestingbar" {
+	reject "Don't send unrequested messages.";
+	stop;
+}
+
+keep;
Index: b/sieve/tests/extensions/reject/smtp.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/reject/smtp.svtest
@@ -0,0 +1,56 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+require "reject";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Frop!
+
+Frop!
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "timo@iki.fi";
+
+test "Basic" {
+	reject "I don't want your mail";
+
+	if not test_result_execute {
+        test_fail "failed to execute reject";
+    }
+
+    test_message :smtp 0;
+
+    if not address :is "to" "sirius@rename-it.nl" {
+        test_fail "to address incorrect";
+    }
+
+    if not header :contains "from" "Mail Delivery Subsystem" {
+        test_fail "from address incorrect";
+    }
+
+	if not envelope :is "to" "sirius@rename-it.nl" {
+		test_fail "envelope recipient incorrect";
+	}
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender not null";
+	}
+}
+
+test_result_reset;
+test_set "envelope.from" "<>";
+
+test "Null Sender" {
+	reject "I don't want your mail";
+
+	if not test_result_execute {
+		test_fail "failed to execute reject";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "reject sent message to NULL sender";
+	}
+}
Index: b/sieve/tests/extensions/relational/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/relational/basic.svtest
@@ -0,0 +1,178 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+/*
+ * Test message
+ */
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Cc: frop@rename-it.nl
+CC: timo@rename-it.nl
+X-Spam-Score: 300
+X-Nonsense: 1000
+X-Nonsense: 20
+X-Alpha: abcdzyx
+X-Count: a
+X-Count: b
+X-Count: c
+X-Count: d
+X-Count: e
+X-Count: f
+X-Count: g
+X-Count: h
+X-Count: i
+X-Count: j
+X-Count: k
+X-Count: l
+X-Count: m
+X-Count: n
+X-Count: o
+X-Count: p
+X-Count: q
+X-Count: r
+X-Count: s
+X-Count: t
+X-Count: u
+X-Count: v
+X-Count: w
+X-Count: x
+X-Count: y
+X-Count: z
+Subject: Test
+Comment:
+
+Test!
+.
+;
+
+/*
+ * Empty strings
+ */
+
+test "Value \"\" eq 40 (vs)" {
+	if header :value "eq" :comparator "i;ascii-numeric" "comment" "40" {
+		test_fail ":value matched empty string with i;ascii-numeric";
+	}
+
+	if header :value "gt" :comparator "i;ascii-numeric" "x-spam-score" "" {
+		test_fail ":value 300 exceeded empty string with i;ascii-numeric";
+	}
+
+	if header :value "gt" :comparator "i;ascii-numeric" "x-spam-score" "" {
+        test_fail ":count exceeded empty string with i;ascii-numeric";
+    }
+}
+
+/*
+ * Match type :value
+ */
+
+test "Value 300 eq 2" {
+	if header :value "eq" :comparator "i;ascii-numeric" "x-spam-score" "2" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Value 300 lt 2" {
+	if header :value "lt" :comparator "i;ascii-numeric" "x-spam-score" "2" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Value 300 le 300" {
+	if not header :value "le" :comparator "i;ascii-numeric" "x-spam-score" "300" {
+		test_fail "should have matched";
+	}
+}
+
+test "Value 300 le 302" {
+	if not header :value "le" :comparator "i;ascii-numeric" "x-spam-score" "302" {
+		test_fail "should have matched";
+	}
+}
+
+test "Value 302 le 00302" {
+	if not header :value "le" :comparator "i;ascii-numeric" "x-spam-score" "00302" {
+		test_fail "should have matched";
+    }
+}
+
+test "Value {1000,20} le 300" {
+    if not header :value "le" :comparator "i;ascii-numeric" "x-nonsense" "300" {
+        test_fail "should have matched";
+    }
+}
+
+test "Value {1000,20} lt 3" {
+    if header :value "lt" :comparator "i;ascii-numeric" "x-nonsense" "3" {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value {1000,20} gt 3000" {
+    if header :value "gt" :comparator "i;ascii-numeric" "x-nonsense" "3000" {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value {1000,20} gt {3000,30}" {
+    if not header :value "gt" :comparator "i;ascii-numeric" "x-nonsense" ["3000","30"] {
+        test_fail "should have matched";
+    }
+}
+
+test "Value {1000,20} lt {3, 19})" {
+    if header :value "lt" :comparator "i;ascii-numeric" "x-nonsense" ["3","19"] {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value {1000,20} gt {3000,1001}" {
+    if header :value "gt" :comparator "i;ascii-numeric" "x-nonsense" ["3000","1001"] {
+        test_fail "should not have matched";
+    }
+}
+
+test "Value abcdzyz gt aaaaaaa" {
+    if not header :value "gt" :comparator "i;octet" "x-alpha" "aaaaaaa" {
+        test_fail "should have matched";
+    }
+}
+
+/*
+ * Match type :count
+ */
+
+test "Count 2 ne 2" {
+	if header :count "ne" :comparator "i;ascii-numeric" "cc" "2" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Count 2 ge 2" {
+	if not header :count "ge" :comparator "i;ascii-numeric" "cc" "2" {
+		test_fail "should have matched";
+	}
+}
+
+test "Count 2 ge 002" {
+	if not header :count "ge" :comparator "i;ascii-numeric" "cc" "002" {
+		test_fail "should have matched";
+	}
+}
+
+test "Count 26 lt {4,5,6,10,20}" {
+	if header :count "lt" :comparator "i;ascii-numeric" "x-count" ["4","5","6","10","20"] {
+		test_fail "should not have matched";
+	}
+}
+
+test "Count 26 lt {4,5,6,10,20,100}" {
+	if not header :count "lt" :comparator "i;ascii-numeric" "x-count" ["4","5","6","10","20","100"] {
+		test_fail "should have matched";
+	}
+}
Index: b/sieve/tests/extensions/relational/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/relational/errors.svtest
@@ -0,0 +1,15 @@
+require "vnd.dovecot.testsuite";
+
+# A bit awkward to test the extension with itself
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Validation errors" {
+	if test_script_compile "errors/validation.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if test_error :count "ne" "3" {
+		test_fail "wrong number of errors reported";
+	}
+}
Index: b/sieve/tests/extensions/relational/errors/validation.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/relational/errors/validation.sieve
@@ -0,0 +1,11 @@
+require "relational";
+
+# Not a valid relation (1)
+if header :value "gr" "from" "ah" {
+	keep;
+}
+
+# Not a valid relation (1)
+if header :count "lf" "from" "eek" {
+	keep;
+}
Index: b/sieve/tests/extensions/relational/rfc.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/relational/rfc.svtest
@@ -0,0 +1,71 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test_set "message" text:
+Received: ...
+Received: ...
+Subject: example
+To: foo@example.com, baz@example.com
+CC: qux@example.com
+
+RFC Example
+.
+;
+
+test "Example 1" {
+	# The test:
+
+	if not address :count "ge" :comparator "i;ascii-numeric"
+		["to", "cc"] ["3"] {
+
+		test_fail "should have counted three addresses";
+	}
+
+    # would evaluate to true, and the test
+
+	if anyof (
+			address :count "ge" :comparator "i;ascii-numeric"
+				["to"] ["3"],
+			address :count "ge" :comparator "i;ascii-numeric"
+				["cc"] ["3"]
+	) {
+
+		test_fail "should not have counted three addresses";
+	}
+
+	# would evaluate to false.
+
+	# To check the number of received fields in the header, the following
+	# test may be used:
+
+	if header :count "ge" :comparator "i;ascii-numeric"
+ 		["received"] ["3"] {
+
+		test_fail "should not have counted three received headers";
+	}
+
+	# This would evaluate to false.  But
+
+	if not header :count "ge" :comparator "i;ascii-numeric"
+		["received", "subject"] ["3"] {
+
+		test_fail "should have counted three headers";
+	}
+
+	# would evaluate to true.
+
+	# The test:
+
+	if header :count "ge" :comparator "i;ascii-numeric"
+		["to", "cc"] ["3"] {
+
+		test_fail "should not have counted three to or cc headers";
+	}
+
+	# will always evaluate to false on an RFC 2822 compliant message
+	# [RFC2822], since a message can have at most one "to" field and at
+	# most one "cc" field.  This test counts the number of fields, not the
+	# number of addresses.
+}
Index: b/sieve/tests/extensions/subaddress/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/subaddress/basic.svtest
@@ -0,0 +1,111 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+require "subaddress";
+
+test_set "message" text:
+From: stephan+sieve@renane-it.nl
+To: test+failed@example.com
+Subject: subaddress test
+
+Test!
+.
+;
+
+test_set "envelope.to" "friep+frop@dovecot.org";
+test_set "envelope.from" "list+request@lists.dovecot.org";
+
+test "Address from :user" {
+	if not address :is :user "from" "stephan" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :is :user "from" "nonsence" {
+		test_fail "address test failed";
+	}
+}
+
+test "Address from :detail" {
+	if not address :is :detail "from" "sieve" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :is :detail "from" "nonsence" {
+		test_fail "address test failed";
+	}
+}
+
+test "Address to :user" {
+	if not address :contains :user "to" "est" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :contains :user "to" "ail" {
+		test_fail "address test failed";
+	}
+}
+
+test "Address to :detail" {
+	if not address :contains :detail "to" "fai" {
+		test_fail "wrong user part extracted";
+	}
+
+	if address :contains :detail "to" "sen" {
+		test_fail "address test failed";
+	}
+}
+
+
+test "Envelope :user" {
+    if not envelope :is :user "to" "friep" {
+        test_fail "wrong user part extracted 1";
+    }
+
+    if not envelope :comparator "i;ascii-casemap" :is :user "to" "FRIEP" {
+        test_fail "wrong user part extracted";
+    }
+
+    if envelope :comparator "i;ascii-casemap" :is :user "to" "FROP" {
+        test_fail "envelope test failed";
+    }
+}
+
+test "Envelope :detail" {
+    if not envelope :comparator "i;ascii-casemap" :contains :detail "from" "QUES" {
+        test_fail "wrong user part extracted";
+    }
+
+    if envelope :comparator "i;ascii-casemap" :contains :detail "from" "LIS" {
+        test_fail "address test failed";
+    }
+}
+
+test_set "message" text:
+From: frop@examples.com
+To: undisclosed-recipients:;
+Subject: subaddress test
+
+Test!
+.
+;
+
+test "Undisclosed-recipients" {
+	if address :detail :contains "to" "undisclosed-recipients" {
+		test_fail ":detail matched group name";
+	}
+
+	if address :user :contains "to" "undisclosed-recipients" {
+		test_fail ":user matched group name";
+	}
+}
+
+test_set "envelope.to" "frop@sieve.nl";
+
+test "No detail" {
+	if envelope :detail "to" "virus" {
+		test_fail ":detail matched non-existant detail element in envelope (separator is missing)";
+	}
+
+	if address :detail "from" "virus" {
+		test_fail ":detail matched non-existant detail element in from header (separator is missing)";
+	}
+}
Index: b/sieve/tests/extensions/subaddress/rfc.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/subaddress/rfc.svtest
@@ -0,0 +1,59 @@
+require "vnd.dovecot.testsuite";
+
+require "subaddress";
+
+test_set "message" text:
+From: stephan+@rename-it.nl
+To: timo+spam@iki.fi
+CC: nico@example.com
+Subject: fetch my spam
+
+Mouhahahaha... Spam!
+.
+;
+
+
+/*
+ * The ":user" argument specifies the user sub-part of the local-part of
+ * an address.  If the address is not encoded to contain a detail sub-
+ * part, then ":user" specifies the entire left side of the address
+ * (equivalent to ":localpart").
+ */
+
+test "User sub-part" {
+	if not address :user "cc" "nico" {
+		test_fail "wrong :user part extracted (1)";
+	}
+
+	if not address :user "to" "timo" {
+		test_fail "wrong :user part extracted (2)";
+	}
+
+	if not address :user "from" "stephan" {
+		test_fail "wrong :user part extracted (3)";
+	}
+}
+
+/* The ":detail" argument specifies the detail sub-part of the local-
+ * part of an address.  If the address is not encoded to contain a
+ * detail sub-part, then the address fails to match any of the specified
+ * keys.  If a zero-length string is encoded as the detail sub-part,
+ * then ":detail" resolves to the empty value ("").
+ */
+
+test "Detail sub-part" {
+	if not address :detail "to" "spam" {
+		test_fail "wrong :detail part extracted";
+	}
+
+	if anyof (
+		address :detail :matches "cc" ["*", "?"],
+		address :detail :contains "cc" "",
+		address :detail :is "cc" "" ) {
+		test_fail ":detail inappropriately matched missing detail sub-part";
+	}
+
+	if not address :detail "from" "" {
+		test_fail "wrong empty :detail part extracted";
+	}
+}
Index: b/sieve/tests/extensions/vacation/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/errors.svtest
@@ -0,0 +1,19 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Action conflicts: reject <-> vacation" {
+	if not test_script_compile "errors/conflict-reject.sieve" {
+		test_fail "compile failed";
+	}
+
+	if test_script_run {
+		test_fail "execution should have failed";
+	}
+
+	if test_error :count "gt" :comparator "i;ascii-numeric" "1" {
+		test_fail "too many runtime errors reported";
+	}
+}
+
Index: b/sieve/tests/extensions/vacation/errors/conflict-reject.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/errors/conflict-reject.sieve
@@ -0,0 +1,5 @@
+require "vacation";
+require "reject";
+
+vacation "Ik ben ff weg.";
+reject "Ik heb nu geen zin aan mail.";
Index: b/sieve/tests/extensions/vacation/execute.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/execute.svtest
@@ -0,0 +1,43 @@
+require "vnd.dovecot.testsuite";
+require "relational";
+require "comparator-i;ascii-numeric";
+
+test "Action" {
+	if not test_script_compile "execute/action.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script run failed";
+	}
+
+	if not test_result :count "eq" :comparator "i;ascii-numeric" "2" {
+		test_fail "invalid number of actions in result";
+	}
+
+	if not test_result :index 1 "vacation" {
+		test_fail "vacation action is not present as first item in result";
+	}
+
+	if not test_result :index 2 "keep" {
+		test_fail "keep action is missing in result";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "No :handle specified" {
+	if not test_script_compile "execute/no-handle.sieve" {
+		test_fail "script compile failed";
+	}
+
+	if not test_script_run {
+		test_fail "script execute failed";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
Index: b/sieve/tests/extensions/vacation/execute/action.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/execute/action.sieve
@@ -0,0 +1,4 @@
+require "vacation";
+
+vacation :addresses "stephan@rename-it.nl" "I am not at home today";
+keep;
Index: b/sieve/tests/extensions/vacation/execute/no-handle.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/execute/no-handle.sieve
@@ -0,0 +1,7 @@
+require "vacation";
+require "variables";
+
+set "reason" "I have a conference in Seattle";
+
+vacation :subject "I am not in: ${reason}" :from "stephan@rename-it.nl" "I am gone for today: ${reason}.";
+
Index: b/sieve/tests/extensions/vacation/message.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/message.svtest
@@ -0,0 +1,48 @@
+require "vnd.dovecot.testsuite";
+require "vacation";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Subject: frop
+References: <1234@local.machine.example> <3456@example.net>
+ <435444@ttms.com> <4223@froop.nl> <m345444444@message-id.exp>
+Message-ID: <432df324@rename-it.nl>
+To: nico@vestingbar.nl
+
+Frop
+.
+;
+
+test "References" {
+	vacation "I am not in today!";
+
+	if not test_result_execute {
+		test_fail "execution of result failed";
+	}
+
+	test_message :smtp 0;
+
+	if not header :contains "references" "432df324@rename-it.nl" {
+		test_fail "references header does not contain new id";
+	}
+
+	if anyof (
+		not header :contains "references" "1234@local.machine.example",
+		not header :contains "references" "3456@example.net",
+		not header :contains "references" "435444@ttms.com",
+		not header :contains "references" "4223@froop.nl",
+		not header :contains "references" "m345444444@message-id.exp"
+		) {
+		test_fail "references header does not contain all existing ids";
+	}
+
+	if header :contains "references" "hutsefluts" {
+		test_fail "references header contains nonsense";
+	}
+}
+
+test "In-Reply-To" {
+	if not header :is "in-reply-to" "<432df324@rename-it.nl>" {
+		test_fail "in-reply-to header set incorrectly";
+	}
+}
Index: b/sieve/tests/extensions/vacation/references.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/references.sieve
@@ -0,0 +1,4 @@
+require "vacation";
+
+vacation "I am on vacation.";
+discard;
Index: b/sieve/tests/extensions/vacation/smtp.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/smtp.svtest
@@ -0,0 +1,56 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+require "vacation";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: tss@iki.fi
+Subject: Frop!
+
+Frop!
+.
+;
+
+test_set "envelope.from" "sirius@rename-it.nl";
+test_set "envelope.to" "timo@iki.fi";
+
+test "Basic" {
+	vacation :addresses "tss@iki.fi" :from "Timo Sirainen <tss@iki.fi>" "I am gone";
+
+	if not test_result_execute {
+        test_fail "failed to execute vacation";
+    }
+
+    test_message :smtp 0;
+
+    if not address :is "to" "sirius@rename-it.nl" {
+        test_fail "to address incorrect";
+    }
+
+    if not address :is "from" "tss@iki.fi" {
+        test_fail "from address incorrect";
+    }
+
+	if not envelope :is "to" "sirius@rename-it.nl" {
+		test_fail "envelope recipient incorrect";
+	}
+
+	if not envelope :is "from" "" {
+		test_fail "envelope sender not null";
+	}
+}
+
+test_result_reset;
+test_set "envelope.from" "<>";
+
+test "Null Sender" {
+	vacation :addresses "tss@iki.fi" "I am gone";
+
+	if not test_result_execute {
+		test_fail "failed to execute vacation";
+	}
+
+	if test_message :smtp 0 {
+		test_fail "reject sent message to NULL sender";
+	}
+}
Index: b/sieve/tests/extensions/vacation/utf-8.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/vacation/utf-8.svtest
@@ -0,0 +1,42 @@
+require "vnd.dovecot.testsuite";
+require "vacation";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Subject: frop
+References: <1234@local.machine.example> <3456@example.net>
+ <435444@ttms.com> <4223@froop.nl> <m345444444@message-id.exp>
+Message-ID: <432df324@rename-it.nl>
+To: nico@vestingbar.nl
+
+Frop
+.
+;
+test "UTF-8 Subject" {
+	/* Trigger vacation response with rediculous Russian subject */
+	vacation :subject "Auto: Я могу есть стекло, оно мне не вредит."
+		"I am not in today";
+
+	/* Execute Sieve result (sending message to dummy SMTP) */
+    if not test_result_execute {
+        test_fail "execution of result failed";
+    }
+
+	/* Retrieve message from dummy SMTP and set it as the active message under
+	 * test.
+	 */
+    test_message :smtp 0;
+
+	set "expected" "Auto: Я могу есть стекло, оно мне не вредит.";
+	if not header :is "subject" "${expected}" {
+		if header :matches "subject" "*" { set "subject" "${1}"; }
+
+        test_fail text:
+subject header is not encoded/decoded properly:
+expected: ${expected}
+decoded: ${subject}
+.
+;
+    }
+}
Index: b/sieve/tests/extensions/variables/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/basic.svtest
@@ -0,0 +1,223 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: test@example.com
+Subject: Variables test
+
+Testing variables...
+.
+;
+
+/*
+ * Substitution syntax
+ */
+
+test "Unknown variables" {
+	set "q" "a";
+	set "qw" "bb";
+	set "qwe" "ccc";
+	set "qwer" "dddd";
+	set "qwert" "ccc";
+
+	if anyof (
+		not string "[${qwerty}]" "[]",
+		not string "[${20}]" "[]"
+	) {
+		test_fail "unknown variable not substituted with empty string";
+	}
+}
+
+test "One pass" {
+	set "something" "value";
+	set "s" "$";
+
+	if string "${s}{something}" "value" {
+		test_fail "somehow variable string is scanned multiple times";
+	}
+
+	if not string :matches "${s}{something}" "?{something}" {
+		test_fail "unexpected result";
+	}
+}
+
+test "Syntax errors" {
+	set "s" "$";
+	set "variable" "nonsense";
+
+	if anyof (
+		not string "$" "${s}",
+		not string "${" "${s}{",
+		not string "${a" "${s}{a",
+		not string "${$}" "${s}{$}",
+		not string "${%%%%}" "${s}{%%%%}",
+		not string "${0.s}" "${s}{0.s}",
+		not string "&%${}!" "&%${s}{}!",
+		not string "${doh!}" "${s}{doh!}" )
+	{
+		test_fail "variables substitution changed substring not matching variable-ref";
+	}
+}
+
+test "RFC syntax examples" {
+	# The variable "company" holds the value "ACME".  No other variables
+    # are set.
+	set "company" "ACME";
+
+	# "${full}"         => the empty string
+	if not string :is "${full}" "" {
+		test_fail "unknown variable did not yield empty string";
+	}
+
+	# "${company}"      => "ACME"
+	if not string :is "${company}" "ACME" {
+		test_fail "assigned variable did not get substituted";
+	}
+
+	# "${BAD${Company}" => "${BADACME"
+	if not string :is "${BAD${Company}" "${BADACME" {
+		test_fail "'BADACME' test did not yield expected result";
+	}
+
+	#"${President, ${Company} Inc.}"
+	#                        => "${President, ACME Inc.}"
+	if not string "${President, ${Company} Inc.}"
+		"${President, ACME Inc.}" {
+		test_fail "'Company president' test did not yield expected result";
+	}
+}
+
+/*
+ * Variable assignments
+ */
+
+test "Basic assignment" {
+	set "test" "Value";
+
+	if not string :is "${test}" "Value" {
+		test_fail "variable assignment failed";
+	}
+
+	if string :is "${test}" "value" {
+		test_fail "string test failed";
+	}
+}
+
+test "Assignment overwritten" {
+	set "test" "Value";
+	set "test" "More";
+
+	if not string :is "${test}" "More" {
+		test_fail "variable assignment failed";
+	}
+
+	if string :is "${test}" "Value" {
+		test_fail "value not overwritten";
+	}
+
+	if string :is "${test}" "nonsense" {
+		test_fail "string test failed";
+	}
+}
+
+test "Two assignments" {
+	set "test" "Value";
+	set "test2" "More";
+
+	if not string :is "${test}" "Value" {
+		test_fail "variable assignment failed";
+	}
+
+	if string :is "${test}" "More" {
+		test_fail "assignments to different variables overlap";
+	}
+
+	if string :is "${test}" "nonsense" {
+		test_fail "string test failed";
+	}
+}
+
+test "Variables case-insensitive" {
+	set "VeRyElAboRATeVaRIABLeName" "interesting value";
+
+	if not string "${veryelaboratevariablename}" "interesting value" {
+		test_fail "variable names are case sensitive (lower case try)";
+	}
+
+	if not string "${VERYELABORATEVARIABLENAME}" "interesting value" {
+		test_fail "variable names are case sensitive (upper case try)";
+	}
+}
+
+test "RFC set command example" {
+	set "honorific"  "Mr";
+	set "first_name" "Wile";
+	set "last_name"  "Coyote";
+	set "vacation" text:
+Dear ${HONORIFIC} ${last_name},
+I'm out, please leave a message after the meep.
+.
+;
+	if not string :is :comparator "i;octet" "${VAcaTION}" text:
+Dear Mr Coyote,
+I'm out, please leave a message after the meep.
+.
+	{
+		test_fail "failed to set variable correctly: ${VAcaTION}";
+	}
+}
+
+/*
+ * Variable substitution
+ */
+
+test "Multi-line string substitution" {
+	set "name" "Stephan Bosch";
+	set "address" "stephan@rename-it.nl";
+	set "subject" "Test message";
+
+	set "message" text: # Message with substitutions
+From: ${name} <${address}>
+To: Bertus van Asseldonk <b.vanasseldonk@hetkennet.nl>
+Subject: ${subject}
+
+This is a test message.
+.
+;
+	if not string :is "${message}" text:
+From: Stephan Bosch <stephan@rename-it.nl>
+To: Bertus van Asseldonk <b.vanasseldonk@hetkennet.nl>
+Subject: Test message
+
+This is a test message.
+.
+	{
+		test_fail "variable substitution failed";
+	}
+}
+
+test "Multiple substitutions" {
+	set "a" "the monkey";
+	set "b" "a nut";
+	set "c" "the fish";
+	set "d" "on fire";
+	set "e" "eats";
+	set "f" "is";
+
+	if not string :is "${a} ${e} ${b}" "the monkey eats a nut" {
+		test_fail "variable substitution failed (1)";
+	}
+
+	if not string :is "${c} ${f} ${d}" "the fish is on fire" {
+		test_fail "variable substitution failed (2)";
+	}
+
+	set :upperfirst "sentence" "${a} ${e} ${b}";
+
+	if not string :is "${sentence}" "The monkey eats a nut" {
+		test_fail "modified variable substitution failed";
+	}
+}
+
+
Index: b/sieve/tests/extensions/variables/errors.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/errors.svtest
@@ -0,0 +1,34 @@
+require "vnd.dovecot.testsuite";
+
+require "comparator-i;ascii-numeric";
+require "relational";
+
+test "Invalid namespaces (FIXME: count only)" {
+	if test_script_compile "errors/namespace.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "5" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Invalid set command invocations (FIXME: count only)" {
+	if test_script_compile "errors/set.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "7" {
+		test_fail "wrong number of errors reported";
+	}
+}
+
+test "Limits (FIXME: count only)" {
+	if test_script_compile "errors/limits.sieve" {
+		test_fail "compile should have failed";
+	}
+
+	if not test_error :count "eq" :comparator "i;ascii-numeric" "6" {
+		test_fail "wrong number of errors reported";
+	}
+}
Index: b/sieve/tests/extensions/variables/errors/limits.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/errors/limits.sieve
@@ -0,0 +1,287 @@
+require "variables";
+
+# Not an error (0)
+set "var123456789012345678901234567890" "value";
+
+# Exceed the maximum variable name length (1)
+set "var123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" "value";
+
+# Must yield unknown namespace error (no limit exceeded) (1)
+set "namespace.sub.sub.variable" "value";
+
+# Must yield unknown namespace error (exceeds element limit) (1)
+set "namespace.sub.sub.sub.variable" "value";
+
+# Not an error (0)
+if string "${32}" "value" {
+	stop;
+}
+
+# Exceed the maximum match value index (1)
+if string "${33}" "value" {
+	stop;
+}
+
+# Exceed the maximum number of declared variables (1!)
+set "var001" "value";
+set "var002" "value";
+set "var003" "value";
+set "var004" "value";
+set "var005" "value";
+set "var006" "value";
+set "var007" "value";
+set "var008" "value";
+set "var009" "value";
+set "var010" "value";
+set "var011" "value";
+set "var012" "value";
+set "var013" "value";
+set "var014" "value";
+set "var015" "value";
+set "var016" "value";
+set "var017" "value";
+set "var018" "value";
+set "var019" "value";
+set "var020" "value";
+set "var021" "value";
+set "var022" "value";
+set "var023" "value";
+set "var024" "value";
+set "var025" "value";
+set "var026" "value";
+set "var027" "value";
+set "var028" "value";
+set "var029" "value";
+set "var030" "value";
+set "var031" "value";
+set "var032" "value";
+set "var033" "value";
+set "var034" "value";
+set "var035" "value";
+set "var036" "value";
+set "var037" "value";
+set "var038" "value";
+set "var039" "value";
+set "var040" "value";
+set "var041" "value";
+set "var042" "value";
+set "var043" "value";
+set "var044" "value";
+set "var045" "value";
+set "var046" "value";
+set "var047" "value";
+set "var048" "value";
+set "var049" "value";
+set "var050" "value";
+set "var051" "value";
+set "var052" "value";
+set "var053" "value";
+set "var054" "value";
+set "var055" "value";
+set "var056" "value";
+set "var057" "value";
+set "var058" "value";
+set "var059" "value";
+set "var060" "value";
+set "var061" "value";
+set "var062" "value";
+set "var063" "value";
+set "var064" "value";
+set "var065" "value";
+set "var066" "value";
+set "var067" "value";
+set "var068" "value";
+set "var069" "value";
+set "var070" "value";
+set "var071" "value";
+set "var072" "value";
+set "var073" "value";
+set "var074" "value";
+set "var075" "value";
+set "var076" "value";
+set "var077" "value";
+set "var078" "value";
+set "var079" "value";
+set "var080" "value";
+set "var081" "value";
+set "var082" "value";
+set "var083" "value";
+set "var084" "value";
+set "var085" "value";
+set "var086" "value";
+set "var087" "value";
+set "var088" "value";
+set "var089" "value";
+set "var090" "value";
+set "var091" "value";
+set "var092" "value";
+set "var093" "value";
+set "var094" "value";
+set "var095" "value";
+set "var096" "value";
+set "var097" "value";
+set "var098" "value";
+set "var099" "value";
+
+set "var100" "value";
+set "var101" "value";
+set "var102" "value";
+set "var103" "value";
+set "var104" "value";
+set "var105" "value";
+set "var106" "value";
+set "var107" "value";
+set "var108" "value";
+set "var109" "value";
+set "var110" "value";
+set "var111" "value";
+set "var112" "value";
+set "var113" "value";
+set "var114" "value";
+set "var115" "value";
+set "var116" "value";
+set "var117" "value";
+set "var118" "value";
+set "var119" "value";
+set "var120" "value";
+set "var121" "value";
+set "var122" "value";
+set "var123" "value";
+set "var124" "value";
+set "var125" "value";
+set "var126" "value";
+set "var127" "value";
+set "var128" "value";
+set "var129" "value";
+set "var130" "value";
+set "var131" "value";
+set "var132" "value";
+set "var133" "value";
+set "var134" "value";
+set "var135" "value";
+set "var136" "value";
+set "var137" "value";
+set "var138" "value";
+set "var139" "value";
+set "var140" "value";
+set "var141" "value";
+set "var142" "value";
+set "var143" "value";
+set "var144" "value";
+set "var145" "value";
+set "var146" "value";
+set "var147" "value";
+set "var148" "value";
+set "var149" "value";
+set "var150" "value";
+set "var151" "value";
+set "var152" "value";
+set "var153" "value";
+set "var154" "value";
+set "var155" "value";
+set "var156" "value";
+set "var157" "value";
+set "var158" "value";
+set "var159" "value";
+set "var160" "value";
+set "var161" "value";
+set "var162" "value";
+set "var163" "value";
+set "var164" "value";
+set "var165" "value";
+set "var166" "value";
+set "var167" "value";
+set "var168" "value";
+set "var169" "value";
+set "var170" "value";
+set "var171" "value";
+set "var172" "value";
+set "var173" "value";
+set "var174" "value";
+set "var175" "value";
+set "var176" "value";
+set "var177" "value";
+set "var178" "value";
+set "var179" "value";
+set "var180" "value";
+set "var181" "value";
+set "var182" "value";
+set "var183" "value";
+set "var184" "value";
+set "var185" "value";
+set "var186" "value";
+set "var187" "value";
+set "var188" "value";
+set "var189" "value";
+set "var190" "value";
+set "var191" "value";
+set "var192" "value";
+set "var193" "value";
+set "var194" "value";
+set "var195" "value";
+set "var196" "value";
+set "var197" "value";
+set "var198" "value";
+set "var199" "value";
+set "var200" "value";
+
+set "var201" "value";
+set "var202" "value";
+set "var203" "value";
+set "var204" "value";
+set "var205" "value";
+set "var206" "value";
+set "var207" "value";
+set "var208" "value";
+set "var209" "value";
+set "var210" "value";
+set "var211" "value";
+set "var212" "value";
+set "var213" "value";
+set "var214" "value";
+set "var215" "value";
+set "var216" "value";
+set "var217" "value";
+set "var218" "value";
+set "var219" "value";
+set "var220" "value";
+set "var221" "value";
+set "var222" "value";
+set "var223" "value";
+set "var224" "value";
+set "var225" "value";
+set "var226" "value";
+set "var227" "value";
+set "var228" "value";
+set "var229" "value";
+set "var230" "value";
+set "var231" "value";
+set "var232" "value";
+set "var233" "value";
+set "var234" "value";
+set "var235" "value";
+set "var236" "value";
+set "var237" "value";
+set "var238" "value";
+set "var239" "value";
+set "var240" "value";
+set "var241" "value";
+set "var242" "value";
+set "var243" "value";
+set "var244" "value";
+set "var245" "value";
+set "var246" "value";
+set "var247" "value";
+set "var248" "value";
+set "var249" "value";
+set "var250" "value";
+set "var251" "value";
+set "var252" "value";
+set "var253" "value";
+set "var254" "value";
+set "var255" "value";
+set "var256" "value";
+set "var257" "value";
+set "var258" "value";
+set "var259" "value";
+set "var260" "value";
Index: b/sieve/tests/extensions/variables/errors/namespace.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/errors/namespace.sieve
@@ -0,0 +1,8 @@
+require "variables";
+require "fileinto";
+
+set "namespace.frop" "value";
+set "complex.struct.frop" "value";
+
+fileinto "${namespace.frop}";
+fileinto "${complex.struct.frop}";
Index: b/sieve/tests/extensions/variables/errors/set.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/errors/set.sieve
@@ -0,0 +1,19 @@
+require "variables";
+
+# Invalid variable name
+set "${frop}" "frop";
+set "...." "frop";
+set "name." "frop";
+set ".name" "frop";
+
+# Not an error
+set "\n\a\m\e" "frop";
+
+# Trying to assign match variable;
+set "0" "frop";
+
+# Not an error
+set :UPPER "name" "frop";
+
+# Invalid tag
+set :inner "name" "frop";
Index: b/sieve/tests/extensions/variables/match.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/match.svtest
@@ -0,0 +1,365 @@
+require "vnd.dovecot.testsuite";
+
+require "variables";
+
+/*
+ * RFC compliance
+ */
+
+# Test acceptance of leading zeroes
+test "RFC - leading zeroes" {
+	if not string :matches "frop:frup:frop" "*:*:*" {
+		test_fail "failed to match";
+	}
+
+	if not string :is "${0000002}" "frup" {
+		test_fail "incorrect match value (0000002): ${0000002}";
+	}
+}
+
+# Test non-greedyness
+test "RFC - not greedy" {
+	if not string :matches "frop.......frop.........frop...." "?*frop*" {
+		test_fail "failed to match";
+	}
+
+	if not string :is "${1}${2}${3}" "frop................frop...." {
+		test_fail "incorrect match values: ${1}${2}${3}";
+	}
+}
+
+# Index out of range
+test "RFC - index out of range" {
+	if not string :matches "test" "*" {
+		test_fail "failed to match (impossible)";
+	}
+
+	if not string :is "${2}" "" {
+		test_fail "incorrect match value: '${2}'";
+	}
+}
+
+# Index 0
+test "RFC - index 0" {
+	if not string :matches "a b c d e f g" "? ? ? ? ? ? ?" {
+		test_fail "failed to match";
+	}
+
+	if not string :is "${0}" "a b c d e f g" {
+        test_fail "incorrect match value: ${0}";
+    }
+}
+
+# Test short-circuit
+test "RFC - test short-circuit" {
+	if not anyof (
+		string :matches "a b c d e f g" "? ?",
+		string :matches "puk pok puk pok" "pu*ok",
+		string :matches "snot kip snot" "snot*snot"
+	) {
+		test_fail "failed to match any";
+	}
+
+	if string :is "${1}" " kip " {
+		test_fail "did not short-circuit test execution or intented test failed.";
+	}
+
+	if not string :is "${1}" "k pok puk p" {
+		test_fail "incorrect match value: ${1}";
+	}
+}
+
+# Test overwriting only on match
+test "RFC - values overwrite" {
+	set "sentence1" "the cat jumps off the table";
+	set "sentence2" "the dog barks at the cat in the alley";
+
+	if not string :matches "${sentence1}" "the * jumps off the *" {
+		test_fail "failed to match first sentence";
+	}
+
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "invalid match values";
+	}
+
+	if string :matches "${sentence2}" "the * barks at the * in the store" {
+		test_fail "should not have matched second sentence";
+	}
+
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "should have preserved match values";
+	}
+
+	if not string :matches "${sentence2}" "the * barks at the * in the alley" {
+		test_fail "failed to match the second sentence (second time)";
+	}
+
+	if not string :is "${1}:${2}" "dog:cat" {
+		test_fail "should have overwritten match values";
+	}
+}
+
+test "RFC - example" {
+	test_set "message" text:
+Subject: [acme-users] [fwd] version 1.0 is out
+List-Id: Dovecot Mailing List <dovecot@dovecot.org>
+To: coyote@ACME.Example.COM
+Fom: stephan@rename-it.nl
+
+Test message.
+.
+;
+	if header :matches "List-ID" "*<*@*" {
+		if not string "INBOX.lists.${2}" "INBOX.lists.dovecot" {
+			test_fail "incorrect match value: INBOX.lists.${2}";
+		}
+	} else {
+		test_fail "failed to match list header";
+	}
+
+	# Imagine the header
+	# Subject: [acme-users] [fwd] version 1.0 is out
+	if header :matches "Subject" "[*] *" {
+		# ${1} will hold "acme-users",
+		# ${2} will hold "[fwd] version 1.0 is out"
+
+		if anyof (
+			not string "${1}" "acme-users",
+			not string "${2}" "[fwd] version 1.0 is out"
+		) {
+			test_fail "invalid match values: ${1} ${2}";
+		}
+	} else {
+		test_fail "failed to match subject";
+	}
+
+	# Imagine the header
+	# To: coyote@ACME.Example.COM
+	if address :matches ["To", "Cc"] ["coyote@**.com",
+		"wile@**.com"] {
+		# ${0} is the matching address
+		# ${1} is always the empty string
+		# ${2} is part of the domain name ("ACME.Example")
+
+		if anyof (
+			not string "${0}" "coyote@ACME.Example.COM",
+			not string "${1}" "",
+			not string "${2}" "ACME.Example"
+		) {
+			test_fail "invalid match values: ${0}, ${1}, ${2}";
+		}
+	} else {
+		# Control wouldn't reach this block if any match was
+		# successful, so no match variables are set at this
+ 		# point.
+
+		test_fail "failed to match to address";
+ 	}
+
+	if anyof (true, address :domain :matches "To" "*.com") {
+		# The second test is never evaluated, so there are
+		# still no match variables set.
+
+		/* FIXME: not compliant */
+	}
+}
+
+/*
+ * Generic tests
+ */
+
+set "match1" "Test of general stupidity";
+
+test "Begin" {
+	if not string :matches "${match1}" "Test of *" {
+		test_fail "should have matched";
+	}
+
+	if not string :is "${1}" "general stupidity" {
+		test_fail "match value incorrect";
+	}
+}
+
+test "Begin no match" {
+	if string :matches "${match1}" "of *" {
+		test_fail "should not have matched";
+	}
+}
+
+set "match2" "toptoptop";
+
+test "End" {
+	if not string :matches "${match2}" "*top" {
+		test_fail "should have matched";
+	}
+
+	if not string :is "${1}" "toptop" {
+		test_fail "match value incorrect";
+	}
+}
+
+set "match3" "ik ben een tukker met grote oren en een lelijke broek.";
+
+test "Multiple" {
+	if not string :matches "${match3}" "ik ben * met * en *." {
+		test_fail "should have matched";
+	}
+
+	set "line" "Hij is ${1} met ${2} en ${3}!";
+
+	if not string :is "${line}"
+		"Hij is een tukker met grote oren en een lelijke broek!" {
+		test_fail "match values incorrect: ${line}";
+	}
+}
+
+set "match4" "beter van niet?";
+
+test "Escape" {
+	if not string :matches "${match4}" "*\\?" {
+		test_fail "should have matched";
+	}
+
+	if not string :is "${1}" "beter van niet" {
+		test_fail "match value incorrect: ${1}";
+	}
+}
+
+set "match5" "The quick brown fox jumps over the lazy dog.";
+
+test "Alphabet ?" {
+	if not string :matches "${match5}" "T?? ????? ????? ?o? ?u??? o?er ?he ???? ?o?." {
+		test_fail "should have matched";
+	}
+
+	set "alphabet" "${22}${8}${6}${25}${2}${13}${26}${1}${5}${15}${7}${21}${16}${12}${10}${17}${3}${9}${18}${20}${4}${19}${11}${14}${24}${23}";
+
+	if not string :is "${alphabet}" "abcdefghijklmnopqrstuvwxyz" {
+		test_fail "match values incorrect: ${alphabet}";
+	}
+
+	if string :matches "${match5}" "T?? ????? ?w??? ?o? ?u??? o?er ?he ???? ?o?." {
+		test_fail "should not have matched";
+	}
+}
+
+set "match6" "zero:one:zero|three;one;zero/five";
+
+test "Words sep ?" {
+
+	if not string :matches "${match6}" "*one?zero?five" {
+		test_fail "should have matched";
+	}
+
+	if not string :is "${1}${2}${3}" "zero:one:zero|three;;/" {
+		test_fail "incorrect match values: ${1} ${2} ${3}";
+	}
+}
+
+set "match7" "frop";
+
+test "Letters begin ?" {
+	if not string :matches "${match7}" "??op" {
+		test_fail "should have matched";
+	}
+
+	set "val" "${0}:${1}:${2}:${3}:";
+
+	if not string :is "${val}" "frop:f:r::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters end ?" {
+    if not string :matches "${match7}" "fr??" {
+        test_fail "should have matched";
+    }
+
+    set "val" "${0}:${1}:${2}:${3}:";
+
+    if not string :is "${val}" "frop:o:p::" {
+        test_fail "incorrect match values: ${val}";
+    }
+}
+
+set "match8" "klopfropstroptop";
+
+test "Letters words *? - 1" {
+	if not string :matches "${match8}" "*fr??*top" {
+		test_fail "should have matched";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:${5}:";
+
+	if not string :is "${val}" ":klopfropstroptop:klop:o:p:strop::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters words *? - 2" {
+	if not string :matches "${match8}" "?*fr??*top" {
+		test_fail "should have matched";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:${5}:${6}:";
+
+	if not string :is "${val}" ":klopfropstroptop:k:lop:o:p:strop::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters words *? backtrack" {
+	if not string :matches "${match8}" "*?op" {
+		test_fail "should have matched";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:";
+
+	if not string :is "${val}" ":klopfropstroptop:klopfropstrop:t:::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+test "Letters words *? first" {
+	if not string :matches "${match8}" "*?op*" {
+		test_fail "failed to match";
+	}
+
+	set "val" ":${0}:${1}:${2}:${3}:${4}:";
+
+	if not string :is "${val}" ":klopfropstroptop:k:l:fropstroptop::" {
+		test_fail "incorrect match values: ${val}";
+	}
+}
+
+/*
+ * Specific tests
+ */
+
+test_set "message" text:
+Return-path: <stephan@xi.rename-it.nl>
+Envelope-to: stephan@xi.rename-it.nl
+Delivery-date: Sun, 01 Feb 2009 11:29:57 +0100
+Received: from stephan by xi.rename-it.nl with local (Exim 4.69)
+	(envelope-from <stephan@xi.rename-it.nl>)
+	id 1LTZaP-0007h3-2e
+	for stephan@xi.rename-it.nl; Sun, 01 Feb 2009 11:29:57 +0100
+From: Dovecot Debian Builder <stephan.rename-it.nl@xi.rename-it.nl>
+To: stephan@xi.rename-it.nl
+Subject: Log for failed build of dovecot_2:1.2.alpha5-0~auto+159 (dist=hardy)
+Message-Id: <E1LTZaP-0007h3-2e@xi.rename-it.nl>
+Date: Sun, 01 Feb 2009 11:29:57 +0100
+
+Automatic build of dovecot_1.2.alpha5-0~auto+159 on xi by sbuild/i386 0.57.7
+.
+;
+
+test "Match combined" {
+	if not header :matches "subject" "Log for ?* build of *" {
+		test_fail "failed to match";
+	}
+
+	if not string "${1}${2}" "failed" {
+		test_fail "incorrect match values: ${1}${2}";
+	}
+}
Index: b/sieve/tests/extensions/variables/modifiers.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/modifiers.svtest
@@ -0,0 +1,140 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+
+/*
+ * Modifiers
+ */
+
+test "Modifier :lower" {
+	set :lower "test" "VaLuE";
+
+	if not string :is "${test}" "value" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :lower :upperfirst" {
+	set :lower :upperfirst "test" "vAlUe";
+
+	if string :is "${test}" "value" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "Value" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :upperfirst :lower" {
+	set :upperfirst :lower "test" "vAlUe";
+
+	if string :is "${test}" "value" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "Value" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :upper" {
+	set :upper "test" "vAlUe";
+
+	if not string :is "${test}" "VALUE" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :upper :lowerfirst" {
+	set :upper :lowerfirst "test" "VaLuE";
+
+	if string :is "${test}" "VALUE" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "vALUE" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifiers :lowerfirst :upper" {
+	set :lowerfirst :upper "test" "VaLuE";
+
+	if string :is "${test}" "VALUE" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "vALUE" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :length" {
+	set :length "test" "VaLuE";
+
+	if not string :is "${test}" "5" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :length (elaborate)" {
+	set "a" "abcdefghijklmnopqrstuvwxyz";
+	set "b" "1234567890";
+	set :length "test" " ${a}:${b}  ";
+
+	if not string :is "${test}" "40" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :quotewildcard" {
+	set :quotewildcard "test" "^^***??**^^";
+
+	if not string :is "${test}" "^^\\*\\*\\*\\?\\?\\*\\*^^" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "Modifier :length :quotewildcard" {
+	set :length :quotewildcard "test" "^^***??**^^";
+
+	if string :is "${test}" "11" {
+		test_fail "modifiers applied with wrong precedence";
+	}
+
+	if not string :is "${test}" "18" {
+		test_fail "modified variable assignment failed";
+	}
+}
+
+test "RFC examples" {
+	set "a" "juMBlEd lETteRS";             # => "juMBlEd lETteRS"
+	if not string "${a}" "juMBlEd lETteRS" {
+		test_fail "modified assignment failed (1): ${a}";
+	}
+
+	set :length "b" "${a}";                # => "15"
+	if not string "${b}" "15" {
+		test_fail "modified assignment failed (2): ${a}";
+	}
+
+	set :lower "b" "${a}";                 #  => "jumbled letters"
+	if not string "${b}" "jumbled letters" {
+		test_fail "modified assignment failed (3): ${a}";
+	}
+
+    set :upperfirst "b" "${a}";            # => "JuMBlEd lETteRS"
+	if not string "${b}" "JuMBlEd lETteRS" {
+		test_fail "modified assignment failed (4): ${a}";
+	}
+
+	set :upperfirst :lower "b" "${a}";     # => "Jumbled letters"
+	if not string "${b}" "Jumbled letters" {
+		test_fail "modified assignment failed (5): ${a}";
+	}
+
+	set :quotewildcard "b" "Rock*";        # => "Rock\*"
+	if not string "${b}" "Rock\\*" {
+		test_fail "modified assignment failed (6): ${a}";
+	}
+}
Index: b/sieve/tests/extensions/variables/quoting.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/quoting.svtest
@@ -0,0 +1,36 @@
+require "vnd.dovecot.testsuite";
+
+require "variables";
+require "encoded-character";
+
+test "Encodings - RFC examples" {
+	set "s" "$";
+	set "foo" "bar";
+
+	# "${fo\o}"  => ${foo}  => the expansion of variable foo.
+	if not string :is "${fo\o}" "bar" {
+		test_fail "failed 'the expansion of variable foo (${s}{fo\\o})'";
+	}
+
+	# "${fo\\o}" => ${fo\o} => illegal identifier => left verbatim.
+	if not string :is "${fo\\o}" "${s}{fo\\o}" {
+		test_fail "failed 'illegal identifier => left verbatim'";
+	}
+
+	# "\${foo}"  => ${foo}  => the expansion of variable foo.
+	if not string "\${foo}" "bar" {
+		test_fail "failed 'the expansion of variable foo (\\${s}{foo})'";
+	}
+
+	# "\\${foo}" => \${foo} => a backslash character followed by the
+	#                          expansion of variable foo.
+	if not string "\\${foo}" "\\bar" {
+		test_fail "failed 'a backslash character followed by expansion of variable foo";
+	}
+
+	set "name" "Ethelbert";
+	if not string "dear${hex:20 24 7b 4e}ame}" "dear Ethelbert" {
+		test_fail "failed 'dear Ethelbert' example";
+    }
+}
+
Index: b/sieve/tests/extensions/variables/regex.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/regex.svtest
@@ -0,0 +1,35 @@
+require "vnd.dovecot.testsuite";
+
+require "regex";
+require "variables";
+
+# Test overwriting only on match
+test "RFC - values overwrite" {
+	set "sentence1" "the cat jumps off the table";
+	set "sentence2" "the dog barks at the cat in the alley";
+
+	if not string :regex "${sentence1}" "the (.*) jumps off the (.*)" {
+		test_fail "failed to match first sentence";
+	}
+
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "invalid match values";
+	}
+
+	if string :regex "${sentence2}" "the (.*) barks at the (.*) in the store" {
+		test_fail "should not have matched second sentence";
+	}
+
+	if not string :is "${1}:${2}" "cat:table" {
+		test_fail "should have preserved match values";
+	}
+
+	if not string :regex "${sentence2}" "the (.*) barks at the (.*) in the alley" {
+		test_fail "failed to match the second sentence (second time)";
+	}
+
+	if not string :is "${1}:${2}" "dog:cat" {
+		test_fail "should have overwritten match values";
+	}
+}
+
Index: b/sieve/tests/extensions/variables/string.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/extensions/variables/string.svtest
@@ -0,0 +1,37 @@
+require "vnd.dovecot.testsuite";
+
+require "relational";
+require "comparator-i;ascii-numeric";
+
+require "variables";
+
+test "String - :count" {
+	if not string :count "eq" :comparator "i;ascii-numeric" ["a", "b", "c"] "3" {
+		test_fail "string test failed :count match";
+	}
+}
+
+test "String - :count \"\"" {
+	if not string :count "eq" :comparator "i;ascii-numeric" ["a", "", "c"] "2" {
+		test_fail "string test failed :count match";
+	}
+}
+
+test "RFC example" {
+	set "state" "${state} pending";
+
+	if not string :matches " ${state} " "* pending *" {
+    	# the above test always succeeds
+
+		test_fail "test should have matched: \" ${state} \"";
+	}
+}
+
+test "No whitespace stripping" {
+	set "vara" "      value       ";
+	set "varb" "value";
+
+	if not string :is :comparator "i;octet" "${vara}" "      ${varb}       " {
+		test_fail "string test seems to have stripped white space";
+	}
+}
Index: b/sieve/tests/header.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/header.svtest
@@ -0,0 +1,57 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+To: nico@vestingbar.nl
+Subject:         Help
+X-A:     Text
+X-B: Text
+X-Multiline: This is a multi-line
+ header body, which should be
+ unfolded correctly.
+
+Text
+
+.
+;
+
+test "Strip center" {
+	if not header :is "subject" "Help" {
+		test_fail "header test does not strip leading or trailing whitespace";
+	}
+}
+
+test "Strip lead" {
+    if not header :is "x-a" "Text" {
+        test_fail "header test does not strip leading whitespace";
+    }
+}
+
+test "Strip trail" {
+    if not header :is "x-b" "Text" {
+        test_fail "header test does not strip trailing whitespace";
+    }
+}
+
+test "Contains empty - exist" {
+	if not header :contains "subject" "" {
+		test_fail "header test :contains match type fails to match \"\" on existing header";
+	}
+
+	if header :contains "subject" "a" {
+		test_fail "header test :contains match type matches nonsense";
+	}
+}
+
+test "Contains empty - not exist" {
+	if header :contains "x-nonsense" "" {
+		test_fail "header test :contains match type matches \"\" on non-existant header";
+	}
+}
+
+test "Folded - equals" {
+	if not header :is "x-multiline"
+		"This is a multi-line header body, which should be unfolded correctly." {
+		test_fail "failed to properly unfold folded header.";
+	}
+}
Index: b/sieve/tests/lexer.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/lexer.svtest
@@ -0,0 +1,39 @@
+require "vnd.dovecot.testsuite";
+require "variables";
+
+/* Test conformance to RFC 5228 - 2.4.2. Strings */
+
+set "text" text: # Comment
+Line 1
+.Line 2
+..Line 3
+.Line 4
+Line 5
+.
+;
+
+set "quoted"
+"Line 1
+.Line 2
+.Line 3
+.Line 4
+Line 5
+";
+
+test "String Literal" {
+	if not string :is "${text}" "${quoted}" {
+		test_fail "lexer messed-up dot stuffing";
+	}
+
+	if string :is "${text}" "" {
+		test_fail "variable substitution failed";
+	}
+}
+
+test "Unknown Escapes" {
+	if not string :is "\a\a\a\a\a" "aaaaa" {
+		test_fail "unknown quoted string escape sequences are handled inappropriately";
+	}
+}
+
+
Index: b/sieve/tests/match-types/contains.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/match-types/contains.svtest
@@ -0,0 +1,81 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Cc: frop@example.com
+To: test@dovecot.org
+X-Bullshit: f fr fro frop frob frobn frobnitzn
+Subject: Test Message
+Comment:
+
+Test!
+.
+;
+
+# Match tests
+
+test "Match empty" {
+	if not header :contains "x-bullshit" "" {
+		test_fail "contains tests fails to match \"\" against non-empty string";
+	}
+
+	if not header :contains "comment" "" {
+        test_fail "contains tests fails to match \"\" against empty string";
+    }
+}
+
+test "Match full" {
+	if not address :contains "from" "stephan@rename-it.nl" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match begin" {
+	if not address :contains "from" "stephan" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match end" {
+	if not address :contains "from" "rename-it.nl" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match middle" {
+	if not address :contains "from" "@" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match similar beginnings" {
+	if not header :contains "x-bullshit" "frobnitzn" {
+		test_fail "should have matched";
+	}
+}
+
+test "Match case-insensitive" {
+	if not address :contains :comparator "i;ascii-casemap" "from" "RENAME-IT" {
+		test_fail "match fails to apply correct comparator";
+	}
+
+	if not address :contains "from" "RENAME-IT" {
+        test_fail "default comparator is wrong";
+    }
+}
+
+# Non-match tests
+
+test "No match full (typo)" {
+	if address :contains "to" "frob@example.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "No match end (typo)" {
+	if header :contains "x-bullshit" "frobnitzm" {
+		test_fail "should not have matched";
+	}
+}
+
+
Index: b/sieve/tests/match-types/is.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/match-types/is.svtest
@@ -0,0 +1,22 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: Stephan Bosch <stephan@rename-it.nl>
+To: nico@vestingbar.nl
+Subject: Test message
+Comment:
+
+Test!
+
+.
+;
+
+test "Empty key" {
+	if header :is "from" "" {
+		test_fail "erroneously matched empty key against non-empty string";
+	}
+
+	if not header :is "comment" "" {
+		test_fail "failed to match empty string";
+	}
+}
Index: b/sieve/tests/match-types/matches.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/match-types/matches.svtest
@@ -0,0 +1,214 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan+sieve@drunksnipers.com
+To: sirius@rename-it.nl
+To: nico@vestingbar.nl
+Cc: me@example.com
+Cc: timo@dovecot.com
+X-Hufter: TRUE
+Subject: make your money very fast!!!
+X-Spam-Score: **********
+X-Bullshit: 33333???a
+Message-ID: <90a02fe01fc25e131d0e9c4c45975894@example.com>
+Comment:
+X-Subject: Log for successful build of Dovecot.
+
+Het werkt!
+.
+;
+
+/*
+ * General conformance testing
+ */
+
+/*
+test "Empty string" {
+	if not header :matches "comment" "" {
+		test_fail "failed to match \"\" against \"\"";
+	}
+
+	if not header :matches "comment" "*" {
+		test_fail "failed to match \"\" against \"*\"";
+	}
+
+	if header :matches "comment" "?" {
+		test_fail "inappropriately matched \"\" against \"?\"";
+	}
+}
+
+test "Multiple '*'" {
+	if not address :matches "from" "*@d*ksn*ers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "*@d*kn*ers.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "End '*'" {
+	if not address :matches "from" "stephan+sieve@drunksnipers.*" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "stepan+sieve@drunksnipers.*" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Begin '*'" {
+	if not address :matches "from" "*+sieve@drunksnipers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "*+sieve@drunksnipers.om" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Middle '?'" {
+	if not address :matches "from" "stephan+sieve?drunksnipers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "stephan+sieve?drunksipers.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Begin '?'" {
+	if not address :matches "from" "?tephan+sieve@drunksnipers.com" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "?tephan+sievedrunksnipers.com" {
+		test_fail "should not have matched";
+	}
+}
+
+test "End '?'" {
+	if not address :matches "from" "stephan+sieve@drunksnipers.co?" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "sephan+sieve@drunksnipers.co?" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Multiple '?'" {
+	if not address :matches "from" "?t?phan?sieve?drunksnip?rs.co?" {
+		test_fail "should have matched";
+	}
+
+	if address :matches "from" "?t?phan?sieve?dunksnip?rs.co?" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Escaped '?'" {
+	if not header :matches "x-bullshit" "33333\\?\\?\\??" {
+		test_fail "should have matched";
+	}
+
+	if header :matches "x-bullshit" "33333\\?\\?\\?" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Escaped '?' following '*'" {
+	if not header :matches "x-bullshit" "33333*\\?\\??" {
+		test_fail "should have matched";
+	}
+
+}
+
+test "Escaped '?' directly following initial '*'" {
+	if not header :matches "X-Bullshit" "*\\?\\?\\?a" {
+		test_fail "should have matched";
+	}
+}
+
+test "Escaped '?' following initial '*'" {
+	if not header :matches "x-bullshit" "*3333\\?\\?\\?a" {
+		test_fail "should have matched";
+	}
+}
+
+test "Escaped '*' with active '*' at the end" {
+	if not header :matches "x-spam-score" "\\*\\*\\*\\*\\**" {
+		test_fail "should have matched";
+	}
+}
+
+test "All escaped '*'" {
+	if not header :matches "x-spam-score" "\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*" {
+		test_fail "should have matched";
+	}
+
+	if header :matches "x-spam-score" "\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Middle not escaped '*'" {
+	if not header :matches "x-spam-score" "\\*\\*\\***\\*\\*" {
+		test_fail "should have matched";
+	}
+}
+
+test "Escaped '*' alternating with '?'" {
+	if not header :matches "x-spam-score" "\\*?\\*?\\*?\\*?\\*?" {
+		test_fail "should have matched";
+	}
+
+	if header :matches "x-spam-score" "\\*?\\*?\\*?\\*?\\*??" {
+		test_fail "should not have matched";
+	}
+}
+
+test "All escaped" {
+	if header :matches "x-bullshit" "\\*3333\\?\\?\\?a" {
+		test_fail "should not have matched";
+	}
+
+
+	if header :matches "x-bullshit" "33333\\?\\?\\?aa" {
+		test_fail "should not have matched";
+	}
+
+	if header :matches "x-bullshit" "\\f3333\\?\\?\\?a" {
+		test_fail "should not have matched";
+	}
+}
+
+test "Put '*' directly before '?'" {
+	if header :matches "x-subject" "Log for *??????????? build of *" {
+		test_fail "should not have matched";
+	}
+
+	if not header :matches "x-subject" "Log for *?????????? build of *" {
+		test_fail "should have matched";
+	}
+
+	if not header :matches "x-subject" "Log for *? build of *" {
+		test_fail "should have matched";
+	}
+}*/
+
+test "Put '?' directly before '*'" {
+	if header :matches "x-subject" "Log for ???????????* build of *" {
+		test_fail "should not have matched";
+	}
+
+	if not header :matches "x-subject" "Log for ??????????* build of *" {
+		test_fail "should have matched";
+	}
+
+	if not header :matches "x-subject" "Log for ?* build of *" {
+		test_fail "should have matched";
+	}
+}
+
+
Index: b/sieve/tests/multiscript/basic.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/basic.svtest
@@ -0,0 +1,91 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Message-ID: <frop33333333333333333@frutsens.nl>
+To: nico@vestingbar.nl
+Subject: Frop.
+
+Friep.
+.
+;
+
+test "Append" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ){
+		test_fail "failed to compile and run first script";
+	}
+
+	if not allof (
+		test_script_compile "vacation.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not allof (
+		test_script_compile "notify.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if not test_result :index 2 "vacation" {
+		test_fail "second action is not 'vacation'";
+	}
+
+	if not test_result :index 3 "notify" {
+		test_fail "third action is not 'notify'";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed";
+	}
+}
+
+test "Sequential Execute" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ) {
+		test_fail "failed to compile and run first script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after first script";
+	}
+
+	if not allof (
+		test_script_compile "vacation.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after second script";
+	}
+
+	if not allof (
+		test_script_compile "notify.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after third script";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if not test_result :index 2 "vacation" {
+		test_fail "second action is not 'vacation'";
+	}
+
+	if not test_result :index 3 "notify" {
+		test_fail "third action is not 'notify'";
+	}
+}
Index: b/sieve/tests/multiscript/conflicts.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/conflicts.svtest
@@ -0,0 +1,94 @@
+require "vnd.dovecot.testsuite";
+
+test_set "message" text:
+From: stephan@rename-it.nl
+Message-ID: <frop33333333333333333@frutsens.nl>
+To: nico@vestingbar.nl
+Subject: Frop.
+
+Friep.
+.
+;
+
+test "Graceful Conflicts" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ){
+		test_fail "failed to compile and run first script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after first script";
+	}
+
+	if not allof (
+		test_script_compile "reject-1.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after second script";
+	}
+
+	if not allof (
+		test_script_compile "reject-2.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after third script";
+	}
+
+	if not test_result :index 1 "store" {
+		test_fail "first action is not 'store'";
+	}
+
+	if test_result :index 2 "reject" {
+		test_fail "reject action not discarded";
+	}
+}
+
+test "Duplicates" {
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run ){
+		test_fail "failed to compile and run first script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after first script";
+	}
+
+	if not allof (
+		test_script_compile "fileinto-inbox.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run second script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after second script";
+	}
+
+	if not allof (
+		test_script_compile "keep.sieve",
+		test_script_run :append_result ) {
+		test_fail "failed to compile and run third script";
+	}
+
+	if not test_result_execute {
+		test_fail "result execute failed after third script";
+	}
+
+	test_result_print;
+
+	if not test_result :index 1 "keep" {
+		test_fail "first action is not 'keep'";
+	}
+
+	if test_result :index 2 "store" {
+		test_fail "fileinto action not discarded";
+	}
+}
+
Index: b/sieve/tests/multiscript/fileinto-frop.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/fileinto-frop.sieve
@@ -0,0 +1,3 @@
+require "fileinto";
+
+fileinto "frop";
Index: b/sieve/tests/multiscript/fileinto-inbox.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/fileinto-inbox.sieve
@@ -0,0 +1,4 @@
+require "fileinto";
+
+fileinto "INBOX";
+
Index: b/sieve/tests/multiscript/keep.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/keep.sieve
@@ -0,0 +1 @@
+keep;
Index: b/sieve/tests/multiscript/notify.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/notify.sieve
@@ -0,0 +1,3 @@
+require "enotify";
+
+notify "mailto:stephan@rename-it.nl";
Index: b/sieve/tests/multiscript/reject-1.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/reject-1.sieve
@@ -0,0 +1,3 @@
+require "reject";
+
+reject "Message is not wanted.";
Index: b/sieve/tests/multiscript/reject-2.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/reject-2.sieve
@@ -0,0 +1,3 @@
+require "reject";
+
+reject "Will not accept this nonsense.";
Index: b/sieve/tests/multiscript/vacation.sieve
===================================================================
--- /dev/null
+++ b/sieve/tests/multiscript/vacation.sieve
@@ -0,0 +1,3 @@
+require "vacation";
+
+vacation "I am not home";
Index: b/sieve/tests/testsuite.svtest
===================================================================
--- /dev/null
+++ b/sieve/tests/testsuite.svtest
@@ -0,0 +1,75 @@
+require "vnd.dovecot.testsuite";
+require "envelope";
+
+/* Test message environment */
+
+test "Message Environment" {
+	test_set "message" text:
+From: sirius@rename-it.nl
+To: nico@vestingbar.nl
+Subject: Frop!
+
+Frop!
+.
+	;
+
+	if not header :contains "from" "rename-it.nl" {
+		test_fail "message data not set properly.";
+	}
+
+	test_set "message" text:
+From: nico@vestingbar.nl
+To: stephan@zuiphol.nl
+Subject: Friep!
+
+Friep!
+.
+	;
+
+	if not header :is "from" "nico@vestingbar.nl" {
+    	test_fail "message data not set properly.";
+	}
+
+	keep;
+}
+
+/* Test envelope environment */
+
+test "Envelope Environment" {
+	test_set "envelope.from" "stephan@hutsefluts.nl";
+
+	if not envelope :is "from" "stephan@hutsefluts.nl" {
+        test_fail "envelope.from data not set properly (1).";
+    }
+
+	test_set "envelope.to" "news@rename-it.nl";
+
+	if not envelope :is "to" "news@rename-it.nl" {
+        test_fail "envelope.to data not set properly (1).";
+    }
+
+	test_set "envelope.auth" "sirius";
+
+    if not envelope :is "auth" "sirius" {
+        test_fail "envelope.auth data not set properly (1).";
+    }
+
+	test_set "envelope.from" "stephan@rename-it.nl";
+
+	if not envelope :is "from" "stephan@rename-it.nl" {
+        test_fail "envelope.from data not reset properly (2).";
+    }
+
+	test_set "envelope.to" "past-news@rename-it.nl";
+
+	if not envelope :is "to" "past-news@rename-it.nl" {
+        test_fail "envelope.to data not reset properly (2).";
+    }
+
+	test_set "envelope.auth" "zilla";
+
+    if not envelope :is "auth" "zilla" {
+        test_fail "envelope.auth data not reset properly (2).";
+    }
+}
+
