#! /bin/sh -e
## DP: Adds support for SIEVE

. $(dirname $0)/DPATCH

exit 0
@DPATCH@
diff -urN dovecot-1.2.0/dovecot-libsieve/AUTHORS dovecot-1.2.0-sieve/dovecot-libsieve/AUTHORS
--- dovecot-1.2.0/dovecot-libsieve/AUTHORS	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/AUTHORS	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,13 @@
+Stephan Bosch <stephan@rename-it.nl>
+
+This plugin is partly based on the original cmusieve plugin for the Dovecot 
+secure IMAP server. It is based only on code relating to interfacing the CMU 
+Sieve implementation to Dovecot, meaning that no CMU code is incorporated in 
+this implementation. 
+
+Both the cmusieve plugin and the Dovecot IMAP server are primarily written by:
+
+Timo Sirainen <tss@iki.fi>
+
+View the AUTHORS files in the Dovecot and Dovecot-Sieve distributions for other 
+contributors. 
diff -urN dovecot-1.2.0/dovecot-libsieve/ChangeLog dovecot-1.2.0-sieve/dovecot-libsieve/ChangeLog
--- dovecot-1.2.0/dovecot-libsieve/ChangeLog	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/ChangeLog	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,7345 @@
+2009-07-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[6b600005be7e] [tip]
+
+	* TODO:
+	Updated TODO.
+	[e45e47df32bf]
+
+2009-07-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgignore:
+	Added item to .hgignore.
+	[964951d1c9fd]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1, src/sieve-
+	tools/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c:
+	Improved consistency of sieve tool documentation.
+	[1b4b951a6c0a]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Enhanced extensions configuration, allowing to specify the enabled
+	extensions relatively to the default.
+	[91cc9f2a2404]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: forgot to initialize script execution status.
+	[c4af2d059871]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Sieve plugin: fixed logging for execution of default main script
+	(went to STDERR).
+	[70098e07fa3b]
+
+2009-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[2a0e9ce87006]
+
+2009-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Added support for CRLF line breaks in strbuf error handler
+	(ManageSieve fix).
+	[763f2cff0cae]
+
+2009-06-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.6 for changeset 6856b1027de8
+	[20d4b1c19c92]
+
+	* .hgtags:
+	Added tag 0.1.5 for changeset 61b52e4618e3
+	[6856b1027de8] [0.1.6]
+
+2009-06-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.1.6 for Dovecot v1.2.rc5.
+	[47f83cfcc68e]
+
+	* NEWS:
+	Updated NEWS file for new release.
+	[e9db961974b1]
+
+2009-06-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed potential problems wil NUL characters in body parts.
+	[908f479dd046]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed assert failure caused by ugly code and a change in
+	dovecot.
+	[c9780425e011]
+
+2009-05-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Body: fixed part of the assert fail problems (Dovecot change).
+	[a14922487fd3]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Adjusted to changes in Dovecot regarding opening a raw stream.
+	[bcd66e758199]
+
+	* src/sieve-tools/Makefile.am:
+	Removed duplicate library dependencies.
+	[bdb7ac7fcbec]
+
+2009-05-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed compiler warning.
+	[4c5c04dd182a]
+
+2009-05-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Made default of sieve_dir setting match the ManageSieve
+	implementation.
+	[334612126bb7]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed indent problems.
+	[f949723e32ef]
+
+2009-04-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, configure.in:
+	Released v0.1.5 for Dovecot v1.2.rc3.
+	[61b52e4618e3] [0.1.5]
+
+	* src/lib-sieve/sieve-binary.c:
+	Increased binary version number.
+	[6f3609b58136]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h, tests/compile/errors.svtest,
+	tests/compile/errors/require.sieve:
+	Improved error message for unknown Sieve extension to account for
+	core commands included as an extension.
+	[c3736fb49332]
+
+2009-04-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed bug in the Sieve plugin's return value that caused omission of
+	delivery when no Sieve scripts are present. Bug spotted by Matthijs
+	Kooijman.
+	[4c858f06b15f]
+
+2009-04-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/environment/ext-environment-common.c:
+	Environment: fixed compiler warning.
+	[afc482d21847]
+
+	* NEWS:
+	Updated NEWS file for upcoming v1.2 release.
+	[f4230bed0845]
+
+	* tests/extensions/environment/rfc.svtest:
+	Testsuite: forgot to add new testcase file.
+	[26e1e01da8bb]
+
+2009-04-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/plugins/environment/ext-environment-
+	common.c, src/lib-sieve/plugins/environment/tst-environment.c:
+	Environment: fixed segfault and fixed some rfc deviations.
+	[831a0a96ea5b]
+
+	* src/lib-sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h,
+	src/testsuite/testsuite.c,
+	tests/extensions/environment/basic.svtest:
+	Environment: activated host environment item.
+	[01b2712fd398]
+
+	* Makefile.am, TODO, configure.in, doc/rfc/environment.rfc5183.txt,
+	src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/environment/Makefile.am, src/lib-
+	sieve/plugins/environment/ext-environment-common.c, src/lib-
+	sieve/plugins/environment/ext-environment-common.h, src/lib-
+	sieve/plugins/environment/ext-environment.c, src/lib-
+	sieve/plugins/environment/sieve-ext-environment.h, src/lib-
+	sieve/plugins/environment/tst-environment.c, src/lib-sieve/sieve-
+	extensions.c, tests/extensions/environment/basic.svtest:
+	Implemented core support for the environment extension.
+	[9d6ceadb490a]
+
+2009-04-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, tests/extensions/include/included-global/rfc-
+	ex1-spam_tests.sieve, tests/extensions/include/included/rfc-
+	ex1-always_allow.sieve, tests/extensions/include/included/rfc-
+	ex1-mailing_lists.sieve, tests/extensions/include/included/rfc-
+	ex1-spam_tests.sieve, tests/extensions/include/included/rfc-
+	ex2-spam_filter_script.sieve,
+	tests/extensions/include/included/twice-1.sieve,
+	tests/extensions/include/included/twice-2.sieve,
+	tests/extensions/include/rfc-ex1-default.sieve,
+	tests/extensions/include/rfc-ex2-default.sieve,
+	tests/extensions/include/rfc.svtest,
+	tests/extensions/include/twice.svtest:
+	Include: added various tests to the testsuite.
+	[ac4fc49c6be1]
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in binary save of global variable scope.
+	[593fe13ac0c9]
+
+2009-04-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, README, TODO, src/lib-sieve/plugins/include/cmd-
+	include.c, src/lib-sieve/plugins/include/ext-include-common.c, src
+	/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c,
+	tests/extensions/include/included/once-2.sieve,
+	tests/extensions/include/included/once-3.sieve,
+	tests/extensions/include/included/once-4.sieve,
+	tests/extensions/include/once.svtest:
+	Include: implemented :once modifier for the include command.
+	[d6e436b78853]
+
+	* src/testsuite/cmd-test.c:
+	Testsuite: fixed minor result passing problem in test code
+	generation.
+	[4c416bcfd49c]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: improved runtime script handling.
+	[2fd8feba11dd]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: added runtime check for circular include.
+	[b21eb653f1dd]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Fixed a few small indent problems.
+	[e948085b5b67]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-sieve/sieve-
+	binary-dumper.c, tests/extensions/include/included/once-1.sieve,
+	tests/extensions/include/included/once-2.sieve,
+	tests/extensions/include/once.svtest:
+	Include: added skeleton :once modifier.
+	[08f3b665caee]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Include: fixed bug in sub-sub include.
+	[f333ecabb7d4]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed warnings in revised plugin code.
+	[a92742e9a7c1]
+
+	* doc/man/sieve-test.1:
+	Minor update to the sieve-test manpage
+	[e400b5a9e182]
+
+	* README, src/lib-sieve/plugins/include/ext-include.c:
+	Include: updated implementation status.
+	[3717f4f237d9]
+
+	* doc/rfc/draft-daboo-sieve-include-05.txt, doc/rfc/draft-ietf-sieve-
+	include-01.txt:
+	Replaced include specification with latest draft.
+	[d8f0bdecc0e8]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-global.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/import-runtime.sieve,
+	tests/extensions/include/errors/variables-inactive.sieve,
+	tests/extensions/include/errors/variables.sieve,
+	tests/extensions/include/included/variables-included1.sieve,
+	tests/extensions/include/included/variables-included2.sieve,
+	tests/extensions/include/included/variables-included3.sieve,
+	tests/extensions/include/variables.svtest:
+	Include: replaced import/export commands with global command as
+	specified in latest draft. Import/export are now DEPRICATED.
+	[6fff255fe757]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve
+	/sieve-address-parts.c, tests/address.svtest,
+	tests/extensions/subaddress/basic.svtest:
+	Definitively fixed handling group specifications in mailbox lists of
+	address headers.
+	[914c3c1f5f8c]
+
+	* doc/man/sieve-test.1:
+	Fixed minor typo in sieve-test man page.
+	[b3ad017662d1]
+
+	* TODO:
+	Updated TODO.
+	[e89b270850c6]
+
+	* src/lib-sieve/sieve-error-private.h, src/lib-sieve/sieve-error.c,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-script.c, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools/sieve-
+	test.c:
+	Major rework of the multiscript support for better error handling.
+	[6dcfb15cf051]
+
+2009-04-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Improved plugin debug message.
+	[24847d4c5ef8]
+
+2009-04-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed problem of unexecuted before/after global scripts when user
+	script is missing.
+	[4d2503564c59]
+
+2009-04-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c:
+	Adjusted to signal handler API changes in Dovecot.
+	[b7e376b7fb07]
+
+2009-04-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve
+	/sieve-address-parts.c:
+	Fixed segfault bug caused by undisclosed-recipients:; when fed to
+	the subaddress extension.
+	[ec78123ec073]
+
+2009-03-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.4 for changeset b7eb19f14fa7
+	[38ef3a309167]
+
+	* NEWS, configure.in:
+	Released v0.1.4 for Dovecot v1.2.beta3.
+	[b7eb19f14fa7] [0.1.4]
+
+2009-03-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sieve-test.1:
+	Documented vnd.dovecot.debug in the sieve-test man page.
+	[3e4cc10a3d89]
+
+	* NEWS:
+	Updated NEWS file.
+	[9daef35779e6]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/sieve-
+	tools/sieve-filter.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c:
+	Improved error handling and added debug extension to all applicable
+	Sieve tools.
+	[ae2f39427f14]
+
+2009-03-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Created replaceable error handler for system errors.
+	[539cfb9b9507]
+
+	* TODO, configure.in, src/sieve-tools/Makefile.am, src/sieve-
+	tools/debug/Makefile.am, src/sieve-tools/debug/cmd-debug-print.c,
+	src/sieve-tools/debug/ext-debug-common.h, src/sieve-tools/debug/ext-
+	debug.c, src/sieve-tools/debug/sieve-ext-debug.h, src/sieve-tools
+	/sieve-test.c:
+	Added Dovecot-specific debug extension to the sieve-test tool.
+	[a74dc7f32b71]
+
+	* TODO, src/sieve-tools/sieve-filter.c:
+	Sieve-filter: implemented basic filtering.
+	[8862c90bc395]
+
+2009-03-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/Makefile.am, src/testsuite/Makefile.am:
+	Removed unnecessary linker flags that break Solaris compilation.
+	[45c04b2fe529]
+
+2009-02-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/regex/ext-regex-common.h, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-address-parts.h, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h:
+	Fixed MAC OSX compile problems: forgot extern modifier at various
+	places.
+	[ab9a06342d33]
+
+2009-02-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed issue with opening relative paths as a mail file.
+	[4d642db0b754]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed tmp file name for raw storage used for sieve tools.
+	[54a07ebb8e1f]
+
+2009-02-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[7d45c1fdf9c1]
+
+	* doc/rfc/collation.rfc4790.txt, doc/rfc/i-ascii-numeric.rfc2244.txt:
+	Removed inappropriate ACAP rfc for i;ascii-numeric comparator and
+	substituted rfc4790 in stead.
+	[cebc91cd58e1]
+
+2009-02-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-tools/sieve-filter.c:
+	Sieve-filter: developed listing messages in a folder a little
+	further.
+	[e7dd36461c67]
+
+	* .hgignore, src/sieve-tools/Makefile.am, src/sieve-tools/sieve-
+	filter.c:
+	Started work on sieve-filter tool.
+	[85230557972e]
+
+2009-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	validator.c, src/testsuite/cmd-test-message.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-smtp.c, src/testsuite/testsuite-smtp.h,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added a few final important tests for the enotify
+	extension.
+	[75b6dac1df2a]
+
+2009-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.3 for changeset 8bdff47ab3f0
+	[977e30fa18c2]
+
+	* configure.in:
+	Released v0.1.3 for Dovecot v1.2.beta1.
+	[8bdff47ab3f0] [0.1.3]
+
+2009-02-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added items to the TODO list.
+	[1c401bb66e52]
+
+	* doc/man/sievec.1:
+	Minor changes to the sievec man page.
+	[c8c404ceeb47]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-script.h:
+	Saved binary now has at most the same permissions as the script file
+	itself.
+	[3bdd01261818]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-extensions.c:
+	Fixed bug the code generation of extensions.
+	[3eb2562e40e8]
+
+	* doc/man/sieved.1, src/sieve-tools/sieved.c:
+	Added -x parameter to sieved tool.
+	[c98dafdf1f49]
+
+2009-02-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed small bug in the extension validation.
+	[15dd897287d2]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Imapflags: marked as depricated and disabled by default.
+	[95a9bb61d7ca]
+
+	* src/lib-sieve/sieve-validator.c:
+	Properly implemented verification of loaded extensions after last
+	require command is validated.
+	[cbb12efa1f1b]
+
+	* tests/extensions/variables/match.svtest:
+	Testsuite: added small test for ?* match values.
+	[2d132b56398a]
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[a57d7b6d95a8]
+
+2009-02-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, tests/extensions/vacation/message.svtest,
+	tests/extensions/vacation/references.svtest:
+	Testsuite: added message tests for the vacation extension.
+	[7a074a0ff5c0]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	result-reset.c, src/testsuite/ext-testsuite.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-result.h, src/testsuite/tst-test-script-run.c,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added support for resetting the result.
+	[42b3ec181e64]
+
+	* tests/extensions/enotify/mailto.svtest:
+	Testsuite: added tests for enotify with multiple recipients.
+	[c84f556f3115]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/include/cmd-import.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-
+	size.c, src/testsuite/Makefile.am, src/testsuite/cmd-test-message.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-message.c, src/testsuite/testsuite-
+	message.h, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-result.c, src/testsuite/testsuite-smtp.c, src/testsuite
+	/testsuite-smtp.h, src/testsuite/tst-test-result-execute.c,
+	tests/extensions/enotify/mailto.svtest:
+	Testsuite: added support for looping back outgoing SMTP messages
+	back into the test.
+	[3f857d8c403e]
+
+2009-02-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src
+	/lib-sieve/sieve-address.c, src/lib-sieve/sieve-address.h:
+	Defined very basic function for address comparison.
+	[e4283ec36db2]
+
+	* src/lib-sieve/sieve-actions.c:
+	Adjusted store action to API changes in Dovecot.
+	[d2ed402f1a5f]
+
+2009-02-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	address.c, tests/extensions/vacation/execute/action.sieve:
+	Vacation: made addresses comparison case-insensitive.
+	[b315fde89b8a]
+
+2009-02-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[cea5c68baa2e]
+
+	* src/lib-sieve/plugins/imap4flags/tag-flags.c,
+	tests/extensions/imap4flags/execute/imapflags.sieve:
+	Imap4flags: fixed dumping of \flagged flag in flags side effect.
+	[a1ad7bbd3ef7]
+
+	* Makefile.am, src/lib-sieve/plugins/imap4flags/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/ext-imapflags.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-validator.c,
+	src/testsuite/testsuite.c,
+	tests/extensions/imap4flags/errors.svtest,
+	tests/extensions/imap4flags/errors/imapflags.sieve,
+	tests/extensions/imap4flags/execute/imapflags.sieve:
+	Imap4flags: added support for obsolete imapflags extension for
+	backwards compatibility with CMUSieve.
+	[4e58445b4f87]
+
+2009-02-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h:
+	Validator: added support for checking loaded extensions.
+	[ab9545a27bbf]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h:
+	Added facilities for requiring extensions and making extensions
+	mutually exclusive.
+	[37fc919d3450]
+
+	* Makefile.am, tests/extensions/imap4flags/basic.svtest,
+	tests/extensions/imap4flags/execute.svtest,
+	tests/extensions/imap4flags/execute/flags-side-effect.sieve,
+	tests/extensions/imap4flags/hasflag.svtest,
+	tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/imapflags/execute/flags-side-effect.sieve,
+	tests/extensions/imapflags/hasflag.svtest:
+	Imap4flags: gave testsuite directory proper name.
+	[f0299c1886fe]
+
+	* src/lib-sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-sieve/sieve-
+	extensions.c:
+	Imap4flags: properly named extension objects.
+	[581df7c170d1]
+
+	* src/lib-sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c:
+	Imap4flags: properly named functions.
+	[debaa7e5a036]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/Makefile.am, src/lib-
+	sieve/plugins/imap4flags/cmd-flag.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.c, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags-common.h, src/lib-
+	sieve/plugins/imap4flags/ext-imap4flags.c, src/lib-
+	sieve/plugins/imap4flags/tag-flags.c, src/lib-
+	sieve/plugins/imap4flags/tst-hasflag.c, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/cmd-flag.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c:
+	Imap4flags: properly named extension directory and source files.
+	[c8d2f78230f9]
+
+2009-02-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Fixed README: now mentions the naming differences of the imap4flags
+	and enotify extensions compared to the old CMU Sieve plugin.
+	[f33ee1af3bdb]
+
+2009-02-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c:
+	Fixed compile warning caused by missing include.
+	[c0a84cf64bbd]
+
+2009-02-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-12.txt, doc/rfc/draft-ietf-sieve-
+	notify-mailto-10.txt, doc/rfc/notify-mailto.rfc5436.txt,
+	doc/rfc/notify.rfc5435.txt, src/lib-sieve/plugins/enotify/ext-
+	enotify.c, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Installed RFC documents for notify extension and corresponding
+	mailto method.
+	[b11bd3479721]
+
+	* src/lib-sieve/mcht-matches.c, tests/match-types/matches.svtest:
+	Cleaned up :matches match-type code.
+	[ca2edcc58fba]
+
+	* src/lib-sieve/mcht-matches.c, tests/match-types/matches.svtest:
+	Fixed bug in the :matches match type.
+	[88cc4bf1c396]
+
+2009-01-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added important TODO item.
+	[42e154b8792e]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/rfc2822.c:
+	Changed SMTP message generation back to CRLF, because the Sieve
+	engine uses CRLF internally.
+	[082216ad12d6]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code.c:
+	Fixed use of data stack by binary dumping code.
+	[258e357cfbf7]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: fixed segfault bug occuring when regex is freed.
+	[6ed559a5f677]
+
+	* src/testsuite/tst-test-script-compile.c:
+	Testsuite: fixed warning.
+	[abc7331b2124]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-validator.c:
+	Increased various initial pool sizes.
+	[cdb4b96e70a8]
+
+2009-01-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Increased initial size of binary's lazy_file pool.
+	[7caaa891d5f4]
+
+	* src/lib-sieve/rfc2822.c:
+	Fixed error in the SMTP message composition that caused mixing of
+	CRLF and LF in redirected messages.
+	[2ae233b6f5ad]
+
+2009-01-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[a8e587b0409e]
+
+	* NEWS:
+	Updated NEWS file.
+	[b93c8d7802a3]
+
+	* README:
+	Updated README file.
+	[171133900f9b]
+
+	* NEWS:
+	Prepared NEWS file for next release.
+	[42ef7e546072]
+
+	* INSTALL:
+	Updated documentation.
+	[32812e4f4722]
+
+	* Makefile.am, tests/extensions/regex/match-values.svtest:
+	Testsuite: added simple tests for the match values produced by the
+	:regex match.
+	[7a91f98d0be1]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: fixed bug in the match value indexes.
+	[de6db6757418]
+
+2009-01-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-degener-sieve-multiscript-00.txt:
+	Added multiscript draft to the doc/rfc directory.
+	[fa223cfeaa35]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-message.c,
+	src/testsuite/testsuite-smtp.c, src/testsuite/testsuite-smtp.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-script-run.c:
+	Testsuite: added storage of outgoing SMTP messages.
+	[3fd7e83720fb]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-message.c,
+	src/testsuite/testsuite-message.h, src/testsuite/testsuite-
+	objects.c, src/testsuite/testsuite.c:
+	Testsuite: exported message handling to separate module.
+	[b15cfe188d87]
+
+2009-01-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h:
+	Enotify: cleaned up method API.
+	[466e57aedb29]
+
+	* tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/hasflag.svtest:
+	Testsuite: improved testsuite with respect to testing of setflag,
+	addflag and removeflag commands.
+	[18b4ee74fc9c]
+
+	* TODO, src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-flag.c, src/lib-sieve/plugins/imapflags
+	/cmd-removeflag.c, src/lib-sieve/plugins/imapflags/cmd-setflag.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h:
+	Imap4flags: merged setflag, addflag and removeflag implementations.
+	[38189d0d5785]
+
+	* INSTALL, src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Added sieve_subaddress_sep setting.
+	[fac1579a1164]
+
+2009-01-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address.c, tests/compile/errors.svtest,
+	tests/compile/errors/out-address.sieve:
+	Fixed bug in the outgoing mail address verification.
+	[60b3f236c3bc]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/duplicates.sieve:
+	Enotify/Mailto: prevented single recipient from receiving multiple
+	notifications on the same message.
+	[38b1269f8e10]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed segfault bugs in the error handling.
+	[31804bc166e3]
+
+2009-01-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Small project status update to the README.
+	[31fb740ce85c]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/duplicates.sieve:
+	Enotify: added API for detecting and killing duplicate notification
+	recipients.
+	[975614b641aa]
+
+	* TODO, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Multiscript: implemented sorting of script files in script
+	directories for Sieve plugin.
+	[c13464cb4fe3]
+
+	* INSTALL, README, TODO, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Updated documentation.
+	[17a66023e259]
+
+	* TODO:
+	Reprioritized TODO.
+	[bcbae5e0e63d]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Got array_get_pool() integrated into Dovecot.
+	[3929bef582c0]
+
+	* README, TODO:
+	Updated documentation.
+	[aec958653b9f]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed segfault in lda sieve plugin.
+	[902ee7cc9588]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify/Mailto: fixed bug in the generation of the SMTP envelope
+	sender.
+	[e124dfa5388c]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: fixed various indent mishaps in ntfy-mailto.c.
+	[f958c97ec9dc]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-tools/sieve-test.c:
+	Multiscript: added untested multiscript support to the lda sieve
+	plugin.
+	[2777abb69dd0]
+
+2009-01-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Added a few accessors to the binary object for convenience.
+	[374039e9194e]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed warning.
+	[15bc0d5d27a5]
+
+	* src/testsuite/testsuite.c:
+	Testsuite: fixed result handling.
+	[8d63ff17d7e8]
+
+	* TODO:
+	Removed remaining references to sieve-exec.
+	[1eca558676df]
+
+2009-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sievec.1, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-
+	tool/sieve-tool.h, src/lib-sieve/sieve-script-private.h, src/lib-
+	sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c:
+	Extended sievec command to allow compiling an entire directory.
+	[a56dfe862df4]
+
+2009-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/man/sieved.1:
+	Minor revisions to the sieved man page.
+	[df54062cbf77]
+
+	* doc/man/sievec.1, src/sieve-tools/sievec.c:
+	Made outfile argument of the sievec command optional.
+	[b7ae0b1d7399]
+
+	* README:
+	Updated README.
+	[7cb784bf0c4c]
+
+	* doc/man/sieve-test.1, doc/man/sievec.1, doc/man/sieved.1, src/lib-
+	sieve/cmd-discard.c, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve.c, src/sieve-tools/Makefile.am,
+	src/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c:
+	Merged sieve-exec tool into sieve-test.
+	[030d37107e10]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c:
+	Fixed various result error messages.
+	[02697b1b4311]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed a theoretical security hole occuring when directory is opened
+	as a Sieve binary.
+	[d2a7caa5566f]
+
+2009-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/sieve-tools/sieve-test.c:
+	Updated TODO.
+	[2c64b5e5db89]
+
+	* src/lib-sieve/sieve-result.c, src/sieve-tools/sieve-test.c:
+	Multiscript: fixed small bug in result printing.
+	[0a5938f5e88c]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	tools/sieve-test.c:
+	Multiscript: improved handling of the keep action.
+	[5d251b577e56]
+
+	* TODO:
+	Updated TODO.
+	[511e2770304c]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-tools/sieve-test.c:
+	Multiscript: implemented execution of multiple scripts for the
+	sieve-test command.
+	[d20619f44dc0]
+
+2009-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Multiscript: implemented API.
+	[50f5d81b9507]
+
+	* doc/man/sieve-test.1, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src
+	/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c,
+	src/testsuite/testsuite-result.c, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite.c:
+	Multiscript: various changes to the interpreter to facilitate
+	multiscript support.
+	[1e54353fd486]
+
+2009-01-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Multiscript: added keep status evaluation to result object.
+	[70b008a20600]
+
+	* src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool/mail-raw.h, src
+	/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool/sieve-tool.h, src
+	/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-
+	keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c,
+	src/lib-sieve/cmd-stop.c, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/ext-encoded-character.c, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/mcht-contains.c, src/lib-sieve
+	/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/ext-body-common.h,
+	src/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body
+	/tst-body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-
+	cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify-limits.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/plugins/enotify/sieve-ext-enotify.h,
+	src/lib-sieve/plugins/enotify/tst-notify-method-capability.c, src
+	/lib-sieve/plugins/enotify/tst-valid-notify-method.c, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/cmd-return.c, src/lib-sieve/plugins/include/ext-include-binary.c,
+	src/lib-sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-limits.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h,
+	src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.h, src/lib-sieve/plugins/variables/ext-variables-dump.c, src
+	/lib-sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-limits.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/rfc2822.c, src
+	/lib-sieve/rfc2822.h, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-address-parts.h, src/lib-sieve/sieve-address.c, src/lib-sieve
+	/sieve-address.h, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	binary-dumper.h, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-config.h, src/lib-sieve/sieve-dump.h, src/lib-sieve/sieve-
+	error-private.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	lexer.h, src/lib-sieve/sieve-limits.c, src/lib-sieve/sieve-limits.h,
+	src/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-
+	types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h,
+	src/lib-sieve/sieve-message.c, src/lib-sieve/sieve-message.h, src
+	/lib-sieve/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-
+	sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	script-private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve
+	/tst-size.c, src/lib-sieve/tst-truefalse.c, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-sieve-plugin.h, src
+	/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-test.c, src/sieve-
+	tools/sievec.c, src/sieve-tools/sieved.c, src/testsuite/cmd-test-
+	fail.c, src/testsuite/cmd-test-result-print.c, src/testsuite/cmd-
+	test-set.c, src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-arguments.c, src/testsuite/testsuite-
+	arguments.h, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite-log.c, src/testsuite
+	/testsuite-log.h, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-objects.h, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-result.h, src/testsuite/testsuite-script.c,
+	src/testsuite/testsuite-script.h, src/testsuite/testsuite-
+	substitutions.c, src/testsuite/testsuite-substitutions.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-error.c,
+	src/testsuite/tst-test-result-execute.c, src/testsuite/tst-test-
+	result.c, src/testsuite/tst-test-script-compile.c, src/testsuite
+	/tst-test-script-run.c:
+	Updated copyright messages to 2009.
+	[9e7bde020990]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve.c, src/testsuite
+	/testsuite-result.c, tests/multiscript/conflicts.svtest,
+	tests/multiscript/fileinto-frop.sieve, tests/multiscript/keep.sieve:
+	Testsuite: extended multiscript testing.
+	[fd189b1545ce]
+
+	* Makefile.am, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/testsuite/Makefile.am,
+	src/testsuite/cmd-test-result-print.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/testsuite-common.h, src/testsuite
+	/testsuite-log.c, src/testsuite/testsuite-result.c, src/testsuite
+	/testsuite-result.h, src/testsuite/tst-test-result-execute.c,
+	src/testsuite/tst-test-script-compile.c, src/testsuite/tst-test-
+	script-run.c, tests/multiscript/basic.svtest,
+	tests/multiscript/conflicts.svtest, tests/multiscript/fileinto-
+	inbox.sieve, tests/multiscript/notify.sieve,
+	tests/multiscript/reject-1.sieve, tests/multiscript/reject-2.sieve,
+	tests/multiscript/vacation.sieve:
+	Testsuite: added multiscript tests and required support.
+	[55a8d5467bb7]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c:
+	Enotify: removed conflicting action flag.
+	[507b4e15de60]
+
+	* src/testsuite/testsuite-log.c, src/testsuite/testsuite-log.h,
+	src/testsuite/testsuite-script.c, src/testsuite/testsuite-script.h:
+	Testsuite: forgot to add new files.
+	[706e67f38fe1]
+
+	* src/testsuite/Makefile.am, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-result.c, src/testsuite/tst-test-error.c,
+	tests/extensions/enotify/basic.svtest:
+	Testsuite: split off script and error handler implementations into
+	separate modules.
+	[934cd4598d45]
+
+2009-01-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c:
+	Fixed warning caused by previous changes.
+	[b1878ff375d3]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-result.c:
+	Multiscript: resolved inter-script action conflict situations.
+	[cf3dacb0427f]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	result.c:
+	Cleaned up action interface.
+	[9aa51ae533c0]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/testsuite/tst-test-result.c, tests/execute/actions.svtest,
+	tests/extensions/vacation/execute.svtest:
+	Multiscript: adjusted result object for sequential execution.
+	[091473d12b22]
+
+2008-12-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[61bdad87a347]
+
+2008-12-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-result.c, src/testsuite/testsuite-
+	result.c, tests/execute/actions.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/vacation/execute.svtest:
+	Testsuite: added basic result execution tests for various
+	extensions.
+	[a3db8c51ef35]
+
+	* src/lib-sieve/sieve-result.h, src/testsuite/Makefile.am,
+	src/testsuite/ext-testsuite.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-result.c,
+	src/testsuite/testsuite-result.h, src/testsuite/tst-test-result-
+	execute.c, tests/extensions/enotify/execute.svtest:
+	Testsuite: added support for executing results.
+	[7b6167bd595c]
+
+	* src/testsuite/tst-test-compile.c, src/testsuite/tst-test-execute.c,
+	src/testsuite/tst-test-script-compile.c, src/testsuite/tst-test-
+	script-run.c:
+	Testsuite: forgot committing rename in previous commit.
+	[f8e21027c484]
+
+	* src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/tst-test-result.c, tests/compile/compile.svtest,
+	tests/compile/errors.svtest, tests/compile/examples.svtest,
+	tests/execute/actions.svtest, tests/execute/errors.svtest,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/execute.svtest,
+	tests/extensions/imapflags/execute.svtest,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/regex/errors.svtest,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/relational/errors.svtest,
+	tests/extensions/vacation/errors.svtest,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/variables/errors.svtest, tests/testsuite.svtest:
+	Testsuite: renamed script compile and run commands to be more
+	intuitive.
+	[f52cf8c2e033]
+
+	* src/lib-sieve/sieve-code.c, src/testsuite/Makefile.am, src/testsuite
+	/ext-testsuite.c, src/testsuite/testsuite-arguments.c, src/testsuite
+	/testsuite-arguments.h, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-substitutions.c, src/testsuite/testsuite-
+	substitutions.h, tests/testsuite.svtest:
+	Testsuite: started implementing support for testsuite-specific
+	string substitutions.
+	[93c9cf02290f]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-
+	commands.c, src/lib-sieve/sieve-commands.h:
+	Exported variable string argument into the Sieve engine itself as
+	'catenated string' (for similar use in other extensions like the
+	testsuite).
+	[0b0b3ab3967f]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h:
+	Exported variable string operand into the Sieve engine itself as
+	'catenated string' (for similar use in other extensions like the
+	testsuite).
+	[75d44b76a63e]
+
+	* TODO:
+	Updated TODO.
+	[4da90917e551]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: forgot to add 'from' header to list of reserved
+	headers.
+	[504ba37c919c]
+
+	* TODO:
+	Updated TODO list.
+	[da6447787785]
+
+	* Makefile.am, TODO, configure.in, dsieve-config.h.in, src/lib-
+	sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src/lib-sieve
+	/sieve-extensions.c:
+	Enotify: added enotify extension to default compile.
+	[1a69b463d9ad]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: enforced limits on number of recipients and
+	headers.
+	[78fdf4f59ff2]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/uri-mailto.sieve:
+	Enotify: mailto: finished URI parsing.
+	[30a272720d99]
+
+2008-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: fixed various bugs introduced by previous
+	enthousiastic commit.
+	[bfc6b485e5bc]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: added check for duplicates of unique headers in the
+	mailto URI.
+	[92b60e522c1e]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: previous change did not distinguish Cc recipients.
+	[4eded3dc6a8a]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: added check for duplicate recipients within URI.
+	[453e9f5ab425]
+
+	* TODO:
+	Updated TODO.
+	[6b666e5ef348]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.c:
+	Enotify: added FIXME.
+	[ee257412d8ba]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: added runtime support for options and performed some minor
+	cleanups.
+	[08b6a2984d57]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/options.sieve:
+	Enotify: added parsing support for the :options argument.
+	[e7c9fab2e100]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed semantic bug in extension handling.
+	[e806506c8e7c]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed segfault bug in extension handling.
+	[f7666442e384]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/enotify/ntfy-
+	mailto.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h:
+	Moved new_message_id function to sieve-message.c where it is more
+	appropriate.
+	[acf8bc97e74c]
+
+	* README, src/lib-sieve/plugins/enotify/ext-enotify.c:
+	Updated documentation.
+	[b577aab39b21]
+
+2008-12-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[7de9c6687512]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/enotify/ext-enotify-
+	common.c, src/lib-sieve/plugins/enotify/ext-enotify-common.h, src
+	/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/enotify/tst-notify-method-capability.c,
+	tests/extensions/enotify/notify_method_capability.svtest,
+	tests/extensions/enotify/valid-notify-method.svtest,
+	tests/extensions/enotify/valid_notify_method.svtest:
+	Enotify: implemented notify_method_capability test.
+	[33c97930469f]
+
+	* TODO, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/tst-valid-notify-method.c, tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/uri-mailto.sieve,
+	tests/extensions/enotify/errors/uri.sieve,
+	tests/extensions/enotify/errors/url-mailto.sieve,
+	tests/extensions/enotify/errors/url.sieve, tests/extensions/enotify
+	/valid-notify-method.svtest:
+	Enotify: implemented the valid_notify_method test.
+	[c504a425e11d]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	binary-dumper.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-message.c, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-validator.c, src/testsuite/ext-
+	testsuite.c:
+	Simplified handling of extension ids.
+	[91a1ac721a68]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/regex
+	/ext-regex-common.c, src/lib-sieve/plugins/relational/ext-
+	relational-common.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-objects.c, src/testsuite/testsuite-objects.c, src/testsuite
+	/testsuite-objects.h:
+	Renamed extension object registry.
+	[0d7c3b514b9d]
+
+2008-12-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[6e22db2771a9]
+
+	* TODO, doc/man/sieve-test.1, doc/man/sievec.1, src/lib-sieve-tool
+	/sieve-tool.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-tools/sieve-
+	test.c, src/sieve-tools/sievec.c:
+	Implemented support for configuring the available extensions.
+	[fb0ba83175f5]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: changed location of X-Sieve header.
+	[0760764e19ce]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: last change used wrong address.
+	[481a04fbfa9c]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: properly implemented use of :from address argument.
+	[51b40d48e6ea]
+
+	* src/lib-sieve/sieve-address.c:
+	Fixed accidental paste in sieve-address.c.
+	[baab6e581455]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/url-mailto.sieve:
+	Enotify: added recipient verification and implemented proper To and
+	Cc header composition.
+	[05b5b209c013]
+
+	* tests/extensions/enotify/errors/from-mailto.sieve:
+	Enotify: forgot to add new file to the test suite.
+	[41cef5314a94]
+
+	* TODO, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/errors.svtest:
+	Enotify: implemented verification of the :from address.
+	[52ec54e6d86a]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: made log struct name shorter.
+	[595a03fe94c5]
+
+	* src/lib-sieve/rfc2822.c:
+	Fixed compiler warning about signed char.
+	[e8f9a89974cd]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: corrected mailto URI error messages.
+	[3e4bb8701786]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: cleaned up URI error handling.
+	[543b25d99edf]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/sieve-actions.c, src/lib-sieve
+	/sieve-actions.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h:
+	Enotify: shielded most of the method API from compiler internals.
+	[996e60017ae1]
+
+2008-12-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: added owner email to auto-submitted header.
+	[c2568b13b4c5]
+
+2008-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[4b85554381de]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Small cosmetic changes to lexer sources.
+	[304d0952005f]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: excluded body 'header' in URI from the header field
+	body verification.
+	[675dcf5550b8]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Enotify: mailto: implemented verification of (unstructured) header
+	field bodies and improved URI syntax checking.
+	[6993557e1579]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-exists.c:
+	Substituted mail_get_headers for mail_get_headers_utf8 for those
+	occasions where utf8 is of no concern.
+	[33ff0356a8d0]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/copy/ext-copy.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-result.c:
+	Improved result execution and prevented failure on store action on
+	dry run (with no specified namespace).
+	[85fbe163f73e]
+
+	* TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: avoided sending notifications on auto-submitted messages.
+	[03ba5acfb863]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	validator.c:
+	Adapted to changes in the Dovecot API.
+	[e290c9a5b8d1]
+
+2008-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Merged concurrent changes.
+	[7c970d2e18c4]
+
+2008-12-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: mailto: added filtering of reserved headers.
+	[2dc8040cc0ca]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: changed notify message to match the latest draft
+	specification better (not yet compliant).
+	[78088c8352ee]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: now using new message composition functions.
+	[5105e03885bd]
+
+	* src/sieve-tools/sieve-exec.c:
+	Fixed message typo in sieve-exec tool.
+	[8aeef1355af5]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/rfc2822.c:
+	Reject: now using new message composition functions.
+	[2c8c7d6c51e0]
+
+	* configure.in:
+	Change to configure.in caused compile error.
+	[0285d0ef1b5a]
+
+	* configure.in:
+	Fixed bug in configure script that emitted Dovecot version in config
+	header in stead of Sieve version.
+	[33b8e83d57d0]
+
+	* src/lib-sieve/cmd-redirect.c:
+	Added X-Sieve header to redirected messages.
+	[073514b8b521]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: now using new message composition functions.
+	[46f1c431076a]
+
+	* src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h:
+	Created basic internet mail message composition functionality.
+	[f6ae429a7256]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/rfc2822.c,
+	src/lib-sieve/rfc2822.h, tests/extensions/vacation/references.sieve,
+	tests/extensions/vacation/references.svtest:
+	Vacation: added support for properly updating references header.
+	[12399f096262]
+
+2008-12-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: implemented basic notify mailto: execution.
+	[71a3f5b90533]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: implemented construction and printing of action object.
+	[ae144360043a]
+
+	* src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h:
+	Enotify: implemented runtime part.
+	[84c05cf58119]
+
+2008-12-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: restructured mailto url parsing to use arrays for the
+	results.
+	[e02c5e441ca2]
+
+	* Makefile.am, src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/errors.svtest,
+	tests/extensions/enotify/errors/url-mailto.sieve,
+	tests/extensions/enotify/errors/url.sieve:
+	Enotify: added verification of header field names in mailto url.
+	[9972da3b72b5]
+
+2008-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO: listed what remains to be done for the enotify
+	extension and its mailto method.
+	[b502f54d24ea]
+
+	* doc/rfc/draft-ietf-sieve-notify-mailto-09.txt, doc/rfc/draft-ietf-
+	sieve-notify-mailto-10.txt:
+	Updated enotify:mailto draft RFC.
+	[a9992d1abeb1]
+
+2008-12-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-reject.c:
+	Reject: improved message rejection log message.
+	[2758742b1a0f]
+
+2008-12-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/rfc2822.c, src/lib-sieve/rfc2822.h, src/lib-
+	sieve/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, tests/compile/warnings/invalid-headers.sieve:
+	Compiler now warns about syntactically invalid header field names.
+	[67f94b204982]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-commands.h, src/lib-sieve/tst-truefalse.c:
+	Exported true and false commands to separate file.
+	[fae455ed3f25]
+
+2008-11-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-extensions.c:
+	Fixed bug in improved capability string composition.
+	[6f2f1b51ce19]
+
+	* src/lib-sieve/plugins/enotify/ext-enotify-limits.h, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c:
+	Enotify: further developed URI parsing.
+	[e0f21b538123]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/rfc2822.c, src/lib-
+	sieve/rfc2822.h:
+	Added support for header verification.
+	[5661acb85286]
+
+	* src/lib-sieve/plugins/enotify/ntfy-mailto.c,
+	tests/extensions/enotify/basic.svtest:
+	Enotify: implemented coarse mailto URI parsing.
+	[f7fba9671c6b]
+
+	* doc/rfc/draft-duerst-mailto-bis-05.txt:
+	Added new draft-bis version of mailto RFC to doc/rfc.
+	[cbecc1c67646]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Activated unload handler for extensions.
+	[478f0bcdb6ff]
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/cmd-notify.c, src/lib-sieve/plugins/enotify
+	/ext-enotify-common.c, src/lib-sieve/plugins/enotify/ext-enotify-
+	common.h, src/lib-sieve/plugins/enotify/ext-enotify-limits.h, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, tests/extensions/enotify/execute.svtest:
+	Enotify: implemented uri scheme verification.
+	[0572076ad26f]
+
+2008-11-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/enotify/ext-enotify-common.c, src
+	/lib-sieve/plugins/enotify/ext-enotify.c, src/lib-
+	sieve/plugins/enotify/ntfy-mailto.c, src/lib-sieve/plugins/enotify
+	/sieve-ext-enotify.h, src/lib-sieve/plugins/imapflags/ext-
+	imapflags.c, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Added unload method to extension object.
+	[27b8f617ddd9]
+
+2008-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Reprioritized TODO.
+	[cbe0a7182be8]
+
+2008-11-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.2 for changeset f01fe5f1e816
+	[ec695f863a30]
+
+	* .hgtags:
+	Added tag 0.1.1 for changeset e534276ecf10
+	[f01fe5f1e816] [0.1.2]
+
+	* NEWS, configure.in:
+	Released v0.1.2 for Dovecot v1.2.alpha4.
+	[3f1ca3de6312]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: improved log message for discarded vacation response.
+	[346b7c072b0a]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed bug in the handling of context during result execution, which
+	resulted in broken redirect action.
+	[28e3144b79d1]
+
+2008-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.1.1 for Dovecot v1.2.alpha4.
+	[e534276ecf10] [0.1.1]
+
+2008-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[4dfeda80d78d]
+
+2008-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/ntfy-mailto.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	address.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	extensions.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Added registry for extension capabilities like the available notify
+	methods and adjusted the enotify extension accordingly.
+	[007bb75439a8]
+
+2008-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/i-ascii-numeric.rfc2244.txt, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/rfc2244.txt:
+	Forgot to move RFC 2244 to proper place in doc/rfc.
+	[9605841f6f27]
+
+	* Makefile.am, doc/rfc/uri.rfc3986.txt, src/lib-sieve/plugins/enotify
+	/vmodf-encodeurl.c, tests/extensions/enotify/encodeurl.svtest:
+	Enotify: implemented :encodeurl variables modifier.
+	[68bae1330f0c]
+
+	* TODO:
+	Added TODO item.
+	[2ab9a8390108]
+
+	* src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool/sieve-tool.c, src
+	/lib-sieve/sieve-actions.c, src/sieve-tools/sieve-exec.c, src/sieve-
+	tools/sieve-test.c, src/testsuite/testsuite.c:
+	Adapted to changes in the mailbox_open() API.
+	[def28c3fc40c]
+
+2008-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Merged concurrent changes.
+	[0cdeefe057f7]
+
+	* doc/rfc/mailto.rfc2368.txt, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/cmd-notify.c, src/lib-sieve/plugins/enotify/ntfy-mailto.c, src/lib-
+	sieve/plugins/enotify/sieve-ext-enotify.h, src/lib-
+	sieve/plugins/enotify/vmodf-encodeurl.c:
+	Enotify: copied action implementation from old plugin.
+	[f4a1cf59f9ce]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.c:
+	Fixed error handling of actions that send mail.
+	[eb88535b1b04]
+
+2008-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-mailto-09.txt:
+	Added notify mailto draft.
+	[c32f0e1a2ab1]
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/vmodf-encodeurl.c, src/lib-sieve/plugins/variables/ext-variables-
+	common.c, src/lib-sieve/plugins/variables/ext-variables-common.h,
+	src/lib-sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h,
+	tests/extensions/enotify/execute.svtest:
+	Enotify: finished skeleton by addin empty :encodeurl implementation.
+	[1468452b4a29]
+
+	* Makefile.am, tests/extensions/enotify/execute.svtest,
+	tests/extensions/enotify/execute/draft-rfc-ex1.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex2.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex3.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex5.sieve,
+	tests/extensions/enotify/execute/draft-rfc-ex6.sieve:
+	Testsuite: added draft RFC examples as execution tests.
+	[45464b463539]
+
+2008-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, configure.in, src/lib-sieve/plugins/include/ext-
+	include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	common.c, src/lib-sieve/plugins/include/ext-include.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Enabled (optional) support for Valgrind in the testsuite and fixed a
+	few intricate bugs in the process.
+	[0d0571b7b81c]
+
+2008-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve-tool/sieve-tool.c:
+	Changed acquisition of usernames in sieve command line tools.
+	[4fcbcffe14c3]
+
+	* tests/header.svtest:
+	Testsuite: added test for header folding.
+	[bca59633ce16]
+
+	* src/lib-sieve-tool/mail-raw.c:
+	Fixed bug in mail_raw implementation: mail_namespaces_deinit() must
+	not be called explicitly for v1.2.
+	[d9a73ee95b2c]
+
+2008-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Previous change did not compile.
+	[80aa797d9521]
+
+	* src/lib-sieve/sieve-actions.c:
+	Matched changes in Dovecot to properly handle/ignore the new mailbox
+	ACL support.
+	[0e7868a06c20]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Merged concurrent changes.
+	[d999e9b1f138]
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Fixed small indentation error.
+	[dbef1b96761a]
+
+2008-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-script.c:
+	Fixed bug in handling of non-existent scripts.
+	[bb9602e98abb]
+
+	* NEWS:
+	Prepared NEWS file for next release.
+	[ce33eb8c29d3]
+
+	* INSTALL, README:
+	Slightly improved documentation.
+	[e957f2fc38ef]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in import/export commands.
+	[49b0d4a70dab]
+
+2008-11-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-validator.c:
+	Imap4flags: fixed bug in the handling of the internal variable.
+
+	Previously the final value of internal variable was for every store
+	action that didn't specify a :flags argument explicitly. This
+	results in out-of order assignment/removal of flags, e.g. also the
+	flags assigned keep actions that were executed before the
+	addflag/setflag command were modified.
+	[94ad1f1aa91b]
+
+	* TODO:
+	Updated TODO.
+	[56ddfa9b2d3b]
+
+	* README:
+	Removed man page issue from README file.
+	[b9a138e1a781]
+
+	* README:
+	Updated README.
+	[f4a59b2c82b2]
+
+	* Makefile.am, doc/man/sieve-test.1:
+	Created man page for the sieve-test command.
+	[f4c64a82078b]
+
+2008-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, doc/man/sieved.1:
+	Created man page for the sieved command.
+	[837bc0ccab02]
+
+	* Makefile.am:
+	Enabled installation of man pages.
+	[6439050d232d]
+
+	* src/lib-sieve/Makefile.am:
+	Forgot to add new sieve-config.h to the distribution.
+	[9fa6336ed90c]
+
+	* doc/man/sievec.1:
+	Created (currently uninstalled) man page for the sievec command.
+	[95478625a6ce]
+
+	* Makefile.am:
+	Testsuite: fail with informative error if compiled against dovecot
+	headers only.
+	[4510184ed680]
+
+	* configure.in, src/Makefile.am:
+	Re-enabled support for compiling against Dovecot headers.
+	[36e00217bdd2]
+
+2008-11-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/tst-notify-method-capability.c:
+	Enotify: added skeleton implementation of notify_method_capability
+	test.
+	[89259cdff750]
+
+2008-11-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/enotify/Makefile.am, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/plugins/enotify
+	/tst-valid-notify-method.c, tests/extensions/enotify/basic.svtest:
+	Enotify: added skeleton implementation of valid_notify_method test.
+	[c9a597e248ab]
+
+2008-11-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/plugins/enotify/cmd-notify.c, src/lib-
+	sieve/plugins/enotify/ext-enotify-common.h, src/lib-
+	sieve/plugins/enotify/ext-enotify.c, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, tests/extensions/enotify/basic.svtest:
+	Enotify: implemented skeleton for the notify command.
+	[a004b31bcc08]
+
+2008-11-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-extensions.c:
+	ENotify: activated empty implementation.
+	[63e099d7edf7]
+
+	* .hgignore, configure.in, dsieve-config.h.in, src/lib-
+	sieve/Makefile.am, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-config.h, src/lib-sieve/sieve-types.h, src/lib-sieve/sieve.h:
+	Started using autoconf output.
+	[c5ff061ac5f4]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/sieve-actions.h:
+	Added UTF-8 to modified UTF-7 folder name conversion for
+	compatibility with IMAP.
+	[fc0395d50d04]
+
+	* .hgignore, src/sieve-tools/sieve-exec, src/sieve-tools/sieve-test,
+	src/sieve-tools/sievec, src/sieve-tools/sieved:
+	Accidentally added binaries for sieve tools.
+	[99b09b8a310a]
+
+2008-11-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-notify-12.txt, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/cmd-notify.c, src/lib-sieve/plugins/enotify/ext-enotify-common.h,
+	src/lib-sieve/plugins/enotify/ext-enotify.c:
+	Enotify: built skeleton for the notify command.
+	[482517b70a32]
+
+	* README, TODO, configure.in, src/Makefile.am, src/lib-sieve-
+	tool/Makefile.am, src/lib-sieve-tool/mail-raw.c, src/lib-sieve-tool
+	/mail-raw.h, src/lib-sieve-tool/sieve-tool.c, src/lib-sieve-tool
+	/sieve-tool.h, src/lib-util/Makefile.am, src/lib-util/mail-raw.c,
+	src/lib-util/mail-raw.h, src/sieve-bin/Makefile.am, src/sieve-bin
+	/bin-common.c, src/sieve-bin/bin-common.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/sieve-bin/sievec.c, src
+	/sieve-bin/sieved.c, src/sieve-tools/Makefile.am, src/sieve-tools
+	/sieve-exec, src/sieve-tools/sieve-exec.c, src/sieve-tools/sieve-
+	test, src/sieve-tools/sieve-test.c, src/sieve-tools/sievec, src
+	/sieve-tools/sievec.c, src/sieve-tools/sieved, src/sieve-
+	tools/sieved.c, src/testsuite/Makefile.am,
+	src/testsuite/testsuite.c:
+	Removed code duplication between testsuite and commandline tools.
+	Also restructured source code of the tools.
+	[bf8ca24d25ef]
+
+2008-10-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/namespaces.c, src/sieve-
+	bin/namespaces.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c, src/testsuite/Makefile.am, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite.c:
+	Removed now obsolete namespaces.c/h from testsuite and commandline
+	tools.
+	[937eb9e8e043]
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/namespaces.c,
+	src/testsuite/Makefile.am, src/testsuite/namespaces.c:
+	Enabled all available mail storage types (those compiled in Dovecot)
+	for the commandline tools and the testsuite.
+	[3d96a883bda0]
+
+	* configure.in, src/Makefile.am, src/lib-util/Makefile.am, src/lib-
+	util/mail-raw.c, src/lib-util/mail-raw.h, src/sieve-bin/Makefile.am,
+	src/sieve-bin/bin-common.c, src/sieve-bin/mail-raw.c, src/sieve-bin
+	/mail-raw.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/testsuite/Makefile.am, src/testsuite/mail-raw.c, src/testsuite
+	/mail-raw.h, src/testsuite/testsuite-common.c:
+	Merged mail-raw implementations of sieve commandline tools and the
+	testsuite, thus removing duplicate code.
+	[7e82c26a38bd]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/bin-common.c:
+	Made lda plugin properly refer to the main script as 'main script'
+	and not the basename of the sieve file (which is of no interest to
+	the user for the main script).
+	[bc09d2616c36]
+
+	* src/lib-sieve/sieve-script.c, src/plugins/lda-sieve/lda-sieve-
+	plugin.c:
+	Improved logging of failed script load.
+	[32c0b5cc77af]
+
+2008-10-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Now using folder name as specified by user in log messages in stead
+	of internal representation.
+	[5d6f65468c6d]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Added mail_debug messages to plugin to find problems in the sieve
+	path specification more easily.
+	[91a3f25c3df5]
+
+	* TODO:
+	Added TODO item.
+	[747107b816dc]
+
+	* src/sieve-bin/sievec.c:
+	Command sievec -d always wrote to std out.
+	[e92ec8bbd16a]
+
+	* src/sieve-bin/bin-common.c, src/testsuite/testsuite.c:
+	Fixed missing mask argument in two open calls (bug found by Sergey
+	Ivanov).
+	[8dcba4f38a67]
+
+2008-10-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in, src/lib-sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/enotify/Makefile.am, src/lib-sieve/plugins/enotify
+	/ext-enotify.c:
+	Started development of enotify extension.
+	[85d6ef932c4f]
+
+2008-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.1.0 for changeset 065c12acdcc0
+	[b7d9c5e026b6]
+
+	* TODO, configure.in:
+	Released v0.1.0 for Dovecot v1.2.alpha3.
+	[065c12acdcc0] [0.1.0]
+
+	* AUTHORS, NEWS, README:
+	Minor revisions to the package documentation.
+	[9e487fec9dce]
+
+2008-10-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-types.h:
+	Fixed warning caused by mixup between mail_storage and
+	sieve_storage.
+	[aa3e90f621b1]
+
+	* src/lib-sieve/sieve-actions.c:
+	Improved execution of store action.
+	[2877fa93580c]
+
+2008-10-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-types.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Properly set storage_r in plugin function to prevent double errors.
+	[a679d84dff88]
+
+2008-10-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-result.c:
+	Prevented transaction context from becoming NULL in execution of
+	store action.
+	[2402b1499813]
+
+	* src/lib-sieve/sieve-result.c:
+	Fixed context handling bug in the result execution.
+	[a88276bff812]
+
+2008-10-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-validator.c, tests/compile/errors.svtest,
+	tests/compile/errors/typos.sieve:
+	Clarified errors occurring when colon is missing.
+	[3366b70ef4e3]
+
+	* src/lib-sieve/sieve-validator.c, tests/compile/errors.svtest:
+	Corrected error message.
+	[84dfe8d5a47a]
+
+	* README, src/lib-sieve/sieve-validator.c,
+	tests/compile/errors.svtest:
+	Clarified error messages for missing semicolon.
+	[b78529976e65]
+
+	* Makefile.am, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/body/body.sieve, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/Makefile.am, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/cmp-i-ascii-numeric.sieve, src/lib-
+	sieve/plugins/copy/Makefile.am, src/lib-
+	sieve/plugins/copy/copy.sieve, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-implicit.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/lib-sieve/plugins/vacation
+	/vacation-errors.sieve, src/lib-
+	sieve/plugins/vacation/vacation.sieve, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/variables-errors.sieve, src/lib-sieve/plugins/variables/variables-
+	match.sieve, src/lib-sieve/plugins/variables/variables-nspace.sieve,
+	src/lib-sieve/plugins/variables/variables-regex.sieve, src/lib-
+	sieve/plugins/variables/variables.sieve, src/testsuite/Makefile.am:
+	Repaired 'make dist' tarball output.
+	[28b57e7024b7]
+
+	* INSTALL, README, configure.in:
+	Revised README.
+	[dd3cdd379693]
+
+	* TODO, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h,
+	src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-result.c, src/testsuite/testsuite-result.h,
+	src/testsuite/tst-test-error.c, src/testsuite/tst-test-result.c,
+	tests/execute/actions.svtest, tests/execute/actions/fileinto.sieve,
+	tests/execute/actions/redirect.sieve,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/vacation/execute/action.sieve:
+	Testsuite: added support for basic result checking.
+	[ff43885270f0]
+
+	* TODO, doc/rfc/RFC Controversy.txt, doc/rfc/RFC-questions.txt:
+	Reported RFC questions to the ietf-mta-filters mailinglist.
+	[c878efb32b9d]
+
+	* TODO, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/sieve-comparators.c,
+	tests/compile/errors.svtest, tests/compile/errors/unsupported.sieve:
+	Added explicit messages and tests for unsupported use of variables.
+	[6d1c5ca0d75c]
+
+2008-10-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[56dc772ca475]
+
+	* TODO, src/lib-sieve/plugins/variables/ext-variables-dump.c:
+	Fixed TODO: made sure main scope used in variables dumping is
+	unreferenced when code dumper is freed.
+	[58f57ad4f723]
+
+	* TODO:
+	Tested replacing cmusieve with sieve.
+	[3a82ec3361db]
+
+	* src/lib-sieve/sieve-binary.c:
+	Function t_str_new_const got moved to its proper place in Dovecot.
+	[7f5fc7f2e8cc]
+
+2008-10-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-
+	dumper.h:
+	Added extension support to code dumper.
+	[59f5b7074e34]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-parser.c:
+	Removed/solved minor TODOs.
+	[f16ab5f94f51]
+
+	* TODO:
+	Merged concurrent changes.
+	[d061ae363863]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables-dump.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h:
+	Variables/Include: added support for dumping variables declared in
+	extension scopes.
+	[d514f5e3a5f4]
+
+2008-10-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/sieve-error.c:
+	Fixed amd64 logging segfault; turns out using same va_args in
+	multiple vprintf calls is not possible.
+	[139edcdd3820]
+
+2008-10-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-actions.c:
+	Added support for mailbox autocreate and autosubscribe.
+	[79da56ccfdc5]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve
+	/sieve-types.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite.c:
+	Made plugin use tried_default_save indicator to prevent duplicate
+	error messages.
+	[f0a7278c5645]
+
+2008-10-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO.
+	[0896583c34c1]
+
+2008-09-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-code-dumper.h:
+	Variables: added identifier dump support for main scope.
+	[87841459a7ee]
+
+2008-09-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-dump.c, src/lib-
+	sieve/plugins/variables/ext-variables-dump.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code-dumper.h:
+	Variables: added dumptime context.
+	[7cd99ac6219f]
+
+2008-09-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[f61d20c07954]
+
+2008-09-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Started NEWS file.
+	[32f5a1ed47c6]
+
+	* DESIGN, Makefile.am, doc/devel/DESIGN:
+	Moved design description to doc/devel directory.
+	[1673630bb79d]
+
+	* README, examples/elvey.sieve, examples/jerry.sieve,
+	examples/mjohnson.sieve, examples/mklose.sieve,
+	examples/relational.rfc5231.sieve, examples/rfc3028.sieve,
+	examples/sanjay.sieve, examples/sieve_examples.sieve,
+	examples/subaddress.rfc5233.sieve, examples/vacation.sieve,
+	examples/vivil.sieve, sieve/examples/elvey.sieve,
+	sieve/examples/jerry.sieve, sieve/examples/mjohnson.sieve,
+	sieve/examples/mklose.sieve,
+	sieve/examples/relational.rfc5231.sieve,
+	sieve/examples/rfc3028.sieve, sieve/examples/sanjay.sieve,
+	sieve/examples/sieve_examples.sieve,
+	sieve/examples/subaddress.rfc5233.sieve,
+	sieve/examples/vacation.sieve, sieve/examples/vivil.sieve,
+	sieve/tests/actions.sieve, sieve/tests/address-part.sieve,
+	sieve/tests/basic.sieve, sieve/tests/comparator.sieve, sieve/tests
+	/encoded-character.sieve, sieve/tests/envelope.sieve,
+	sieve/tests/extensions.sieve, sieve/tests/if.sieve, sieve/tests
+	/match-type.sieve, sieve/tests/matches.sieve,
+	sieve/tests/stop.sieve, sieve/tests/vacation.sieve,
+	tests/compile/examples.svtest:
+	Restructured Sieve example scripts.
+	[a1962f923e34]
+
+	* Makefile.am, sieve/tests/fileinto.sieve, sieve/tests/redirect.sieve,
+	tests/execute/actions.svtest, tests/execute/actions/fileinto.sieve,
+	tests/execute/actions/redirect.sieve,
+	tests/extensions/reject/execute.svtest:
+	Testsuite: added execution tests for core actions (to find
+	segfaults).
+	[a1dd8113e9d3]
+
+	* Makefile.am, sieve/tests/reject.sieve,
+	tests/extensions/reject/execute.svtest,
+	tests/extensions/reject/execute/basic.sieve:
+	Testsuite: added trivial reject action execution test.
+	[f319f06ede13]
+
+2008-09-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/address-errors.sieve, sieve/errors/address-part-
+	errors.sieve, sieve/errors/encoded-character.sieve, sieve/errors
+	/envelope-errors.sieve, sieve/errors/header-errors.sieve,
+	sieve/errors/if-errors.sieve, sieve/errors/interesting.sieve,
+	sieve/errors/keep-errors.sieve, sieve/errors/out-address-
+	errors.sieve, sieve/errors/parse-errors.sieve, sieve/errors/require-
+	errors.sieve, sieve/errors/size-errors.sieve, sieve/errors/stop-
+	errors.sieve, sieve/errors/tag-errors.sieve,
+	tests/compile/errors.svtest, tests/compile/errors/out-address.sieve,
+	tests/compile/errors/tag.sieve:
+	Testsuite: added final existing error tests.
+	[08769a713018]
+
+	* README:
+	Improved README to be more readable.
+	[e6c4a1fdfb42]
+
+2008-09-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c:
+	Removed useless PTR_OFFSET from logfile error handler
+	implementation.
+	[6f8a49489e5e]
+
+	* TODO:
+	Added pre-release TODO item.
+	[4b4ef898598d]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src
+	/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-size.c, src/testsuite
+	/testsuite-objects.c:
+	Improved argument error reporting.
+	[ad5905fa16bc]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h:
+	Restructured error reporting in validator and code generator.
+	[d54dfe15ad5f]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/tst-
+	size.c, src/testsuite/tst-test-error.c:
+	Fixed new ia64 warnings.
+	[191eabe91f70]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed new ia64 warnings in sieve-code.
+	[bc8e86291ec7]
+
+	* src/lib-sieve/sieve-code.h:
+	Fixed new ia64 warnings in sieve-code.
+	[f655f4d28eb2]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed ia64 warnings in sieve-code.
+	[4f2b18823f75]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c:
+	Variables: fixed ia64 compiler warnings.
+	[04859d48e9f6]
+
+	* src/lib-sieve/sieve-error.c:
+	Forgot to handle return value of o_stream_send in logfile error
+	hander implementation.
+	[50f6194d644e]
+
+	* src/lib-sieve/sieve-error.c:
+	Forgot O_TRUNC in logfile error handler's second logfile open()
+	call.
+	[9f7e64968d61]
+
+	* src/lib-sieve/plugins/include/cmd-import.c:
+	Include: improved trace verbosity for import command.
+	[6618ab99e32a]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/variables/ext-variables-common.c,
+	src/lib-sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c:
+	Hopefully resolved various type cast warnings surfacing on ia_64 and
+	not on i386.
+	[0e9312deb8ea]
+
+	* tests/address.svtest:
+	Testsuite: added address test case for specific strange situation.
+	[5bc7b863ba0b]
+
+	* src/lib-sieve/plugins/relational/mcht-count.c:
+	Relational: fixed portability issue in count match type (warning).
+	[910812bf8e80]
+
+2008-09-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[11408405fac3]
+
+	* TODO, src/lib-sieve/sieve-error.c:
+	Devised simple log rotation to prevent per-user sieve processing
+	logs to grow indefinitely.
+	[9d42eeb8ce8f]
+
+2008-09-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[a589169c1870]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-modifiers.c, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/tst-string.c,
+	src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src/testsuite
+	/cmd-test-fail.c, src/testsuite/cmd-test-set.c, src/testsuite/cmd-
+	test.c, src/testsuite/testsuite-objects.c, src/testsuite/tst-test-
+	compile.c, src/testsuite/tst-test-error.c:
+	Improved byte code dumping to be more readable.
+	[758155f2aab1]
+
+	* TODO:
+	Updated TODO file.
+	[b9341f8c801e]
+
+2008-09-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README, TODO:
+	Updated documentation.
+	[6628c1731333]
+
+	* TODO:
+	Removed redundant security issue listed in TODO.
+	[05599a5b010b]
+
+	* Makefile.am, TODO, src/lib-sieve/mcht-is.c, src/lib-sieve/sieve-
+	address-parts.c, tests/address.svtest:
+	Resolved handling of invalid addresses in headers for the most part.
+	[0f3e2d8877e4]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: made sure broken/malicious binary cannot allocate
+	variable storage of arbitrary size.
+	[1ce135869da6]
+
+	* src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c:
+	Variables: added coding of variable scope.
+	[511ac1c1864e]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Added support for per-script extension intialization.
+	[8ce3c35e05d7]
+
+2008-09-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Reduced the severity of the warning indicating the experimental
+	nature of this implementation.
+	[ceea4bd93458]
+
+	* TODO:
+	Updated TODO.
+	[a200a842fd4c]
+
+2008-08-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code-dumper.c:
+	Minor cosmetic change to code dumping.
+	[75828a2293e0]
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve.c, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite.c:
+	Added the concept of a script code header to list the extensions
+	actually used by a script (was using all extensions listed in the
+	binary).
+	[7be9b0d97e5f]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/sieve-ast.c, src/lib-
+	sieve/sieve-ast.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c:
+	Revised implementation of the require command.
+	[40c588255ef4]
+
+	* Makefile.am, TODO, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	tests/extensions/vacation/execute.svtest,
+	tests/extensions/vacation/execute/no-handle.sieve:
+	Vacation: properly implemented handling of variables vs. handle
+	generation.
+	[93fb21f7bc6b]
+
+	* tests/extensions/imapflags/execute.svtest,
+	tests/extensions/imapflags/execute/flags-side-effect.sieve:
+	Forgot to add niet testsuite files.
+	[aae56b7f1a47]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Added support for runtime detection of variable strings.
+	[6e1f1dcabba9]
+
+	* TODO:
+	Updated TODO.
+	[7741fd1718b8]
+
+	* Makefile.am, TODO, src/lib-sieve/cmd-keep.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/tag-
+	flags.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-result.c:
+	Imapflags: properly implemented handling of duplicate store actions
+	with different :flags.
+	[3ac7e031ebd0]
+
+2008-08-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c:
+	Fixed assertion triggered at the end when redirect was executed
+	before.
+	[3ac9261ad66f]
+
+	* src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-bin
+	/sieve-exec.c, src/sieve-bin/sieve-test.c:
+	Incorporated changes in deliver into the mail-raw implementation of
+	the sieve tools.
+	[938996ab0023]
+
+2008-08-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c:
+	Imapflags: Added FIXME.
+	[fd1281ef5eef]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	result.c, src/lib-sieve/sieve-result.h, tests/execute/errors.svtest,
+	tests/execute/errors/actions-limit.sieve, tests/execute/errors
+	/redirect-limit.sieve:
+	Implemented policy limit on the maximum number of redirect actions
+	in a result.
+	[c8524a9a370f]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-limits.c, src/lib-
+	sieve/sieve-limits.h, src/lib-sieve/sieve-result.c,
+	tests/execute/errors.svtest, tests/execute/errors/actions-
+	limit.sieve:
+	Implemented limit on the number of actions active simultaneously.
+	[a62a86f489d0]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/include/errors/action-conflicts.sieve,
+	tests/extensions/include/errors/included/action-fileinto.sieve,
+	tests/extensions/include/errors/included/action-reject.sieve,
+	tests/extensions/include/errors/runtime.sieve:
+	Include: fixed a stupid bug triggered when variables are not used.
+	[48079cfe53f7]
+
+	* tests/extensions/include/errors.svtest:
+	Testsuite: activated runtime tests for the include extension.
+	[73aa79ec006a]
+
+	* Makefile.am, tests/extensions/vacation/errors.svtest,
+	tests/extensions/vacation/errors/conflict-reject.sieve:
+	Testsuite: added runtime error tests for vacation extension.
+	[d32c37e395ce]
+
+	* Makefile.am, tests/execute/errors.svtest, tests/execute/errors
+	/action-conflicts.sieve, tests/execute/errors/conflict-reject-
+	fileinto.sieve, tests/execute/errors/conflict-reject-keep.sieve,
+	tests/execute/errors/conflict-reject-redirect.sieve:
+	Testsuite: added simple runtime action conflict tests.
+	[6bef60271972]
+
+	* doc/rfc/draft-ietf-sieve-refuse-reject-07.txt:
+	Installed refuse-reject draft RFC in doc/rfc directory.
+	[c608ef17a086]
+
+2008-08-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/action-conflicts.sieve, sieve/errors/action-
+	duplicates.sieve, src/lib-sieve/sieve-interpreter.c,
+	src/testsuite/Makefile.am, src/testsuite/ext-testsuite.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c, src/testsuite/tst-test-execute.c,
+	tests/execute/errors/action-conflicts.sieve, tests/execute/errors
+	/action-duplicates.sieve:
+	Testsuite: added support for testing runtime errors.
+	[e2a304290b53]
+
+	* TODO, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve
+	/sieve-ast.c, src/lib-sieve/sieve-ast.h:
+	Vacation: discovered and partially fixed various RFC-related issues.
+	[97e0e14d9557]
+
+	* doc/rfc/vacation.rfc5230.txt, src/lib-sieve/plugins/vacation/draft-
+	ietf-sieve-vacation-07.txt, src/lib-sieve/plugins/vacation/ext-
+	vacation.c:
+	Installed new RFC for vacation extension in doc/rfc directory.
+	[df13b70a2cb1]
+
+	* TODO:
+	Updated TODO.
+	[a256cbead058]
+
+	* TODO, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-set.c,
+	src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/mail-raw.c, src/testsuite/mail-raw.h,
+	src/testsuite/namespaces.c, src/testsuite/namespaces.h,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h, src/testsuite/testsuite.c, src/testsuite/tst-test-
+	compile.c, src/testsuite/tst-test-error.c:
+	Finished code cleanup for now.
+	[a458a0b55c11]
+
+	* src/sieve-bin/bin-common.c, src/sieve-bin/bin-common.h, src/sieve-
+	bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-
+	bin/namespaces.c, src/sieve-bin/namespaces.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/sieve-bin/sievec.c, src
+	/sieve-bin/sieved.c:
+	Cleaned up Sieve tools.
+	[ae09a094452c]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.h:
+	Cleaned up LDA Sieve plugin.
+	[ed1ca951fd92]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-limits.h, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.h, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c:
+	Cleaned up variables extension.
+	[5a4e4e269892]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c:
+	Vacation: removed useless duplicate_mark call.
+	[569aaef1dd00]
+
+	* src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c:
+	Cleaned up vacation extension.
+	[8df7a1bc6564]
+
+2008-08-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, sieve/examples/subaddress.rfc5233.sieve, tests/address-
+	parts/subaddress.svtest, tests/compile/examples.svtest,
+	tests/extensions/subaddress/basic.svtest,
+	tests/extensions/subaddress/rfc.svtest:
+	Testsuite: extended tests for the subaddress extension.
+	[7f440b626914]
+
+2008-08-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/subaddress.rfc5233.txt, src/lib-
+	sieve/plugins/subaddress/rfc3598.txt:
+	Installed new subaddress RFC in doc/rfc directory.
+	[5cb09b134086]
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c:
+	Cleaned up subaddress extension.
+	[ec5e1f9fda78]
+
+	* Makefile.am, sieve/examples/relational.rfc5231.sieve, tests/compile
+	/compile-examples.svtest, tests/compile/examples.svtest,
+	tests/extensions/relational/basic.svtest,
+	tests/extensions/relational/errors.svtest,
+	tests/extensions/relational/errors/validation.sieve,
+	tests/extensions/relational/rfc.svtest, tests/match-
+	types/relational.svtest:
+	Testsuite: restructured and extended tests for the relational
+	extension.
+	[17ee47e6d698]
+
+	* doc/rfc/relational.rfc5231.txt, src/lib-
+	sieve/plugins/relational/rfc3431.txt:
+	Installed new relational RFC in doc/rfc directory.
+	[6a1838d879d9]
+
+	* src/lib-sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c:
+	Cleaned up relational extension.
+	[8fa1cca640b9]
+
+	* src/lib-sieve/plugins/regex/ext-regex-common.c, src/lib-
+	sieve/plugins/regex/ext-regex-common.h, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/regex/mcht-regex.c:
+	Cleaned up regex extension.
+	[930e79a89723]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/cmd-return.c, src/lib-sieve/plugins/include/ext-include-binary.c,
+	src/lib-sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-limits.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c:
+	Cleaned up include extension.
+	[4f58be7cfde3]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c:
+	Cleaned up imapflags extension.
+	[1dc6e9c11f50]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c:
+	Cleaned up copy extension.
+	[1ae3233e93c0]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c:
+	Cleaned up comparator-i;ascii-numeric.
+	[3bc2c679843b]
+
+2008-08-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* tests/extensions/body/match-values.svtest:
+	Forgot to add test file.
+	[31efedcb72a6]
+
+	* Makefile.am:
+	Testsuite: added test for the behavior of the body test with match
+	values.
+	[76c69d75e5bd]
+
+	* src/lib-sieve/plugins/body/ext-body-common.h, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/sieve-match-types.c:
+	Body: now disables match value processing during body test
+	evaluation as required by RFC.
+	[43ed6da2c07d]
+
+	* src/lib-sieve/mcht-contains.c, src/lib-sieve/mcht-is.c, src/lib-
+	sieve/mcht-matches.c, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve-script-private.h, src/lib-sieve
+	/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-sieve/sieve-
+	types.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Finished code cleanup of the sieve library itself.
+	[7041828c5bf4]
+
+	* src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-dump.h, src/lib-
+	sieve/sieve-error-private.h, src/lib-sieve/sieve-error.c, src/lib-
+	sieve/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-limits.h, src/lib-sieve
+	/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h:
+	Broad code cleanup.
+	[ce2750c32d73]
+
+	* src/lib-sieve/cmd-stop.c:
+	Forgot to add new file for stop command.
+	[85e220b27364]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-if.c, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-
+	size.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-set.c,
+	src/testsuite/cmd-test.c, src/testsuite/tst-test-compile.c,
+	src/testsuite/tst-test-error.c:
+	Cleaned up commands implementation.
+	[b91b56692665]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Cleaned up sieve-code.
+	[bbee4bf32b63]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-binary-
+	dumper.h:
+	Cleaned up sieve-binary-dumper.
+	[08a3dc06bce3]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h:
+	Cleaned up sieve-binary.
+	[22672ecf40c3]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h:
+	Cleaned up sieve-ast.
+	[00363cd89a2a]
+
+	* src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-address.h:
+	Cleaned up sieve-address.
+	[cb7d1b1feb8d]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Cleaned up actions implementation.
+	[af5589339bd3]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-comparators.c:
+	Cleaned up address part and comparator implementation.
+	[dfc2d1398889]
+
+	* sieve/errors/match-type-errors.sieve, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/variables/tst-string.c, src
+	/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-match-types.c,
+	src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-header.c, src/testsuite/tst-test-error.c,
+	tests/compile/errors.svtest, tests/compile/errors/match-type.sieve:
+	Cleaned up match type implementation.
+	[945375c5c915]
+
+	* TODO, src/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: improvements and bugfixes.
+	[a6cf1195a291]
+
+	* Makefile.am, src/lib-sieve/plugins/regex/regex-errors.sieve,
+	tests/extensions/regex/basic.svtest,
+	tests/extensions/regex/errors.svtest,
+	tests/extensions/regex/errors/compile.sieve, tests/match-
+	types/regex.svtest:
+	Testsuite: restructured regex tests.
+	[8e7c02d55cf3]
+
+	* Makefile.am, doc/rfc/draft-murchison-sieve-regex-07.txt, src/lib-
+	sieve/plugins/regex/draft-murchison-sieve-regex-07.txt, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/sieve-match-types.c,
+	tests/extensions/variables/regex.svtest, tests/match-
+	types/regex.svtest:
+	Regex: fixed a few minor bugs.
+	[560db263607a]
+
+2008-08-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src/sieve-
+	bin/namespaces.c, src/sieve-bin/namespaces.h, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c, src/testsuite/mail-raw.c,
+	src/testsuite/mail-raw.h, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Compile fix for changes in Dovecot.
+	[aa1a94658613]
+
+2008-08-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/include/errors/runtime.sieve:
+	Include: implemented runtime checking of export/import.
+	[cbd74d26eff4]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include-variables.c, src
+	/lib-sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-validator.c,
+	tests/extensions/include/variables.svtest:
+	Include: transformed import and export to actual code operations for
+	runtime checking.
+	[d8002c76aabb]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: added functionality to obtain variable identifier from
+	storage using linked scope.
+	[504a89d17b2d]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h:
+	Variables: invalid variable indexes now trigger interpretation to
+	fail with EXEC_BIN_CORRUPT.
+	[7a03042a70ea]
+
+2008-08-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c:
+	Include: variable indexes are now verified to the global variable
+	scope, meaning that a corrupt binary cannot allocate arbitrary
+	global variables anymore.
+	[d8b16b132509]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Removed obsoleted runtime_load() extension event.
+	[6f0b6cbd33c6]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-match-types.c:
+	Added run() event to the interpreter_extension object.
+	[878c2ad37f27]
+
+	* TODO:
+	Cleaned up TODO file.
+	[8ca8af945cec]
+
+	* TODO, doc/rfc/RFC Controversy.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags-common.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.c, src/lib-sieve/plugins/variables/ext-variables-
+	limits.h, src/lib-sieve/plugins/variables/ext-variables-name.c, src
+	/lib-sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/limits.sieve:
+	Variables: implemented limits on number of variables in a scope, the
+	length of variable names, size of variable values and the number of
+	accesible match values.
+	[f23512858a52]
+
+	* TODO, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/regex/mcht-
+	regex.c, src/lib-sieve/sieve-limits.h, src/lib-sieve/sieve-match-
+	types.c:
+	Limited number of accepted match values
+	[31520dab90b8]
+
+	* src/lib-sieve/plugins/include/ext-include-limits.h:
+	Include: forgot to add new file to the repository.
+	[32e7a10e0c4e]
+
+	* TODO:
+	Merged concurrent changes.
+	[9a691e80df72]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: limited the number of included scripts.
+	[f01020cfcebb]
+
+	* src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/bin-common.c:
+	LDA-Plugin: prevented plugin from polluting the logfiles when the
+	script does not exist.
+	[5d70ae722bca]
+
+2008-08-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/generic.sieve:
+	Include: used wrong messaging function in previous commit.
+	[177bf38926ca]
+
+	* src/lib-sieve/plugins/include/cmd-include.c:
+	Include: prohibited use of '/' in scriptnames.
+	[88105cf833da]
+
+2008-08-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, tests/extensions/body/basic.svtest:
+	Body: discovered various issues (listed in disabled tests).
+	[66543e00dfba]
+
+	* src/lib-sieve/sieve-message.c, src/lib-sieve/sieve-message.h,
+	src/testsuite/cmd-test-set.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite-objects.c,
+	src/testsuite/testsuite-objects.h,
+	tests/extensions/body/basic.svtest:
+	Body: added test regarding empty bodies and fixed testsuite to flush
+	the message context when the message is changed.
+	[c6c5a7eb8e6e]
+
+	* src/lib-sieve/plugins/body/tst-body.c,
+	tests/extensions/body/basic.svtest:
+	Body: fixed default comparator and added testsuite test to prevent
+	this in the future.
+	[83bd74561800]
+
+	* Makefile.am, src/lib-sieve/plugins/body/ext-body-common.c, src/lib-
+	sieve/plugins/body/tst-body.c, tests/extensions/body/basic.svtest:
+	Body: fixed bug in the :raw transform, added much comment to the
+	body extraction code and added a first simple test to the testsuite.
+	[3153995e2bc7]
+
+	* src/lib-sieve/sieve-lexer.c, src/testsuite/mail-raw.c:
+	Made the lexer conform to the new Sieve RFC.
+	[0fae7796f624]
+
+	* doc/rfc/body.rfc5173.txt, src/lib-sieve/plugins/body/draft-ietf-
+	sieve-body-07.txt, src/lib-sieve/plugins/body/ext-body.c:
+	Installed RFC for the body extension in the doc/rfc directory.
+	[42dc34bb2dc2]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/imapflags/ext-imapflags-
+	common.c, src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/relational/ext-
+	relational-common.c, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	src/lib-sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h, src/lib-sieve/tst-address.c:
+	Made sure error messages do not print large erroneous values.
+	[ea459c2b87c0]
+
+	* TODO, src/lib-sieve/sieve-parser.c, tests/compile/errors.svtest,
+	tests/compile/errors/parser.sieve:
+	Limited the depth of the AST and added tests to verify that it is
+	resolved gracefully.
+	[aa4d3069f079]
+
+2008-08-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-limits.h, src/lib-sieve/sieve-parser.c,
+	tests/compile/errors.svtest, tests/compile/errors/parser.sieve:
+	Limited number of command arguments.
+	[9a2fc3c9675d]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Made lexer use the (i_*) ctype.h functions.
+	[51d06f8b3339]
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-limits.h,
+	tests/compile/errors.svtest, tests/compile/errors/lexer.sieve:
+	Limited the length of identifiers.
+	[aaca552f0561]
+
+	* TODO, src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/sieve-address.c, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-limits.h,
+	src/lib-sieve/sieve-parser.c, tests/compile/errors.svtest,
+	tests/compile/errors/lexer.sieve:
+	Enforced limits on string length and handled the finite nature of
+	integers for number parsing and the construction of the AST.
+	[317c332b2623]
+
+2008-08-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c:
+	Include: fixed bug in global variables referencing the main script.
+	[b1c1779b1d4b]
+
+2008-08-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h,
+	tests/extensions/include/variables.svtest:
+	Include: symbol table for global variables now also includes
+	locations for the first import/export of each known variable.
+	[ba3785f991b9]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h:
+	Include: included scripts are now referenced by an include_id in
+	stead of the binary block id.
+	[b67c51062eba]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-validator.c:
+	Forgot to implement free() event for validator and interpreter
+	extensions.
+	[e1f834c53a3d]
+
+	* src/lib-sieve/plugins/include/cmd-import.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/sieve-ext-
+	variables.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve
+	/sieve-binary-dumper.h, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-generator.c, src/testsuite/ext-testsuite.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/import-runtime.sieve,
+	tests/extensions/include/errors/variables.sieve:
+	Include: added symbol table to the binary for global variables.
+	[d9518ecfeb23]
+
+	* README, TODO:
+	Updated documentation.
+	[54897b07b2da]
+
+2008-08-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Minor TODO file revisions.
+	[472b4c6dde9e]
+
+	* Makefile.am, tests/match-types/regex.svtest:
+	Testsuite: added match values test for the :regex match
+	[35384a182b33]
+
+	* TODO, src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/regex/mcht-regex.c, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h,
+	tests/extensions/variables/match.svtest, tests/match-
+	types/matches.svtest:
+	Fixed replacing match values only when a test succeeds.
+	[dd371558d0fb]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Upgraded validator and interpreter extension support to provide
+	destruction notifications.
+	[0ec7042e1ce5]
+
+2008-08-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Include: found one issue.
+	[37f5ac342261]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite.c,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/circular-1.sieve,
+	tests/extensions/include/errors/circular-2.sieve,
+	tests/extensions/include/errors/circular-3.sieve,
+	tests/extensions/include/errors/included/circular-one.sieve,
+	tests/extensions/include/errors/included/circular-three-2.sieve,
+	tests/extensions/include/errors/included/circular-three-3.sieve,
+	tests/extensions/include/errors/included/circular-three.sieve,
+	tests/extensions/include/errors/included/circular-two-2.sieve,
+	tests/extensions/include/errors/included/circular-two.sieve,
+	tests/extensions/include/included/variables-included1.sieve,
+	tests/extensions/include/included/variables-included2.sieve,
+	tests/extensions/include/included/variables-included3.sieve,
+	tests/extensions/include/variables-included1.sieve,
+	tests/extensions/include/variables-included2.sieve,
+	tests/extensions/include/variables-included3.sieve:
+	Testsuite: added circular include tests.
+	[bfa2fb869c31]
+
+	* doc/rfc/draft-daboo-sieve-include-05.txt, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/draft-daboo-sieve-include-05.txt, src/lib-sieve/plugins/include
+	/include-error.sieve, src/lib-sieve/plugins/include/include-
+	variables.sieve, src/lib-sieve/plugins/include/include-
+	variables1.sieve, src/lib-sieve/plugins/include/include-
+	variables2.sieve, src/lib-sieve/plugins/include/include-
+	variables3.sieve, src/lib-sieve/plugins/include/include.sieve, src
+	/lib-sieve/plugins/include/included1.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve,
+	tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/generic.sieve:
+	Include: cleaned up source directory.
+	[525f4e7bd2ce]
+
+	* Makefile.am, src/lib-sieve/plugins/include/include-variables-
+	error.sieve, src/lib-sieve/plugins/include/include-variables-
+	error2.sieve, tests/extensions/include/errors.svtest,
+	tests/extensions/include/errors/variables-inactive.sieve,
+	tests/extensions/include/errors/variables.sieve:
+	Testsuite: added compile error tests for the include extension.
+	[7efaba3fb362]
+
+	* src/lib-sieve/plugins/copy/rfc3894.txt:
+	Copy: forgot to remove RFC from old location.
+	[4cd77c6931ad]
+
+	* doc/rfc/copy.rfc3894.txt:
+	Copy: moved RFC to doc/rfc directory.
+	[04dd13d1e194]
+
+	* doc/rfc/imap4flags.rfc5232.txt, src/lib-sieve/plugins/imapflags
+	/draft-ietf-sieve-imapflags-05.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c:
+	Imapflags: updated specification to RFC 5232.
+	[f1f8c50c2d7e]
+
+	* TODO:
+	Imapflags: found one new issue.
+	[9f896bff4250]
+
+	* Makefile.am, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-generator.c, tests/extensions/imapflags/hasflag.svtest,
+	tests/extensions/imapflags/rfc.svtest:
+	Imapflags: accidentally omitted support for multiple variables in
+	the hasflag test.
+	[b6602e8dd433]
+
+	* TODO, tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/set.sieve,
+	tests/extensions/variables/string.svtest:
+	Testsuite: added new tests for the variables extension.
+	[ff3d19af6da3]
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-validator.c,
+	tests/compile/trivial.sieve,
+	tests/extensions/variables/errors.svtest:
+	Fixed various case-sensitivily-related issues.
+	[8d140a08e7d8]
+
+	* Makefile.am, src/lib-sieve/plugins/variables/ext-variables-
+	arguments.c, tests/extensions/variables/errors.svtest,
+	tests/extensions/variables/errors/namespace.sieve,
+	tests/extensions/variables/errors/set.sieve:
+	Variables: fixed various error handling issues.
+	[eb93d4e65fce]
+
+	* src/lib-sieve/sieve-address.c:
+	Fixed a warning.
+	[5e651fda205f]
+
+2008-08-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/ext-variables.c:
+	Fixed 'make dist' to produce a working tarball.
+	[39a595dbbde4]
+
+	* src/lib-sieve/mcht-matches.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, tests/match-
+	types/contains.svtest, tests/match-types/is.svtest, tests/match-
+	types/matches.svtest, tests/match-types/relational.svtest:
+	Testsuite: added test regarding matching the empty string and fixed
+	an issue in the i;ascii-numeric comparator.
+	[4817eca9348a]
+
+	* Makefile.am, TODO, src/lib-sieve/mcht-contains.c, src/lib-sieve
+	/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/plugins/relational
+	/mcht-count.c, src/lib-sieve/plugins/relational/mcht-value.c, src
+	/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	match-types.h, src/lib-sieve/sieve-match.c,
+	tests/extensions/variables/string.svtest:
+	Variables: fixed :count issue for the string test.
+	[fc0444f14dd1]
+
+	* TODO, tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/modifiers.svtest,
+	tests/extensions/variables/string.svtest:
+	Testsuite: added more tests for the variables extension and found
+	one issue.
+	[cd218e005c1e]
+
+	* Makefile.am, src/lib-sieve/ext-envelope.c, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/match.svtest,
+	tests/extensions/variables/modifiers.svtest, tests/match-
+	types/contains.svtest:
+	Testsuite: added RFC compliance tests for the variables extension
+	and fixed use of wrong default comparator.
+	[2246d563ad2d]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-validator.c, tests/extensions/variables/quoting.svtest:
+	Fixed bug in the order of default argument processing. Variable
+	strings were evaluated befor constant strings, which is wrong.
+	[6fa43c9bac62]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address.c,
+	tests/extensions/envelope.svtest:
+	Envelope: added more test and fixed source route parsing.
+	[568d3af73d04]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address.c,
+	tests/extensions/envelope.svtest:
+	Envelope: fixed one bug in the path parsing (printfs active).
+	[fbae4e8724ad]
+
+2008-07-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, doc/rfc/RFC Controversy.txt, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h, src/lib-sieve
+	/sieve-common.h, tests/extensions/envelope.svtest,
+	tests/testsuite.svtest:
+	Envelope: working towards proper RFC compliance of forward/return-
+	path parsing.
+	[0d6138082c33]
+
+2008-07-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed RFC compliance issue regarding failing validation
+	on unknown namespaces.
+	[336904483e84]
+
+	* src/lib-sieve/plugins/variables/ext-variables-arguments.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed bug in variables substitution (RFC example failed
+	during testing).
+	[ccbfb44d427c]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c,
+	tests/extensions/variables/basic.svtest:
+	Variables: fixed very significant bug in the variable scope
+	implementation.
+	[225f7cfd99c0]
+
+	* src/lib-sieve/sieve-binary.h:
+	Removed superfluous include.
+	[29e9b491cadf]
+
+	* tests/extensions/variables/basic.svtest:
+	Testsuite: cleaned up basic varibles test case.
+	[b8ac459bccec]
+
+	* Makefile.am, configure.in, src/testsuite/Makefile.am,
+	src/testsuite/tests/address-parts/subaddress.svtest,
+	src/testsuite/tests/comparators/core.svtest,
+	src/testsuite/tests/compile/compile-examples.svtest,
+	src/testsuite/tests/compile/compile.svtest,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address-part.sieve,
+	src/testsuite/tests/compile/errors/address.sieve,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/compile/errors/envelope.sieve,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/compile/errors/if.sieve,
+	src/testsuite/tests/compile/errors/keep.sieve,
+	src/testsuite/tests/compile/errors/require.sieve,
+	src/testsuite/tests/compile/errors/size.sieve,
+	src/testsuite/tests/compile/errors/stop.sieve,
+	src/testsuite/tests/compile/redirect.sieve,
+	src/testsuite/tests/compile/trivial.sieve, src/testsuite/tests
+	/control-structures.svtest, src/testsuite/tests/exists.svtest,
+	src/testsuite/tests/extensions/encoded-character.svtest,
+	src/testsuite/tests/extensions/envelope.svtest,
+	src/testsuite/tests/extensions/imapflags/basic.svtest,
+	src/testsuite/tests/extensions/imapflags/rfc.svtest,
+	src/testsuite/tests/extensions/include/variables-included1.sieve,
+	src/testsuite/tests/extensions/include/variables-included2.sieve,
+	src/testsuite/tests/extensions/include/variables-included3.sieve,
+	src/testsuite/tests/extensions/include/variables.svtest,
+	src/testsuite/tests/extensions/variables/basic.svtest,
+	src/testsuite/tests/extensions/variables/match.svtest,
+	src/testsuite/tests/header.svtest, src/testsuite/tests/lexer.svtest,
+	src/testsuite/tests/match-types/contains.svtest, src/testsuite/tests
+	/match-types/is.svtest, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/tests/match-
+	types/relational.svtest, src/testsuite/tests/testsuite.svtest, tests
+	/address-parts/subaddress.svtest, tests/comparators/core.svtest,
+	tests/compile/compile-examples.svtest, tests/compile/compile.svtest,
+	tests/compile/errors.svtest, tests/compile/errors/address-
+	part.sieve, tests/compile/errors/address.sieve, tests/compile/errors
+	/encoded-character.sieve, tests/compile/errors/envelope.sieve,
+	tests/compile/errors/header.sieve, tests/compile/errors/if.sieve,
+	tests/compile/errors/keep.sieve, tests/compile/errors/require.sieve,
+	tests/compile/errors/size.sieve, tests/compile/errors/stop.sieve,
+	tests/compile/redirect.sieve, tests/compile/trivial.sieve, tests
+	/control-structures.svtest, tests/exists.svtest, tests/extensions
+	/encoded-character.svtest, tests/extensions/envelope.svtest,
+	tests/extensions/imapflags/basic.svtest,
+	tests/extensions/imapflags/rfc.svtest, tests/extensions/include
+	/variables-included1.sieve, tests/extensions/include/variables-
+	included2.sieve, tests/extensions/include/variables-included3.sieve,
+	tests/extensions/include/variables.svtest,
+	tests/extensions/variables/basic.svtest,
+	tests/extensions/variables/match.svtest, tests/header.svtest,
+	tests/lexer.svtest, tests/match-types/contains.svtest, tests/match-
+	types/is.svtest, tests/match-types/matches.svtest, tests/match-
+	types/relational.svtest, tests/testsuite.svtest:
+	Testsuite: moved tests directory to the root of the package.
+	[bbd0d8bab632]
+
+	* doc/rfc/variables.rfc5229.txt, src/lib-
+	sieve/plugins/variables/rfc5229.txt:
+	Installed variables rfc in the doc/rfc directory.
+	[785a600fb225]
+
+	* TODO, src/lib-sieve/ext-encoded-character.c,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/extensions/encoded-character.svtest:
+	Encoded-character: resolved error reporting issue, added some syntax
+	error tests and fixed some parsing bugs in the process.
+	[9dd5079adbbe]
+
+	* TODO, src/lib-sieve/ext-encoded-character.c,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address-part.sieve,
+	src/testsuite/tests/compile/errors/encoded-character.sieve,
+	src/testsuite/tests/compile/errors/envelope.sieve,
+	src/testsuite/tests/compile/errors/keep.sieve,
+	src/testsuite/tests/compile/errors/size.sieve,
+	src/testsuite/tests/compile/errors/stop.sieve, src/testsuite/tests
+	/control-structures.svtest:
+	Testsuite: added compile error testcases and discovered one new
+	issue.
+	[1bf8cc2f7f10]
+
+	* TODO:
+	Reprioritized TODO file.
+	[1342d7920181]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Variables: resolved issues in the scope implementation.
+	[a3bcc26814b1]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Added proper extension support to AST object.
+	[031f0a483697]
+
+2008-07-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-
+	sieve/sieve-validator.c, src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/address.sieve,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/compile/errors/if.sieve,
+	src/testsuite/tests/compile/errors/require.sieve, src/testsuite
+	/testsuite-common.c:
+	Testsuite: added a few more compile error test cases.
+	[658fa458abd4]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/testsuite/Makefile.am,
+	src/testsuite/tests/compile/errors.svtest,
+	src/testsuite/tests/compile/errors/header.sieve,
+	src/testsuite/tests/errors.svtest, src/testsuite/tests/header-
+	errors.sieve, src/testsuite/testsuite-common.c, src/testsuite
+	/testsuite-common.h, src/testsuite/testsuite.c, src/testsuite/tst-
+	test-compile.c, src/testsuite/tst-test-error.c:
+	Testsuite: completed support for error validation and added one test
+	case.
+	[b7ae709ef86e]
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/errors.svtest, src/testsuite/tests/header-
+	errors.sieve, src/testsuite/testsuite-common.h, src/testsuite/tst-
+	test-compile.c, src/testsuite/tst-test-error.c:
+	Testsuite: started support for error validation.
+	[bef773d65f77]
+
+	* TODO, src/testsuite/Makefile.am, src/testsuite/tests/match-
+	types/contains.svtest, src/testsuite/tests/match-types/is.svtest:
+	Testsuite: marginally improved match-type tests.
+	[444696f0d147]
+
+	* src/testsuite/Makefile.am:
+	Added variables testcase to the testsuite.
+	[2030448d3cd4]
+
+	* src/lib-sieve/mcht-matches.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h,
+	src/testsuite/tests/extensions/variables/match.svtest,
+	src/testsuite/tests/lexer.svtest, src/testsuite/tests/match-
+	types/matches.svtest:
+	Fixed bugs in the :matches match type.
+	[6305d80a9f22]
+
+	* src/lib-sieve/ext-encoded-character.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/encoded-character.svtest:
+	Encoded-character: fixed a few bugs to properly match the examples
+	provided in the RFC.
+	[a320882164ec]
+
+2008-07-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/tst-header.c:
+	Added stripping of right white space from header content.
+	[9a21206c0260]
+
+	* TODO:
+	Updated TODO
+	[8ec5db20d93b]
+
+	* src/testsuite/tests/extensions/envelope.svtest:
+	Envelope: forgot to add new test case.
+	[ce3a837f69f0]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/testsuite/Makefile.am:
+	Envelope: <> return path now always matches as the empty string,
+	regardless of the specified address part.
+	[270b07d72782]
+
+	* TODO:
+	Minor TODO file change.
+	[9ba44410e26e]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/tst-address.c:
+	Forgot to adjust comment.
+	[3560a09d215a]
+
+	* doc/rfc/RFC Controversy.txt:
+	Updated documentation.
+	[20da4decbf18]
+
+	* TODO, doc/rfc/RFC Controversy.txt, sieve/errors/envelope-
+	errors.sieve, sieve/examples/elvey.sieve, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h,
+	src/lib-sieve/tst-address.c:
+	Envelope: added compile-time envelope-part verification.
+	[9a5d8cd44c16]
+
+	* doc/rfc/RFC Controversy.txt:
+	Added RFC controversy file to log all matters that require
+	clarification from RFC editors.
+	[eaa9516bda0a]
+
+	* TODO:
+	Restricted allowable headers for the address test.
+	[b7212151acde]
+
+	* TODO, sieve/errors/address-errors.sieve, src/lib-sieve/tst-
+	address.c, src/testsuite/tests/extensions/imapflags/rfc.svtest:
+	Imapflags: forgot to add testcase file.
+	[afe2b84e7719]
+
+	* src/lib-sieve/sieve-match.c:
+	Disallowed extraction of key elements from key strings for match
+	types for with that would not make sense.
+	[ba9fe4253d74]
+
+	* TODO, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src
+	/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Imapflags: resolved problem of hasflags encountering duplicate flags
+	in flag lists contained in a variable.
+	[df6023e12048]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/lib-sieve/mcht-contains.c,
+	src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/tst-
+	hasflag.c, src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-match-
+	types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-match.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c,
+	src/testsuite/Makefile.am,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Imapflags: resolved string representation issue in hasflag.
+	[9261c0d19ce3]
+
+	* TODO, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-match.c,
+	src/lib-sieve/sieve-match.h, src/lib-sieve/tst-header.c,
+	src/testsuite/tests/extensions/imapflags/basic.svtest:
+	Resolved code duplication among commands that use comparators and
+	match-types and found problems in the imapflags extension in the
+	process.
+	[662b8d662c89]
+
+2008-07-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	LDA-Sieve plugin: forgot to save the new binary when encountered a
+	corrupt one.
+	[d42d299f470b]
+
+	* TODO, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Improved the handling corrupt binaries further for the action
+	commands.
+	[fd1d663f3b2c]
+
+2008-07-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/Makefile.am, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/mcht-contains.c, src/lib-sieve/mcht-is.c, src/lib-sieve
+	/mcht-matches.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.h, src/lib-sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-
+	match-types.h, src/lib-sieve/sieve-match.c, src/lib-sieve/sieve-
+	match.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c,
+	src/sieve-bin/sieve-test.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/control-structures.svtest, src/testsuite/tests
+	/match-types/relational.svtest, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Significantly improved handling of old/corrupt binaries and revised
+	matching implementation in the process.
+	[07f6bc2fe04b]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c:
+	Fixed extremely stupid bug in the i;ascii-numeric comparator.
+	[f7df94b061ec]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-interpreter.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c:
+	Implemented graceful handling of corrupt binaries by the sieve lda
+	plugin.
+	[c300bab057a2]
+
+	* configure.in:
+	Properly configured package name.
+	[dfe8a1ecad3c]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	types.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src/sieve-bin
+	/sieve-exec.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-
+	test-set.c, src/testsuite/cmd-test.c, src/testsuite/tst-test-
+	compile.c:
+	Working towards improving the handling of currupt binaries: defined
+	multiple exit codes for execution functions and defined trace macro
+	for reporting binary corruptions.
+	[10c30a4bd44a]
+
+	* TODO, src/testsuite/tests/extensions/include/variables-
+	included1.sieve, src/testsuite/tests/extensions/include/variables-
+	included2.sieve, src/testsuite/tests/extensions/include/variables-
+	included3.sieve,
+	src/testsuite/tests/extensions/include/variables.svtest:
+	Testsuite: forgot to add test cases for include extension.
+	[e3542907a783]
+
+	* TODO, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-sieve
+	/sieve-script.c, src/lib-sieve/sieve-script.h,
+	src/testsuite/Makefile.am, src/testsuite/testsuite.c:
+	Fixed code emission for extension-defined variables and removed
+	hardcoded paths from include extension.
+	[c3dfcab426ca]
+
+	* TODO:
+	Added future TODO item.
+	[defad0db1bb4]
+
+	* TODO, src/lib-sieve/sieve-interpreter.h:
+	Updated TODO and removed spurious FIXME.
+	[477722eeaf09]
+
+	* README, src/testsuite/ext-testsuite.c:
+	Updated documentation.
+	[89e50989541a]
+
+	* .hgignore, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/tests/compile/compile-
+	examples.svtest, src/testsuite/tests/compile/compile.svtest,
+	src/testsuite/tests/compile/redirect.sieve,
+	src/testsuite/tests/compile/trivial.sieve, src/testsuite/testsuite-
+	common.h, src/testsuite/tst-test-compile.c:
+	Testsuite: added test_compile command to test compilation of
+	scripts.
+	[e6846fc1dc11]
+
+2008-07-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, sieve/errors/out-address-errors.sieve, src/lib-sieve/sieve-
+	address.c, src/lib-sieve/sieve-binary.c:
+	Revised Sieve address validation functionality.
+	[10abb0055a23]
+
+	* README, TODO, configure.in, src/lib-sieve/sieve-binary.c:
+	Started using new str_new_const() function.
+	[3fc4deedc23b]
+
+	* TODO, src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/imapflags
+	/cmd-addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c,
+	src/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	result.c, src/lib-sieve/sieve-result.h:
+	Imapflags: improved handling of invalid flags.
+	[4d45ccdd880b]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	validator.c:
+	Significantly improved pool allocation by checking --enable-debug
+	warnings from dovecot.
+	[4a5f60764e5f]
+
+	* src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-validator.c:
+	Removed all legacy use of array_create().
+	[f4bb043dc649]
+
+	* src/lib-sieve/sieve-lexer.c:
+	Lexer: fixed repetitive string alloation problem.
+	[14dd750dfeb8]
+
+2008-07-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed bug introduced by previous change.
+	[e4db63d3e106]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/variables/cmd-
+	set.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-common.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-match-types.c, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-objects.c:
+	Reworked operand and operation binary coding functions.
+	[a8f9c4a6c502]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.h, src/lib-sieve/plugins/variables/ext-variables-
+	operands.c, src/lib-sieve/plugins/variables/sieve-ext-variables.h,
+	src/lib-sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	address-parts.h, src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/sieve-message.c, src/lib-sieve/sieve-message.h, src/lib-sieve
+	/sieve-objects.c, src/lib-sieve/sieve-objects.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src
+	/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve
+	/tst-size.c, src/testsuite/cmd-test-fail.c, src/testsuite/cmd-test-
+	set.c, src/testsuite/cmd-test.c, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Fully substituted the use of extension ids with the use of the
+	extension object itself.
+	[0da758d61cad]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/plugins/subaddress/ext-
+	subaddress.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-validator.c, src/testsuite/ext-testsuite.c:
+	Made initially assigned extension id available directly from the
+	const extension object itself.
+	[3e237d753a2a]
+
+	* TODO, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Reworked previous change into three elegant macros.
+	[416c6954b998]
+
+2008-07-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-script.c, src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made utility functions for neatly handing system errors, warnings
+	and notices.
+	[8a116201d954]
+
+	* src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c,
+	src/testsuite/tests/control-structures.svtest:
+	Testsuite: added tests for use of allof/anyof with a single test and
+	optimized code generation.
+	[971a8a94e8ab]
+
+	* TODO, src/testsuite/tests/header.svtest, src/testsuite/tests/match-
+	types/contains.svtest:
+	Testsuite: added test case for the header test and found one issue.
+	[447d40a17ea0]
+
+	* src/lib-sieve/sieve-lexer.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/lexer.svtest:
+	Testsuite: added lexer string scan comparison test and fixed lexer
+	bug in the process.
+	[1bab36c85b54]
+
+2008-07-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/testsuite/tests/control-structures.svtest:
+	Testsuite: added some control structure tests involving nesting.
+	[46a2df6cafe4]
+
+	* TODO, src/lib-sieve/tst-exists.c, src/testsuite/Makefile.am,
+	src/testsuite/tests/exists.svtest, src/testsuite/testsuite-
+	objects.c:
+	Testsuite: added tests for 'exists' test and fixed a semantic error
+	in the 'exists' test.
+	[ce5660cb5dbf]
+
+	* TODO, src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address-
+	parts.c, src/testsuite/tests/testsuite.svtest, src/testsuite
+	/testsuite-objects.c:
+	Testsuite: tested handling of teststuite envelope environment and
+	fixed bugs in the envelope test in the process.
+	[ff0f9c67a106]
+
+	* src/testsuite/Makefile.am, src/testsuite/tests/address-
+	parts/subaddress.svtest, src/testsuite/testsuite-common.c:
+	Testsuite: added test case for subadress extension.
+	[21061d5f3422]
+
+	* Makefile.am, TODO, configure.in, src/Makefile.am,
+	src/testsuite/Makefile.am, src/testsuite/tests/testsuite.svtest,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	Coupled testsuite to 'make test'.
+	[36ab72963cd1]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/cmd-if.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-encoded-character.c,
+	src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c:
+	Cleaned up test and core extension implementations.
+	[5df6769ad854]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c:
+	Cleaned up command implementations.
+	[837769563332]
+
+	* src/lib-sieve/sieve-script-private.h, src/lib-sieve/sieve-script.c:
+	Fixed handling of script files that are in fact symbolic links.
+	[fd9003533d28]
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed bug in binary created without a corresponding script object.
+	[9560bfd8e2e5]
+
+	* TODO, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-error.c, src
+	/lib-sieve/sieve-error.h, src/lib-sieve/sieve-script.c:
+	Reversed stat() and open() on two occasions to make retrieved stat
+	information guaranteed to be valid for the opened file and added
+	error handling for various close() system calls.
+	[b04c29c4ac90]
+
+	* TODO:
+	Updated TODO list.
+	[bab521877ded]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-modifiers.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c:
+	Removed various unnecessary includes of <ctype.h> and replaced yey
+	another toupper() with its i_* equivalent.
+	[2e1963c29390]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/variables/ext-variables-name.c:
+	Removed direct use of isdigit, isalpha and isalnum and replaced
+	these with their dovecot i_* equivalents to prevent problems on some
+	systems.
+	[732c5001ccb5]
+
+	* TODO:
+	Updated TODO.
+	[47c0a9d219b6]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.c, src/lib-sieve/plugins/variables/ext-variables-
+	modifiers.h, src/lib-sieve/plugins/variables/ext-variables.c, src
+	/lib-sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/variables-match.sieve,
+	src/testsuite/tests/extensions/variables/basic.svtest:
+	Variables: made set modifiers descendants of the sieve object too.
+	[6c31299662d8]
+
+2008-07-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-objects.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Testsuite: made testsuite objects a descendant from sieve objects.
+	[12a346d25711]
+
+	* TODO, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h:
+	Removed remaining code duplication among comparators, match types
+	and address parts.
+	[1654a241fa56]
+
+	* TODO:
+	Updated TODO list.
+	[8292d75ce253]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.h,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-
+	sieve/sieve-comparators.h, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/sieve-objects.c, src/lib-sieve/sieve-objects.h:
+	Made side effects sieve objects too.
+	[81b6c6a65f86]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/mcht-contains.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/regex/ext-regex-common.c, src/lib-
+	sieve/plugins/regex/mcht-regex.c, src/lib-sieve/plugins/relational
+	/ext-relational-common.c, src/lib-sieve/plugins/relational/mcht-
+	count.c, src/lib-sieve/plugins/relational/mcht-value.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h, src/lib-sieve/sieve-objects.c, src/lib-
+	sieve/sieve-objects.h:
+	Introduced the concept of a sieve object to merge the coding of
+	comparators, match types, address parts and other objects that might
+	need to be represented in byte code (removes lots of code
+	duplication).
+	[344eaae8693c]
+
+2008-07-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/cmp-i-octet.c, src/lib-sieve/mcht-contains.c,
+	src/lib-sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-sieve/plugins/regex/ext-
+	regex-common.c, src/lib-sieve/plugins/regex/ext-regex-common.h, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/mcht-regex.c, src/lib-sieve/plugins/relational/ext-relational-
+	common.c, src/lib-sieve/plugins/relational/ext-relational-common.h,
+	src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Revised extension support for match-types.
+	[a6bf1b1c8a2b]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmp-i-ascii-casemap.c, src
+	/lib-sieve/cmp-i-octet.c, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-comparators.h:
+	Cleaned up comparator implementation.
+	[8976941d215c]
+
+	* TODO, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/testsuite/tests/comparators/core.svtest:
+	Revised extension support for comparators.
+	[29676b9e16c2]
+
+2008-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-comparators.c:
+	Fixed stupid bug in the match-type context validation.
+	[e67e5024a970]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-lexer.c,
+	src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve-script-private.h, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-types.h, src/lib-sieve/sieve.h:
+	Made error reporting cleaner by avoiding the scriptname of the main
+	script and indicating that the printed numbers are in fact source
+	code lines.
+	[2c5ae7a67d28]
+
+	* src/lib-sieve/sieve-validator.h:
+	Fixed warnings caused by remaining spurious inline definitions in
+	sieve-validator.h
+	[bfc24ba04381]
+
+2008-07-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-
+	sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c:
+	Code cleanup: parser, lexer, lda-plugin and main interface.
+	[d5ca488d55b7]
+
+	* TODO:
+	Updated TODO.
+	[c44e8d20b130]
+
+2008-07-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL:
+	Update INSTALL file.
+	[c0acf033f79d]
+
+	* README, TODO:
+	Updated documentation.
+	[3f2415b96676]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/cmd-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h:
+	Made runtime errors for action conflicts more user-friendly by
+	adding sourcecode line numbers.
+	[5dfc5676bd6f]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-
+	require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/tst-body.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/tst-
+	string.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-generator.c, src
+	/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c, src/testsuite/cmd-
+	test-fail.c, src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/testsuite-objects.c:
+	Cleaned up generator code and added emission of source line
+	positions for all actions.
+	[d60e232af73e]
+
+2008-07-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, sieve/tests/stop.sieve, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve/sieve-parser.c:
+	Resolved various small issues.
+	[dd844326cd20]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin
+	/sieve-test.c, src/testsuite/testsuite.c:
+	Removed last significant printf()s from library code.
+	[663bb4cf98d8]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-encoded-character.c, src/lib-sieve/plugins/copy/ext-
+	copy.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src/lib-sieve
+	/sieve-address.c, src/lib-sieve/sieve-address.h, src/lib-sieve
+	/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-
+	result.c:
+	Added address normalization to prevent redirect action duplicates.
+	[41e894bd5adb]
+
+	* src/lib-sieve/sieve-actions.c:
+	Made "INBOX" folder name case-insensitive.
+	[ad20dac29faf]
+
+	* TODO, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-redirect.c, src
+	/lib-sieve/ext-reject.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/imapflags/imapflags-implicit.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-common.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/sieve-test.c,
+	src/testsuite/testsuite.c:
+	Built result print functions thus removing various printf()s.
+	[ab0569f04717]
+
+	* TODO, src/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve
+	/sieve-result.c, src/sieve-bin/sieve-exec.c:
+	Removed various printf()s.
+	[8b83101ed51a]
+
+	* README, TODO, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-result.c:
+	Implemented support for side-effects to implicit keep and finished
+	the imapflags extension.
+	[c0b959cfdf01]
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/testsuite/ext-testsuite.c:
+	Previous change in extension interface for implicit side effect
+	support broke include extension.
+	[4cb32478d80d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-redirect.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body-common.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c,
+	src/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-sieve/plugins/vacation
+	/cmd-vacation.c, src/lib-sieve/plugins/variables/ext-variables.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-common.h, src/lib-sieve/sieve-extensions.c, src
+	/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-message.c,
+	src/lib-sieve/sieve-message.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h:
+	Added support for implicit side effects and adjusted imapflags
+	extension accordingly.
+	[f55d47d1daee]
+
+2008-07-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve
+	/sieve-actions.c, src/lib-sieve/sieve-actions.h:
+	Imapflags: flags are stored for explicit actions.
+	[9fa69efd67d1]
+
+2008-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c:
+	Imapflags: cleaned up some debug messages and fixed triggered
+	assertion.
+	[ebdd1e5333ca]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c:
+	Forgot a few trace macros.
+	[4f32214d959c]
+
+	* TODO:
+	Updated TODO list.
+	[9d16b8207a91]
+
+	* src/lib-sieve/sieve-actions.c:
+	Fixed typos in some error messages.
+	[584e2516320d]
+
+	* sieve/errors/out-address-errors.sieve, src/lib-sieve/Makefile.am,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	address.h, src/lib-sieve/sieve-validator-address.c, src/lib-sieve
+	/sieve-validator.h:
+	Improved address validation significantly.
+	[3d2a4f000814]
+
+	* src/testsuite/tests/control-structures.svtest, src/testsuite/tests
+	/match-types/contains.svtest:
+	Added two simple test cases.
+	[8354f6045c96]
+
+	* src/lib-sieve/sieve-commands.c:
+	Forgot trace macro for the stop command.
+	[2affc8a239aa]
+
+	* TODO:
+	Removed llist TODO item, turns out to be less mergeable than
+	initially thought.
+	[e324d382f62b]
+
+2008-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/tests/match-types/matches.svtest:
+	Testsuite: extended :matches tests.
+	[3cc1f848aa72]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/plugins/body/tst-body.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/tst-string.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c,
+	src/lib-sieve/tst-size.c, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test-set.c, src/testsuite/cmd-test.c,
+	src/testsuite/ext-testsuite.c, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/testsuite-common.c,
+	src/testsuite/testsuite-common.h, src/testsuite/testsuite.c:
+	Introduced trace macro for runtime tracing and improved testsuite
+	implementation.
+	[d4206ad35724]
+
+	* src/lib-sieve/mcht-matches.c, src/testsuite/mail-raw.c,
+	src/testsuite/tests/match-types/matches.svtest:
+	Testsuite: fixed CRLF bug in reading a script-specified mail
+	message.
+	[65bedbabab62]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/tst-header.c, src/testsuite/tests/match-types/matches.svtest:
+	Fixed bugs in :matches implementation.
+	[ded9f063bb3b]
+
+2008-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-generator.c, src/testsuite/tests/match-
+	types/matches.svtest, src/testsuite/tests/testsuite.sieve,
+	src/testsuite/tests/testsuite.svtest:
+	Added testcase to the testsuite.
+	[901e88d94ef2]
+
+	* README, src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/variables
+	/ext-variables.c:
+	Updated documentation.
+	[fe8d65b77b9d]
+
+	* TODO:
+	Updated TODO.
+	[e591cfdaaab9]
+
+	* TODO, src/lib-sieve/sieve-error-private.h, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-parser.c,
+	src/lib-sieve/sieve-validator.c, src/plugins/lda-sieve/lda-sieve-
+	plugin.c, src/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c,
+	src/sieve-bin/sieve-test.c, src/testsuite/testsuite.c:
+	Added support for limits on the maximum number of errors collected
+	during compilation.
+	[16066e307609]
+
+	* README, TODO:
+	Updated documentation.
+	[4282b0a65c30]
+
+	* sieve/errors/out-address-errors.sieve, src/lib-sieve/Makefile.am,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/plugins/vacation/cmd-
+	vacation.c, src/lib-sieve/sieve-address.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-validator-address.c, src/lib-sieve
+	/sieve-validator.h:
+	Added compile-time address validation.
+	[d977d476923d]
+
+	* doc/rfc/imail.rfc2822.txt:
+	Added IMAIL rfc.
+	[252d826d42e3]
+
+	* doc/rfc/draft-ietf-sieve-3028bis-13.txt, doc/rfc/rfc3028.txt,
+	doc/rfc/rfc3629.txt, doc/rfc/sieve.rfc5228.txt,
+	doc/rfc/utf-8.rfc3629.txt:
+	Updated doc/rfc directory.
+	[c045f8d8aaf8]
+
+	* README, TODO:
+	Updated documentation.
+	[85aee022d63b]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/plugins/imapflags/tag-
+	flags.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-extensions-private.h:
+	Imapflags: finished for implicit flag attachment to fileinto and
+	keep commands.
+	[b9d8f9649bde]
+
+2008-06-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/copy/ext-
+	copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src
+	/lib-sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/vacation/cmd-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-ast.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-size.c, src/testsuite/testsuite-
+	objects.c:
+	Added the concept of persistent tags and implemented imapflags
+	extension for bare keep and fileinto commands (intermittent commit,
+	not working properly yet).
+	[b941171d7557]
+
+2008-06-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Imapflags: added execution support for variables.
+	[3115627a9c60]
+
+	* src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-variables.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-arguments.c, src/lib-sieve/plugins/variables/ext-
+	variables-arguments.h, src/lib-sieve/plugins/variables/ext-
+	variables-operands.c, src/lib-sieve/plugins/variables/ext-variables-
+	operands.h, src/lib-sieve/plugins/variables/sieve-ext-variables.h,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Imapflags: added validation and code support for variables.
+	[eebce2c24704]
+
+2008-06-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sieve/plugins/vacation/vacation.sieve, src/lib-sieve
+	/sieve-validator.c:
+	Fixed bug in duplicate argument detection.
+	[9a8045ad9897]
+
+	* src/lib-sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/vacation/cmd-vacation.c, src/lib-
+	sieve/plugins/vacation/ext-vacation-common.h, src/lib-
+	sieve/plugins/vacation/ext-vacation.c:
+	Vacation: exported command implementation to separate file.
+	[c0d69bd47692]
+
+	* src/lib-sieve/sieve-binary.c, src/sieve-bin/sieved.c:
+	Fixed bug in sieved.
+	[0cf9a6ab85d6]
+
+	* INSTALL, README, configure.in, src/sieve-bin/Makefile.am:
+	Minor compile and documentation changes.
+	[5d55a9fb061d]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Made lda sieve plugin save and load binaries.
+	[98a4a28d48d3]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-generator.c,
+	src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-lexer.c, src
+	/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve-result.h, src/lib-sieve/sieve-script.c, src/lib-sieve
+	/sieve-script.h, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/sieve-validator.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h,
+	src/sieve-bin/sievec.c, src/testsuite/cmd-test.c, src/testsuite
+	/testsuite-common.c:
+	Resolved all outstanding warnings.
+	[61acd01fe9df]
+
+	* DESIGN, INSTALL, Makefile.am, README, TODO, src/lib-
+	sieve/Makefile.am, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/Makefile.am, src/lib-
+	sieve/plugins/copy/Makefile.am, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/ext-imapflags-common.c, src/lib-sieve/plugins/include/Makefile.am,
+	src/lib-sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am:
+	Updated documentation and fixed 'make dist'.
+	[65c7b117ff36]
+
+2008-05-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h,
+	src/testsuite/Makefile.am, src/testsuite/cmd-test-fail.c,
+	src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h:
+	Testsuite: added test_fail command.
+	[063d37ff4c79]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/tst-allof.c, src/lib-sieve
+	/tst-anyof.c, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	set.c, src/testsuite/cmd-test.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.h, src/testsuite/testsuite-objects.c:
+	Testsuite: added 'test' command to group sieve statements into a
+	test.
+	[3cc05036846c]
+
+2008-05-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/cmd-test-set.c, src/testsuite/ext-testsuite.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite-
+	common.c, src/testsuite/testsuite-common.h, src/testsuite/testsuite-
+	objects.c, src/testsuite/testsuite-objects.h:
+	Testsuite: added support for test object members.
+	[62f783ff9f22]
+
+2008-05-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/testsuite/Makefile.am, src/testsuite/cmd-test-set.c,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite-objects.c, src/testsuite/testsuite-
+	objects.h:
+	Testsuite: exported testsuit object interface to separate files.
+	[e26637dce509]
+
+	* src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-extensions-
+	private.h, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	message.c, src/testsuite/cmd-test-set.c, src/testsuite/ext-
+	testsuite.c, src/testsuite/tests/testsuite.sieve, src/testsuite
+	/testsuite-common.c, src/testsuite/testsuite-common.h:
+	Testsuite: implemented testsuite object interface.
+	[3e39d288a27f]
+
+2008-05-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/vacation/vacation-errors.sieve:
+	vacation: added TODO regarding duplicate tagged arguments to the
+	vacation command.
+	[62ced79fac8a]
+
+	* .hgignore, src/testsuite/testsuite:
+	testsuite: removed spurious binary from repository.
+	[058401bf5f8a]
+
+	* configure.in, src/testsuite/Makefile.am, src/testsuite/cmd-test-
+	message.c, src/testsuite/mail-raw.c,
+	src/testsuite/tests/testsuite.sieve, src/testsuite/testsuite,
+	src/testsuite/testsuite-common.c, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	Testsuite: setting message content works.
+	[93b3a300c389]
+
+	* src/lib-sieve/sieve-binary-dumper.c, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-extensions-private.h, src/lib-sieve
+	/sieve-extensions.c, src/testsuite/cmd-test-message.c, src/testsuite
+	/ext-testsuite.c, src/testsuite/testsuite,
+	src/testsuite/testsuite.c:
+	Fixed execution of initial testsuite implementation.
+	[c1455741740d]
+
+2008-05-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-imapflags.c, src
+	/lib-sieve/plugins/include/ext-include-binary.c, src/lib-
+	sieve/plugins/include/ext-include-binary.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	binary-dumper.c, src/lib-sieve/sieve-binary-dumper.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code-dumper.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-match-types.c,
+	src/testsuite/testsuite:
+	Properly implemented dumping a binary including a list of required
+	extensions and support for extension-specific output.
+	[49041cf55a5c]
+
+2008-05-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgignore, src/Makefile.am, src/lib-sieve/Makefile.am, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/body/ext-body.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/imapflags.sieve,
+	src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-binary-
+	dumper.c, src/lib-sieve/sieve-binary-dumper.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-code-dumper.h, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-common.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-dump.h, src
+	/lib-sieve/sieve-extensions-private.h, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/tst-header.c, src/testsuite/Makefile.am, src/testsuite
+	/cmd-test-message.c, src/testsuite/ext-testsuite.c, src/testsuite
+	/mail-raw.c, src/testsuite/mail-raw.h, src/testsuite/namespaces.c,
+	src/testsuite/namespaces.h, src/testsuite/tests/testsuite.sieve,
+	src/testsuite/testsuite, src/testsuite/testsuite-common.h,
+	src/testsuite/testsuite.c:
+	RECOVERED FROM INCONSISTENCY: developed testsuite and binary dumping
+	and fixed various small issues.
+	[5173404351c7]
+
+2008-04-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[e80c85bfd227]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/include-variables.sieve, src/lib-
+	sieve/plugins/include/include-variables1.sieve, src/lib-
+	sieve/plugins/include/include-variables2.sieve, src/lib-
+	sieve/plugins/include/include-variables3.sieve, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables-
+	operands.c, src/lib-sieve/plugins/variables/ext-variables.c, src
+	/lib-sieve/plugins/variables/sieve-ext-variables.h:
+	Include: merged import and export commands into a single
+	implementation and implemented global variable storage.
+	[2071bd319715]
+
+	* README, src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.c, src/lib-
+	sieve/plugins/variables/ext-variables-operands.h, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Variables: exported new operand definitions to separate file.
+	[1515291be1fe]
+
+2008-04-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.c, src/lib-
+	sieve/plugins/variables/ext-variables-arguments.h, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Variables: exported new argument definitions to separate file.
+	[889cea0db5b6]
+
+	* src/lib-sieve/plugins/include/cmd-export.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	variables.c, src/lib-sieve/plugins/include/ext-include-variables.h:
+	Include: implemented global variable scope.
+	[5cce69ab4eb4]
+
+2008-04-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/sieve-bin/sieve-test.c:
+	Added -c option to sieve-test to force compile.
+	[5c2eeabbafbe]
+
+2008-03-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/variables/ext-variables.c:
+	Updated documentation.
+	[157a94a31c54]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/ext-include-binary.h,
+	src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include-variables.c, src/lib-
+	sieve/plugins/include/ext-include-variables.h, src/lib-
+	sieve/plugins/include/include-variables1.sieve, src/lib-
+	sieve/plugins/include/include-variables2.sieve:
+	Include: moved variables support to separate file.
+	[9a997c6e97d0]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/ext-include-binary.c, src/lib-sieve/plugins/include/ext-include-
+	binary.h, src/lib-sieve/plugins/include/ext-include-common.c, src
+	/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c:
+	Include: moved implementation of binary extension to separate file.
+	[29877e0201ea]
+
+	* src/lib-sieve/plugins/include/cmd-export.c, src/lib-
+	sieve/plugins/include/cmd-import.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include-variables-error2.sieve, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Include: added AST context and now export context detectects export
+	of imported variables.
+	[7e2750e9e64b]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/include-error.sieve, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h:
+	Include: moved script existance validation back to validation stage.
+	[f179c5640bed]
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/include-variables-
+	error.sieve, src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Include: made import and export commands check whether the variables
+	extension is active.
+	[b1e85659979f]
+
+2008-03-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/Makefile.am, src/lib-
+	sieve/plugins/include/cmd-export.c, src/lib-sieve/plugins/include
+	/cmd-import.c, src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/include
+	/include-variables.sieve, src/lib-sieve/plugins/include/include-
+	variables1.sieve, src/lib-sieve/plugins/include/include-
+	variables2.sieve, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-script.c:
+	Include: added skeleton import and export commands.
+	[c3f48302b86a]
+
+	* README:
+	Updated TODO.
+	[404001bc4009]
+
+	* src/lib-sieve/plugins/regex/mcht-regex.c, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/variables-regex.sieve, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h:
+	Regex: added match values support.
+	[5dfb64a0f93b]
+
+	* src/lib-sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/ext-relational-common.c, src/lib-
+	sieve/plugins/relational/ext-relational-common.h, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/mcht-count.c, src/lib-
+	sieve/plugins/relational/mcht-value.c:
+	Relational: split match-type implementation into separate file.
+	[c3887aa30660]
+
+	* src/lib-sieve/plugins/regex/Makefile.am, src/lib-sieve/plugins/regex
+	/ext-regex-common.h, src/lib-sieve/plugins/regex/ext-regex.c, src
+	/lib-sieve/plugins/regex/mcht-regex.c:
+	Regex: split match type implementation into separate file.
+	[6de0ef9ce851]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/mcht-contains.c, src/lib-
+	sieve/mcht-is.c, src/lib-sieve/mcht-matches.c, src/lib-
+	sieve/plugins/body/ext-body-common.c, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-match-types.h:
+	Exported match type implementations to separate files.
+	[9c87314c8c6e]
+
+2008-03-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c:
+	Finished :matches function for now, but it can still be improved and
+	it needs more testing.
+	[dce3ebd372de]
+
+2008-03-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Revised :matches function, but did finish.
+	[361d7952dcc3]
+
+2008-03-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/variables-match.sieve, src/lib-sieve
+	/sieve-match-types.c:
+	Variables: fixed bug in match value indexing.
+	[eb6b7af13024]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/body/tst-body.c,
+	src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables-match.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c:
+	Variables: First work towards match value support.
+	[39ae5f637374]
+
+2008-02-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/variables/ext-variables.c:
+	Updated documentation.
+	[b01fae741c62]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/variables-errors.sieve:
+	Variables: added variable name parsing to the set command and added
+	error handling.
+	[636f16de84ad]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.c, src/lib-
+	sieve/plugins/variables/ext-variables-name.h, src/lib-
+	sieve/plugins/variables/variables-nspace.sieve:
+	Variables: exported namespace+variable parsing to separate file.
+	[1eb6468cbb57]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c:
+	Variables: exported namespace+variable parsing to separate function.
+	[324762d634a0]
+
+	* README:
+	Updated documentation.
+	[2d7d8b3882d6]
+
+2008-02-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.c:
+	Variables: added parsing support for namespaces.
+	[be3b8bac2c3b]
+
+	* src/lib-sieve/plugins/variables/tst-string.c:
+	Variables: fixed string test.
+	[6b07d2c2aecf]
+
+2008-02-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Expand ~ to home in sieve path.
+	[5a26dbbd6b04]
+
+2008-02-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c:
+	Fixed indent in sieve-banary.c
+	[b3ad65e8017e]
+
+	* src/lib-sieve/sieve-script.c:
+	Simplified needlessly complex assignment.
+	[71baeea1b4c2]
+
+	* README:
+	Added TODO item.
+	[5e891151c11d]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-
+	comparators.c:
+	Avoid direct to_lower() invocations; replaced by i_tolower().
+	[4a4da0b36b73]
+
+	* README:
+	Updated documentation.
+	[23fddcb3bff4]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-match-types.c:
+	Changed various p_new(pool_datastack_create(),) invocations to
+	t_new()
+	[4a350bcb98fb]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Envelope: changed p_array_init(,pool_datastack_create(),) into
+	t_array_init(,)
+	[d2659865968c]
+
+	* README:
+	Updated documentation.
+	[8854635f2819]
+
+2008-02-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-code.c:
+	Variables: fixed bug in string-list containing variables.
+	[bda964bee9f5]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-
+	commands.c:
+	Fixed bugs in string substitution support and the regex extension.
+	[2c93a6f1f120]
+
+	* src/lib-sieve/plugins/variables/draft-ietf-sieve-variables-08.txt,
+	src/lib-sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/rfc5229.txt:
+	Variables: updated included specification to new RFC 5229.
+	[970977365e61]
+
+	* README:
+	Updated documentation.
+	[8223da28978b]
+
+	* src/lib-sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: made variable identifiers case insensitive.
+	[22ba1d548f77]
+
+2008-02-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/variables-errors.sieve:
+	Variables: added check for equal precedence and added comment.
+	[78ac4b9fd4b7]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated 'quotewildcard' set modifier and fixed a bug.
+	[f5cc923c0cf8]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated 'length' set modifier.
+	[571ff4050c4e]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: activated support for set command modifiers.
+	[9c3840cc68f6]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Adjusted body extension to compile with dovecot past 1.1.beta16
+	(message parser changes)
+	[854549e5e6d9]
+
+2008-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* AUTHORS:
+	Added notice about the omission CMU code to the AUTHORS file.
+	[e10b34c008dd]
+
+	* .hgignore, configure.in:
+	Assigned proper package version and name.
+	[19fa7bfb0623]
+
+	* .hgignore, COPYING:
+	Removed duplicate licence.
+	[be7aad6c814d]
+
+	* Makefile.am:
+	Added maintainermode functions to Makefile.am
+	[fdf2ea8d11d3]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-encoded-character.c, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/sieve-address-parts.c, src/lib-
+	sieve/sieve-ast.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Incorporated changes in dovecot-1.1
+	[c8c67641d0dc]
+
+2008-02-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Variables: set modifiers are now sorted.
+	[5ceb8e6709ef]
+
+2008-02-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Added code support for set modifiers.
+	[edba29e3d158]
+
+2008-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/tst-
+	string.c, src/lib-sieve/plugins/variables/variables.sieve, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Fixed bugs in validation error handling and fixed bugs in dynamic
+	argument support.
+	[207f7dea843e]
+
+2008-01-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/variables.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-validator.c:
+	First successful variable substitutions.
+	[beaacb4d8406]
+
+	* Merged concurrent changes.
+	[8e8f0012b6c1]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h, src/lib-
+	sieve/plugins/variables/tst-string.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-comparators.c, src/lib-
+	sieve/sieve-comparators.h, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-
+	sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Changed operand read API to get access to the runtime environment
+	inside the read functions.
+	[be351797c032]
+
+2008-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/interesting.sieve, src/lib-sieve/sieve-parser.c:
+	Minor fix in the error reporting of the sieve parser.
+	[d403335a9351]
+
+	* src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h,
+	src/lib-sieve/sieve.c:
+	Implemented dynamic sieve_get_capabilities() for proper MANAGESIEVE
+	support.
+	[5ecaa79ab879]
+
+	* src/lib-sieve/sieve.c, src/lib-sieve/sieve.h:
+	Published compiler API using script objects instead of paths.
+	[16d8c8b63bcc]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed segfault occuring when command did not exist.
+	[31182d66d254]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-script.c:
+	Small changes: removed T_FRAME and improved an error message.
+	[dac13553f2fa]
+
+2008-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/include/ext-
+	include-common.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	error-private.h, src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-
+	error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-script-
+	private.h, src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-
+	script.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c,
+	src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-sieve-plugin.c, src
+	/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c, src/sieve-bin
+	/sieve-test.c:
+	Implemented required features for use with MANAGESIEVE service.
+	[41d479d33f26]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h:
+	Added strbuf error handler.
+	[57118bf13efc]
+
+2007-12-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-match-types.c:
+	Added variable operand to the variables extension.
+	[cd89ce24b255]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.h, src
+	/lib-sieve/sieve-match-types.c:
+	Added support for adding new types operands to the engine.
+	[6f5eadd0e4c8]
+
+	* src/lib-sieve/plugins/variables/cmd-set.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.c, src/lib-
+	sieve/plugins/variables/ext-variables-common.h, src/lib-
+	sieve/plugins/variables/sieve-ext-variables.h:
+	Defined variable argument for the variables extension.
+	[b0552c08b279]
+
+2007-12-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-generator.c, src
+	/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h:
+	Changed validation and generation of string list argument to fully
+	support the new string list encoding.
+	[f65dd8431ae8]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-binary.c, src
+	/lib-sieve/sieve-code.c:
+	Changed encoding of stringlist. Now it contains string operands in
+	stead of bare strings.
+	[7bac41b7e6c1]
+
+	* src/lib-sieve/sieve-extensions-private.h:
+	Removed obsolete code.
+	[9aeb0333b0d7]
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/body
+	/ext-body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-
+	cmp-i-ascii-numeric.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/ext-variables.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-extensions-private.h, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-validator.c:
+	Removed much code duplication between extensions that provide
+	support for further extension.
+	[3009bde82cd7]
+
+2007-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions-private.h, src
+	/lib-sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h:
+	Further migrated implementation of extensions to new extension
+	architecture.
+	[4ac0b9e8635c]
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-
+	encoded-character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/copy/copy.sieve, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-include.c, src
+	/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.h, src/lib-sieve/plugins/variables/ext-
+	variables.c, src/lib-sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-binary.h, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	extensions-private.h, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-validator.c, src/lib-
+	sieve/sieve.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Major changes in the extensions support.
+	[8b74028295fd]
+
+2007-12-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-match-
+	types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h:
+	Changed implementation of command context handling and instanced
+	tags to avoid duplicate lookups.
+	[74d12bfed7c8]
+
+	* src/lib-sieve/plugins/variables/Makefile.am, src/lib-
+	sieve/plugins/variables/cmd-set.c, src/lib-sieve/plugins/variables
+	/ext-variables-common.c, src/lib-sieve/plugins/variables/ext-
+	variables-common.h, src/lib-sieve/plugins/variables/ext-variables.c,
+	src/lib-sieve/plugins/variables/tst-string.c, src/lib-
+	sieve/plugins/variables/variables.sieve:
+	Further developed the variables extension.
+	[492938049fc1]
+
+2007-12-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/variables/Makefile.am, src/lib-sieve/plugins/variables
+	/draft-ietf-sieve-variables-08.txt, src/lib-sieve/plugins/variables
+	/ext-variables.c, src/lib-sieve/plugins/variables/variables.sieve,
+	src/lib-sieve/sieve-extensions.c:
+	Started skeleton implementation of variables extension.
+	[cac5b0cdb8e6]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/ext-encoded-
+	character.c:
+	Fixed non-standard behavior for the encoded-character extension.
+	[6900d4693821]
+
+	* README, sieve/errors/encoded-character.sieve, sieve/tests/encoded-
+	character.sieve, src/lib-sieve/ext-encoded-character.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/sieve-bin
+	/mail-raw.c:
+	Finished encoded-character extension.
+	[dd6a814d5350]
+
+	* doc/rfc/rfc3629.txt:
+	Added UTF-8 rfc to doc/rfc directory.
+	[772db2c40fd1]
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/ext-encoded-
+	character.c, src/lib-sieve/sieve-validator.c:
+	Built a little more extensive tests for the encoded-character
+	extension.
+	[f6cba45b3299]
+
+2007-12-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/encoded-character.sieve, src/lib-sieve/cmd-redirect.c,
+	src/lib-sieve/ext-encoded-character.c, src/lib-sieve/ext-envelope.c,
+	src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Encoded character extension basicly works, but no unicode support is
+	implemented.
+	[0c62d3501b83]
+
+2007-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/cmd-require.c, src/lib-sieve/ext-
+	encoded-character.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/body/tst-body.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code-
+	dumper.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src
+	/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-sieve
+	/tst-not.c, src/lib-sieve/tst-size.c:
+	Implemented support for overriding default argument implementations
+	of number, string and string-list.
+	[811636f212aa]
+
+2007-12-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* doc/rfc/draft-ietf-sieve-3028bis-13.txt, doc/rfc/rfc3028.txt:
+	Added sieve rfc and new sieve 3028bis to the doc/rfc directory.
+	[cf0d3511810b]
+
+	* doc/rfc:
+	Removed erroneous rfc file from new doc dir.
+	[50462444b677]
+
+	* doc/rfc, sieve/tests/encoded-character.sieve, src/lib-sieve/ext-
+	encoded-character.c:
+	Forgot to add new files.
+	[ec01147fbf36]
+
+	* README:
+	Updated documentation.
+	[d870f0bb6228]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/sieve-extensions.c:
+	Started skeleton for the encoded-character extension.
+	[915854a9a6e7]
+
+	* README:
+	Updated TODO list.
+	[c4f08e56f98f]
+
+	* README, src/lib-sieve/plugins/body/ext-body.c:
+	Updated documentation.
+	[7853b0fd8c2f]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c:
+	Changed imapflags extension to use the message context instead of
+	the interpreter context.
+	[73f99ee08abb]
+
+	* src/lib-sieve/plugins/body/ext-body-common.c:
+	Changed body extension to use the message context instead of the
+	interpreter context.
+	[c769d7261264]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Introduced message context to give extensions the ability to
+	associate context data with the currently processed message.
+	[08a085d3c1b9]
+
+	* README, src/lib-sieve/plugins/body/ext-body.c:
+	Updated documentation.
+	[d47f4b7439d2]
+
+	* src/lib-sieve/plugins/body/body.sieve, src/lib-sieve/plugins/body
+	/ext-body-common.c, src/lib-sieve/plugins/body/tst-body.c:
+	Fixed minor bug in the body extension.
+	[c8ea2fb589cc]
+
+	* AUTHORS, src/lib-sieve/plugins/body/Makefile.am, src/lib-
+	sieve/plugins/body/body.sieve, src/lib-sieve/plugins/body/ext-body-
+	common.c, src/lib-sieve/plugins/body/ext-body-common.h, src/lib-
+	sieve/plugins/body/ext-body.c, src/lib-sieve/plugins/body/tst-
+	body.c, src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve
+	/sieve-address-parts.c, src/lib-sieve/sieve-match-types.c, src/lib-
+	sieve/sieve-match-types.h, src/lib-sieve/tst-header.c:
+	Implemented evaluation for the body test introduced by the body
+	extension.
+	[7dc23ed0c79f]
+
+	* src/lib-sieve/plugins/body/ext-body.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h:
+	Implemented validation and code generation for body extension.
+	[24a83b8759f7]
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/body/Makefile.am,
+	src/lib-sieve/plugins/body/draft-ietf-sieve-body-07.txt, src/lib-
+	sieve/plugins/body/ext-body.c:
+	Started skeleton for the body extension.
+	[87141cd62e03]
+
+	* README, src/lib-sieve/plugins/include/ext-include.c:
+	Updated documentation.
+	[ebdc3d4b1ebb]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/cmd-return.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/included2.sieve, src/lib-
+	sieve/sieve-binary.c:
+	Implemented return command for include extension.
+	[2ecc3c3f89cf]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-error.c:
+	Basic include functionality seems to be working and if source
+	scripts are changed the binary is always recompiled.
+	[4d87cc13eb79]
+
+2007-12-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-script.c, src/lib-
+	sieve/sieve-script.h, src/lib-sieve/sieve.c:
+	Working towards proper dependency handling for sieve binaries.
+	[7055341a175d]
+
+	* src/lib-sieve/sieve-binary.c:
+	Added support for lazy binary load.
+	[443f611ba331]
+
+2007-12-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-sieve/sieve-
+	binary.c:
+	Added internal support for different methods of loading a binary.
+	[06efb6d54463]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve.c, src/sieve-
+	bin/sieved.c:
+	Working towards complete binary support for the include extension.
+	[1f60d0e233a2]
+
+2007-12-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation.
+	[cd70b1e8764f]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-interpreter.c:
+	Fixed bug regarding stop command in combination with include
+	extension.
+	[84c480ec5cd3]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c:
+	Simplified the include loop a little.
+	[e930ac1deb4e]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h:
+	Implemented mostly untested deep-level include execution support.
+	[c88db860a282]
+
+2007-12-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve.c:
+	First successful (single level) execution of four consecutive
+	includes.
+	[5f1564b65675]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h:
+	Added support for interrupting an interpreter and continuing
+	execution later.
+	[1af35588edfc]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/include/cmd-include.c, src/lib-sieve/plugins/include
+	/ext-include-common.c, src/lib-sieve/plugins/include/ext-include-
+	common.h, src/lib-sieve/plugins/include/ext-include.c:
+	Include extension now generates include opcode. Not executable yet
+	though.
+	[ac8496b3d19c]
+
+	* src/lib-sieve/sieve-binary.c:
+	Implemented the binary_free event for binary extensions. Script
+	references in the include extension are now properly released.
+	[d0a0bbdaf6b0]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-common.h:
+	Fixed behavior of binary object with respect to pre-loaded
+	extensons. Broke it with last change.
+	[ce0e32e63adc]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h:
+	Changed binary object's extension linkage for extending the binary
+	itself.
+	[5633827bd892]
+
+2007-12-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-sieve/sieve-script.c,
+	src/lib-sieve/sieve-script.h:
+	Doubly included scripts are no longer compiled and included multiple
+	times.
+	[64ffbd9afaaa]
+
+	* src/lib-sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-
+	binary.c:
+	Forgot to set the number of blocks in the binary header.
+	[69967868a8cc]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included1.sieve:
+	Re-established circular include detection for include extension.
+	[e8867e044d2c]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h,
+	src/lib-sieve/sieve.c:
+	Further developed the include extension to compile included scripts
+	in additional blocks of the binary.
+	[6d0b5b112f00]
+
+2007-12-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-
+	sieve/sieve.c:
+	Further developed the binary format: binary can now contain multiple
+	blocks with arbitrary data.
+	[958ac41805fc]
+
+	* README:
+	Updated documentation: Changed priorities in TODO list.
+	[c27f92353192]
+
+	* README:
+	Updated documentation.
+	[b1b5f7d6ff6c]
+
+2007-12-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary.c, src/lib-
+	sieve/sieve-binary.h, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-script.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/sieve-bin/sieved.c:
+	Moved actual include operation from validator to generator stage.
+	[c49356652255]
+
+	* .hgignore, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	script.c, src/lib-sieve/sieve-script.h, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/sieve-bin/sievec.c:
+	Sieve executables now work with binaries too.
+	[8e7a1b3c0ad9]
+
+	* .hgignore, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-
+	binary.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-script.c, src/sieve-
+	bin/Makefile.am, src/sieve-bin/sievec.c, src/sieve-bin/sieved.c:
+	Made a basic implementation of saving binaries to disk.
+	[60a7a53897cf]
+
+2007-12-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-parser.c, src/lib-
+	sieve/sieve.c:
+	Cleaned up ast implementation a little.
+	[82fb78a39773]
+
+	* src/lib-sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve.c:
+	Prevented more scripts from being included when errors have occured.
+	[fade5794fecf]
+
+	* src/lib-sieve/plugins/include/cmd-include.c, src/lib-
+	sieve/plugins/include/ext-include-common.c, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve-lexer.c,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve.c:
+	Properly implemented circular include detection for the include
+	extension.
+	[d3b8e1347bb5]
+
+	* src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/ext-include-common.c,
+	src/lib-sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-
+	sieve/plugins/include/included1.sieve, src/lib-
+	sieve/plugins/include/included2.sieve, src/lib-
+	sieve/plugins/include/included3.sieve, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-commands.h, src/lib-
+	sieve/sieve-common.h, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	lexer.h, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h,
+	src/lib-sieve/sieve-script.c, src/lib-sieve/sieve-script.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h:
+	First defined an encapsulating script object and implemented part of
+	the include extension.
+	[20278c7b7254]
+
+2007-12-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/include/Makefile.am, src/lib-sieve/plugins/include
+	/cmd-include.c, src/lib-sieve/plugins/include/cmd-return.c, src/lib-
+	sieve/plugins/include/draft-daboo-sieve-include-05.txt, src/lib-
+	sieve/plugins/include/ext-include-common.h, src/lib-
+	sieve/plugins/include/ext-include.c, src/lib-
+	sieve/plugins/include/include.sieve, src/lib-sieve/sieve-
+	extensions.c:
+	Started skeleton implementation for the include extension.
+	[fae946e07bd2]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Updated documentation.
+	[3ffe74253949]
+
+2007-12-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/plugins/vacation/ext-
+	vacation.c:
+	Added :addresses support to the vacation extension.
+	[22045e56dec8]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/imapflags/cmd-
+	addflag.c, src/lib-sieve/plugins/imapflags/cmd-removeflag.c, src
+	/lib-sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-exists.c, src/lib-sieve/tst-header.c:
+	Added support for reading an entire stringlist into memory. Also
+	fixed various identical bugs in stringlist-related error handling.
+	[a2ae74cddb58]
+
+	* README:
+	Added two TODO items.
+	[5b3f80ba5fa5]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Tiny update to documentation and removed a compiler warning.
+	[57bef612b360]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	generator.c:
+	Added :mime support to vacation extension.
+	[e0170e8422a7]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h,
+	src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Renamed mail_environment to script_env.
+	[357df85b1c14]
+
+	* README, src/lib-sieve/cmd-redirect.c:
+	Added mail-loop detection to the redirect action.
+	[5208c9de6da9]
+
+	* src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins
+	/lda-sieve/lda-sieve-plugin.c, src/sieve-bin/sieve-exec.c:
+	Changed execution error handling a little.
+	[9bedd7aaed60]
+
+	* src/lib-sieve/ext-reject.c, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-commands.c, src/lib-
+	sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-
+	validator.c:
+	Adopted code to use Dovecot's new T_FRAME* macros.
+	[7d056b0525a8]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	code-dumper.h, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-result.h, src/lib-sieve/sieve-
+	validator.h:
+	Added proper ATTR_FORMAT to all functions that accept a string
+	format and fixed one bug in the process.
+	[ed5bbe4892fe]
+
+	* README:
+	Further updated documentation and cleaned up the README file.
+	[34dd6d80f884]
+
+	* INSTALL, README:
+	Updated documentation. We are gettin closer to a first release.
+	[ba0d6c952726]
+
+	* src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-result.c, src/sieve-bin/bin-common.c, src/sieve-bin
+	/sieve-exec.c:
+	Implemented implicit keep to execute when not canceled or when the
+	preceeding action execution fails.
+	[83139c099737]
+
+2007-12-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-interpreter.c:
+	Fixed minor bugs in the error reporting.
+	[3cf617a5c19b]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Fixed tiny bug in the error reporting in the lda-sieve plugin.
+	[dd6d34c328e0]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Further developed the error handling.
+	[b440e2ecb968]
+
+2007-12-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Added a little more error logging to the lda-sieve plugin.
+	[22100a6b83a0]
+
+	* src/lib-sieve/sieve-error.c, src/lib-sieve/sieve-error.h,
+	src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Implemented logfile error handler and assigned it to the lda-sieve
+	plugin.
+	[1dd0d188e90d]
+
+2007-12-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-parser.c,
+	src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve
+	/lda-sieve-plugin.c, src/sieve-bin/bin-common.c, src/sieve-
+	bin/sievec.c:
+	Further developed error handling.
+	[38b7c79a1bc9]
+
+2007-12-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c:
+	Forgot to initialize sieve library in lda-sieve plugin. It has now
+	successfully delivered its first message.
+	[0bb383b96a44]
+
+	* src/plugins/lda-sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-
+	sieve-plugin.h:
+	Fixed misnamed module entry points for the lda-sieve plugin.
+	[b8b366a08231]
+
+	* configure.in, src/Makefile.am, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/plugins/lda-sieve/Makefile.am, src/plugins/lda-
+	sieve/lda-sieve-plugin.c, src/plugins/lda-sieve/lda-sieve-plugin.h,
+	src/sieve-bin/bin-common.c:
+	Included sieve plugin into the build process.
+	[0eee6014369f]
+
+	* README, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/plugins/lda-sieve/lda-
+	sieve-plugin.c, src/sieve-bin/sievec.c:
+	Documentation updates.
+	[f48f95ebfcad]
+
+	* src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-
+	error.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve.c, src
+	/lib-sieve/sieve.h, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c,
+	src/sieve-bin/sievec.c:
+	Implemented sieve test binaries further. They now have proper
+	command line arguments.
+	[c1e500086b9c]
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/bin-common.c, src/sieve-bin
+	/bin-common.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c, src/sieve-bin/sievec.c:
+	Updated and cleaned-up the sieve test binaries.
+	[9ed2f2979c35]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags-common.c, src/lib-sieve/plugins/imapflags/tag-flags.c, src
+	/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-code-dumper.c, src/lib-sieve
+	/sieve-code-dumper.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src
+	/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c, src/sieve-
+	bin/sievec.c:
+	Properly implemented the code dumper. Dumps are now printed in a
+	stream. The individual opcode and operand implementations no longer
+	use printf()s.
+	[b68f9e45a6bd]
+
+	* src/lib-sieve/sieve-code-dumper.c, src/lib-sieve/sieve-code-
+	dumper.h:
+	Forgot to add new files.
+	[3a75f9a2a4ac]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/plugins/imapflags
+	/tst-hasflag.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-code.c, src
+	/lib-sieve/sieve-code.h, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-interpreter.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, src/lib-sieve/tst-size.c:
+	Exported sieve-code-dumper from sieve-interpreter containing all
+	code dumping related implementation. Now to remove all printfs....
+	[ca3bfa6b2284]
+
+2007-12-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Fixed bug in handling optional operands to opcodes that have no
+	mandatory operands (0 is no longer a valid opcode)
+	[77e421643cc2]
+
+	* sieve/errors/action-conflicts.sieve, sieve/errors/action-
+	duplicates.sieve, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-
+	keep.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c,
+	src/lib-sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-
+	vacation.c, src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-
+	actions.h, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added conflict and duplicate checking to vacation and reject
+	actions.
+	[c33bb67f8b09]
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve.h, src/sieve-
+	bin/sieve-exec.c, src/sieve-bin/sieve-test.c:
+	Implemented actions reject and vacation.
+	[d34c2fe9ac63]
+
+	* src/lib-sieve/ext-envelope.c:
+	Fixed minor bug in envelope extension.
+	[e39957361fed]
+
+2007-11-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.c,
+	src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve-validator.c:
+	Further developed imapflags extension and added proper logging
+	functions to the result object.
+	[bc668e541c89]
+
+2007-11-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-actions.h,
+	src/lib-sieve/sieve-interpreter.c:
+	The :flags tag introduced by the imapflags extension now attaches
+	side-effects to the appropriate action commands.
+	[b3f4220296e2]
+
+	* README, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-actions.c, src
+	/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-result.c:
+	Properly implemented handling of the implicit keep flag and fully
+	implemented the copy extension.
+	[24896ebd3e8d]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/plugins/copy/ext-copy.c, src
+	/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-
+	sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-common.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added basic execution support to copy extension. Not completely
+	functional yet.
+	[8ad6e3739a65]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	code.c:
+	Added support for reading side effect operands.
+	[04e8fa76e983]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c:
+	Added registration of side-effect extension into binary.
+	[98c1c9798c08]
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h:
+	Defined side-effect object for the copy extension.
+	[f22e0d5b9788]
+
+	* src/lib-sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/tst-header.c:
+	Incorporated the signedness of the id_code in the optional_read
+	functions as well
+	[2923c10f41b9]
+
+2007-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/tst-size.c:
+	Changed id_code for optional operands to signed and fixed a
+	ext_my_id-related error in the vacation and copy extensions.
+	[38a9854e21ca]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-extensions.c:
+	Added operand emission support for action side effects.
+	[8b9ba3e6a631]
+
+	* src/lib-sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src
+	/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h:
+	Created pre-loaded action side effects 'extension'.
+	[37a2969e9787]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-match-types.c:
+	Removed part of the code duplication between address-part, match-
+	type and comparator implementations.
+	[34b4be8738f2]
+
+	* src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added untested support for side effects to result object.
+	[ec22e9a0a06d]
+
+2007-11-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c, src/lib-sieve/plugins/imapflags/imapflags.sieve,
+	src/lib-sieve/plugins/imapflags/tag-flags.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-result.c:
+	Added :flags tag to the imapflags extension and fixed bug in the
+	result execution.
+	[e4ccc420bbc8]
+
+	* README:
+	Updated documentation.
+	[0b63e817f6b6]
+
+	* src/lib-sieve/plugins/copy/copy.sieve, src/lib-sieve/plugins/copy
+	/ext-copy.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Added support for externally adding tags to (possibly not yet
+	registered) command. The copy extension now adds such a tag to
+	fileinto and redirect.
+	[9ad768a6d2b9]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/copy/Makefile.am,
+	src/lib-sieve/plugins/copy/ext-copy.c, src/lib-
+	sieve/plugins/copy/rfc3894.txt, src/lib-sieve/sieve-extensions.c,
+	src/sieve-bin/sieve-exec.c:
+	Added skeleton for the copy extension.
+	[f4d0e3674a8c]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c:
+	Minor changes
+	[da31c25af3df]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c, src/sieve-
+	bin/sieve-exec.c:
+	Store action seems to work properly now.
+	[eec88e2b625d]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/sieve-actions.c, src/lib-
+	sieve/sieve-actions.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/Makefile.am, src/sieve-bin/mail-raw.c,
+	src/sieve-bin/mail-raw.h, src/sieve-bin/namespaces.c, src/sieve-
+	bin/namespaces.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Almost finished implementing the store action. But, I still get
+	strange errors when the mail transaction commits. Mail is stored
+	though.
+	[246c88fea246]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/sieve-actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve
+	/sieve-result.c:
+	Turned action execution into a transaction.
+	[d9a51d8e6d16]
+
+	* README, src/lib-sieve/cmd-discard.c, src/lib-sieve/cmd-keep.c, src
+	/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added (not yet active) handling of implicit keep and adjusted
+	commands accordingly.
+	[d8eaf00dd960]
+
+	* README:
+	Added TODO item.
+	[2e2cbe36ac1d]
+
+2007-11-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-
+	test.c:
+	Added inbox location to mail environment and made keep command use
+	it to generate its store action.
+	[1fabb5b3de8f]
+
+	* README, src/lib-sieve/ext-fileinto.c:
+	Updated documentation.
+	[b77f5ae48116]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/Makefile.am, src/lib-sieve
+	/cmd-discard.c, src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/sieve-
+	actions.c, src/lib-sieve/sieve-actions.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h:
+	Fileinto command now produces a store action which is now produced
+	by the keep command as well.
+	[b59ff97b1b4b]
+
+	* sieve/tests/actions.sieve, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-keep.c:
+	Made discard command add discard action to the result.
+	[d00c1ecbe750]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-discard.c, src/lib-
+	sieve/cmd-keep.c, src/lib-sieve/sieve-commands.c:
+	Exported discard command to its own separate file.
+	[8bedc7e9f17e]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h:
+	Added support for detecting action conflicts.
+	[37fcab36395a]
+
+	* README:
+	Updated documentation.
+	[eb3c1925ac1f]
+
+	* sieve/tests/redirect.sieve, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/cmd-redirect.c, src/lib-sieve/sieve-result.c, src/lib-sieve/sieve-
+	result.h:
+	Added support for avoiding duplicate actions in the sieve result.
+	[7fa2aeb9a269]
+
+	* src/lib-sieve/cmd-keep.c, src/lib-sieve/cmd-redirect.c:
+	Made keep command add keep action to the result.
+	[b4ac2186369d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-keep.c, src/lib-sieve
+	/sieve-commands-private.h, src/lib-sieve/sieve-commands.c:
+	Exported keep command to its own separate file.
+	[a061b79e6eb1]
+
+2007-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/bin-common.c, src/sieve-bin/sieve-exec.c, src/sieve-
+	bin/sieve-test.c:
+	Minor changes to the executables.
+	[1c349f5cf532]
+
+	* README, src/lib-sieve/sieve-interpreter.c, src/sieve-bin/sieve-
+	exec.c, src/sieve-bin/sieve-test.c:
+	Added mail-file parameter to the sieve-test and sieve-exec binaries.
+	[38ff5f7794ad]
+
+	* .hgignore, sieve/tests/redirect.sieve, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-
+	bin/Makefile.am, src/sieve-bin/bin-common.c, src/sieve-bin/bin-
+	common.h, src/sieve-bin/mail-raw.c, src/sieve-bin/mail-raw.h, src
+	/sieve-bin/sieve-exec.c, src/sieve-bin/sieve-test.c, src/sieve-
+	bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Cleaned up implementation of sieve test binaries and added sieve-
+	exec
+	[ab2fd12a0195]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Removed spurious debug message.
+	[5b53dd17b678]
+
+2007-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src
+	/lib-sieve/sieve-result.h, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/sieve-bin/Makefile.am, src/sieve-
+	bin/sieve_test.c:
+	Added first action execution support. Redirect is the first command
+	to actually work.
+	[3ea3f400caa9]
+
+	* README:
+	Added TODO item.
+	[312bfe51f644]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Moved address-part, match-type and comparator code registries from
+	interpreter to binary where they belong.
+	[17fe832ec983]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-interpreter.c:
+	Added extension context storage support to the sieve binary.
+	[bf61316d9b84]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/comparator-i-ascii-numeric
+	/ext-cmp-i-ascii-numeric.c, src/lib-sieve/plugins/imapflags/ext-
+	imapflags.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-match-types.c:
+	Added binary_load event to the sieve extensions.
+	[abc3d97f3cfe]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h,
+	src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h,
+	src/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-
+	interpreter.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-match-types.h, src/lib-sieve/sieve-result.c, src/lib-sieve
+	/sieve-result.h, src/lib-sieve/sieve.c, src/lib-sieve/tst-address.c,
+	src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src/lib-
+	sieve/tst-size.c:
+	Grouped runtime parameters into a single runtime environment and
+	started implementation of result composition/execution.
+	[7c800bfa74cc]
+
+	* src/lib-sieve/sieve-interpreter.c:
+	Changed interpreter in the event of an unimplemented opcode.
+	[91fd90402931]
+
+	* README, src/lib-sieve/plugins/imapflags/ext-imapflags.c:
+	Updated documentation.
+	[9dd4fe921d74]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c:
+	Implemented hasflag command interpretation for the imapflags
+	extension.
+	[30917ef6965c]
+
+2007-11-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-2.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/tst-size.c:
+	Added actual flag management to the imapflags extension. Addflag,
+	removeflag and setflag now do what they should do.
+	[610b5f638c33]
+
+	* README, src/lib-sieve/cmd-if.c, src/lib-sieve/plugins/comparator-i
+	-ascii-numeric/ext-cmp-i-ascii-numeric.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c:
+	Finished i;ascii-numeric comparator and fixed a segfault bug in the
+	process.
+	[8cd504cc2e3a]
+
+	* README, src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-
+	sieve/plugins/imapflags/tst-hasflag.c, src/lib-sieve/tst-header.c:
+	Added hasflag test to the imapflags extension.
+	[cc5f85570a9a]
+
+	* src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h:
+	Implemented code generation and interpretation for the commands
+	introduced by the imapflags extension.
+	[f0c34dee6ae7]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-sieve/plugins/regex
+	/ext-regex.c, src/lib-sieve/plugins/relational/ext-relational.c, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-match-types.c,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-
+	sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Upgraded opcode extension support to handle more than one opcode per
+	extension.
+	[2a2d82471e77]
+
+2007-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve:
+	imapflags: Added (dummy) check for the existance of the variables
+	extension.
+	[9d97ea5c52c6]
+
+	* src/lib-sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/imapflags-errors.sieve, src/lib-sieve/sieve-
+	validator.c:
+	Implemented validation for the commands introduced by the imapflags
+	extension.
+	[82e86518dfc9]
+
+	* src/lib-sieve/plugins/imapflags/Makefile.am, src/lib-
+	sieve/plugins/imapflags/cmd-addflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-removeflag.c, src/lib-
+	sieve/plugins/imapflags/cmd-setflag.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.c, src/lib-
+	sieve/plugins/imapflags/ext-imapflags-common.h, src/lib-
+	sieve/plugins/imapflags/ext-imapflags.c, src/lib-
+	sieve/plugins/imapflags/imapflags.sieve, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve/sieve-
+	validator.c:
+	Created skeletons for the commands introduced by the imapflags
+	extension.
+	[c0471778290f]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/imapflags/Makefile.am, src/lib-sieve/plugins/imapflags
+	/draft-ietf-sieve-imapflags-05.txt, src/lib-sieve/plugins/imapflags
+	/ext-imapflags.c:
+	Started skeleton for the imapflags extension.
+	[6ea6b7699606]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/plugins/Makefile.am, src
+	/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am, src/lib-
+	sieve/plugins/regex/Makefile.am, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/vacation/Makefile.am, src/sieve-bin/Makefile.am:
+	Cleaned up make process and included the 'plugins' into the main
+	sieve library archive.
+	[b669519df1b5]
+
+	* README, src/lib-sieve/sieve-commands.c:
+	Updated documentation.
+	[ab270d1accc1]
+
+	* sieve/examples/vivil.sieve, sieve/tests/stop.sieve, src/lib-sieve
+	/cmd-if.c, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h:
+	Removed unecessary jump after commands like stop.
+	[a487f6447efa]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/sieve-match-types.c:
+	Debugged :matches match type and no more bugs are currently known.
+	[acdcd1d8f031]
+
+	* sieve/tests/matches.sieve, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/ext-cmp-i-ascii-numeric.c, src/lib-sieve/sieve-
+	comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-sieve
+	/sieve-match-types.c:
+	Made first buggy implementation of :matches match type.
+	[d3756743700b]
+
+2007-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Updated documentation with respect to extensions.
+	[cd8b13651e87]
+
+	* sieve/tests/reject.sieve, src/lib-sieve/ext-reject.c:
+	Added dummy execution support to reject extension.
+	[29620589f088]
+
+	* README, src/lib-sieve/plugins/vacation/ext-vacation.c:
+	Updated documentation.
+	[3dcfafbef34d]
+
+	* sieve/tests/vacation.sieve, src/lib-sieve/plugins/vacation/ext-
+	vacation.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h:
+	Implemented dummy execution for vacation extension.
+	[ef682330f822]
+
+	* src/lib-sieve/ext-envelope.c:
+	Resolved compiler warning in envelope extension.
+	[7e2d6e8893dc]
+
+	* sieve/tests/redirect.sieve:
+	Added test script for redirect command.
+	[30ec001eaee2]
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h:
+	Properly implemented stop command and associated opcode.
+	[cb2ac2578b83]
+
+	* src/sieve-bin/sieve_test.c:
+	Added status message to sieve_test to indicate successful script
+	run.
+	[64e0b6403468]
+
+	* src/lib-sieve/cmd-redirect.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.h:
+	Created dummy interpretation support for the redirect command.
+	[382920e5c5ae]
+
+	* sieve/tests/fileinto.sieve, src/lib-sieve/ext-fileinto.c:
+	Created dummy interpretation support for the fileinto extension.
+	[c410f5746af3]
+
+	* src/lib-sieve/ext-envelope.c:
+	Removed debug lines in envelope extension.
+	[0d144c5c6726]
+
+	* src/lib-sieve/ext-envelope.c:
+	Made ext_envelope_get_fields cleaner.
+	[962e5ed2a7b0]
+
+	* README, src/lib-sieve/ext-envelope.c:
+	Updated documentation.
+	[c05059b64271]
+
+	* sieve/tests/envelope.sieve, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-parts.h,
+	src/lib-sieve/sieve.h, src/lib-sieve/tst-address.c, src/sieve-
+	bin/sieve_test.c:
+	Made basic execution implementation of the envelope extension.
+	[6bf04ad6e814]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-common.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src
+	/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c,
+	src/lib-sieve/tst-size.c, src/sieve-bin/sieve_test.c:
+	Added envelope data to the interpreter environment.
+	[b9cf89b005f2]
+
+	* README, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-header.c:
+	Completed implementation of the relational extension.
+	[7dd971306703]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-match-types.h:
+	Improved match handling and started implementing the interpretation
+	of the relational match type.
+	[158169910d95]
+
+2007-11-20  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/errors/match-type-errors.sieve, sieve/tests/match-type.sieve,
+	src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-match-types.c:
+	Implemented context validation for :contains match type.
+	[6f1dcac24c57]
+
+	* README, src/lib-sieve/plugins/regex/ext-regex.c:
+	Updated documentation with respect to regex externsion and match-
+	type support.
+	[37fd899b7dca]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Last commit broke execution of match types other than
+	:regex...fixed.
+	[f9e2b975f5eb]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-sieve/plugins/relational
+	/ext-relational.c, src/lib-sieve/sieve-address-parts.c, src/lib-
+	sieve/sieve-address-parts.h, src/lib-sieve/sieve-common.h, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Implemented regex match execution.
+	[114ec23016dd]
+
+	* sieve/examples/sanjay.sieve:
+	Fixed missing require in sanjay.sieve example
+	[81baf031527e]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c:
+	Forgot to handle stringlists in :regex validation.
+	[4e082129513a]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/plugins/regex/ext-
+	regex.c, src/lib-sieve/plugins/regex/regex-errors.sieve, src/lib-
+	sieve/sieve-match-types.c, src/lib-sieve/sieve-match-types.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Implemented :regex match validation.
+	[fefebffac65f]
+
+	* sieve/errors/address-part-errors.sieve,
+	sieve/errors/interesting.sieve, sieve/errors/match-type-
+	errors.sieve, src/lib-sieve/sieve-address-parts.c, src/lib-sieve
+	/sieve-ast.h, src/lib-sieve/sieve-match-types.c, src/lib-sieve
+	/sieve-validator.c:
+	Implemented detection of duplicate optional arguments.
+	[9add85be3ddd]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-sieve/plugins/regex
+	/regex-errors.sieve, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src/lib-
+	sieve/sieve-validator.c:
+	Made regex match complaint about comparators other than i;octet or i
+	;ascii-casemap
+	[ebf35c004764]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Added support for match-type argument context validation.
+	[9db6e7335e9e]
+
+	* src/lib-sieve/sieve-validator.c:
+	Added support for argument context validation.
+	[7dcaf16bcf7d]
+
+	* src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-match-types.c, src/lib-sieve/sieve-validator.c, src/lib-sieve
+	/tst-size.c:
+	Added validat_context method to command arguments for the to-be-
+	implemented argument context validation.
+	[754320bac6bb]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-commands.c,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-comparators.c,
+	src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-match-types.c:
+	Changed argument generator function prototype to assign
+	responsibility of advancing to the next argument to the generator
+	itself.
+	[6ba97a809b25]
+
+	* src/lib-sieve/sieve-commands.c:
+	Removed i_unreached() at inappropriate location.
+	[80a6ca8aa099]
+
+	* src/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-commands.h, src/lib-sieve
+	/sieve-validator.c:
+	Removed code duplication in validator: merged command and test
+	validation in one function.
+	[55047d9405c9]
+
+	* src/lib-sieve/sieve-validator.c:
+	Fixed bug in the command validation.
+	[0f7c34ca82a9]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-require.c, src/lib-sieve
+	/sieve-commands.h:
+	Improved validation of command placement for if and require
+	commands.
+	[7666f12ccc2a]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve
+	/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-commands-
+	private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-
+	commands.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-allof.c,
+	src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve
+	/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-size.c:
+	Changed validator's command syntax validation such that command
+	implementations don't have to call the argument, test and block
+	validation functions explicitly.
+	[e43df7ab9749]
+
+2007-11-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-redirect.c, src/lib-sieve
+	/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-
+	fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.h,
+	src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/sieve-validator.h, src/lib-sieve/tst-address.c, src/lib-
+	sieve/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src
+	/lib-sieve/tst-size.c:
+	Changed argument validation to record the first positional argument
+	into the command context by default. Also furter improved
+	validator's error handling.
+	[d357da9effa4]
+
+	* sieve/errors/address-errors.sieve, sieve/errors/header-errors.sieve,
+	src/lib-sieve/cmd-redirect.c, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/subaddress/subaddress.sieve,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-
+	ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve
+	/tst-header.c, src/lib-sieve/tst-size.c:
+	Revised positional argument checking and fixed the validator's error
+	handling.
+	[31ade1ddf884]
+
+	* src/lib-sieve/sieve-match-types.c:
+	Prevent unimplemented match type from causing a segfault.
+	[614e7a053e31]
+
+	* src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-
+	numeric.c, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-interpreter.h, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-header.c:
+	Implemented match type execution and activated match types :is and
+	:contains.
+	[44f7b3f89e34]
+
+2007-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README, src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c:
+	Minor updates to the documentation.
+	[033d7cb3a8dd]
+
+	* src/lib-sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Fixed code generation for relational extension.
+	[9aedfec64626]
+
+	* src/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-sieve/sieve-
+	match-types.c, src/lib-sieve/sieve-match-types.h:
+	Implemented support for additional parameters to match-types and
+	implemented validation for the relational extension.
+	[c49afa847933]
+
+	* configure.in, sieve/tests/match-type.sieve, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/regex/Makefile.am,
+	src/lib-sieve/plugins/regex/draft-murchison-sieve-regex-07.txt, src
+	/lib-sieve/plugins/regex/ext-regex.c, src/lib-
+	sieve/plugins/regex/regex.sieve, src/lib-
+	sieve/plugins/relational/Makefile.am, src/lib-
+	sieve/plugins/relational/ext-relational.c, src/lib-
+	sieve/plugins/relational/relational.sieve, src/lib-
+	sieve/plugins/relational/rfc3431.txt, src/lib-sieve/sieve-
+	extensions.c, src/sieve-bin/Makefile.am:
+	Created skeletons for regex and relational extensions. These are to
+	be developed simultaneously with the match-type support in general.
+	[f3db84e346eb]
+
+	* README, sieve/tests/match-type.sieve, src/lib-sieve/Makefile.am, src
+	/lib-sieve/ext-envelope.c, src/lib-sieve/sieve-address-parts.c, src
+	/lib-sieve/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-
+	sieve/sieve-extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-match-types.c, src
+	/lib-sieve/sieve-match-types.h, src/lib-sieve/sieve-validator.c, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Started implementation of match-type support and fixed compilation
+	error.
+	[b352686b0063]
+
+	* README, src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i
+	-ascii-numeric.c, src/lib-sieve/plugins/vacation/ext-vacation.c, src
+	/lib-sieve/sieve-comparators.c:
+	Updated README and a few minor cosmetic changes to the code.
+	[8eddb5ec9ddb]
+
+	* configure.in, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/Makefile.am, src/lib-sieve/plugins/comparator-i-ascii-
+	numeric/cmp-i-ascii-numeric.sieve, src/lib-
+	sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c,
+	src/lib-sieve/plugins/comparator-i-ascii-numeric/rfc2244.txt, src
+	/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions.c, src/lib-
+	sieve/tst-address.c, src/lib-sieve/tst-header.c, src/sieve-
+	bin/Makefile.am:
+	Implemented comparator-i;ascii-numeric extension and activated
+	comparator extension support.
+	[01386a471dc7]
+
+	* src/lib-sieve/sieve-extensions.c:
+	Added dummy extensions for core comparators.
+	[ae2e6fd6f94e]
+
+	* sieve/tests/extensions.sieve, src/lib-sieve/cmd-require.c, src/lib-
+	sieve/sieve-address-parts.c:
+	A few small cosmetic changes in addr-part code and generic extension
+	support.
+	[7b9f9e71030e]
+
+2007-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-sieve/sieve-
+	address-parts.c, src/lib-sieve/sieve-common.h:
+	Finished implementation of subaddress extension.
+	[05c4031e501e]
+
+	* configure.in, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/Makefile.am, src/lib-
+	sieve/plugins/subaddress/Makefile.am, src/lib-
+	sieve/plugins/subaddress/ext-subaddress.c, src/lib-
+	sieve/plugins/subaddress/rfc3598.txt, src/lib-
+	sieve/plugins/subaddress/subaddress.sieve, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	ast.h, src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h,
+	src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-commands.h, src
+	/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-validator.c, src/lib-sieve/tst-address.c, src
+	/lib-sieve/tst-size.c, src/sieve-bin/Makefile.am:
+	Implemented support for the subaddress extension and fixed extension
+	support to work properly.
+	[4e9f385adc07]
+
+2007-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/sieve-address-parts.c,
+	src/lib-sieve/sieve-address-parts.h, src/lib-sieve/tst-address.c:
+	Implemented address part execution support.
+	[af5ea3cdd396]
+
+2007-11-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/address-part.sieve, src/lib-sieve/ext-envelope.c, src
+	/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-address-
+	parts.h, src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h, src
+	/lib-sieve/sieve-validator.c, src/lib-sieve/tst-address.c:
+	Activated address-part code generation support.
+	[60ab1abd0d01]
+
+	* src/lib-sieve/sieve-address-parts.c, src/lib-sieve/sieve-ast.h, src
+	/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands-private.h, src/lib-sieve
+	/sieve-commands.c, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-comparators.c, src/lib-sieve/sieve-error.c, src/lib-sieve
+	/sieve-error.h, src/lib-sieve/sieve-extensions.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-lexer.c, src/lib-sieve
+	/sieve-lexer.h, src/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-
+	parser.h, src/lib-sieve/sieve-validator.h:
+	Lots of cosmetic changes
+	[19366331bc99]
+
+	* INSTALL, README:
+	Added a little documentation to the README file.
+	[2fd76028ca9b]
+
+	* src/lib-sieve/sieve-validator.c:
+	Removed unused static pre-declaration from validator.
+	[f745b4988763]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/Makefile.am, src/lib-
+	sieve/cmd-require.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-address-
+	parts.c, src/lib-sieve/sieve-address-parts.h, src/lib-sieve/sieve-
+	binary.c, src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c,
+	src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-comparators.c, src
+	/lib-sieve/sieve-comparators.h, src/lib-sieve/sieve-extensions.c,
+	src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-generator.c,
+	src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c,
+	src/lib-sieve/sieve-interpreter.h, src/lib-sieve/sieve-validator.c,
+	src/lib-sieve/sieve-validator.h, src/lib-sieve/sieve.c, src/lib-
+	sieve/sieve.h, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	header.c, src/sieve-bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Rewrote large parts of the extension support and added partial
+	address-part implementation.
+	[bbbf416d458c]
+
+2007-11-11  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/sieve-bin/Makefile.am, src/sieve-bin/sieve_test.c:
+	Upgraded sieve_test to 1.1.beta8
+	[beaeb564662c]
+
+	* src/lib-sieve/sieve-commands.c, src/lib-sieve/sieve-common.h, src
+	/lib-sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h,
+	src/lib-sieve/tst-address.c, src/lib-sieve/tst-header.c:
+	Enabled comparator execution support.
+	[5b4103b61afd]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/ext-envelope.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-
+	size.c:
+	Added support for optional operators to the byte code
+	implementation.
+	[9355ea520e77]
+
+2007-11-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-code.c, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-comparators.h, src/lib-sieve/sieve-extensions.h, src/lib-
+	sieve/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h:
+	Started implementation of comparator execution support.
+	[a3e2d0467235]
+
+2007-11-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-code.c, src/lib-sieve/sieve-code.h:
+	Changed string-list single-string handling for coded list.
+	[494b84c7dab4]
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-envelope.c, src/lib-sieve
+	/ext-fileinto.c, src/lib-sieve/ext-reject.c, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/tst-address.c, src/lib-sieve
+	/tst-allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c,
+	src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c:
+	Properly implemented opcode and operand handing and moved code to
+	more appropriate units.
+	[6d30cd3270b4]
+
+2007-11-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/examples/sieve_examples.sieve, sieve/examples/stephan.sieve,
+	sieve/examples/unparsed-elvey.sieve, src/lib-sieve/sieve-code.h:
+	A few minor changes
+	[8eb67ba19a03]
+
+	* sieve/examples/elvey.sieve, sieve/examples/jerry.sieve,
+	sieve/examples/mjohnson.sieve, sieve/examples/mklose.sieve,
+	sieve/examples/sanjay.sieve, sieve/examples/vivil.sieve:
+	Added sieve example and documented the others with author and the
+	url where I found them.
+	[36b747fc5a42]
+
+2007-10-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-interpreter.c, src
+	/lib-sieve/sieve-interpreter.h:
+	Moved literall access functions from interpreter to binary.
+	[df004c3d4967]
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-comparators.c, src/lib-sieve/sieve-comparators.h, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h:
+	Implemented comparator support towards code generation,
+	interpretation is not possible yet.
+	[c4eb303c242c]
+
+	* src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/plugins/vacation/ext-vacation.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-
+	header.c, src/lib-sieve/tst-size.c:
+	Changed argument to operand processing to be much more flexible.
+	[b07f5129b239]
+
+2007-10-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-binary.h, src/lib-
+	sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h:
+	Moved literal emission functions from generator to binary source.
+	[8d9c3aa76abf]
+
+	* sieve/tests/comparator.sieve, src/lib-sieve/Makefile.am, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-code.c, src/lib-sieve
+	/sieve-code.h, src/lib-sieve/sieve-commands.h, src/lib-sieve/sieve-
+	common.h, src/lib-sieve/sieve-comparators.c, src/lib-sieve/sieve-
+	comparators.h, src/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-
+	generator.h, src/lib-sieve/sieve-validator.c, src/lib-sieve/sieve-
+	validator.h, src/lib-sieve/tst-size.c:
+	First steps towards implementing code generation and interpretation
+	for proper comperators.
+	[8f8c18edbd39]
+
+	* src/lib-sieve/tst-exists.c:
+	Extremely minor cosmetic change.
+	[8b215ab7e80f]
+
+	* src/lib-sieve/plugins/Makefile, src/lib-sieve/plugins/Makefile.in:
+	Removed files with intermittent compilation results from the
+	repository (oops)
+	[3c56353ce681]
+
+	* sieve/tests/basic.sieve, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/tst-exists.c, src/lib-sieve/tst-header.c:
+	Made header and exists tests executable.
+	[38b4e757271d]
+
+2007-10-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* sieve/tests/basic.sieve, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve.c, src/lib-sieve/sieve.h, src
+	/lib-sieve/tst-address.c, src/lib-sieve/tst-size.c, src/sieve-
+	bin/Makefile.am, src/sieve-bin/sieve_test.c, src/sieve-bin/sievec.c:
+	Made address and size tests executable and fixed minor bug regarding
+	the lexer.
+	[931a0b442f19]
+
+	* .hgignore, src/lib-sieve/Makefile.am, src/lib-sieve/sieve-ast.c, src
+	/lib-sieve/sieve-generator.c, src/lib-sieve/sieve-generator.h, src
+	/lib-sieve/sieve-parser.c, src/lib-sieve/sieve-parser.h, src/lib-
+	sieve/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sieve.c, src/lib-sieve/sieve.h, src/sieve-bin/Makefile, src
+	/sieve-bin/Makefile.am, src/sieve-bin/Makefile.in, src/sieve-
+	bin/sieve_test.c, src/sieve-bin/sievec, src/sieve-bin/sievec.c, src
+	/sieve-bin/sievec.o:
+	Created libsieve interface and started the sieve_test binary.
+	[8d922df3dd5c]
+
+2007-10-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve
+	/ext-reject.c, src/lib-sieve/plugins/Makefile, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-ast.c,
+	src/lib-sieve/sieve-binary.c, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-commands.c, src/lib-sieve/sieve-generator.c, src/lib-
+	sieve/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-
+	sieve/sieve-lexer.c, src/lib-sieve/sieve-parser.c, src/lib-sieve
+	/sieve-result.c, src/lib-sieve/sieve-validator.c, src/lib-sieve/tst-
+	address.c, src/lib-sieve/tst-size.c, src/sieve-bin/Makefile, src
+	/sieve-bin/Makefile.am, src/sieve-bin/Makefile.in, src/sieve-
+	bin/sievec, src/sieve-bin/sievec.o:
+	Upgraded from dovecot-1.0 to dovecot-1.1 (array changes and various
+	_unref differences)
+	[f36e62f9baf9]
+
+	* configure.in, sieve/errors/address-errors.sieve, sieve/errors
+	/header-errors.sieve, sieve/errors/if-errors.sieve,
+	sieve/errors/interesting.sieve, sieve/errors/keep-errors.sieve,
+	sieve/errors/parse-errors.sieve, sieve/errors/require-errors.sieve,
+	sieve/errors/size-errors.sieve, sieve/errors/stop-errors.sieve,
+	sieve/errors/tag-errors.sieve, sieve/examples/elvey.sieve,
+	sieve/examples/mjohnson.sieve, sieve/examples/mklose.sieve,
+	sieve/examples/rfc3028.sieve, sieve/examples/sanjay.sieve,
+	sieve/examples/sieve_examples.sieve, sieve/examples/stephan.sieve,
+	sieve/examples/unparsed-elvey.sieve, sieve/examples/vacation.sieve,
+	sieve/examples/vivil.sieve, sieve/tests/basic.sieve,
+	sieve/tests/extensions.sieve, sieve/tests/if.sieve, src/Makefile.am,
+	src/lib-sieve/Makefile.am, src/lib-sieve/scripts/errors/address-
+	errors.sieve, src/lib-sieve/scripts/errors/header-errors.sieve, src
+	/lib-sieve/scripts/errors/if-errors.sieve, src/lib-
+	sieve/scripts/errors/interesting.sieve, src/lib-sieve/scripts/errors
+	/keep-errors.sieve, src/lib-sieve/scripts/errors/parse-errors.sieve,
+	src/lib-sieve/scripts/errors/require-errors.sieve, src/lib-
+	sieve/scripts/errors/size-errors.sieve, src/lib-sieve/scripts/errors
+	/stop-errors.sieve, src/lib-sieve/scripts/errors/tag-errors.sieve,
+	src/lib-sieve/scripts/examples/elvey.sieve, src/lib-
+	sieve/scripts/examples/mjohnson.sieve, src/lib-
+	sieve/scripts/examples/mklose.sieve, src/lib-
+	sieve/scripts/examples/rfc3028.sieve, src/lib-
+	sieve/scripts/examples/sanjay.sieve, src/lib-
+	sieve/scripts/examples/sieve_examples.sieve, src/lib-
+	sieve/scripts/examples/stephan.sieve, src/lib-sieve/scripts/examples
+	/unparsed-elvey.sieve, src/lib-
+	sieve/scripts/examples/vacation.sieve, src/lib-
+	sieve/scripts/examples/vivil.sieve, src/lib-
+	sieve/scripts/tests/extensions.sieve, src/lib-
+	sieve/scripts/tests/if.sieve, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/sieve-interpreter.h, src/lib-sieve/sieve-result.c, src/lib-
+	sieve/sievec.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	exists.c, src/lib-sieve/tst-header.c, src/lib-sieve/tst-size.c, src
+	/sieve-bin/Makefile, src/sieve-bin/Makefile.am, src/sieve-
+	bin/Makefile.in, src/sieve-bin/sievec, src/sieve-bin/sievec.c, src
+	/sieve-bin/sievec.o:
+	Exported sievec binary to separate directory called sieve-bin.
+	[f3dd838d3893]
+
+2007-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/cmd-if.c, src/lib-sieve
+	/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/vacation/Makefile.am, src/lib-
+	sieve/plugins/vacation/ext-vacation.c, src/lib-sieve/sieve-binary.c,
+	src/lib-sieve/sieve-binary.h, src/lib-sieve/sieve-code.c, src/lib-
+	sieve/sieve-code.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-common.h, src/lib-sieve/sieve-extensions.h, src/lib-sieve
+	/sieve-generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve
+	/sieve-interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-
+	sieve/sieve-result.c, src/lib-sieve/sieve-result.h, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-size.c:
+	Started first support for actual execution of sieve script.
+	[7d3b717d834d]
+
+	* src/lib-sieve/Makefile.am, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/sieve-interpreter.h, src/plugins/Makefile.am, src/plugins/lda-
+	sieve/Makefile.am, src/plugins/lda-sieve/lda-sieve-plugin.c,
+	src/plugins/lda-sieve/lda-sieve-plugin.h:
+	* Minor changes to the extension implementation
+	* Started the lda plugin source
+	[5252fd9fd951]
+
+2007-10-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/sieve-address.c:
+	Changed (currently unused) sieve-address.c to use dovecot rfc822
+	parser.
+	[d32cc88f0ecf]
+
+	* src/lib-sieve/plugins/vacation/draft-ietf-sieve-vacation-07.txt:
+	Added draft RFC for vacation extension.
+	[4f6590dd1d7e]
+
+	* configure.in, src/lib-sieve/Makefile.am, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/Makefile, src/lib-
+	sieve/plugins/Makefile.am, src/lib-sieve/plugins/Makefile.in, src
+	/lib-sieve/plugins/comparator-i;ascii-numeric.c, src/lib-
+	sieve/plugins/copy.c, src/lib-sieve/plugins/vacation/Makefile.am,
+	src/lib-sieve/plugins/vacation/ext-vacation.c, src/lib-
+	sieve/plugins/vacation/vacation.sieve, src/lib-
+	sieve/scripts/tests/extensions.sieve, src/lib-sieve/sieve-
+	extensions.c:
+	* Further developed the extension support
+	* Added plugins as static libraries (for now)
+	[2b26d303f3d1]
+
+	* src/lib-sieve/scripts/tests/extensions.sieve, src/lib-
+	sieve/scripts/tests/reject.sieve:
+	Renamed reject.sieve to extensions.sieve for generic extensions
+	testing.
+	[3993600b2e1f]
+
+	* src/lib-sieve/cmd-require.c, src/lib-sieve/ext-fileinto.c:
+	* Added generation support to the fileinto extension.
+	* Fixed a bug in the require command generation.
+	[4f38530232e6]
+
+	* .hgignore, src/lib-sieve/Makefile.am, src/lib-sieve/cmd-require.c,
+	src/lib-sieve/ext-envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-
+	sieve/ext-reject.c, src/lib-sieve/scripts/tests/reject.sieve, src
+	/lib-sieve/sieve-ast.h, src/lib-sieve/sieve-binary.c, src/lib-sieve
+	/sieve-binary.h, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sievec.c:
+	Added basic extension support to generator and interpreter.
+	[2f78fc8c9919]
+
+2007-10-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sieve/cmd-if.c, src/lib-sieve/ext-reject.c, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	commands-private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-extensions.h, src/lib-sieve/sieve-generator.c, src/lib-sieve
+	/sieve-generator.h, src/lib-sieve/sieve-interpreter.c, src/lib-sieve
+	/tst-address.c, src/lib-sieve/tst-allof.c, src/lib-sieve/tst-
+	anyof.c, src/lib-sieve/tst-exists.c, src/lib-sieve/tst-header.c, src
+	/lib-sieve/tst-size.c:
+	Initial commit didn't compile because it was comitted in the middle
+	of a new feature.
+	[b50c7ada434a]
+
+	* autogen.sh:
+	Added autogen.sh from the dovecot project (removed doc/wiki code)
+	[10ed2a377ea0]
+
+2007-10-21  stephan  <stephan@flappie>
+
+	* .hgignore, libsieve-config.h.in:
+	Added -config files to the hgignore and removed them from the
+	repository
+	[ddac82bec3c3]
+
+	* .hgignore, AUTHORS, COPYING.LGPL, INSTALL, Makefile.am, NEWS,
+	README, configure.in, libsieve-config.h.in, src/Makefile.am, src
+	/lib-sieve/Makefile.am, src/lib-sieve/cmd-if.c, src/lib-sieve/cmd-
+	redirect.c, src/lib-sieve/cmd-require.c, src/lib-sieve/ext-
+	envelope.c, src/lib-sieve/ext-fileinto.c, src/lib-sieve/ext-
+	reject.c, src/lib-sieve/plugins/comparator-i;ascii-numeric.c, src
+	/lib-sieve/plugins/copy.c, src/lib-sieve/scripts/errors/address-
+	errors.sieve, src/lib-sieve/scripts/errors/header-errors.sieve, src
+	/lib-sieve/scripts/errors/if-errors.sieve, src/lib-
+	sieve/scripts/errors/interesting.sieve, src/lib-sieve/scripts/errors
+	/keep-errors.sieve, src/lib-sieve/scripts/errors/parse-errors.sieve,
+	src/lib-sieve/scripts/errors/require-errors.sieve, src/lib-
+	sieve/scripts/errors/size-errors.sieve, src/lib-sieve/scripts/errors
+	/stop-errors.sieve, src/lib-sieve/scripts/errors/tag-errors.sieve,
+	src/lib-sieve/scripts/examples/elvey.sieve, src/lib-
+	sieve/scripts/examples/mjohnson.sieve, src/lib-
+	sieve/scripts/examples/mklose.sieve, src/lib-
+	sieve/scripts/examples/rfc3028.sieve, src/lib-
+	sieve/scripts/examples/sanjay.sieve, src/lib-
+	sieve/scripts/examples/sieve_examples.sieve, src/lib-
+	sieve/scripts/examples/stephan.sieve, src/lib-sieve/scripts/examples
+	/unparsed-elvey.sieve, src/lib-
+	sieve/scripts/examples/vacation.sieve, src/lib-
+	sieve/scripts/examples/vivil.sieve, src/lib-
+	sieve/scripts/tests/if.sieve, src/lib-sieve/sieve-address.c, src
+	/lib-sieve/sieve-ast.c, src/lib-sieve/sieve-ast.h, src/lib-sieve
+	/sieve-code.c, src/lib-sieve/sieve-code.h, src/lib-sieve/sieve-
+	commands-private.h, src/lib-sieve/sieve-commands.c, src/lib-sieve
+	/sieve-commands.h, src/lib-sieve/sieve-common.h, src/lib-sieve
+	/sieve-error.c, src/lib-sieve/sieve-error.h, src/lib-sieve/sieve-
+	extensions.c, src/lib-sieve/sieve-extensions.h, src/lib-sieve/sieve-
+	generator.c, src/lib-sieve/sieve-generator.h, src/lib-sieve/sieve-
+	interpreter.c, src/lib-sieve/sieve-interpreter.h, src/lib-sieve
+	/sieve-lexer.c, src/lib-sieve/sieve-lexer.h, src/lib-sieve/sieve-
+	parser.c, src/lib-sieve/sieve-parser.h, src/lib-sieve/sieve-
+	validator.c, src/lib-sieve/sieve-validator.h, src/lib-
+	sieve/sievec.c, src/lib-sieve/tst-address.c, src/lib-sieve/tst-
+	allof.c, src/lib-sieve/tst-anyof.c, src/lib-sieve/tst-exists.c, src
+	/lib-sieve/tst-header.c, src/lib-sieve/tst-not.c, src/lib-sieve/tst-
+	size.c, stamp.h.in:
+	First entered libsieve into new Hg repository
+	[d31c1c993bcf]
+
diff -urN dovecot-1.2.0/dovecot-libsieve/configure.in dovecot-1.2.0-sieve/dovecot-libsieve/configure.in
--- dovecot-1.2.0/dovecot-libsieve/configure.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/configure.in	2009-07-05 19:20:03.000000000 +0000
@@ -0,0 +1,114 @@
+AC_INIT([Dovecot Sieve], [0.1.7], [dovecot@dovecot.org], [dovecot-1.2-sieve])
+AC_CONFIG_SRCDIR([src])
+
+# Autoheader is not needed and does more harm than good for this package. However, it is 
+# tightly integrated in autoconf/automake and therefore it is difficult not to use it. As 
+# a workaround we give autoheader a dummy config header to chew on and we handle the 
+# real config header ourselves.
+AC_CONFIG_HEADERS([dummy-config.h dsieve-config.h])
+
+AC_DEFINE_UNQUOTED(SIEVE_NAME, "$PACKAGE_NAME", 
+	[Define to the full name of this Sieve implementation.])
+AC_DEFINE_UNQUOTED(SIEVE_VERSION, "$PACKAGE_VERSION", 
+	[Define to the version of this Sieve implementation.])
+
+AM_INIT_AUTOMAKE(no-define)
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[AC_HELP_STRING([--with-dovecot=DIR], [Dovecot base directory [../dovecot]])],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+old=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $old
+AC_SUBST(dovecotdir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  echo "WARNING: Cannot build Sieve commandline tools without the compiled"
+  echo "         Dovecot sources. Compiling against headers will only build"
+  echo "         the Sieve plugin." 
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+# Extensions under development
+#
+
+AC_ARG_WITH(unfinished-features,
+[AC_HELP_STRING([--with-unfinished-features], 
+	[Build unfinished new features/extensions [default=no]])],
+        if test x$withval = xno || test x$withval = xauto; then
+                want_unfinished_features=$withval
+        else
+                want_unfinished_features=yes
+        fi,
+        want_enotify=no)
+AM_CONDITIONAL(BUILD_UNFINISHED, test "$want_unfinished_features" = "yes")
+
+if test "$want_unfinished_features" = "yes"; then
+	AC_DEFINE(HAVE_SIEVE_UNFINISHED,,
+		[Define to build Sieve unfinished features/extensions.])
+fi
+
+#
+#
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/lib-sieve/Makefile
+src/lib-sieve/plugins/Makefile
+src/lib-sieve/plugins/vacation/Makefile
+src/lib-sieve/plugins/subaddress/Makefile
+src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile
+src/lib-sieve/plugins/relational/Makefile
+src/lib-sieve/plugins/regex/Makefile
+src/lib-sieve/plugins/imap4flags/Makefile
+src/lib-sieve/plugins/copy/Makefile
+src/lib-sieve/plugins/include/Makefile
+src/lib-sieve/plugins/body/Makefile
+src/lib-sieve/plugins/variables/Makefile
+src/lib-sieve/plugins/enotify/Makefile
+src/lib-sieve/plugins/environment/Makefile
+src/lib-sieve-tool/Makefile
+src/plugins/Makefile
+src/plugins/lda-sieve/Makefile
+src/sieve-tools/Makefile
+src/sieve-tools/debug/Makefile
+stamp.h])
+
+AC_OUTPUT
diff -urN dovecot-1.2.0/dovecot-libsieve/COPYING dovecot-1.2.0-sieve/dovecot-libsieve/COPYING
--- dovecot-1.2.0/dovecot-libsieve/COPYING	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/COPYING	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,4 @@
+See AUTHORS file for list of copyright holders.
+
+Everything is licenced under LGPLv2.1 (see /usr/share/common-licenses/LGPL-2.1)
+unless otherwise mentioned at the beginning of the file.
diff -urN dovecot-1.2.0/dovecot-libsieve/doc/devel/DESIGN dovecot-1.2.0-sieve/dovecot-libsieve/doc/devel/DESIGN
--- dovecot-1.2.0/dovecot-libsieve/doc/devel/DESIGN	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/doc/devel/DESIGN	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,45 @@
+The compiler consists of the following stages:
+
+PARSER: sieve-parser.c, sieve-lexer.c
+  Parses the scriptfile and produces an abstract syntax tree for it 
+  (sieve-ast.c). 
+
+VALIDATOR: sieve-validator.c
+  Performs contextual analysis on the ast produced by the parser. This checks 
+  for the validity of commands, tests and arguments. Also, the ast is decorated 
+  with any context data acquired during the process. This context is used by the 
+  last compiler stage. 
+
+GENERATOR: sieve-generator.c
+  This last compiler stage uses a visitor pattern to wander through the ast and 
+  produces sieve byte code (sieve-binary.c).
+
+The resulting (in-memory) binary can be fed to the interpreter for execution:
+
+INTERPRETER: sieve-interpreter.c 
+  The interpreter executes the byte code and produces a sieve_result object. 
+  This result is no more than just a collection of actions to be performed. 
+  During execution, action commands add actions to the result. Duplates and 
+  conflicts between actions are handled in this execution phase.
+
+RESULT: sieve-result.c sieve-actions.c
+  When the result is to be executed, it needs no further checking, as the 
+  validity of the result was verified during interpretation already. The 
+  result's actions are executed in a transaction-like atomic manner. If one of 
+  the actions fails, the whole transaction is rolled back meaning that either 
+  everything succeeds or everything fails. This is only possible to some extent:
+  transmitted responses can of course not be rolled back. However, these are 
+  executed in the commit phase, meaning that they will only be performed if all
+  other actions were successful.
+  
+Debugging:
+
+BINARY-DUMPER: sieve-code-dumper.c sieve-binary-dumper.c
+  A loaded binary can be dumped to a stream in human-readable form using the 
+  binary-dumper. The binary-dumper displays information on all the blocks that
+  the binary consists off. Program code blocks are dumped using the code-dumper.
+  It's implementation is similar to the interpreter, with the exception that it 
+  performs no actions and just sequentially wanders through the byte code 
+  printing instructions along the way. The term human-readable is a bit optimistic 
+  though; currently, the presented data looks like an assembly language. 
+
diff -urN dovecot-1.2.0/dovecot-libsieve/doc/man/sievec.1 dovecot-1.2.0-sieve/dovecot-libsieve/doc/man/sievec.1
--- dovecot-1.2.0/dovecot-libsieve/doc/man/sievec.1	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/doc/man/sievec.1	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,65 @@
+.TH "SIEVEC" "1" "4 July 2009"
+.SH NAME
+sievec \- Sieve script compiler for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sievec [\fB-d\fR] [\fB-x\fR "\fIextension extension ...\fR"] \fIscript-file\fR [\fIout-file\fR]
+.SH DESCRIPTION
+.PP
+The \fBsievec\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsievec\fP command, Sieve scripts can be compiled into a binary representation. 
+The resulting binary can be used directly to process e-mail messages during the delivery process. 
+The delivery of mail messages and therefore also the execution of Sieve scripts is  
+performed by Dovecot's local delivery agent (LDA) called \fBdeliver\fP. Usually, it is not 
+necessary to compile the Sieve script manually using \fBsievec\fP, because \fBdeliver\fP will do 
+this automatically if the binary is missing. However, in some cases \fBdeliver\fP does not have 
+permission to write the compiled binary to disk, forcing it to recompile the script every time it 
+is executed. Using the \fBsievec\fP tool, this can be performed manually by an authorized user to 
+increase performance.
+.PP
+The \fBsievec\fP command accepts two arguments: the \fIscript-file\fP argument specifies the 
+script to be compiled and the \fIout-file\fR argument specifies where the (binary) output is to
+be written. This Sieve implementation reconizes files with a \fB.sieve\fP extension as Sieve 
+scripts and corresponding files with a \fB.svbin\fP extension as the associated compiled binary. 
+This means for example that Dovecot's deliver process will look for a binary file 'dovecot.svbin' 
+when it needs to execute 'dovecot.sieve'. Such filename is chosen automatically for the binary output
+when the out-file argument is missing.
+.PP
+If the \fIscript-file\fP  argument is a directory, all files in that directory with a \fI.sieve\fP 
+extension are compiled into a corresponding \fI.svbin\fP binary file. The compilation is not halted 
+upon errors; it attempts to compile as many scripts in the directory as possible. Note that the 
+\fB-d\fP option and the \fIout-file\fP argument are not allowed when the \fIscript-file\fP argument 
+is a directory.
+.PP
+The \fBsievec\fP command is also useful to verify Sieve scripts before using. Additionally, with 
+the \fB-d\fP option it can output a textual (and thus human-readable) dump of the generated Sieve
+code to the specified file. The output is then identical to what the \fBsieved\fP(1) command produces
+for a stored binary file. This output is mainly useful to find bugs in the compiler that yield corrupt 
+binaries.
+.SH OPTIONS
+.TP 
+\fB-d\fP 
+Don't write the binary to \fIout-file\fP, but write a textual dump of the binary in 
+stead. In this context, the \fIout-file\fP value '-' has special meaning: it causes the the textual 
+dump to be written to \fBstdout\fP. The \fIout-file\fP argument may also be omitted, which has 
+the same effect as '-'. The output is identical to what the \fBsieved\fP(1) command produces for 
+a compiled Sieve binary file. Note that this option is not allowed when the \fIout-file\fP argument
+is a directory.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The \fIextensions\fP parameter is a space-separated list of the 
+active extensions. Unknown extensions are ignored, but a warning is produced.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sieved (1),
+.BR sieve-test (1)
+
diff -urN dovecot-1.2.0/dovecot-libsieve/doc/man/sieved.1 dovecot-1.2.0-sieve/dovecot-libsieve/doc/man/sieved.1
--- dovecot-1.2.0/dovecot-libsieve/doc/man/sieved.1	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/doc/man/sieved.1	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,48 @@
+.TH "SIEVED" "1" "4 July 2009"
+.SH NAME
+sieved \- Sieve script binary dump tool for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sieved [\fB-x\fR "\fIextension extension ...\fR"] \fIsieve-binary\fR [\fIout-file\fR]
+.br
+.SH DESCRIPTION
+.PP
+The \fBsieved\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsieved\fP command, Sieve binaries, which are produced for instance by
+\fBsievec\fP(1), can be transformed into a human-readable textual representation. This can 
+provide valuable insight in how the Sieve script is executed. This is also particularly useful 
+to view corrupt binaries that can result from bugs in the Sieve implementation. This tool is 
+intended mainly for development purposes, so normally system administrators and users will not 
+need to use this tool.
+.PP
+The \fIsieve-binary\fR argument specifies the Sieve binary file that needs to be dumped. The
+optional \fIout-file\fR argument specifies where the output must be written. If omitted, the
+output is written to \fBstdout\fR.
+.PP
+The format of the output is not explained here in detail, but it should be relatively easy
+to understand. The Sieve binaries comprise a set of data blocks, each of which can contain
+arbitrary data. For the base language implementation two blocks are used: the first containing
+a specification of all required language extensions and the second containing the main Sieve
+program. Compiled Sieve programs are represented as flat byte code and therefore the dump of
+the main program is a disassembly listing of the interpreter operations. Extensions can define 
+new operations and use additional blocks. Therefore, the output of \fBsieved\fP depends greatly
+on the language extensions used when compiling the binary. 
+.SH OPTIONS
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The option's parameter is a space-separated list of the active
+extensions. Unknown extensions are ignored, but a warning is produced.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieve-test (1)
+
diff -urN dovecot-1.2.0/dovecot-libsieve/doc/man/sieve-test.1 dovecot-1.2.0-sieve/dovecot-libsieve/doc/man/sieve-test.1
--- dovecot-1.2.0/dovecot-libsieve/doc/man/sieve-test.1	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/doc/man/sieve-test.1	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,123 @@
+.TH "SIEVE-TEST" "1" "4 July 2009"
+.SH NAME
+sieve-test \- Sieve script tester for the Dovecot secure IMAP server
+.SH SYNOPSIS
+sieve-test
+[\fB-c\fR] 
+[\fB-d\fR \fIdump-file\fR]
+[\fB-e\fR]
+[\fB-f\fR \fIenvelope-sender\fR]
+[\fB-l\fR \fImail-location\fR]
+[\fB-m\fR \fIdefault-mailbox\fR]
+[\fB-r\fR \fIrecipient-address\fR]
+[\fB-s\fR \fIscript-file\fR]
+[\fB-t\fR]
+[\fB-x\fR "\fIextension extension ...\fR"]
+\fIscript-file\fR \fImail-file\fR
+.SH DESCRIPTION
+.PP
+The \fBsieve-test\fP command is part of the Sieve implementation for the Dovecot secure 
+IMAP server. Sieve (RFC 5228) is a simple and highly extensible language for filtering 
+e-mail messages. It can be implemented for any type of mail access protocol, mail 
+architecture and operating system. The language cannot execute external programs and in 
+its basic form it does not provide the means to cause infinite loops, making it suitable 
+for running securely on mail servers where mail users have no permission run arbitrary programs.
+.PP
+Using the \fBsieve-test\fP command, the execution of Sieve scripts can be tested. This evaluates
+the script for the provided message, yielding a set of Sieve actions. Unless the \fB-e\fP option is 
+specified, it does not actually execute these actions, meaning that it does not store or forward the 
+message anywere. In stead, it prints a detailed list of what actions would normally take place. 
+Note that, even when \fB-e\fP is specified, no messages are ever transmitted to remote SMTP 
+recipients. The outgoing messages are printed to \fBstdout\fP in stead. 
+.PP
+This is a very useful tool to debug the execution of Sieve scripts. It can be used to verify
+newly installed scripts for the intended behaviour and it can provide more detailed information
+about script execution problems that are reported by the Sieve plugin.
+.PP
+The command has two mandatory arguments: the \fIscript-file\fP argument, which specifies the
+script to (compile and) execute, and the \fImail-file\fP argument, which specifies the file 
+containing the e-mail message to filter. 
+
+Note that this tool looks for a pre-compiled binary file with a \fI.svbin\fP extension and 
+with basename and path identical to the specified script. Use the \fB-c\fP option to disable this
+behavior by forcing the script to be compiled into a new binary.  
+.SH OPTIONS
+.TP 
+\fB-c\fP
+Force compilation. By default, the compiled binary is stored on disk. When this binary is found
+during the next execution of \fBsieve-test\fP and its modification time is more recent than the
+script file, it is used and the script is not compiled again. This option forces the script to be
+compiled, thus ignoring any present binary. Refer to \fBsievec\fP(1) for more information about 
+Sieve compilation.
+.TP
+\fB-d\fP \fIdump-file\fP
+Causes a dump of the generated code to be written to the specified file. This is identical to the
+dump produced by \fBsieved\fR(1). Using '-' as filename causes the dump to be written to \fBstdout\fP.
+.TP
+\fB-e\fP
+Turns on true execution of the set of actions that results from running the script. In combination
+with the \fB-l\fP parameter, the actual delivery of messages can be tested. Note that this will
+not transmit any messages to remote SMTP recipients. Such actions only print the outgoing message
+to \fBstdout\fP.
+.TP
+\fB-f\fP \fIenvelope-sender\fP
+The envelope sender or return path. This is what Sieve's envelope test will compare to when the 
+"from" envelope part is requested. Also, this is where response messages are sent to. 
+.TP
+\fB-l\fP \fImail-location\fP
+The location of the user's mail store. The syntax of this option's \fImail-location\fP parameter 
+is identical to what is used for the mail_location setting in the Dovecot config file. This 
+parameter is typically used in combination with \fB-e\fP to test the actual delivery of messages. 
+If \fB-l\fP is omitted when \fB-e\fP is specified, mail store actions like fileinto and keep are 
+skipped.
+.TP
+\fB-m\fP \fIdefault-mailbox\fP
+The mailbox where the keep action stores the message. This is "INBOX" by default.
+.TP
+\fB-r\fP \fIrecipient-address\fP
+The envelope recipient address. This is what Sieve's envelope test will compare to when the "to"
+envelope part is requested. Some tests and actions will also use this as the owner's e-mail address.
+.TP
+\fB-s\fP \fIscript-file\fP
+Specify additional scripts to be executed before the main script. Multiple \fB-s\fP arguments are
+allowed and the specified scripts are executed sequentially in the order specified at the command
+line.
+.TP
+\fB-t\fP
+Enable simple trace debugging; prints all encountered byte code instructions to \fBstdout\fP. This is
+currently only intelligible for developers.
+.TP
+\fB-x\fP "\fIextension extension ...\fP"
+Set the available extensions. The option's parameter is a space-separated list of the active 
+extensions. Unknown extensions are ignored, but a warning is produced.
+.SH DEBUG SUPPORT
+.PP
+To improve script debugging, the Sieve command line tools such as \fBsieve-test\fP support a custom
+Sieve language extension called 'vnd.dovecot.debug'. It adds the \fBdebug_print\fP command that allows
+printing debug messages to \fBstdout\fP. 
+.PP
+Example:
+.PP
+require "vnd.dovecot.debug";
+.PP
+if header :contains "subject" "hello" {
+.PP
+  debug_print "Subject header contains hello!";
+.PP
+}
+.PP
+Other tools like \fBsievec\fP and \fBsieved\fP also recognize the vnd.dovecot.debug extension. In contrast,
+the actual Sieve plugin for Deliver does not allow the use of the debug extension. So, keep in mind that 
+scripts and compiled binaries that refer to de debug extension will fail to be run by the Sieve plugin itself.
+.PP
+Note that it is not necessary to enable nor possible to disable the availability of the debug extension with 
+the \fB-x\fP option.
+.SH AUTHOR
+.PP
+The Sieve implementation for Dovecot was written by Stephan Bosch <stephan@rename-it.nl>.
+.PP
+Dovecot was written by Timo Sirainen <tss@iki.fi>.
+.SH "SEE ALSO"
+.BR sievec (1),
+.BR sieved (1)
+
diff -urN dovecot-1.2.0/dovecot-libsieve/dsieve-config.h.in dovecot-1.2.0-sieve/dovecot-libsieve/dsieve-config.h.in
--- dovecot-1.2.0/dovecot-libsieve/dsieve-config.h.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/dsieve-config.h.in	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,9 @@
+
+/* Define to the full name of this Sieve implementation. */
+#undef SIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef SIEVE_VERSION
+
+/* Define to make Sieve enotify extension available to users. */
+#undef HAVE_SIEVE_UNFINISHED
diff -urN dovecot-1.2.0/dovecot-libsieve/dummy-config.h.in dovecot-1.2.0-sieve/dovecot-libsieve/dummy-config.h.in
--- dovecot-1.2.0/dovecot-libsieve/dummy-config.h.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/dummy-config.h.in	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,62 @@
+/* dummy-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to build Sieve unfinished features/extensions. */
+#undef HAVE_SIEVE_UNFINISHED
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to the full name of this Sieve implementation. */
+#undef SIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef SIEVE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/elvey.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/elvey.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/elvey.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/elvey.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,153 @@
+# Example Sieve Script
+#   Author: Matthew Elvey (Slightly modified to remove syntax and context errors)
+#   URL: http://www.elvey.com/it/sieve/SieveScript.txt
+
+# Initial version completed and put in place 4/1/02 by Matthew Elvey  (firstname@lastname.com ; I've checked and it's not a valid address.); Copyright (C).and.current as of 5/19/2002 
+#Change log:
+#+ spam[:high]; major reordering; +DFC,BugTraq, PB up +Economist, FolderPath corrections 
+#+ redid .0 matches. +Korean + whitelist +@f(useful once I start bouncing mail!)
+#+open mag, simplifications, to fm=spamNOTwhite, Bulk changes, IETF rules, +lst
+#Reword spam bounce.+scalable@ re-correction+++Work+activate Spam Optimization, etc...
+#oops high = 2x threshold, so 2x1 is 2!  Too low. To @fm:bounce.  Added tons of comments.
+require ["fileinto", "reject", "vacation", "envelope", "regex"];
+
+if header :contains "subject" ["un eject", "lastname.com/spamoff.htm agreed to"] {  #I give out "uneject" to people to let them bypass the spam or size filters.
+  keep;
+} elsif header :contains "subject" ["ADV:", "bounceme", "2002 Gov Grants",   #bounceme is useful for testing.
+             "ADV:ADLT", "ADV-ADULT", "ADULT ADVERTISEMENT"] {  #Subject text required by various US State laws
+  reject text: 
+  Hello.  The server content filter/spam detector I use has bounced your message. It appears to be spam. 
+
+  I do not accept spam/UCE (Unsolicited Commercial Email). 
+
+Please ask me how to bypass this filter if your email is not UCE.  In that case, I am sorry about this 
+highly unusual error.  The filter is >99% accurate.
+
+  (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+  -Firstname
+
+  (P.S. You may also override the filter if you accept the terms at http://www.lastname.com/spamoff.htm, 
+         by including "lastname.com/spamoff.htm agreed to." in the subject.)
+.
+   ;
+}
+# LINE 30.
+  elsif size :over 10M {    # (note that the four leading dots get "stuffed" to three)
+
+  reject text:
+   Message NOT delivered!
+   This system normally accepts email that is less than 10MB in size, because that is how I configured it.
+   You may want to put your file on a server and send me the URL.
+   Or, you may request override permission and/or unreject instructions via another (smaller) email.
+   Sorry for the inconvenience.
+
+   Thanks,
+
+.... Firstname
+   (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+   Unsolicited advertising sent to this E-Mail address is expressly prohibited 
+   under USC Title 47, Section 227.  Violators are subject to charge of up to 
+   $1,500 per incident or treble actual costs, whichever is greater.
+.
+  ; 
+#LINE 47.
+} elsif header :contains "From" "Firstname@lastname.com" {	#if I send myself email, leave it in the Inbox.
+  keep;			#next, is the processing for the various mailing lists I'm on.  
+} elsif header :contains ["Sender", "X-Sender", "Mailing-List", "Delivered-To", "List-Post", "Subject", "To", "Cc", "From", "Reply-to", "Received"] "burningman" {
+  fileinto "INBOX.DaBurn";
+} elsif header :contains ["Subject", "From", "Received"] ["E*TRADE", "Datek", "TD Waterhouse", "NetBank"] {
+  fileinto "INBOX.finances.status";
+} elsif header :contains "subject" "\[pacbell" {
+  fileinto "INBOX.pacbell.dslreports";
+} elsif header :contains "From" ["owner-te-wg ", "te-wg ", "iana.org"] {
+  fileinto "INBOX.lst.IETF";
+} elsif header :contains ["Mailing-List", "Subject", "From", "Received"] ["Red Hat", "Double Funk Crunch", "@economist.com", "Open Magazine", "@nytimes.com", "mottimorell", "Harrow Technology Report"] {
+  fileinto "INBOX.lst.interesting";
+} elsif header :contains ["Mailing-List", "Subject", "From", "Received", "X-LinkName"] ["DJDragonfly", "Ebates", "Webmonkey", "DHJ8091@aol.com", "Expedia Fare Tracker", "SoulShine", "Martel and Nabiel", "\[ecc\]"] {
+  fileinto "INBOX.lst.lame";
+} elsif header :contains ["Subject", "From", "To"] ["guru.com", "monster.com", "hotjobs", "dice.com", "linkify.com"] {  #job boards and current clients.
+  fileinto "INBOX.lst.jobs";
+} elsif header :contains "subject" "\[yaba" {
+  fileinto "INBOX.rec.yaba";
+} elsif header :contains ["to", "cc"] "scalable@" {
+  fileinto "INBOX.lst.scalable";
+} elsif header :contains ["Sender", "To", "Return-Path", "Received"] "NTBUGTRAQ@listserv.ntbugtraq.com" {
+  fileinto "INBOX.lst.bugtraq";
+} elsif header :contains "subject" "Wired" {
+  fileinto "INBOX.lst.wired";
+#LINE 72.
+} elsif anyof (header :contains "From" ["postmaster", "daemon", "abuse"], header :contains "Subject" ["warning:", "returned mail", "failure notice", "undelivered mail"] ) {
+keep;		#this one is important - don't want to miss any bounce messages!
+#LINE 77.
+} elsif anyof (header :contains "From" ["and here I put a whitelist of pretty much all the email addresses in my address book - it's several pages..."]) {
+  fileinto "INBOX.white"; 
+# better than keep;
+# LINE 106.
+
+
+} elsif anyof (address :all :is ["To", "CC", "BCC"] "Firstname.lastname@fastmail.fm",    #a couple people send to this, but I have have all their addrs in whitelist so OK.
+           header :matches "X-Spam-score"  ["9.?" , "10.?", "9", "10", "11.?", "12.?" ,"13.?", "14.?", "11", "12","13", "14", "15.?", "16.?", "17.?" ,"18.?", "19.?", "15", "16", "17" ,"18", "19", "2?.?", "2?", "3?.?" , "3?", "40"]) { 		 #"5.?", "6.?", "5", "6" "7.?" , "8.?" , "7", "8"
+  reject text: 
+  Hello.  The server content filter/spam detector I use has bounced your message. It appears to be spam. 
+
+  I do not accept spam/UCE (Unsolicited Commercial Email). 
+
+Please ask me how to bypass this filter if your email is not UCE.  In that case, I am sorry about this 
+highly unusual error.  The filter is >99% accurate.
+
+  (This is an automated message; I will not be aware that your message did not get through if I do not hear from you again.)
+
+  -Firstname
+
+  (P.S. You may also override the filter if you accept the terms at http://www.lastname.com/spamoff.htm, 
+         by including "lastname.com/spamoff.htm agreed to." in the subject.)
+.
+   ;
+#LINE 127.
+ 
+} elsif 
+header :matches "X-Spam" ["spam", "high"] { if					#optimization idea line 1/2
+           header :matches "X-Spam-score" ["5.?", "6.?", "5", "6"] { 
+  fileinto "INBOX.Spam.5-7"; 
+} elsif header :matches "X-Spam-score" ["7.?" , "8.?" , "7", "8"] { 
+  fileinto "INBOX.Spam.7-9"; 
+#} elsif header :matches "X-Spam-score" ["9.?" , "10.?" , "9", "10"] { 	#These lines obsoleted by reject text rule above, but others will find 'em useful!
+#  fileinto "INBOX.Spam.9-11"; 
+#} elsif header :matches "X-Spam-score" ["11.?" , "12.?" ,"13.?" , "14.?", "11" , "12" ,"13" , "14"] { 
+#  fileinto "INBOX.Spam.11-15"; 
+#} elsif header :matches "X-Spam-score" ["15.?" , "16.?" ,"17.?" ,"18.?" , "19.?", "15" , "16" ,"17" ,"18" , "19"] { 
+#  fileinto "INBOX.Spam.15-20"; 
+#} elsif header :matches "X-Spam-score" ["2?.?", "2?" ] {
+#  fileinto "Inbox.Spam.20-30";
+#} elsif header :matches "X-Spam-score" ["3?.?" , "3?", "40"] {
+#fileinto "Inbox.Spam.30-40";
+ }											#optimization idea  line 2/2 
+
+#LINE 149.
+	
+} elsif header:contains ["Content-Type","Subject"] ["ks_c_5601-1987","euc_kr","euc-kr"]{
+  fileinto "Inbox.Spam.kr";								#block Korean; it's prolly spam and I certainly can't read it.
+} elsif header :contains "Received" "yale.edu" {
+  fileinto "INBOX.Yale";								#if it made it past all the filters above, it's probably of interest.
+      } elsif anyof (header :contains "Subject" ["HR 1910", "viagra", "MLM", "               ","	" ], # common in spam.  (prolly redundant to SpamAssassin.)
+      not exists ["From", "Date"], 						#RFC822 violations common in spam.
+      header :contains ["Sender", "X-Sender", "Mailing-List", "X-Apparently-From", "X-Version", "X-Sender-IP", "Received", "Return-Path", "Delivered-To", "List-Post", "Date", "Subject", "To", "Cc", "From", "Reply-to", "X-AntiAbuse", "Content-Type", "Received", "X-LinkName"] ["btamail.net.cn", "@arabia.com" ] ) {               #spam havens.
+  fileinto "INBOX.GreyMail";
+} elsif header :contains ["Precedence", "Priority", "X-Priority", "Mailing-List", "Subject", "From", "Received", "X-LinkName"] ["Bulk", "Newsletter"] {
+  fileinto "INBOX.Bulk Precedence";
+} elsif header :contains ["to", "cc", "Received"] ["IT@lastname.com", "mail.freeservers.com"] {
+  fileinto "INBOX.lastname.IT";
+} elsif header :contains ["To", "CC"] "Firstname@lastname.com" {
+  fileinto "INBOX.lastname.non-BCC";
+}
+#LINE 167.
+#END OF SCRIPT.  Implied 'keep' is part of the Sieve spec.
+
+
+
+
+
+ 
+
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/jerry.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/jerry.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/jerry.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/jerry.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,224 @@
+# Example Sieve Script
+#   Author: Jerry
+#   URL: http://www.emaildiscussions.com/showthread.php?postid=145322#post145322
+
+require ["fileinto", "reject", "vacation", "regex", "relational",
+"comparator-i;ascii-numeric"];
+
+
+#### BLACKLIST - BOUNCE ANYTHING THAT MATCHES
+#    From individual addresses
+         if header :contains "from"
+         [
+           "username@example.com",
+           "username@example.net"
+         ]
+         { reject "Message bounced by server content filter"; stop; }
+
+#    From domains
+         elsif header :contains "from"
+         [
+           "example.com",
+           "example.net"
+         ]
+         { reject "Message bounced by server content filter"; stop; }
+
+
+
+#### BLACKLIST - DELETE ANYTHING THAT MATCHES
+#    From individual addresses
+         elsif header :contains "from"
+         [
+           "username@example.com",
+           "username@example.net"
+         ]
+         { discard; stop; }
+
+#    From domains
+         elsif header :contains "from"
+         [
+           "example.com",
+           "example.net"
+         ]
+         { discard; stop; }
+
+#    I just added the following section after the joe-job
+#    that we all suffered at the hands of "inbox.com".
+#    The "myusername" is MY username at FastMail.
+#    DISCARDing this mail instead of directing it to a
+#    SPAM folder kept me from going over quota repeatedly.
+
+#    To individual addresses
+         elsif header :contains "to"
+         [
+           "myusername@inbox.com",
+           "myusername@example.net"
+         ]
+         { discard; stop; }
+
+         elsif  allof
+             (
+                 not anyof
+                 (
+#### WHITELIST - KEEP ANYTHING THAT MATCHES
+#    From individual addresses
+                     header :contains "from"
+                     [
+                       "username@example.com",
+                       "username@example.net"
+                     ],
+
+#    From trusted domains
+                     header :contains "from"
+                     [
+                       "example.com",
+                       "example.net"
+                     ],
+
+#    Specific "to" address (mailing lists etc)
+                     header :contains ["to", "cc"]
+                     [
+                       "username@example.com",
+                       "username@example.net"
+                     ],
+
+#    Specific "subject" keywords
+                     header :contains "subject"
+                     [
+                       "code_word_for_friend_#1",
+                       "code_word_for_friend_#2"
+                     ]
+
+                 ),
+                 anyof
+                 (
+
+#    Filter by keywords in subject or from headers
+                     header :contains ["subject", "from"]
+                     [
+                       "adilt", "adult", "advertise", "affordable",
+                       "as seen on tv", "antenna", "alarm",
+                       "background check", "bankrupt", "bargain",
+                       "best price", "bikini", "boost reliability",
+                       "brand new", "breast", "business directory",
+                       "business opportunity", "based business", "best
+                       deal", "bachelor's", "benefits", "cable",
+                       "career", "casino", "celeb", "cheapest", "child
+                       support", "cd-r", "catalog", "classified ad",
+                       "click here", "coed", "classmate", "commerce",
+                       "congratulations", "credit", "cruise", "cds",
+                       "complimentary", "columbia house", "crushlink",
+                       "debt", "detective", "diploma", "directv",
+                       "directtv", "dish", "dream vacation", "deluxe",
+                       "drug", "dvds", "dvd movie", "doubleclick",
+                       "digital tv", "erotic", "exciting new",
+                       "equalamail", "fantastic business", "fat
+                       burning", "financial independence", "finalist",
+                       "for life", "financing", "fitness", "fixed
+                       rate", "four reports", "free!", "free
+                       business", "from home", "funds", "fbi know",
+                       "fortune", "gambl", "getaway", "girls", "great
+                       price", "guaranteed", "get big", "get large",
+                       "giveaway", "hard core", "hardcore", "home
+                       document imaging", "home employment directory",
+                       "homeowner", "home owner", "homeworker", "home
+                       security", "home video", "immediate release",
+                       "information you requested", "income",
+                       "inkjet", "insurance", "interest rate",
+                       "invest", "internet connection", "join price",
+                       "judicial judgment", "just released", "know
+                       your rights", "legal", "license", "loan", "long
+                       distance", "look great", "low interest",
+                       "low-interest", "low rate", "lust", "lbs",
+                       "make money", "market", "master card",
+                       "mastercard", "meg web", "merchant account",
+                       "millionaire", "mini-vacation", "mortgage",
+                       "master's", "magazine", "nasty", "new car",
+                       "nigeria", "nude", "nympho", "naked",
+                       "obligation", "online business", "opportunity",
+                       "pager", "paying too much", "pda", "penis",
+                       "pennies", "pills", "porn", "pounds",
+                       "pre-approved", "prescri", "prscri", "prize",
+                       "prostate", "printer ink", "quote", "refinanc",
+                       "remove fat", "removing fat", "reward",
+                       "sales", "satellite", "saw your site",
+                       "scrambler", "sex", "smoking", "snoring", "some
+                       people succeed", "special invitation", "special
+                       offer", "stock", "saving", "singles", "teen",
+                       "ticket", "tired of", "truth about anyone",
+                       "the best", "ucking", "unbelievable",
+                       "uncensored", "uncollected", "unlimited", "USA
+                       domains", "urgent", "valium", "viagra",
+                       "venture capital", "virgin", "visa", "vitamin",
+                       "waist", "wealth", "webcam", "weight", "win a",
+                       "winner", "win one", "work smarter", "work at
+                       home", "xxx", "younger", "your web site", "your
+                       money", "your date is wait",
+                       "!!!", "$", "%", "10K"
+                     ],
+
+#    Filter when the subject is all uppercase (no lowercase)
+                     header :regex :comparator
+                     "i;octet" "subject" "^[^[:lower:]]+$",
+
+#    Filter using regular expressions on the subject
+                     header :regex    "subject"
+                     [
+                       "start.+business", "live.+auction",
+                       "discover.+card", "pay.+college", "apr$",
+                       "apr[^[:alnum:]]", "adv[^[:alnum:]]",
+                       "free.+(coupon|info|install|money)",
+                       "free.+(phone|sample|test|trial)",
+                       "(buy|sell).+(house|home)"
+                     ],
+
+#    Filter with tracker codes in the subject
+                     header :regex    "subject"
+                     "[[:space:].\-_]{4}#?\[?[[:alnum:]-]+\]?$",
+
+#    Filter spam with no to/from address set
+                     not exists    ["To", "From"],
+
+#    Filter spam not addressed to me
+#        Put here all of your own addresses (and alias) that you expect
+#        mail addressed to.  I found a lot of my spam didn't have my
+#        name in the TO or CC fields at all -- it must have been in the
+#        BCC (which doesn't show in the headers).  I can still get BCC
+#        mail from legitimate sources because everyone in my address
+#        book is on the WHITELIST above.
+
+                     not header :contains ["to", "cc"]
+                     [
+                       "myusername@example.com",
+                       "myusername@example.net"
+                     ]
+
+                 )
+             )
+         { fileinto "INBOX.1_spam"; }
+
+
+
+#### Virus Filter
+         elsif  header :contains ["subject", "from"]
+         [
+           "infected file rejected",
+           "infected file rejected"
+         ]
+         { fileinto "INBOX.1_virus"; }
+
+
+#### Telephone Alerts
+#        Any message that gets this far should not be spam,
+#        and a copy gets sent to my cell-phone as a TEXT message.
+
+         elsif  header :contains ["to", "cc"]
+         [
+           "myusername@example.com",
+           "myaliasname@example.com"
+         ]
+         { redirect "2135551234@mobile.example.net"; keep; }
+
+
+
+# END OF SCRIPT
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/mjohnson.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/mjohnson.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/mjohnson.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/mjohnson.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,421 @@
+# Example Sieve Script
+#  Author: Matthew Johnson
+#  URL: http://wiki.fastmail.fm/index.php?title=MatthewJohnson
+
+##########################################################################
+#######  SIEVE SCRIPT by Matthew Johnson - MRJ Solutions, Inc. ###########
+#######  Email me at mailto:mattjohnson2005@gmail.com ##
+#######  Code Version: 12JUN2004                               ###########
+##########################################################################
+require ["envelope", "fileinto", "reject", "vacation", "regex", "relational",
+         "comparator-i;ascii-numeric"];
+#
+# todo:
+# change to a nested format with
+#   allof()s and nots.
+# add "in address book" check. ex:"header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes""
+# finish reformating lines to <= 75 col (for web edit box)
+#   and delete rulers.
+# Mine Michael Klose script for ideas.
+# Check out the update to the Sieve pages on the Fastmail Wiki.
+#
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+require ["envelope", "fileinto", "reject", "vacation", "regex",
+         "relational", "comparator-i;ascii-numeric"];
+
+
+
+# BLACKLIST - Mails to discard, drop on the floor.
+#   -high spam values except those delivered to me
+#   -Chinese content except for low spam values
+#   -virus rejected notifications
+#   -known spam addresses
+#   -newsletters that refuse my removal requests
+#   -twit-list
+#   -double twit-list
+#   -other
+
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+if  anyof
+    (
+      allof       # combo test one - high spam values except for mail to/from me
+      (
+        # spam score is greater or equal to 14
+        header :value "ge" :comparator "i;ascii-numeric"
+                           ["X-Spam-score"] ["14"],
+        not header :contains "X-Spam-Score" "-",  
+        not header :contains "X-Spam-Score" "0.0",
+        not header :contains ["to","from","cc","bcc","received"]
+           [
+             # do not discard email to me, will file or discard
+             # as spam later if needed
+             "matt@zeta.net",
+             "matthew@bigsc.com",
+             "matthew_johnson@bigsmallcompany.com",
+             "mmm@spend.com",
+             "finger@spend.com",
+             "myyaacct@yahoo.com"
+           ]
+       ), # end allof
+      allof       #combo test two - chinese content except for low spam values
+      (
+        anyof
+        (
+           header :regex "Subject"  "^=\\?(gb|GB)2312\\?",  # Chinese ecoding at subject
+           header :regex "Subject"  "^=\\?big5\\?", # Other kind of  Chinese mail
+
+           # Chinese content type
+           header :contains "Content-Type"
+            [
+             "GB2312",
+             "big5"
+            ]
+        ), #end anyof
+        not anyof
+        (
+           #We have to check the sign and the value separately: ascii-numeric, defined at
+           #header :contains "X-Spam-Score" "-",
+           header :value "lt" :comparator "i;ascii-numeric" "X-Spam-Score" "3"
+         )  #end not anyof
+     ), # end allof - test two
+
+     # single tests
+
+     # discard fastmail virus notifications
+     header :is ["subject"] ["Infected file rejected"],
+
+     # black list, invalid addresses receiving a large amount of spam
+     # or spam bounces,rejected zeta.net accounts.
+     header :contains ["X-Delivered-to"]
+
+                        ["eagleeye@zeta.net","ealgeeye@zeta.net",
+                        "alica.thiele@zeta.net", "2005@theta.com",
+                        "jimlovingu2@zeta.net",
+                        "alpha@zeta.net",
+                        "JoshuaS@zeta.net",
+                        "donnaf@zeta.net",
+                        "pspinks@zeta.net",
+                        "jsherman@zeta.net",
+                        "holly@zeta.net",
+                        "clabarca@zeta.net",
+                        "meghanr@zeta.net",
+                        "rtaylor@zeta.net",
+                        "lboone@zeta.net",
+                        "brower@zeta.net",
+                        "jenj@zeta.net",
+                        "cbackus@zeta.net",
+                        "spengles@zeta.net",
+                        "adams@zeta.net",
+                        "dsmith@zeta.net",
+                        "jwilderman@zeta.net",
+                        "TimF@zeta.net",
+                        "zd@zeta.net",
+                        "louise@zeta.net"]
+
+     # single 'not' tests
+     # ---out for testing---  not header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes"
+    ) # end anyof()
+{
+   discard;
+   stop;
+}
+
+
+#
+# WHITELIST - Keep these mails and put them in the inbox
+#             (some kept getting put in Junk Mail)
+#             Family, Friends, Current Vendors, Customers
+#             Contents of fastmail address book.
+#
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+if  anyof (  header :contains ["from","to","cc","bcc"]
+                     [ "notification@eBay.com",
+                       "MAILER-DAEMON@zeta.net",
+                       "USPS_Track_Confirm@usps.com",
+                       "credit.services@target.com",
+                       "Comcast_Paydirect@comcast.net",
+                       "mary@zeta.net",
+                       "betty@zeta.net",
+                       "andmanymore@zeta.net"
+                       ],
+            header :is :comparator "i;octet" "X-Spam-Known-Sender" "yes"
+          )
+{
+  fileinto "INBOX";
+  stop;
+}
+
+# redirects
+if header :contains ["to", "cc"] "mary1@zeta.net"
+ {
+  redirect "mary@zeta.net";
+  stop;
+ }
+
+
+#
+#   +Spam filtering by score on 3, 5 and 14(above).
+#
+#
+if  header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["5"]  {
+    fileinto "INBOX.Junk Mail.ge5";
+    stop;
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+} elsif  header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["3"]  {
+    fileinto "INBOX.Junk Mail.ge3";
+    stop;
+}
+
+
+# Potential Blacklist, start with soft discard, then migrate to full discard above
+#
+# Blacklist (2nd) During testing, throw into "Junk Mail.discard" until
+#                 ready to discard.
+#
+if anyof
+   (
+    # rejects for accounts across all domains
+    header :contains ["X-Delivered-to"]
+                  [
+                  "drjoe@","VX@",
+                  "alfa@zeta.net",
+                  "media@zeta.net",
+                  "zeta@zeta.net",
+                  "xyz@zeta.net"
+                  ],
+
+    # other criteria - weird message from this account
+    header :contains ["from"] ["Charlie Root"],
+    # mailers that are always sending spam returns to me
+    header :contains ["from"] ["MAILER-DAEMON@aol.com"] ,
+    header :contains ["from"] ["MAILER-DAEMON@otenet.gr"] ,
+
+    # common account names that I don't use in any of my domains and that spammers like
+    header :contains ["X-Delivered-to"]
+                     [ "biz@","sales@","support@", "service@", "reg@",
+                       "registration@", "regisration@", "root@", "webmaster@", "noreply@"
+                     ],
+    # zeta.net common account names to reject
+    header :contains ["X-Delivered-to"] ["info@zeta.net"],
+    # bigsc.com  rejects
+    header :contains ["X-Delivered-to"] ["info@bigsc.com"],
+    # theta.com rejects
+    header :contains ["X-Delivered-to"] ["info@theta.com"],
+    header :contains ["X-Delivered-to"] ["reg@theta.com"]
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+        # saves for use maybe later
+        #   header :contains ["X-Delivered-to"] ["webmaster@zeta.net"],
+        #   header :contains ["X-Delivered-to"] ["webmaster@theta.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@bs.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@theta.com"],
+        #   header :contains ["X-Delivered-to"] ["sales@bigsc.com"],
+        #   header :contains ["X-Delivered-to"] "root@zeta.net",
+
+   )   #end  anyof() 2nd blacklist
+{
+
+  fileinto "INBOX.Junk Mail.discard";
+  stop;
+}
+
+
+#  +Greylist, move to "INBOX.Junk Mail.greylist"
+#
+#   'Soft' Blacklist  ?Greylist?
+#
+
+#annoying person(s) that send questionable attachments
+#  look at occationally
+if  header :contains "from" "alex@yahoo.com"
+{
+  fileinto "INBOX.Junk Mail.greylist";
+} elsif  header :contains "subject" "MAILER-DAEMON@fastmail.fm"
+                                     #  non-person, but might
+                                     # want to look at it while
+								     # figuring issues
+{
+  fileinto "INBOX.Junk Mail.greylist";
+  stop;
+}
+
+#   +Spammy domains to filter
+#
+# domains that are known to be present in spam
+#
+if  header :contains ["from", "received"] [".ru",".jp", ".kr", ".pt",
+					                     ".pl",".at",".cz",".cn",".lu" ]
+{
+  fileinto "INBOX.Junk Mail.discard";
+  stop;
+}
+
+
+#
+#  Annoying newsletters that won't unsubscribe me, reject
+#
+
+if anyof (
+           #annoying newsletters
+           header :contains ["from"] "VistaPrintNews",               # 2003
+           header :contains ["from"] "newsletter@briantracyintl.com", # 2003
+           header :contains ["from"] "info@yogalist.com",            # 2003
+           header :contains ["from"] "The Angela Larson Real Estate Team",
+           header :contains ["from"] "Brian Tracy"
+         )
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+{
+   reject "I HAVE TRIED TO UNSUBSCRIBE; I DO NOT WANT YOUR NEWSLETTER; PLEASE UNSUBSCRIBE ME";
+  stop;
+}
+
+
+
+
+#
+# Suspected zeta.net user from/to Zeta Institute, NY - reject
+#
+#
+#
+if    header :contains ["X-Delivered-to","from"]
+          [
+          # aaaaNEW_ENTRIES_ABOVE  ###################################
+          "neville@zeta.net",
+          "animika@zeta.net",
+          "linda@zeta.net",
+          "jerry@zeta.net",
+          "adamS@zeta.net",
+          "lkdamon@zeta.net",
+          "AdamS@zeta.net",
+          "DConnor@zeta.net",
+          "LOUISR@zeta.net",
+
+          # Start of Alpha #############################################
+          "Allanv@zeta.net",
+          "AmberJ@zeta.net",
+          "DANDERSON@zeta.net",
+          "Jonas@zeta.net",
+          "KarenE@zeta.net",
+          "J.R.C.@zeta.net", # check to see if this is working
+          "PMackey@zeta.net",
+
+          "adrienne@zeta.net","alpha@zeta.net","amina@zeta.net",
+          "anamika@zeta.net",
+          "claborca@zeta.net","communications@zeta.net",
+          "cz241@zeta.net",
+          "dee@zeta.net",
+          "ellenb@zeta.net","evis@zeta.net",
+          "frivera@zeta.net",
+          "gblack@zeta.net","gbrown@zeta.net","george@zeta.net","grace@zeta.net",
+          "happygolucky@zeta.net","hsp@zeta.net",
+          "ila@zeta.net",
+          "jacqueline_fenatifa@zeta.net","jlengler@zeta.net",
+          "joel@zeta.net","jolsen@zeta.net", "jsherman@zeta.net",
+          "kronjeklandish@zeta.net","kwilcox@zeta.net","bettyb@zeta.net",
+          "laurie@zeta.net","llmansell@zeta.net",
+          "louise@zeta.net","lzollo@zeta.net",
+          "mcraft@zeta.net","meganB@zeta.net","mwezi@zeta.net",
+          "nanwile@zeta.net",
+          "zetasound@zeta.net",
+          "peter@zeta.net",
+          "randi@zeta.net", "rcbackus@zeta.net", "registration@zeta.net",
+          "registration@omgea.org",
+          "rtaylor@zeta.net",
+          "sdonnarumma@zeta.net","stephanR@zeta.net","suzanne@zeta.net","suzzane@zeta.net",
+          "taryngaughan_dn@zeta.net"
+          # zzzzEND_OF_LIST####
+          ]   #end of Xdelivered-to list for possible zeta institute users
+
+{
+  reject text:
+      ERROR: Your email has not been delivered.
+
+      You have reached the mailer at zeta.net
+
+      Perhaps you want to send to Zeta Institute in DillyDally, NY, USA?
+
+      Use  USER@zeta.net for them
+
+      or try registration@zeta.net
+      Check the website at  http://www.zeta.net/zeta/contact/
+      Call Registration at    1 800 944 1001.
+
+      or use this information:
+
+      Zeta Institute
+      150 River Drive
+      DillyDally, NY 12666
+      Registration: 800-900-0000
+      Ph: 845-200-0000
+      Fax: 845-200-0001
+      registration@zeta.net
+
+      sincerely, POSTMASTER
+.
+;
+  fileinto "Inbox.Junk Mail.ezeta";
+  stop;
+ }
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+# +Move messages into folders
+#
+# Process other messages into separate folders
+#
+ # newsletters and mail lists
+if  header :contains  ["subject"]
+                      [ "newsletter", "[tc-ieee-", "[icntc",
+                        "JUG News", "Xdesksoftware",
+                        "announcement"   ]
+{
+  fileinto "INBOX.Newsletters";
+} elsif header :contains ["from","subject"] ["Anthony Robbins"] {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains ["from","subject"] ["MN Entrepreneurs","ME!"]  {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains ["from","received"] "adc.apple.com" {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "wnewadmn@ieee.org" {
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "@lb.bcentral.com" {  # techworthy@lb.bcentral.com
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "announcement@netbriefings.com" {  #st paul company
+  fileinto "INBOX.Newsletters";
+} elsif  header :contains "from" "newsletter@eletters.extremetech.com" {  #semi-annoying rag
+  fileinto "INBOX.Newsletters";
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+# my newsletter throw-away addresses
+} elsif  header :contains "to" ["microcenter@zeta.net","nmha@zeta.net"] {
+  fileinto "INBOX.Newsletters";
+
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+#
+# Alerts mailbox
+} elsif header :contains ["subject", "from"]
+                         [
+                          "Alert",                         # F-Prot virus alert service, matches:
+                                                           # "FRISK Virus Alert"
+                                                           #     or use s:FRISK Virus Alert:
+                                                           #     or use f:support@f-prot.com
+                          "Payment",                       # Alerts from other payments
+                          "credit.services@target.com",    # Target Card Payments
+                          "notify@quickbase.com"           # Tic Talkers Database changes
+                         ]
+{
+  fileinto "INBOX.Alerts";
+  stop;
+}
+
+# +Announcements from Dave Rolm, forward
+#
+# Perl Announcements from Dave Rolm
+if  header :contains "from" "dave@other.org"
+{
+  fileinto "Inbox";
+  keep;
+}
+#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+
+#######################################################################
+#### END OF SIEVE SCRIPT by Matthew Johnson - MRJ Solutions, Inc. #####
+################ email me at mailto:mattjohnson2005@gmail.com   #
+
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/mklose.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/mklose.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/mklose.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/mklose.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,303 @@
+# Example Sieve Script
+#   Author: Michael Klose
+#   URL: http://wiki.fastmail.fm/index.php?title=MichaelKloseSieveScript
+
+require ["fileinto", "reject", "vacation", "regex", "relational", "comparator-i;ascii-numeric"];
+
+# Experimental
+
+# End experimental
+
+
+
+# ----------------------------------------------
+#    Discard messages (high Spam values)
+# ----------------------------------------------
+
+if anyof
+    (
+     allof
+      (
+       #Spam score > 17?
+       #We have to check the sign and the value separately: ascii-numeric, defined at http://www.ietf.org/rfc/rfc2244.txt, doesn't see minus signs or decimal points ("-" or ".").
+       header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "17",
+       not header :contains "X-Spam-Score" "-",
+
+       not header :contains ["to","cc"]
+        [
+         "@my-domain.de",
+         "myemail@myotherdomain.us",
+         "myotheremail@myotherdomain.us",
+         "myotheremail2@myotherdomain.us"
+         # Do not discard stuff going to me - gets filed into Junk later
+        ],
+       not header :contains "from"
+        [
+         "lockergnome.com",
+         "Excite@info.excite.com" # gets filed into Junk later
+        ]
+
+
+      ),
+     allof
+      (
+       header :contains "X-LinkName" "hotmail", # OR anything from Hotmail with low spam
+       allof
+        (
+         header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "7",
+         not header :contains "X-Spam-Score" "-"
+        )
+      ),
+
+     # Black List
+
+     header :contains "from"
+      [
+       "ahbbcom@cncorn.com",
+       "Darg. B."
+      ],
+
+     # Chinese Encoding at BEGINNING of Subject
+
+     allof
+      (
+       anyof
+        (
+         header :regex "Subject"  "^=\\?(gb|GB)2312\\?",  # Chinese ecoding at subject
+         header :regex "Subject"  "^=\\?big5\\?", # Other kind of Chinese mail
+
+         # Chinese content type
+
+         header :contains "Content-Type"
+          [
+           "GB2312",
+           "big5"
+          ]
+        ),
+       not anyof
+        (
+      #Spam score > -4? <sic> - ascii-numeric ignores the ".9"!.  -Or is this correct?
+       #We have to check the sign and the value separately: ascii-numeric, defined at http://www.ietf.org/rfc/rfc2244.txt, doesn't see minus signs or decimal points ("-" or ".").
+
+         header :contains "X-Spam-Score" "-",
+         header :value "lt" :comparator "i;ascii-numeric" "X-Spam-Score" "4"
+        )
+      )
+    )
+
+{
+
+
+  # discard;
+
+  if header :contains "X-LinkName" "hotmail"
+   { discard; }
+  else
+   { fileinto "INBOX.Junk.Reject"; }
+   # I used to reject this stuff, but I wanted to know what I was rejecting, and this stuck.
+  stop;
+}
+
+
+
+# Addresses that need to be forwarded to a different domain here before spam checking
+# ******************************Michael - I don't understand what you're doing here!  -elvey
+# REPLY: this here is actually used to forward stuff addressed to my sister (using my domain)
+# to her - without using one of the own-domain aliases.
+
+if header :contains ["to", "cc"]
+ [
+  "bla@blabla.de",
+  "bla2@blabla.us",
+  "bla3@blabla.us"
+ ]
+ {
+  redirect "otheremailaddress@something.com";
+  redirect "anotheremailadress@something.com";
+  stop;
+ }
+
+
+# File into a folder before Spam filtering
+
+if header :contains ["to","cc"]
+ [
+  "important@mydomain.us",
+  "important2@mydomain.us"
+ ]
+ {
+  fileinto "Inbox.Important";
+  stop;
+ }
+
+
+
+# -------------------------------------------
+#              Filing rules
+# -------------------------------------------
+
+
+# Pre-SPAM
+
+
+if size :over 750K
+ {
+  fileinto "INBOX.largemail";
+  stop;
+ }
+
+
+if header :contains "from"
+   [
+
+# White list 1 (with SMS notification)
+
+    "Fred Bloggs",
+    "f.bloggs@hotmail.com",
+    "myboss@somecompany.com",
+    "Trisha",
+    "endofauction@ebay.de" # I want to know about end of auctions
+    ]
+ {
+  fileinto "Inbox";
+
+  # Send an SMS
+  redirect "smsgateway@somegateway.de";
+  keep;
+
+  stop;
+ }
+
+  # Advertising I want to receive, which normally ends up in the SPAM filter
+
+  if anyof
+   (
+    header :contains "from"
+
+     [
+
+# Advertising whitelist
+
+      "Mark Libbert",
+      "newsletter@snapfish.dom"
+     ],
+    header :contains "Return-Path" "mailings@gmx.dom"
+   )
+   { fileinto "INBOX.Ads"; }
+  elsif  header :contains "from"
+   [
+    "newsletter@neuseelandhaus.dom",
+    "Lockergnome",
+    "CNET News.com"
+   ]
+   { fileinto "INBOX.Newsletter";
+
+
+
+# Spam protection
+
+
+} elsif anyof
+   (
+
+    #Spam assasin
+    allof
+     (
+      header :value "ge" :comparator "i;ascii-numeric" "X-Spam-Score" "6",
+      not header :contains "X-Spam-Score" "-",
+      not anyof # White list
+       (
+        header :contains "From"         # Whitelist From addresses
+         [
+          "CNN Quick News",
+          "FastMail.FM Support",
+          "lockergnome.com"
+         ]
+       )
+     ),
+
+    # User defined
+
+    # Filter out Femalename1234z12@ spam (base64 encoded)
+    allof
+     (
+      header :regex "From" "alpha:{2,}digit:{2,}alpha:+digit:{2,}@",
+      header :contains "Content-Type" "multipart/mixed"
+     ),
+    # Filter our Spam with invalid headers. You can see this because FM adds
+    # @fastmail.fm to them. For safty, check that mklose@ @michael-klose mkmail@gmx do
+    # not appear
+
+    # Mklose: addition: The only negative side effect I have seen of the condition below
+    # is that it catches the FM newsletters. So far I find them in the spam occasionly
+    # but since they are so few, I have never bothered changing this to not catch them.
+
+    allof
+     (
+      header :contains "To" "@fastmail.fm", # I do not have a fastmail address   # This doesn't catch BCC's; you should be checking the envelop instead.  -elvey
+      not header :contains ["To", "CC", "Reply-To"] ["klose","mkmail@gmx.dom", "chaospower"]
+     )
+   )
+  {
+   fileinto "INBOX.Junk";
+   stop;
+  }
+
+
+# Post Spam-protection
+
+  elsif  header :contains ["to", "cc"] "gpc@gnu.dom" {
+  fileinto "INBOX.GPC";
+} elsif  header :contains ["to", "cc"] "alfs\-discuss@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-Support.ALFS";
+} elsif  header :contains "subject" "(usagi\-users" {
+  fileinto "INBOX.Usagi";
+} elsif anyof (header :contains "Subject" "\[eplus-de\]", header :contains "Reply-To" "eplus-de") {
+  fileinto "INBOX.E-Plus";
+} elsif  header :contains ["to", "cc"] "lfs\-support@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-Support";
+} elsif  header :contains ["to", "cc"] "netdev@oss.sgi.dom" {
+  fileinto "INBOX.NetDev";
+} elsif  header :contains ["to", "cc"] "lfs\-dev@linuxfromscratch.dom" {
+  fileinto "INBOX.LFS-DEV";
+} elsif  header :contains "from" "GMX Best Price" {
+  fileinto "INBOX.Werbung";
+} elsif  header :contains "subject" "RHN Errata Alert" {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "from"
+  [
+   "EmailDiscussions.com Mailer",
+   "help1@dungorm.dom"
+  ] {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "subject" "\[Gaim\-commits\]" {
+  fileinto "INBOX.Notifications";
+} elsif  header :contains "subject" "\[Bug" {
+  fileinto "INBOX.Notifications.Bugzilla";
+} elsif header :contains "X-LinkName" "hotmail" {
+  fileinto "INBOX.Old Hotmail.new";
+}
+
+
+# -----------------------------------------------------------------------
+#               SMS notifications and forwarding
+# -----------------------------------------------------------------------
+
+if allof
+    (
+     header :contains "to" ["@mydomain1.de","email@mydomain2.us","email2@somedomain"],
+     not header :contains "from"
+      [
+
+# This avoids sending SMS notifications if I am the sender
+
+       "@mydomain1.de",
+       "myotheremail@somedomain.de",
+       "myotheremail@someotherdomain.de"
+      ]
+    )
+ {
+  redirect "smsgateway@somegateway.com";
+  keep;
+ }
+
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/relational.rfc5231.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/relational.rfc5231.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/relational.rfc5231.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/relational.rfc5231.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,33 @@
+require ["relational", "comparator-i;ascii-numeric", "fileinto"];
+
+if header :value "lt" :comparator "i;ascii-numeric"
+	["x-priority"] ["3"]
+{
+	fileinto "Priority";
+}
+
+elsif address :count "gt" :comparator "i;ascii-numeric"
+	["to"] ["5"]
+{
+	# everything with more than 5 recipients in the "to" field
+	# is considered SPAM
+	fileinto "SPAM";
+}
+
+elsif address :value "gt" :all :comparator "i;ascii-casemap"
+	["from"] ["M"]
+{
+	fileinto "From N-Z";
+} else {
+	fileinto "From A-M";
+}
+
+if allof ( 
+	address :count "eq" :comparator "i;ascii-numeric"
+		["to", "cc"] ["1"] ,
+	address :all :comparator "i;ascii-casemap"
+		["to", "cc"] ["me@foo.example.com"] )
+{
+	fileinto "Only me";
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/rfc3028.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/rfc3028.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/rfc3028.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/rfc3028.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,58 @@
+#
+# Example Sieve Filter
+# Declare any optional features or extension used by the script
+#
+require ["fileinto", "reject"];
+
+#
+# Reject any large messages (note that the four leading dots get
+# "stuffed" to three)
+#
+if size :over 1M
+    {
+    reject text:
+Please do not send me large attachments.
+Put your file on a server and send me the URL.
+Thank you.
+.... Fred
+.
+;
+    stop;
+    }
+#
+
+# Handle messages from known mailing lists
+# Move messages from IETF filter discussion list to filter folder
+#
+if header :is "Sender" "owner-ietf-mta-filters@imc.org"
+    {
+    fileinto "filter";  # move to "filter" folder
+    }
+#
+# Keep all messages to or from people in my company
+#
+elsif address :domain :is ["From", "To"] "example.com"
+    {
+    keep;               # keep in "In" folder
+    }
+
+#
+# Try and catch unsolicited email.  If a message is not to me,
+# or it contains a subject known to be spam, file it away.
+#
+elsif anyof (not address :all :contains
+         ["To", "Cc", "Bcc"] "me@example.com",
+     header :matches "subject"
+         ["*make*money*fast*", "*university*dipl*mas*"])
+    {
+    # If message header does not contain my address,
+    # it's from a list.
+    fileinto "spam";   # move to "spam" folder
+    }
+ else
+    {
+    # Move all other (non-company) mail to "personal"
+    # folder.
+    fileinto "personal";
+    }
+
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/sanjay.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/sanjay.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/sanjay.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/sanjay.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,171 @@
+# Example Sieve Script
+#   Author: SanjaySheth
+#   URL: http://wiki.fastmail.fm/index.php?title=SanjaySieveSpamFilter
+
+require "fileinto";
+
+if anyof (
+
+      # Blacklisted sender domains
+      header :contains ["from", "Received", "X-Sender", "Sender",
+                        "To","CC","Subject","X-Mail-from"]
+             [ "123greetings", "allfreewebsite.com",
+               "new-fields.com","atlasrewards","azogle.com",
+               "bannerport.net","bettingextreme.com","bigemailoffers.com",
+               "BlingMail.com",
+               "beyondoffers.net", ".biz ", ".biz]",
+               "cavalrymail.com","ciol.com","citywire.co.uk",
+               "cosmicclick.com",
+               "consumergamblingreport","creativemailoffers.com","creativeoffers.com",
+               "daily-promotions.com",
+               "dailypromo.","dailypromotions.",
+               "dandyoffers","dlbdirect",
+               "e54.org",  "email-specials.net","email-ware.com","emailoffersondemand",
+               "emailbargain.com","emailofferz","emailrewardz","etoll.net","emailvalues.com",
+               "evaluemarketing.com","exitrequest.com",
+               "fantastic-bargain.com","fpsamplesmail.com","freelotto",
+               "findtv.com", "freddysfabulousfinds.com",
+               "genuinerewards.com",
+               "hotdailydeal.com","hulamediamail","hy-e.net",
+               "inboxbargains.com","idealemail.com",
+               "jackpot.com","jpmailer.com",
+               "lolita","lund.com.br",
+               "mafgroup.com","mailasia.com","mailtonic.net","migada.com","ms83.com",
+               "nationaloffers.com","nexdeals.com ",
+               "offercatch.com","offermagnet.com","offerservice.net","offertime.com",
+               "offersdaily.net","optnetwork.net",
+               "ombramarketing.com","on-line-offers.com","outblaze.com",
+               "permissionpass","primetimedirect.net","productsontheweb.net",
+               "rapid-e.net","recessionspecials", "redmoss","remit2india",
+               "sampleoffers.com","savingsmansion.com","sendoutmail.com","simpleoffers.com",
+               "specialdailydeals4u.com","Select-Point.net",
+               "speedyvalues.com","sportsoffers","sporttime.info","suntekglobal.com",
+               "superstorespecials.com", "synapseconnect","sunsetterawnings.com",
+               "thefreesamplenews","truemail.net",
+               "ub-kool","ultimatesports.info","uniquemailoffers","utopiad.com",
+               "unixlovers.net",
+               "valuesdirect","virtualoffers.net",
+               "wagerzine", "webdpoffrz",
+               "yestshirt.com",
+               "z-offer.com", "zipido.com"
+             ],
+
+      # Blacklisted ip subnets due to excessive spam from them
+      header :contains "Received"
+             [ "[4.63.221.224",
+               "[24.244.141.112",
+               "[61.171.253.177",
+               "[63.123.149.", "[63.209.206.", "(63.233.30.73", "[63.251.200.",
+               "[64.41.183.","[64.49.250.", "[64.57.188.", "[64.57.221.",
+               "[64.62.204.",
+               "[64.70.17.", "[64.70.44.", "[64.70.53.",
+               "[64.39.27.6", "[64.39.27.7","[64.191.25.","[64.191.36.",
+               "[64.191.9.",
+               "[64.125.181.", "[64.191.123.", "[64.191.23.", "[64.239.182.",
+               "[65.211.3.",
+               "[66.46.150.", "[66.62.162.", "[66.118.170.", "[66.129.124.",
+               "[66.205.217.", "[66.216.111.", "[66.239.204.",
+               "[67.86.69.",
+               "[80.34.206.", "[80.80.98.",
+               "[81.72.233.13",
+               "[128.242.120.",
+               "[157.238.18",
+               "[168.234.195.18]",
+               "[193.253.198.57",
+               "[194.25.83.1",
+               "[200.24.129.", "[200.161.203.",
+               "[202.164.182.76]","[202.57.69.116",
+               "[203.19.220.","[203.22.104.","[203.22.105.",
+               "[204.188.52.",
+               "[205.153.154.203",
+               "[206.26.195.", "[206.154.33.","[206.169.178",
+               "[207.142.3.",
+               "[208.46.5.","[208.187.",
+               "[209.164.27.","[209.236.",
+               "[210.90.75.129]",
+               "[211.101.138.199","[211.185.7.125]","[211.239.231.",
+               "[212.240.95.",
+               "[213.47.250.139", "[213.225.61.",
+               "[216.22.79.","[216.39.115.","[216.99.240.",
+               "[216.126.32.", "[216.187.123.","[217.36.124.53",
+               "[218.145.25","[218.52.71.103","[218.158.136.115",
+               "[218.160.42.74", "[218.242.112.4]"
+             ],
+
+      # Blacklisted SpamAssassin flags
+      header :contains ["SPAM", "X-Spam-hits"]
+             ["ADDRESSES_ON_CD","ACT_NOW","ADULT_SITE", "ALL_CAP_PORN",
+              "AMATEUR_PORN", "AS_SEEN_ON",
+              "BAD_CREDIT", "BALANCE_FOR_LONG_20K", "BARELY_LEGAL", "BEEN_TURNED_DOWN",
+              "BANG_GUARANTEE", "BANG_MONEY","BASE64_ENC_TEXT",
+              "BAYES_99","BAYES_90",
+              "BE_BOSS", "BEST_PORN", "BULK_EMAIL",
+              "CASINO", "CONSOLIDATE_DEBT", "COPY_ACCURATELY", "COPY_DVD",
+              "DIET", "DO_IT_TODAY","DOMAIN_4U2",
+              "EMAIL_MARKETING","EMAIL_ROT13", "EXPECT_TO_EARN","EARN_MONEY",
+              "FIND_ANYTHING", "FORGED_AOL_RCVD",
+              "FORGED_HOTMAIL_RCVD", "FORGED_YAHOO_RCVD",
+              "FORGED_RCVD_TRAIL", "FORGED_JUNO_RCVD",
+              "FORGED_MUA_",
+              "FREE_MONEY","FREE_PORN",
+              "GENTLE_FEROCITY", "GET_PAID", "GUARANTEED_STUFF", "GUARANTEED_100_PERCENT",
+              "HAIR_LOSS", "HIDDEN_ASSETS", "HGH,", "HOME_EMPLOYMENT","HOT_NASTY","HTTP_ESCAPED_HOST",
+              "HTTP_USERNAME_USED","HTML_FONT_INVISIBLE",
+              "IMPOTENCE","INVALID_MSGID","INVESTMENT",
+              "LESBIAN","LIVE_PORN","LOSE_POUNDS",
+              "MARKETING_PARTNERS", "MORTGAGE_OBFU", "MORTGAGE_RATES",
+              "NIGERIAN_SCAM", "NIGERIAN_TRANSACTION_1", "NIGERIAN_BODY", "NUMERIC_HTTP_ADDR",
+              "NO_MX_FOR_FROM","NO_DNS_FOR_FROM",
+              "OBFUSCATING_COMMENT", "ONLINE_PHARMACY",
+              "PENIS_ENLARGE",
+              "PREST_NON_ACCREDITED", "PURE_PROFIT","PORN_4",
+              "RCVD_IN_DSBL", "RCVD_IN_OSIRUSOFT_COM","RCVD_IN_BL_SPAMCOP_NET", "RCVD_IN_SBL",
+              "RCVD_IN_MULTIHOP_DSBL", "RCVD_IN_RELAYS_ORDB_ORG", "RCVD_IN_UNCONFIRMED_DSBL",
+              "RCVD_FAKE_HELO_DOTCOM", "RCVD_IN_RFCI", "RCVD_IN_NJABL","RCVD_IN_SORBS",
+              "REFINANCE", "REVERSE_AGING",
+              "SAVE_ON_INSURANCE","SPAM_REDIRECTOR", "STOCK_ALERT", "STOCK_PICK", "STRONG_BUY",
+              "SEE_FOR_YOURSELF", "SUPPLIES_LIMITED",
+              "THE_BEST_RATE","TONER",
+              "UNSECURED_CREDIT",
+              "VACATION_SCAM", "VIAGRA", "VJESTIKA",
+              "WHILE_SUPPLIES", "WORK_AT_HOME",
+              "X_OSIRU_DUL", "X_OSIRU_SPAMWARE_SITE", "X_OSIRU_SPAM_SRC"
+             ],
+
+
+      # Blacklisted subjects
+
+      header :contains ["From","Subject"]
+             [" penis ",
+              "ADV:", "adult dvd", "adult movie", "adultdirect", "adultemail",
+              "background check", "bankrupt", "boobs", "business opportunity","big@boss.com",
+              "casino", "cash guarantee",
+              "debt free", "diet bread", "ebay secrets", "erection",
+              "financial freedom", "free credit",
+              "gambl", "gov grants", "jackpot",
+              "life insurance", "lottery", "lotto",
+              "mortgage", "nude", "OTCBB",
+              "penis", "porn", "promotion", "proven System",
+              " rape ",
+              " sex ", "skin resurfacing", "special offer",
+              "ultimate software", "viagra", "V1AGRA", "vivatrim",
+              "win money","work from home", "xxx"
+             ],
+
+      # often spam emails to multiple addresses with same name & different domain
+      header :matches ["To","CC"]
+             ["*fastmail*fastmail*fastmail*fastmail*fastmail*"],
+
+      # Almost all emails from these domains is spam (at least for me)
+      header :contains ["from", "received"]
+                       [".ru ",".jp ", ".kr ", ".pt ",".pl ",".at ",".cz ",
+                        ".ru>",".jp>", ".kr>", ".pt>", ".pl>",".at>",".cz>"],
+
+      # Really high SpamAssassin scores (15.0+)
+      header :matches ["X-Spam-score","X-Remote-Spam-score"] [
+          "1?.?", "2?.?", "3?.?", "4?.?", "5?.?", "6?.?"     # 10.0 to 69.9
+      ]
+) {
+      fileinto "INBOX.Spam.discard";
+      stop;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/sieve_examples.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/sieve_examples.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/sieve_examples.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/sieve_examples.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,73 @@
+# Example Sieve Script
+#   Author: unknown
+#   URL: http://wiki.fastmail.fm/index.php?title=MoreSieveExamples
+
+require ["fileinto", "reject"];
+
+###BYPASSES###
+
+if anyof (
+              header :contains ["From"] "friend1",
+              header :contains ["From"] "friend12",
+              header :contains ["From"] "friend3",
+              header :contains ["From"] "friendsdomanin",
+              header :contains ["Subject"] "elephant"  ##a safeword
+         )
+             {
+                   fileinto "INBOX";
+                   stop;
+             }
+
+###BIG MESSAGE PROTECTION
+if size :over 5000K {
+         reject "Message over 5MB size limit.  Please contact me before sending this.";
+}
+
+##SPAM FILTERING##
+if header :contains ["X-Spam"] "high" {
+      discard;
+      stop;
+}
+if header :contains ["X-Spam-Flag"] "HIGH" {
+      discard;
+      stop;
+}
+if header :contains ["X-Spam"] "spam" {
+      fileinto "INBOX.spam";  #emails forwarded from my unviersity account get SA tagged like this
+      stop;
+}
+if header :contains ["X-Spam-Flag"] "YES" {
+      fileinto "INBOX.spam";
+      stop;
+}
+
+####LOCAL SPAM RULES#######
+if header :contains ["From"]  "bannerport" { discard; stop; }  ##keyword filters for when SA doesn't quite catch them
+if header :contains ["To"]  "MATT NOONE" { discard; stop; }
+###AUTO management rules###
+
+####Student Digest stuff#### ###   Examples of boolean OR rules
+if anyof (
+            header :contains ["X-BeenThere"] "student-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "firstyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "secondyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "thirdyear-digest@list.xxx.edu",
+            header :contains ["X-BeenThere"] "fourthyear-digest@list.xxx.edu"
+         )
+         {
+            fileinto "INBOX.lists.digests";
+            stop;
+         }
+if allof (   ###A Boolean AND rule
+            header :contains ["From"] "buddy1",
+            header :contains ["To"]   "myotheraddress"
+         )
+         {
+            fileinto "INBOX.scc.annoy";
+            stop;
+         }
+
+#other local rules
+if header :contains ["Subject"]  "helmreich" { fileinto "INBOX.lists.helmreich"; stop; }
+if header :contains ["Subject"]  "helmcomm" { fileinto "INBOX.lists.helmreich"; stop; }
+if header :contains ["Subject"]  "packeteer" { fileinto "INBOX.lists"; stop; }
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/subaddress.rfc5233.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/subaddress.rfc5233.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/subaddress.rfc5233.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/subaddress.rfc5233.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,23 @@
+require ["envelope", "subaddress", "fileinto"];
+
+# In this example the same user account receives mail for both
+# "ken@example.com" and "postmaster@example.com"
+
+# File all messages to postmaster into a single mailbox,
+# ignoring the :detail part.
+if envelope :user "to" "postmaster" {
+	fileinto "inbox.postmaster";
+	stop;
+}
+
+# File mailing list messages (subscribed as "ken+mta-filters").
+if envelope :detail "to" "mta-filters" {
+	fileinto "inbox.ietf-mta-filters";
+}
+
+# Redirect all mail sent to "ken+foo".
+if envelope :detail "to" "foo" {
+	redirect "ken@example.net";
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/vacation.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/vacation.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/vacation.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/vacation.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,23 @@
+require ["fileinto","reject", "vacation"];
+if allof (header :contains  "X-Spam-Flag" "YES") 
+{
+    discard ;
+}
+
+elsif allof (header :contains "subject" "<quation>") 
+{
+vacation 
+:addresses "<name@domain.ru>"
+:subject "<Answear>" 
+:mime "MIME-Version: 1.0
+Content-Type: text/html; charset=KOI8-R
+Content-Transfer-Encoding: 7bit
+<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">
+<HTML><HEAD><META http-equiv=Content-Type content=\"text/html; charset=windows-KOI8-R\">
+</HEAD><BODY>123</BODY></HTML>";
+ discard ;
+}
+else 
+{
+     keep;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/examples/vivil.sieve dovecot-1.2.0-sieve/dovecot-libsieve/examples/vivil.sieve
--- dovecot-1.2.0/dovecot-libsieve/examples/vivil.sieve	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/examples/vivil.sieve	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,94 @@
+# Example Sieve Script
+#   Author: Vivil
+#   URL: http://wiki.fastmail.fm/index.php?title=Vivil
+#   Removed unused notify require
+
+# *************************************************************************
+require ["envelope", "fileinto", "reject", "vacation", "regex", "relational", 
+"comparator-i;ascii-numeric"];
+
+
+if size :over 2048K {
+  reject "Message not delivered; size over limit accepted by recipient";
+  stop;  
+}
+
+#because of the use of elsif below, none of the "stop;"'s below are needed, but they're good 'defensive programming'. Only the one above is actually needed.
+
+redirect "login@gmail.dom";
+
+if header :contains ["from","cc"]
+[
+  "from-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "sex.com newsletter",
+  "ad@gator.com",
+  "newsletter@takecareof.com",
+  "from-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+
+elsif header :contains ["from"]
+[
+  "mygirlfriend-who-use-incredimail@foo.dom"
+]
+{
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+
+#use of "to" field detection next lines is ONLY USEFUL FOR DOMAIN NAME OWNERS if you forward your mail to your fastmail account, some virus/spam send mail to well known addresses as info@willemijns.dom i never use...
+
+elsif header :contains ["to","cc"]
+[
+  "to-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "FTPsebastien@willemijns.dom",
+  "info@willemijns.dom",
+  "webmaster@willemijns.dom",
+  "to-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+
+elsif header :contains ["subject"]
+[
+  "subject-begin@beginbeginbeginbeginbeginbeginbeginbeginbegin.fr",
+  "Undeliverable mail: Registration is accepted",
+  "subject-end@endendendendendendendendendendendendendendendend.fr"
+]
+{
+  discard;
+  stop;
+}
+elsif header :value "ge" :comparator "i;ascii-numeric" ["X-Spam-score"] ["6"]  {
+  fileinto "INBOX.Junk Mail";
+  stop;
+}
+elsif header :contains "from" "reflector@launay.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains "from" "do-not-reply@franconews.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains "from" "devnull@news.telefonica.dom" {
+  fileinto "INBOX.TEST";
+  stop;
+}
+elsif header :contains ["to"] ["sebastien@willemijns.dom"] {
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+elsif header :contains ["to"] ["seb@willemijns.dom"] {
+  fileinto "INBOX.PRIORITY";
+  stop;
+}
+else {
+  fileinto "INBOX";
+}
+# ********************************************************************
diff -urN dovecot-1.2.0/dovecot-libsieve/INSTALL dovecot-1.2.0-sieve/dovecot-libsieve/INSTALL
--- dovecot-1.2.0/dovecot-libsieve/INSTALL	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/INSTALL	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,125 @@
+Compiling
+---------
+
+First of all you'll need to have pre-built Dovecot 1.2 sources available. It's 
+also not a good idea to build the plugin against self-compiled Dovecot sources, 
+but then actually use a prebuilt binary package of Dovecot. That might work if 
+the Dovecot versions are the same, but it's not guaranteed. You can also use 
+installed Dovecot headers to compile this package, but then command line tools 
+like sievec and sieved will not be compiled. This is also true for the test 
+suite. 
+
+This package is compiled and configured as follows:
+
+./configure --with-dovecot=../dovecot-1.2
+make
+sudo make install
+
+The --with-dovecot parameter points to your Dovecot sources or, in case you are 
+compiling against the headers, to the directory where the dovecot-config file is 
+installed.
+
+If you downloaded this package through Mercurial, you need to execute 
+./autogen.sh first to build the automake/autoconf structure. This requires
+autotools and libtool to be installed. 
+
+Configuring
+-----------
+
+Configuration is currently mostly identical to the cmusieve module. However, the 
+name of the module is 'sieve' and not 'cmusieve'. For a detailed description on 
+installing the cmusieve plugin for deliver refer to the dovecot wiki:
+
+http://wiki.dovecot.org/LDA/Sieve
+
+The following options for the plugin section of the Dovecot config file are new
+when compared to the old CMU Sieve:
+
+  sieve_extensions = 
+
+    Use this setting to specify which Sieve language extensions are available 
+    to users. By default, all supported extensions are available, but some 
+    system administrators may want to disable certain Sieve extensions. 
+
+  sieve_before = 
+  sieve_after =
+
+    This Sieve implementation allows executing multiple Sieve scripts 
+    sequentially. These two options are used to specify what scripts need to
+    be executed before and after the user's script (as specified by the sieve
+    option). These settings allow specifying only one path each. However, if 
+    the path leads to a directory, all the Sieve scripts contained therein are 
+    executed. The order of execution is determined by the file names, using 
+    a normal 8bit per-character comparison.
+
+    After one script terminates, the next script is executed if an implicit or 
+    explicit "keep" is in effect. Thus, to end all script execution, a script 
+    must not execute keep and it must cancel the implicit keep, e.g. by
+    executing `discard; stop;'. Keep in mind that `fileinto "INBOX"' is not 
+    the same as a keep action in this context (only for the last script).
+
+    Just as for executing a single script the normal way, this implementation 
+    takes care never to duplicate deliveries, forwards or responses. When 
+    vacation actions are executed multiple times in different scripts, the 
+    usual error is not triggered: the subsequent duplicate vacation actions 
+    are simply discarded.
+
+    Apart from the keep action, all actions triggered in a script in the
+    sequence are executed before continuing to the next script. This means 
+    that when a script in the sequence encounters an error, actions from
+    preceeding scripts are not affected. The sequence is broken however, 
+    meaning that the script execution of the offending script is aborted and
+    no further scripts are executed. An implicit keep is executed in stead.
+
+  sieve_subaddress_sep = +
+
+    This setting specifies what separator is used between the :user and :detail 
+    address parts introduced by the subaddress extension. This may also be a 
+    sequence of characters (e.g. '--'). The current implementation looks for
+    the separator from the left of the localpart and uses the first one 
+    encountered. The :user part is left of the separator and the :detail part 
+    is right. 
+    
+For example:
+
+# ...
+
+protocol lda {
+  postmaster_address = postmaster@example.com
+
+  mail_plugins = sieve
+
+  # ... 
+}
+
+plugin {
+   # The user's own script
+   sieve = ~/.dovecot.sieve
+
+   # Global script if user has none
+   #   If this is omitted, Sieve processing is skipped when the user has no 
+   #   script of his own. This includes multiscript
+   sieve_global_path = /etc/dovecot/sieve.global/default.sieve
+
+   # Scripts executed before the user's script.
+   #   E.g. handling messages marked as dangerous
+   sieve_before = /etc/dovecot/sieve.global/discard-virusses.sieve
+
+   # Scripts executed after the user's script (if keep is still in effect)
+   #   E.g. default mail filing rules.  
+   sieve_after = /etc/dovecot/sieve.d/
+}
+
+Test Suite
+----------
+
+This package includes a test suite to verify the basic processing of the Sieve
+interpreter on your particular platform. Note that the test suite is not 
+available when this package is compiled against the Dovecot headers only. The 
+test suite executes a list of test cases and halts when one of them fails. If it 
+executes all test cases successfully, the test suite finishes. You can execute 
+the test suite using `make test`. 
+
+A failing test case is always a bug and a report is greatly appreciated.
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,17 @@
+SUBDIRS = src
+
+EXTRA_DIST = \
+	examples/* \
+	doc/devel \
+	ChangeLog
+
+dist_man_MANS = \
+	doc/man/sievec.1 \
+	doc/man/sieved.1 \
+	doc/man/sieve-test.1
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
+
diff -urN dovecot-1.2.0/dovecot-libsieve/NEWS dovecot-1.2.0-sieve/dovecot-libsieve/NEWS
--- dovecot-1.2.0/dovecot-libsieve/NEWS	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/NEWS	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,142 @@
+v0.1.7 5-7-2009  Stephan Bosch <stephan@rename-it.nl>
+	+ Added support for CRLF line breaks in strbuf error handler to fix a
+	  ManageSieve problem.
+	+ Improved consistency of sieve tool documentation and fixed missing
+	  parameters in internal tool help output.
+	+ Enhanced extensions configuration, allowing to specify the enabled
+	  extensions relatively to the default (patch by Steffen Kaiser).
+	- Forgot to initialize script execution status in Sieve plugin, causing 
+	  segfaults on compile errors in specific conditions.
+	- Fixed logging in Sieve plugin for execution of default main script (went 
+	  to STDERR).
+                                                                               
+v0.1.6 18-6-2009  Stephan Bosch <stephan@rename-it.nl>
+	* Adjusted to changes in Dovecot to make it compile against v1.2.rc5
+	* Made default of sieve_dir setting match the ManageSieve implementation.
+	- Fixed a few problems in de body extension that caused assert failures in
+	  specific situations.	
+
+v0.1.5 18-4-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Ported the implementation of the Sieve include extension to the latest 
+	  draft. This means that the import and export commands are replaced by a new 
+	  command called global. The import and export commands are now DEPRICATED and
+	  are mere aliases for the global command. The new specification also adds the
+	  :once modifier to the include command. The also newly specified global.* 
+	  variable namespace is not implemented yet as support for variable namespaces
+	  is currently missing.
+	* Did a major rework of the multiscript support for better error handling and
+	  made sure that persistent global scripts (sieve_before/sieve_after) are
+	  always executed, even when the user does not have a script of his own and 
+	  a global default is missing. 
+	+ Provided basic support for the environment extension. Currenly, the name,
+	  version and host items are useful. Others are pending.
+	+ Improved error message that is presented when an unknown Sieve extension is
+	  provided as argument to the require command. It now notifies the user that
+	  Sieve core commands do not need to be specified in require.
+	- Fixed bug in includes at levels deeper than one.
+	- Fixed bug in address matching that was caused by the failure to handle group 
+	  specifications. In dovecot, these are marked by address items with NULL 
+	  elements, which causes a segfault if not considered. The group 'undisclosed-
+	  recipients:;' in particular triggered this bug. Bug reported by Bernhard
+	  Schmidt. 	  
+
+v0.1.4 21-3-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Started work on the sieve-filter tool. With this command line tool it will 
+	  be possible to (re-)apply Sieve filters on a mail folder. It is currently
+	  undocumented and far from functional.
+	+ Added a custom debug extension that provides the possibility to print debug 
+	  messages from scripts executed by the Sieve tools.
+	- Fixed issue with opening relative paths as a mail file. Bug reported by Ian
+	  P. Christian.
+	- Fixed MAC OSX compile problem. Turns out the extern modifier was missing at
+	  multiple places. Bug reported by Edgar Fuss.
+	- Fixed Solaris compile problem: removed unecessary and unportable linker
+	  flags that caused compile to fail. Bug reported by Andrés Yacopino.
+
+v0.1.3 12-2-2009  Stephan Bosch <stephan@rename-it.nl>
+
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot
+	  >= 1.2.beta1
+	* Made mail address comparison fully case-insensitive. This is particularly
+	  noticeable for the :addresses argument of the vacation command. 
+	+ Finished enotify extension. Currently, only the mailto notification method
+	  is implemented. All still needs to be tested thoroughly.
+	+ Implemented multiscript support. It is now possible to execute multiple
+	  Sieve scripts sequentially. Administrator-controlled scripts can be
+	  executed before and after the user's script. Still needs to be tested
+	  thoroughly.
+	+ Implemented support for configuring the available Sieve extensions.
+	+ Made the subaddress extension (partially) configurable using the
+	  sieve_subaddress_sep setting, which allows specifying a (multi-charater)
+	  separator other than '+'.
+	+ Compiler now warns about invalid header field names used for the header and
+	  address tests.
+	+ Vacation extension now properly generates a References header for the 
+	  response message.
+	+ Added testing of basic result execution to the test suite. Also added 
+	  supportfor testing the outgoing messages produced by the Sieve interpreter. 
+	+ Included execution of the actual result in the sieve-test command line tool.
+	  The undocumented sieve-exec tool that existed for this is now removed as 
+	  planned.
+	+ Added support for the now obsolete 'imapflags' extension for backwards
+	  compatibility with CMUSieve. This also implements the mark/unmark commands.
+	- Fixed bugs in the regex extension: 1) if an optional match value did not in 
+	  fact match, subsequent match values would get unexpected indexes. 2) fixed
+	  segfault bug occuring when regex is freed.
+	- Fixed bug in the use of the :from agrument for the vacation command. If this
+	  address included a phrase part, the response would not be a valid RFC822
+	  message.
+	- Plugged a theoretical security hole occuring when a directory is opened as a 
+	  Sieve binary.
+	- Cleaned up and fixed various log messages.
+	- Fixed bug in the outgoing address verification. Addresses ending in ',' were 
+	  erroneously accepted.
+
+v0.1.2 26-11-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	- Fixed important bug in the redirect action (and probably other actions like
+	  reject and vacation that only send messages). This was a bug in the handling
+	  of context information during the execution of actions. It caused the sieve 
+	  interpreter to crash with a segfault when redirect was executed. 
+
+v0.1.1 24-11-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	* Re-enabled support for compiling against dovecot headers. Much like 
+	  cmusieve, command line tools like sievec and sieved are not compiled in this 
+	  case.
+	* Started implementation of enotify extension. Not anywhere near finished
+	  though. 
+	* Adapted to changes in Dovecot on various occasions, making this release
+	  dependent on Dovecot >= v1.2.alpa4.
+
+	+ Improved logging of errors at specific occasions and added debug messages to
+	  find script execution problems quicker. 
+	+ Removed code duplication between command line tools and the test suite. 
+	  Also restructured the sources of the tools.
+	+ Added UTF-8 to UTF-7 folder name conversion for compatibility with IMAP.
+	+ Created man pages for the command line tools. These are automatically 
+	  installed upon 'make install'
+	+ Incorporated Valgrind support into the testsuite and fixed a few memory
+	  leaks in the process.
+	- Fixed compile error surfacing for gcc3.4. Forgot mask argument for the 
+	  open() system call when the O_CREAT flag is specified. Bug found by 
+	  Sergey Ivanov.
+	- Fixed bug in the sievec tool. -d output was always written to stdout.
+	- Fixed important bug in the imap4flags extension. When no :flags argument is 
+	  specified, the previous version would always use the final value of the
+	  internal variable to set the flags. This means that modifications to the 
+	  internal variable also affected the bare fileinto/keep actions executed 
+	  earlier. This does not comply to the RFC. 
+	- Fixed bug in the include extension's import/export commands. Duplicate
+	  import/exports caused problems.
+	- Fixed bug in the handling of non-existent scripts. Errors were sometimes 
+	  ignored. 
+	- Dovecot omitted unfolding multi-line headers. This was added to the cmusieve
+	  plugin after the code was incorporated into the new implementation. This is
+	  now mplicitly fixed by concurrent change in Dovecot. 
+
+v0.1.0 23-10-2008  Stephan Bosch <stephan@rename-it.nl>
+
+	* Initial release
diff -urN dovecot-1.2.0/dovecot-libsieve/README dovecot-1.2.0-sieve/dovecot-libsieve/README
--- dovecot-1.2.0/dovecot-libsieve/README	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/README	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,194 @@
+Sieve implementation for Dovecot v1.2
+
+Introduction
+------------
+
+Sieve is a machine language specifically tailored for internet message 
+filtering. This package compiles into a Sieve plugin for the Dovecot local 
+delivery agent called Deliver. The plugin adds Sieve filtering support to the 
+delivery process.  
+
+Previously, the same functionality was provided by the cmusieve plugin for 
+Dovecot. This old plugin is based on the CMU Sieve implementation included with
+the Cyrus project. This new package provides a complete rewrite of the Sieve 
+engine integrating it tightly with Dovecot. The actual execution of the Sieve 
+actions is based on the original cmusieve plugin, but only on the code added to 
+interface the CMU Sieve implementation with Dovocot. 
+
+The main reason for rewriting the Sieve engine is to provide more reliable 
+script execution and to provide better error messages to users and system 
+administrators. Also, since the Sieve language evolves quickly, with new 
+language extensions published every year, the aim is to provide support for 
+quickly extending the engine with new features. 
+
+Features
+--------
+
+* Well-structured 3-stage compiler:
+ 
+  Uses dovecot framework and avoids using lex/yacc. Compiler doesn't bail on 
+  first error, but tries to find more. Produced errors are aimed to be useful 
+  and generally user-comprehensible. Things like 'Generic error' are a nuisance 
+  of the past. 
+
+* Highly extendable with new Sieve capabilities: 
+
+  This keeps the possibility of plugins in mind. It should eventually provide 
+  the necessary infrastructure for at least all currently known (proposed) 
+  extensions. The goal is to keep the extension interface provided by sieve 
+  engine as generic as possible, i.e. without explicit support for specific 
+  extensions. New similar extensions can then use the same interface methods 
+  without changes to the sieve engine code. If an extension is not loaded using 
+  the require command, the compiler truly does not know of its existance. 
+
+* Supports all extensions provided by the original CMUSieve plugin:
+ 
+  In addition, it has support for the new and very useful variables extension
+  (see next section). 
+
+  NOTE: The original CMUSieve plugin is based on old specifications of the 
+  imap4flags and enotify extension. Among other subtle differences, these 
+  extensions were known as 'imapflags' and 'notify' for the CMU Sieve plugin.
+  Support for the old imapflags extension is provided for backwards compatibility.
+
+* Supports executing multiple scrips sequentially.
+  
+  Using this feature it is possible to execute administrator-controlled Sieve
+  scripts before and after the user's Sieve script is executed. As long as the
+  verdict is at least (implicit) keep, the execution will continue with the next
+  script. Multiple scripts can be executed before or after the user's script by 
+  specifying directories containing sieve files.
+
+* Supported by ManageSieve service:
+
+  This Sieve implementation is supported by the ManageSieve implementation for 
+  Dovecot v1.2. Therefore, ManageSieve support can be added to Dovecot for the
+  new Sieve plugin just as for the cmusieve plugin.
+
+* Test suite included:
+	
+  This package includes a test suite to automatically asses whether the compiled 
+  sieve engine works correctly. The test suite is an extension to the Sieve 
+  language and is therefore easily extended with new tests. Currently, the 
+  test suite is mostly limited to testing script processing. The performed actions 
+  are not tested fully yet. 
+
+Implementation Status
+---------------------
+
+The the core of the language (as specified in RFC 5228) is fully supported. In 
+addition to that, this Sieve implementation features various extensions. The 
+following list outlines the implementation status of each supported extension:
+	
+  Base specification (RFC5228):
+    fileinto: full
+    reject: full (without Dovecot LMTP currently no refuse support)
+    envelope: full
+    encoded-character: full
+
+  Other RFCs/drafts:
+    subaddress: full (limited configurability)
+    comparator-i;ascii-numeric: full
+    relational: full 
+    copy: full
+    regex: mostly full; but suboptimal and no UTF-8
+    body: mostly full, but text body-transform implementation is simple
+        and some issues make it still not completely RFC incompliant. 
+    include: almost full; global namespace missing 
+    vacation: mostly full; handling of utf-8 in headers is non-existant
+    imap4flags: full (old imapflags supported for backwards compatibility)
+    variables: mostly full; currently no support for future namespaces 
+    notify: full, mailto support only; needs to be tested more
+	environment: basic
+
+All implemented extensions are like the engine itself currently experimental. 
+A status of 'full' does not necessarily mean that the extension is bug-free or 
+even fully RFC-compliant. Check the TODO file for open issues.
+ 
+Many more extensions to the language exist. Not all of these extensions are 
+useful for Dovecot in particular, but many of them are. Currently, the author 
+has taken notice of the following extensions:
+
+    date,index: planned
+    editheader: planned, needs additional support from Dovecot though.
+    mimeloop: planned
+
+These extensions will be added as soon as the necessary infrastructure is 
+available. 
+
+Compiling and Configuring
+-------------------------
+
+Refer to INSTALL file.
+
+Using
+-----
+
+The main purpose of this package is to replace the existing cmusieve plugin that 
+is currently available for Dovecot's deliver. With this respect it is currently 
+not very different from the cmusieve plugin implementation.
+
+Unlike cmusieve, this sieve module logs runtime errors to <scriptfile>.log if 
+it can and not <scriptfile>.err. It appends new timestamped log entries to the 
+end of the logfile. If the log grows too large (currently > 10kB), the logfile 
+is rotated to <scriptfile>.log.0 and <scriptfile>.log starts out empty again. 
+
+The cmusieve plugin compiled the script into a file with an appended 'c', e.g. 
+'test.sievec'. This new implementation recognizes scripts to have the .sieve 
+extension. The binary is (by default) written to a file with extension .svbin. 
+This means that the default .dovecot.sieve is compiled into .dovecot.svbin. 
+Included scripts are currently always compiled into the main binary, meaning 
+that no other files are written and no permission to do so is necessary for the 
+global script directories. 
+
+To test the sieve engine outside deliver, it is useful to try the commands that 
+exist in the src/sieve-tools/ directory of this package. After installation, 
+these are available at your $prefix/bin directory. The following commands are 
+installed:
+
+sievec     - Compiles sieve scripts into a binary representation for later 
+             execution.
+
+sieve-test - This is a universal Sieve test tool for testing the effect of a
+             Sieve script on a particular message. It allows compiling, running 
+             and testing Sieve scripts. It can either be used to display the
+             actions that would be performed on the provided test message or it
+             can be used to test the actual delivery of the message and show the
+             messages that would normally be sent through SMTP.
+
+sieved     - Dumps the content of a Sieve binary file for (development) 
+             debugging purposes.
+
+When installed, man pages are also available for these commands. In this package
+the man pages are present in doc/man and can be viewed before install using e.g.: 
+
+man -l doc/man/sieve-test.1
+
+Various example scripts are bundled in the directory 'examples'. These scripts
+were downloaded from various locations. View the top comment in the scripts for 
+url and author information.
+
+Known issues
+------------
+
+Most open issues are outlined in the TODO file. The more generic ones are (re-)
+listed here:
+
+- Compile errors are sometimes a bit obscure and long. This needs work. 
+  Suggestions for improvement are welcome. 
+- The documentation needs work.
+
+Authors
+-------
+
+Refer to AUTHORS file.
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about 
+this package. You can post to the list without subscribing, the mail then waits 
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-discard.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-discard.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-discard.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-discard.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,156 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-dump.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/* 
+ * Discard command 
+ * 
+ * Syntax
+ *   discard
+ */	
+
+static bool cmd_discard_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx ATTR_UNUSED); 
+
+const struct sieve_command cmd_discard = { 
+	"discard", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, 
+	cmd_discard_generate, 
+	NULL 
+};
+
+/*
+ * Discard operation
+ */
+
+static bool cmd_discard_operation_dump
+	(const struct sieve_operation *op,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_discard_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_discard_operation = { 
+	"DISCARD",
+	NULL,
+	SIEVE_OPERATION_DISCARD,
+	cmd_discard_operation_dump, 
+	cmd_discard_operation_execute 
+};
+
+/* 
+ * Discard actions
+ */
+
+static void act_discard_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_discard_commit
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+		
+const struct sieve_action act_discard = {
+	"discard",
+	0,
+	NULL, NULL, NULL,
+	act_discard_print,
+	NULL, NULL,
+	act_discard_commit,
+	NULL
+};
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_discard_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &cmd_discard_operation);
+
+	/* Emit line number */
+    sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+
+static bool cmd_discard_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+    const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "DISCARD");
+    sieve_code_descend(denv);
+
+    /* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+    return sieve_code_dumper_print_optional_operands(denv, address);
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_discard_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	unsigned int source_line;
+	
+	/* Source line */
+    if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "failed to read source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "DISCARD action");
+
+	return ( sieve_result_add_action
+		(renv, &act_discard, NULL, source_line, NULL, 0) >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+ 
+static void act_discard_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context ATTR_UNUSED, 
+	bool *keep)	
+{
+	sieve_result_action_printf(rpenv, "discard");
+	
+	*keep = FALSE;
+}
+
+static bool act_discard_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv ATTR_UNUSED, 
+	void *tr_context ATTR_UNUSED, bool *keep)
+{
+	*keep = FALSE;
+
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-if.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-if.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-if.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-if.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,225 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/*
+ * Commands
+ */
+
+/* If command
+ *
+ * Syntax:   
+ *   if <test1: test> <block1: block>
+ */
+
+static bool cmd_if_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_if_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_if = { 
+	"if", 
+	SCT_COMMAND, 
+	0, 1, TRUE, TRUE,
+	NULL, NULL,
+	cmd_if_validate, 
+	cmd_if_generate, 
+	NULL 
+};
+
+/* ElsIf command
+ *
+ * Santax:
+ *   elsif <test2: test> <block2: block>
+ */
+
+static bool cmd_elsif_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+
+const struct sieve_command cmd_elsif = {
+    "elsif", 
+	SCT_COMMAND,
+	0, 1, TRUE, TRUE, 
+	NULL, NULL, 
+	cmd_elsif_validate, 
+	cmd_if_generate, 
+	NULL 
+};
+
+/* Else command 
+ *
+ * Syntax:   
+ *   else <block>
+ */
+
+static bool cmd_else_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_else = {
+    "else", 
+	SCT_COMMAND, 
+	0, 0, TRUE, TRUE,
+	NULL, NULL,
+	cmd_elsif_validate, 
+	cmd_else_generate, 
+	NULL 
+};
+
+/* 
+ * Context management
+ */
+
+struct cmd_if_context_data {
+	struct cmd_if_context_data *previous;
+	struct cmd_if_context_data *next;
+	
+	bool jump_generated;
+	sieve_size_t exit_jump;
+};
+
+static void cmd_if_initialize_context_data
+(struct sieve_command_context *cmd, struct cmd_if_context_data *previous) 
+{ 	
+	struct cmd_if_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), struct cmd_if_context_data, 1);
+	ctx_data->exit_jump = 0;
+	ctx_data->jump_generated = FALSE;
+
+	/* Update linked list of contexts */
+	ctx_data->previous = previous;
+	ctx_data->next = NULL;	
+	if ( previous != NULL )
+		previous->next = ctx_data;
+	
+	/* Assign to command context */
+	cmd->data = ctx_data;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_if_validate
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_command_context *cmd) 
+{ 
+	/* Start if-command structure */
+	cmd_if_initialize_context_data(cmd, NULL);
+	
+	return TRUE;
+}
+
+static bool cmd_elsif_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd)
+{
+	struct sieve_command_context *prev_context = 
+		sieve_command_prev_context(cmd);
+
+	/* Check valid command placement */
+	if ( prev_context == NULL ||
+		( prev_context->command != &cmd_if &&
+			prev_context->command != &cmd_elsif ) ) 
+	{		
+		sieve_command_validate_error(validator, cmd, 
+			"the %s command must follow an if or elseif command", 
+			cmd->command->identifier);
+		return FALSE;
+	}
+	
+	/* Previous command in this block is 'if' or 'elsif', so we can safely refer 
+	 * to its context data 
+	 */
+	cmd_if_initialize_context_data(cmd, prev_context->data);
+
+	return TRUE;
+}
+
+/* 
+ * Code generation 
+ */
+
+/* The if command does not generate specific IF-ELSIF-ELSE opcodes, but only uses
+ * JMP instructions. This is why the implementation of the if command does not 
+ * include an opcode implementation.
+ */
+
+static void cmd_if_resolve_exit_jumps
+(struct sieve_binary *sbin, struct cmd_if_context_data *ctx_data) 
+{
+	struct cmd_if_context_data *if_ctx = ctx_data->previous;
+	
+	/* Iterate backwards through all if-command contexts and resolve the 
+	 * exit jumps to the current code position.
+	 */
+	while ( if_ctx != NULL ) {
+		if ( if_ctx->jump_generated ) 
+			sieve_binary_resolve_offset(sbin, if_ctx->exit_jump);
+		if_ctx = if_ctx->previous;	
+	}
+}
+
+static bool cmd_if_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct cmd_if_context_data *ctx_data = (struct cmd_if_context_data *) ctx->data;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist jmplist;
+	
+	/* Prepare jumplist */
+	sieve_jumplist_init_temp(&jmplist, sbin);
+	
+	/* Generate test condition */
+	test = sieve_ast_test_first(ctx->ast_node);
+	if ( !sieve_generate_test(cgenv, test, &jmplist, FALSE) )
+		return FALSE;
+		
+	/* Case true { */
+	if ( !sieve_generate_block(cgenv, ctx->ast_node) ) 
+		return FALSE;
+	
+	/* Are we the final command in this if-elsif-else structure? */
+	if ( ctx_data->next != NULL ) {
+		/* No, generate jump to end of if-elsif-else structure (resolved later) 
+		 * This of course is not necessary if the {} block contains a command 
+		 * like stop at top level that unconditionally exits the block already
+		 * anyway. 
+		 */
+		if ( !sieve_command_block_exits_unconditionally(ctx) ) {
+			sieve_operation_emit_code(sbin, &sieve_jmp_operation);
+			ctx_data->exit_jump = sieve_binary_emit_offset(sbin, 0);
+			ctx_data->jump_generated = TRUE;
+		}
+	} else {
+		/* Yes, Resolve previous exit jumps to this point */
+		cmd_if_resolve_exit_jumps(sbin, ctx_data);
+	}
+	
+	/* Case false ... (subsequent elsif/else commands might generate more) */
+	sieve_jumplist_resolve(&jmplist);	
+		
+	return TRUE;
+}
+
+static bool cmd_else_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	struct cmd_if_context_data *ctx_data = (struct cmd_if_context_data *) ctx->data;
+	
+	/* Else { */
+	if ( !sieve_generate_block(cgenv, ctx->ast_node) ) 
+		return FALSE;
+		
+	/* } End: resolve all exit blocks */	
+	cmd_if_resolve_exit_jumps(cgenv->sbin, ctx_data);
+		
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-keep.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-keep.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-keep.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-keep.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,124 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-dump.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/* 
+ * Keep command 
+ *
+ * Syntax:
+ *   keep
+ */	
+
+static bool cmd_keep_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_keep = { 
+	"keep", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, 
+	cmd_keep_generate, 
+	NULL
+};
+
+/* 
+ * Keep operation 
+ */
+
+static bool cmd_keep_operation_dump
+	(const struct sieve_operation *op,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_keep_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_keep_operation = { 
+	"KEEP",
+	NULL,
+	SIEVE_OPERATION_KEEP,
+	cmd_keep_operation_dump, 
+	cmd_keep_operation_execute 
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_keep_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	/* Emit opcode */
+	sieve_operation_emit_code(cgenv->sbin, &cmd_keep_operation);
+
+	/* Emit line number */
+    sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+
+static bool cmd_keep_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+    const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "KEEP");
+    sieve_code_descend(denv);
+
+    /* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+    return sieve_code_dumper_print_optional_operands(denv, address);
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_keep_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	struct sieve_side_effects_list *slist = NULL;
+	unsigned int source_line;
+	int ret = 0;	
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands (side effects only) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 ) 
+		return ret;
+
+	sieve_runtime_trace(renv, "KEEP action");
+	
+	/* Add keep action to result. 
+	 */
+	ret = sieve_result_add_keep(renv, slist, source_line);
+	
+	return ( ret >= 0 );
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-redirect.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-redirect.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-redirect.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-redirect.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,384 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "istream-crlf.h"
+#include "istream-header-filter.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-address.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+#include "sieve-result.h"
+
+#include <stdio.h>
+
+/* 
+ * Configuration 
+ */
+
+#define CMD_REDIRECT_DUPLICATE_KEEP (3600 * 24)
+
+/* 
+ * Redirect command 
+ * 
+ * Syntax
+ *   redirect <address: string>
+ */
+
+static bool cmd_redirect_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_redirect_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_redirect = { 
+	"redirect", 
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE, 
+	NULL, NULL,
+	cmd_redirect_validate, 
+	cmd_redirect_generate, 
+	NULL 
+};
+
+/* 
+ * Redirect operation 
+ */
+
+static bool cmd_redirect_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_redirect_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_redirect_operation = { 
+	"REDIRECT",
+	NULL, 
+	SIEVE_OPERATION_REDIRECT,
+	cmd_redirect_operation_dump, 
+	cmd_redirect_operation_execute 
+};
+
+/* 
+ * Redirect action 
+ */
+
+static bool act_redirect_equals
+	(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2);
+static int act_redirect_check_duplicate
+	(const struct sieve_runtime_env *renv,
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_redirect_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_redirect_commit
+	(const struct sieve_action *action, const struct sieve_action_exec_env *aenv,
+		void *tr_context, bool *keep);
+		
+const struct sieve_action act_redirect = {
+	"redirect",
+	SIEVE_ACTFLAG_TRIES_DELIVER,
+	act_redirect_equals,
+	act_redirect_check_duplicate, 
+	NULL,
+	act_redirect_print,
+	NULL, NULL,
+	act_redirect_commit,
+	NULL
+};
+
+struct act_redirect_context {
+	const char *to_address;
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_redirect_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	/* Check and activate address argument */
+
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "address", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+
+	/* We can only assess the validity of the outgoing address when it is 
+	 * a string literal. For runtime-generated strings this needs to be 
+	 * done at runtime (FIXME!)
+     */
+	if ( sieve_argument_is_string_literal(arg) ) {
+		string_t *address = sieve_ast_argument_str(arg);
+		const char *error;
+		const char *norm_address;
+
+		T_BEGIN {
+			/* Verify and normalize the address to 'local_part@domain' */
+			norm_address = sieve_address_normalize(address, &error);
+		
+			if ( norm_address == NULL ) {
+				sieve_argument_validate_error(validator, arg, 
+					"specified redirect address '%s' is invalid: %s",
+					str_sanitize(str_c(address),128), error);
+			} else {
+				/* Replace string literal in AST */
+				sieve_ast_argument_string_setc(arg, norm_address);
+			}
+		} T_END;
+
+		return ( norm_address != NULL );
+	}		
+
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_redirect_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &cmd_redirect_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_redirect_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "REDIRECT");
+	sieve_code_descend(denv);
+
+	/* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) )
+		return FALSE;
+
+	return sieve_opr_string_dump(denv, address, "reason");
+}
+
+/*
+ * Intepretation
+ */
+
+static int cmd_redirect_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_redirect_context *act;
+	string_t *redirect;
+	unsigned int source_line;
+	pool_t pool;
+	int ret = 0;
+
+	/* Source line */
+    if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+        return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Optional operands (side effects) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	/* Read the address */
+	if ( !sieve_opr_string_read(renv, address, &redirect) ) {
+		sieve_runtime_trace_error(renv, "invalid address string");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* FIXME: perform address normalization if the string is not a string literal
+	 */
+
+	sieve_runtime_trace(renv, "REDIRECT action (\"%s\")", str_sanitize(str_c(redirect), 64));
+	
+	/* Add redirect action to the result */
+
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_redirect_context, 1);
+	act->to_address = p_strdup(pool, str_c(redirect));
+	
+	ret = sieve_result_add_action
+		(renv, &act_redirect, slist, source_line, (void *) act, sieve_max_redirects);
+	
+	return ( ret >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static bool act_redirect_equals
+(const struct sieve_script_env *senv ATTR_UNUSED, 
+	const void *ctx1, const void *ctx2)
+{
+	struct act_redirect_context *rd_ctx1 = 
+		(struct act_redirect_context *) ctx1;
+	struct act_redirect_context *rd_ctx2 = 
+		(struct act_redirect_context *) ctx2;
+
+	/* Address is already normalized */
+	return ( sieve_address_compare
+		(rd_ctx1->to_address, rd_ctx2->to_address, TRUE) == 0 );
+}
+ 
+static int act_redirect_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	return ( act_redirect_equals
+		(renv->scriptenv, act->context, act_other->context) ? 1 : 0 );
+}
+
+static void act_redirect_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, bool *keep)	
+{
+	struct act_redirect_context *ctx = (struct act_redirect_context *) context;
+	
+	sieve_result_action_printf(rpenv, "redirect message to: %s", 
+		str_sanitize(ctx->to_address, 128));
+	
+	*keep = FALSE;
+}
+
+static bool act_redirect_send	
+(const struct sieve_action_exec_env *aenv, struct act_redirect_context *ctx)
+{
+	static const char *hide_headers[] = { "Return-Path", "X-Sieve" };
+
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	struct istream *input, *crlf_input;
+	void *smtp_handle;
+	FILE *f;
+	const unsigned char *data;
+	size_t size;
+	int ret;
+	
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "redirect action has no means to send mail.");
+		return TRUE;
+	}
+	
+	if (mail_get_stream(msgdata->mail, NULL, NULL, &input) < 0)
+		return FALSE;
+		
+	/* Open SMTP transport */
+	smtp_handle = senv->smtp_open(ctx->to_address, msgdata->return_path, &f);
+
+	/* Remove unwanted headers */
+	input = i_stream_create_header_filter
+		(input, HEADER_FILTER_EXCLUDE, hide_headers,
+			N_ELEMENTS(hide_headers), null_header_filter_callback, NULL);
+	
+	/* Make sure the message contains CRLF consistently */
+	crlf_input = i_stream_create_crlf(input);
+
+	/* Prepend sieve version header (should not affect signatures) */
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+
+	/* Pipe the message to the outgoing SMTP transport */
+	while ((ret = i_stream_read_data(crlf_input, &data, &size, 0)) > 0) {	
+		if (fwrite(data, size, 1, f) == 0)
+			break;
+		i_stream_skip(crlf_input, size);
+	}
+
+	i_stream_unref(&crlf_input);
+	i_stream_unref(&input);
+
+	/* Close SMTP transport */
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv, 
+			"failed to redirect message to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(ctx->to_address, 80));
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool act_redirect_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{
+	struct act_redirect_context *ctx = (struct act_redirect_context *) tr_context;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	const char *dupeid;
+	
+	/* Prevent mail loops if possible */
+	dupeid = msgdata->id == NULL ? 
+		NULL : t_strdup_printf("%s-%s", msgdata->id, ctx->to_address);
+	if (dupeid != NULL) {
+		/* Check whether we've seen this message before */
+		if (senv->duplicate_check(dupeid, strlen(dupeid), senv->username)) {
+			sieve_result_log(aenv, "discarded duplicate forward to <%s>",
+				str_sanitize(ctx->to_address, 128));
+			return TRUE;
+		}
+	}
+	
+	/* Try to forward the message */
+	if ( act_redirect_send(aenv, ctx) ) {
+	
+		/* Mark this message id as forwarded to the specified destination */
+		if (dupeid != NULL) {
+			senv->duplicate_mark(dupeid, strlen(dupeid), senv->username,
+				ioloop_time + CMD_REDIRECT_DUPLICATE_KEEP);
+		}
+	
+		sieve_result_log(aenv, "forwarded to <%s>", 
+			str_sanitize(ctx->to_address, 128));	
+
+		/* Indicate that message was successfully forwarded */
+		aenv->exec_status->message_forwarded = TRUE;
+
+		/* Cancel implicit keep */
+		*keep = FALSE;
+
+		return TRUE;
+	}
+  
+	return FALSE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-require.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-require.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-require.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-require.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,86 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-extensions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+
+/* 
+ * Require command
+ *
+ * Syntax 
+ *   Syntax: require <capabilities: string-list>
+ */
+
+static bool cmd_require_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+
+const struct sieve_command cmd_require = { 
+	"require", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL, 
+	cmd_require_validate, 
+	NULL, NULL
+};
+ 
+/* 
+ * Validation 
+ */
+
+static bool cmd_require_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	bool result = TRUE;
+	struct sieve_ast_argument *arg;
+	struct sieve_command_context *prev_context = 
+		sieve_command_prev_context(cmd);
+	
+	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) ||
+		( !sieve_command_is_first(cmd) && prev_context != NULL &&
+			prev_context->command != &cmd_require ) ) 
+	{	
+		sieve_command_validate_error(validator, cmd, 
+			"require commands can only be placed at top level "
+			"at the beginning of the file");
+		return FALSE;
+	}
+	
+	/* Check argument and load specified extension(s) */
+
+	arg = cmd->first_positional;
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		const struct sieve_extension *ext = sieve_validator_extension_load
+			(validator, cmd, arg, sieve_ast_argument_str(arg));	
+
+		if ( ext == NULL ) result = FALSE;
+		
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+		
+		while ( stritem != NULL ) {
+			const struct sieve_extension *ext = sieve_validator_extension_load
+				(validator, cmd, stritem, sieve_ast_strlist_str(stritem));
+
+			if ( ext == NULL ) result = FALSE;
+	
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		/* Something else */
+		sieve_argument_validate_error(validator, arg, 
+			"the require command accepts a single string or string list argument, "
+			"but %s was found", 
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+	 
+	return result;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-stop.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-stop.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmd-stop.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmd-stop.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,90 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+/* 
+ * Stop command 
+ * 
+ * Syntax
+ *   stop
+ */	
+
+static bool cmd_stop_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx ATTR_UNUSED);
+static bool cmd_stop_validate
+	(struct sieve_validator *validator, struct sieve_command_context *ctx);
+	
+const struct sieve_command cmd_stop = { 
+	"stop", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL,  
+	cmd_stop_validate, 
+	cmd_stop_generate, 
+	NULL 
+};
+
+/* 
+ * Stop operation
+ */
+
+static int opc_stop_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_stop_operation = { 
+	"STOP",
+	NULL,
+	SIEVE_OPERATION_STOP,
+	NULL, 
+	opc_stop_execute 
+};
+
+/*
+ * Command validation
+ */
+ 
+static bool cmd_stop_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *ctx)
+{
+	sieve_command_exit_block_unconditionally(ctx);
+	
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+
+static bool cmd_stop_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &cmd_stop_operation);
+
+	return TRUE;
+}
+
+/*
+ * Code execution
+ */
+
+static int opc_stop_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv,  
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	sieve_runtime_trace(renv, "STOP");
+	
+	sieve_interpreter_interrupt(renv->interp);
+
+	return SIEVE_EXEC_OK;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmp-i-ascii-casemap.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* Comparator 'i;ascii-casemap': 
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+
+/*
+ * Forward declarations
+ */
+ 
+static int cmp_i_ascii_casemap_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+static bool cmp_i_ascii_casemap_char_match
+	(const struct sieve_comparator *cmp, const char **val1, const char *val1_end, 
+		const char **val2, const char *val2_end);
+
+/*
+ * Comparator object
+ */
+ 
+const struct sieve_comparator i_ascii_casemap_comparator = {
+	SIEVE_OBJECT
+		("i;ascii-casemap", &comparator_operand, SIEVE_COMPARATOR_I_ASCII_CASEMAP),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY |
+		SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH | SIEVE_COMPARATOR_FLAG_PREFIX_MATCH,
+	cmp_i_ascii_casemap_compare,
+	cmp_i_ascii_casemap_char_match,
+	sieve_comparator_octet_skip
+};
+
+/*
+ * Comparator implementation
+ */
+
+static int cmp_i_ascii_casemap_compare(
+	const struct sieve_comparator *cmp ATTR_UNUSED,
+	const char *val1, size_t val1_size, const char *val2, size_t val2_size)
+{
+	int result;
+
+	if ( val1_size == val2_size ) {
+		return strncasecmp(val1, val2, val1_size);
+	} 
+	
+	if ( val1_size > val2_size ) {
+		result = strncasecmp(val1, val2, val2_size);
+		
+		if ( result == 0 ) return 1;
+		
+		return result;
+	} 
+
+	result = strncasecmp(val1, val2, val1_size);
+		
+	if ( result == 0 ) return -1;
+		
+	return result;
+}
+
+static bool cmp_i_ascii_casemap_char_match
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end, 
+		const char **key, const char *key_end)
+{
+	const char *val_begin = *val;
+	const char *key_begin = *key;
+	
+	while ( i_tolower(**val) == i_tolower(**key) &&
+		*val < val_end && *key < key_end ) {
+		(*val)++;
+		(*key)++;
+	}
+	
+	if ( *key < key_end ) {
+		/* Reset */
+		*val = val_begin;
+		*key = key_begin;	
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/cmp-i-octet.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,93 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* Comparator 'i;octet': 
+ *
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int cmp_i_octet_compare
+	(const struct sieve_comparator *cmp,
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+static bool cmp_i_octet_char_match
+	(const struct sieve_comparator *cmp, const char **val1, const char *val1_end, 
+		const char **val2, const char *val2_end);
+
+/*
+ * Comparator object
+ */
+
+const struct sieve_comparator i_octet_comparator = {
+	SIEVE_OBJECT("i;octet",	&comparator_operand, SIEVE_COMPARATOR_I_OCTET),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY |
+		SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH | SIEVE_COMPARATOR_FLAG_PREFIX_MATCH,
+	cmp_i_octet_compare,
+	cmp_i_octet_char_match,
+	sieve_comparator_octet_skip	
+};
+
+/*
+ * Comparator implementation
+ */
+ 
+static int cmp_i_octet_compare(
+	const struct sieve_comparator *cmp ATTR_UNUSED,
+	const char *val1, size_t val1_size, const char *val2, size_t val2_size)
+{
+	int result;
+
+	if ( val1_size == val2_size ) {
+		return memcmp((void *) val1, (void *) val2, val1_size);
+	} 
+	
+	if ( val1_size > val2_size ) {
+		result = memcmp((void *) val1, (void *) val2, val2_size);
+		
+		if ( result == 0 ) return 1;
+		
+		return result;
+	} 
+
+	result = memcmp((void *) val1, (void *) val2, val1_size);
+		
+	if ( result == 0 ) return -1;
+		
+	return result;
+}
+
+static bool cmp_i_octet_char_match
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end, 
+		const char **key, const char *key_end)
+{
+	const char *val_begin = *val;
+	const char *key_begin = *key;
+	
+	while ( **val == **key && *val < val_end && *key < key_end ) {
+		(*val)++;
+		(*key)++;
+	}
+	
+	if ( *key < key_end ) {
+		/* Reset */
+		*val = val_begin;
+		*key = key_begin;	
+	
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+ 
+ 
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-encoded-character.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,280 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension encoded-character 
+ * ---------------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full 
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+
+#include <ctype.h>
+
+/* 
+ * Extension
+ */
+
+static bool ext_encoded_character_validator_load
+	(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+struct sieve_extension encoded_character_extension = { 
+	"encoded-character", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_encoded_character_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/*
+ * Encoded string argument
+ */
+
+bool arg_encoded_string_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument encoded_string_argument = { 
+	"@encoded-string", 
+	NULL, NULL,
+	arg_encoded_string_validate, 
+	NULL, NULL 
+};
+
+/* Parsing */
+
+static bool _skip_whitespace
+	(const char **in, const char *inend)
+{
+	while ( *in < inend ) {
+		if ( **in == '\r' ) {
+			(*in)++;
+			if ( **in != '\n' )
+				return FALSE;
+			continue;
+		}
+		
+		/* (Loose LF is non-standard) */
+		if ( **in != ' ' && **in != '\n' && **in != '\t' ) 
+			break;
+			
+		(*in)++;
+	}
+	
+	return TRUE;
+}
+
+static bool _parse_hexint
+(const char **in, const char *inend, int max_digits, unsigned int *result)
+{
+	int digit = 0;
+	*result = 0;
+		
+	while ( *in < inend && (max_digits == 0 || digit < max_digits) ) {
+	
+		if ( (**in) >= '0' && (**in) <= '9' ) 
+			*result = ((*result) << 4) + (**in) - ((unsigned int) '0');
+		else if ( (**in) >= 'a' && (**in) <= 'f' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) 'a') + 0x0a;
+		else if ( (**in) >= 'A' && (**in) <= 'F' )
+			*result = ((*result) << 4) + (**in) - ((unsigned int) 'A') + 0x0a;
+		else
+			return ( digit > 0 );
+	
+		(*in)++;
+		digit++;
+	}
+	
+	if ( digit == max_digits ) {
+		/* Hex digit _MUST_ end here */
+		if ( (**in >= '0' && **in <= '9')	|| (**in >= 'a' && **in <= 'f') ||
+			(**in >= 'A' && **in <= 'F') )
+			return FALSE;
+			
+		return TRUE;
+	}
+	
+	return ( digit > 0 );
+}
+
+static bool _decode_hex
+(const char **in, const char *inend, string_t *result) 
+{
+	int values = 0;
+	
+	while ( *in < inend ) {
+		unsigned int hexpair;
+		
+		if ( !_skip_whitespace(in, inend) ) return FALSE;
+		
+		if ( !_parse_hexint(in, inend, 2, &hexpair) ) break;
+		
+		str_append_c(result, (unsigned char) hexpair);
+		values++;
+	}
+	
+	return ( values > 0 );
+}
+
+static int _decode_unicode
+(const char **in, const char *inend, string_t *result, unsigned int *error_hex) 
+{
+	int values = 0;
+	bool valid = TRUE;
+	
+	while ( *in < inend ) {
+		unsigned int unicode_hex;
+		
+		if ( !_skip_whitespace(in, inend) ) return FALSE;
+		
+		if ( !_parse_hexint(in, inend, 0, &unicode_hex) ) break;
+
+		if ( (unicode_hex <= 0xD7FF) || 
+			(unicode_hex >= 0xE000 && unicode_hex <= 0x10FFFF)	) 
+			uni_ucs4_to_utf8_c((unichar_t) unicode_hex, result);
+		else {
+			if ( valid ) *error_hex = unicode_hex;
+			valid = FALSE;
+		}	
+		values++;
+	}
+	
+	return ( values > 0 );
+}
+
+bool arg_encoded_string_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd)
+{
+	bool result = TRUE;
+	enum { ST_NONE, ST_OPEN, ST_TYPE, ST_CLOSE } 
+		state = ST_NONE;
+	string_t *str = sieve_ast_argument_str(*arg);
+	string_t *tmpstr, *newstr = NULL;
+	const char *p, *mark, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	unsigned int error_hex = 0;
+
+	T_BEGIN {		
+		tmpstr = t_str_new(32);	
+			
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+			/* Normal string */
+			case ST_NONE:
+				if ( *p == '$' ) {
+					substart = p;
+					state = ST_OPEN;
+				}
+				p++;
+				break;
+			/* Parsed '$' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_TYPE;
+					p++;
+				} else 
+					state = ST_NONE;
+				break;
+			/* Parsed '${' */
+			case ST_TYPE:
+				mark = p;
+				/* Scan for 'hex' or 'unicode' */
+				while ( p < strend && i_isalpha(*p) ) p++;
+					
+				if ( *p != ':' ) {
+					state = ST_NONE;
+					break;
+				}
+				
+				state = ST_CLOSE;
+				
+				str_truncate(tmpstr, 0);
+				if ( strncasecmp(mark, "hex", p - mark) == 0 ) {
+					/* Hexadecimal */
+					p++;
+					if ( !_decode_hex(&p, strend, tmpstr) )
+						state = ST_NONE;
+				} else if ( strncasecmp(mark, "unicode", p - mark) == 0 ) {
+					/* Unicode */
+					p++;
+					if ( !_decode_unicode(&p, strend, tmpstr, &error_hex) )
+						state = ST_NONE;
+				} else {	
+					/* Invalid encoding */
+					p++;
+					state = ST_NONE;
+				}
+				break;
+			case ST_CLOSE:
+				if ( *p == '}' ) {				
+					/* We now know that the substitution is valid */	
+
+					if ( error_hex != 0 ) {
+						sieve_argument_validate_error(validator, *arg, 
+							"invalid unicode character 0x%08x in encoded character substitution",
+							error_hex);
+						result = FALSE;
+						break;
+					}
+					
+					if ( newstr == NULL ) {
+						newstr = str_new(sieve_ast_pool((*arg)->ast), str_len(str)*2);
+					}
+					
+					str_append_n(newstr, strstart, substart-strstart);
+					str_append_str(newstr, tmpstr);
+					
+					strstart = p + 1;
+					substart = strstart;
+					
+					p++;	
+				} 
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	if ( !result ) return FALSE;
+	
+	if ( newstr != NULL ) {
+		if ( strstart != strend )
+			str_append_n(newstr, strstart, strend-strstart);	
+	
+		sieve_ast_argument_string_set(*arg, newstr);
+	}
+	
+	/* Pass the processed string to a (possible) next layer of processing */
+	return sieve_validator_argument_activate_super
+		(validator, cmd, *arg, TRUE);
+}
+
+/* 
+ * Extension implementation
+ */
+
+static bool ext_encoded_character_validator_load
+(struct sieve_validator *validator ATTR_UNUSED)
+{
+	/* Override the constant string argument with our own */
+	sieve_validator_argument_override(validator, SAT_CONST_STRING, 
+		&encoded_string_argument); 
+	
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-envelope.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-envelope.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-envelope.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-envelope.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,519 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension envelope 
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+/*
+ * Forward declarations
+ */
+
+static const struct sieve_command envelope_test;
+const struct sieve_operation envelope_operation;
+const struct sieve_extension envelope_extension;
+
+/* 
+ * Extension 
+ */
+
+static bool ext_envelope_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension envelope_extension = { 
+	"envelope", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_envelope_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(envelope_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS 
+};
+
+static bool ext_envelope_validator_load(struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, &envelope_test);
+
+	return TRUE;
+}
+
+/* 
+ * Envelope test 
+ *
+ * Syntax
+ *   envelope [COMPARATOR] [ADDRESS-PART] [MATCH-TYPE]
+ *     <envelope-part: string-list> <key-list: string-list>   
+ */
+
+static bool tst_envelope_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_envelope_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_envelope_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+static const struct sieve_command envelope_test = { 
+	"envelope", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_envelope_registered, 
+	NULL,
+	tst_envelope_validate, 
+	tst_envelope_generate, 
+	NULL 
+};
+
+/* 
+ * Envelope operation 
+ */
+
+static bool ext_envelope_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_envelope_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation envelope_operation = { 
+	"ENVELOPE",
+	&envelope_extension,
+	0,
+	ext_envelope_operation_dump, 
+	ext_envelope_operation_execute 
+};
+
+/*
+ * Envelope parts
+ *
+ * FIXME: not available to extensions
+ */
+
+struct sieve_envelope_part {
+	const char *identifier;
+
+	const struct sieve_address *const *(*get_addresses)
+		(const struct sieve_runtime_env *renv);
+	const char * const *(*get_values)
+		(const struct sieve_runtime_env *renv);
+};
+
+static const struct sieve_address *const *_from_part_get_addresses
+	(const struct sieve_runtime_env *renv);
+static const char *const *_from_part_get_values
+	(const struct sieve_runtime_env *renv);
+static const struct sieve_address *const *_to_part_get_addresses
+	(const struct sieve_runtime_env *renv);
+static const char *const *_to_part_get_values
+	(const struct sieve_runtime_env *renv);
+static const char *const *_auth_part_get_values
+	(const struct sieve_runtime_env *renv);
+
+static const struct sieve_envelope_part _from_part = {
+	"from",
+	_from_part_get_addresses,
+	_from_part_get_values,
+};
+
+static const struct sieve_envelope_part _to_part = {
+	"to",
+	_to_part_get_addresses,
+	_to_part_get_values,
+};	
+
+static const struct sieve_envelope_part _auth_part = {
+	"auth",
+	NULL,
+	_auth_part_get_values,
+};	
+
+static const struct sieve_envelope_part *_envelope_parts[] = {
+	/* Required */
+	&_from_part, &_to_part, 
+
+	/* Non-standard */
+	&_auth_part
+};
+
+static unsigned int _envelope_part_count = N_ELEMENTS(_envelope_parts);
+
+static const struct sieve_envelope_part *_envelope_part_find
+(const char *identifier)
+{
+	unsigned int i;
+
+	for ( i = 0; i < _envelope_part_count; i++ ) {
+		if ( strcasecmp( _envelope_parts[i]->identifier, identifier ) == 0 ) {
+			return _envelope_parts[i];
+        }
+	}
+	
+	return NULL;
+}
+
+
+/* 
+ * Command Registration 
+ */
+
+static bool tst_envelope_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_AM_OPT_COMPARATOR);
+	sieve_address_parts_link_tags(validator, cmd_reg, SIEVE_AM_OPT_ADDRESS_PART);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_AM_OPT_MATCH_TYPE);
+	
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static int _envelope_part_is_supported
+(void *context, struct sieve_ast_argument *arg)
+{
+	const struct sieve_envelope_part **not_address =
+		(const struct sieve_envelope_part **) context;
+
+	if ( sieve_argument_is_string_literal(arg) ) {
+		const struct sieve_envelope_part *epart;
+
+		if ( (epart=_envelope_part_find(sieve_ast_strlist_strc(arg))) != NULL ) {
+			if ( epart->get_addresses == NULL ) {
+				if ( *not_address == NULL )
+					*not_address = epart;
+			}
+					
+			return TRUE;
+		}
+		
+		return FALSE;
+	} 
+	
+	return TRUE; /* Can't check at compile time */
+}
+
+static bool tst_envelope_validate
+(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_ast_argument *epart;
+	const struct sieve_envelope_part *not_address = NULL;
+				
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "envelope part", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+		
+	/* Check whether supplied envelope parts are supported
+	 *   FIXME: verify dynamic envelope parts at runtime 
+	 */
+	epart = arg;
+	if ( !sieve_ast_stringlist_map(&epart, (void *) &not_address, 
+		_envelope_part_is_supported) ) {		
+		
+		sieve_argument_validate_error(validator, epart, 
+			"specified envelope part '%s' is not supported by the envelope test", 
+				str_sanitize(sieve_ast_strlist_strc(epart), 64));
+		return FALSE;
+	}
+
+	if ( not_address != NULL ) {
+		struct sieve_ast_argument *addrp_arg = 
+			sieve_command_find_argument(tst, &address_part_tag);
+
+		if ( addrp_arg != NULL ) {
+			sieve_argument_validate_error(validator, addrp_arg,
+				"address part ':%s' specified while non-address envelope part '%s' "
+				"is tested with the envelope test",
+                sieve_ast_argument_tag(addrp_arg), not_address->identifier);
+	        return FALSE;
+		}
+	}
+	
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool tst_envelope_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	(void)sieve_operation_emit_code(cgenv->sbin, &envelope_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool ext_envelope_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "ENVELOPE");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_addrmatch_default_dump_optionals(denv, address) )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "envelope part") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static const struct sieve_address *const *_from_part_get_addresses
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const struct sieve_address *);
+	const struct sieve_address *address =
+		sieve_address_parse_envelope_path(renv->msgdata->return_path);
+	
+	if ( address != NULL ) {
+		t_array_init(&envelope_values, 2);
+
+        array_append(&envelope_values, &address, 1);
+
+	    (void)array_append_space(&envelope_values);
+    	return array_idx(&envelope_values, 0);
+	} 
+
+	return NULL;
+}
+
+static const char *const *_from_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->return_path != NULL ) {
+        array_append(&envelope_values, &renv->msgdata->return_path, 1);
+	}
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+static const struct sieve_address *const *_to_part_get_addresses
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const struct sieve_address *);
+	const struct sieve_address *address = 
+		sieve_address_parse_envelope_path(renv->msgdata->to_address);	
+
+	if ( address != NULL && address->local_part != NULL ) {
+		t_array_init(&envelope_values, 2);
+
+        array_append(&envelope_values, &address, 1);
+
+	    (void)array_append_space(&envelope_values);
+    	return array_idx(&envelope_values, 0);
+	}
+
+	return NULL;
+}
+
+static const char *const *_to_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->to_address != NULL ) {
+        array_append(&envelope_values, &renv->msgdata->to_address, 1);
+	}
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+
+static const char *const *_auth_part_get_values
+(const struct sieve_runtime_env *renv)
+{
+	ARRAY_DEFINE(envelope_values, const char *);
+
+	t_array_init(&envelope_values, 2);
+
+	if ( renv->msgdata->auth_user != NULL )
+        array_append(&envelope_values, &renv->msgdata->auth_user, 1);
+
+	(void)array_append_space(&envelope_values);
+
+	return array_idx(&envelope_values, 0);
+}
+
+static int ext_envelope_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	const struct sieve_address_part *addrp = &all_address_part;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *envp_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *envp_item;
+	bool matched;
+	int ret;
+
+	/*
+	 * Read operands
+	 */
+	
+	sieve_runtime_trace(renv, "ENVELOPE test");
+
+	if ( (ret=sieve_addrmatch_default_get_optionals
+		(renv, address, &addrp, &mtch, &cmp)) <= 0 )
+		return ret; 
+
+	/* Read envelope-part */
+	if ( (envp_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid envelope-part operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list);
+	
+	/* Iterate through all requested headers to match */
+	envp_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(envp_list, &envp_item)) 
+		&& envp_item != NULL ) {
+		const struct sieve_envelope_part *epart;
+			
+		if ( (epart=_envelope_part_find(str_c(envp_item))) != NULL ) {
+			const struct sieve_address * const *addresses = NULL;
+			int i;
+
+			if ( epart->get_addresses != NULL ) {
+				/* Field contains addresses */
+				addresses = epart->get_addresses(renv);
+
+				if ( addresses != NULL ) {
+					for ( i = 0; !matched && addresses[i] != NULL; i++ ) {
+						if ( addresses[i]->local_part == NULL ) {
+							/* Null path <> */
+							ret = sieve_match_value(mctx, "", 0);
+						} else {
+							const char *part = addrp->extract_from(addresses[i]);
+							if ( part != NULL ) 
+								ret = sieve_match_value(mctx, part, strlen(part));
+						}
+
+						if ( ret < 0 ) {
+							result = FALSE;
+							break;
+						}
+
+       	        		matched = ret > 0;
+					}
+				}
+			} 
+
+			if ( epart->get_values != NULL && addresses == NULL && 
+				addrp == &all_address_part ) {
+				/* Field contains something else */
+				const char *const *values = epart->get_values(renv);
+
+				if ( values == NULL ) continue;
+	
+				for ( i = 0; !matched && values[i] != NULL; i++ ) {				
+
+					if ( (ret=sieve_match_value
+						(mctx, values[i], strlen(values[i]))) < 0 ) {
+	                    result = FALSE;
+    	                break;
+        	        }
+			
+					matched = ret > 0;				
+				}
+			}
+		}
+	}
+	
+	/* Finish match */
+	if ( (ret=sieve_match_end(mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+
+	if ( result ) {
+		/* Set test result for subsequent conditional jump */
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string-list item");	
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-fileinto.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-fileinto.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-fileinto.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-fileinto.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,223 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension fileinto 
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228
+ * Implementation: full
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "imap-utf7.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_command fileinto_command;
+const struct sieve_operation fileinto_operation;
+const struct sieve_extension fileinto_extension; 
+
+/* 
+ * Extension
+ */
+
+static bool ext_fileinto_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension fileinto_extension = { 
+	"fileinto", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_fileinto_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(fileinto_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS	
+};
+
+static bool ext_fileinto_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &fileinto_command);
+
+	return TRUE;
+}
+
+/* 
+ * Fileinto command
+ *
+ * Syntax: 
+ *   fileinto <folder: string>
+ */
+
+static bool cmd_fileinto_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_fileinto_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+static const struct sieve_command fileinto_command = { 
+	"fileinto", 
+	SCT_COMMAND,
+	1, 0, FALSE, FALSE, 
+	NULL, NULL,
+	cmd_fileinto_validate, 
+	cmd_fileinto_generate, 
+	NULL 
+};
+
+/* 
+ * Fileinto operation 
+ */
+
+static bool ext_fileinto_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_fileinto_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address); 
+
+const struct sieve_operation fileinto_operation = { 
+	"FILEINTO",
+	&fileinto_extension,
+	0,
+	ext_fileinto_operation_dump, 
+	ext_fileinto_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_fileinto_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "folder", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_fileinto_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &fileinto_operation);
+
+	/* Emit line number */
+    sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool ext_fileinto_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "FILEINTO");
+	sieve_code_descend(denv);
+
+	/* Source line */
+    if ( !sieve_code_source_line_dump(denv, address) )
+        return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) ) {
+		return FALSE;
+	}
+
+	return sieve_opr_string_dump(denv, address, "folder");
+}
+
+/*
+ * Execution
+ */
+
+static int ext_fileinto_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL; 
+	string_t *folder, *folder_utf7;
+	const char *mailbox;
+	unsigned int source_line;
+	int ret = 0;
+	
+	/*
+	 * Read operands
+	 */
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */
+	if ( (ret=sieve_interpreter_handle_optional_operands(renv, address, &slist)) 
+		<= 0 )
+		return ret;
+
+	/* Folder operand */
+	if ( !sieve_opr_string_read(renv, address, &folder) ) {
+		sieve_runtime_trace_error(renv, "invalid folder operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	mailbox = str_sanitize(str_c(folder), 64);
+	sieve_runtime_trace(renv, "FILEINTO action (\"%s\")", mailbox);
+		
+	/* Convert utf-8 folder name to utf-7
+	 *   FIXME: perform this at compile time when possible.
+	 */
+	folder_utf7 = t_str_new(256);
+	if ( imap_utf8_to_utf7(str_c(folder), folder_utf7) < 0 ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"mailbox name not utf-8: %s", mailbox);
+	}	
+		
+	/* Add action to result */	
+	ret = sieve_act_store_add_to_result
+		(renv, slist, str_c(folder_utf7), source_line);
+
+	return ( ret >= 0 );
+}
+
+
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-reject.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-reject.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/ext-reject.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/ext-reject.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,456 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension reject 
+ * ----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC5228, draft-ietf-sieve-refuse-reject-04
+ * Implementation: full  
+ * Status: experimental, largely untested
+ *
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "hostpid.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "message-size.h"
+#include "istream.h"
+#include "istream-header-filter.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_command reject_command;
+struct sieve_operation reject_operation;
+struct sieve_extension reject_extension; 
+
+/* 
+ * Extension
+ */
+
+static bool ext_reject_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+struct sieve_extension reject_extension = { 
+	"reject", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_reject_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(reject_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_reject_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &reject_command);
+
+	return TRUE;
+}
+
+/* 
+ * Reject command
+ * 
+ * Syntax: 
+ *   reject <reason: string>
+ */
+
+static bool cmd_reject_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_reject_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx); 
+
+static const struct sieve_command reject_command = { 
+	"reject", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_reject_validate, 
+	cmd_reject_generate, 
+	NULL 
+};
+
+/* 
+ * Reject operation 
+ */
+
+static bool ext_reject_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_reject_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+struct sieve_operation reject_operation = { 
+	"REJECT",
+	&reject_extension, 
+	0,
+	ext_reject_operation_dump, 
+	ext_reject_operation_execute 
+};
+
+/* 
+ * Reject action 
+ */
+
+static int act_reject_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+int act_reject_check_conflict
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_reject_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_reject_commit
+	(const struct sieve_action *action ATTR_UNUSED, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+		
+const struct sieve_action act_reject = {
+	"reject",
+	SIEVE_ACTFLAG_SENDS_RESPONSE,
+	NULL,
+	act_reject_check_duplicate, 
+	act_reject_check_conflict,
+	act_reject_print,
+	NULL, NULL,
+	act_reject_commit,
+	NULL
+};
+
+struct act_reject_context {
+	const char *reason;
+};
+
+/* 
+ * Validation 
+ */
+
+static bool cmd_reject_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+		
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, cmd, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_reject_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &reject_operation);
+
+	/* Emit line number */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool ext_reject_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "REJECT");
+	sieve_code_descend(denv);
+	
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	if ( !sieve_code_dumper_print_optional_operands(denv, address) )
+		return FALSE;
+	
+	return
+		sieve_opr_string_dump(denv, address, "reason");
+}
+
+/*
+ * Interpretation
+ */
+
+static int ext_reject_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_reject_context *act;
+	string_t *reason;
+	unsigned int source_line;
+	pool_t pool;
+	int ret;
+
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands (side effects) */
+	if ( (ret=sieve_interpreter_handle_optional_operands
+		(renv, address, &slist)) <= 0 )
+		return ret;
+
+	/* Read rejection reason */
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "REJECT action (\"%s\")", str_sanitize(str_c(reason), 64));
+
+	/* Add reject action to the result */
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_reject_context, 1);
+	act->reason = p_strdup(pool, str_c(reason));
+	
+	ret = sieve_result_add_action
+		(renv, &act_reject, slist, source_line, (void *) act, 0);
+	
+	return ( ret >= 0 );
+}
+
+/*
+ * Action implementation
+ */
+
+static int act_reject_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( !act_other->executed ) {
+		sieve_runtime_error(renv, act->location, 
+			"duplicate reject action not allowed "
+			"(previously triggered one was here: %s)", act_other->location);	
+		return -1;
+	}
+	
+	return 1;
+}
+ 
+int act_reject_check_conflict
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( (act_other->action->flags & SIEVE_ACTFLAG_TRIES_DELIVER) > 0 ) {
+		if ( !act_other->executed ) {
+			sieve_runtime_error(renv, act->location, 
+				"reject action conflicts with other action: "
+				"the %s action (%s) tries to deliver the message",
+				act_other->action->name, act_other->location);	
+			return -1;
+		}
+	}
+
+	if ( (act_other->action->flags & SIEVE_ACTFLAG_SENDS_RESPONSE) > 0 ) {
+		struct act_reject_context *rj_ctx;
+
+		if ( !act_other->executed ) {
+			sieve_runtime_error(renv, act->location, 
+				"reject action conflicts with other action: "
+				"the %s action (%s) also sends a response to the sender",
+				act_other->action->name, act_other->location);	
+			return -1;
+		}
+
+		rj_ctx = (struct act_reject_context *) act->context;
+		rj_ctx->reason = NULL;
+	}
+
+	return 0;
+}
+ 
+static void act_reject_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, bool *keep)	
+{
+	struct act_reject_context *rj_ctx = (struct act_reject_context *) context;
+	
+	if ( rj_ctx->reason != NULL ) {
+		sieve_result_action_printf(rpenv, "reject message with reason: %s", 
+			str_sanitize(rj_ctx->reason, 128));
+	} else {
+		sieve_result_action_printf(rpenv, "reject message without sending a response (discard)"); 		
+	}
+	
+	*keep = FALSE;
+}
+
+static bool act_reject_send	
+	(const struct sieve_action_exec_env *aenv, struct act_reject_context *ctx)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	struct istream *input;
+	void *smtp_handle;
+	struct message_size hdr_size;
+	FILE *f;
+	const char *new_msgid, *boundary;
+	const unsigned char *data;
+	const char *header;
+	size_t size;
+	int ret;
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "reject action has no means to send mail");
+		return TRUE;
+	}
+
+	smtp_handle = senv->smtp_open(msgdata->return_path, NULL, &f);
+
+	new_msgid = sieve_message_get_new_id(senv);
+	boundary = t_strdup_printf("%s/%s", my_pid, senv->hostname);
+
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+	rfc2822_header_field_write(f, "Message-ID", new_msgid);
+	rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+	rfc2822_header_field_printf(f, "From", "Mail Delivery Subsystem <%s>",
+		senv->postmaster_address);
+	rfc2822_header_field_printf(f, "To", "<%s>", msgdata->return_path);
+	rfc2822_header_field_write(f, "Subject", "Automatically rejected mail");
+	rfc2822_header_field_write(f, "Auto-Submitted", "auto-replied (rejected)");
+	rfc2822_header_field_write(f, "Precedence", "bulk");
+	
+	rfc2822_header_field_write(f, "MIME-Version", "1.0");
+	rfc2822_header_field_printf(f, "Content-Type", 
+		"multipart/report; report-type=disposition-notification;\n"
+		"boundary=\"%s\"", boundary);
+	
+	fprintf(f, "\r\nThis is a MIME-encapsulated message\r\n\r\n");
+
+	/* Human readable status report */
+	fprintf(f, "--%s\r\n", boundary);
+	fprintf(f, "Content-Type: text/plain; charset=utf-8\r\n");
+	fprintf(f, "Content-Disposition: inline\r\n");
+	fprintf(f, "Content-Transfer-Encoding: 8bit\r\n\r\n");
+
+	/* FIXME: var_expand_table expansion not possible */
+	fprintf(f, "Your message to <%s> was automatically rejected:\r\n"	
+		"%s\r\n", msgdata->to_address, ctx->reason);
+
+	/* MDN status report */
+	fprintf(f, "--%s\r\n"
+		"Content-Type: message/disposition-notification\r\n\r\n", boundary);
+	fprintf(f, "Reporting-UA: %s; Dovecot Mail Delivery Agent\r\n",
+		senv->hostname);
+	if (mail_get_first_header(msgdata->mail, "Original-Recipient", &header) > 0)
+		fprintf(f, "Original-Recipient: rfc822; %s\r\n", header);
+	fprintf(f, "Final-Recipient: rfc822; %s\r\n",	msgdata->to_address);
+
+	if ( msgdata->id != NULL )
+		fprintf(f, "Original-Message-ID: %s\r\n", msgdata->id);
+	fprintf(f, "Disposition: "
+		"automatic-action/MDN-sent-automatically; deleted\r\n");
+	fprintf(f, "\r\n");
+
+	/* original message's headers */
+	fprintf(f, "--%s\r\nContent-Type: message/rfc822\r\n\r\n", boundary);
+
+	if (mail_get_stream(msgdata->mail, &hdr_size, NULL, &input) == 0) {
+    /* Note: If you add more headers, they need to be sorted.
+       We'll drop Content-Type because we're not including the message
+       body, and having a multipart Content-Type may confuse some
+       MIME parsers when they don't see the message boundaries. */
+    static const char *const exclude_headers[] = {
+	    "Content-Type"
+    };
+
+    input = i_stream_create_header_filter(input,
+    	HEADER_FILTER_EXCLUDE | HEADER_FILTER_NO_CR | HEADER_FILTER_HIDE_BODY, 
+    	exclude_headers, N_ELEMENTS(exclude_headers), 
+    	null_header_filter_callback, NULL);
+
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			if (fwrite(data, size, 1, f) == 0)
+				break;
+				i_stream_skip(input, size);
+		}
+		i_stream_unref(&input);
+			
+		i_assert(ret != 0);
+	}
+
+	fprintf(f, "\r\n\r\n--%s--\r\n", boundary);
+
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv, 
+			"failed to send rejection message to <%s> "
+			"(refer to server log for more information)",
+			str_sanitize(msgdata->return_path, 80));
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool act_reject_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	struct act_reject_context *rj_ctx = (struct act_reject_context *) tr_context;
+	
+	if ( rj_ctx->reason == NULL ) {
+		sieve_result_log(aenv, "discarded reject (would cause second response to sender)");
+    
+		*keep = FALSE;
+		return TRUE;
+	}
+
+	if ( msgdata->return_path == NULL || *(msgdata->return_path) == '\0' ) {
+		sieve_result_log(aenv, "discarded reject to <>");
+    
+		*keep = FALSE;
+		return TRUE;
+	}
+		
+	if ( act_reject_send(aenv, rj_ctx) ) {
+		sieve_result_log(aenv, "rejected message from <%s>",
+			str_sanitize(msgdata->return_path, 80));	
+
+		*keep = FALSE;
+		return TRUE;
+	}
+	  
+	return FALSE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,128 @@
+SUBDIRS = plugins
+
+noinst_LTLIBRARIES = libsieve.la
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-imap
+
+tests = \
+	tst-truefalse.c \
+	tst-not.c \
+	tst-anyof.c \
+	tst-allof.c \
+	tst-address.c \
+	tst-header.c \
+	tst-exists.c \
+	tst-size.c
+
+commands = \
+	cmd-require.c \
+	cmd-stop.c \
+	cmd-if.c \
+	cmd-keep.c \
+	cmd-redirect.c \
+	cmd-discard.c
+
+extensions = \
+	ext-fileinto.c \
+	ext-reject.c \
+	ext-envelope.c \
+	ext-encoded-character.c
+
+match_types = \
+	mcht-is.c \
+	mcht-contains.c \
+	mcht-matches.c
+
+comparators = \
+	cmp-i-octet.c \
+	cmp-i-ascii-casemap.c
+
+# These are not actual plugins just yet...
+plugins = \
+	./plugins/vacation/libsieve_ext_vacation.la \
+	./plugins/subaddress/libsieve_ext_subaddress.la \
+ 	./plugins/comparator-i-ascii-numeric/libsieve_ext_comparator-i-ascii-numeric.la \
+	./plugins/relational/libsieve_ext_relational.la \
+	./plugins/regex/libsieve_ext_regex.la \
+	./plugins/copy/libsieve_ext_copy.la \
+	./plugins/imap4flags/libsieve_ext_imap4flags.la \
+	./plugins/include/libsieve_ext_include.la \
+	./plugins/body/libsieve_ext_body.la \
+	./plugins/variables/libsieve_ext_variables.la \
+	./plugins/enotify/libsieve_ext_enotify.la \
+	./plugins/environment/libsieve_ext_environment.la
+
+libsieve_la_DEPENDENCIES = $(plugins)
+libsieve_la_LIBADD = $(plugins)
+
+libsieve_la_SOURCES = \
+	rfc2822.c \
+	sieve-limits.c \
+	sieve-message.c \
+	sieve-lexer.c \
+	sieve-script.c \
+	sieve-ast.c \
+	sieve-binary.c \
+	sieve-parser.c \
+	sieve-address.c \
+	sieve-validator.c \
+	sieve-generator.c \
+	sieve-interpreter.c \
+	sieve-code-dumper.c \
+	sieve-binary-dumper.c \
+	sieve-result.c \
+	sieve-error.c \
+	sieve-objects.c \
+	sieve-comparators.c \
+	sieve-match-types.c \
+	sieve-address-parts.c \
+	sieve-match.c \
+	sieve-commands.c \
+	sieve-code.c \
+	sieve-actions.c \
+	sieve-extensions.c \
+	$(comparators) \
+	$(match_types) \
+	$(tests) \
+	$(commands) \
+	$(extensions) \
+	sieve.c 
+
+noinst_HEADERS = \
+	rfc2822.h \
+	sieve-config.h \
+	sieve-types.h \
+	sieve-common.h \
+	sieve-limits.h \
+	sieve-message.h \
+	sieve-lexer.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve-ast.h \
+	sieve-binary.h \
+	sieve-parser.h \
+	sieve-address.h \
+	sieve-validator.h \
+	sieve-generator.h \
+	sieve-interpreter.h \
+	sieve-code-dumper.h \
+	sieve-binary-dumper.h \
+	sieve-dump.h \
+	sieve-result.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-objects.h \
+	sieve-match.h \
+	sieve-comparators.h \
+	sieve-match-types.h \
+	sieve-address-parts.h \
+	sieve-commands.h \
+	sieve-code.h \
+	sieve-actions.h \
+	sieve-extensions.h \
+	sieve.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/mcht-contains.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/mcht-contains.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/mcht-contains.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/mcht-contains.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,69 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* Match-type ':contains' 
+ */
+
+#include "lib.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */ 
+
+static int mcht_contains_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type contains_match_type = {
+	SIEVE_OBJECT("contains", &match_type_operand,	SIEVE_MATCH_TYPE_CONTAINS),
+	TRUE, TRUE,
+	NULL,
+	sieve_match_substring_validate_context,
+	NULL,
+	mcht_contains_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+/* FIXME: Naive substring match implementation. Should switch to more 
+ * efficient algorithm if large values need to be searched (e.g. message body).
+ */
+static int mcht_contains_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = mctx->comparator;
+	const char *vend = (const char *) val + val_size;
+	const char *kend = (const char *) key + key_size;
+	const char *vp = val;
+	const char *kp = key;
+
+	if ( val == NULL || val_size == 0 ) 
+		return ( key_size == 0 );
+
+	if ( mctx->comparator->char_match == NULL ) 
+		return FALSE;
+
+	while ( (vp < vend) && (kp < kend) ) {
+		if ( !cmp->char_match(cmp, &vp, vend, &kp, kend) )
+			vp++;
+	}
+    
+	return (kp == kend);
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/mcht-is.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/mcht-is.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/mcht-is.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/mcht-is.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,54 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+/* Match-type ':is': 
+ */
+
+#include "lib.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/* 
+ * Forward declarations 
+ */
+
+static int mcht_is_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+
+/* 
+ * Match-type object 
+ */
+
+const struct sieve_match_type is_match_type = {
+	SIEVE_OBJECT("is", &match_type_operand, SIEVE_MATCH_TYPE_IS),
+	TRUE, TRUE,
+	NULL, NULL, NULL,
+	mcht_is_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+static int mcht_is_match
+(struct sieve_match_context *mctx ATTR_UNUSED, 
+	const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	if ( (val == NULL || val_size == 0) ) 
+		return ( key_size == 0 );
+
+	if ( mctx->comparator->compare != NULL )
+		return (mctx->comparator->compare(mctx->comparator, 
+			val, val_size, key, key_size) == 0);
+
+	return FALSE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/mcht-matches.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/mcht-matches.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/mcht-matches.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/mcht-matches.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,434 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+/* Match-type ':matches' 
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-match-types.h"
+#include "sieve-comparators.h"
+#include "sieve-match.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/*
+ * Forward declarations
+ */
+
+static int mcht_matches_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+
+/*
+ * Match-type object
+ */
+
+const struct sieve_match_type matches_match_type = {
+	SIEVE_OBJECT("matches", &match_type_operand, SIEVE_MATCH_TYPE_MATCHES),
+	TRUE, FALSE,
+	NULL,
+	sieve_match_substring_validate_context, 
+	NULL,
+	mcht_matches_match,
+	NULL
+};
+
+/*
+ * Match-type implementation
+ */
+
+/* Quick 'n dirty debug */
+//#define MATCH_DEBUG
+#ifdef MATCH_DEBUG
+#define debug_printf(...) printf ("match debug: " __VA_ARGS__)
+#else
+#define debug_printf(...) 
+#endif
+
+/* FIXME: Naive implementation, substitute this with dovecot src/lib/str-find.c
+ */
+static inline bool _string_find(const struct sieve_comparator *cmp, 
+	const char **valp, const char *vend, const char **keyp, const char *kend)
+{
+	while ( (*valp < vend) && (*keyp < kend) ) {
+		if ( !cmp->char_match(cmp, valp, vend, keyp, kend) )
+			(*valp)++;
+	}
+	
+	return (*keyp == kend);
+}
+
+static char _scan_key_section
+	(string_t *section, const char **wcardp, const char *key_end)
+{
+	/* Find next wildcard and resolve escape sequences */	
+	str_truncate(section, 0);
+	while ( *wcardp < key_end && **wcardp != '*' && **wcardp != '?') {
+		if ( **wcardp == '\\' ) {
+			(*wcardp)++;
+		}
+		str_append_c(section, **wcardp);
+		(*wcardp)++;
+	}
+	
+	/* Record wildcard character or \0 */
+	if ( *wcardp < key_end ) {			
+		return **wcardp;
+	} 
+	
+	i_assert( *wcardp == key_end );
+	return '\0';
+}
+
+static int mcht_matches_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = mctx->comparator;
+	struct sieve_match_values *mvalues;
+	string_t *mvalue = NULL, *mchars = NULL;
+	string_t *section, *subsection;
+	const char *vend, *kend, *vp, *kp, *wp, *pvp;
+	bool backtrack = FALSE; /* TRUE: match of '?'-connected sections failed */
+	char wcard = '\0';      /* Current wildcard */
+	char next_wcard = '\0'; /* Next  widlcard */
+	unsigned int key_offset = 0;
+
+	/* Value may be NULL, parse empty string in stead */
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+	
+	/* Key sections */
+	section = t_str_new(32);    /* Section (after beginning or *) */
+	subsection = t_str_new(32); /* Sub-section (after ?) */
+	
+	/* Mark end of value and key */
+	vend = (const char *) val + val_size;
+	kend = (const char *) key + key_size;
+
+	/* Initialize pointers */
+	vp = val;                   /* Value pointer */
+	kp = key;                   /* Key pointer */
+	wp = key;                   /* Wildcard (key) pointer */
+	pvp = val;                  /* Previous value Pointer */
+
+	/* Start match values list if requested */
+	if ( (mvalues = sieve_match_values_start(mctx->interp)) != NULL ) {
+		/* Skip ${0} for now; added when match succeeds */
+		sieve_match_values_add(mvalues, NULL);
+
+		mvalue = t_str_new(32);     /* Match value (*) */
+		mchars = t_str_new(32);     /* Match characters (.?..?.??) */
+	}
+	
+	/* Match the pattern: 
+	 *   <pattern> = <section>*<section>*<section>...
+	 *   <section> = <sub-section>?<sub-section>?<sub-section>...
+	 *
+	 * Escape sequences \? and \* need special attention. 
+	 */
+	 
+	debug_printf("=== Start ===\n");
+	debug_printf("  key:   %s\n", t_strdup_until(key, kend));
+	debug_printf("  value: %s\n", t_strdup_until(val, vend));
+
+	/* Loop until either key or value ends */
+	while (kp < kend && vp < vend ) {
+		const char *needle, *nend;
+		
+		if ( !backtrack ) {
+			/* Search the next '*' wildcard in the key string */
+
+			wcard = next_wcard;
+			
+			/* Find the needle to look for in the string */	
+			key_offset = 0;	
+			for (;;) {
+				next_wcard = _scan_key_section(section, &wp, kend);
+				
+				if ( wcard == '\0' || str_len(section) > 0 ) 
+					break;
+					
+				if ( next_wcard == '*' ) {	
+					break;
+				}
+					
+				if ( wp < kend ) 
+					wp++;
+				else 
+					break;
+				key_offset++;
+			}
+			
+			debug_printf("found wildcard '%c' at pos [%d]\n", 
+				next_wcard, (int) (wp-key));
+	
+			if ( mvalues != NULL )			
+				str_truncate(mvalue, 0);
+		} else {
+			/* Backtracked; '*' wildcard is retained */
+			debug_printf("backtracked");
+			backtrack = FALSE;
+		}
+		
+		/* Determine what we are looking for */
+		needle = str_c(section);
+		nend = PTR_OFFSET(needle, str_len(section));		
+		 
+		debug_printf("  section needle:  '%s'\n", t_strdup_until(needle, nend));
+		debug_printf("  section key:     '%s'\n", t_strdup_until(kp, kend));
+		debug_printf("  section remnant: '%s'\n", t_strdup_until(wp, kend));
+		debug_printf("  value remnant:   '%s'\n", t_strdup_until(vp, vend));
+		debug_printf("  key offset:      %d\n", key_offset);
+		
+		pvp = vp;
+		if ( next_wcard == '\0' ) {
+			/* No more wildcards; find the needle substring at the end of string */
+	
+			const char *qp, *qend;
+			
+			debug_printf("next_wcard = NUL; must find needle at end\n");				 
+
+			/* Check if the value is still large enough */			
+			if ( vend - str_len(section) < vp ) {
+				debug_printf("  wont match: value is too short\n");
+				break;
+			}
+
+			/* Move value pointer to where the needle should be */
+			vp = PTR_OFFSET(vend, -str_len(section));
+
+			/* Record match values */
+			qend = vp;
+			qp = vp - key_offset;
+		
+			if ( mvalues != NULL )
+				str_append_n(mvalue, pvp, qp-pvp);
+					
+			/* Compare needle to end of value string */
+			if ( !cmp->char_match(cmp, &vp, vend, &needle, nend) ) {	
+				debug_printf("  match at end failed\n");				 
+				break;
+			}
+			
+			/* Add match values */
+			if ( mvalues != NULL ) {
+				/* Append '*' match value */
+				sieve_match_values_add(mvalues, mvalue);
+
+				/* Append any initial '?' match values */
+				for ( ; qp < qend; qp++ )
+					sieve_match_values_add_char(mvalues, *qp); 
+			}
+
+			/* Finish match */
+			kp = kend;
+			vp = vend;
+
+			debug_printf("  matched end of value\n");
+			break;
+		} else {
+			/* Next wildcard found; match needle before next wildcard */
+
+			const char *prv = NULL; /* Stored value pointer for backtrack */
+			const char *prk = NULL; /* Stored key pointer for backtrack */
+			const char *prw = NULL; /* Stored wildcard pointer for backtrack */
+			const char *chars;
+
+			/* Reset '?' match values */
+			if ( mvalues != NULL )		
+				str_truncate(mchars, 0);
+							
+			if ( wcard == '\0' ) {
+				/* No current wildcard; match needs to happen right at the beginning */
+				debug_printf("wcard = NUL; needle should be found at the beginning.\n");
+				debug_printf("  begin needle: '%s'\n", t_strdup_until(needle, nend));
+				debug_printf("  begin value:  '%s'\n", t_strdup_until(vp, vend));
+
+				if ( !cmp->char_match(cmp, &vp, vend, &needle, nend) ) {	
+					debug_printf("  failed to find needle at beginning\n");				 
+					break;
+				}
+
+			} else {
+				/* Current wildcard present; match needle between current and next wildcard */
+				debug_printf("wcard != NUL; must find needle at an offset (>= %d).\n",
+					key_offset);
+
+				/* Match may happen at any offset (>= key offset): find substring */				
+				vp += key_offset;
+				if ( (vp >= vend) || !_string_find(cmp, &vp, vend, &needle, nend) ) {
+					debug_printf("  failed to find needle at an offset\n"); 
+					break;
+				}
+
+				prv = vp - str_len(section);
+				prk = kp;
+				prw = wp;		
+	
+				/* Append match values */
+				if ( mvalues != NULL ) {
+					const char *qend = vp - str_len(section);
+					const char *qp = qend - key_offset;
+
+					/* Append '*' match value */
+					str_append_n(mvalue, pvp, qp-pvp);
+
+					/* Append any initial '?' match values (those that caused the key
+					 * offset.
+					 */
+					for ( ; qp < qend; qp++ )
+						str_append_c(mchars, *qp);
+				}
+			}
+			
+			/* Update wildcard and key pointers for next wildcard scan */
+			if ( wp < kend ) wp++;
+			kp = wp;
+		
+			/* Scan successive '?' wildcards */
+			while ( next_wcard == '?' ) {
+				debug_printf("next_wcard = '?'; need to match arbitrary character\n");
+				
+				/* Add match value */ 
+				if ( mvalues != NULL )
+					str_append_c(mchars, *vp);
+
+				vp++;
+
+				/* Scan for next '?' wildcard */				
+				next_wcard = _scan_key_section(subsection, &wp, kend);
+				debug_printf("found next wildcard '%c' at pos [%d] (fixed match)\n", 
+					next_wcard, (int) (wp-key));
+					
+				/* Determine what we are looking for */
+				needle = str_c(subsection);
+				nend = PTR_OFFSET(needle, str_len(subsection));
+
+				debug_printf("  sub key:       '%s'\n", t_strdup_until(needle, nend));
+				debug_printf("  value remnant: '%s'\n", vp <= vend ? t_strdup_until(vp, vend) : "");
+
+				/* Try matching the needle at fixed position */
+				if ( (needle == nend && next_wcard == '\0' && vp < vend ) || 
+					!cmp->char_match(cmp, &vp, vend, &needle, nend) ) {	
+					
+					/* Match failed: now we have a problem. We need to backtrack to the previous
+					 * '*' wildcard occurence and start scanning for the next possible match.
+					 */
+
+					debug_printf("  failed fixed match\n");
+					
+					/* Start backtrack */
+					if ( prv != NULL && prv + 1 < vend ) {
+						/* Restore pointers */
+						vp = prv;
+						kp = prk;
+						wp = prw;
+				
+						/* Skip forward one value character to scan the next possible match */
+						if ( mvalues != NULL )
+							str_append_c(mvalue, *vp);
+						vp++;
+				
+						/* Set wildcard state appropriately */
+						wcard = '*';
+						next_wcard = '?';
+				
+						/* Backtrack */
+						backtrack = TRUE;				 
+
+						debug_printf("  BACKTRACK\n");
+					}
+
+					/* Break '?' wildcard scanning loop */
+					break;
+				}
+				
+				/* Update wildcard and key pointers for next wildcard scan */
+				if ( wp < kend ) wp++;
+				kp = wp;
+			}
+			
+			if ( !backtrack ) {
+				unsigned int i;
+				
+				if ( next_wcard == '?' ) {
+					debug_printf("failed to match '?'\n");	
+					break;
+				}
+				
+				if ( mvalues != NULL ) {
+					if ( prv != NULL )
+						sieve_match_values_add(mvalues, mvalue);
+
+					chars = (const char *) str_data(mchars);
+
+					for ( i = 0; i < str_len(mchars); i++ ) {
+						sieve_match_values_add_char(mvalues, chars[i]);
+					}
+				}
+
+				if ( next_wcard != '*' ) {
+					debug_printf("failed to match at end of string\n");
+					break;
+				}
+			}
+		}
+					
+		/* Check whether string ends in a wildcard 
+		 * (avoid scanning the rest of the string)
+		 */
+		if ( kp == kend && next_wcard == '*' ) {
+			/* Add the rest of the string as match value */
+			if ( mvalues != NULL ) {
+				str_truncate(mvalue, 0);
+				str_append_n(mvalue, vp, vend-vp);
+				sieve_match_values_add(mvalues, mvalue);
+			}
+		
+			/* Finish match */
+			kp = kend;
+			vp = vend;
+		
+			debug_printf("key ends with '*'\n");
+			break;
+		}			
+					
+		debug_printf("== Loop ==\n");
+	}
+
+	/* Eat away a trailing series of *s */
+	if ( vp == vend ) {
+		while ( kp < kend && *kp == '*' ) kp++;
+	}
+
+	/* By definition, the match is only successful if both value and key pattern
+	 * are exhausted.
+	 */
+	
+	debug_printf("=== Finish ===\n");
+	debug_printf("  result: %s\n", (kp == kend && vp == vend) ? "true" : "false");
+	
+	if (kp == kend && vp == vend) {
+		/* Activate new match values after successful match */
+		if ( mvalues != NULL ) {
+			/* Set ${0} */
+			string_t *matched = str_new_const(pool_datastack_create(), val, val_size);
+			sieve_match_values_set(mvalues, 0, matched);
+
+			/* Commit new match values */
+			sieve_match_values_commit(mctx->interp, &mvalues);
+		}
+		return TRUE;
+	}
+
+	/* No match; drop collected match values */
+	sieve_match_values_abort(&mvalues);
+	return FALSE;
+}
+			 
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,73 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension body 
+ * ------------------
+ *
+ * Authors: Stephan Bosch, original CMUSieve implementation by Timo Sirainen
+ * Specification: RFC 5173
+ * Implementation: full, but text body-transform implementation is simple
+ * Status: experimental, largely untested
+ *
+ */
+ 
+/* FIXME: 
+ *
+ * From RFC with respect to :text body transform:
+ *
+ * "Sophisticated implementations MAY strip mark-up from the text prior
+ *  to matching, and MAY convert media types other than text to text
+ *  prior to matching.
+ *
+ *  (For example, they may be able to convert proprietary text editor
+ *  formats to text or apply optical character recognition algorithms to
+ *  image data.)"
+ *
+ * We might want to do this in the future, i.e. we must evaluate whether this is 
+ * feasible.
+ */
+ 
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-body-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_body_validator_load(struct sieve_validator *validator);
+
+int ext_body_my_id = -1;
+
+const struct sieve_extension body_extension = { 
+	"body", 
+	&ext_body_my_id,
+	NULL, NULL,
+	ext_body_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(body_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_body_validator_load(struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, &body_test);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,343 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "array.h"
+#include "str.h"
+#include "istream.h"
+#include "rfc822-parser.h"
+#include "message-date.h"
+#include "message-parser.h"
+#include "message-decoder.h"
+
+#include "sieve-common.h"
+#include "sieve-message.h"
+#include "sieve-interpreter.h"
+
+#include "ext-body-common.h"
+
+/* This implementation is largely borrowed from the original sieve-cmu.c of the 
+ * cmusieve plugin.
+ */
+ 
+struct ext_body_part_cached {
+	const char *content_type;
+
+	const char *raw_body;
+	const char *decoded_body;
+	size_t raw_body_size;
+	size_t decoded_body_size;
+	
+	bool have_body; /* there's the empty end-of-headers line */
+};
+
+struct ext_body_message_context {
+	pool_t pool;
+	ARRAY_DEFINE(cached_body_parts, struct ext_body_part_cached);
+	ARRAY_DEFINE(return_body_parts, struct ext_body_part);
+	buffer_t *tmp_buffer;
+};
+
+static bool _is_wanted_content_type
+(const char * const *wanted_types, const char *content_type)
+{
+	const char *subtype = strchr(content_type, '/');
+	size_t type_len;
+
+	type_len = ( subtype == NULL ? strlen(content_type) :
+		(size_t)(subtype - content_type) );
+
+	i_assert( wanted_types != NULL );
+
+	for (; *wanted_types != NULL; wanted_types++) {
+		const char *wanted_subtype = strchr(*wanted_types, '/');
+
+		if (**wanted_types == '\0') {
+			/* empty string matches everything */
+			return TRUE;
+		}
+		if (wanted_subtype == NULL) {
+			/* match only main type */
+			if (strlen(*wanted_types) == type_len &&
+			    strncasecmp(*wanted_types, content_type,
+					type_len) == 0)
+				return TRUE;
+		} else {
+			/* match whole type/subtype */
+			if (strcasecmp(*wanted_types, content_type) == 0)
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+static bool ext_body_get_return_parts
+(struct ext_body_message_context *ctx, const char * const *wanted_types,
+	bool decode_to_plain)
+{
+	const struct ext_body_part_cached *body_parts;
+	unsigned int i, count;
+	struct ext_body_part *return_part;
+
+	/* Check whether any body parts are cached already */
+	body_parts = array_get(&ctx->cached_body_parts, &count);
+	if ( count == 0 )
+		return FALSE;
+
+	/* Clear result array */
+	array_clear(&ctx->return_body_parts);
+	
+	/* Fill result array with requested content_types */
+	for (i = 0; i < count; i++) {
+		if (!body_parts[i].have_body) {
+			/* Part has no body; according to RFC this MUST not match to anything and 
+			 * therefore it is not included in the result.
+			 */
+			continue;
+		}
+
+		/* Skip content types that are not requested */
+		if (!_is_wanted_content_type(wanted_types, body_parts[i].content_type))
+			continue;
+
+		/* Add new item to the result */
+		return_part = array_append_space(&ctx->return_body_parts);
+		
+		/* Depending on whether a decoded body part is requested, the appropriate
+		 * cache item is read. If it is missing, this function fails and the cache 
+		 * needs to be completed by ext_body_parts_add_missing().
+		 */
+		if (decode_to_plain) {
+			if (body_parts[i].decoded_body == NULL)
+				return FALSE;
+			return_part->content = body_parts[i].decoded_body;
+			return_part->size = body_parts[i].decoded_body_size;
+		} else {
+			if (body_parts[i].raw_body == NULL)
+				return FALSE;
+			return_part->content = body_parts[i].raw_body;
+			return_part->size = body_parts[i].raw_body_size;
+		}
+	}
+
+	return TRUE;
+}
+
+static void ext_body_part_save
+(struct ext_body_message_context *ctx, struct message_part *part,
+	struct ext_body_part_cached *body_part, bool decoded)
+{
+	buffer_t *buf = ctx->tmp_buffer;
+	char *part_data;
+	size_t part_size;
+
+	/* Add terminating NUL to the body part buffer */
+	buffer_append_c(buf, '\0');
+
+	part_data = p_malloc(ctx->pool, buf->used);
+	memcpy(part_data, buf->data, buf->used);
+	part_size = buf->used - 1;
+	
+	/* Depending on whether the part is decoded or not store message body in the
+	 * appropriate cache location.
+	 */
+	if ( !decoded ) {
+		body_part->raw_body = part_data;
+		body_part->raw_body_size = part_size;
+		i_assert(buf->used - 1 == part->body_size.physical_size);
+	} else {
+		body_part->decoded_body = part_data;
+		body_part->decoded_body_size = part_size;
+	}
+	
+	/* Clear buffer */
+	buffer_set_used_size(buf, 0);
+}
+
+static const char *_parse_content_type(const struct message_header_line *hdr)
+{
+	struct rfc822_parser_context parser;
+	string_t *content_type;
+
+	rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);
+	(void)rfc822_skip_lwsp(&parser);
+
+	content_type = t_str_new(64);
+	if (rfc822_parse_content_type(&parser, content_type) < 0)
+		return "";
+	return str_c(content_type);
+}
+
+/* ext_body_parts_add_missing():
+ *   Add requested message body parts to the cache that are missing. 
+ */
+static bool ext_body_parts_add_missing
+(const struct sieve_message_data *msgdata, struct ext_body_message_context *ctx, 
+	const char * const *content_types, bool decode_to_plain)
+{
+	struct ext_body_part_cached *body_part = NULL;
+	struct message_parser_ctx *parser;
+	struct message_decoder_context *decoder;
+	struct message_block block, decoded;
+	struct message_part *parts, *prev_part = NULL;
+	struct istream *input;
+	unsigned int idx = 0;
+	bool save_body = FALSE, have_all;
+	int ret;
+
+	/* First check whether any are missing */
+	if (ext_body_get_return_parts(ctx, content_types, decode_to_plain)) {
+		/* Cache hit; all are present */
+		return TRUE;
+	}
+
+	/* Get the message stream */
+	if ( mail_get_stream(msgdata->mail, NULL, NULL, &input) < 0 )
+		return FALSE;
+		
+	buffer_set_used_size(ctx->tmp_buffer, 0);
+	
+	/* Initialize body decoder */
+	decoder = decode_to_plain ? message_decoder_init(FALSE) : NULL;
+	
+	parser = message_parser_init
+		(ctx->pool, input, 0, MESSAGE_PARSER_FLAG_SKIP_BODY_BLOCK);
+	while ( (ret = message_parser_parse_next_block(parser, &block)) > 0 ) {
+		if ( block.part != prev_part ) {
+			/* Save previous body part */
+			if ( body_part != NULL && save_body ) {
+				ext_body_part_save(ctx, prev_part, body_part, decoder != NULL);
+			}
+			
+			/* Start processing next */
+			prev_part = block.part;
+			body_part = array_idx_modifiable(&ctx->cached_body_parts, idx);
+			idx++;
+			body_part->content_type = "text/plain";
+		}
+		
+		if ( block.hdr != NULL || block.size == 0 ) {
+			/* reading headers */
+			if ( decoder != NULL ) {
+				(void)message_decoder_decode_next_block(decoder,
+					&block, &decoded);
+			}
+
+			if ( block.hdr == NULL ) {
+				/* save bodies only if we have a wanted
+				   content-type */
+				save_body = _is_wanted_content_type
+					(content_types, body_part->content_type);
+				continue;
+			}
+			
+			/* Encountered the empty line that indicates the end of the headers and 
+			 * the start of the body
+			 */
+			if ( block.hdr->eoh )
+				body_part->have_body = TRUE;
+				
+			/* We're interested of only Content-Type: header */
+			if ( strcasecmp(block.hdr->name, "Content-Type" ) != 0)
+				continue;
+
+			/* Header can have folding whitespace. Acquire the full value before 
+			 * continuing
+			 */
+			if ( block.hdr->continues ) {
+				block.hdr->use_full_value = TRUE;
+				continue;
+			}
+		
+			/* Parse the content type from the Content-type header */
+			T_BEGIN {
+				body_part->content_type =
+					p_strdup(ctx->pool, _parse_content_type(block.hdr));
+			} T_END;
+			
+			continue;
+		}
+
+		/* reading body */
+		if (save_body) {
+			if (decoder != NULL) {
+				(void)message_decoder_decode_next_block(decoder,
+							&block, &decoded);
+				buffer_append(ctx->tmp_buffer,
+					      decoded.data, decoded.size);
+			} else {
+				buffer_append(ctx->tmp_buffer,
+					      block.data, block.size);
+			}
+		}
+	}
+
+	/* Save last body part if necessary */
+	if (body_part != NULL && save_body)
+		ext_body_part_save(ctx, prev_part, body_part, decoder != NULL);
+
+	/* Try to fill the return_body_parts array once more */
+	have_all = ext_body_get_return_parts(ctx, content_types, decode_to_plain);
+	
+	/* This time, failure is a bug */
+	i_assert(have_all);
+
+	/* Cleanup */
+	(void)message_parser_deinit(&parser, &parts);
+	if (decoder != NULL)
+		message_decoder_deinit(&decoder);
+	
+	/* Return status */
+	return ( input->stream_errno == 0 );
+}
+
+static struct ext_body_message_context *ext_body_get_context
+(struct sieve_message_context *msgctx)
+{
+	pool_t pool = sieve_message_context_pool(msgctx);
+	struct ext_body_message_context *ctx;
+	
+	/* Get message context (contains cached message body information) */
+	ctx = (struct ext_body_message_context *)
+		sieve_message_context_extension_get(msgctx, &body_extension);
+	
+	/* Create it if it does not exist already */
+	if ( ctx == NULL ) {
+		ctx = p_new(pool, struct ext_body_message_context, 1);	
+		ctx->pool = pool;
+		p_array_init(&ctx->cached_body_parts, pool, 8);
+		p_array_init(&ctx->return_body_parts, pool, 8);
+		ctx->tmp_buffer = buffer_create_dynamic(pool, 1024*64);
+		
+		/* Register context */
+		sieve_message_context_extension_set(msgctx, &body_extension, (void *) ctx);
+	}
+	
+	return ctx;
+}
+
+bool ext_body_get_content
+(const struct sieve_runtime_env *renv, const char * const *content_types,
+	int decode_to_plain, struct ext_body_part **parts_r)
+{
+	bool result = TRUE;
+	struct ext_body_message_context *ctx = ext_body_get_context(renv->msgctx);
+
+	T_BEGIN {
+		/* Fill the return_body_parts array */
+		if ( !ext_body_parts_add_missing
+			(renv->msgdata, ctx, content_types, decode_to_plain != 0) )
+			result = FALSE;
+	} T_END;
+	
+	/* Check status */
+	if ( !result ) return FALSE;
+
+	/* Return the array of body items */
+	(void) array_append_space(&ctx->return_body_parts); /* NULL-terminate */
+	*parts_r = array_idx_modifiable(&ctx->return_body_parts, 0);
+
+	return result;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/ext-body-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,38 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_BODY_COMMON_H
+#define __EXT_BODY_COMMON_H
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension body_extension;
+
+/* 
+ * Commands
+ */
+
+extern const struct sieve_command body_test;
+ 
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation body_operation;
+
+/*
+ * Message body part extraction
+ */
+
+struct ext_body_part {
+	const char *content;
+	unsigned long size;
+};
+
+bool ext_body_get_content
+(const struct sieve_runtime_env *renv, const char * const *content_types,
+	int decode_to_plain, struct ext_body_part **parts_r);
+
+#endif /* __EXT_BODY_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_body.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tsts = \
+	tst-body.c
+
+libsieve_ext_body_la_SOURCES = \
+	ext-body-common.c \
+	$(tsts) \
+	ext-body.c
+
+noinst_HEADERS = \
+	ext-body-common.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/body/tst-body.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,425 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-body-common.h"
+
+/*
+ * Types
+ */
+
+enum tst_body_transform {
+	TST_BODY_TRANSFORM_RAW,
+	TST_BODY_TRANSFORM_CONTENT,
+	TST_BODY_TRANSFORM_TEXT
+};
+
+/* 
+ * Body test 
+ *
+ * Syntax
+ *   body [COMPARATOR] [MATCH-TYPE] [BODY-TRANSFORM]
+ *     <key-list: string-list>
+ */
+
+static bool tst_body_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_body_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_body_generate
+	(const struct sieve_codegen_env *cgenv,	struct sieve_command_context *ctx);
+
+const struct sieve_command body_test = { 
+	"body", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	tst_body_registered, 
+	NULL,
+	tst_body_validate, 
+	tst_body_generate, 
+	NULL 
+};
+
+/* 
+ * Body operation 
+ */
+
+static bool ext_body_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_body_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation body_operation = { 
+	"body",
+	&body_extension,
+	0,
+	ext_body_operation_dump, 
+	ext_body_operation_execute 
+};
+
+/*
+ * Optional operands
+ */
+
+enum tst_body_optional {	
+	OPT_BODY_TRANSFORM = SIEVE_MATCH_OPT_LAST
+};
+
+/* 
+ * Tagged arguments 
+ */
+
+/* Forward declarations */
+
+static bool tag_body_transform_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_body_transform_generate	
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+ 
+static const struct sieve_argument body_raw_tag = { 
+	"raw", 
+	NULL, NULL,
+	tag_body_transform_validate, 
+	NULL, 
+	tag_body_transform_generate 
+};
+
+static const struct sieve_argument body_content_tag = { 
+	"content", 
+	NULL, NULL,
+	tag_body_transform_validate, 
+	NULL, 
+	tag_body_transform_generate 
+};
+
+static const struct sieve_argument body_text_tag = { 
+	"text", 
+	NULL, NULL,
+	tag_body_transform_validate, 
+	NULL, 
+	tag_body_transform_generate
+};
+
+/* Argument implementation */
+ 
+static bool tag_body_transform_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	enum tst_body_transform transform;
+	struct sieve_ast_argument *tag = *arg;
+
+	/* BODY-TRANSFORM:
+	 *   :raw
+	 *     / :content <content-types: string-list>
+	 *     / :text
+	 */
+	if ( (bool) cmd->data ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"the :raw, :content and :text arguments for the body test are mutually "
+			"exclusive, but more than one was specified");
+		return FALSE;
+	}
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	/* :content tag has a string-list argument */
+	if ( tag->argument == &body_raw_tag ) 
+		transform = TST_BODY_TRANSFORM_RAW;
+		
+	else if ( tag->argument == &body_text_tag )
+		transform = TST_BODY_TRANSFORM_TEXT;
+		
+	else if ( tag->argument == &body_content_tag ) {
+		/* Check syntax:
+		 *   :content <content-types: string-list>
+		 */
+		if ( !sieve_validate_tag_parameter
+			(validator, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+			return FALSE;
+		}
+		
+		if ( !sieve_validator_argument_activate(validator, cmd, *arg, FALSE) )
+			return FALSE;
+		
+		/* Assign tag parameters */
+		tag->parameters = *arg;
+		*arg = sieve_ast_arguments_detach(*arg,1);
+		
+		transform = TST_BODY_TRANSFORM_CONTENT;
+	} else 
+		return FALSE;
+	
+	/* Signal the presence of this tag */
+	cmd->data = (void *) TRUE;
+		
+	/* Assign context data */
+	tag->context = (void *) transform;	
+		
+	return TRUE;
+}
+
+/* 
+ * Command Registration 
+ */
+
+static bool tst_body_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &body_raw_tag, OPT_BODY_TRANSFORM); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &body_content_tag, OPT_BODY_TRANSFORM); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &body_text_tag, OPT_BODY_TRANSFORM); 	
+	
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static bool tst_body_validate
+(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+					
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool tst_body_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	(void)sieve_operation_emit_code(cgenv->sbin, &body_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+static bool tag_body_transform_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	enum tst_body_transform transform =	(enum tst_body_transform) arg->context;
+	
+	sieve_binary_emit_byte(cgenv->sbin, transform);
+	sieve_generate_argument_parameters(cgenv, cmd, arg); 
+			
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool ext_body_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	enum tst_body_transform transform;
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "BODY");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_BODY_TRANSFORM:
+			if ( !sieve_binary_read_byte(denv->sbin, address, &transform) )
+				return FALSE;
+			
+			switch ( transform ) {
+			case TST_BODY_TRANSFORM_RAW:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: RAW");
+				break;
+			case TST_BODY_TRANSFORM_TEXT:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: TEXT");
+				break;
+			case TST_BODY_TRANSFORM_CONTENT:
+				sieve_code_dumpf(denv, "BODY-TRANSFORM: CONTENT");
+				
+				sieve_code_descend(denv);
+				if ( !sieve_opr_stringlist_dump(denv, address, "content types") )
+					return FALSE;
+				sieve_code_ascend(denv);
+				break;
+			default:
+				return FALSE;
+			}
+			break;
+		default: 
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+
+	return sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static int ext_body_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	static const char * const _no_content_types[] = { "", NULL };
+	
+	int ret = SIEVE_EXEC_OK;
+	int opt_code = 0;
+	int mret;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	enum tst_body_transform transform;
+	struct sieve_coded_stringlist *key_list, *ctype_list = NULL;
+	struct sieve_match_context *mctx;
+	const char * const *content_types = _no_content_types;
+	struct ext_body_part *body_parts;
+	bool mvalues_active;
+	bool matched;
+
+	/*
+	 * Read operands
+	 */
+	
+	/* Handle any optional operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+			
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END: 
+			break;
+		case OPT_BODY_TRANSFORM:
+			if ( !sieve_binary_read_byte(renv->sbin, address, &transform) ||
+				transform > TST_BODY_TRANSFORM_TEXT ) {
+				sieve_runtime_trace_error(renv, "invalid body transform type");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			
+			if ( transform == TST_BODY_TRANSFORM_CONTENT ) {				
+				if ( (ctype_list=sieve_opr_stringlist_read(renv, address)) 
+					== NULL ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid :content body transform operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			}
+			break;
+
+		default:
+			sieve_runtime_trace_error(renv, "unknown optional operand");
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+		
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	if ( ctype_list != NULL && !sieve_coded_stringlist_read_all
+		(ctype_list, pool_datastack_create(), &content_types) ) {
+		sieve_runtime_trace_error(renv, "invalid content-type-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "BODY action");
+	
+	/* Extract requested parts */
+	
+	if ( !ext_body_get_content
+		(renv, content_types, transform != TST_BODY_TRANSFORM_RAW, &body_parts) ) {
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	/* Disable match values processing as required by RFC */
+		
+	mvalues_active = sieve_match_values_set_enabled(renv->interp, FALSE);
+
+	/* Iterate through all requested body parts to match */
+
+	matched = FALSE;	
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+	while ( !matched && body_parts->content != NULL ) {
+		if ( (mret=sieve_match_value(mctx, body_parts->content, body_parts->size)) 	
+			< 0) 
+		{
+			sieve_runtime_trace_error(renv, "invalid string list item");
+			ret = SIEVE_EXEC_BIN_CORRUPT;
+			break;
+		}
+		
+		matched = ( mret > 0 );			
+		body_parts++;	
+	}
+
+	if ( (mret=sieve_match_end(mctx)) < 0 ) {
+		sieve_runtime_trace_error(renv, "invalid string list item");
+		ret = SIEVE_EXEC_BIN_CORRUPT;
+	} else	
+		matched = ( mret > 0 || matched ); 	
+	
+	/* Restore match values processing */ 
+	
+	(void)sieve_match_values_set_enabled(renv->interp, mvalues_active);
+	
+	/* Set test result */	
+	
+	if ( ret == SIEVE_EXEC_OK )
+		sieve_interpreter_set_test_result(renv->interp, matched);
+
+	return ret;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/ext-cmp-i-ascii-numeric.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,166 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */ 
+
+/* Extension comparator-i;ascii-numeric
+ * ------------------------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 2244
+ * Implementation: full
+ * Status: experimental, largely untested
+ * 
+ */
+ 
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-comparators.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include <ctype.h>
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_operand my_comparator_operand;
+
+const struct sieve_comparator i_ascii_numeric_comparator;
+
+static bool ext_cmp_i_ascii_numeric_validator_load
+	(struct sieve_validator *validator);
+
+/* 
+ * Extension
+ */
+
+static int ext_my_id = -1;
+
+const struct sieve_extension comparator_i_ascii_numeric_extension = { 
+	"comparator-i;ascii-numeric", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_cmp_i_ascii_numeric_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(my_comparator_operand)
+};
+
+static bool ext_cmp_i_ascii_numeric_validator_load
+	(struct sieve_validator *validator)
+{
+	sieve_comparator_register(validator, &i_ascii_numeric_comparator);
+	return TRUE;
+}
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_comparators =
+	SIEVE_EXT_DEFINE_COMPARATOR(i_ascii_numeric_comparator);
+	
+static const struct sieve_operand my_comparator_operand = { 
+	"comparator-i;ascii-numeric", 
+	&comparator_i_ascii_numeric_extension,
+	0, 
+	&sieve_comparator_operand_class,
+	&ext_comparators
+};
+
+/*
+ * Comparator
+ */
+
+/* Forward declarations */
+ 
+static int cmp_i_ascii_numeric_compare
+	(const struct sieve_comparator *cmp, 
+		const char *val1, size_t val1_size, const char *val2, size_t val2_size);
+
+/* Comparator object */
+
+const struct sieve_comparator i_ascii_numeric_comparator = { 
+	SIEVE_OBJECT("i;ascii-numeric", &my_comparator_operand, 0),
+	SIEVE_COMPARATOR_FLAG_ORDERING | SIEVE_COMPARATOR_FLAG_EQUALITY,
+	cmp_i_ascii_numeric_compare,
+	NULL,
+	NULL
+};
+
+/* Comparator implementation */
+
+static int cmp_i_ascii_numeric_compare
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char *val, size_t val_size, const char *key, size_t key_size)
+{	
+	const char *vend = val + val_size;
+	const char *kend = key + key_size;
+	const char *vp = val;
+	const char *kp = key;
+	int digits, i;
+
+	/* RFC 4790: All input is valid; strings that do not start with a digit 
+	 * represent positive infinity.
+	 */
+	if ( !i_isdigit(*vp) ) {
+		if ( i_isdigit(*kp) ) {
+			/* Value is greater */
+			return -1;
+		}
+	} else {
+		if ( !i_isdigit(*kp) ) {
+            /* Value is less */
+            return -1;
+        }
+	}
+	
+	/* Ignore leading zeros */
+
+	while ( *vp == '0' && vp < vend )  
+		vp++;
+
+	while ( *kp == '0' && kp < kend )  
+		kp++;
+
+	/* Check whether both numbers are equally long in terms of digits */
+
+	digits = 0;
+	while ( vp < vend && kp < kend && i_isdigit(*vp) && i_isdigit(*kp) ) {
+		vp++;
+		kp++;
+		digits++;	
+	}
+
+	if ( vp == vend || !i_isdigit(*vp) ) {
+		if ( kp != kend && i_isdigit(*kp) ) {
+			/* Value is less */
+			return -1;
+		}
+	} else {
+		/* Value is greater */	
+		return 1;
+	}
+
+	/* Equally long: compare digits */
+
+	vp -= digits;
+	kp -= digits;
+	i = 0;
+	while ( i < digits ) {
+		if ( *vp > *kp )
+			return 1;
+		else if ( *vp < *kp )
+			return -1;
+
+		kp++;
+		vp++;
+		i++;
+	}
+		
+	return 0;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/comparator-i-ascii-numeric/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_comparator-i-ascii-numeric.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_comparator_i_ascii_numeric_la_SOURCES = \
+	ext-cmp-i-ascii-numeric.c
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/copy/ext-copy.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,175 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension copy
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 3894
+ * Implementation: full
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+/* 
+ * Forward declarations 
+ */
+
+static const struct sieve_argument copy_tag;
+static const struct sieve_operand copy_side_effect_operand;
+
+/* 
+ * Extension
+ */
+
+static bool ext_copy_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension copy_extension = { 
+	"copy", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_copy_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_OPERAND(copy_side_effect_operand)
+};
+
+static bool ext_copy_validator_load(struct sieve_validator *validator)
+{
+	/* Register copy tag with redirect and fileinto commands and we don't care
+	 * whether these commands are registered or even whether they will be
+	 * registered at all. The validator handles either situation gracefully 
+	 */
+	sieve_validator_register_external_tag(validator, &copy_tag, "redirect", -1);
+	sieve_validator_register_external_tag(validator, &copy_tag, "fileinto", -1);
+
+	return TRUE;
+}
+
+/*
+ * Side effect 
+ */
+
+static void seff_copy_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *se_context, bool *keep);
+static void seff_copy_post_commit
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *se_context,
+		void *tr_context, bool *keep);
+
+const struct sieve_side_effect copy_side_effect = {
+	SIEVE_OBJECT("copy", &copy_side_effect_operand, 0),
+	&act_store,
+	NULL, NULL, NULL,
+	seff_copy_print,
+	NULL, NULL,
+	seff_copy_post_commit, 
+	NULL
+};
+
+/* 
+ * Tagged argument 
+ */
+
+static bool tag_copy_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_copy_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *context);
+
+static const struct sieve_argument copy_tag = { 
+	"copy", 
+	NULL, NULL,
+	tag_copy_validate, 
+	NULL,
+	tag_copy_generate
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(copy_side_effect);
+
+static const struct sieve_operand copy_side_effect_operand = {
+	"copy operand",
+	&copy_extension,
+	0,
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool tag_copy_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tag_copy_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+    struct sieve_command_context *context ATTR_UNUSED)
+{
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit(cgenv->sbin, &copy_side_effect);
+
+	return TRUE;
+}
+
+/* 
+ * Side effect implementation
+ */
+
+static void seff_copy_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv,
+	void *se_context ATTR_UNUSED, bool *keep)
+{
+	sieve_result_seffect_printf(rpenv, "preserve implicit keep");
+
+	*keep = TRUE;
+}
+
+static void seff_copy_post_commit
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv ATTR_UNUSED, 
+		void *se_context ATTR_UNUSED,	void *tr_context ATTR_UNUSED, bool *keep)
+{	
+	*keep = TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/copy/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_copy.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_copy_la_SOURCES = \
+	ext-copy.c
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/cmd-notify.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,606 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+
+#include "ext-enotify-common.h"
+
+/* 
+ * Forward declarations 
+ */
+ 
+static const struct sieve_argument notify_importance_tag;
+static const struct sieve_argument notify_from_tag;
+static const struct sieve_argument notify_options_tag;
+static const struct sieve_argument notify_message_tag;
+
+/* 
+ * Notify command 
+ *	
+ * Syntax: 
+ *    notify [":from" string]
+ *           [":importance" <"1" / "2" / "3">]
+ *           [":options" string-list]
+ *           [":message" string]
+ *           <method: string>
+ */
+
+static bool cmd_notify_registered
+	(struct sieve_validator *valdtr, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_notify_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_notify_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+static bool cmd_notify_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command notify_command = { 
+	"notify",
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE, 
+	cmd_notify_registered,
+	cmd_notify_pre_validate,
+	cmd_notify_validate, 
+	cmd_notify_generate, 
+	NULL 
+};
+
+/*
+ * Notify command tags
+ */
+
+/* Forward declarations */
+
+static bool cmd_notify_validate_string_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_notify_validate_stringlist_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_notify_validate_importance_tag
+	(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument notify_from_tag = { 
+	"from", 
+	NULL, NULL,
+	cmd_notify_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_options_tag = { 
+	"options", 
+	NULL, NULL,
+	cmd_notify_validate_stringlist_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_message_tag = { 
+	"message", 
+	NULL, NULL, 
+	cmd_notify_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument notify_importance_tag = { 
+	"importance", 
+	NULL, NULL,
+	cmd_notify_validate_importance_tag, 
+	NULL, NULL 
+};
+
+/* Codes for optional arguments */
+
+enum cmd_notify_optional {
+	OPT_END,
+	OPT_FROM,
+	OPT_OPTIONS,
+	OPT_MESSAGE,
+	OPT_IMPORTANCE
+};
+
+/* 
+ * Notify operation 
+ */
+
+static bool cmd_notify_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_notify_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation notify_operation = { 
+	"NOTIFY",
+	&enotify_extension,
+	EXT_ENOTIFY_OPERATION_NOTIFY,
+	cmd_notify_operation_dump, 
+	cmd_notify_operation_execute
+};
+
+/* 
+ * Notify action 
+ */
+
+/* Forward declarations */
+
+static int act_notify_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act,
+		const struct sieve_action_data *act_other);
+static void act_notify_print
+	(const struct sieve_action *action, const struct sieve_result_print_env *rpenv,
+		void *context, bool *keep);	
+static bool act_notify_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv, 
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action act_notify = {
+	"notify",
+	0,
+	NULL,
+	act_notify_check_duplicate, 
+	NULL,
+	act_notify_print,
+	NULL, NULL,
+	act_notify_commit,
+	NULL
+};
+
+/*
+ * Command validation context
+ */
+ 
+struct cmd_notify_context_data {
+	struct sieve_ast_argument *from;
+	struct sieve_ast_argument *message;
+	struct sieve_ast_argument *options;
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool cmd_notify_validate_string_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :from <string>
+	 *   :message <string>
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING) )
+		return FALSE;
+
+	if ( tag->argument == &notify_from_tag ) {
+		ctx_data->from = *arg;
+		
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+		
+	} else if ( tag->argument == &notify_message_tag ) {
+		ctx_data->message = *arg;
+
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);	
+	}
+			
+	return TRUE;
+}
+
+static bool cmd_notify_validate_stringlist_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :options string-list
+	 */
+	if ( !sieve_validate_tag_parameter(valdtr, cmd, tag, *arg, SAAT_STRING_LIST) ) 
+		return FALSE;
+		
+	/* Assign context */
+	ctx_data->options = *arg;	
+	
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_notify_validate_importance_tag
+(struct sieve_validator *valdtr, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	const struct sieve_ast_argument *tag = *arg;
+	const char *impstr;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	/* Check syntax: 
+	 *   :importance <"1" / "2" / "3">
+	 */
+
+	if ( sieve_ast_argument_type(*arg) != SAAT_STRING ) {
+		/* Not a string */
+		sieve_argument_validate_error(valdtr, *arg, 
+			"the :importance tag for the notify command requires a string parameter, "
+			"but %s was found", sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+
+	impstr = sieve_ast_argument_strc(*arg);
+
+	if ( impstr[0] < '1' || impstr[0]  > '3' || impstr[1] != '\0' ) {
+		/* Invalid importance */
+		sieve_argument_validate_error(valdtr, *arg, 
+			"invalid :importance value for notify command: %s", impstr);
+		return FALSE;
+	} 
+
+	sieve_ast_argument_number_substitute(*arg, impstr[0] - '0');
+	(*arg)->arg_id_code = tag->arg_id_code;
+	(*arg)->argument = &number_argument;
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+			
+	return TRUE;
+}
+
+
+/* 
+ * Command registration 
+ */
+
+static bool cmd_notify_registered
+(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_importance_tag, OPT_IMPORTANCE); 	
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_from_tag, OPT_FROM); 	
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_options_tag, OPT_OPTIONS); 	
+	sieve_validator_register_tag
+		(valdtr, cmd_reg, &notify_message_tag, OPT_MESSAGE); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+
+static bool cmd_notify_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd) 
+{
+	struct cmd_notify_context_data *ctx_data;
+	
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), 
+		struct cmd_notify_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+ 
+static bool cmd_notify_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_notify_context_data *ctx_data = 
+		(struct cmd_notify_context_data *) cmd->data; 
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, cmd, arg, "method", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, cmd, arg, FALSE) )
+		return FALSE;
+		
+	return ext_enotify_compile_check_arguments
+		(valdtr, arg, ctx_data->message, ctx_data->from, ctx_data->options);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_notify_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{		 
+	sieve_operation_emit_code(cgenv->sbin, &notify_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_notify_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "NOTIFY");
+	sieve_code_descend(denv);	
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_dump(denv, address, "importance") )
+					return FALSE;
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_dump(denv, address, "from") )
+					return FALSE;
+				break;
+			case OPT_OPTIONS:
+				if ( !sieve_opr_stringlist_dump(denv, address, "options") )
+					return FALSE;
+				break;
+			case OPT_MESSAGE:
+				if ( !sieve_opr_string_dump(denv, address, "message") )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	/* Dump reason and handle operands */
+	return 
+		sieve_opr_string_dump(denv, address, "method");
+}
+
+/* 
+ * Code execution
+ */
+ 
+static int cmd_notify_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct sieve_side_effects_list *slist = NULL;
+	struct sieve_enotify_action *act;
+	void *method_context;
+	pool_t pool;
+	int opt_code = 1, result = SIEVE_EXEC_OK;
+	sieve_number_t importance = 1;
+	struct sieve_coded_stringlist *options = NULL;
+	const struct sieve_enotify_method *method;
+	string_t *method_uri, *message = NULL, *from = NULL; 
+	unsigned int source_line;
+
+	/*
+	 * Read operands
+	 */
+		
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_IMPORTANCE:
+				if ( !sieve_opr_number_read(renv, address, &importance) ) {
+					sieve_runtime_trace_error(renv, "invalid importance operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+	
+				/* Enforce 0 < importance < 4 (just to be sure) */
+				if ( importance < 1 ) 
+					importance = 1;
+				else if ( importance > 3 )
+					importance = 3;
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_read(renv, address, &from) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MESSAGE:
+				if ( !sieve_opr_string_read(renv, address, &message) ) {
+					sieve_runtime_trace_error(renv, "invalid from operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_OPTIONS:
+				if ( (options=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid options operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				sieve_runtime_trace_error(renv, "unknown optional operand: %d", 
+					opt_code);
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+	
+	/* Reason operand */
+	if ( !sieve_opr_string_read(renv, address, &method_uri) ) {
+		sieve_runtime_trace_error(renv, "invalid method operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY action");	
+
+	/* Check operands */
+
+	if ( (result=ext_enotify_runtime_check_operands
+		(renv, source_line, method_uri, message, from, options, &method, 
+			&method_context)) ) 
+	{
+		/* Add notify action to the result */
+
+		pool = sieve_result_pool(renv->result);
+		act = p_new(pool, struct sieve_enotify_action, 1);
+		act->method = method;
+		act->method_context = method_context;
+		act->importance = importance;
+		if ( message != NULL )
+			act->message = p_strdup(pool, str_c(message));
+		if ( from != NULL )
+			act->from = p_strdup(pool, str_c(from));
+		
+		return ( sieve_result_add_action
+			(renv, &act_notify, slist, source_line, (void *) act, 0) >= 0 );
+	}
+	
+	return result;
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_notify_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	const struct sieve_action_data *act ATTR_UNUSED,
+	const struct sieve_action_data *act_other ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *nact1, *nact2;
+	struct sieve_enotify_log nlog;
+		
+	if ( act->context == NULL || act_other->context == NULL )
+		return 0;
+
+	nact1 = (const struct sieve_enotify_action *) act->context;
+	nact2 = (const struct sieve_enotify_action *) act_other->context;
+
+	if ( nact1->method == NULL || nact1->method->action_check_duplicates == NULL )
+		return 0;
+
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.location = act->location;
+	nlog.ehandler = sieve_result_get_error_handler(renv->result);
+
+	return nact1->method->action_check_duplicates
+		(&nlog, nact1->method_context, nact2->method_context, act_other->location);
+}
+
+/* Result printing */
+ 
+static void act_notify_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, 
+	bool *keep ATTR_UNUSED)	
+{
+	const struct sieve_enotify_action *act = 
+		(const struct sieve_enotify_action *) context;
+
+	sieve_result_action_printf
+		( rpenv, "send notification with method '%s:':", act->method->identifier);
+		
+	if ( act->method->action_print != NULL ) {
+		struct sieve_enotify_print_env penv;
+
+		memset(&penv, 0, sizeof(penv));
+		penv.result_penv = rpenv;
+
+		act->method->action_print(&penv, act);
+	}
+}
+
+/* Result execution */
+
+static bool act_notify_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, 
+	bool *keep ATTR_UNUSED)
+{
+	const struct sieve_enotify_action *act = 
+		(const struct sieve_enotify_action *) tr_context;
+	struct sieve_enotify_exec_env nenv;
+	struct sieve_enotify_log nlog;
+		
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.location = sieve_action_get_location(aenv);
+	nlog.ehandler = sieve_result_get_error_handler(aenv->result);
+
+	nenv.scriptenv = aenv->scriptenv;
+	nenv.msgdata = aenv->msgdata;
+	nenv.notify_log = &nlog;
+
+	if ( act->method->action_execute != NULL )
+		return act->method->action_execute(&nenv, act);
+			
+	return TRUE;
+}
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension enotify
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5435
+ * Implementation: full
+ * Status: testing
+ * 
+ */
+	
+#include <stdio.h>
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Operations
+ */
+
+const struct sieve_operation *ext_enotify_operations[] = {
+	&notify_operation,
+	&valid_notify_method_operation,
+	&notify_method_capability_operation
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_enotify_load(void);
+static void ext_enotify_unload(void);
+static bool ext_enotify_validator_load(struct sieve_validator *valdtr);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension enotify_extension = { 
+	"enotify", 
+	&ext_my_id,
+	ext_enotify_load,
+	ext_enotify_unload,
+	ext_enotify_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_enotify_operations),
+	SIEVE_EXT_DEFINE_OPERAND(encodeurl_operand)
+};
+
+static bool ext_enotify_load(void)
+{
+	ext_enotify_methods_init();
+
+	sieve_extension_capabilities_register(&notify_capabilities);
+
+	return TRUE;
+}
+
+static void ext_enotify_unload(void)
+{
+	ext_enotify_methods_deinit();
+}
+
+static bool ext_enotify_validator_load(struct sieve_validator *valdtr)
+{
+	/* Register new commands */
+	sieve_validator_register_command(valdtr, &notify_command);
+	sieve_validator_register_command(valdtr, &valid_notify_method_test);
+	sieve_validator_register_command(valdtr, &notify_method_capability_test);
+	
+	/* Register new set modifier for variables extension */
+	sieve_variables_modifier_register(valdtr, &encodeurl_modifier);
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,629 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+
+#include "ext-enotify-limits.h"
+#include "ext-enotify-common.h"
+
+#include <ctype.h>
+
+/* FIXME: (from draft RFC)
+ *
+ * Header/envelope tests [Sieve] together with Sieve variables can be
+ * used to extract the list of users to receive notifications from the
+ * incoming email message or its envelope.  This is potentially quite
+ * dangerous, as this can be used for Deny Of Service attacks on
+ * recipients controlled by the message sender.  For this reason
+ * implementations SHOULD NOT allow use of variables containing values
+ * extracted from the email message in the method parameter to the
+ * notify action.  Note that violation of this SHOULD NOT may result in
+ * the creation of an open relay, i.e. any sender would be able to
+ * create specially crafted email messages that would result in
+ * notifications delivered to recipients under the control of the
+ * sender.  In worst case this might result in financial loss by user
+ * controlling the Sieve script and/or by recipients of notifications
+ * (e.g. if a notification is an SMS message).
+ *
+ * --> This is currently not possible to check.
+ */
+
+/*
+ * Notify capability
+ */
+
+static const char *ext_notify_get_methods_string(void);
+
+const struct sieve_extension_capabilities notify_capabilities = {
+	"notify",
+	&enotify_extension,
+	ext_notify_get_methods_string
+};
+
+/*
+ * Notify method registry
+ */
+ 
+static ARRAY_DEFINE(ext_enotify_methods, const struct sieve_enotify_method *); 
+
+void ext_enotify_methods_init(void)
+{
+	p_array_init(&ext_enotify_methods, default_pool, 4);
+
+	sieve_enotify_method_register(&mailto_notify);
+}
+
+void ext_enotify_methods_deinit(void)
+{
+	array_free(&ext_enotify_methods);
+}
+
+void sieve_enotify_method_register(const struct sieve_enotify_method *method) 
+{
+	array_append(&ext_enotify_methods, &method, 1);
+}
+
+const struct sieve_enotify_method *ext_enotify_method_find
+(const char *identifier) 
+{
+	unsigned int meth_count, i;
+	const struct sieve_enotify_method *const *methods;
+	 
+	methods = array_get(&ext_enotify_methods, &meth_count);
+		
+	for ( i = 0; i < meth_count; i++ ) {
+		if ( strcasecmp(methods[i]->identifier, identifier) == 0 ) {
+			return methods[i];
+		}
+	}
+	
+	return NULL;
+}
+
+static const char *ext_notify_get_methods_string(void)
+{
+	unsigned int meth_count, i;
+	const struct sieve_enotify_method *const *methods;
+	string_t *result = t_str_new(128);
+	 
+	methods = array_get(&ext_enotify_methods, &meth_count);
+		
+	if ( meth_count > 0 ) {
+		str_append(result, methods[0]->identifier);
+		
+		for ( i = 1; i < meth_count; i++ ) {
+			str_append_c(result, ' ');
+			str_append(result, methods[i]->identifier);
+		}
+		
+		return str_c(result);
+	}
+	
+	return NULL;
+}
+
+/*
+ * Compile-time argument validation
+ */
+ 
+static const char *ext_enotify_uri_scheme_parse(const char **uri_p)
+{
+	string_t *scheme = t_str_new(EXT_ENOTIFY_MAX_SCHEME_LEN);
+	const char *p = *uri_p;
+	unsigned int len = 0;
+	
+	/* RFC 3968:
+	 *
+	 *   scheme  = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+	 *
+	 * FIXME: we do not allow '%' in schemes. Is this correct?
+	 */
+	 
+	if ( !i_isalpha(*p) )
+		return NULL;
+		
+	str_append_c(scheme, *p);
+	p++;
+		
+	while ( *p != '\0' && len < EXT_ENOTIFY_MAX_SCHEME_LEN ) {
+			
+		if ( !i_isalnum(*p) && *p != '+' && *p != '-' && *p != '.' )
+			break;
+	
+		str_append_c(scheme, *p);
+		p++;
+		len++;
+	}
+	
+	if ( *p != ':' )
+		return NULL;
+	p++;
+	
+	*uri_p = p;
+	return str_c(scheme);
+}
+
+static bool ext_enotify_option_parse
+(struct sieve_enotify_log *nlog, const char *option, bool name_only,
+	const char **opt_name_r, const char **opt_value_r)
+{
+	const char *p = option;
+	
+	/* "<optionname>=<value>".
+	 * 
+	 * l-d = ALPHA / DIGIT
+	 * l-d-p = l-d / "." / "-" / "_"
+	 * optionname = l-d *l-d-p
+	 * value = *(%x01-09 / %x0B-0C / %x0E-FF)
+	 */
+				
+	/* 
+	 * Parse option name 
+	 *
+	 * optionname = l-d *l-d-p
+	 */
+	
+	/* Explicitly report empty option as such */
+	if ( *p == '\0' ) {
+		sieve_enotify_error(nlog, "empty option specified");
+		return FALSE;
+	}
+
+	/* l-d = ALPHA / DIGIT */
+	if ( i_isalnum(*p) ) {
+		p++;
+	
+		/* l-d-p = l-d / "." / "-" / "_" */
+		while ( i_isalnum(*p) || *p == '.' || *p == '-' || *p == '_' )
+			p++;
+	}
+	
+	/* Parsing must end at '=' and we must parse at least one character */
+	if ( *p != '=' || p == option ) {
+		sieve_enotify_error(nlog, "invalid option name specified in option '%s'",
+				str_sanitize(option, 80));
+		return FALSE;
+	}
+	
+	/* Assign option name */
+	if ( opt_name_r != NULL ) 
+		*opt_name_r = t_strdup_until(option, p);
+	
+	/* Skip '=' */
+	p++;
+	
+	/* Exit now if only the option name is of interest */
+	if ( name_only )
+		return TRUE;
+			
+	/* 
+	 * Parse option value
+	 */
+	 
+	/* value = *(%x01-09 / %x0B-0C / %x0E-FF) */
+	while ( *p != '\0' && *p != 0x0A && *p != 0x0D )
+		p++;
+		
+	/* Parse must end at end of string */
+	if ( *p != '\0' ) {
+		sieve_enotify_error(nlog, 
+			"notify command: invalid option value specified in option '%s'",
+				str_sanitize(option, 80));
+		return FALSE;
+	}
+	
+	/* Assign option value */
+	if ( opt_value_r != NULL )
+		*opt_value_r = p;
+		
+	return TRUE;
+} 
+
+struct _ext_enotify_option_check_context {
+	struct sieve_validator *valdtr;
+	const struct sieve_enotify_method *method;
+};
+
+static int _ext_enotify_option_check
+(void *context, struct sieve_ast_argument *arg)
+{
+	struct _ext_enotify_option_check_context *optn_context = 
+		(struct _ext_enotify_option_check_context *) context;
+	struct sieve_validator *valdtr = optn_context->valdtr;
+	const struct sieve_enotify_method *method = optn_context->method;
+	struct sieve_enotify_log nlog;
+	const char *option = sieve_ast_argument_strc(arg);
+	const char *opt_name = NULL, *opt_value = NULL;
+	bool literal = sieve_argument_is_string_literal(arg);
+	
+	/* Compose log structure */
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.ehandler = sieve_validator_error_handler(valdtr);
+	nlog.prefix = "notify command";
+	nlog.location = sieve_error_script_location
+		(sieve_validator_script(valdtr), arg->source_line);
+		
+	/* Parse option */
+	if ( !literal ) {
+		/* Variable string: partial option parse
+		 * 
+		 * If the string item is not a string literal, it cannot be validated fully
+		 * at compile time. We can however check whether the '=' is in the string
+		 * specification and whether the part before the '=' is a valid option name.
+		 * In that case, the method option check function is called with the value
+		 * parameter equal to NULL, meaning that it should only check the validity
+		 * of the option itself and not the assigned value.
+		 */ 
+		if ( !ext_enotify_option_parse(NULL, option, TRUE, &opt_name, &opt_value) )
+			return TRUE;
+	} else {
+		/* Literal string: full option parse */
+		if ( !ext_enotify_option_parse
+			(&nlog, option, FALSE, &opt_name, &opt_value) )
+			return FALSE;
+	}
+	
+	/* Call method's option check function */
+	if ( method->compile_check_option != NULL ) 
+		return method->compile_check_option(&nlog, opt_name, opt_value); 
+	
+	return TRUE;
+}
+
+bool ext_enotify_compile_check_arguments
+(struct sieve_validator *valdtr, struct sieve_ast_argument *uri_arg,
+	struct sieve_ast_argument *msg_arg, struct sieve_ast_argument *from_arg,
+	struct sieve_ast_argument *options_arg)
+{
+	const char *uri = sieve_ast_argument_strc(uri_arg);
+	const char *scheme;
+	const struct sieve_enotify_method *method;
+	struct sieve_enotify_log nlog;
+
+	/* If the uri string is not a constant literal, we cannot determine which
+	 * method is used, so we bail out successfully and defer checking to runtime.
+	 */
+	if ( !sieve_argument_is_string_literal(uri_arg) )
+		return TRUE;
+	
+	/* Parse scheme part of URI */
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL ) {
+		sieve_argument_validate_error(valdtr, uri_arg, 
+			"notify command: invalid scheme part for method URI '%s'", 
+			str_sanitize(sieve_ast_argument_strc(uri_arg), 80));
+		return FALSE;
+	}
+	
+	/* Find used method with the parsed scheme identifier */
+	if ( (method=ext_enotify_method_find(scheme)) == NULL ) {
+		sieve_argument_validate_error(valdtr, uri_arg, 
+			"notify command: invalid method '%s'", scheme);
+		return FALSE;
+	}
+
+	/* Compose log structure */
+	memset(&nlog, 0, sizeof(nlog));
+	nlog.ehandler = sieve_validator_error_handler(valdtr);
+	nlog.prefix = "notify command";
+	
+	/* Check URI itself */
+	if ( method->compile_check_uri != NULL ) {
+		/* Set log location to location of URI argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), uri_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_uri
+			(&nlog, sieve_ast_argument_strc(uri_arg), uri) )
+			return FALSE;
+	}
+
+	/* Check :message argument */
+	if ( msg_arg != NULL && sieve_argument_is_string_literal(msg_arg) && 
+		method->compile_check_message != NULL ) {
+		/* Set log location to location of :message argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), msg_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_message
+			(&nlog, sieve_ast_argument_str(msg_arg)) )
+			return FALSE;
+	}
+
+	/* Check :from argument */
+	if ( from_arg != NULL && sieve_argument_is_string_literal(from_arg) &&
+		method->compile_check_from != NULL ) {
+		/* Set log location to location of :from argument */
+		nlog.location = sieve_error_script_location
+			(sieve_validator_script(valdtr), from_arg->source_line);
+
+		/* Execute method check function */
+		if ( !method->compile_check_from(&nlog, sieve_ast_argument_str(from_arg)) )
+			return FALSE;
+	}
+	
+	/* Check :options argument */
+	if ( options_arg != NULL ) {
+		struct sieve_ast_argument *option = options_arg;
+		struct _ext_enotify_option_check_context optn_context = { valdtr, method };
+		
+		/* Parse and check options */
+		if ( sieve_ast_stringlist_map
+			(&option, (void *) &optn_context, _ext_enotify_option_check) <= 0 )
+			return FALSE;
+			
+		/* Discard argument if options are not accepted by method */
+		if ( method->compile_check_option == NULL ) {
+			sieve_argument_validate_warning(valdtr, options_arg, 
+				"notify command: method '%s' accepts no options", scheme);
+			(void)sieve_ast_arguments_detach(options_arg,1);
+		}
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Runtime operand checking
+ */
+ 
+bool ext_enotify_runtime_method_validate
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri = str_c(method_uri);
+	const char *scheme;
+	
+	/* Get the method */
+	
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL )
+		return FALSE;
+	
+	if ( (method=ext_enotify_method_find(scheme)) == NULL )
+		return FALSE;
+		
+	/* Validate the provided URI */
+	
+	if ( method->runtime_check_uri != NULL ) {
+		struct sieve_enotify_log nlog;
+		
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "valid_notify_method test";
+
+		/* Use the method check function to validate the URI */
+		return method->runtime_check_uri(&nlog, str_c(method_uri), uri);
+	}
+
+	/* Method has no check function */
+	return TRUE;
+}
+ 
+static const struct sieve_enotify_method *ext_enotify_get_method
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, const char **uri_body_r)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri = str_c(method_uri);
+	const char *scheme;
+	
+	/* Parse part before ':' of the uri (the scheme) and use it to identify
+	 * notify method.
+	 */
+	if ( (scheme=ext_enotify_uri_scheme_parse(&uri)) == NULL ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"invalid scheme part for method URI '%s'", 
+				str_sanitize(str_c(method_uri), 80));
+		return NULL;
+	}
+	
+	/* Find the notify method */
+	if ( (method=ext_enotify_method_find(scheme)) == NULL ) {
+		sieve_runtime_error
+			(renv, sieve_error_script_location(renv->script, source_line),
+				"invalid notify method '%s'", scheme);
+		return NULL;
+	}
+
+	/* Return the parse pointer and the found method */
+	*uri_body_r = uri;
+	return method;
+}
+
+const char *ext_enotify_runtime_get_method_capability
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, const char *capability)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri;
+	
+	/* Get method */
+	method = ext_enotify_get_method(renv, source_line, method_uri, &uri);
+	if ( method == NULL ) return NULL;
+	
+	/* Get requested capability */
+	if ( method->runtime_get_method_capability != NULL ) {
+		struct sieve_enotify_log nlog;
+		
+		/* Compose log structure */
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "notify_method_capability test";
+
+		/* Execute method function to acquire capability value */
+		return method->runtime_get_method_capability
+			(&nlog, str_c(method_uri), uri, capability);
+	}
+
+	return NULL;
+}
+
+int ext_enotify_runtime_check_operands
+(const struct sieve_runtime_env *renv, unsigned int source_line,
+	string_t *method_uri, string_t *message, string_t *from, 
+	struct sieve_coded_stringlist *options, 
+	const struct sieve_enotify_method **method_r, void **method_context)
+{
+	const struct sieve_enotify_method *method;
+	const char *uri;
+	
+	/* Get method */
+	method = ext_enotify_get_method(renv, source_line, method_uri, &uri);
+	if ( method == NULL ) return SIEVE_EXEC_FAILURE;
+	
+	/* Check provided operands */
+	if ( method->runtime_check_operands != NULL ) {
+		struct sieve_enotify_log nlog;
+		
+		/* Compose log structure */
+		memset(&nlog, 0, sizeof(nlog));
+		nlog.location = sieve_error_script_location(renv->script, source_line);
+		nlog.ehandler = sieve_interpreter_get_error_handler(renv->interp);
+		nlog.prefix = "notify action";
+
+		/* Execute check function */
+		if ( method->runtime_check_operands(&nlog, str_c(method_uri), uri, message, 
+			from, sieve_result_pool(renv->result), method_context) ) {
+			
+			/* Check any provided options */
+			if ( options != NULL ) {			
+				int result = TRUE;
+				string_t *option = NULL;
+			
+				/* Iterate through all provided options */
+				while ( result && 
+					(result=sieve_coded_stringlist_next_item(options, &option)) && 
+					option != NULL ) {
+					const char *opt_name = NULL, *opt_value = NULL;
+				
+					/* Parse option into <optionname> and <value> */
+					if ( ext_enotify_option_parse
+						(&nlog, str_c(option), FALSE, &opt_name, &opt_value) ) {
+					
+						/* Set option */
+						if ( method->runtime_set_option != NULL ) {
+							(void) method->runtime_set_option
+								(&nlog, *method_context, opt_name, opt_value);
+						}
+					}
+				}
+			
+				/* Check for binary corruptions encountered during string list iteration
+				 */
+				if ( result ) {
+					*method_r = method;
+					return SIEVE_EXEC_OK;
+				}
+	
+				/* Binary corrupt */
+				sieve_runtime_trace_error(renv, "invalid item in options string list");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			/* No options */			
+			*method_r = method;
+			return SIEVE_EXEC_OK;
+		}
+		
+		/* Check failed */
+		return SIEVE_EXEC_FAILURE;
+	}
+
+	/* No check function defined: a most unlikely situation */
+	*method_context = NULL;	
+	*method_r = method;
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Notify method printing
+ */
+
+void sieve_enotify_method_printf
+(const struct sieve_enotify_print_env *penv, const char *fmt, ...)
+{
+	va_list args;
+	
+	va_start(args, fmt);	
+	sieve_result_vprintf(penv->result_penv, fmt, args);
+	va_end(args);	 
+}
+
+/*
+ * Method logging
+ */
+
+void sieve_enotify_error
+(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	if ( nlog == NULL ) return;
+	
+	T_BEGIN {
+		if ( nlog->prefix == NULL )
+			sieve_verror(nlog->ehandler, nlog->location, fmt, args);
+		else
+			sieve_error(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix, 
+				t_strdup_vprintf(fmt, args));
+	} T_END;
+	
+	va_end(args);
+}
+
+void sieve_enotify_warning
+(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	if ( nlog == NULL ) return;
+	
+	T_BEGIN { 
+		if ( nlog->prefix == NULL )
+			sieve_vwarning(nlog->ehandler, nlog->location, fmt, args);
+		else			
+			sieve_warning(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix, 
+				t_strdup_vprintf(fmt, args));
+	} T_END;
+	
+	va_end(args);
+}
+
+void sieve_enotify_log
+(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+
+	if ( nlog == NULL ) return;
+	
+	T_BEGIN { 
+		if ( nlog->prefix == NULL )
+			sieve_vinfo(nlog->ehandler, nlog->location, fmt, args);
+		else
+			sieve_info(nlog->ehandler, nlog->location, "%s: %s", nlog->prefix, 
+				t_strdup_vprintf(fmt, args));	
+	} T_END;
+	
+	va_end(args);
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,115 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENOTIFY_COMMON_H
+#define __EXT_ENOTIFY_COMMON_H
+
+#include "sieve-ext-variables.h"
+
+#include "sieve-ext-enotify.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension enotify_extension;
+extern const struct sieve_extension_capabilities notify_capabilities;
+
+/*
+ * Commands
+ */
+
+extern const struct sieve_command notify_command;
+
+/*
+ * Tests
+ */
+
+extern const struct sieve_command valid_notify_method_test;
+extern const struct sieve_command notify_method_capability_test;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation notify_operation;
+extern const struct sieve_operation valid_notify_method_operation;
+extern const struct sieve_operation notify_method_capability_operation;
+
+enum ext_variables_opcode {
+	EXT_ENOTIFY_OPERATION_NOTIFY,
+	EXT_ENOTIFY_OPERATION_VALID_NOTIFY_METHOD,
+	EXT_ENOTIFY_OPERATION_NOTIFY_METHOD_CAPABILITY
+};
+
+/*
+ * Operands
+ */
+ 
+extern const struct sieve_operand encodeurl_operand;
+
+/*
+ * Modifiers
+ */
+
+extern const struct sieve_variables_modifier encodeurl_modifier;
+
+/*
+ * Notify methods
+ */
+ 
+extern const struct sieve_enotify_method mailto_notify;
+ 
+void ext_enotify_methods_init(void);
+void ext_enotify_methods_deinit(void);
+
+const struct sieve_enotify_method *ext_enotify_method_find
+	(const char *identifier);
+	
+/*
+ * Validation
+ */
+ 
+bool ext_enotify_compile_check_arguments
+(struct sieve_validator *valdtr, struct sieve_ast_argument *uri_arg,
+	struct sieve_ast_argument *msg_arg, struct sieve_ast_argument *from_arg,
+	struct sieve_ast_argument *options_arg);
+
+/*
+ * Runtime
+ */
+ 
+bool ext_enotify_runtime_method_validate
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri);
+ 
+const char *ext_enotify_runtime_get_method_capability
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri, const char *capability);
+
+int ext_enotify_runtime_check_operands
+	(const struct sieve_runtime_env *renv, unsigned int source_line,
+		string_t *method_uri, string_t *message, string_t *from, 
+		struct sieve_coded_stringlist *options, 
+		const struct sieve_enotify_method **method_r, void **method_context);
+		
+/*
+ * Method printing
+ */
+
+struct sieve_enotify_print_env {
+	const struct sieve_result_print_env *result_penv;
+};
+
+/*
+ * Method logging
+ */ 
+
+struct sieve_enotify_log {
+	struct sieve_error_handler *ehandler;
+	
+	const char *location;
+	const char *prefix;
+};
+
+#endif /* __EXT_ENOTIFY_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ext-enotify-limits.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_ENOTIFY_LIMITS_H
+#define __EXT_ENOTIFY_LIMITS_H
+
+#define EXT_ENOTIFY_MAX_SCHEME_LEN  32
+
+#endif /* __EXT_ENOTIFY_LIMITS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,36 @@
+noinst_LTLIBRARIES = libsieve_ext_enotify.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-notify.c
+
+tests = \
+	tst-valid-notify-method.c \
+	tst-notify-method-capability.c
+
+var_modifiers = \
+	vmodf-encodeurl.c
+
+notify_methods = \
+	ntfy-mailto.c
+
+libsieve_ext_enotify_la_SOURCES = \
+	ext-enotify.c \
+	ext-enotify-common.c \
+	$(commands) \
+	$(tests) \
+	$(var_modifiers) \
+	$(notify_methods)
+
+noinst_HEADERS = \
+	sieve-ext-enotify.h \
+	ext-enotify-limits.h \
+	ext-enotify-common.h
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/ntfy-mailto.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1095 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+/* Notify method mailto
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5436
+ * Implementation: full
+ * Status: testing
+ * 
+ */
+ 
+/* FIXME: URI syntax conforms to something somewhere in between RFC 2368 and
+ *   draft-duerst-mailto-bis-05.txt. Should fully migrate to new specification
+ *   when it matures. This requires modifications to the address parser (no
+ *   whitespace allowed within the address itself) and UTF-8 support will be
+ *   required in the URL.
+ */
+ 
+#include "lib.h"
+#include "array.h"
+#include "str.h"
+#include "ioloop.h"
+#include "str-sanitize.h"
+#include "message-date.h"
+#include "mail-storage.h"
+
+#include "rfc2822.h"
+
+#include "sieve-ext-enotify.h"
+#include "sieve-address.h"
+#include "sieve-message.h"
+
+/*
+ * Configuration
+ */
+ 
+#define NTFY_MAILTO_MAX_RECIPIENTS  8
+#define NTFY_MAILTO_MAX_HEADERS     16
+#define NTFY_MAILTO_MAX_SUBJECT     256
+
+/* 
+ * Types 
+ */
+
+struct ntfy_mailto_header_field {
+	const char *name;
+	const char *body;
+};
+
+struct ntfy_mailto_recipient {
+	const char *full;
+	const char *normalized;
+	bool carbon_copy;
+};
+
+ARRAY_DEFINE_TYPE(recipients, struct ntfy_mailto_recipient);
+ARRAY_DEFINE_TYPE(headers, struct ntfy_mailto_header_field);
+
+/* 
+ * Mailto notification method
+ */
+ 
+static bool ntfy_mailto_compile_check_uri
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body);
+static bool ntfy_mailto_compile_check_from
+	(const struct sieve_enotify_log *nlog, string_t *from);
+
+static const char *ntfy_mailto_runtime_get_notify_capability
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body, 
+		const char *capability);
+static bool ntfy_mailto_runtime_check_uri
+	(const struct sieve_enotify_log *nlog, const char *uri, const char *uri_body);
+static bool ntfy_mailto_runtime_check_operands
+	(const struct sieve_enotify_log *nlog, const char *uri,const char *uri_body, 
+		string_t *message, string_t *from, pool_t context_pool, 
+		void **method_context);
+
+static int ntfy_mailto_action_check_duplicates
+	(const struct sieve_enotify_log *nlog, void *method_ctx1, void *method_ctx2,
+		const char *dupl_location);
+
+static void ntfy_mailto_action_print
+	(const struct sieve_enotify_print_env *penv, 
+		const struct sieve_enotify_action *act);	
+
+static bool ntfy_mailto_action_execute
+	(const struct sieve_enotify_exec_env *nenv, 
+		const struct sieve_enotify_action *act);
+
+const struct sieve_enotify_method mailto_notify = {
+	"mailto",
+	ntfy_mailto_compile_check_uri,
+	NULL,
+	ntfy_mailto_compile_check_from,
+	NULL,
+	ntfy_mailto_runtime_check_uri,
+	ntfy_mailto_runtime_get_notify_capability,
+	ntfy_mailto_runtime_check_operands,
+	NULL,
+	ntfy_mailto_action_check_duplicates,
+	ntfy_mailto_action_print,
+	ntfy_mailto_action_execute
+};
+
+/*
+ * Method context data
+ */
+ 
+struct ntfy_mailto_context {
+	ARRAY_TYPE(recipients) recipients;
+	ARRAY_TYPE(headers) headers;
+	const char *subject;
+	const char *body;
+	const char *from_normalized;
+};
+
+/*
+ * Reserved headers
+ */
+ 
+static const char *_reserved_headers[] = {
+	"auto-submitted",
+	"received",
+	"message-id",
+	"data",
+	"bcc",
+	"in-reply-to",
+	"references",
+	"resent-date",
+	"resent-from",
+	"resent-sender",
+	"resent-to",
+	"resent-cc",
+ 	"resent-bcc",
+	"resent-msg-id",
+	"from",
+	"sender",
+	NULL
+};
+
+static const char *_unique_headers[] = {
+	"reply-to",
+	NULL
+};
+
+static inline bool _ntfy_mailto_header_allowed(const char *field_name)
+{
+	const char **rhdr = _reserved_headers;
+
+	/* Check whether it is reserved */
+	while ( *rhdr != NULL ) {
+		if ( strcasecmp(field_name, *rhdr) == 0 )
+			return FALSE;
+		rhdr++;
+	}
+
+	return TRUE;
+}
+
+static inline bool _ntfy_mailto_header_unique(const char *field_name)
+{
+	const char **rhdr = _unique_headers;
+
+	/* Check whether it is supposed to be unique */
+	while ( *rhdr != NULL ) {
+		if ( strcasecmp(field_name, *rhdr) == 0 )
+			return TRUE;
+		rhdr++;
+	}
+
+	return FALSE;
+}
+
+/*
+ * Mailto URI parsing
+ */
+ 
+/* Util functions */
+
+#define _uri_parse_error(LOG, ...) \
+	sieve_enotify_error(LOG, "invalid mailto URI: " __VA_ARGS__ )
+	
+#define _uri_parse_warning(LOG, ...) \
+	sieve_enotify_warning(LOG, "mailto URI: " __VA_ARGS__ )
+
+/* FIXME: much of this implementation will be common to other URI schemes. This
+ *        should be merged into a common implementation.
+ */
+
+static const char _qchar_lookup[256] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 00
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 10
+	0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0,  // 20
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,  // 30
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 40
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  // 50
+	0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 60
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,  // 70
+
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 80
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 90
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // A0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // B0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // C0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // D0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // E0
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // F0
+};
+
+static inline bool _is_qchar(unsigned char c)
+{
+	return _qchar_lookup[c];
+}
+  
+static inline int _decode_hex_digit(char digit)
+{
+	switch ( digit ) {
+	case '0': case '1': case '2': case '3': case '4': 
+	case '5': case '6': case '7': case '8': case '9': 
+		return (int) digit - '0';
+
+	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+		return (int) digit - 'a' + 0x0a;
+		
+	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+		return (int) digit - 'A' + 0x0A;
+	}
+	
+	return -1;
+}
+
+static bool _parse_hex_value(const char **in, char *out)
+{
+	char value;
+		
+	if ( **in == '\0' || (value=_decode_hex_digit(**in)) < 0 )
+		return FALSE;
+	
+	*out = value << 4;
+	(*in)++;
+	
+	if ( **in == '\0' || (value=_decode_hex_digit(**in)) < 0 )
+		return FALSE;	
+
+	*out |= value;
+	(*in)++;
+	return (*out != '\0');	
+}
+
+static bool _uri_add_valid_recipient
+(const struct sieve_enotify_log *nlog, ARRAY_TYPE(recipients) *recipients, 
+	string_t *recipient, bool cc)
+{
+	const char *error;
+	const char *normalized;
+	 
+	/* Verify recipient */
+	if ( (normalized=sieve_address_normalize(recipient, &error)) == NULL ) {
+		_uri_parse_error(nlog, "invalid recipient '%s': %s",
+			str_sanitize(str_c(recipient), 80), error);
+		return FALSE;
+	}
+					
+	/* Add recipient to the list */
+	if ( recipients != NULL ) {
+		struct ntfy_mailto_recipient *new_recipient;
+		struct ntfy_mailto_recipient *rcpts;
+		unsigned int count, i;
+		pool_t pool;
+
+		rcpts = array_get_modifiable(recipients, &count);
+		
+		/* Enforce limits */
+		if ( count >= NTFY_MAILTO_MAX_RECIPIENTS ) {
+			if ( count == NTFY_MAILTO_MAX_RECIPIENTS ) {
+				_uri_parse_warning(nlog, 
+					"more than the maximum %u recipients specified; "
+					"rest is discarded", NTFY_MAILTO_MAX_RECIPIENTS);
+			}
+			return TRUE;	
+		}
+		
+		/* Check for duplicate first */
+		for ( i = 0; i < count; i++ ) {
+			if ( sieve_address_compare(rcpts[i].normalized, normalized, TRUE) == 0 ) 
+				{
+				/* Upgrade existing Cc: recipient to a To: recipient if possible */
+				rcpts[i].carbon_copy = ( rcpts[i].carbon_copy && cc );
+				
+				_uri_parse_warning(nlog, "ignored duplicate recipient '%s'",
+					str_sanitize(str_c(recipient), 80));
+				return TRUE;
+			} 
+		}			
+
+		/* Add */
+		pool = array_get_pool(recipients);
+		new_recipient = array_append_space(recipients);
+		new_recipient->carbon_copy = cc;
+		new_recipient->full = p_strdup(pool, str_c(recipient));
+		new_recipient->normalized = p_strdup(pool, normalized);
+	}
+
+	return TRUE;
+}
+
+static bool _uri_parse_recipients
+(const struct sieve_enotify_log *nlog, const char **uri_p, 
+	ARRAY_TYPE(recipients) *recipients_r)
+{
+	string_t *to = t_str_new(128);
+	const char *p = *uri_p;
+	
+	if ( *p == '\0' || *p == '?' )
+		return TRUE;
+		
+	while ( *p != '\0' && *p != '?' ) {
+		if ( *p == '%' ) {
+			/* % encoded character */
+			char ch;
+			
+			p++;
+			
+			/* Parse 2-digit hex value */
+			if ( !_parse_hex_value(&p, &ch) ) {
+				_uri_parse_error(nlog, "invalid %% encoding");
+				return FALSE;
+			}
+
+			/* Check for delimiter */
+			if ( ch == ',' ) {
+				/* Verify and add recipient */
+				if ( !_uri_add_valid_recipient(nlog, recipients_r, to, FALSE) )
+					return FALSE;
+			
+				/* Reset for next recipient */
+				str_truncate(to, 0);
+			}	else {
+				/* Content character */
+				str_append_c(to, ch);
+			}
+		} else {
+			if ( *p == ':' || *p == ';' || *p == ',' || !_is_qchar(*p) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in 'to' part", *p);
+				return FALSE;
+			}
+
+			/* Content character */
+			str_append_c(to, *p);
+			p++;
+		}
+	}	
+	
+	/* Skip '?' */
+	if ( *p != '\0' ) p++;
+	
+	/* Verify and add recipient */
+	if ( !_uri_add_valid_recipient(nlog, recipients_r, to, FALSE) )
+		return FALSE;
+
+	*uri_p = p;
+	return TRUE;
+}
+
+static bool _uri_parse_header_recipients
+(const struct sieve_enotify_log *nlog, string_t *rcpt_header, 
+	ARRAY_TYPE(recipients) *recipients_r, bool cc)
+{
+	string_t *to = t_str_new(128);
+	const char *p = (const char *) str_data(rcpt_header);
+	const char *pend = p + str_len(rcpt_header);
+		
+	while ( p < pend ) {
+		if ( *p == ',' ) {
+			/* Verify and add recipient */
+			if ( !_uri_add_valid_recipient(nlog, recipients_r, to, cc) )
+				return FALSE;
+			
+			/* Reset for next recipient */
+			str_truncate(to, 0);
+		} else {
+			/* Content character */
+			str_append_c(to, *p);
+		}
+		p++;
+	}	
+	
+	/* Verify and add recipient */
+	if ( !_uri_add_valid_recipient(nlog, recipients_r, to, cc) )
+		return FALSE;
+
+	return TRUE;	
+}
+
+static bool _uri_header_is_duplicate
+(ARRAY_TYPE(headers) *headers, const char *field_name)
+{	
+	if ( _ntfy_mailto_header_unique(field_name) ) {
+		const struct ntfy_mailto_header_field *hdrs;
+		unsigned int count, i;
+
+		hdrs = array_get(headers, &count);	
+		for ( i = 0; i < count; i++ ) {
+			if ( strcasecmp(hdrs[i].name, field_name) == 0 ) 
+				return TRUE;
+		}
+	}
+	
+	return FALSE;
+}
+
+static bool _uri_parse_headers
+(const struct sieve_enotify_log *nlog, const char **uri_p, 
+	ARRAY_TYPE(headers) *headers_r, ARRAY_TYPE(recipients) *recipients_r,
+	const char **body, const char **subject)
+{
+	unsigned int header_count = 0;
+	string_t *field = t_str_new(128);
+	const char *p = *uri_p;
+	pool_t pool = NULL;
+
+	if ( body != NULL )
+		*body = NULL;
+		
+	if ( subject != NULL )
+		*subject = NULL;
+			
+	if ( headers_r != NULL )
+		pool = array_get_pool(headers_r);
+		
+	while ( *p != '\0' ) {
+		enum {
+			_HNAME_IGNORED, 
+			_HNAME_GENERIC,
+			_HNAME_TO,
+			_HNAME_CC,
+			_HNAME_SUBJECT, 
+			_HNAME_BODY 
+		} hname_type = _HNAME_GENERIC;
+		struct ntfy_mailto_header_field *hdrf = NULL;
+		const char *field_name;
+		
+		/* Parse field name */
+		while ( *p != '\0' && *p != '=' ) {
+			char ch = *p;
+			p++;
+			
+			if ( ch == '%' ) {
+				/* Encoded, parse 2-digit hex value */
+				if ( !_parse_hex_value(&p, &ch) ) {
+					_uri_parse_error(nlog, "invalid %% encoding");
+					return FALSE;
+				}
+			} else if ( ch != '=' && !_is_qchar(ch) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in header field name part", ch);
+				return FALSE;
+			}
+
+			str_append_c(field, ch);
+		}
+		if ( *p != '\0' ) p++;
+
+		/* Verify field name */
+		if ( !rfc2822_header_field_name_verify(str_c(field), str_len(field)) ) {
+			_uri_parse_error(nlog, "invalid header field name");
+			return FALSE;
+		}
+
+		if ( header_count >= NTFY_MAILTO_MAX_HEADERS ) {
+			/* Refuse to accept more headers than allowed by policy */
+			if ( header_count == NTFY_MAILTO_MAX_HEADERS ) {
+				_uri_parse_warning(nlog, "more than the maximum %u headers specified; "
+					"rest is discarded", NTFY_MAILTO_MAX_HEADERS);
+			}
+			
+			hname_type = _HNAME_IGNORED;
+		} else {
+			/* Add new header field to array and assign its name */
+			
+			field_name = str_c(field);
+			if ( strcasecmp(field_name, "to") == 0 )
+				hname_type = _HNAME_TO;
+			else if ( strcasecmp(field_name, "cc") == 0 )
+				hname_type = _HNAME_CC;
+			else if ( strcasecmp(field_name, "subject") == 0 )
+				hname_type = _HNAME_SUBJECT;
+			else if ( strcasecmp(field_name, "body") == 0 )
+				hname_type = _HNAME_BODY;
+			else if ( _ntfy_mailto_header_allowed(field_name) ) {
+				if ( headers_r != NULL ) {
+					if ( !_uri_header_is_duplicate(headers_r, field_name) ) {
+						hdrf = array_append_space(headers_r);
+						hdrf->name = p_strdup(pool, field_name);
+					} else {
+						_uri_parse_warning(nlog, 
+							"ignored duplicate for unique header field '%s'",
+							str_sanitize(field_name, 32));
+						hname_type = _HNAME_IGNORED;
+					}
+				} else {
+					hname_type = _HNAME_IGNORED;
+				}
+			} else {
+				_uri_parse_warning(nlog, "ignored reserved header field '%s'",
+					str_sanitize(field_name, 32));
+				hname_type = _HNAME_IGNORED;
+			}
+		}
+		
+		header_count++;
+			
+		/* Reset for field body */
+		str_truncate(field, 0);
+		
+		/* Parse field body */		
+		while ( *p != '\0' && *p != '&' ) {
+			char ch = *p;
+			p++;
+			
+			if ( ch == '%' ) {
+				/* Encoded, parse 2-digit hex value */
+				if ( !_parse_hex_value(&p, &ch) ) {
+					_uri_parse_error(nlog, "invalid %% encoding");
+					return FALSE;
+				}
+			} else if ( ch != '=' && !_is_qchar(ch) ) {
+				_uri_parse_error
+					(nlog, "invalid character '%c' in header field value part", ch);
+				return FALSE;
+			}
+			str_append_c(field, ch);
+		}
+		if ( *p != '\0' ) p++;
+		
+		/* Verify field body */
+		if ( hname_type == _HNAME_BODY ) {
+			// FIXME: verify body ... 
+		} else {
+			if ( !rfc2822_header_field_body_verify(str_c(field), str_len(field)) ) {
+				_uri_parse_error
+					(nlog, "invalid header field body");
+				return FALSE;
+			}
+		}
+		
+		/* Assign field body */
+
+		switch ( hname_type ) {
+		case _HNAME_IGNORED:
+			break;
+		case _HNAME_TO:
+			/* Gracefully allow duplicate To fields */
+			if ( !_uri_parse_header_recipients(nlog, field, recipients_r, FALSE) )
+				return FALSE;
+			break;
+		case _HNAME_CC:
+			/* Gracefully allow duplicate Cc fields */
+			if ( !_uri_parse_header_recipients(nlog, field, recipients_r, TRUE) )
+				return FALSE;
+			break;
+		case _HNAME_SUBJECT:
+			if ( subject != NULL ) {
+				/* Igore duplicate subject field */
+				if ( *subject == NULL )
+					*subject = p_strdup(pool, str_c(field));
+				else
+					_uri_parse_warning(nlog, "ignored duplicate subject field");
+			}
+			break;
+		case _HNAME_BODY:
+			if ( body != NULL ) {
+				/* Igore duplicate body field */
+				if ( *body == NULL )
+					*body = p_strdup(pool, str_c(field));
+				else 
+					_uri_parse_warning(nlog, "ignored duplicate body field");
+			}				
+			break;
+		case _HNAME_GENERIC:
+			if ( hdrf != NULL ) 
+				hdrf->body = p_strdup(pool, str_c(field));
+			break;
+		}
+			
+		/* Reset for next name */
+		str_truncate(field, 0);
+	}	
+	
+	/* Skip '&' */
+	if ( *p != '\0' ) p++;
+
+	*uri_p = p;
+	return TRUE;
+}
+
+static bool ntfy_mailto_parse_uri
+(const struct sieve_enotify_log *nlog, const char *uri_body, 
+	ARRAY_TYPE(recipients) *recipients_r, ARRAY_TYPE(headers) *headers_r,
+	const char **body, const char **subject)
+{
+	const char *p = uri_body;
+	
+	/* 
+	 * mailtoURI   = "mailto:" [ to ] [ hfields ]
+	 * to          = [ addr-spec *("%2C" addr-spec ) ]
+	 * hfields     = "?" hfield *( "&" hfield )
+	 * hfield      = hfname "=" hfvalue
+	 * hfname      = *qchar
+	 * hfvalue     = *qchar
+	 * addr-spec   = local-part "@" domain
+	 * local-part  = dot-atom / quoted-string
+	 * qchar       = unreserved / pct-encoded / some-delims
+	 * some-delims = "!" / "$" / "'" / "(" / ")" / "*"
+	 *               / "+" / "," / ";" / ":" / "@"
+	 *
+	 * to         ~= *tqchar
+	 * tqchar     ~= <qchar> without ";" and ":" 
+	 * 
+	 * Scheme 'mailto:' already parsed, starting parse after colon
+	 */
+
+	/* First extract to-part by searching for '?' and decoding % items
+	 */
+
+	if ( !_uri_parse_recipients(nlog, &p, recipients_r) )
+		return FALSE;	
+
+	/* Extract hfield items */	
+	
+	while ( *p != '\0' ) {		
+		/* Extract hfield item by searching for '&' and decoding '%' items */
+		if ( !_uri_parse_headers(nlog, &p, headers_r, recipients_r, body, subject) )
+			return FALSE;		
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Validation
+ */
+
+static bool ntfy_mailto_compile_check_uri
+(const struct sieve_enotify_log *nlog, const char *uri ATTR_UNUSED,
+	const char *uri_body)
+{	
+	ARRAY_TYPE(recipients) recipients;
+	ARRAY_TYPE(headers) headers;
+	const char *body = NULL, *subject = NULL;
+
+	t_array_init(&recipients, NTFY_MAILTO_MAX_RECIPIENTS);
+	t_array_init(&headers, NTFY_MAILTO_MAX_HEADERS);
+	
+	if ( !ntfy_mailto_parse_uri
+		(nlog, uri_body, &recipients, &headers, &body, &subject) )
+		return FALSE;
+		
+	if ( array_count(&recipients) == 0 )
+		sieve_enotify_warning(nlog, "notification URI specifies no recipients");
+	
+	return TRUE;
+}
+
+static bool ntfy_mailto_compile_check_from
+(const struct sieve_enotify_log *nlog, string_t *from)
+{
+	const char *error;
+	bool result = FALSE;
+
+	T_BEGIN {
+		result = sieve_address_validate(from, &error);
+
+		if ( !result ) {
+			sieve_enotify_error(nlog,
+				"specified :from address '%s' is invalid for "
+				"the mailto method: %s",
+				str_sanitize(str_c(from), 128), error);
+		}
+	} T_END;
+
+	return result;
+}
+
+/*
+ * Runtime
+ */
+ 
+static const char *ntfy_mailto_runtime_get_notify_capability
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, const char *uri ATTR_UNUSED, 
+	const char *uri_body, const char *capability)
+{
+	if ( !ntfy_mailto_parse_uri(NULL, uri_body, NULL, NULL, NULL, NULL) ) {
+		return NULL;
+	}
+	
+	if ( strcasecmp(capability, "online") == 0 ) 
+		return "maybe";
+	
+	return NULL;
+}
+
+static bool ntfy_mailto_runtime_check_uri
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, const char *uri ATTR_UNUSED,
+	const char *uri_body)
+{
+	return ntfy_mailto_parse_uri(NULL, uri_body, NULL, NULL, NULL, NULL);
+}
+ 
+static bool ntfy_mailto_runtime_check_operands
+(const struct sieve_enotify_log *nlog, const char *uri ATTR_UNUSED,
+	const char *uri_body, string_t *message ATTR_UNUSED, string_t *from, 
+	pool_t context_pool, void **method_context)
+{
+	struct ntfy_mailto_context *mtctx;
+	const char *error, *normalized;
+
+	/* Need to create context before validation to have arrays present */
+	mtctx = p_new(context_pool, struct ntfy_mailto_context, 1);
+
+	/* Validate :from */
+	if ( from != NULL ) {
+		T_BEGIN {
+			normalized = sieve_address_normalize(from, &error);
+
+			if ( normalized == NULL ) {
+				sieve_enotify_error(nlog,
+					"specified :from address '%s' is invalid for "
+					"the mailto method: %s",
+					str_sanitize(str_c(from), 128), error);
+			} else 
+				mtctx->from_normalized = p_strdup(context_pool, normalized);
+		} T_END;
+
+		if ( !normalized ) return FALSE;
+	}
+
+	p_array_init(&mtctx->recipients, context_pool, NTFY_MAILTO_MAX_RECIPIENTS);
+	p_array_init(&mtctx->headers, context_pool, NTFY_MAILTO_MAX_HEADERS);
+
+	if ( !ntfy_mailto_parse_uri
+		(nlog, uri_body, &mtctx->recipients, &mtctx->headers, &mtctx->body, 
+			&mtctx->subject) ) {
+		return FALSE;
+	}
+
+	*method_context = (void *) mtctx;
+	return TRUE;	
+}
+
+/*
+ * Action duplicates
+ */
+
+static int ntfy_mailto_action_check_duplicates
+(const struct sieve_enotify_log *nlog ATTR_UNUSED, 
+	void *method_ctx1, void *method_ctx2,
+	const char *dupl_location ATTR_UNUSED)
+{
+	struct ntfy_mailto_context *mt_new = 
+		(struct ntfy_mailto_context *) method_ctx1;
+	struct ntfy_mailto_context *mt_old = 
+		(struct ntfy_mailto_context *) method_ctx2;
+	const struct ntfy_mailto_recipient *new_rcpts, *old_rcpts;
+	unsigned int new_count, old_count, i, j;
+	unsigned int del_start = 0, del_len = 0;
+
+	new_rcpts = array_get(&mt_new->recipients, &new_count);
+	old_rcpts = array_get(&mt_old->recipients, &old_count);
+
+	for ( i = 0; i < new_count; i++ ) {
+		for ( j = 0; j < old_count; j++ ) {
+			if ( sieve_address_compare
+				(new_rcpts[i].normalized, old_rcpts[j].normalized, TRUE) == 0 )
+				break;				
+		}
+
+		if ( j == old_count ) {
+			/* Not duplicate */
+			if ( del_len > 0 ) {
+				/* Perform pending deletion */
+				array_delete(&mt_new->recipients, del_start, del_len);
+
+				/* Make sure the loop integrity is maintained */
+				i -= del_len;
+				new_rcpts = array_get(&mt_new->recipients, &new_count);
+			}
+			del_len = 0;		
+		} else {
+			/* Mark deletion */
+			if ( del_len == 0 )
+				del_start = i;
+			del_len++;
+		}
+	}
+
+	/* Perform pending deletion */
+	if ( del_len > 0 ) {
+		array_delete(&mt_new->recipients, del_start, del_len);			
+	}
+
+	return ( array_count(&mt_new->recipients) > 0 ? 0 : 1 );
+}
+
+/*
+ * Action printing
+ */
+ 
+static void ntfy_mailto_action_print
+(const struct sieve_enotify_print_env *penv, 
+	const struct sieve_enotify_action *act)
+{
+	unsigned int count, i;
+	const struct ntfy_mailto_recipient *recipients;
+	const struct ntfy_mailto_header_field *headers;
+	struct ntfy_mailto_context *mtctx = 
+		(struct ntfy_mailto_context *) act->method_context;
+	
+	/* Print main method parameters */
+
+	sieve_enotify_method_printf
+		(penv,   "    => importance   : %d\n", act->importance);
+
+	if ( act->message != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => subject      : %s\n", act->message);
+	else if ( mtctx->subject != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => subject      : %s\n", mtctx->subject);
+
+	if ( act->from != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => from         : %s\n", act->from);
+
+	/* Print mailto: recipients */
+
+	sieve_enotify_method_printf(penv,   "    => recipients   :\n" );
+
+	recipients = array_get(&mtctx->recipients, &count);
+	if ( count == 0 ) {
+		sieve_enotify_method_printf(penv,   "       NONE, action has no effect\n");
+	} else {
+		for ( i = 0; i < count; i++ ) {
+			if ( recipients[i].carbon_copy )
+				sieve_enotify_method_printf
+					(penv,   "       + Cc: %s\n", recipients[i].full);
+			else
+				sieve_enotify_method_printf
+					(penv,   "       + To: %s\n", recipients[i].full);
+		}
+	}
+
+	/* Print accepted headers for notification message */
+	
+	headers = array_get(&mtctx->headers, &count);
+	if ( count > 0 ) {
+		sieve_enotify_method_printf(penv,   "    => headers      :\n" );	
+		for ( i = 0; i < count; i++ ) {
+			sieve_enotify_method_printf(penv,   "       + %s: %s\n", 
+				headers[i].name, headers[i].body);
+		}
+	}
+
+	/* Print body for notification message */
+	
+	if ( mtctx->body != NULL )
+		sieve_enotify_method_printf
+			(penv, "    => body         : \n--\n%s\n--\n", mtctx->body);
+
+	/* Finish output with an empty line */
+
+	sieve_enotify_method_printf(penv,   "\n");
+}
+
+/*
+ * Action execution
+ */
+
+static bool _contains_8bit(const char *msg)
+{
+	const unsigned char *s = (const unsigned char *)msg;
+
+	for (; *s != '\0'; s++) {
+		if ((*s & 0x80) != 0)
+			return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static bool ntfy_mailto_send
+(const struct sieve_enotify_exec_env *nenv, 
+	const struct sieve_enotify_action *act)
+{ 
+	const struct sieve_enotify_log *nlog = nenv->notify_log;
+	const struct sieve_message_data *msgdata = nenv->msgdata;
+	const struct sieve_script_env *senv = nenv->scriptenv;
+	struct ntfy_mailto_context *mtctx = 
+		(struct ntfy_mailto_context *) act->method_context;	
+	const char *from = NULL, *from_smtp = NULL; 
+	const char *subject = mtctx->subject;
+	const char *body = mtctx->body;
+	string_t *to, *cc;
+	const struct ntfy_mailto_recipient *recipients;
+	void *smtp_handle;
+	unsigned int count, i;
+	FILE *f;
+	const char *outmsgid;
+
+	/* Get recipients */
+	recipients = array_get(&mtctx->recipients, &count);
+	if ( count == 0  ) {
+		sieve_enotify_warning(nlog, 
+			"notify mailto uri specifies no recipients; action has no effect");
+		return TRUE;
+	}
+
+	/* Just to be sure */
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_enotify_warning(nlog, 
+			"notify mailto method has no means to send mail");
+		return TRUE;
+	}
+	
+	/* Determine message from address */
+	if ( act->from == NULL ) {
+		from = t_strdup_printf("Postmaster <%s>", senv->postmaster_address);
+	} else {
+		from = act->from;
+	}
+
+	/* Determine SMTP from address */
+	if ( msgdata->return_path != NULL ) {
+		if ( mtctx->from_normalized == NULL ) {
+			from_smtp = senv->postmaster_address;
+		} else {
+			from_smtp = mtctx->from_normalized;
+		}
+	}
+	
+	/* Determine subject */
+	if ( act->message != NULL ) {
+		/* FIXME: handle UTF-8 */
+		subject = str_sanitize(act->message, NTFY_MAILTO_MAX_SUBJECT);
+	} else if ( subject == NULL ) {
+		const char *const *hsubject;
+		
+		/* Fetch subject from original message */
+		if ( mail_get_headers_utf8
+			(msgdata->mail, "subject", &hsubject) >= 0 )
+			subject = str_sanitize(t_strdup_printf("Notification: %s", hsubject[0]), 
+				NTFY_MAILTO_MAX_SUBJECT);
+		else
+			subject = "Notification: (no subject)";
+	}
+
+	/* Compose To and Cc headers */
+	to = NULL;
+	cc = NULL;
+	for ( i = 0; i < count; i++ ) {
+		if ( recipients[i].carbon_copy ) {
+			if ( cc == NULL ) {
+				cc = t_str_new(256);
+				str_append(cc, recipients[i].full);
+			} else {
+				str_append(cc, ", ");
+				str_append(cc, recipients[i].full);
+			}
+		} else {
+			if ( to == NULL ) {
+				to = t_str_new(256);
+				str_append(to, recipients[i].full);
+			} else {
+				str_append(to, ", ");
+				str_append(to, recipients[i].full);
+			}
+		}
+	}
+
+	/* Send message to all recipients */
+	for ( i = 0; i < count; i++ ) {
+		const struct ntfy_mailto_header_field *headers;
+		unsigned int h, hcount;
+
+		smtp_handle = senv->smtp_open(recipients[i].normalized, from_smtp, &f);
+		outmsgid = sieve_message_get_new_id(senv);
+	
+		rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);
+		rfc2822_header_field_write(f, "Message-ID", outmsgid);
+		rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+		rfc2822_header_field_write(f, "Subject", subject);
+
+		rfc2822_header_field_printf(f, "From", "%s", from);
+
+		if ( to != NULL )
+			rfc2822_header_field_printf(f, "To", "%s", str_c(to));
+		
+		if ( cc != NULL )
+			rfc2822_header_field_printf(f, "Cc", "%s", str_c(cc));
+			
+		rfc2822_header_field_printf(f, "Auto-Submitted", 
+			"auto-notified; owner-email=\"%s\"", msgdata->to_address);
+		rfc2822_header_field_write(f, "Precedence", "bulk");
+
+		/* Set importance */
+		switch ( act->importance ) {
+		case 1:
+			rfc2822_header_field_write(f, "X-Priority", "1 (Highest)");
+			rfc2822_header_field_write(f, "Importance", "High");
+			break;
+		case 3:
+			rfc2822_header_field_write(f, "X-Priority", "5 (Lowest)");
+			rfc2822_header_field_write(f, "Importance", "Low");
+			break;
+		case 2:
+		default:
+			rfc2822_header_field_write(f, "X-Priority", "3 (Normal)");
+			rfc2822_header_field_write(f, "Importance", "Normal");
+			break;
+		}
+		
+		/* Add custom headers */
+		
+		headers = array_get(&mtctx->headers, &hcount);
+		for ( h = 0; h < hcount; h++ ) {
+			const char *name = rfc2822_header_field_name_sanitize(headers[h].name);
+		
+			rfc2822_header_field_write(f, name, headers[h].body);
+		}
+			
+		/* Generate message body */
+		if ( body != NULL ) {
+			if (_contains_8bit(body)) {
+				rfc2822_header_field_write(f, "MIME-Version", "1.0");
+				rfc2822_header_field_write
+					(f, "Content-Type", "text/plain; charset=UTF-8");
+				rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+			}
+			
+			fprintf(f, "\r\n");
+			fprintf(f, "%s\r\n", body);
+			
+		} else {
+			fprintf(f, "\r\n");
+			fprintf(f, "Notification of new message.\r\n");
+		}
+	
+		if ( senv->smtp_close(smtp_handle) ) {
+			sieve_enotify_log(nlog, 
+				"sent mail notification to <%s>", 
+				str_sanitize(recipients[i].normalized, 80));
+		} else {
+			sieve_enotify_error(nlog,
+				"failed to send mail notification to <%s> "
+				"(refer to system log for more information)", 
+				str_sanitize(recipients[i].normalized, 80));
+		}
+	}
+
+	return TRUE;
+}
+
+static bool ntfy_mailto_action_execute
+(const struct sieve_enotify_exec_env *nenv, 
+	const struct sieve_enotify_action *act)
+{
+	const struct sieve_message_data *msgdata = nenv->msgdata;
+	const char *const *headers;
+
+	/* Is the message an automatic reply ? */
+	if ( mail_get_headers
+		(msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		const char *const *hdsp = headers;
+
+		/* Theoretically multiple headers could exist, so lets make sure */
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_enotify_log(nenv->notify_log, 
+					"not sending notification for auto-submitted message from <%s>", 
+					str_sanitize(msgdata->return_path, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+
+	return ntfy_mailto_send(nenv, act);
+}
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/sieve-ext-enotify.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,138 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXT_ENOTIFY_H
+#define __SIEVE_EXT_ENOTIFY_H
+
+#include "lib.h"
+#include "compat.h"
+#include <stdarg.h>
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_enotify_log;
+struct sieve_enotify_context; 
+struct sieve_enotify_action;
+struct sieve_enotify_print_env;
+struct sieve_enotify_exec_env;
+
+/*
+ * Notify context
+ */
+
+struct sieve_enotify_context {
+	struct sieve_error_handler *ehandler;
+	
+	/* Script location */
+	const struct sieve_script *script;
+	unsigned int source_line;
+
+	const struct sieve_message_data *msgdata;
+	pool_t pool;
+};
+
+/*
+ * Notify methods
+ */ 
+
+struct sieve_enotify_method {
+	const char *identifier;
+	
+	/* Validation */
+	bool (*compile_check_uri)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body);
+	bool (*compile_check_message)
+		(const struct sieve_enotify_log *nlog, string_t *message);
+	bool (*compile_check_from)
+		(const struct sieve_enotify_log *nlog, string_t *from);
+	bool (*compile_check_option)
+		(const struct sieve_enotify_log *nlog, const char *option, 
+			const char *value);
+
+	/* Runtime */
+	bool (*runtime_check_uri)
+		(const struct sieve_enotify_log *nlog, const char *uri,
+			const char *uri_body);
+	const char *(*runtime_get_method_capability)
+		(const struct sieve_enotify_log *nlog, const char *uri, 
+			const char *uri_body, const char *capability);
+	bool (*runtime_check_operands)
+		(const struct sieve_enotify_log *nlog, const char *uri, 
+			const char *uri_body, string_t *message, string_t *from, 
+			pool_t context_pool, void **method_context);
+	bool (*runtime_set_option)
+		(const struct sieve_enotify_log *nlog, void *method_context,
+			const char *option, const char *value);
+
+	/* Action duplicates */
+	int (*action_check_duplicates)
+		(const struct sieve_enotify_log *nlog, void *method_ctx1, 
+			void *method_ctx2, const char *dupl_location);
+		
+	/* Action print */
+	void (*action_print)
+		(const struct sieve_enotify_print_env *penv, 
+			const struct sieve_enotify_action *act);	
+			
+	/* Action execution */
+	bool (*action_execute)
+		(const struct sieve_enotify_exec_env *nenv, 
+			const struct sieve_enotify_action *act);
+};
+
+void sieve_enotify_method_register(const struct sieve_enotify_method *method);
+
+/*
+ * Notify method printing
+ */
+
+void sieve_enotify_method_printf
+	(const struct sieve_enotify_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+/*
+ * Notify execution environment
+ */
+
+struct sieve_enotify_exec_env {
+	const struct sieve_enotify_log *notify_log;
+
+	const struct sieve_script_env *scriptenv;
+	const struct sieve_message_data *msgdata;
+};
+
+/*
+ * Notify action
+ */
+ 
+struct sieve_enotify_action {
+	const struct sieve_enotify_method *method;
+	void *method_context;
+	
+	sieve_number_t importance;
+	const char *message;
+	const char *from;
+};
+
+/*
+ * Logging
+ */
+
+void sieve_enotify_error
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+void sieve_enotify_warning
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+void sieve_enotify_log
+	(const struct sieve_enotify_log *nlog, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+
+#endif /* __SIEVE_EXT_ENOTIFY_H */
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-notify-method-capability.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,253 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-enotify-common.h"
+
+/* 
+ * String test 
+ *
+ * Syntax:
+ *   notify_method_capability [COMPARATOR] [MATCH-TYPE]
+ *     <notification-uri: string>
+ *     <notification-capability: string>
+ *     <key-list: string-list>
+ */
+
+static bool tst_notifymc_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_notifymc_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_notifymc_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command notify_method_capability_test = { 
+	"notify_method_capability", 
+	SCT_TEST, 
+	3, 0, FALSE, FALSE,
+	tst_notifymc_registered, 
+	NULL,
+	tst_notifymc_validate, 
+	tst_notifymc_generate, 
+	NULL 
+};
+
+/* 
+ * String operation
+ */
+
+static bool tst_notifymc_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_notifymc_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation notify_method_capability_operation = { 
+	"NOTIFY_METHOD_CAPABILITY",
+	&enotify_extension, 
+	EXT_ENOTIFY_OPERATION_NOTIFY_METHOD_CAPABILITY, 
+	tst_notifymc_operation_dump, 
+	tst_notifymc_operation_execute 
+};
+
+/* 
+ * Optional arguments 
+ */
+
+enum tst_notifymc_optional {	
+	OPT_END,
+	OPT_COMPARATOR,
+	OPT_MATCH_TYPE
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_notifymc_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_notifymc_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "notification-uri", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "notification-capability", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+		
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key-list", 3, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_notifymc_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &notify_method_capability_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_notifymc_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "NOTIFY_METHOD_CAPABILITY");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+		
+	return
+		sieve_opr_string_dump(denv, address, "notify uri") &&
+		sieve_opr_string_dump(denv, address, "notify capability") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_notifymc_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_octet_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	string_t *notify_uri, *notify_capability;
+	struct sieve_coded_stringlist *key_list;
+	const char *cap_value;
+	bool matched;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands */
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read notify uri */
+	if ( !sieve_opr_string_read(renv, address, &notify_uri) ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uri operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read notify capability */
+	if ( !sieve_opr_string_read(renv, address, &notify_capability) ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uri operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "NOTIFY_METHOD_CAPABILITY test");
+
+	cap_value = ext_enotify_runtime_get_method_capability
+		(renv, 0 /* FIXME */, notify_uri, str_c(notify_capability));
+
+	if ( cap_value != NULL ) {
+		mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+		if ( (mret=sieve_match_value(mctx, cap_value, strlen(cap_value))) < 0 )
+			result = FALSE;
+		matched = ( mret > 0 );		
+
+		if ( (mret=sieve_match_end(mctx)) < 0 ) 
+			result = FALSE;
+		matched = ( mret > 0 ) || matched;		
+	} else {
+		matched = FALSE;
+	}
+	
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/tst-valid-notify-method.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,148 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-enotify-common.h"
+
+/* 
+ * Valid_notify_method test 
+ *
+ * Syntax:
+ *   valid_notify_method <notification-uris: string-list>
+ */
+
+static bool tst_vnotifym_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_vnotifym_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command valid_notify_method_test = { 
+	"valid_notify_method", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	tst_vnotifym_validate, 
+	tst_vnotifym_generate, 
+	NULL 
+};
+
+/* 
+ * Valid_notify_method operation
+ */
+
+static bool tst_vnotifym_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_vnotifym_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation valid_notify_method_operation = { 
+	"VALID_NOTIFY_METHOD",
+	&enotify_extension, 
+	EXT_ENOTIFY_OPERATION_VALID_NOTIFY_METHOD, 
+	tst_vnotifym_operation_dump, 
+	tst_vnotifym_operation_execute 
+};
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_vnotifym_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "notification-uris", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_vnotifym_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &valid_notify_method_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_vnotifym_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "VALID_NOTIFY_METHOD");
+	sieve_code_descend(denv);
+		
+	return
+		sieve_opr_stringlist_dump(denv, address, "notify-uris");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_vnotifym_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_coded_stringlist *notify_uris;
+	string_t *uri_item;
+	bool result = TRUE, all_valid = TRUE;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Read notify uris */
+	if ( (notify_uris=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid notify-uris operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "VALID_NOTIFY_METHOD test");
+
+	uri_item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(notify_uris, &uri_item)) 
+		&& uri_item != NULL ) {
+		
+		if ( !ext_enotify_runtime_method_validate(renv, 0 /* FIXME */, uri_item) ) {
+			all_valid = FALSE;
+			break;
+		}
+	}
+	
+	if ( !result ) {
+		sieve_runtime_trace_error(renv, "invalid method uri item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	sieve_interpreter_set_test_result(renv->interp, all_valid);
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/enotify/vmodf-encodeurl.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,84 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-enotify-common.h"
+
+/*
+ * Encodeurl modifier
+ */
+ 
+bool mod_encodeurl_modify(string_t *in, string_t **result);
+ 
+const struct sieve_variables_modifier encodeurl_modifier = {
+	SIEVE_OBJECT("encodeurl", &encodeurl_operand, 0),
+	15,
+	mod_encodeurl_modify
+};
+ 
+/*
+ * Modifier operand
+ */
+
+static const struct sieve_extension_objects ext_enotify_modifiers =
+	SIEVE_VARIABLES_DEFINE_MODIFIER(encodeurl_modifier);
+
+const struct sieve_operand encodeurl_operand = { 
+	"modifier", 
+	&enotify_extension,
+	0, 
+	&sieve_variables_modifier_operand_class,
+	&ext_enotify_modifiers
+};
+
+/*
+ * Modifier implementation
+ */
+
+static const char _uri_reserved_lookup[256] = {
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 00
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 10
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,  // 20
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  // 30
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 40
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,  // 50
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 60
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1,  // 70
+
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 80
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // 90
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // A0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // B0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // C0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // D0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // E0
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // F0
+};
+
+bool mod_encodeurl_modify(string_t *in, string_t **result)
+{	
+	unsigned int i;
+	const unsigned char *c;
+
+	*result = t_str_new(2*str_len(in));
+	c = str_data(in);
+	
+	for ( i = 0; i < str_len(in); i++, c++ ) {
+		if ( _uri_reserved_lookup[*c] ) {
+			str_printfa(*result, "%%%02X", *c);
+		} else {
+			str_append_c(*result, *c); 
+		}	
+	}
+
+	return TRUE;
+}
+ 
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,53 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension variables 
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5183
+ * Implementation: full
+ * Status: experimental, not thoroughly tested
+ *
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-validator.h"
+
+#include "ext-environment-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_environment_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+const struct sieve_extension environment_extension = { 
+	"environment", 
+	&ext_my_id,
+	ext_environment_init, 
+	ext_environment_deinit,
+	ext_environment_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(tst_environment_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_environment_validator_load
+	(struct sieve_validator *validator)
+{
+	sieve_validator_register_command(validator, &tst_environment);
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,168 @@
+#include "lib.h"
+#include "hash.h"
+
+#include "ext-environment-common.h"
+
+static struct hash_table *environment_items;
+
+/*
+ * Core environment items
+ */
+
+static const struct sieve_environment_item *core_env_items[] = {
+	&domain_env_item, 
+	&host_env_item, 
+	&location_env_item, 
+	&phase_env_item, 
+	&name_env_item, 
+	&version_env_item
+};
+
+static unsigned int core_env_items_count = N_ELEMENTS(core_env_items);
+
+/*
+ * Initialization
+ */
+
+bool ext_environment_init(void) 
+{
+	unsigned int i;
+
+	environment_items = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+
+	for ( i = 0; i < core_env_items_count; i++ ) {
+		sieve_ext_environment_item_register(core_env_items[i]);
+	}
+
+	return TRUE;
+}
+
+void ext_environment_deinit(void)
+{
+	hash_table_destroy(&environment_items);
+}
+
+/*
+ * Registration
+ */
+
+void sieve_ext_environment_item_register
+(const struct sieve_environment_item *item)
+{
+	hash_table_insert
+		(environment_items, (void *) item->name, (void *) item);
+}
+
+/*
+ * Retrieval
+ */
+
+const char *ext_environment_item_get_value
+(const char *name, const struct sieve_script_env *senv)
+{
+	const struct sieve_environment_item *item = 
+		(const struct sieve_environment_item *) 
+			hash_table_lookup(environment_items, name);
+
+	if ( item == NULL )
+		return NULL;
+
+	if ( item->value != NULL )
+		return item->value;
+
+	if ( item->get_value != NULL ) 
+		return item->get_value(senv);
+
+	return NULL; 
+}
+
+/*
+ * Default environment items
+ */
+
+/* "domain":
+ *
+ *   The primary DNS domain associated with the Sieve execution context, usually 
+ *   but not always a proper suffix of the host name.
+ */
+const struct sieve_environment_item domain_env_item = {
+	"domain",
+	NULL,
+	NULL,
+};
+
+/* "host":
+ *
+ *   The fully-qualified domain name of the host where the Sieve script is 
+ *   executing.
+ */
+
+static const char *envit_host_get_value(const struct sieve_script_env *senv)
+{
+	return senv->hostname != NULL ? senv->hostname : "";
+}
+
+const struct sieve_environment_item host_env_item = {
+	"host",
+	NULL,
+	envit_host_get_value,
+};
+
+/* "location":
+ *
+ *   Sieve evaluation can be performed at various different points as messages 
+ *   are processed. This item provides additional information about the type of
+ *   service that is evaluating the script.  Possible values are:
+ *    "MTA" - the Sieve script is being evaluated by a Message Transfer Agent 
+ *    "MDA" - evaluation is being performed by a Mail Delivery Agent 
+ *    "MUA" - evaluation is being performed by a Mail User Agent
+ *    "MS"  - evaluation is being performed by a Message Store
+ */
+const struct sieve_environment_item location_env_item = {
+	"location",
+	NULL,
+	NULL,
+};
+
+/* "phase":
+ *
+ *   The point relative to final delivery where the Sieve script is being
+ *   evaluated.  Possible values are "pre", "during", and "post", referring 
+ *   respectively to processing before, during, and after final delivery has 
+ *   taken place.
+ */
+
+const struct sieve_environment_item phase_env_item = {
+	"phase",
+	NULL,
+	NULL,
+};
+
+/* "name":
+ *
+ *  The product name associated with the Sieve interpreter.
+ */
+const struct sieve_environment_item name_env_item = {
+	"name",
+	SIEVE_NAME,
+	NULL,
+};
+
+/* "version":
+ *
+ * The product version associated with the Sieve interpreter. The meaning of the 
+ * product version string is product-specific and should always be considered
+ * in the context of the product name given by the "name" item.
+ */
+
+const struct sieve_environment_item version_env_item = {
+	"version",
+	SIEVE_VERSION,
+	NULL,
+};
+
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/ext-environment-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,54 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_ENVIRONMENT_COMMON_H
+#define __EXT_ENVIRONMENT_COMMON_H
+
+#include "sieve-common.h"
+
+#include "sieve-ext-environment.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension environment_extension;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command tst_environment;
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation tst_environment_operation;
+
+/*
+ * Environment items
+ */
+
+extern const struct sieve_environment_item domain_env_item;
+extern const struct sieve_environment_item host_env_item;
+extern const struct sieve_environment_item location_env_item;
+extern const struct sieve_environment_item phase_env_item;
+extern const struct sieve_environment_item name_env_item;
+extern const struct sieve_environment_item version_env_item;
+
+/*
+ * Initialization
+ */
+
+bool ext_environment_init(void);
+void ext_environment_deinit(void);
+
+/*
+ * Environment item retrieval
+ */
+
+const char *ext_environment_item_get_value
+	(const char *name, const struct sieve_script_env *senv);
+
+#endif /* __EXT_VARIABLES_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,20 @@
+noinst_LTLIBRARIES = libsieve_ext_environment.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+tests = \
+	tst-environment.c
+
+libsieve_ext_environment_la_SOURCES = \
+	$(tests) \
+	ext-environment-common.c \
+	ext-environment.c
+
+noinst_HEADERS = \
+	ext-environment-common.h \
+	sieve-ext-environment.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/sieve-ext-environment.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,16 @@
+#ifndef __SIEVE_EXT_ENVIRONMENT_H
+#define __SIEVE_EXT_ENVIRONMENT_H
+
+#include "sieve-common.h"
+
+struct sieve_environment_item {
+	const char *name;
+	
+	const char *value;
+	const char *(*get_value)(const struct sieve_script_env *senv);
+};
+
+void sieve_ext_environment_item_register
+	(const struct sieve_environment_item *item);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/environment/tst-environment.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,226 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-environment-common.h"
+
+/* 
+ * Environment test 
+ *
+ * Syntax:
+ *   environment [COMPARATOR] [MATCH-TYPE]
+ *      <name: string> <key-list: string-list>
+ */
+
+static bool tst_environment_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_environment_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_environment_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_environment = { 
+	"environment", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_environment_registered, 
+	NULL,
+	tst_environment_validate, 
+	tst_environment_generate, 
+	NULL 
+};
+
+/* 
+ * Environment operation
+ */
+
+static bool tst_environment_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_environment_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_environment_operation = { 
+	"ENVIRONMENT",
+	&environment_extension, 
+	0, 
+	tst_environment_operation_dump, 
+	tst_environment_operation_execute 
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_environment_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_environment_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_octet_comparator);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_environment_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_environment_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+	
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_environment_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "ENVIRONMENT");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+		
+	return
+		sieve_opr_string_dump(denv, address, "name") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_environment_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	string_t *name;
+	struct sieve_coded_stringlist *key_list;
+	const char *env_item;
+	bool matched = FALSE;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read source */
+	if ( !sieve_opr_string_read(renv, address, &name) ) {
+		sieve_runtime_trace_error(renv, "invalid name operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "ENVIRONMENT test");
+
+	env_item = ext_environment_item_get_value(str_c(name), renv->scriptenv);
+
+	if ( env_item != NULL ) {
+		mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+		if ( (mret=sieve_match_value(mctx, strlen(env_item) == 0 ? NULL : env_item, 
+			strlen(env_item))) < 0 ) {
+			result = FALSE;
+		} else {
+			matched = ( mret > 0 );				
+		}
+
+		if ( (mret=sieve_match_end(mctx)) < 0 )
+			result = FALSE;
+		else
+			matched = ( mret > 0 || matched );
+	}
+	
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid key list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/cmd-flag.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,264 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Commands
+ */
+
+/* Forward declarations */
+
+static bool cmd_flag_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+/* Setflag command 
+ *
+ * Syntax: 
+ *   setflag [<variablename: string>] <list-of-flags: string-list>
+ */
+ 
+const struct sieve_command cmd_setflag = { 
+	"setflag", 
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	NULL, NULL,
+	ext_imap4flags_command_validate, 
+	cmd_flag_generate, 
+	NULL 
+};
+
+/* Addflag command 
+ *
+ * Syntax:
+ *   addflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command cmd_addflag = { 
+	"addflag", 
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	NULL, NULL,
+	ext_imap4flags_command_validate, 
+	cmd_flag_generate, 
+	NULL 
+};
+
+
+/* Removeflag command 
+ *
+ * Syntax:
+ *   removeflag [<variablename: string>] <list-of-flags: string-list>
+ */
+
+const struct sieve_command cmd_removeflag = { 
+	"removeflag", 
+	SCT_COMMAND,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	NULL, NULL,
+	ext_imap4flags_command_validate, 
+	cmd_flag_generate, 
+	NULL 
+};
+
+/*
+ * Operations
+ */
+
+/* Forward declarations */
+
+bool cmd_flag_operation_dump
+	(const struct sieve_operation *op,
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_flag_operation_execute
+	(const struct sieve_operation *op,	
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Setflag operation */
+
+const struct sieve_operation setflag_operation = { 
+	"SETFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_SETFLAG,
+	cmd_flag_operation_dump,
+	cmd_flag_operation_execute
+};
+
+/* Addflag operation */
+
+const struct sieve_operation addflag_operation = { 
+	"ADDFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_ADDFLAG,
+	cmd_flag_operation_dump,	
+	cmd_flag_operation_execute
+};
+
+/* Removeflag operation */
+
+const struct sieve_operation removeflag_operation = { 
+	"REMOVEFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_REMOVEFLAG,
+	cmd_flag_operation_dump, 
+	cmd_flag_operation_execute 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool cmd_flag_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	const struct sieve_command *command = ctx->command;
+
+	/* Emit operation */
+	if ( command == &cmd_setflag ) 
+		sieve_operation_emit_code(cgenv->sbin, &setflag_operation);
+	else if ( command == &cmd_addflag ) 
+		sieve_operation_emit_code(cgenv->sbin, &addflag_operation);
+	else if ( command == &cmd_removeflag ) 
+		sieve_operation_emit_code(cgenv->sbin, &removeflag_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+
+	return TRUE;
+}
+
+/*
+ * Code dump
+ */
+
+bool cmd_flag_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_operand *operand;
+
+	sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);
+	
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+
+	if ( sieve_operand_is_variable(operand) ) {	
+		return 
+			sieve_opr_string_dump_data(denv, operand, address, 
+				"variable name") &&
+			sieve_opr_stringlist_dump(denv, address, 
+				"list of flags");
+	}
+	
+	return 
+		sieve_opr_stringlist_dump_data(denv, operand, address,
+			"list of flags");
+}
+ 
+/*
+ * Code execution
+ */
+
+static int cmd_flag_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	const struct sieve_operand *operand;
+	sieve_size_t op_address = *address;
+	bool result = TRUE;
+	string_t *flag_item;
+	struct sieve_coded_stringlist *flag_list;
+	struct sieve_variable_storage *storage;
+	unsigned int var_index;
+	ext_imapflag_flag_operation_t flag_op;
+	int ret;
+		
+	/* 
+	 * Read operands 
+	 */
+
+	operand = sieve_operand_read(renv->sbin, address);
+	if ( operand == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	if ( sieve_operand_is_variable(operand) ) {		
+
+		/* Read the variable operand */
+		if ( !sieve_variable_operand_read_data
+			(renv, operand, address, &storage, &var_index) ) {
+			sieve_runtime_trace_error(renv, "invalid variable operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		/* Read flag list */
+		if ( (flag_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+			sieve_runtime_trace_error(renv, "invalid flag-list operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+	} else if ( sieve_operand_is_stringlist(operand) ) {	
+		storage = NULL;
+		var_index = 0;
+		
+		/* Read flag list */
+		if ( (flag_list=sieve_opr_stringlist_read_data
+			(renv, operand, op_address, address)) == NULL ) {
+			sieve_runtime_trace_error(renv, "invalid flag-list operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+	} else {
+		sieve_runtime_trace_error(renv, "unexpected operand '%s'", 
+			operand->name);
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */	
+	
+	sieve_runtime_trace(renv, "%s command", op->mnemonic);
+
+	/* Determine what to do */
+
+	if ( op == &setflag_operation )
+		flag_op = ext_imap4flags_set_flags;
+	else if ( op == &addflag_operation )
+		flag_op = ext_imap4flags_add_flags;
+	else if ( op == &removeflag_operation )
+		flag_op = ext_imap4flags_remove_flags;
+	else
+		i_unreached();
+
+	/* Iterate through all flags and perform requested operation */
+	
+	while ( (result=sieve_coded_stringlist_next_item(flag_list, &flag_item)) && 
+		flag_item != NULL ) {
+
+		if ( (ret=flag_op(renv, storage, var_index, flag_item)) <= 0)
+			return ret;
+	}
+
+	if ( !result ) {	
+		sieve_runtime_trace_error(renv, "invalid flag-list item");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	return SIEVE_EXEC_OK;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension imap4flags
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5232
+ * Implementation: full 
+ * Status: experimental, roughly tested
+ *
+ */
+ 
+#include "lib.h"
+#include "mempool.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-imap4flags-common.h"
+
+/* 
+ * Operations 
+ */
+
+const struct sieve_operation *imap4flags_operations[] = { 
+	&setflag_operation, 
+	&addflag_operation, 
+	&removeflag_operation,
+	&hasflag_operation 
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_imap4flags_validator_load(struct sieve_validator *valdtr);
+static bool ext_imap4flags_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+int ext_imap4flags_my_id = -1;
+
+const struct sieve_extension imap4flags_extension = { 
+	"imap4flags", 
+	&ext_imap4flags_my_id,
+	NULL, NULL,
+	ext_imap4flags_validator_load, 
+	NULL, 
+	ext_imap4flags_interpreter_load, 
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATIONS(imap4flags_operations), 
+	SIEVE_EXT_DEFINE_OPERAND(flags_side_effect_operand)
+};
+
+static bool ext_imap4flags_validator_load
+(struct sieve_validator *valdtr)
+{
+	/* Register commands */
+	sieve_validator_register_command(valdtr, &cmd_setflag);
+	sieve_validator_register_command(valdtr, &cmd_addflag);
+	sieve_validator_register_command(valdtr, &cmd_removeflag);
+	sieve_validator_register_command(valdtr, &tst_hasflag);
+	
+	ext_imap4flags_attach_flags_tag(valdtr, "keep");
+	ext_imap4flags_attach_flags_tag(valdtr, "fileinto");
+
+	return TRUE;
+}
+
+static bool ext_imap4flags_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	sieve_interpreter_extension_register
+        (renv->interp, &imap4flags_interpreter_extension, NULL);
+
+	return TRUE;
+}
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,488 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-result.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Forward declarations
+ */
+
+static bool flag_is_valid(const char *flag);
+
+/* 
+ * Tagged arguments 
+ */
+
+extern const struct sieve_argument tag_flags;
+extern const struct sieve_argument tag_flags_implicit;
+
+/* 
+ * Common command functions 
+ */
+
+bool ext_imap4flags_command_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct sieve_ast_argument *arg2;
+	
+	/* Check arguments */
+	
+	if ( arg == NULL ) {
+		sieve_command_validate_error(validator, cmd, 
+			"the %s %s expects at least one argument, but none was found", 
+			cmd->command->identifier, sieve_command_type_name(cmd->command));
+		return FALSE;
+	}
+	
+	if ( sieve_ast_argument_type(arg) != SAAT_STRING && 
+		sieve_ast_argument_type(arg) != SAAT_STRING_LIST ) 
+	{
+		sieve_argument_validate_error(validator, arg, 
+			"the %s %s expects either a string (variable name) or "
+			"a string-list (list of flags) as first argument, but %s was found", 
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			sieve_ast_argument_name(arg));
+		return FALSE; 
+	}
+
+	arg2 = sieve_ast_argument_next(arg);
+	if ( arg2 != NULL ) {		
+		/* First, check syntax sanity */
+				
+		if ( sieve_ast_argument_type(arg) != SAAT_STRING ) 
+		{
+			if ( cmd->command == &tst_hasflag ) {
+				if ( sieve_ast_argument_type(arg) != SAAT_STRING_LIST ) {
+					sieve_argument_validate_error(validator, arg, 
+						"if a second argument is specified for the hasflag, the first "
+						"must be a string-list (variable-list), but %s was found",
+						sieve_ast_argument_name(arg));
+					return FALSE;
+				}
+			} else {
+				sieve_argument_validate_error(validator, arg, 
+					"if a second argument is specified for the %s %s, the first "
+					"must be a string (variable name), but %s was found",
+					cmd->command->identifier, sieve_command_type_name(cmd->command), 
+					sieve_ast_argument_name(arg));
+				return FALSE; 
+			}
+		}
+		
+		/* Then, check whether the second argument is permitted */
+		
+		if ( !sieve_ext_variables_is_active(validator) )	{
+			sieve_argument_validate_error(validator,arg, 
+				"the %s %s only allows for the specification of a "
+				"variable name when the variables extension is active",
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+			return FALSE;
+		}		
+		
+		if ( !sieve_variable_argument_activate(validator, cmd, arg, 
+			cmd->command != &tst_hasflag ) )
+			return FALSE;
+		
+		if ( sieve_ast_argument_type(arg2) != SAAT_STRING && 
+			sieve_ast_argument_type(arg2) != SAAT_STRING_LIST ) 
+		{
+			sieve_argument_validate_error(validator, arg2, 
+				"the %s %s expects a string list (list of flags) as "
+				"second argument when two arguments are specified, "
+				"but %s was found",
+				cmd->command->identifier, sieve_command_type_name(cmd->command),
+				sieve_ast_argument_name(arg2));
+			return FALSE; 
+		}
+	} else
+		arg2 = arg;
+
+	if ( !sieve_validator_argument_activate(validator, cmd, arg2, FALSE) )
+		return FALSE;
+
+	if ( cmd->command != &tst_hasflag && sieve_argument_is_string_literal(arg2) ) {
+		struct ext_imap4flags_iter fiter;
+		const char *flag;
+		
+		/* Warn the user about validity of verifiable flags */
+		ext_imap4flags_iter_init(&fiter, sieve_ast_argument_str(arg));
+
+		while ( (flag=ext_imap4flags_iter_get_flag(&fiter)) != NULL ) {
+			if ( !flag_is_valid(flag) ) {
+				sieve_argument_validate_warning(validator, arg,
+                	"IMAP flag '%s' specified for the %s command is invalid "
+					"and will be ignored (only first invalid is reported)",					
+					str_sanitize(flag, 64), cmd->command->identifier);
+				break;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Flags tag registration 
+ */
+
+void ext_imap4flags_attach_flags_tag
+(struct sieve_validator *valdtr, const char *command)
+{
+	/* Register :flags tag with the command and we don't care whether it is 
+	 * registered or even whether it will be registered at all. The validator 
+	 * handles either situation gracefully 
+	 */
+	 
+	/* Tag specified by user */
+	sieve_validator_register_external_tag
+		(valdtr, &tag_flags, command, -1);
+
+    /* Implicit tag if none is specified */
+	sieve_validator_register_persistent_tag
+		(valdtr, &tag_flags_implicit, command);
+}
+
+/* 
+ * Result context 
+ */
+
+struct ext_imap4flags_result_context {
+    string_t *internal_flags;
+};
+
+static inline struct ext_imap4flags_result_context *_get_result_context
+(struct sieve_result *result)
+{
+	struct ext_imap4flags_result_context *rctx =
+		(struct ext_imap4flags_result_context *) 
+		sieve_result_extension_get_context(result, &imap4flags_extension);
+
+	if ( rctx == NULL ) {
+		pool_t pool = sieve_result_pool(result);
+
+		rctx =p_new(pool, struct ext_imap4flags_result_context, 1);
+		rctx->internal_flags = str_new(pool, 32);
+
+		sieve_result_extension_set_context
+			(result, &imap4flags_extension, rctx);
+	}
+
+	return rctx;
+}
+
+static string_t *_get_flags_string
+(struct sieve_result *result)
+{
+	struct ext_imap4flags_result_context *ctx = 
+		_get_result_context(result);
+		
+	return ctx->internal_flags;
+}
+
+/* 
+ * Runtime initialization 
+ */
+
+static void ext_imap4flags_runtime_init
+(const struct sieve_runtime_env *renv, void *context ATTR_UNUSED)
+{	
+	sieve_result_add_implicit_side_effect
+		(renv->result, &act_store, &flags_side_effect, NULL);
+}
+
+const struct sieve_interpreter_extension imap4flags_interpreter_extension = {
+	&imap4flags_extension,
+	ext_imap4flags_runtime_init,
+	NULL,
+};
+
+/* 
+ * Flag operations 
+ */
+
+/* FIXME: This currently accepts a potentially unlimited number of 
+ * flags, making the internal or variable flag list indefinitely long
+ */
+static bool flag_is_valid(const char *flag)
+{	
+	if (*flag == '\\') {
+		/* System flag */
+		const char *atom = t_str_ucase(flag); 
+        
+		if (
+			(strcmp(atom, "\\ANSWERED") != 0) &&
+			(strcmp(atom, "\\FLAGGED") != 0) &&
+			(strcmp(atom, "\\DELETED") != 0) &&
+			(strcmp(atom, "\\SEEN") != 0) &&
+			(strcmp(atom, "\\DRAFT") != 0) )  
+		{           
+			return FALSE;
+		}
+	} else {
+		/* Custom keyword:
+		 *
+		 * The validity of the keyword cannot be validated until the 
+		 * target mailbox for the message is known. Meaning that the 
+		 * verfication of keyword can only be performed when the
+		 * action side effect is about to be executed.
+		 *
+		 * FIXME: technically this is nonsense, since we can simply parse
+		 * using the flag-keyword grammar provided by imap.
+		 */					
+	}
+
+	return TRUE;  
+}
+
+void ext_imap4flags_iter_init
+(struct ext_imap4flags_iter *iter, string_t *flags_list) 
+{
+	iter->flags_list = flags_list;
+	iter->offset = 0;
+	iter->last = 0;
+}
+
+const char *ext_imap4flags_iter_get_flag
+(struct ext_imap4flags_iter *iter) 
+{
+	unsigned int len = str_len(iter->flags_list);
+	const unsigned char *fp;
+	const unsigned char *fbegin;
+	const unsigned char *fstart;
+	const unsigned char *fend;
+	
+	if ( iter->offset >= len ) return NULL;
+	
+	fbegin = str_data(iter->flags_list);
+	fp = fbegin + iter->offset;
+	fstart = fp;
+	fend = fbegin + len;
+	for (;;) {
+		if ( fp >= fend || *fp == ' ' ) { 
+			if ( fp > fstart ) {
+				const char *flag = t_strdup_until(fstart, fp);
+				
+				iter->last = fstart - fbegin;
+				iter->offset = fp - fbegin;
+				return flag;
+			} 	
+			
+			fstart = fp+1;
+		}
+		
+		if ( fp >= fend ) break;
+				
+		fp++;
+	}
+	
+	iter->last = fstart - fbegin;
+	iter->offset = fp - fbegin;
+	return NULL;
+}
+
+static void ext_imap4flags_iter_delete_last
+(struct ext_imap4flags_iter *iter) 
+{
+	iter->offset++;
+	if ( iter->offset > str_len(iter->flags_list) )
+		iter->offset = str_len(iter->flags_list);
+	if ( iter->offset == str_len(iter->flags_list) )
+		iter->last--;
+
+	str_delete(iter->flags_list, iter->last, iter->offset - iter->last);	
+	
+	iter->offset = iter->last;
+}
+
+static bool flags_list_flag_exists
+(string_t *flags_list, const char *flag)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags_list);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( strcasecmp(flg, flag) == 0 ) 
+			return TRUE; 	
+	}
+	
+	return FALSE;
+}
+
+static void flags_list_flag_delete
+(string_t *flags_list, const char *flag)
+{
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags_list);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( strcasecmp(flg, flag) == 0 ) {
+			ext_imap4flags_iter_delete_last(&flit);
+		} 	
+	}
+}
+ 			
+static void flags_list_add_flags
+(string_t *flags_list, string_t *flags)
+{	
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		if ( flag_is_valid(flg) && !flags_list_flag_exists(flags_list, flg) ) {
+			if ( str_len(flags_list) != 0 ) 
+				str_append_c(flags_list, ' '); 
+			str_append(flags_list, flg);
+		} 	
+	}
+}
+
+static void flags_list_remove_flags
+(string_t *flags_list, string_t *flags)
+{	
+	const char *flg;
+	struct ext_imap4flags_iter flit;
+		
+	ext_imap4flags_iter_init(&flit, flags);
+	
+	while ( (flg=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {
+		flags_list_flag_delete(flags_list, flg); 	
+	}
+}
+
+static void flags_list_set_flags
+(string_t *flags_list, string_t *flags)
+{
+	str_truncate(flags_list, 0);
+	flags_list_add_flags(flags_list, flags);
+}
+
+/* 
+ * Flag registration 
+ */
+
+int ext_imap4flags_set_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+
+	if ( cur_flags != NULL )
+		flags_list_set_flags(cur_flags, flags);		
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_add_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+	
+	if ( cur_flags != NULL )
+		flags_list_add_flags(cur_flags, flags);
+	
+	return SIEVE_EXEC_OK;	
+}
+
+int ext_imap4flags_remove_flags
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+	unsigned int var_index, string_t *flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+	
+	if ( cur_flags != NULL )
+		flags_list_remove_flags(cur_flags, flags);		
+
+	return SIEVE_EXEC_OK;
+}
+
+int ext_imap4flags_get_flags_string
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage, 
+	unsigned int var_index, const char **flags)
+{
+	string_t *cur_flags;
+	
+	if ( storage != NULL ) {
+		if ( !sieve_variable_get_modifiable(storage, var_index, &cur_flags) )
+			return SIEVE_EXEC_BIN_CORRUPT;
+	} else
+		cur_flags = _get_flags_string(renv->result);
+	
+	if ( cur_flags == NULL )
+		*flags = "";
+	else 
+		*flags = str_c(cur_flags);
+
+	return SIEVE_EXEC_OK;
+}
+
+void ext_imap4flags_get_flags_init
+(struct ext_imap4flags_iter *iter, const struct sieve_runtime_env *renv,
+	string_t *flags_list)
+{
+	string_t *cur_flags;
+	
+	if ( flags_list != NULL ) {
+		cur_flags = t_str_new(256);
+		
+		flags_list_set_flags(cur_flags, flags_list);
+	}
+	else
+		cur_flags = _get_flags_string(renv->result);
+	
+	ext_imap4flags_iter_init(iter, cur_flags);		
+}
+
+void ext_imap4flags_get_implicit_flags_init
+(struct ext_imap4flags_iter *iter, struct sieve_result *result)
+{
+	string_t *cur_flags = _get_flags_string(result);
+	
+	ext_imap4flags_iter_init(iter, cur_flags);		
+}
+
+
+	
+	
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imap4flags-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_IMAP4FLAGS_COMMON_H
+#define __EXT_IMAP4FLAGS_COMMON_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-ext-variables.h"
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension imap4flags_extension;
+extern const struct sieve_interpreter_extension 
+	imap4flags_interpreter_extension;
+
+/*
+ * Side effect
+ */
+
+extern const struct sieve_side_effect flags_side_effect;
+
+/*
+ * Operands
+ */
+
+extern const struct sieve_operand flags_side_effect_operand;
+
+/*
+ * Operations
+ */
+ 
+enum ext_imap4flags_opcode {
+	ext_imap4flags_OPERATION_SETFLAG,
+	ext_imap4flags_OPERATION_ADDFLAG,
+	ext_imap4flags_OPERATION_REMOVEFLAG,
+	ext_imap4flags_OPERATION_HASFLAG
+};
+
+extern const struct sieve_operation setflag_operation;
+extern const struct sieve_operation addflag_operation;
+extern const struct sieve_operation removeflag_operation;
+extern const struct sieve_operation hasflag_operation;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command cmd_setflag;
+extern const struct sieve_command cmd_addflag;
+extern const struct sieve_command cmd_removeflag;
+
+extern const struct sieve_command tst_hasflag;
+
+/*
+ * Common command functions
+ */
+
+bool ext_imap4flags_command_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+
+/*
+ * Flags tagged argument
+ */	
+	
+void ext_imap4flags_attach_flags_tag
+	(struct sieve_validator *valdtr, const char *command);
+
+/* 
+ * Flag management 
+ */
+
+struct ext_imap4flags_iter {
+	string_t *flags_list;
+	unsigned int offset;
+	unsigned int last;
+};
+
+void ext_imap4flags_iter_init
+	(struct ext_imap4flags_iter *iter, string_t *flags_list);
+	
+const char *ext_imap4flags_iter_get_flag
+	(struct ext_imap4flags_iter *iter);
+
+typedef int (*ext_imapflag_flag_operation_t)
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+
+int ext_imap4flags_set_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+int ext_imap4flags_add_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+int ext_imap4flags_remove_flags
+	(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage,
+		unsigned int var_index, string_t *flags);
+
+/*
+ * Flags access
+ */
+
+int ext_imap4flags_get_flags_string
+(const struct sieve_runtime_env *renv, struct sieve_variable_storage *storage, 
+	unsigned int var_index, const char **flags);
+
+void ext_imap4flags_get_flags_init
+	(struct ext_imap4flags_iter *iter, const struct sieve_runtime_env *renv,
+		string_t *flags_list);
+void ext_imap4flags_get_implicit_flags_init
+	(struct ext_imap4flags_iter *iter, struct sieve_result *result);
+
+
+#endif /* __EXT_IMAP4FLAGS_COMMON_H */
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/ext-imapflags.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,175 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension imapflags
+ * --------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-melnikov-sieve-imapflags-03.txt
+ * Implementation: depricated; provided for backwards compatibility
+ * Status: depricated
+ *
+ */
+ 
+#include "lib.h"
+#include "mempool.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Commands
+ */
+
+static bool cmd_mark_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd);
+
+/* Mark command
+ *
+ * Syntax:
+ *   mark
+ */
+
+static const struct sieve_command cmd_mark = {
+    "mark",
+    SCT_COMMAND,
+    0, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_mark_validate,
+    NULL, NULL,
+};
+
+/* Unmark command
+ *
+ * Syntax:
+ *   unmark
+ */
+static const struct sieve_command cmd_unmark = {
+    "unmark",
+    SCT_COMMAND,
+    0, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_mark_validate,
+    NULL, NULL,
+};
+
+/* 
+ * Extension
+ */
+
+static bool ext_imapflags_load(void);
+static bool ext_imapflags_validator_load(struct sieve_validator *valdtr);
+static bool ext_imapflags_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+int ext_imapflags_my_id = -1;
+
+const struct sieve_extension imapflags_extension = { 
+	"imapflags", 
+	&ext_imapflags_my_id,
+	ext_imapflags_load, 
+	NULL,
+	ext_imapflags_validator_load, 
+	NULL,
+	ext_imapflags_interpreter_load, 
+	NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_imapflags_load(void)
+{
+	/* Make sure real extension is registered, it is needed by the binary */
+	(void)sieve_extension_require(&imap4flags_extension);
+
+	return TRUE;
+}
+
+/*
+ * Validator
+ */
+
+static bool ext_imapflags_validator_extension_validate
+	(struct sieve_validator *valdtr, void *context, struct sieve_ast_argument *require_arg);
+
+const struct sieve_validator_extension imapflags_validator_extension = {
+	&imapflags_extension,
+	ext_imapflags_validator_extension_validate,
+	NULL
+};
+
+static bool ext_imapflags_validator_load
+(struct sieve_validator *valdtr)
+{
+	sieve_validator_extension_register
+	    (valdtr, &imapflags_validator_extension, NULL);
+
+	/* Register commands */
+	sieve_validator_register_command(valdtr, &cmd_setflag);
+	sieve_validator_register_command(valdtr, &cmd_addflag);
+	sieve_validator_register_command(valdtr, &cmd_removeflag);
+
+	sieve_validator_register_command(valdtr, &cmd_mark);
+	sieve_validator_register_command(valdtr, &cmd_unmark);	
+	
+	return TRUE;
+}
+
+static bool ext_imapflags_validator_extension_validate
+(struct sieve_validator *valdtr, void *context ATTR_UNUSED, 
+	struct sieve_ast_argument *require_arg)
+{
+	if ( sieve_validator_extension_loaded(valdtr, &imap4flags_extension) ) {
+		sieve_argument_validate_error(valdtr, require_arg,
+			"the (depricated) imapflags extension cannot be used "
+			"together with the imap4flags extension");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*
+ * Interpreter
+ */
+
+static bool ext_imapflags_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+    sieve_interpreter_extension_register
+        (renv->interp, &imap4flags_interpreter_extension, NULL);
+
+    return TRUE;
+}
+
+/*
+ * Command validation
+ */ 
+
+static bool cmd_mark_validate
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd)
+{
+	if ( cmd->command == &cmd_mark )
+		cmd->command = &cmd_addflag;
+	else
+		cmd->command = &cmd_removeflag;
+
+	cmd->first_positional = sieve_ast_argument_cstring_create
+		(cmd->ast_node, "\\flagged", cmd->ast_node->source_line);
+
+	if ( !sieve_validator_argument_activate(valdtr, cmd, cmd->first_positional, FALSE) )
+        return FALSE;	
+		
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,30 @@
+noinst_LTLIBRARIES = libsieve_ext_imap4flags.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+    -I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-flag.c
+
+tests = \
+	tst-hasflag.c
+
+tags = \
+	tag-flags.c
+
+libsieve_ext_imap4flags_la_SOURCES = \
+	ext-imap4flags-common.c \
+	$(commands) \
+	$(tests) \
+	$(tags) \
+	ext-imap4flags.c \
+	ext-imapflags.c
+	
+
+noinst_HEADERS = \
+	ext-imap4flags-common.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tag-flags.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,443 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "array.h"
+#include "mail-storage.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-result.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-actions.h"
+#include "sieve-dump.h"
+
+#include "ext-imap4flags-common.h"
+
+#include <ctype.h>
+
+/* 
+ * Flags tagged argument
+ */
+
+static bool tag_flags_validate
+	(struct sieve_validator *validator,	struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_flags_validate_persistent
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool tag_flags_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+		struct sieve_command_context *cmd);
+
+const struct sieve_argument tag_flags = { 
+	"flags", 
+	NULL, NULL,
+	tag_flags_validate, 
+	NULL, 
+	tag_flags_generate 
+};
+
+const struct sieve_argument tag_flags_implicit = { 
+	"flags-implicit", 
+	NULL,
+	tag_flags_validate_persistent, 
+	NULL, NULL,
+	tag_flags_generate
+};
+
+/* 
+ * Side effect 
+ */
+
+static bool seff_flags_dump_context
+	(const struct sieve_side_effect *seffect,
+    	const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static bool seff_flags_read_context
+	(const struct sieve_side_effect *seffect, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address,
+		void **se_context);
+
+static int seff_flags_merge
+	(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+		const struct sieve_side_effect *seffect, 
+		void **old_context, void *new_context);
+static void seff_flags_print
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action,
+		const struct sieve_result_print_env *rpenv, void *se_context, bool *keep);
+static bool seff_flags_pre_execute
+	(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, 
+		void **se_context, void *tr_context);
+
+const struct sieve_side_effect flags_side_effect = {
+	SIEVE_OBJECT("flags", &flags_side_effect_operand, 0),
+	&act_store,
+
+	seff_flags_dump_context,
+	seff_flags_read_context,
+	seff_flags_merge,
+	seff_flags_print,
+	seff_flags_pre_execute, 
+	NULL, NULL, NULL
+};
+
+/*
+ * Operand
+ */
+
+static const struct sieve_extension_objects ext_side_effects =
+	SIEVE_EXT_DEFINE_SIDE_EFFECT(flags_side_effect);
+
+const struct sieve_operand flags_side_effect_operand = { 
+	"flags operand", 
+	&imap4flags_extension,
+	0, 
+	&sieve_side_effect_operand_class,
+	&ext_side_effects
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool tag_flags_validate_persistent
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_command_context *cmd)
+{
+	if ( sieve_command_find_argument(cmd, &tag_flags) == NULL ) {
+		sieve_command_add_dynamic_tag(cmd, &tag_flags_implicit, -1);
+	}
+	
+	return TRUE;
+}
+
+static bool tag_flags_validate
+(struct sieve_validator *validator,	struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	/* Check syntax:
+	 *   :flags <list-of-flags: string-list>
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	tag->parameters = *arg;
+	
+	/* Detach parameter */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+
+	return TRUE;
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tag_flags_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg,
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *param;
+
+	if ( sieve_ast_argument_type(arg) != SAAT_TAG ) {
+		return FALSE;
+	}
+
+	sieve_opr_side_effect_emit(cgenv->sbin, &flags_side_effect);
+
+	if ( arg->argument == &tag_flags ) {
+		/* Explicit :flags tag */
+		param = arg->parameters;
+
+		/* Call the generation function for the argument */ 
+		if ( param->argument != NULL && param->argument->generate != NULL && 
+			!param->argument->generate(cgenv, param, cmd) ) 
+			return FALSE;
+
+	} else if ( arg->argument == &tag_flags_implicit ) {
+		/* Implicit flags */
+		sieve_opr_omitted_emit(cgenv->sbin);
+	
+	} else {
+		/* Something else?! */
+		i_unreached();
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Side effect implementation
+ */
+ 
+/* Context data */
+
+struct seff_flags_context {
+	ARRAY_DEFINE(keywords, const char *);
+	enum mail_flags flags;
+};
+
+/* Context coding */
+
+static bool seff_flags_dump_context
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    const struct sieve_operand *operand;
+
+    operand = sieve_operand_read(denv->sbin, address);
+
+    if ( sieve_operand_is_omitted(operand) ) {
+		sieve_code_dumpf(denv, "flags: INTERNAL");
+		return TRUE;
+    }
+
+    return sieve_opr_stringlist_dump_data(denv, operand, address,
+            "flags");
+}
+
+static struct seff_flags_context *seff_flags_get_implicit_context
+(struct sieve_result *result)
+{
+	pool_t pool = sieve_result_pool(result);
+	struct seff_flags_context *ctx;
+	const char *flag;
+	struct ext_imap4flags_iter flit;
+	
+	ctx = p_new(pool, struct seff_flags_context, 1);
+	p_array_init(&ctx->keywords, pool, 2);
+	
+	T_BEGIN {
+		
+		/* Unpack */
+		ext_imap4flags_get_implicit_flags_init(&flit, result);
+		while ( (flag=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {		
+			if (flag != NULL && *flag != '\\') {
+				/* keyword */
+				const char *keyword = p_strdup(pool, flag);
+				array_append(&ctx->keywords, &keyword, 1);
+			} else {
+				/* system flag */
+				if (flag == NULL || strcasecmp(flag, "\\flagged") == 0)
+					ctx->flags |= MAIL_FLAGGED;
+				else if (strcasecmp(flag, "\\answered") == 0)
+					ctx->flags |= MAIL_ANSWERED;
+				else if (strcasecmp(flag, "\\deleted") == 0)
+					ctx->flags |= MAIL_DELETED;
+				else if (strcasecmp(flag, "\\seen") == 0)
+					ctx->flags |= MAIL_SEEN;
+				else if (strcasecmp(flag, "\\draft") == 0)
+					ctx->flags |= MAIL_DRAFT;
+			}
+		}
+
+	} T_END;
+	
+	return ctx;
+}
+
+static bool seff_flags_read_context
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address,
+	void **se_context)
+{
+	bool result = TRUE;
+	sieve_size_t op_address = *address;
+	const struct sieve_operand *operand;
+	pool_t pool = sieve_result_pool(renv->result);
+	struct seff_flags_context *ctx;
+	string_t *flags_item;
+	struct sieve_coded_stringlist *flag_list;
+	
+	ctx = p_new(pool, struct seff_flags_context, 1);
+	p_array_init(&ctx->keywords, pool, 2);
+	
+	t_push();
+
+	/* Check whether explicit flag list operand is present */
+	operand = sieve_operand_read(renv->sbin, address);
+
+    if ( operand == NULL ) {
+        sieve_runtime_trace_error(renv, "invalid operand");
+		t_pop();
+        return FALSE;
+    }
+
+    if ( sieve_operand_is_omitted(operand) ) {
+		/* Flag list is omitted, use current value of internal 
+		 * variable to construct side effect context.
+		 */
+		*se_context = seff_flags_get_implicit_context(renv->result);
+		t_pop();
+		return TRUE;
+	}
+	
+	/* Read flag-list */
+	if ( (flag_list=sieve_opr_stringlist_read_data
+		(renv, operand, op_address, address)) == NULL ) {
+		t_pop();
+		return FALSE;
+	}
+	
+	/* Unpack */
+	flags_item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(flag_list, &flags_item)) && 
+		flags_item != NULL ) {
+		const char *flag;
+		struct ext_imap4flags_iter flit;
+
+		ext_imap4flags_iter_init(&flit, flags_item);
+	
+		while ( (flag=ext_imap4flags_iter_get_flag(&flit)) != NULL ) {		
+			if (flag != NULL && *flag != '\\') {
+				/* keyword */
+				const char *keyword = p_strdup(pool, flag);
+
+				/* FIXME: should check for duplicates (cannot trust variables) */
+				array_append(&ctx->keywords, &keyword, 1);
+
+			} else {
+				/* system flag */
+				if (flag == NULL || strcasecmp(flag, "\\flagged") == 0)
+					ctx->flags |= MAIL_FLAGGED;
+				else if (strcasecmp(flag, "\\answered") == 0)
+					ctx->flags |= MAIL_ANSWERED;
+				else if (strcasecmp(flag, "\\deleted") == 0)
+					ctx->flags |= MAIL_DELETED;
+				else if (strcasecmp(flag, "\\seen") == 0)
+					ctx->flags |= MAIL_SEEN;
+				else if (strcasecmp(flag, "\\draft") == 0)
+					ctx->flags |= MAIL_DRAFT;
+			}
+		}
+	}
+	
+	*se_context = (void *) ctx;
+
+	t_pop();
+	
+	return result;
+}
+
+/* Result verification */
+
+static int seff_flags_merge
+(const struct sieve_runtime_env *renv ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	void **old_context, void *new_context)
+{
+	*old_context = new_context;
+	
+	return 1;
+}
+
+/* Result printing */
+
+static void seff_flags_print
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv,
+	void *se_context, bool *keep ATTR_UNUSED)
+{
+	struct sieve_result *result = rpenv->result;
+	struct seff_flags_context *ctx = (struct seff_flags_context *) se_context;
+	unsigned int i;
+	
+	if ( ctx == NULL )
+		ctx = seff_flags_get_implicit_context(result);
+	
+	if ( ctx->flags != 0 || array_count(&ctx->keywords) > 0 ) {
+		T_BEGIN {
+			string_t *flags = t_str_new(128);
+ 
+			if ( (ctx->flags & MAIL_FLAGGED) > 0 )
+				str_printfa(flags, " \\flagged");
+
+			if ( (ctx->flags & MAIL_ANSWERED) > 0 )
+				str_printfa(flags, " \\answered");
+		
+			if ( (ctx->flags & MAIL_DELETED) > 0 )
+				str_printfa(flags, " \\deleted");
+					
+			if ( (ctx->flags & MAIL_SEEN) > 0 )
+				str_printfa(flags, " \\seen");
+			
+			if ( (ctx->flags & MAIL_DRAFT) > 0 )
+				str_printfa(flags, " \\draft");
+
+			for ( i = 0; i < array_count(&ctx->keywords); i++ ) {
+				const char *const *keyword = array_idx(&ctx->keywords, i);
+				str_printfa(flags, " %s", str_sanitize(*keyword, 64));
+			}
+
+			sieve_result_seffect_printf(rpenv, "add IMAP flags:%s", str_c(flags));
+		} T_END;
+	}
+}
+
+/* Result execution */
+
+static bool seff_flags_pre_execute
+(const struct sieve_side_effect *seffect ATTR_UNUSED, 
+	const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, 
+	void **se_context, void *tr_context)
+{	
+	struct seff_flags_context *ctx = (struct seff_flags_context *) *se_context;
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+		
+	if ( ctx == NULL ) {
+		ctx = seff_flags_get_implicit_context(aenv->result);
+		*se_context = (void *) ctx;
+	}
+
+	/* Assign mail keywords for subsequent mailbox_copy() */
+	if ( array_count(&ctx->keywords) > 0 ) {
+		unsigned int i;
+
+		if ( !array_is_created(&trans->keywords) ) {
+			pool_t pool = sieve_result_pool(aenv->result); 
+			p_array_init(&trans->keywords, pool, 2);
+		}
+		
+		for ( i = 0; i < array_count(&ctx->keywords); i++ ) {		
+			const char *const *keyword = array_idx(&ctx->keywords, i);
+			const char *kw_error;
+
+			if ( trans->box != NULL ) {
+				if ( mailbox_keyword_is_valid(trans->box, *keyword, &kw_error) )
+					array_append(&trans->keywords, keyword, 1);
+				else {
+					char *error = "";
+					if ( kw_error != NULL && *kw_error != '\0' ) {
+						error = t_strdup_noconst(kw_error);
+						error[0] = i_tolower(error[0]);
+					}
+				
+					sieve_result_warning(aenv, 
+						"specified IMAP keyword '%s' is invalid (ignored): %s", 
+						str_sanitize(*keyword, 64), error);
+				}
+			}
+		}
+	}
+
+	/* Assign mail flags for subsequent mailbox_copy() */
+	trans->flags |= ctx->flags;
+	
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/imap4flags/tst-hasflag.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,300 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-imap4flags-common.h"
+
+/*
+ * Hasflag test
+ *
+ * Syntax: 
+ *   hasflag [MATCH-TYPE] [COMPARATOR] [<variable-list: string-list>]
+ *       <list-of-flags: string-list>
+ */
+
+static bool tst_hasflag_registered
+	(struct sieve_validator *validator,
+		struct sieve_command_registration *cmd_reg);
+static bool tst_hasflag_validate
+	(struct sieve_validator *validator,	struct sieve_command_context *ctx);
+static bool tst_hasflag_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+ 
+const struct sieve_command tst_hasflag = { 
+	"hasflag", 
+	SCT_TEST,
+	-1, /* We check positional arguments ourselves */
+	0, FALSE, FALSE, 
+	tst_hasflag_registered, 
+	NULL,
+	tst_hasflag_validate, 
+	tst_hasflag_generate, 
+	NULL 
+};
+
+/* 
+ * Hasflag operation 
+ */
+
+static bool tst_hasflag_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_hasflag_operation_execute
+	(const struct sieve_operation *op,	
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation hasflag_operation = { 
+	"HASFLAG",
+	&imap4flags_extension,
+	ext_imap4flags_OPERATION_HASFLAG,
+	tst_hasflag_operation_dump,
+	tst_hasflag_operation_execute
+};
+
+/* 
+ * Optional arguments 
+ */
+
+enum tst_hasflag_optional {	
+	OPT_VARIABLES = SIEVE_MATCH_OPT_LAST,
+};
+
+/* 
+ * Tag registration 
+ */
+
+static bool tst_hasflag_registered
+(struct sieve_validator *validator, 
+	struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+
+static bool tst_hasflag_validate
+(struct sieve_validator *validator,	struct sieve_command_context *tst)
+{
+	struct sieve_ast_argument *vars = tst->first_positional;
+	struct sieve_ast_argument *keys = sieve_ast_argument_next(vars);
+		
+	if ( !ext_imap4flags_command_validate(validator, tst) )
+		return FALSE;
+	
+	if ( keys == NULL ) {
+		keys = vars;
+		vars = NULL;
+	} else {
+		vars->arg_id_code = OPT_VARIABLES;
+	}
+	
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, keys, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tst_hasflag_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx)
+{
+	sieve_operation_emit_code(cgenv->sbin, &hasflag_operation);
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool tst_hasflag_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,	
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "HASFLAG");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	do {
+		if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+			return FALSE;
+
+		switch ( opt_code ) {
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_VARIABLES:
+			sieve_opr_stringlist_dump(denv, address, "variables");
+			break;
+		default:
+			return FALSE;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+			
+	return 
+		sieve_opr_stringlist_dump(denv, address, "list of flags");
+}
+
+/*
+ * Interpretation
+ */
+ 
+static int _flag_key_extract_init
+(void **context, string_t *raw_key)
+{
+	struct ext_imap4flags_iter *iter = t_new(struct ext_imap4flags_iter, 1);
+	
+	ext_imap4flags_iter_init(iter, raw_key);
+	
+	*context = iter; 
+	
+	return TRUE;
+}
+
+static int _flag_key_extract
+(void *context, const char **key, size_t *size)
+{
+	struct ext_imap4flags_iter *iter = (struct ext_imap4flags_iter *) context;
+	
+	if ( (*key = ext_imap4flags_iter_get_flag(iter)) != NULL ) {
+		*size = strlen(*key); 
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static const struct sieve_match_key_extractor _flag_extractor = {
+	_flag_key_extract_init,
+	_flag_key_extract
+};
+
+static int tst_hasflag_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *flag_list, *variables_list = NULL;
+	struct ext_imap4flags_iter iter;
+	const char *flag;
+	bool matched;
+	
+	/*
+	 * Read operands
+	 */
+
+	/* Handle match-type and comparator operands */
+	do {
+		if ( (ret=sieve_match_read_optional_operands
+			(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+			return ret;
+	
+		/* Check whether we neatly finished the list of optional operands*/
+		switch ( opt_code ) { 
+		case SIEVE_MATCH_OPT_END:
+			break;
+		case OPT_VARIABLES:
+			if ( (variables_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid variables-list operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+			break;
+		default:
+			sieve_runtime_trace_error(renv, "invalid optional operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+	} while ( opt_code != SIEVE_MATCH_OPT_END );
+		
+	/* Read flag list */
+	if ( (flag_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid flag-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "HASFLAG test");
+
+	matched = FALSE;
+	mctx = sieve_match_begin
+		(renv->interp, mtch, cmp, &_flag_extractor, flag_list); 	
+
+	matched = FALSE;
+
+	if ( variables_list != NULL ) {
+		string_t *var_item = NULL;
+		
+		/* Iterate through all requested variables to match */
+		while ( result && !matched && 
+			(result=sieve_coded_stringlist_next_item(variables_list, &var_item)) 
+			&& var_item != NULL ) {
+		
+			ext_imap4flags_get_flags_init(&iter, renv, var_item);	
+			while ( !matched && (flag=ext_imap4flags_iter_get_flag(&iter)) != NULL ) {
+				if ( (mret=sieve_match_value(mctx, flag, strlen(flag))) < 0 ) {
+					result = FALSE;
+					break;
+				}
+
+				matched = ( mret > 0 ); 	
+			}
+		}
+	} else {
+		ext_imap4flags_get_flags_init(&iter, renv, NULL);	
+		while ( !matched && (flag=ext_imap4flags_iter_get_flag(&iter)) != NULL ) {
+			if ( (mret=sieve_match_value(mctx, flag, strlen(flag))) < 0 ) {
+				result = FALSE;
+				break;
+			}
+
+			matched = ( mret > 0 ); 	
+		}
+	}
+
+	if ( (mret=sieve_match_end(mctx)) < 0 ) {
+		result = FALSE;
+	} else
+		matched = ( mret > 0 || matched ); 	
+	
+	/* Assign test result */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-global.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,310 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+/* 
+ * Commands 
+ */
+
+static bool cmd_global_validate
+  (struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_global_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd);
+
+const struct sieve_command cmd_global = {
+    "global",
+    SCT_COMMAND,
+    1, 0, FALSE, FALSE,
+    NULL, NULL,
+    cmd_global_validate,
+    cmd_global_generate,
+    NULL
+};
+
+/* DEPRICATED:
+ */
+		
+/* Import command 
+ * 
+ * Syntax
+ *   import
+ */	
+const struct sieve_command cmd_import = { 
+	"import", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_global_validate, 
+	cmd_global_generate, 
+	NULL
+};
+
+/* Export command 
+ * 
+ * Syntax
+ *   export
+ */	
+const struct sieve_command cmd_export = { 
+	"export", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL, 
+	cmd_global_validate, 
+	cmd_global_generate, 
+	NULL
+};
+
+/*
+ * Operations
+ */
+
+static bool opc_global_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int opc_global_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Global operation */
+
+const struct sieve_operation global_operation = { 
+	"global",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_GLOBAL,
+	opc_global_dump, 
+	opc_global_execute
+};
+
+/*
+ * Validation
+ */
+
+static bool cmd_global_validate
+  (struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct sieve_command_context *prev_context = 
+		sieve_command_prev_context(cmd);
+
+	/* Check valid command placement */
+	if ( !sieve_command_is_toplevel(cmd) ||
+		( !sieve_command_is_first(cmd) && prev_context != NULL &&
+			prev_context->command != &cmd_require ) ) {
+
+		if ( cmd->command == &cmd_global ) {
+			if ( prev_context->command != &cmd_global ) {
+				sieve_command_validate_error(validator, cmd, 
+					"a global command can only be placed at top level "
+					"at the beginning of the file after any require or other global commands");
+				return FALSE;
+			}
+		} else {
+			if ( prev_context->command != &cmd_import && prev_context->command != &cmd_export ) {
+                sieve_command_validate_error(validator, cmd,
+                    "the DEPRICATED %s command can only be placed at top level "
+                    "at the beginning of the file after any require or import/export commands",
+					cmd->command->identifier);
+                return FALSE;
+            }
+		}
+	}
+
+	/* Check for use of variables extension */	
+	if ( !sieve_ext_variables_is_active(validator) ) {
+		sieve_command_validate_error(validator, cmd, 
+			"%s command requires that variables extension is active",
+			cmd->command->identifier);
+		return FALSE;
+	}
+		
+	/* Register global variable */
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		const char *identifier = sieve_ast_argument_strc(arg);
+		struct sieve_variable *var;
+		
+		if ( (var=ext_include_variable_import_global
+			(validator, cmd, identifier)) == NULL )
+			return FALSE;
+			
+		arg->context = (void *) var;
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+		
+		while ( stritem != NULL ) {
+			const char *identifier = sieve_ast_argument_strc(stritem);
+			struct sieve_variable *var;
+			
+			if ( (var=ext_include_variable_import_global
+				(validator, cmd, identifier)) == NULL )
+				return FALSE;
+
+			stritem->context = (void *) var;
+	
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		/* Something else */
+		sieve_argument_validate_error(validator, arg, 
+			"the %s command accepts a single string or string list argument, "
+			"but %s was found", cmd->command->identifier,
+			sieve_ast_argument_name(arg));
+		return FALSE;
+	}
+	
+	/* Join global commands with predecessors if possible */
+	if ( prev_context->command == cmd->command ) {
+		/* Join this command's string list with the previous one */
+		prev_context->first_positional = sieve_ast_stringlist_join
+			(prev_context->first_positional, cmd->first_positional);
+		
+		if ( prev_context->first_positional == NULL ) {
+			/* Not going to happen unless MAXINT stringlist items are specified */
+			sieve_command_validate_error(validator, cmd, 
+				"compiler reached AST limit (script too complex)");
+			return FALSE;
+		}
+
+		/* Detach this command node */
+		sieve_ast_node_detach(cmd->ast_node);
+	}
+		
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_global_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd) 
+{
+	struct sieve_ast_argument *arg = cmd->first_positional;
+
+	sieve_operation_emit_code(cgenv->sbin, &global_operation);
+ 	 			
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		struct sieve_variable *var = (struct sieve_variable *) arg->context;
+		
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, 1);
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, var->index);
+		
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem = sieve_ast_strlist_first(arg);
+		
+		(void)sieve_binary_emit_unsigned(cgenv->sbin, sieve_ast_strlist_count(arg));
+						
+		while ( stritem != NULL ) {
+			struct sieve_variable *var = (struct sieve_variable *) stritem->context;
+			
+			(void)sieve_binary_emit_unsigned(cgenv->sbin, var->index);
+			
+			stritem = sieve_ast_strlist_next(stritem);
+		}
+	} else {
+		i_unreached();
+	}
+ 	 		
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool opc_global_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int count, i, var_count;
+	struct sieve_variable_scope *scope;
+	struct sieve_variable * const *vars;
+	
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &count) )
+		return FALSE;
+
+	sieve_code_dumpf(denv, "GLOBAL (count: %u):", count);
+
+	scope = ext_include_binary_get_global_scope(denv->sbin);
+	vars = sieve_variable_scope_get_variables(scope, &var_count);
+
+	sieve_code_descend(denv);
+
+	for ( i = 0; i < count; i++ ) {
+		unsigned int index;
+		
+		sieve_code_mark(denv);
+		if ( !sieve_binary_read_unsigned(denv->sbin, address, &index) ||
+			index >= var_count )
+			return FALSE;
+			
+		sieve_code_dumpf(denv, "VAR[%d]: '%s'", index, vars[index]->identifier); 
+	}
+	 
+	return TRUE;
+}
+
+/* 
+ * Execution
+ */
+ 
+static int opc_global_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct sieve_variable_scope *scope;	
+	struct sieve_variable_storage *storage;
+	struct sieve_variable * const *vars;
+	unsigned int var_count, count, i;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &count) ) {
+		sieve_runtime_trace_error(renv, "invalid count operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	scope = ext_include_binary_get_global_scope(renv->sbin);
+	vars = sieve_variable_scope_get_variables(scope, &var_count);
+	storage = ext_include_interpreter_get_global_variables(renv->interp);
+
+	for ( i = 0; i < count; i++ ) {
+		unsigned int index;
+		
+		if ( !sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+			sieve_runtime_trace_error(renv, "invalid global variable operand");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		if ( index >= var_count ) {
+			sieve_runtime_trace_error(renv, "invalid global variable index (%u > %u)",
+				index, var_count);
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		/* Make sure variable is initialized (export) */
+		(void)sieve_variable_get_modifiable(storage, index, NULL); 
+	}
+
+	return SIEVE_EXEC_OK;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-include.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,351 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+
+/* 
+ * Include command 
+ *	
+ * Syntax: 
+ *   include [LOCATION] <value: string>
+ *
+ * [LOCATION]:      
+ *   ":personal" / ":global"
+ */
+
+static bool cmd_include_registered
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_include_pre_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+		struct sieve_command_context *cmd);
+static bool cmd_include_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_include_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_include = { 
+	"include",
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE, 
+	cmd_include_registered,
+	cmd_include_pre_validate,  
+	cmd_include_validate, 
+	cmd_include_generate, 
+	NULL 
+};
+
+/* 
+ * Include operation 
+ */
+
+static bool opc_include_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int opc_include_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation include_operation = { 
+	"include",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_INCLUDE,
+	opc_include_dump, 
+	opc_include_execute
+};
+
+/* 
+ * Context structures 
+ */
+
+struct cmd_include_context_data {
+	enum ext_include_script_location location;
+	bool location_assigned;
+	
+	bool include_once;
+	
+	struct sieve_script *script;
+};   
+
+/* 
+ * Tagged arguments
+ */
+
+static bool cmd_include_validate_location_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument include_personal_tag = { 
+	"personal", 
+	NULL, NULL,
+	cmd_include_validate_location_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument include_global_tag = { 
+	"global", 
+	NULL, NULL,
+	cmd_include_validate_location_tag, 
+	NULL, NULL 
+};
+
+static bool cmd_include_validate_once_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+static const struct sieve_argument include_once_tag = { 
+	"once", 
+	NULL, NULL,
+	cmd_include_validate_once_tag, 
+	NULL, NULL 
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool cmd_include_validate_location_tag
+(struct sieve_validator *validator,	struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{    
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+	
+	if ( ctx_data->location_assigned) {
+		sieve_argument_validate_error(validator, *arg, 
+			"include: cannot use location tags ':personal' and ':global' "
+			"multiple times");
+		return FALSE;
+	}
+	
+	if ( (*arg)->argument == &include_personal_tag )
+		ctx_data->location = EXT_INCLUDE_LOCATION_PERSONAL;
+	else if ( (*arg)->argument == &include_global_tag )
+		ctx_data->location = EXT_INCLUDE_LOCATION_GLOBAL;
+	else
+		return FALSE;
+	
+	ctx_data->location_assigned = TRUE;
+
+	/* Delete this tag (for now) */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+static bool cmd_include_validate_once_tag
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{    
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+
+	ctx_data->include_once = TRUE;
+	
+	/* Delete this tag (for now) */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	return TRUE;
+}
+
+/* 
+ * Command registration 
+ */
+
+static bool cmd_include_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(validator, cmd_reg, &include_personal_tag, 0); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &include_global_tag, 0); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &include_once_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+
+static bool cmd_include_pre_validate
+	(struct sieve_validator *validator ATTR_UNUSED, 
+		struct sieve_command_context *cmd)
+{
+	struct cmd_include_context_data *ctx_data;
+
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), struct cmd_include_context_data, 1);
+	ctx_data->location = EXT_INCLUDE_LOCATION_PERSONAL;
+	cmd->data = ctx_data;
+	
+	return TRUE;
+}
+
+static bool cmd_include_validate(struct sieve_validator *validator, 
+	struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+	struct sieve_script *script;
+	const char *script_dir, *script_name;
+	
+	/* Check argument */
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "value", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(arg) ) {
+		sieve_argument_validate_error(validator, arg, 
+			"this Sieve implementation currently only supports "
+			"a literal string argument for the include command");
+		return FALSE;
+	}
+
+	/* Find the script */
+
+	script_name = sieve_ast_argument_strc(arg);
+
+	if ( strchr(script_name, '/') != NULL ) {
+ 		sieve_argument_validate_error(validator, arg,
+			"include: '/' not allowed in script name (%s)",
+			str_sanitize(script_name, 80));
+		return FALSE;
+	}
+		
+	script_dir = ext_include_get_script_directory
+		(ctx_data->location, script_name);
+	if ( script_dir == NULL ) {
+		sieve_argument_validate_error(validator, arg,
+			"include: specified location for included script '%s' is unavailable "
+			"(system logs should provide more information)",
+			str_sanitize(script_name, 80));
+		return FALSE;
+	}
+	
+	/* Create script object */
+	script = sieve_script_create_in_directory(script_dir, script_name, 
+		sieve_validator_error_handler(validator), NULL);
+	if ( script == NULL ) 
+		return FALSE;	
+
+	ext_include_ast_link_included_script(cmd->ast_node->ast, script);		
+	ctx_data->script = script;
+		
+	arg = sieve_ast_arguments_detach(arg, 1);
+	
+	return TRUE;
+}
+
+/*
+ * Code Generation
+ */
+ 
+static bool cmd_include_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd) 
+{
+	struct cmd_include_context_data *ctx_data = 
+		(struct cmd_include_context_data *) cmd->data;
+	const struct ext_include_script_info *included;
+	unsigned int flags = ctx_data->include_once;
+
+	/* Compile (if necessary) and include the script into the binary.
+	 * This yields the id of the binary block containing the compiled byte code.  
+	 */
+	if ( !ext_include_generate_include
+		(cgenv, cmd, ctx_data->location, ctx_data->script, &included,
+			ctx_data->include_once) )
+ 		return FALSE;
+ 		
+ 	(void)sieve_operation_emit_code(cgenv->sbin, &include_operation);
+	(void)sieve_binary_emit_unsigned(cgenv->sbin, included->id); 
+	(void)sieve_binary_emit_byte(cgenv->sbin, flags); 
+ 	 		
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool opc_include_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct ext_include_script_info *included;
+	struct ext_include_binary_context *binctx;
+	unsigned int include_id, flags;
+
+	sieve_code_dumpf(denv, "INCLUDE:");
+	
+	sieve_code_mark(denv);
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &include_id) )
+		return FALSE;
+
+	if ( !sieve_binary_read_byte(denv->sbin, address, &flags) )
+		return FALSE;
+
+	binctx = ext_include_binary_get_context(denv->sbin);
+	included = ext_include_binary_script_get_included(binctx, include_id);
+	if ( included == NULL )
+		return FALSE;
+		
+	sieve_code_descend(denv);
+	sieve_code_dumpf(denv, "script: %s %s[ID: %d, BLOCK: %d]", 
+		sieve_script_filename(included->script), (flags & 0x01 ? "(once) " : ""),
+		include_id, included->block_id);
+
+	return TRUE;
+}
+
+/* 
+ * Execution
+ */
+ 
+static int opc_include_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	unsigned int include_id, flags;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &include_id) ) {
+		sieve_runtime_trace_error(renv, "invalid include-id operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &flags) ) {
+		sieve_runtime_trace_error(renv, "invalid flags operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	return ext_include_execute_include(renv, include_id, flags & 0x01);
+}
+
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/cmd-return.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,78 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h" 
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-include-common.h"
+
+/* 
+ * Return command 
+ * 
+ * Syntax
+ *   return
+ */
+
+static bool cmd_return_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx ATTR_UNUSED);
+	
+const struct sieve_command cmd_return = { 
+	"return", 
+	SCT_COMMAND, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, 
+	cmd_return_generate, 
+	NULL
+};
+
+/* 
+ * Return operation 
+ */
+
+static int opc_return_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation return_operation = { 
+	"return",
+	&include_extension,
+	EXT_INCLUDE_OPERATION_RETURN,
+	NULL, 
+	opc_return_execute 
+};
+
+/*
+ * Code generation
+ */
+
+static bool cmd_return_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx ATTR_UNUSED) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &return_operation);
+
+	return TRUE;
+}
+
+/*
+ * Execution
+ */
+
+static int opc_return_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, 
+	sieve_size_t *address ATTR_UNUSED)
+{	
+	sieve_runtime_trace(renv, "RETURN command");
+
+	ext_include_execute_return(renv);
+	return SIEVE_EXEC_OK;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,425 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-limits.h"
+#include "ext-include-variables.h"
+#include "ext-include-binary.h"
+
+/*
+ * Forward declarations
+ */
+ 
+static bool ext_include_binary_save(struct sieve_binary *sbin);
+static bool ext_include_binary_open(struct sieve_binary *sbin);
+static bool ext_include_binary_up_to_date(struct sieve_binary *sbin);
+static void ext_include_binary_free(struct sieve_binary *sbin);
+
+/* 
+ * Binary include extension
+ */
+ 
+const struct sieve_binary_extension include_binary_ext = {
+	&include_extension,
+	ext_include_binary_save,
+	ext_include_binary_open,
+	ext_include_binary_free,
+	ext_include_binary_up_to_date
+};
+
+/*
+ * Binary context management
+ */
+ 
+struct ext_include_binary_context {
+	struct sieve_binary *binary;
+	unsigned int dependency_block;
+	
+	struct hash_table *included_scripts;
+	ARRAY_DEFINE(include_index, struct ext_include_script_info *);
+
+	struct sieve_variable_scope *global_vars;
+};
+
+ 
+static struct ext_include_binary_context *ext_include_binary_create_context
+(struct sieve_binary *sbin)
+{
+	pool_t pool = sieve_binary_pool(sbin);
+	
+	struct ext_include_binary_context *ctx = 
+		p_new(pool, struct ext_include_binary_context, 1);
+	
+	ctx->binary = sbin;			
+	ctx->included_scripts = hash_table_create(default_pool, pool, 0, 
+		(hash_callback_t *) sieve_script_hash, 
+		(hash_cmp_callback_t *) sieve_script_cmp);
+	p_array_init(&ctx->include_index, pool, 128);
+
+	sieve_binary_extension_set(sbin, &include_binary_ext, ctx);
+
+	return ctx;
+}
+
+struct ext_include_binary_context *ext_include_binary_get_context
+(struct sieve_binary *sbin)
+{	
+	struct ext_include_binary_context *ctx = (struct ext_include_binary_context *)
+		sieve_binary_extension_get_context(sbin, &include_extension);
+	
+	if ( ctx == NULL )
+		ctx = ext_include_binary_create_context(sbin);
+	
+	return ctx;
+}
+ 
+struct ext_include_binary_context *ext_include_binary_init
+(struct sieve_binary *sbin, struct sieve_ast *ast)
+{
+	struct ext_include_ast_context *ast_ctx =
+		ext_include_get_ast_context(ast);
+	struct ext_include_binary_context *ctx;
+	
+	/* Get/create our context from the binary we are working on */
+	ctx = ext_include_binary_get_context(sbin);
+	
+	/* Create dependency block */
+	if ( ctx->dependency_block == 0 )
+		ctx->dependency_block = 
+			sieve_binary_extension_create_block(sbin, &include_extension);
+
+	if ( ctx->global_vars == NULL ) {
+		ctx->global_vars = ast_ctx->global_vars;
+		sieve_variable_scope_ref(ctx->global_vars);
+	}
+			
+	return ctx;
+}
+
+/*
+ * Script inclusion
+ */
+
+const struct ext_include_script_info *ext_include_binary_script_include
+(struct ext_include_binary_context *binctx, struct sieve_script *script,
+	enum ext_include_script_location location, unsigned int block_id)
+{
+	pool_t pool = sieve_binary_pool(binctx->binary);
+	struct ext_include_script_info *incscript;
+
+	incscript = p_new(pool, struct ext_include_script_info, 1);
+	incscript->id = array_count(&binctx->include_index)+1;
+	incscript->script = script;
+	incscript->location = location;
+	incscript->block_id = block_id;
+	
+	/* Unreferenced on binary_free */
+	sieve_script_ref(script);
+	
+	hash_table_insert(binctx->included_scripts, (void *) script, (void *) incscript);
+	array_append(&binctx->include_index, &incscript, 1);
+
+	return incscript;
+}
+
+bool ext_include_binary_script_is_included
+(struct ext_include_binary_context *binctx, struct sieve_script *script,
+	const struct ext_include_script_info **script_info_r)
+{
+	struct ext_include_script_info *incscript = (struct ext_include_script_info *)
+		hash_table_lookup(binctx->included_scripts, script);
+		
+	if ( incscript == NULL )
+		return FALSE;
+				
+	*script_info_r = incscript;
+	return TRUE;
+}
+
+const struct ext_include_script_info *ext_include_binary_script_get_included
+(struct ext_include_binary_context *binctx, unsigned int include_id)
+{		
+	if ( include_id > 0 && (include_id - 1) < array_count(&binctx->include_index) ) {
+		struct ext_include_script_info *const *sinfo =
+			array_idx(&binctx->include_index, include_id - 1);
+
+		return *sinfo;
+	}
+
+	return NULL;
+}
+
+const struct ext_include_script_info *ext_include_binary_script_get
+(struct ext_include_binary_context *binctx, struct sieve_script *script)
+{
+	return (struct ext_include_script_info *)
+		hash_table_lookup(binctx->included_scripts, script);
+}
+
+unsigned int ext_include_binary_script_get_count
+(struct ext_include_binary_context *binctx)
+{
+	return array_count(&binctx->include_index);
+}
+
+/*
+ * Variables 
+ */
+
+struct sieve_variable_scope *ext_include_binary_get_global_scope
+(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+
+	return binctx->global_vars;
+}
+
+/*
+ * Binary extension
+ */
+
+static bool ext_include_binary_save(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct ext_include_script_info *const *scripts;
+	unsigned int script_count, i;
+	unsigned int prvblk;
+	bool result = TRUE;
+	
+	sieve_binary_block_clear(sbin, binctx->dependency_block);
+	if ( !sieve_binary_block_set_active(sbin, binctx->dependency_block, &prvblk) )	
+		return FALSE;
+
+	scripts = array_get(&binctx->include_index, &script_count);
+
+	sieve_binary_emit_unsigned(sbin, script_count);
+
+	for ( i = 0; i < script_count; i++ ) {
+		struct ext_include_script_info *incscript = scripts[i];
+
+		sieve_binary_emit_unsigned(sbin, incscript->block_id);
+		sieve_binary_emit_byte(sbin, incscript->location);
+		sieve_binary_emit_cstring(sbin, sieve_script_name(incscript->script));
+	}
+
+	result = ext_include_variables_save(sbin, binctx->global_vars);
+	
+	(void) sieve_binary_block_set_active(sbin, prvblk, NULL);
+
+	return result;
+}
+
+static bool ext_include_binary_open(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx; 
+	unsigned int block, prvblk, depcount, i;
+	sieve_size_t offset;
+	
+	block = sieve_binary_extension_get_block(sbin, &include_extension);
+	
+	if ( !sieve_binary_block_set_active(sbin, block, &prvblk) )
+		return FALSE; 
+		
+	offset = 0;	
+		
+	if ( !sieve_binary_read_unsigned(sbin, &offset, &depcount) ) {
+		sieve_sys_error("include: failed to read include count "
+			"for dependency block %d of binary %s", block, sieve_binary_path(sbin)); 
+		return FALSE;
+	}
+	
+	binctx = ext_include_binary_get_context(sbin);
+
+	/* Check include limit */	
+	if ( depcount > EXT_INCLUDE_MAX_INCLUDES ) {
+		sieve_sys_error("include: binary %s includes too many scripts (%u > %u)",
+			sieve_binary_path(sbin), depcount, EXT_INCLUDE_MAX_INCLUDES); 
+		return FALSE;
+	}
+	
+	/* Read dependencies */
+	for ( i = 0; i < depcount; i++ ) {
+		unsigned int block_id;
+		enum ext_include_script_location location;
+		string_t *script_name;
+		const char *script_dir;
+		struct sieve_script *script;
+		
+		if ( 
+			!sieve_binary_read_unsigned(sbin, &offset, &block_id) ||
+			!sieve_binary_read_byte(sbin, &offset, &location) ||
+			!sieve_binary_read_string(sbin, &offset, &script_name) ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: failed to read included script "
+				"from dependency block %d of binary %s", block, sieve_binary_path(sbin)); 
+			return FALSE;
+		}
+		
+		if ( location >= EXT_INCLUDE_LOCATION_INVALID ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: dependency block %d of binary %s "
+				"reports invalid script location (id %d)", 
+				block, sieve_binary_path(sbin), location); 
+			return FALSE;
+		}		
+		
+		/* Can we find/open the script dependency ? */
+		script_dir = ext_include_get_script_directory(location, str_c(script_name));		
+		if ( script_dir == NULL || 
+			!(script=sieve_script_create_in_directory
+				(script_dir, str_c(script_name), NULL, NULL)) ) {
+			/* No, recompile */
+			return FALSE;
+		}
+		
+		(void)ext_include_binary_script_include(binctx, script, location, block_id);
+				
+		sieve_script_unref(&script);
+	}
+
+	if ( !ext_include_variables_load(sbin, &offset, block, &binctx->global_vars) )
+		return FALSE;
+	
+	/* Restore previously active block */
+	(void)sieve_binary_block_set_active(sbin, prvblk, NULL);
+
+	return TRUE;	
+}
+
+static bool ext_include_binary_up_to_date(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+		
+	/* Release references to all included script objects */
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript = (struct ext_include_script_info *) value;
+		
+		/* Is the binary newer than this dependency? */
+		if ( !sieve_binary_script_older(sbin, incscript->script) ) {
+			/* No, recompile */
+			return FALSE;
+		}
+	}
+	hash_table_iterate_deinit(&hctx);
+
+	return TRUE;
+}
+
+static void ext_include_binary_free(struct sieve_binary *sbin)
+{
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+		
+	/* Release references to all included script objects */
+	hctx = hash_table_iterate_init(binctx->included_scripts);
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript = (struct ext_include_script_info *) value;
+		
+		sieve_script_unref(&incscript->script);
+	}
+	hash_table_iterate_deinit(&hctx);
+
+	hash_table_destroy(&binctx->included_scripts);
+
+	if ( binctx->global_vars != NULL ) 
+		sieve_variable_scope_unref(&binctx->global_vars);
+}
+
+/*
+ * Dumping the binary 
+ */
+
+inline static const char *_script_location
+(enum ext_include_script_location loc)
+{
+	switch ( loc ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		return "personal";
+	case EXT_INCLUDE_LOCATION_GLOBAL:
+		return "global";
+	default:
+		break;
+	}
+	
+	return "<<INVALID LOCATION>>";
+}
+
+bool ext_include_binary_dump(struct sieve_dumptime_env *denv)
+{
+	struct sieve_binary *sbin = denv->sbin;
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	struct hash_iterate_context *hctx;
+	void *key, *value;
+	unsigned int prvblk = 0;
+
+	if ( !ext_include_variables_dump(denv, binctx->global_vars) )
+		return FALSE;
+
+	hctx = hash_table_iterate_init(binctx->included_scripts);		
+	while ( hash_table_iterate(hctx, &key, &value) ) {
+		struct ext_include_script_info *incscript = (struct ext_include_script_info *) value;
+
+		sieve_binary_dump_sectionf(denv, "Included %s script '%s' (block: %d)", 
+			_script_location(incscript->location), 
+			sieve_script_name(incscript->script), incscript->block_id);
+			
+		if ( prvblk == 0 ) {
+			if ( !sieve_binary_block_set_active(sbin, incscript->block_id, &prvblk) )	
+				return FALSE;
+		} else {
+			if ( !sieve_binary_block_set_active(sbin, incscript->block_id, NULL) )	
+				return FALSE;
+		}
+				
+		denv->cdumper = sieve_code_dumper_create(denv);
+
+		if ( denv->cdumper == NULL )
+			return FALSE;
+
+		sieve_code_dumper_run(denv->cdumper);
+		sieve_code_dumper_free(&(denv->cdumper));
+	}
+	
+	if ( !sieve_binary_block_set_active(sbin, prvblk, NULL) ) 
+		return FALSE;
+	
+	hash_table_iterate_deinit(&hctx);
+	
+	return TRUE;
+}
+
+bool ext_include_code_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address ATTR_UNUSED)
+{
+	struct sieve_binary *sbin = denv->sbin;
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(sbin);
+	
+	sieve_ext_variables_dump_set_scope(denv, &include_extension, binctx->global_vars);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-binary.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,63 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_BINARY_H
+#define __EXT_INCLUDE_BINARY_H
+
+#include "sieve-common.h"
+
+/*
+ * Binary context management
+ */
+
+struct ext_include_binary_context;
+
+struct ext_include_binary_context *ext_include_binary_init
+	(struct sieve_binary *sbin, struct sieve_ast *ast);
+struct ext_include_binary_context *ext_include_binary_get_context
+	(struct sieve_binary *sbin);
+
+/*
+ * Variables
+ */
+
+struct sieve_variable_scope *ext_include_binary_get_global_scope
+    (struct sieve_binary *sbin);
+
+/*
+ * Including scripts
+ */
+
+struct ext_include_script_info {
+    unsigned int id;
+
+    struct sieve_script *script;
+    enum ext_include_script_location location;
+
+    unsigned int block_id;
+};
+
+const struct ext_include_script_info *ext_include_binary_script_include
+	(struct ext_include_binary_context *binctx, struct sieve_script *script,
+		enum ext_include_script_location location, unsigned int block_id);
+bool ext_include_binary_script_is_included
+	(struct ext_include_binary_context *binctx, struct sieve_script *script,
+		const struct ext_include_script_info **script_info_r);
+
+const struct ext_include_script_info *ext_include_binary_script_get_included
+	(struct ext_include_binary_context *binctx, unsigned int include_id);
+const struct ext_include_script_info *ext_include_binary_script_get
+	(struct ext_include_binary_context *binctx, struct sieve_script *script);
+unsigned int ext_include_binary_script_get_count
+	(struct ext_include_binary_context *binctx);
+
+/*
+ * Dumping the binary
+ */
+
+bool ext_include_binary_dump(struct sieve_dumptime_env *denv);
+bool ext_include_code_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address ATTR_UNUSED);
+		
+#endif /* __EXT_INCLUDE_BINARY_H */
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,102 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension include
+ * -----------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-ietf-sieve-include-01
+ * Implementation: almost full; global namespace is missing. 
+ * Status: experimental
+ * 
+ */
+ 
+/* FIXME: Current include implementation does not allow for parts of the script
+ * to be located in external binaries; all included scripts are recompiled and
+ * the resulting byte code is imported into the main binary in separate blocks.
+ */
+ 
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+
+/* 
+ * Operations 
+ */
+
+static const struct sieve_operation *ext_include_operations[] = { 
+	&include_operation, 
+	&return_operation,
+	&global_operation
+};
+
+/* 
+ * Extension
+ */
+ 
+/* Forward declaration */
+
+static bool ext_include_validator_load(struct sieve_validator *validator);
+static bool ext_include_generator_load(const struct sieve_codegen_env *cgenv);
+static bool ext_include_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Extension objects */
+
+static int ext_my_id = -1;
+
+const struct sieve_extension include_extension = { 
+	"include", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_include_validator_load, 
+	ext_include_generator_load,
+	ext_include_interpreter_load,
+	NULL,
+	ext_include_binary_dump,
+	ext_include_code_dump,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_include_operations),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/* Extension hooks */
+
+static bool ext_include_validator_load(struct sieve_validator *validator)
+{
+	/* Register new commands */
+	sieve_validator_register_command(validator, &cmd_include);
+	sieve_validator_register_command(validator, &cmd_return);
+	sieve_validator_register_command(validator, &cmd_global);
+
+	/* DEPRICATED */
+	sieve_validator_register_command(validator, &cmd_import);
+	sieve_validator_register_command(validator, &cmd_export);
+
+	return TRUE;
+}	
+
+static bool ext_include_generator_load(const struct sieve_codegen_env *cgenv)
+{
+	ext_include_register_generator_context(cgenv);
+
+	return TRUE;
+}
+
+static bool ext_include_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{
+	ext_include_interpreter_context_init(renv->interp);
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,698 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "str-sanitize.h"
+#include "home-expand.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-include-common.h"
+#include "ext-include-limits.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+#include <stdlib.h>
+
+/*
+ * Forward declarations
+ */
+
+/* Generator context */
+
+struct ext_include_generator_context {
+	unsigned int nesting_level;
+	struct sieve_script *script;
+	struct ext_include_generator_context *parent;
+};
+
+static inline struct ext_include_generator_context *
+	ext_include_get_generator_context
+	(struct sieve_generator *gentr);
+
+/* Interpreter context */
+
+struct ext_include_interpreter_global {
+	ARRAY_DEFINE(included_scripts, struct sieve_script *);
+
+	struct sieve_variable_storage *variables;
+};
+
+struct ext_include_interpreter_context {
+	struct ext_include_interpreter_context *parent;
+	struct ext_include_interpreter_global *global;
+
+	struct sieve_interpreter *interp;
+	pool_t pool;
+
+	unsigned int nesting_level;
+
+	struct sieve_script *script;
+	const struct ext_include_script_info *script_info;
+	
+	const struct ext_include_script_info *include;
+	bool returned;
+};
+
+/* 
+ * Script access 
+ */
+
+const char *ext_include_get_script_directory
+(enum ext_include_script_location location, const char *script_name)
+{
+	const char *sieve_dir;
+
+	switch ( location ) {
+	case EXT_INCLUDE_LOCATION_PERSONAL:
+		sieve_dir = getenv("SIEVE_DIR");
+
+		if (sieve_dir == NULL) {
+			const char *home = getenv("HOME");
+			
+			sieve_dir = home_expand_tilde("~/sieve", home);	
+		}
+		break;
+   	case EXT_INCLUDE_LOCATION_GLOBAL:
+		sieve_dir = getenv("SIEVE_GLOBAL_DIR");
+		break;
+	default:
+		return NULL;
+	}
+
+	if (sieve_dir == NULL) {
+		sieve_sys_error("include: sieve_dir and home not set "	
+			"(wanted script %s)", str_sanitize(script_name, 80));
+		return NULL;
+	}
+
+	return sieve_dir;
+}
+
+/*
+ * AST context management
+ */
+
+static void ext_include_ast_free
+(struct sieve_ast *ast ATTR_UNUSED, void *context)
+{
+	struct ext_include_ast_context *actx = 
+		(struct ext_include_ast_context *) context;
+	struct sieve_script **scripts;
+	unsigned int count, i;
+
+	/* Unreference included scripts */
+	scripts = array_get_modifiable(&actx->included_scripts, &count);
+	for ( i = 0; i < count; i++ ) {
+		sieve_script_unref(&scripts[i]);
+	}	
+
+	/* Unreference variable scopes */
+	if ( actx->global_vars != NULL )
+		sieve_variable_scope_unref(&actx->global_vars);
+}
+
+static const struct sieve_ast_extension include_ast_extension = {
+	&include_extension,
+	ext_include_ast_free
+};
+
+struct ext_include_ast_context *ext_include_create_ast_context
+(struct sieve_ast *ast, struct sieve_ast *parent)
+{
+	struct ext_include_ast_context *actx;
+
+	pool_t pool = sieve_ast_pool(ast);
+	actx = p_new(pool, struct ext_include_ast_context, 1);
+	p_array_init(&actx->included_scripts, pool, 32);
+
+	if ( parent != NULL ) {
+		struct ext_include_ast_context *parent_ctx =
+			(struct ext_include_ast_context *)
+				sieve_ast_extension_get_context(parent, &include_extension);
+		actx->global_vars = parent_ctx->global_vars;
+
+		i_assert( actx->global_vars != NULL );
+
+		sieve_variable_scope_ref(actx->global_vars);
+	} else
+		actx->global_vars = sieve_variable_scope_create(&include_extension);			
+
+	sieve_ast_extension_register(ast, &include_ast_extension, (void *) actx);
+
+	return actx;
+}
+
+struct ext_include_ast_context *ext_include_get_ast_context
+(struct sieve_ast *ast)
+{
+	struct ext_include_ast_context *actx = (struct ext_include_ast_context *)
+		sieve_ast_extension_get_context(ast, &include_extension);
+
+	if ( actx != NULL ) return actx;
+
+	return ext_include_create_ast_context(ast, NULL);
+}
+
+void ext_include_ast_link_included_script
+(struct sieve_ast *ast, struct sieve_script *script) 
+{
+	struct ext_include_ast_context *actx = ext_include_get_ast_context(ast);
+
+	array_append(&actx->included_scripts, &script, 1);
+}
+
+/* 
+ * Generator context management 
+ */
+ 
+static struct ext_include_generator_context *
+	ext_include_create_generator_context
+(struct sieve_generator *gentr, struct ext_include_generator_context *parent, 
+	struct sieve_script *script)
+{	
+	struct ext_include_generator_context *ctx;
+
+	pool_t pool = sieve_generator_pool(gentr);
+	ctx = p_new(pool, struct ext_include_generator_context, 1);
+	ctx->parent = parent;
+	ctx->script = script;
+	if ( parent == NULL ) {
+		ctx->nesting_level = 0;
+	} else {
+		ctx->nesting_level = parent->nesting_level + 1;
+	}
+	
+	return ctx;
+}
+
+static inline struct ext_include_generator_context *
+	ext_include_get_generator_context
+(struct sieve_generator *gentr)
+{
+	return (struct ext_include_generator_context *)
+		sieve_generator_extension_get_context(gentr, &include_extension);
+}
+
+static inline void ext_include_initialize_generator_context
+(struct sieve_generator *gentr, struct ext_include_generator_context *parent, 
+	struct sieve_script *script)
+{
+	sieve_generator_extension_set_context(gentr, &include_extension,
+		ext_include_create_generator_context(gentr, parent, script));
+}
+
+void ext_include_register_generator_context
+(const struct sieve_codegen_env *cgenv)
+{
+	struct ext_include_generator_context *ctx = 
+		ext_include_get_generator_context(cgenv->gentr);
+	
+	/* Initialize generator context if necessary */
+	if ( ctx == NULL ) {
+		ctx = ext_include_create_generator_context(
+			cgenv->gentr, NULL, cgenv->script);
+		
+		sieve_generator_extension_set_context
+			(cgenv->gentr, &include_extension, (void *) ctx);		
+	}
+
+	/* Initialize ast context if necessary */
+	(void)ext_include_get_ast_context(cgenv->ast);
+	(void)ext_include_binary_init(cgenv->sbin, cgenv->ast);
+}
+
+/*
+ * Runtime initialization
+ */
+
+static void ext_include_runtime_init
+    (const struct sieve_runtime_env *renv, void *context)
+{
+	struct ext_include_interpreter_context *ctx = 
+		(struct ext_include_interpreter_context *) context;
+
+	if ( ctx->parent == NULL ) {
+		ctx->global = p_new(ctx->pool, struct ext_include_interpreter_global, 1);
+		ctx->global->variables = sieve_variable_storage_create
+			(ctx->pool, ext_include_binary_get_global_scope(renv->sbin), 0);
+		p_array_init(&ctx->global->included_scripts, ctx->pool, 10);
+	} else {
+		ctx->global = ctx->parent->global;
+	}
+
+	sieve_ext_variables_set_storage
+		(renv->interp, ctx->global->variables, &include_extension);	
+}
+
+static struct sieve_interpreter_extension include_interpreter_extension = {
+	&include_extension,
+	ext_include_runtime_init,
+	NULL,
+};
+
+/* 
+ * Interpreter context management 
+ */
+
+static struct ext_include_interpreter_context *
+	ext_include_interpreter_context_create
+(struct sieve_interpreter *interp, 
+	struct ext_include_interpreter_context *parent, 
+	struct sieve_script *script, const struct ext_include_script_info *sinfo)
+{	
+	struct ext_include_interpreter_context *ctx;
+
+	pool_t pool = sieve_interpreter_pool(interp);
+	ctx = p_new(pool, struct ext_include_interpreter_context, 1);
+	ctx->pool = pool;
+	ctx->parent = parent;
+	ctx->interp = interp;
+	ctx->script = script;
+	ctx->script_info = sinfo;
+
+	if ( parent == NULL ) {
+		ctx->nesting_level = 0;
+	} else {
+		ctx->nesting_level = parent->nesting_level + 1;
+	}
+
+	return ctx;
+}
+
+static inline struct ext_include_interpreter_context *
+	ext_include_get_interpreter_context
+(struct sieve_interpreter *interp)
+{
+	return (struct ext_include_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, &include_extension);
+}
+
+static inline struct ext_include_interpreter_context *
+	ext_include_interpreter_context_init_child
+(struct sieve_interpreter *interp, 
+	struct ext_include_interpreter_context *parent, 
+	struct sieve_script *script, const struct ext_include_script_info *sinfo)
+{
+	struct ext_include_interpreter_context *ctx = 
+		ext_include_interpreter_context_create(interp, parent, script, sinfo);
+		
+	sieve_interpreter_extension_register
+		(interp, &include_interpreter_extension, ctx);
+	
+	return ctx;
+}
+
+void ext_include_interpreter_context_init
+(struct sieve_interpreter *interp)
+{
+	struct ext_include_interpreter_context *ctx = 
+		ext_include_get_interpreter_context(interp);
+
+	/* Is this is the top-level interpreter ? */	
+	if ( ctx == NULL ) {
+		struct sieve_script *script;
+
+		/* Initialize top context */
+		script = sieve_interpreter_script(interp);
+		ctx = ext_include_interpreter_context_create
+			(interp, NULL, script, NULL);
+		
+		sieve_interpreter_extension_register
+			(interp, &include_interpreter_extension, (void *) ctx);			
+	}
+}
+
+struct sieve_variable_storage *ext_include_interpreter_get_global_variables
+(struct sieve_interpreter *interp)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(interp);
+		
+	return ctx->global->variables;
+}
+
+/* 
+ * Including a script during code generation 
+ */
+
+bool ext_include_generate_include
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+	enum ext_include_script_location location, struct sieve_script *script, 
+	const struct ext_include_script_info **included_r, bool once)
+{
+	bool result = TRUE;
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_generator *gentr = cgenv->gentr;
+	struct ext_include_binary_context *binctx;
+	struct sieve_generator *subgentr;
+	struct ext_include_generator_context *ctx =
+		ext_include_get_generator_context(gentr);
+	struct ext_include_generator_context *pctx;
+	struct sieve_error_handler *ehandler = sieve_generator_error_handler(gentr);
+	const struct ext_include_script_info *included;
+		
+	*included_r = NULL;
+
+	/* Just to be sure: do not include more scripts when errors have occured 
+	 * already. 
+	 */
+	if ( sieve_get_errors(ehandler) > 0 )
+		return FALSE;
+		
+	/* Limit nesting level */
+	if ( ctx->nesting_level >= EXT_INCLUDE_MAX_NESTING_LEVEL ) {
+		sieve_command_generate_error
+			(gentr, cmd, "cannot nest includes deeper than %d levels",
+				EXT_INCLUDE_MAX_NESTING_LEVEL);
+		return FALSE;
+	}
+	
+	/* Check for circular include */
+	if ( !once ) {
+		pctx = ctx;
+		while ( pctx != NULL ) {
+			if ( sieve_script_equals(pctx->script, script) ) {
+				sieve_command_generate_error(gentr, cmd, "circular include");
+				
+				return FALSE;
+			}
+		
+			pctx = pctx->parent;
+		}
+	}
+
+	/* Get binary context */
+	binctx = ext_include_binary_init(sbin, cgenv->ast);
+
+	/* Is the script already compiled into the current binary? */
+	if ( !ext_include_binary_script_is_included(binctx, script, &included) )	
+	{	
+		unsigned int inc_block_id, this_block_id;
+		const char *script_name = sieve_script_name(script);
+
+		/* Check whether include limit is exceeded */
+		if ( ext_include_binary_script_get_count(binctx) >= 
+			EXT_INCLUDE_MAX_INCLUDES ) {
+	 		sieve_command_generate_error(gentr, cmd, 
+	 			"failed to include script '%s': no more than %u includes allowed", 
+				str_sanitize(script_name, 80), EXT_INCLUDE_MAX_INCLUDES);
+	 		return FALSE;			
+		}
+		
+		/* No, allocate a new block in the binary and mark the script as included.
+		 */
+		inc_block_id = sieve_binary_block_create(sbin);
+		included = ext_include_binary_script_include
+			(binctx, script, location, inc_block_id);
+
+		/* Parse */
+		if ( (ast = sieve_parse(script, ehandler)) == NULL ) {
+	 		sieve_command_generate_error(gentr, cmd, 
+	 			"failed to parse included script '%s'", str_sanitize(script_name, 80));
+	 		return FALSE;
+		}
+		
+		/* Included scripts inherit global variable scope */
+		(void)ext_include_create_ast_context(ast, cmd->ast_node->ast);
+
+		/* Validate */
+		if ( !sieve_validate(ast, ehandler) ) {
+			sieve_command_generate_error(gentr, cmd, 
+				"failed to validate included script '%s'", str_sanitize(script_name, 80));
+	 		sieve_ast_unref(&ast);
+	 		return FALSE;
+	 	}
+
+		/* Generate 
+		 *
+		 * FIXME: It might not be a good idea to recurse code generation for 
+		 * included scripts.
+		 */
+		if ( sieve_binary_block_set_active(sbin, inc_block_id, &this_block_id) ) {
+		 	subgentr = sieve_generator_create(ast, ehandler);			
+			ext_include_initialize_generator_context(subgentr, ctx, script);
+				
+			if ( !sieve_generator_run(subgentr, &sbin) ) {
+				sieve_command_generate_error(gentr, cmd, 
+					"failed to generate code for included script '%s'", 
+					str_sanitize(script_name, 80));
+		 		result = FALSE;
+			}
+			
+			if ( sbin != NULL )		
+				(void) sieve_binary_block_set_active(sbin, this_block_id, NULL); 	
+			sieve_generator_free(&subgentr);
+		} else {
+			sieve_sys_error("include: failed to activate binary  block %d for "
+				"generating code for the included script", inc_block_id);
+			result = FALSE;
+		}
+		
+		/* Cleanup */
+		sieve_ast_unref(&ast);		
+	} 
+
+	if ( result ) *included_r = included;
+	
+	return result;
+}
+
+/* 
+ * Executing an included script during interpretation 
+ */
+
+static int ext_include_runtime_check_circular
+(struct ext_include_interpreter_context *ctx,
+	const struct ext_include_script_info *include)
+{
+	struct ext_include_interpreter_context *pctx;
+
+	pctx = ctx;
+	while ( pctx != NULL ) {
+
+		if ( sieve_script_equals(include->script, pctx->script) )
+			return TRUE;
+
+		pctx = pctx->parent;
+	}
+
+	return FALSE;
+}
+
+static bool ext_include_runtime_include_mark
+(struct ext_include_interpreter_context *ctx,
+	const struct ext_include_script_info *include, bool once)
+{
+	struct sieve_script *const *includes;
+	unsigned int count, i;
+	
+	includes = array_get(&ctx->global->included_scripts, &count);
+	for ( i = 0; i < count; i++ )	{
+		if ( sieve_script_equals(include->script, includes[i]) )
+			return ( !once );
+	}
+	
+	array_append(&ctx->global->included_scripts, &include->script, 1);
+
+	return TRUE;
+}
+
+bool ext_include_execute_include
+(const struct sieve_runtime_env *renv, unsigned int include_id, bool once)
+{
+	int result = TRUE;
+	struct ext_include_interpreter_context *ctx;
+	const struct ext_include_script_info *included;
+	struct ext_include_binary_context *binctx = 
+		ext_include_binary_get_context(renv->sbin);
+
+	/* Check for invalid include id (== corrupt binary) */
+	included = ext_include_binary_script_get_included(binctx, include_id);
+	if ( included == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid include id: %d", include_id);
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	ctx = ext_include_get_interpreter_context(renv->interp);
+	
+	sieve_runtime_trace(renv, 
+		"INCLUDE command (script: %s, id: %d block: %d) START::", 
+		sieve_script_name(included->script), include_id, included->block_id);
+
+	/* If :once modifier is specified, check for duplicate include */
+	if ( !ext_include_runtime_include_mark(ctx, included, once) ) {
+		/* skip */
+
+		sieve_runtime_trace(renv, 
+			"INCLUDE command (block: %d) SKIPPED ::", included->block_id);
+		return result;
+	}
+
+	/* Check circular include during interpretation as well. 
+	 * Let's not trust binaries.
+	 */
+	if ( ext_include_runtime_check_circular(ctx, included) ) {
+		sieve_runtime_trace_error(renv, 
+			"circular include for script: %s [%d]", 
+			sieve_script_name(included->script), included->block_id);
+
+		/* Situation has no valid way to emerge at runtime */
+		return SIEVE_EXEC_BIN_CORRUPT; 
+	}
+
+	if ( ctx->parent == NULL ) {
+		struct ext_include_interpreter_context *curctx = NULL;
+		struct sieve_error_handler *ehandler = 
+			sieve_interpreter_get_error_handler(renv->interp);
+		struct sieve_interpreter *subinterp;
+		unsigned int this_block_id;
+		bool interrupted = FALSE;	
+
+		/* We are the top-level interpreter instance */	
+		
+		/* Activate block for included script */
+		if ( !sieve_binary_block_set_active
+			(renv->sbin, included->block_id, &this_block_id) ) {			
+			sieve_runtime_trace_error(renv, "invalid block id: %d", 
+				included->block_id);
+			result = SIEVE_EXEC_BIN_CORRUPT;
+		}
+
+		if ( result > 0 ) {
+			/* Create interpreter for top-level included script
+			 * (first sub-interpreter) 
+			 */
+			subinterp = sieve_interpreter_create(renv->sbin, ehandler);
+
+			if ( subinterp != NULL ) {			
+				curctx = ext_include_interpreter_context_init_child
+					(subinterp, ctx, included->script, included);
+
+				/* Activate and start the top-level included script */
+				result = ( sieve_interpreter_start
+					(subinterp, renv->msgdata, renv->scriptenv, renv->msgctx, 
+						renv->result, &interrupted) == 1 );
+			} else
+				result = SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		/* Included scripts can have includes of their own. This is not implemented
+		 * recursively. Rather, the sub-interpreter interrupts and defers the 
+		 * include to the top-level interpreter, which is here.
+		 */
+		if ( result > 0 && interrupted && !curctx->returned ) {
+			while ( result > 0 ) {
+
+				if ( ( (interrupted && curctx->returned) || (!interrupted) ) && 
+					curctx->parent != NULL ) {
+					
+					/* Sub-interpreter ended or executed return */
+					
+					sieve_runtime_trace(renv, "INCLUDE command (block: %d) END ::", 
+						curctx->script_info->block_id);
+
+					/* Ascend interpreter stack */
+					curctx = curctx->parent;
+					sieve_interpreter_free(&subinterp);
+					
+					/* This is the top-most sub-interpreter, bail out */
+					if ( curctx->parent == NULL ) break;
+					
+					/* Reactivate parent */
+					(void) sieve_binary_block_set_active
+						(renv->sbin, curctx->script_info->block_id, NULL);
+					subinterp = curctx->interp; 	
+					
+					/* Continue parent */
+					curctx->include = NULL;
+					curctx->returned = FALSE;
+
+					result = ( sieve_interpreter_continue(subinterp, &interrupted) == 1 );
+				} else {
+					if ( curctx->include != NULL ) {
+
+						/* Sub-include requested */
+															
+						/* Activate the sub-include's block */
+						if ( !sieve_binary_block_set_active
+							(renv->sbin, curctx->include->block_id, NULL) ) {
+							sieve_runtime_trace_error(renv, "invalid block id: %d", 
+								curctx->include->block_id);
+							result = SIEVE_EXEC_BIN_CORRUPT;
+						}
+				
+						if ( result > 0 ) {
+							/* Create sub-interpreter */
+							subinterp = sieve_interpreter_create(renv->sbin, ehandler);			
+
+							if ( subinterp != NULL ) {
+								curctx = ext_include_interpreter_context_init_child
+									(subinterp, curctx, curctx->include->script, 
+										curctx->include);
+
+								/* Start the sub-include's interpreter */
+								curctx->include = NULL;
+								curctx->returned = FALSE;
+								result = ( sieve_interpreter_start
+									(subinterp, renv->msgdata, renv->scriptenv, renv->msgctx,
+										renv->result, &interrupted) == 1 );		 	
+							} else
+								result = SIEVE_EXEC_BIN_CORRUPT;
+						}
+					} else {
+						/* Sub-interpreter was interrupted outside this extension, probably
+						 * stop command was executed. Generate an interrupt ourselves, 
+						 * ending all script execution.
+						 */
+						sieve_interpreter_interrupt(renv->interp);
+						break;
+					}
+				}
+			}
+		} else 
+			sieve_runtime_trace(renv, "INCLUDE command (block: %d) END ::", 
+				curctx->script_info->block_id);
+
+		/* Free any sub-interpreters that might still be active */
+		while ( curctx != NULL && curctx->parent != NULL ) {
+			struct ext_include_interpreter_context *nextctx	= curctx->parent;
+			struct sieve_interpreter *killed_interp = curctx->interp;
+
+			/* This kills curctx too */
+			sieve_interpreter_free(&killed_interp);
+
+			/* Luckily we recorded the parent earlier */
+			curctx = nextctx;
+		}
+
+		/* Return to our own block */
+		(void) sieve_binary_block_set_active(renv->sbin, this_block_id, NULL); 	
+	} else {
+		/* We are an included script already, defer inclusion to main interpreter */
+
+		ctx->include = included;
+		sieve_interpreter_interrupt(renv->interp);
+	}
+	
+	return result;
+}
+
+void ext_include_execute_return(const struct sieve_runtime_env *renv)
+{
+	struct ext_include_interpreter_context *ctx =
+		ext_include_get_interpreter_context(renv->interp);
+	
+	ctx->returned = TRUE;
+	sieve_interpreter_interrupt(renv->interp);	
+}
+	
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,110 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_COMMON_H
+#define __EXT_INCLUDE_COMMON_H
+
+#include "lib.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+
+/* 
+ * Forward declarations
+ */
+
+struct ext_include_script_info;
+struct ext_include_binary_context;
+
+/* 
+ * Types 
+ */
+
+enum ext_include_script_location { 
+	EXT_INCLUDE_LOCATION_PERSONAL, 
+	EXT_INCLUDE_LOCATION_GLOBAL,
+	EXT_INCLUDE_LOCATION_INVALID 
+}; 
+
+/* 
+ * Extension 
+ */
+
+extern const struct sieve_extension include_extension;
+extern const struct sieve_binary_extension include_binary_ext;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command cmd_include;
+extern const struct sieve_command cmd_return;
+extern const struct sieve_command cmd_global;
+
+/* DEPRICATED */ 
+extern const struct sieve_command cmd_import;
+extern const struct sieve_command cmd_export;
+
+/*
+ * Operations
+ */
+ 
+enum ext_include_opcode {
+	EXT_INCLUDE_OPERATION_INCLUDE,
+	EXT_INCLUDE_OPERATION_RETURN,
+	EXT_INCLUDE_OPERATION_GLOBAL
+};
+ 
+extern const struct sieve_operation include_operation;
+extern const struct sieve_operation return_operation;
+extern const struct sieve_operation global_operation;
+
+/* 
+ * Script access 
+ */
+
+const char *ext_include_get_script_directory
+	(enum ext_include_script_location location, const char *script_name);
+
+/* 
+ * Context 
+ */
+ 
+/* AST Context */
+
+struct ext_include_ast_context {
+    struct sieve_variable_scope *global_vars;
+
+    ARRAY_DEFINE(included_scripts, struct sieve_script *);
+};
+
+struct ext_include_ast_context *ext_include_create_ast_context
+	(struct sieve_ast *ast, struct sieve_ast *parent);
+struct ext_include_ast_context *ext_include_get_ast_context
+	(struct sieve_ast *ast);
+
+void ext_include_ast_link_included_script
+	(struct sieve_ast *ast, struct sieve_script *script);
+
+/* Generator context */
+
+void ext_include_register_generator_context
+	(const struct sieve_codegen_env *cgenv);
+
+bool ext_include_generate_include
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+		enum ext_include_script_location location, struct sieve_script *script, 
+		const struct ext_include_script_info **included_r, bool once);
+
+/* Interpreter context */
+
+void ext_include_interpreter_context_init(struct sieve_interpreter *interp);
+
+bool ext_include_execute_include
+	(const struct sieve_runtime_env *renv, unsigned int block_id, bool once);
+void ext_include_execute_return(const struct sieve_runtime_env *renv);
+
+struct sieve_variable_storage *ext_include_interpreter_get_global_variables
+	(struct sieve_interpreter *interp);
+
+#endif /* __EXT_INCLUDE_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-limits.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,12 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_LIMITS_H
+#define __EXT_INCLUDE_LIMITS_H
+
+#include "sieve-common.h"
+
+#define EXT_INCLUDE_MAX_NESTING_LEVEL 10
+#define EXT_INCLUDE_MAX_INCLUDES      255
+
+#endif /* __EXT_INCLUDE_LIMITS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,148 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+#include "ext-include-binary.h"
+#include "ext-include-variables.h"
+
+/* 
+ * Variable import-export
+ */
+ 
+struct sieve_variable *ext_include_variable_import_global
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	const char *variable)
+{
+	struct sieve_ast *ast = cmd->ast_node->ast;
+	struct ext_include_ast_context *ctx = ext_include_get_ast_context(ast);
+	struct sieve_variable_scope *main_scope;
+	struct sieve_variable *var = NULL;
+
+	/* Sanity safeguard */	
+	i_assert ( ctx->global_vars != NULL );
+
+	/* Get/Declare the variable in the global scope */
+	var = sieve_variable_scope_get_variable(ctx->global_vars, variable, TRUE);
+
+	/* Check whether scope is over its size limit */
+	if ( var == NULL ) {
+		sieve_command_validate_error(valdtr, cmd,
+			"declaration of new global variable '%s' exceeds the limit "
+			"(max variables: %u)", 
+			variable, SIEVE_VARIABLES_MAX_SCOPE_SIZE);
+	}
+	
+	/* Import the global variable into the local script scope */
+	main_scope = sieve_ext_variables_get_main_scope(valdtr);
+	(void)sieve_variable_scope_import(main_scope, var);
+
+	return var;	
+}
+
+/*
+ * Binary symbol table
+ */
+ 
+bool ext_include_variables_save
+(struct sieve_binary *sbin, struct sieve_variable_scope *global_vars)
+{
+	unsigned int count = sieve_variable_scope_size(global_vars);
+
+	sieve_binary_emit_unsigned(sbin, count);
+
+	if ( count > 0 ) {
+		unsigned int size, i;
+		struct sieve_variable *const *vars = 
+			sieve_variable_scope_get_variables(global_vars, &size);
+
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_emit_cstring(sbin, vars[i]->identifier);
+		}
+	}
+
+	return TRUE;
+}
+
+bool ext_include_variables_load
+(struct sieve_binary *sbin, sieve_size_t *offset, unsigned int block,
+	struct sieve_variable_scope **global_vars_r)
+{
+	unsigned int count = 0;
+	unsigned int i;
+	pool_t pool;
+
+	/* Sanity assert */
+	i_assert( *global_vars_r == NULL );
+
+	if ( !sieve_binary_read_unsigned(sbin, offset, &count) ) {
+		sieve_sys_error("include: failed to read global variables count "
+			"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+		return FALSE;
+	}
+
+	if ( count > SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		sieve_sys_error("include: global variable scope size of binary %s "
+			"exceeds the limit (%u > %u)", sieve_binary_path(sbin),
+			count, SIEVE_VARIABLES_MAX_SCOPE_SIZE );
+		return FALSE;
+	}
+
+	*global_vars_r = sieve_variable_scope_create(&include_extension);
+	pool = sieve_variable_scope_pool(*global_vars_r);
+
+	/* Read global variable scope */
+	for ( i = 0; i < count; i++ ) {
+		struct sieve_variable *var;
+		string_t *identifier;
+
+		if ( !sieve_binary_read_string(sbin, offset, &identifier) ) {
+			/* Binary is corrupt, recompile */
+			sieve_sys_error("include: failed to read global variable specification "
+				"from dependency block %d of binary %s", block, sieve_binary_path(sbin));
+			return FALSE;
+		}
+		
+		var = sieve_variable_scope_declare(*global_vars_r, str_c(identifier));
+
+		i_assert( var != NULL );
+		i_assert( var->index == i );
+	}
+	
+	return TRUE;
+}
+
+bool ext_include_variables_dump
+(struct sieve_dumptime_env *denv, struct sieve_variable_scope *global_vars)
+{
+	unsigned int size;
+	struct sieve_variable *const *vars;
+
+	i_assert(global_vars != NULL);
+
+	vars = sieve_variable_scope_get_variables(global_vars, &size);
+
+	if ( size > 0 ) {
+		unsigned int i;
+
+		sieve_binary_dump_sectionf(denv, "Global variables");
+	
+		for ( i = 0; i < size; i++ ) {
+			sieve_binary_dumpf(denv, "%3d: '%s' \n", i, vars[i]->identifier);
+		}	
+	}
+
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/ext-include-variables.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_INCLUDE_VARIABLES_H
+#define __EXT_INCLUDE_VARIABLES_H
+
+#include "sieve-common.h"
+
+#include "sieve-ext-variables.h"
+
+#include "ext-include-common.h"
+
+/* 
+ * Variable import-export
+ */
+ 
+struct sieve_variable *ext_include_variable_import_global
+	(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+		const char *variable);
+
+/*
+ * Binary symbol table
+ */
+
+bool ext_include_variables_save
+	(struct sieve_binary *sbin, struct sieve_variable_scope *global_vars);
+bool ext_include_variables_load
+	(struct sieve_binary *sbin, sieve_size_t *offset, unsigned int block,
+		struct sieve_variable_scope **global_vars_r);
+bool ext_include_variables_dump
+	(struct sieve_dumptime_env *denv, struct sieve_variable_scope *global_vars);
+		
+#endif /* __EXT_INCLUDE_VARIABLES_H */
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/include/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,27 @@
+noinst_LTLIBRARIES = libsieve_ext_include.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I../variables \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage
+
+cmds = \
+	cmd-include.c \
+	cmd-return.c \
+	cmd-global.c
+
+libsieve_ext_include_la_SOURCES = \
+	$(cmds) \
+	ext-include-common.c \
+	ext-include-binary.c \
+	ext-include-variables.c \
+	ext-include.c
+
+noinst_HEADERS = \
+	ext-include-common.h \
+	ext-include-limits.h \
+	ext-include-binary.h \
+	ext-include-variables.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,14 @@
+SUBDIRS = \
+	vacation \
+	subaddress \
+	comparator-i-ascii-numeric \
+	relational \
+	regex \
+	imap4flags \
+	copy \
+	include \
+	body \
+	variables \
+	enotify \
+	environment
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,67 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension regex 
+ * ---------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: draft-murchison-sieve-regex-07
+ * Implementation: full, but suboptimal
+ * Status: experimental, largely untested
+ *
+ * FIXME: Regular expressions are compiled during compilation and 
+ * again during interpretation. This is suboptimal and should be 
+ * changed. This requires dumping the compiled regex to the binary. 
+ * Most likely, this will only be possible when we implement regular
+ * expressions ourselves. 
+ * 
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-regex-common.h"
+
+#include <sys/types.h>
+#include <regex.h>
+
+/* 
+ * Extension
+ */
+
+static bool ext_regex_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension regex_extension = { 
+	"regex", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_regex_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(regex_match_type_operand)
+};
+
+static bool ext_regex_validator_load(struct sieve_validator *validator)
+{
+	sieve_match_type_register(validator, &regex_match_type); 
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,23 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-match-types.h"
+
+#include "ext-regex-common.h"
+
+/* 
+ * Regex match type operand
+ */
+
+static const struct sieve_extension_objects ext_match_types =
+    SIEVE_EXT_DEFINE_MATCH_TYPE(regex_match_type);
+
+const struct sieve_operand regex_match_type_operand = {
+    "regex match",
+    &regex_extension,
+    0,
+    &sieve_match_type_operand_class,
+    &ext_match_types
+};
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/ext-regex-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_REGEX_COMMON_H
+#define __EXT_REGEX_COMMON_H
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension regex_extension;
+
+/*
+ * Operand
+ */
+
+extern const struct sieve_operand regex_match_type_operand;
+
+/*
+ * Match type
+ */
+
+extern const struct sieve_match_type regex_match_type;
+
+#endif /* __EXT_REGEX_COMMON_H */
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,16 @@
+noinst_LTLIBRARIES = libsieve_ext_regex.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_regex_la_SOURCES = \
+	mcht-regex.c \
+	ext-regex-common.c \
+	ext-regex.c
+
+noinst_HEADERS = \
+	ext-regex-common.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/regex/mcht-regex.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,303 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Match-type ':regex'
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "array.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-match.h"
+
+#include "ext-regex-common.h"
+
+#include <sys/types.h>
+#include <regex.h>
+#include <ctype.h>
+
+/*
+ * Configuration
+ */
+
+#define MCHT_REGEX_MAX_SUBSTITUTIONS SIEVE_MAX_MATCH_VALUES
+
+/* 
+ * Match type
+ */
+ 
+bool mcht_regex_validate_context
+(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+    struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg);
+
+static void mcht_regex_match_init(struct sieve_match_context *mctx);
+static int mcht_regex_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size,
+    	const char *key, size_t key_size, int key_index);
+static int mcht_regex_match_deinit(struct sieve_match_context *mctx);
+
+const struct sieve_match_type regex_match_type = {
+	SIEVE_OBJECT("regex", &regex_match_type_operand, 0),
+	TRUE, FALSE,
+	NULL,
+	mcht_regex_validate_context,
+	mcht_regex_match_init,
+	mcht_regex_match,
+	mcht_regex_match_deinit
+};
+
+/* 
+ * Match type validation 
+ */
+
+/* Wrapper around the regerror function for easy access */
+static const char *_regexp_error(regex_t *regexp, int errorcode)
+{
+	size_t errsize = regerror(errorcode, regexp, NULL, 0); 
+
+	if ( errsize > 0 ) {
+		char *errbuf;
+
+		buffer_t *error_buf = 
+			buffer_create_dynamic(pool_datastack_create(), errsize);
+		errbuf = buffer_get_space_unsafe(error_buf, 0, errsize);
+
+		errsize = regerror(errorcode, regexp, errbuf, errsize);
+	 
+		/* We don't want the error to start with a capital letter */
+		errbuf[0] = i_tolower(errbuf[0]);
+
+		buffer_append_space_unsafe(error_buf, errsize);
+
+		return str_c(error_buf);
+	}
+
+	return "";
+}
+
+static int mcht_regex_validate_regexp
+(struct sieve_validator *validator, 
+	struct sieve_match_type_context *ctx ATTR_UNUSED,
+	struct sieve_ast_argument *key, int cflags) 
+{
+	int ret;
+	regex_t regexp;
+
+	if ( (ret=regcomp(&regexp, sieve_ast_argument_strc(key), cflags)) != 0 ) {
+		sieve_argument_validate_error(validator, key,
+			"invalid regular expression for regex match: %s", 
+			_regexp_error(&regexp, ret));
+
+		regfree(&regexp);	
+		return FALSE;
+	}
+
+	regfree(&regexp);
+	return TRUE;
+}
+
+struct _regex_key_context {
+	struct sieve_validator *valdtr;
+	struct sieve_match_type_context *mctx;
+	int cflags;
+};
+
+static int mcht_regex_validate_key_argument
+(void *context, struct sieve_ast_argument *key)
+{
+	struct _regex_key_context *keyctx = (struct _regex_key_context *) context;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(key) ) {
+		sieve_argument_validate_error(keyctx->valdtr, key,
+			"this Sieve implementation currently only accepts a literal string "
+			"for a regular expression");
+		return FALSE;
+	}
+
+	return mcht_regex_validate_regexp
+		(keyctx->valdtr, keyctx->mctx, key, keyctx->cflags);
+}
+	
+bool mcht_regex_validate_context
+(struct sieve_validator *validator, struct sieve_ast_argument *arg ATTR_UNUSED,
+	struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg)
+{
+	const struct sieve_comparator *cmp = ctx->comparator;
+	int cflags = REG_EXTENDED | REG_NOSUB;
+	struct _regex_key_context keyctx;
+	struct sieve_ast_argument *kitem;
+
+	if ( cmp != NULL ) { 
+		if ( cmp == &i_ascii_casemap_comparator )
+			cflags =  REG_EXTENDED | REG_NOSUB | REG_ICASE;
+		else if ( cmp == &i_octet_comparator )
+			cflags =  REG_EXTENDED | REG_NOSUB;
+		else {
+			sieve_argument_validate_error(validator, ctx->match_type_arg, 
+				"regex match type only supports "
+				"i;octet and i;ascii-casemap comparators" );
+			return FALSE;	
+		}
+	}
+
+	/* Validate regular expression keys */
+
+	keyctx.valdtr = validator;
+	keyctx.mctx = ctx;
+	keyctx.cflags = cflags;
+
+	kitem = key_arg;
+	if ( !sieve_ast_stringlist_map(&kitem, (void *) &keyctx,
+		mcht_regex_validate_key_argument) )
+		return FALSE;
+
+	return TRUE;
+}
+
+/* 
+ * Match type implementation 
+ */
+
+struct mcht_regex_context {
+	ARRAY_DEFINE(reg_expressions, regex_t);
+	int value_index;
+	regmatch_t *pmatch;
+	size_t nmatch;
+};
+
+static void mcht_regex_match_init
+	(struct sieve_match_context *mctx)
+{
+	struct mcht_regex_context *ctx = 
+		t_new(struct mcht_regex_context, 1);
+	
+	t_array_init(&ctx->reg_expressions, 4);
+
+	ctx->value_index = -1;
+	if ( sieve_match_values_are_enabled(mctx->interp) ) {
+		ctx->pmatch = t_new(regmatch_t, MCHT_REGEX_MAX_SUBSTITUTIONS);
+		ctx->nmatch = MCHT_REGEX_MAX_SUBSTITUTIONS;
+	} else {
+		ctx->pmatch = NULL;
+		ctx->nmatch = 0;
+	}
+	
+	mctx->data = (void *) ctx;
+}
+
+static regex_t *mcht_regex_get
+(struct mcht_regex_context *ctx,
+	const struct sieve_comparator *cmp, 
+	const char *key, unsigned int key_index)
+{
+	int ret;
+	int cflags;
+	regex_t *regexp;
+	
+	if ( ctx->value_index <= 0 ) {
+		array_idx_clear(&ctx->reg_expressions, key_index);
+		regexp = array_idx_modifiable(&ctx->reg_expressions, key_index);
+
+		if ( cmp == &i_octet_comparator ) 
+			cflags =  REG_EXTENDED;
+		else if ( cmp ==  &i_ascii_casemap_comparator )
+			cflags =  REG_EXTENDED | REG_ICASE;
+		else
+			return NULL;
+			
+		if ( ctx->nmatch == 0 ) cflags |= REG_NOSUB;
+
+		if ( (ret=regcomp(regexp, key, cflags)) != 0 ) {
+			/* FIXME: Do something useful, i.e. report error somewhere */
+			return NULL;
+		}
+	} else {
+		regexp = array_idx_modifiable(&ctx->reg_expressions, key_index);
+	}
+
+	return regexp;
+}
+
+static int mcht_regex_match
+(struct sieve_match_context *mctx, 
+	const char *val, size_t val_size ATTR_UNUSED, 
+	const char *key, size_t key_size ATTR_UNUSED, int key_index)
+{
+	struct mcht_regex_context *ctx = (struct mcht_regex_context *) mctx->data;
+	regex_t *regexp;
+
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	if ( key_index < 0 ) return FALSE;
+
+	if ( key_index == 0 ) ctx->value_index++;
+
+	if ( (regexp=mcht_regex_get(ctx, mctx->comparator, key, key_index)) == NULL )
+		return FALSE;
+
+	if ( regexec(regexp, val, ctx->nmatch, ctx->pmatch, 0) == 0 ) {
+
+		if ( ctx->nmatch > 0 ) {
+			size_t i;
+			int skipped = 0;
+			string_t *subst = t_str_new(32);
+
+			struct sieve_match_values *mvalues = sieve_match_values_start(mctx->interp);
+
+			i_assert( mvalues != NULL );
+
+			for ( i = 0; i < ctx->nmatch; i++ ) {
+				str_truncate(subst, 0);
+			
+				if ( ctx->pmatch[i].rm_so != -1 ) {
+					if ( skipped > 0 ) {
+						sieve_match_values_skip(mvalues, skipped);
+						skipped = 0;
+					}
+					
+					str_append_n(subst, val + ctx->pmatch[i].rm_so, 
+						ctx->pmatch[i].rm_eo - ctx->pmatch[i].rm_so);
+					sieve_match_values_add(mvalues, subst);
+				} else 
+					skipped++;
+			}
+
+			sieve_match_values_commit(mctx->interp, &mvalues);
+		}
+
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+int mcht_regex_match_deinit
+	(struct sieve_match_context *mctx)
+{
+	struct mcht_regex_context *ctx = (struct mcht_regex_context *) mctx->data;
+	regex_t *regexps;
+	unsigned int count, i;
+
+	regexps = array_get_modifiable(&ctx->reg_expressions, &count);
+	for ( i = 0; i < count; i++ ) {
+		regfree(&regexps[i]);
+	}
+
+	return FALSE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension relational 
+ * --------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 3431
+ * Implementation: full
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-relational-common.h"
+
+/* 
+ * Extension
+ */
+
+static bool ext_relational_validator_load(struct sieve_validator *validator);
+
+int ext_relational_my_id = -1;
+
+const struct sieve_extension relational_extension = { 
+	"relational", 
+	&ext_relational_my_id,
+	NULL, NULL,
+	ext_relational_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(rel_match_type_operand)
+};
+
+static bool ext_relational_validator_load(struct sieve_validator *validator)
+{
+	sieve_match_type_register(validator, &value_match_type); 
+	sieve_match_type_register(validator, &count_match_type); 
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,160 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Syntax:
+ *   MATCH-TYPE =/ COUNT / VALUE
+ *   COUNT = ":count" relational-match
+ *   VALUE = ":value" relational-match
+ *   relational-match = DQUOTE ( "gt" / "ge" / "lt"
+ *                             / "le" / "eq" / "ne" ) DQUOTE
+ */ 
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Forward declarations
+ */
+
+const struct sieve_match_type *rel_match_types[];
+
+/* 
+ * Validation 
+ */
+
+bool mcht_relational_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_match_type_context *ctx)
+{	
+	enum relational_match rel_match = REL_MATCH_INVALID;
+	string_t *rel_match_ident;
+
+	/* Check syntax:
+	 *   relational-match = DQUOTE ( "gt" / "ge" / "lt"	
+ 	 *                             / "le" / "eq" / "ne" ) DQUOTE
+ 	 *
+	 * So, actually this must be a constant string and it is implemented as such 
+	 */
+	 
+	/* Did we get a string in the first place ? */ 
+	if ( (*arg)->type != SAAT_STRING ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"the :%s match-type requires a constant string argument being "
+			"one of \"gt\", \"ge\", \"lt\", \"le\", \"eq\" or \"ne\", "
+			"but %s was found", 
+			ctx->match_type->object.identifier, sieve_ast_argument_name(*arg));
+		return FALSE;
+	}
+	
+	/* Check the relational match id */
+	
+	rel_match_ident = sieve_ast_argument_str(*arg);
+	if ( str_len(rel_match_ident) == 2 ) {
+		const char *rel_match_id = str_c(rel_match_ident);
+
+		switch ( rel_match_id[0] ) {
+		/* "gt" or "ge" */
+		case 'g':
+			switch ( rel_match_id[1] ) {
+			case 't': 
+				rel_match = REL_MATCH_GREATER; 
+				break;
+			case 'e': 
+				rel_match = REL_MATCH_GREATER_EQUAL; 
+				break;
+			default: 
+				rel_match = REL_MATCH_INVALID;
+			}
+			break;
+		/* "lt" or "le" */
+		case 'l':
+			switch ( rel_match_id[1] ) {
+			case 't': 
+				rel_match = REL_MATCH_LESS; 
+				break;
+			case 'e': 
+				rel_match = REL_MATCH_LESS_EQUAL; 
+				break;
+			default: 
+				rel_match = REL_MATCH_INVALID;
+			}
+			break;
+		/* "eq" */
+		case 'e':
+			if ( rel_match_id[1] == 'q' )
+				rel_match = REL_MATCH_EQUAL;
+			else	
+				rel_match = REL_MATCH_INVALID;		
+			break;
+		/* "ne" */
+		case 'n':
+			if ( rel_match_id[1] == 'e' )
+				rel_match = REL_MATCH_NOT_EQUAL;
+			else	
+				rel_match = REL_MATCH_INVALID;
+			break;
+		/* invalid */
+		default:
+			rel_match = REL_MATCH_INVALID;
+		}
+	}
+	
+	if ( rel_match >= REL_MATCH_INVALID ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"the :%s match-type requires a constant string argument being "
+			"one of \"gt\", \"ge\", \"lt\", \"le\", \"eq\" or \"ne\", "
+			"but \"%s\" was found", 
+			ctx->match_type->object.identifier, 
+			str_sanitize(str_c(rel_match_ident), 32));
+		return FALSE;
+	}
+	
+	/* Delete argument */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Not used just yet */
+	ctx->ctx_data = (void *) rel_match;
+
+	/* Override the actual match type with a parameter-specific one */
+	ctx->match_type = rel_match_types
+		[REL_MATCH_INDEX(ctx->match_type->object.code, rel_match)];
+
+	return TRUE;
+}
+
+/*
+ * Relational match-type operand
+ */
+
+const const struct sieve_match_type *rel_match_types[] = {
+    &rel_match_value_gt, &rel_match_value_ge, &rel_match_value_lt,
+    &rel_match_value_le, &rel_match_value_eq, &rel_match_value_ne,
+    &rel_match_count_gt, &rel_match_count_ge, &rel_match_count_lt,
+    &rel_match_count_le, &rel_match_count_eq, &rel_match_count_ne
+};
+
+static const struct sieve_extension_objects ext_match_types =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(rel_match_types);
+
+const struct sieve_operand rel_match_type_operand = {
+    "relational match",
+    &relational_extension,
+    0,
+    &sieve_match_type_operand_class,
+    &ext_match_types
+};
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/ext-relational-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_RELATIONAL_COMMON_H
+#define __EXT_RELATIONAL_COMMON_H
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+/* 
+ * Types 
+ */
+
+enum ext_relational_match_type {
+	RELATIONAL_VALUE,
+	RELATIONAL_COUNT
+};
+
+enum relational_match {
+	REL_MATCH_GREATER,
+	REL_MATCH_GREATER_EQUAL,
+	REL_MATCH_LESS,
+	REL_MATCH_LESS_EQUAL,
+	REL_MATCH_EQUAL,
+	REL_MATCH_NOT_EQUAL,
+	REL_MATCH_INVALID
+};
+
+#define REL_MATCH_INDEX(type, match) \
+	(type * REL_MATCH_INVALID + match)
+#define REL_MATCH_TYPE(index) \
+	(index / REL_MATCH_INVALID)
+#define REL_MATCH(index) \
+	(index % REL_MATCH_INVALID)
+
+/* 
+ * Extension definitions 
+ */
+
+extern int ext_relational_my_id;
+
+extern const struct sieve_extension relational_extension;
+extern const struct sieve_match_type_extension relational_match_extension;
+
+/*
+ * Match types
+ */
+ 
+/* Registered for validation */ 
+
+extern const struct sieve_match_type value_match_type;
+extern const struct sieve_match_type count_match_type;
+
+/* Used in byte code */
+
+extern const struct sieve_match_type rel_match_count_gt;
+extern const struct sieve_match_type rel_match_count_ge;
+extern const struct sieve_match_type rel_match_count_lt;
+extern const struct sieve_match_type rel_match_count_le;
+extern const struct sieve_match_type rel_match_count_eq;
+extern const struct sieve_match_type rel_match_count_ne;
+
+extern const struct sieve_match_type rel_match_value_gt;
+extern const struct sieve_match_type rel_match_value_ge;
+extern const struct sieve_match_type rel_match_value_lt;
+extern const struct sieve_match_type rel_match_value_le;
+extern const struct sieve_match_type rel_match_value_eq;
+extern const struct sieve_match_type rel_match_value_ne;
+
+/*
+ * Operand
+ */
+ 
+extern const struct sieve_operand rel_match_type_operand;
+
+
+/*
+ * Match type validation
+ */
+
+bool mcht_relational_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_match_type_context *ctx);
+		
+/*
+ * Value match function (also used by :count)
+ */
+ 
+int mcht_value_match
+    (struct sieve_match_context *mctx, const char *val, size_t val_size,
+        const char *key, size_t key_size, int key_index);
+
+
+#endif /* __EXT_RELATIONAL_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,17 @@
+noinst_LTLIBRARIES = libsieve_ext_relational.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_relational_la_SOURCES = \
+	ext-relational-common.c \
+	mcht-value.c \
+	mcht-count.c \
+	ext-relational.c 
+
+noinst_HEADERS = \
+	ext-relational-common.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-count.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,136 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+/* Match-type ':count' 
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-match.h"
+
+#include "ext-relational-common.h"
+
+/* 
+ * Forward declarations
+ */
+
+static void mcht_count_match_init(struct sieve_match_context *mctx);
+static int mcht_count_match
+	(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+		const char *key, size_t key_size, int key_index);
+static int mcht_count_match_deinit(struct sieve_match_context *mctx);
+
+/* 
+ * Match-type objects
+ */
+ 
+const struct sieve_match_type count_match_type = {
+	SIEVE_OBJECT("count", &rel_match_type_operand, RELATIONAL_COUNT),
+	FALSE, FALSE,
+	mcht_relational_validate,
+	NULL, NULL, NULL, NULL
+};
+
+#define COUNT_MATCH_TYPE(name, rel_match)                     \
+const struct sieve_match_type rel_match_count_ ## name = {    \
+	SIEVE_OBJECT(                                             \
+		"count-" #name, &rel_match_type_operand,              \
+		REL_MATCH_INDEX(RELATIONAL_COUNT, rel_match)),        \
+	FALSE, FALSE,                                             \
+	NULL, NULL,                                               \
+	mcht_count_match_init,                                    \
+	mcht_count_match,                                         \
+	mcht_count_match_deinit                                   \
+}
+	
+COUNT_MATCH_TYPE(gt, REL_MATCH_GREATER);
+COUNT_MATCH_TYPE(ge, REL_MATCH_GREATER_EQUAL);
+COUNT_MATCH_TYPE(lt, REL_MATCH_LESS);
+COUNT_MATCH_TYPE(le, REL_MATCH_LESS_EQUAL);
+COUNT_MATCH_TYPE(eq, REL_MATCH_EQUAL);
+COUNT_MATCH_TYPE(ne, REL_MATCH_NOT_EQUAL);
+
+/* 
+ * Match-type implementation 
+ */
+
+struct mcht_count_context {
+	unsigned int count;
+};
+
+static void mcht_count_match_init(struct sieve_match_context *mctx)
+{
+	struct mcht_count_context *cctx = t_new(struct mcht_count_context, 1);
+
+	cctx->count = 0;
+	mctx->data = (void *) cctx;
+}
+
+static int mcht_count_match
+(struct sieve_match_context *mctx, 
+	const char *val ATTR_UNUSED, size_t val_size ATTR_UNUSED, 
+	const char *key ATTR_UNUSED, size_t key_size ATTR_UNUSED,
+	int key_index) 
+{
+	if ( val == NULL )
+		return FALSE;
+
+	/* Count values */
+	if ( key_index == -1 ) {
+		struct mcht_count_context *cctx = 
+			(struct mcht_count_context *) mctx->data;
+
+		cctx->count++;
+	}
+
+	return FALSE;
+}
+
+static int mcht_count_match_deinit(struct sieve_match_context *mctx)
+{
+	struct mcht_count_context *cctx =
+            (struct mcht_count_context *) mctx->data;
+	int key_index;
+	string_t *key_item;
+    sieve_coded_stringlist_reset(mctx->key_list);
+	bool ok = TRUE;
+
+	string_t *value = t_str_new(20);
+	str_printfa(value, "%d", cctx->count);
+
+    /* Match to all key values */
+    key_index = 0;
+    key_item = NULL;
+    while ( (ok=sieve_coded_stringlist_next_item(mctx->key_list, &key_item)) 
+		&& key_item != NULL )
+    {
+		int ret = mcht_value_match
+			(mctx, str_c(value), str_len(value), str_c(key_item), 
+				str_len(key_item), key_index);
+        
+		if ( ret > 0 )   
+			return TRUE;
+	
+		if ( ret < 0 )
+			return ret;
+
+        key_index++;
+    }
+
+	return ( ok ? FALSE : -1 );
+}
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/relational/mcht-value.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,92 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-match.h"
+
+#include "ext-relational-common.h"
+
+/*
+ * Match-type objects
+ */
+
+const struct sieve_match_type value_match_type = {
+	SIEVE_OBJECT("value", &rel_match_type_operand, RELATIONAL_VALUE), 
+	TRUE, TRUE,
+	mcht_relational_validate,
+	NULL, NULL, NULL, NULL
+};
+
+#define VALUE_MATCH_TYPE(name, rel_match)                   \
+const struct sieve_match_type rel_match_value_ ## name = {  \
+	SIEVE_OBJECT(                                           \
+		"value-" #name, &rel_match_type_operand,            \
+		REL_MATCH_INDEX(RELATIONAL_VALUE, rel_match)),      \
+	TRUE, TRUE,                                             \
+	NULL, NULL, NULL,                                       \
+	mcht_value_match,                                       \
+	NULL                                                    \
+}
+
+VALUE_MATCH_TYPE(gt, REL_MATCH_GREATER);
+VALUE_MATCH_TYPE(ge, REL_MATCH_GREATER_EQUAL); 
+VALUE_MATCH_TYPE(lt, REL_MATCH_LESS);
+VALUE_MATCH_TYPE(le, REL_MATCH_LESS_EQUAL); 
+VALUE_MATCH_TYPE(eq, REL_MATCH_EQUAL);
+VALUE_MATCH_TYPE(ne, REL_MATCH_NOT_EQUAL);
+
+/* 
+ * Match-type implementation 
+ */
+
+int mcht_value_match
+(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+	const char *key, size_t key_size, int key_index ATTR_UNUSED)
+{
+	const struct sieve_match_type *mtch = mctx->match_type;
+	unsigned int rel_match = REL_MATCH(mtch->object.code);	
+	int cmp_result;
+
+	if ( val == NULL ) {
+		val = "";
+		val_size = 0;
+	}
+
+	cmp_result = mctx->comparator->
+		compare(mctx->comparator, val, val_size, key, key_size);
+
+	switch ( rel_match ) {
+	case REL_MATCH_GREATER:
+		return ( cmp_result > 0 );
+	case REL_MATCH_GREATER_EQUAL:
+		return ( cmp_result >= 0 );
+	case REL_MATCH_LESS:
+		return ( cmp_result < 0 );
+	case REL_MATCH_LESS_EQUAL:
+		return ( cmp_result <= 0 );
+	case REL_MATCH_EQUAL:
+		return ( cmp_result == 0 );
+	case REL_MATCH_NOT_EQUAL:
+		return ( cmp_result != 0 );
+	case REL_MATCH_INVALID:
+ 	default:
+		break;
+	}	
+	
+	return FALSE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/subaddress/ext-subaddress.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,163 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension subaddress 
+ * --------------------
+ *
+ * Author: Stephan Bosch
+ * Specification: RFC 3598
+ * Implementation: full, but not configurable
+ * Status: experimental, largely untested
+ * 
+ * FIXME: This extension is not configurable in any way. The separation 
+ * character is currently only configurable for compilation and not at runtime. 
+ *
+ */
+ 
+#include "sieve-common.h"
+
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+/* 
+ * Configuration 
+ */
+
+#define SUBADDRESS_DEFAULT_SEP "+"
+
+static const char *sieve_subaddress_sep = SUBADDRESS_DEFAULT_SEP;
+
+/*
+ * Forward declarations 
+ */
+
+const struct sieve_address_part user_address_part;
+const struct sieve_address_part detail_address_part;
+
+static struct sieve_operand subaddress_operand;
+
+/*
+ * Extension
+ */
+
+static bool ext_subaddress_load(void);
+static bool ext_subaddress_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension subaddress_extension = { 
+	"subaddress", 
+	&ext_my_id,
+	ext_subaddress_load, 
+	NULL,
+	ext_subaddress_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_OPERAND(subaddress_operand)
+};
+
+static bool ext_subaddress_load(void)
+{
+	sieve_subaddress_sep = getenv("SIEVE_SUBADDRESS_SEP");
+
+	if ( sieve_subaddress_sep == NULL )
+		sieve_subaddress_sep = SUBADDRESS_DEFAULT_SEP;
+
+	return TRUE;
+}
+
+static bool ext_subaddress_validator_load(struct sieve_validator *validator)
+{
+	sieve_address_part_register(validator, &user_address_part); 
+	sieve_address_part_register(validator, &detail_address_part); 
+
+	return TRUE;
+}
+
+/*
+ * Address parts
+ */
+ 
+enum ext_subaddress_address_part {
+  SUBADDRESS_USER,
+  SUBADDRESS_DETAIL
+};
+
+/* Forward declarations */
+
+static const char *subaddress_user_extract_from
+	(const struct sieve_address *address);
+static const char *subaddress_detail_extract_from
+	(const struct sieve_address *address);
+
+
+/* Address part objects */	
+
+const struct sieve_address_part user_address_part = {
+	SIEVE_OBJECT("user", &subaddress_operand, SUBADDRESS_USER),
+	subaddress_user_extract_from
+};
+
+const struct sieve_address_part detail_address_part = {
+	SIEVE_OBJECT("detail", &subaddress_operand, SUBADDRESS_DETAIL),
+	subaddress_detail_extract_from
+};
+
+/* Address part implementation */
+
+static const char *subaddress_user_extract_from
+	(const struct sieve_address *address)
+{
+	const char *sep;
+
+	sep = strstr(address->local_part, sieve_subaddress_sep);
+	
+	if ( sep == NULL ) return address->local_part;
+	
+	return t_strdup_until(address->local_part, sep);
+}
+
+static const char *subaddress_detail_extract_from
+	(const struct sieve_address *address)
+{
+	const char *sep;
+
+	if ( (sep=strstr(address->local_part, sieve_subaddress_sep)) == NULL )
+		return NULL; 
+
+	sep += strlen(sieve_subaddress_sep);
+
+	/* Just to be sure */
+	if ( sep > (address->local_part + strlen(address->local_part)) ) 
+		return NULL;
+
+	return sep;
+}
+
+/*
+ * Operand 
+ */
+
+const struct sieve_address_part *ext_subaddress_parts[] = {
+	&user_address_part, &detail_address_part
+};
+
+static const struct sieve_extension_objects ext_address_parts =
+	SIEVE_EXT_DEFINE_ADDRESS_PARTS(ext_subaddress_parts);
+
+static struct sieve_operand subaddress_operand = { 
+	"address-part", 
+	&subaddress_extension, 0,
+	&sieve_address_part_operand_class,
+	&ext_address_parts
+};
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/subaddress/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,11 @@
+noinst_LTLIBRARIES = libsieve_ext_subaddress.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+libsieve_ext_subaddress_la_SOURCES = \
+	ext-subaddress.c
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/cmd-vacation.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "md5.h"
+#include "hostpid.h"
+#include "str-sanitize.h"
+#include "message-address.h"
+#include "message-date.h"
+#include "ioloop.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-actions.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-message.h"
+
+#include "ext-vacation-common.h"
+
+#include <stdio.h>
+
+/* 
+ * Forward declarations 
+ */
+ 
+static const struct sieve_argument vacation_days_tag;
+static const struct sieve_argument vacation_subject_tag;
+static const struct sieve_argument vacation_from_tag;
+static const struct sieve_argument vacation_addresses_tag;
+static const struct sieve_argument vacation_mime_tag;
+static const struct sieve_argument vacation_handle_tag;
+
+/* 
+ * Vacation command 
+ *	
+ * Syntax: 
+ *    vacation [":days" number] [":subject" string]
+ *                 [":from" string] [":addresses" string-list]
+ *                 [":mime"] [":handle" string] <reason: string>
+ */
+
+static bool cmd_vacation_registered
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg);
+static bool cmd_vacation_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd); 
+static bool cmd_vacation_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_vacation_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command vacation_command = { 
+	"vacation",
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE, 
+	cmd_vacation_registered,
+	cmd_vacation_pre_validate, 
+	cmd_vacation_validate, 
+	cmd_vacation_generate, 
+	NULL 
+};
+
+/*
+ * Vacation command tags
+ */
+
+/* Forward declarations */
+
+static bool cmd_vacation_validate_number_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_vacation_validate_string_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_vacation_validate_stringlist_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool cmd_vacation_validate_mime_tag
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument objects */
+
+static const struct sieve_argument vacation_days_tag = { 
+	"days", 
+	NULL, NULL,
+	cmd_vacation_validate_number_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_subject_tag = { 
+	"subject", 
+	NULL, NULL,
+	cmd_vacation_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_from_tag = { 
+	"from", 
+	NULL, NULL,
+	cmd_vacation_validate_string_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_addresses_tag = { 
+	"addresses", 
+	NULL, NULL,
+	cmd_vacation_validate_stringlist_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument vacation_mime_tag = { 
+	"mime",	
+	NULL, NULL, 
+	cmd_vacation_validate_mime_tag,
+	NULL, NULL
+};
+
+static const struct sieve_argument vacation_handle_tag = { 
+	"handle", 
+	NULL, NULL, 
+	cmd_vacation_validate_string_tag, 
+	NULL, NULL 
+};
+
+/* Codes for optional arguments */
+
+enum cmd_vacation_optional {
+	OPT_END,
+	OPT_DAYS,
+	OPT_SUBJECT,
+	OPT_FROM,
+	OPT_ADDRESSES,
+	OPT_MIME
+};
+
+/* 
+ * Vacation operation 
+ */
+
+static bool ext_vacation_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int ext_vacation_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation vacation_operation = { 
+	"VACATION",
+	&vacation_extension,
+	0,
+	ext_vacation_operation_dump, 
+	ext_vacation_operation_execute
+};
+
+/* 
+ * Vacation action 
+ */
+
+/* Forward declarations */
+
+static int act_vacation_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+int act_vacation_check_conflict
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_vacation_print
+	(const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *context, bool *keep);	
+static bool act_vacation_commit
+	(const struct sieve_action *action,	const struct sieve_action_exec_env *aenv, 
+		void *tr_context, bool *keep);
+
+/* Action object */
+
+const struct sieve_action act_vacation = {
+	"vacation",
+	SIEVE_ACTFLAG_SENDS_RESPONSE,
+	NULL,
+	act_vacation_check_duplicate, 
+	act_vacation_check_conflict,
+	act_vacation_print,
+	NULL, NULL,
+	act_vacation_commit,
+	NULL
+};
+
+/* Action context information */
+		
+struct act_vacation_context {
+	const char *reason;
+
+	sieve_number_t days;
+	const char *subject;
+	const char *handle;
+	bool mime;
+	const char *from;
+	const char *from_normalized;	
+	const char *const *addresses;
+};
+
+/*
+ * Command validation context
+ */
+ 
+struct cmd_vacation_context_data {
+	string_t *from;
+	string_t *subject;
+	
+	bool mime;
+	
+	string_t *handle;
+};
+
+/* 
+ * Tag validation 
+ */
+
+static bool cmd_vacation_validate_number_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :days number
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+
+	/* Enforce :days > 0 */
+	if ( sieve_ast_argument_number(*arg) == 0 ) {
+		sieve_ast_argument_number_set(*arg, 1);
+	}
+
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_string_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) cmd->data; 
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :subject string
+	 *   :from string
+	 *   :handle string
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	if ( tag->argument == &vacation_from_tag ) {
+		if ( sieve_argument_is_string_literal(*arg) ) {
+			string_t *address = sieve_ast_argument_str(*arg);
+			const char *error;
+	 		bool result;
+	 		
+	 		T_BEGIN {
+	 			result = sieve_address_validate(address, &error);
+	 
+				if ( !result ) {
+					sieve_argument_validate_error(validator, *arg, 
+						"specified :from address '%s' is invalid for vacation action: %s", 
+						str_sanitize(str_c(address), 128), error);
+				}
+			} T_END;
+		
+			if ( !result )
+				return FALSE;
+		}
+		
+		ctx_data->from = sieve_ast_argument_str(*arg);
+		
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+		
+	} else if ( tag->argument == &vacation_subject_tag ) {
+		ctx_data->subject = sieve_ast_argument_str(*arg);
+		
+		/* Skip parameter */
+		*arg = sieve_ast_argument_next(*arg);
+		
+	} else if ( tag->argument == &vacation_handle_tag ) {
+		ctx_data->handle = sieve_ast_argument_str(*arg);
+		
+		/* Detach optional argument (emitted as mandatory) */
+		*arg = sieve_ast_arguments_detach(*arg,1);
+	}
+			
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_stringlist_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_ast_argument *tag = *arg;
+
+	/* Detach the tag itself */
+	*arg = sieve_ast_arguments_detach(*arg,1);
+	
+	/* Check syntax:
+	 *   :addresses string-list
+	 */
+	if ( !sieve_validate_tag_parameter
+		(validator, cmd, tag, *arg, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	/* Skip parameter */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool cmd_vacation_validate_mime_tag
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) cmd->data; 
+
+	ctx_data->mime = TRUE;
+
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	return TRUE;
+}
+
+/* 
+ * Command registration 
+ */
+
+static bool cmd_vacation_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_days_tag, OPT_DAYS); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_subject_tag, OPT_SUBJECT); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_from_tag, OPT_FROM); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_addresses_tag, OPT_ADDRESSES); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_mime_tag, OPT_MIME); 	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &vacation_handle_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+ 
+static bool cmd_vacation_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd) 
+{
+	struct cmd_vacation_context_data *ctx_data;
+	
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(cmd), 
+		struct cmd_vacation_context_data, 1);
+	cmd->data = ctx_data;
+
+	return TRUE;
+}
+
+static const char _handle_empty_subject[] = "<default-subject>";
+static const char _handle_empty_from[] = "<default-from>";
+static const char _handle_mime_enabled[] = "<MIME>";
+static const char _handle_mime_disabled[] = "<NO-MIME>";
+
+static bool cmd_vacation_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{ 	
+	struct sieve_ast_argument *arg = cmd->first_positional;
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) cmd->data; 
+
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "reason", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, cmd, arg, FALSE) )
+		return FALSE;
+		
+	/* Construct handle if not set explicitly */
+	if ( ctx_data->handle == NULL ) {
+		string_t *reason = sieve_ast_argument_str(arg);
+		unsigned int size = str_len(reason);
+		
+		/* Precalculate the size of it all */
+		size += ctx_data->subject == NULL ? 
+			sizeof(_handle_empty_subject) - 1 : str_len(ctx_data->subject);
+		size += ctx_data->from == NULL ? 
+			sizeof(_handle_empty_from) - 1 : str_len(ctx_data->from); 
+		size += ctx_data->mime ? 
+			sizeof(_handle_mime_enabled) - 1 : sizeof(_handle_mime_disabled) - 1; 
+			
+		/* Construct the string */
+		ctx_data->handle = str_new(sieve_command_pool(cmd), size);
+		str_append_str(ctx_data->handle, reason);
+		
+		if ( ctx_data->subject != NULL )
+			str_append_str(ctx_data->handle, ctx_data->subject);
+		else
+			str_append(ctx_data->handle, _handle_empty_subject);
+		
+		if ( ctx_data->from != NULL )
+			str_append_str(ctx_data->handle, ctx_data->from);
+		else
+			str_append(ctx_data->handle, _handle_empty_from);
+			
+		str_append(ctx_data->handle, 
+			ctx_data->mime ? _handle_mime_enabled : _handle_mime_disabled );
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_vacation_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	struct cmd_vacation_context_data *ctx_data = 
+		(struct cmd_vacation_context_data *) ctx->data;
+		 
+	sieve_operation_emit_code(cgenv->sbin, &vacation_operation);
+
+	/* Emit source line */
+	sieve_code_source_line_emit(cgenv->sbin, sieve_command_source_line(ctx));
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+
+	/* FIXME: this will not allow the handle to be a variable */
+	sieve_opr_string_emit(cgenv->sbin, ctx_data->handle);
+		
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool ext_vacation_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	int opt_code = 1;
+	
+	sieve_code_dumpf(denv, "VACATION");
+	sieve_code_descend(denv);	
+
+	/* Source line */
+	if ( !sieve_code_source_line_dump(denv, address) )
+		return FALSE;
+
+	/* Dump optional operands */
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			sieve_code_mark(denv);
+			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_DAYS:
+				if ( !sieve_opr_number_dump(denv, address, "days") )
+					return FALSE;
+				break;
+			case OPT_SUBJECT:
+				if ( !sieve_opr_string_dump(denv, address, "subject") )
+					return FALSE;
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_dump(denv, address, "from") )
+					return FALSE;
+				break;
+			case OPT_ADDRESSES:
+				if ( !sieve_opr_stringlist_dump(denv, address, "addresses") )
+					return FALSE;
+				break;
+			case OPT_MIME:
+				sieve_code_dumpf(denv, "mime");	
+				break;
+			
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	/* Dump reason and handle operands */
+	return 
+		sieve_opr_string_dump(denv, address, "reason") &&
+		sieve_opr_string_dump(denv, address, "handle");
+}
+
+/* 
+ * Code execution
+ */
+ 
+static int ext_vacation_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct sieve_side_effects_list *slist = NULL;
+	struct act_vacation_context *act;
+	pool_t pool;
+	int opt_code = 1;
+	sieve_number_t days = 7;
+	bool mime = FALSE;
+	struct sieve_coded_stringlist *addresses = NULL;
+	string_t *reason, *subject = NULL, *from = NULL, *handle = NULL; 
+	unsigned int source_line;
+	const char *from_normalized = NULL;
+
+	/*
+	 * Read operands
+	 */
+		
+	/* Source line */
+	if ( !sieve_code_source_line_read(renv, address, &source_line) ) {
+		sieve_runtime_trace_error(renv, "invalid source line");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Optional operands */	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case OPT_DAYS:
+				if ( !sieve_opr_number_read(renv, address, &days) ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid days operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+	
+				/* Enforce days > 0 (just to be sure) */
+				if ( days == 0 )
+					days = 1;
+				break;
+			case OPT_SUBJECT:
+				if ( !sieve_opr_string_read(renv, address, &subject) ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid subject operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_FROM:
+				if ( !sieve_opr_string_read(renv, address, &from) ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid from address operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_ADDRESSES:
+				if ( (addresses=sieve_opr_stringlist_read(renv, address))
+					== NULL ) {
+					sieve_runtime_trace_error(renv, 
+						"invalid addresses operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case OPT_MIME:
+				mime = TRUE;
+				break;
+			default:
+				sieve_runtime_trace_error(renv, 
+					"unknown optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+		}
+	}
+	
+	/* Reason operand */
+	if ( !sieve_opr_string_read(renv, address, &reason) ) {
+		sieve_runtime_trace_error(renv, "invalid reason operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Handle operand */
+	if ( !sieve_opr_string_read(renv, address, &handle) ) {
+		sieve_runtime_trace_error(renv, "invalid handle operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "VACATION action");	
+
+	/* Check and normalize :from address */
+	if ( from != NULL ) {
+		const char *error;
+
+		from_normalized = sieve_address_normalize(from, &error);
+	
+		if ( from_normalized == NULL) {
+			sieve_runtime_error(renv, 
+				sieve_error_script_location(renv->script, source_line),
+				"specified :from address '%s' is invalid for vacation action: %s",
+				str_sanitize(str_c(from), 128), error);
+   		}
+	}
+
+	/* Add vacation action to the result */
+
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_vacation_context, 1);
+	act->reason = p_strdup(pool, str_c(reason));
+	act->handle = p_strdup(pool, str_c(handle));
+	act->days = days;
+	act->mime = mime;
+	if ( subject != NULL )
+		act->subject = p_strdup(pool, str_c(subject));
+	if ( from != NULL ) {
+		act->from = p_strdup(pool, str_c(from));
+		act->from_normalized = p_strdup(pool, from_normalized);
+	}
+
+	/* Normalize all addresses */
+	if ( addresses != NULL ) {
+		ARRAY_DEFINE(norm_addresses, const char *);
+		string_t *raw_address;
+		bool result = FALSE;
+		
+		sieve_coded_stringlist_reset(addresses);
+			
+		p_array_init(&norm_addresses, pool, 4);
+		
+		raw_address = NULL;
+		while ( (result=sieve_coded_stringlist_next_item(addresses, &raw_address))
+			&& raw_address != NULL ) {
+			const char *error;
+			const char *addr_norm = sieve_address_normalize(raw_address, &error);
+			
+			if ( addr_norm != NULL ) {
+				addr_norm = p_strdup(pool, addr_norm);
+		
+				array_append(&norm_addresses, &addr_norm, 1);			
+			} else {
+				/* FIXME: report proper warning */
+			}
+		}
+		
+		if ( !result ) {
+			sieve_runtime_trace_error(renv, "invalid addresses stringlist");
+			return SIEVE_EXEC_BIN_CORRUPT;
+		}
+		
+		(void)array_append_space(&norm_addresses);
+		act->addresses = array_idx(&norm_addresses, 0);
+	}	
+		
+	return ( sieve_result_add_action
+		(renv, &act_vacation, slist, source_line, (void *) act, 0) >= 0 );
+}
+
+/*
+ * Action
+ */
+
+/* Runtime verification */
+
+static int act_vacation_check_duplicate
+(const struct sieve_runtime_env *renv ATTR_UNUSED,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( !act_other->executed ) {
+		sieve_runtime_error(renv, act->location, 
+			"duplicate vacation action not allowed "
+			"(previously triggered one was here: %s)", act_other->location);
+		return -1;
+	}
+
+	/* Not an error if executed in preceeding script */
+	return 1;
+}
+
+int act_vacation_check_conflict
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	if ( (act_other->action->flags & SIEVE_ACTFLAG_SENDS_RESPONSE) > 0 ) {
+		if ( !act_other->executed && !act->executed) {
+			sieve_runtime_error(renv, act->location, 
+				"vacation action conflicts with other action: "
+				"the %s action (%s) also sends a response back to the sender",	
+				act_other->action->name, act_other->location);
+			return -1;
+		} else {
+			/* Not an error if executed in preceeding script */
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/* Result printing */
+ 
+static void act_vacation_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, 
+	bool *keep ATTR_UNUSED)	
+{
+	struct act_vacation_context *ctx = (struct act_vacation_context *) context;
+	
+	sieve_result_action_printf( rpenv, "send vacation message:");
+	sieve_result_printf(rpenv, "    => days   : %d\n", ctx->days);
+	if ( ctx->subject != NULL )
+		sieve_result_printf(rpenv, "    => subject: %s\n", ctx->subject);
+	if ( ctx->from != NULL )
+		sieve_result_printf(rpenv, "    => from   : %s\n", ctx->from);
+	if ( ctx->handle != NULL )
+		sieve_result_printf(rpenv, "    => handle : %s\n", ctx->handle);
+	sieve_result_printf(rpenv, "\nSTART MESSAGE\n%s\nEND MESSAGE\n", ctx->reason);
+}
+
+/* Result execution */
+
+/* Headers known to be associated with mailing lists 
+ */
+static const char * const _list_headers[] = {
+	"list-id",
+	"list-owner",
+	"list-subscribe",
+	"list-post",	
+	"list-unsubscribe",
+	"list-help",
+	"list-archive",
+	NULL
+};
+
+/* Headers that should be searched for the user's own mail address(es) 
+ */
+
+static const char * const _my_address_headers[] = {
+	"to",
+	"cc",
+	"bcc",
+	"resent-to",	
+	"resent-cc",
+	"resent-bcc",
+	NULL
+};
+
+static inline bool _is_system_address(const char *address)
+{
+	if ( strncasecmp(address, "MAILER-DAEMON", 13) == 0 )
+		return TRUE;
+
+	if ( strncasecmp(address, "LISTSERV", 8) == 0 )
+		return TRUE;
+
+	if ( strncasecmp(address, "majordomo", 9) == 0 )
+		return TRUE;
+
+	if ( strstr(address, "-request@") != NULL )
+		return TRUE;
+
+	if ( strncmp(address, "owner-", 6) == 0 )
+		return TRUE;
+
+	return FALSE;
+}
+
+static inline bool _contains_my_address
+	(const char * const *headers, const char *my_address)
+{
+	const char *const *hdsp = headers;
+	bool result = FALSE;
+	
+	while ( *hdsp != NULL && !result ) {
+		const struct message_address *addr;
+
+		T_BEGIN {
+	
+			addr = message_address_parse
+				(pool_datastack_create(), (const unsigned char *) *hdsp, 
+					strlen(*hdsp), 256, FALSE);
+
+			while ( addr != NULL && !result ) {
+				if (addr->domain != NULL) {
+					const char *hdr_address; 
+					
+					i_assert(addr->mailbox != NULL);
+
+					hdr_address = t_strconcat(addr->mailbox, "@", addr->domain, NULL);
+					if ( sieve_address_compare(hdr_address, my_address, TRUE) == 0 ) {
+						result = TRUE;
+						break;
+					}
+				}
+
+				addr = addr->next;
+			}
+		} T_END;
+		
+		hdsp++;
+	}
+	
+	return result;
+}
+
+static bool act_vacation_send	
+	(const struct sieve_action_exec_env *aenv, struct act_vacation_context *ctx)
+{
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	void *smtp_handle;
+	FILE *f;
+ 	const char *outmsgid;
+ 	const char *const *headers;
+	int ret;
+
+	/* Check smpt functions just to be sure */
+
+	if ( senv->smtp_open == NULL || senv->smtp_close == NULL ) {
+		sieve_result_warning(aenv, "vacation action has no means to send mail");
+		return TRUE;
+	}
+
+	/* Open smtp session */
+
+	smtp_handle = senv->smtp_open(msgdata->return_path, NULL, &f);
+	outmsgid = sieve_message_get_new_id(senv);
+
+	/* Produce a proper reply */
+
+	rfc2822_header_field_write(f, "X-Sieve", SIEVE_IMPLEMENTATION);    
+	rfc2822_header_field_write(f, "Message-ID", outmsgid);
+	rfc2822_header_field_write(f, "Date", message_date_create(ioloop_time));
+
+	if ( ctx->from != NULL && *(ctx->from) != '\0' )
+		rfc2822_header_field_printf(f, "From", "%s", ctx->from);
+	else
+		rfc2822_header_field_printf(f, "From", "<%s>", msgdata->to_address);
+		
+	/* FIXME: If From header of message has same address, we should use that in 
+	 * stead properly include the phrase part.
+	 */
+	rfc2822_header_field_printf(f, "To", "<%s>", msgdata->return_path);
+
+	rfc2822_header_field_printf(f, "Subject", "%s", 
+		str_sanitize(ctx->subject, 256));
+
+	/* Compose proper in-reply-to and references headers */
+	
+	ret = mail_get_headers
+		(aenv->msgdata->mail, "references", &headers);
+			
+	if ( msgdata->id != NULL ) {
+		rfc2822_header_field_write(f, "In-Reply-To", msgdata->id);
+	
+		if ( ret >= 0 && headers[0] != NULL )
+			rfc2822_header_field_write
+				(f, "References", t_strconcat(headers[0], " ", msgdata->id, NULL));
+		else
+			rfc2822_header_field_write(f, "References", msgdata->id);
+	} else if ( ret >= 0 && headers[0] != NULL ) {
+		rfc2822_header_field_write(f, "References", headers[0]);
+	}
+			
+	rfc2822_header_field_write(f, "Auto-Submitted", "auto-replied (vacation)");
+	rfc2822_header_field_write(f, "Precedence", "bulk");
+	
+	rfc2822_header_field_write(f, "MIME-Version", "1.0");
+    
+	if ( !ctx->mime ) {
+		rfc2822_header_field_write(f, "Content-Type", "text/plain; charset=utf-8");
+		rfc2822_header_field_write(f, "Content-Transfer-Encoding", "8bit");
+		fprintf(f, "\r\n");
+	}
+
+	fprintf(f, "%s\r\n", ctx->reason);
+
+	/* Close smtp session */    
+	if ( !senv->smtp_close(smtp_handle) ) {
+		sieve_result_error(aenv, 
+			"failed to send vacation response to <%s> "
+			"(refer to server log for more information)", 
+			str_sanitize(msgdata->return_path, 128));	
+		return TRUE;
+	}
+	
+	return TRUE;
+}
+
+static void act_vacation_hash
+(const struct sieve_message_data *msgdata, struct act_vacation_context *vctx, 
+	unsigned char hash_r[])
+{
+	const char *rpath = t_str_lcase(msgdata->return_path);
+	struct md5_context ctx;
+
+	md5_init(&ctx);
+	md5_update(&ctx, rpath, strlen(rpath));
+
+	md5_update(&ctx, vctx->handle, strlen(vctx->handle));
+	
+	md5_final(&ctx, hash_r);
+}
+
+static bool act_vacation_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, 
+	bool *keep ATTR_UNUSED)
+{
+	const char *const *hdsp;
+	const struct sieve_message_data *msgdata = aenv->msgdata;
+	const struct sieve_script_env *senv = aenv->scriptenv;
+	struct act_vacation_context *ctx = (struct act_vacation_context *) tr_context;
+	unsigned char dupl_hash[MD5_RESULTLEN];
+	const char *const *headers;
+	pool_t pool;
+
+	/* Is the return_path unset ?
+	 */
+	if ( msgdata->return_path == NULL || *(msgdata->return_path) == '\0' ) {
+		sieve_result_log(aenv, "discarded vacation reply to <>");
+		return TRUE;
+	}    
+	
+	/* Are we perhaps trying to respond to ourselves ? 
+	 * (FIXME: verify this to :addresses as well?)
+	 */
+	if ( sieve_address_compare(msgdata->return_path, msgdata->to_address, TRUE) 
+		== 0 ) {
+		sieve_result_log(aenv, "discarded vacation reply to own address");	
+		return TRUE;
+	}
+	
+	/* Did whe respond to this user before? */
+	if ( senv->duplicate_check != NULL ) {
+		act_vacation_hash(msgdata, ctx, dupl_hash);
+	
+		if ( senv->duplicate_check(dupl_hash, sizeof(dupl_hash), senv->username) ) 
+		{
+			sieve_result_log(aenv, "discarded duplicate vacation response to <%s>",
+				str_sanitize(msgdata->return_path, 128));
+			return TRUE;
+		}
+	}
+	
+	/* Are we trying to respond to a mailing list ? */
+	hdsp = _list_headers;
+	while ( *hdsp != NULL ) {
+		if ( mail_get_headers
+			(msgdata->mail, *hdsp, &headers) >= 0 && headers[0] != NULL ) {	
+			/* Yes, bail out */
+			sieve_result_log(aenv, 
+				"discarding vacation response to mailinglist recipient <%s>", 
+				str_sanitize(msgdata->return_path, 128));	
+			return TRUE;				 
+		}
+		hdsp++;
+	}
+	
+	/* Is the message that we are replying to an automatic reply ? */
+	if ( mail_get_headers
+		(msgdata->mail, "auto-submitted", &headers) >= 0 ) {
+		/* Theoretically multiple headers could exist, so lets make sure */
+		hdsp = headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "no") != 0 ) {
+				sieve_result_log(aenv, 
+					"discardig vacation response to auto-submitted message from <%s>", 
+					str_sanitize(msgdata->return_path, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+	
+	/* Check for the (non-standard) precedence header */
+	if ( mail_get_headers
+		(msgdata->mail, "precedence", &headers) >= 0 ) {
+		/* Theoretically multiple headers could exist, so lets make sure */
+		hdsp = headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp(*hdsp, "junk") == 0 || strcasecmp(*hdsp, "bulk") == 0 ||
+				strcasecmp(*hdsp, "list") == 0 ) {
+				sieve_result_log(aenv, 
+					"discarding vacation response to precedence=%s message from <%s>", 
+					*hdsp, str_sanitize(msgdata->return_path, 128));	
+					return TRUE;				 
+			}
+			hdsp++;
+		}
+	}
+	
+	/* Do not reply to system addresses */
+	if ( _is_system_address(msgdata->return_path) ) {
+		sieve_result_log(aenv, 
+			"not sending vacation response to system address <%s>", 
+			str_sanitize(msgdata->return_path, 128));	
+		return TRUE;				
+	} 
+	
+	/* Is the original message directly addressed to the user or the addresses
+	 * specified using the :addresses tag? 
+	 */
+	hdsp = _my_address_headers;
+	while ( *hdsp != NULL ) {
+		if ( mail_get_headers_utf8
+			(msgdata->mail, *hdsp, &headers) >= 0 && headers[0] != NULL ) {	
+			
+			if ( _contains_my_address(headers, msgdata->to_address) ) 
+				break;
+			
+			if ( ctx->addresses != NULL ) {
+				bool found = FALSE;
+				const char * const *my_address = ctx->addresses;
+		
+				while ( !found && *my_address != NULL ) {
+					found = _contains_my_address(headers, *my_address);
+					my_address++;
+				}
+				
+				if ( found ) break;
+			}
+		}
+		hdsp++;
+	}	
+
+	if ( *hdsp == NULL ) {
+		/* No, bail out */
+		sieve_result_log(aenv, 
+			"discarding vacation response for message implicitly delivered to <%s>",
+			( msgdata->to_address == NULL ? "UNKNOWN" : msgdata->to_address ) );	
+		return TRUE;				 
+	}	
+		
+	/* Make sure we have a subject for our reply */
+	if ( ctx->subject == NULL || *(ctx->subject) == '\0' ) {
+		if ( mail_get_headers_utf8
+			(msgdata->mail, "subject", &headers) >= 0 && headers[0] != NULL ) {
+			pool = sieve_result_pool(aenv->result);
+			ctx->subject = p_strconcat(pool, "Auto: ", headers[0], NULL);
+		}	else {
+			ctx->subject = "Automated reply";
+		}
+	}	
+	
+	/* Send the message */
+	
+	if ( act_vacation_send(aenv, ctx) ) {
+		sieve_result_log(aenv, "sent vacation response to <%s>", 
+			str_sanitize(msgdata->return_path, 128));	
+
+		/* Mark as replied */
+		if ( senv->duplicate_mark != NULL )
+			senv->duplicate_mark(dupl_hash, sizeof(dupl_hash), senv->username,
+				ioloop_time + ctx->days * (24 * 60 * 60));
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,52 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension vacation
+ * ------------------
+ *
+ * Authors: Stephan Bosch <stephan@rename-it.nl>
+ * Specification: RFC 5230
+ * Implementation: almost complete; the required sopport for Refences header 
+ *   is missing.
+ * Status: experimental, largely untested
+ * 
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-vacation-common.h"
+
+/* 
+ * Extension
+ */
+
+static bool ext_vacation_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension vacation_extension = { 
+	"vacation",
+	&ext_my_id,
+	NULL, NULL,
+	ext_vacation_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(vacation_operation),
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_vacation_validator_load(struct sieve_validator *validator)
+{
+	/* Register new command */
+	sieve_validator_register_command(validator, &vacation_command);
+
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/ext-vacation-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,25 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VACATION_COMMON_H
+#define __EXT_VACATION_COMMON_H
+
+#include "sieve-common.h"
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command vacation_command;
+
+/* 
+ * Operations 
+ */
+
+extern const struct sieve_operation vacation_operation;
+
+/* Extension */
+
+extern const struct sieve_extension vacation_extension;
+
+#endif /* __EXT_VACATION_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/vacation/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_vacation.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+cmds = \
+	cmd-vacation.c
+
+libsieve_ext_vacation_la_SOURCES = \
+	$(cmds) \
+	ext-vacation.c
+
+noinst_HEADERS = \
+	ext-vacation-common.h
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/cmd-set.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,368 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+
+#include "sieve-code.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-modifiers.h"
+
+/* 
+ * Set command 
+ *	
+ * Syntax: 
+ *    set [MODIFIER] <name: string> <value: string>
+ */
+
+static bool cmd_set_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool cmd_set_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_set_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd);
+static bool cmd_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command cmd_set = { 
+	"set",
+	SCT_COMMAND, 
+	2, 0, FALSE, FALSE, 
+	cmd_set_registered,
+	cmd_set_pre_validate,  
+	cmd_set_validate, 
+	cmd_set_generate, 
+	NULL 
+};
+
+/* 
+ * Set operation 
+ */
+
+static bool cmd_set_operation_dump
+	(const struct sieve_operation *op,	
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_set_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation cmd_set_operation = { 
+	"SET",
+	&variables_extension,
+	EXT_VARIABLES_OPERATION_SET,
+	cmd_set_operation_dump, 
+	cmd_set_operation_execute
+};
+
+/* 
+ * Compiler context 
+ */
+
+struct cmd_set_context {
+	ARRAY_DEFINE(modifiers, const struct sieve_variables_modifier *);
+};
+
+/* 
+ * Set modifier tag
+ *
+ * [MODIFIER]:
+ *   ":lower" / ":upper" / ":lowerfirst" / ":upperfirst" /
+ *             ":quotewildcard" / ":length"
+ */
+
+/* Forward declarations */
+ 
+static bool tag_modifier_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmdctx,	
+		struct sieve_ast_argument *arg);	
+static bool tag_modifier_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+
+/* Modifier tag object */
+
+const struct sieve_argument modifier_tag = { 
+	"MODIFIER",
+	tag_modifier_is_instance_of, 
+	NULL,
+	tag_modifier_validate, 
+	NULL, NULL
+};
+ 
+/* Modifier tag implementation */ 
+ 
+static bool tag_modifier_is_instance_of
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmdctx ATTR_UNUSED,	
+	struct sieve_ast_argument *arg)
+{	
+	const struct sieve_variables_modifier *modf = ext_variables_modifier_find
+		(validator, sieve_ast_argument_tag(arg));
+
+	arg->context = (void *) modf;
+		
+	return ( modf != NULL );
+}
+
+static bool tag_modifier_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	unsigned int i;
+	bool inserted;
+	const struct sieve_variables_modifier *modf = 
+		(const struct sieve_variables_modifier *) (*arg)->context;
+	struct cmd_set_context *sctx = (struct cmd_set_context *) cmd->data;
+	
+	inserted = FALSE;
+	for ( i = 0; i < array_count(&sctx->modifiers) && !inserted; i++ ) {
+		const struct sieve_variables_modifier * const *smdf =
+			array_idx(&sctx->modifiers, i);
+	
+		if ( (*smdf)->precedence == modf->precedence ) {
+			sieve_argument_validate_error(validator, *arg, 
+				"modifiers :%s and :%s specified for the set command conflict "
+				"having equal precedence", 
+				(*smdf)->object.identifier, modf->object.identifier);
+			return FALSE;
+		}
+			
+		if ( (*smdf)->precedence < modf->precedence ) {
+			array_insert(&sctx->modifiers, i, &modf, 1);
+			inserted = TRUE;
+		}
+	}
+	
+	if ( !inserted )
+		array_append(&sctx->modifiers, &modf, 1);
+	
+	/* Added to modifier list; self-destruct to prevent duplicate generation */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+	
+	return TRUE;
+}
+
+/* Command registration */
+
+static bool cmd_set_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	sieve_validator_register_tag(validator, cmd_reg, &modifier_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Command validation 
+ */
+
+static bool cmd_set_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd)
+{
+	pool_t pool = sieve_command_pool(cmd);
+	struct cmd_set_context *sctx = p_new(pool, struct cmd_set_context, 1);
+	
+	/* Create an array for the sorted list of modifiers */
+	p_array_init(&sctx->modifiers, pool, 2);
+
+	cmd->data = (void *) sctx;
+	
+	return TRUE;
+} 
+
+static bool cmd_set_validate(struct sieve_validator *validator, 
+	struct sieve_command_context *cmd) 
+{ 
+	struct sieve_ast_argument *arg = cmd->first_positional;
+		
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "name", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_variable_argument_activate(validator, cmd, arg, TRUE) ) {
+		return FALSE;
+	}
+
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(validator, cmd, arg, "value", 2, SAAT_STRING) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, cmd, arg, FALSE);	
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_set_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct cmd_set_context *sctx = (struct cmd_set_context *) ctx->data;
+	unsigned int i;	
+
+	sieve_operation_emit_code(sbin, &cmd_set_operation); 
+
+	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;	
+		
+	/* Generate modifiers (already sorted during validation) */
+	sieve_binary_emit_byte(sbin, array_count(&sctx->modifiers));
+	for ( i = 0; i < array_count(&sctx->modifiers); i++ ) {
+		const struct sieve_variables_modifier * const * modf =
+			array_idx(&sctx->modifiers, i);
+			
+		ext_variables_opr_modifier_emit(sbin, *modf);
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Code dump
+ */
+ 
+static bool cmd_set_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{	
+	unsigned int mdfs, i;
+	
+	sieve_code_dumpf(denv, "SET");
+	sieve_code_descend(denv);
+	
+	/* Print both variable name and string value */
+	if ( !sieve_opr_string_dump(denv, address, "variable") ||
+		!sieve_opr_string_dump(denv, address, "value") )
+		return FALSE;
+	
+	/* Read the number of applied modifiers we need to read */
+	if ( !sieve_binary_read_byte(denv->sbin, address, &mdfs) ) 
+		return FALSE;
+	
+	/* Print all modifiers (sorted during code generation already) */
+	for ( i = 0; i < mdfs; i++ ) {
+		if ( !ext_variables_opr_modifier_dump(denv, address) )
+			return FALSE;
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Code execution
+ */
+ 
+static int cmd_set_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	struct sieve_variable_storage *storage;
+	unsigned int var_index, mdfs, i;
+	string_t *value;
+	int ret = SIEVE_EXEC_OK;
+
+	/*
+	 * Read the normal operands
+	 */
+		
+	/* Read the variable */
+	if ( !sieve_variable_operand_read
+		(renv, address, &storage, &var_index) ) {
+		sieve_runtime_trace_error(renv, "invalid variable operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read the raw string value */
+	if ( !sieve_opr_string_read(renv, address, &value) ) {
+		sieve_runtime_trace_error(renv, "invalid string operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read the number of modifiers used */
+	if ( !sieve_binary_read_byte(renv->sbin, address, &mdfs) ) {
+		sieve_runtime_trace_error(renv, "invalid modifier count");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* 
+	 * Determine and assign the value 
+	 */
+
+	sieve_runtime_trace(renv, "SET action");
+
+	/* Hold value within limits */
+	if ( str_len(value) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+		str_truncate(value, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+
+	T_BEGIN {
+		/* Apply modifiers if necessary (sorted during code generation already) */
+		if ( str_len(value) > 0 ) {
+			for ( i = 0; i < mdfs; i++ ) {
+				string_t *new_value;
+				const struct sieve_variables_modifier *modf =
+					ext_variables_opr_modifier_read(renv, address);
+
+				if ( modf == NULL ) {
+					value = NULL;
+
+					sieve_runtime_trace_error(renv, "invalid modifier operand");
+					ret = SIEVE_EXEC_BIN_CORRUPT;
+					break;
+				}
+				
+				if ( modf->modify != NULL ) {
+					if ( !modf->modify(value, &new_value) ) {
+						value = NULL;
+						ret = SIEVE_EXEC_FAILURE;
+						break;
+					}
+
+					value = new_value;
+					if ( value == NULL )
+						break;
+
+					/* Hold value within limits */
+					if ( str_len(value) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+						str_truncate(value, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+				}
+			}
+		}	
+		
+		/* Actually assign the value if all is well */
+		if ( value != NULL ) {
+			if ( !sieve_variable_assign(storage, var_index, value) )
+				ret = SIEVE_EXEC_BIN_CORRUPT;
+		}	
+	} T_END;
+			
+	if ( ret <= 0 ) 
+		return ret;		
+
+	return ( value != NULL );
+}
+
+
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,438 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-limits.h"
+#include "ext-variables-name.h"
+#include "ext-variables-arguments.h"
+
+/*
+ * Common error messages
+ */
+
+static inline void _ext_variables_scope_size_error
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	const char *variable)
+{
+	sieve_argument_validate_error(valdtr, arg, 
+		"(implicit) declaration of new variable '%s' exceeds the limit "
+		"(max variables: %u)", variable, 
+		SIEVE_VARIABLES_MAX_SCOPE_SIZE);
+}
+
+static inline void _ext_variables_match_index_error
+(struct sieve_validator *valdtr, struct sieve_ast_argument *arg,
+	unsigned int variable_index)
+{
+	sieve_argument_validate_error(valdtr, arg, 
+		"match value index %u out of range (max: %u)", variable_index, 
+		SIEVE_VARIABLES_MAX_MATCH_INDEX);
+}
+
+/* 
+ * Variable argument 
+ */
+
+static bool arg_variable_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument variable_argument = { 
+	"@variable", 
+	NULL, NULL, NULL, NULL,
+	arg_variable_generate 
+};
+
+static struct sieve_ast_argument *ext_variables_variable_argument_create
+(struct sieve_validator *validator, struct sieve_ast *ast, 
+	unsigned int source_line, const char *variable)
+{
+	struct sieve_variable *var;
+	struct sieve_ast_argument *arg;
+	
+	var = ext_variables_validator_get_variable(validator, variable, TRUE);
+
+	if ( var == NULL ) 
+		return NULL;
+	
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = &variable_argument;
+	arg->context = (void *) var;
+	
+	return arg;
+}
+
+static bool _sieve_variable_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd ATTR_UNUSED, 
+	struct sieve_ast_argument *arg, bool assignment)
+{
+	bool result = FALSE;
+	struct sieve_variable *var;
+	string_t *variable;
+	const char *varstr, *varend;
+	ARRAY_TYPE(ext_variable_name) vname;	
+	int nelements = 0;
+
+	T_BEGIN {
+		t_array_init(&vname, 2);			
+	
+		variable = sieve_ast_argument_str(arg);
+		varstr = str_c(variable);
+		varend = PTR_OFFSET(varstr, str_len(variable));
+		nelements = ext_variable_name_parse(&vname, &varstr, varend);
+
+		/* Check whether name parsing succeeded */	
+		if ( nelements < 0 || varstr != varend ) {
+			/* Parse failed */
+			sieve_argument_validate_error(validator, arg, 
+				"invalid variable name '%s'", str_sanitize(str_c(variable),80));
+		} else if ( nelements == 1 ) {
+			/* Normal (match) variable */
+
+			const struct ext_variable_name *cur_element = 
+				array_idx(&vname, 0);
+
+			if ( cur_element->num_variable < 0 ) {
+				/* Variable */
+				var = ext_variables_validator_get_variable
+					(validator, str_c(cur_element->identifier), TRUE);
+
+				if ( var == NULL ) {
+					_ext_variables_scope_size_error
+						(validator, arg, str_c(cur_element->identifier));
+				} else {
+					arg->argument = &variable_argument;
+					arg->context = (void *) var;
+				
+					result = TRUE;
+				}
+			} else {
+				/* Match value */
+				if ( !assignment ) {
+					if ( cur_element->num_variable > SIEVE_VARIABLES_MAX_MATCH_INDEX ) {
+						_ext_variables_match_index_error
+							(validator, arg, cur_element->num_variable);
+					} else {
+						arg->argument = &match_value_argument;
+						arg->context = POINTER_CAST(cur_element->num_variable);
+										
+						result = TRUE;
+					}
+				} else {		
+					sieve_argument_validate_error(validator, arg, 
+						"cannot assign to match variable");
+				}
+			}
+		} else {
+			/* Namespace variable */
+
+			const struct ext_variable_name *cur_element = 
+				array_idx(&vname, 0);
+
+			/* FIXME: Variable namespaces unsupported. */
+	
+			/* References to namespaces without a prior require statement for 
+			 * the relevant extension MUST cause an error.
+			 */
+
+			sieve_argument_validate_error(validator, arg, 
+				"cannot %s to variable in unknown namespace '%s'", 
+				assignment ? "assign" : "refer", str_c(cur_element->identifier));
+		}
+	} T_END;
+
+	return result;
+}
+
+bool sieve_variable_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool assignment)
+{
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		/* Single string */
+		return _sieve_variable_argument_activate(validator, cmd, arg, assignment);
+		
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		/* String list */
+		struct sieve_ast_argument *stritem;
+		
+		i_assert ( !assignment );
+		
+		stritem = sieve_ast_strlist_first(arg);
+		while ( stritem != NULL ) {
+			if ( !_sieve_variable_argument_activate
+				(validator, cmd, stritem, assignment) )
+				return FALSE;
+			
+			stritem = sieve_ast_strlist_next(stritem);
+
+		}
+		
+		arg->argument = &string_list_argument;
+		
+		return TRUE;
+	} 
+	
+	return FALSE;
+}
+
+static bool arg_variable_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	struct sieve_variable *var = (struct sieve_variable *) arg->context;
+	
+	ext_variables_opr_variable_emit(cgenv->sbin, var);
+
+	return TRUE;
+}
+
+/* 
+ * Match value argument 
+ */
+
+static bool arg_match_value_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED);
+
+const struct sieve_argument match_value_argument = { 
+	"@match_value", 
+	NULL, NULL, NULL, NULL,
+	arg_match_value_generate 
+};
+
+static struct sieve_ast_argument *ext_variables_match_value_argument_create
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast *ast, 
+	unsigned int source_line,	unsigned int index)
+{
+	struct sieve_ast_argument *arg;
+	
+	arg = sieve_ast_argument_create(ast, source_line);
+	arg->type = SAAT_STRING;
+	arg->argument = &match_value_argument;
+	arg->context = POINTER_CAST(index);
+	
+	return arg;
+}
+
+static bool arg_match_value_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	unsigned int index = POINTER_CAST_TO(arg->context, unsigned int);
+	
+	ext_variables_opr_match_value_emit(cgenv->sbin, index);
+
+	return TRUE;
+}
+
+/* 
+ * Variable string argument 
+ */
+
+static bool arg_variable_string_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+
+const struct sieve_argument variable_string_argument = { 
+	"@variable-string", 
+	NULL, NULL,
+	arg_variable_string_validate, 
+	NULL, 
+	sieve_arg_catenated_string_generate,
+};
+
+static bool arg_variable_string_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd)
+{
+	enum { ST_NONE, ST_OPEN, ST_VARIABLE, ST_CLOSE } state = ST_NONE;
+	pool_t pool = sieve_ast_pool((*arg)->ast);
+	struct sieve_arg_catenated_string *catstr = NULL;
+	string_t *str = sieve_ast_argument_str(*arg);
+	const char *p, *strstart, *substart = NULL;
+	const char *strval = (const char *) str_data(str);
+	const char *strend = strval + str_len(str);
+	bool result = TRUE;
+
+	ARRAY_TYPE(ext_variable_name) substitution;	
+	int nelements = 0;
+	
+	T_BEGIN {
+		/* Initialize substitution structure */
+		t_array_init(&substitution, 2);		
+	
+		p = strval;
+		strstart = p;
+		while ( result && p < strend ) {
+			switch ( state ) {
+
+			/* Nothing found yet */
+			case ST_NONE:
+				if ( *p == '$' ) {
+					substart = p;
+					state = ST_OPEN;
+				}
+				p++;
+				break;
+
+			/* Got '$' */
+			case ST_OPEN:
+				if ( *p == '{' ) {
+					state = ST_VARIABLE;
+					p++;
+				} else 
+					state = ST_NONE;
+				break;
+
+			/* Got '${' */ 
+			case ST_VARIABLE:
+				nelements = ext_variable_name_parse(&substitution, &p, strend);
+			
+				if ( nelements < 0 )
+					state = ST_NONE;
+				else 
+					state = ST_CLOSE;
+			
+				break;
+
+			/* Finished parsing name, expecting '}' */
+			case ST_CLOSE:
+				if ( *p == '}' ) {				
+					struct sieve_ast_argument *strarg;
+				
+					/* We now know that the substitution is valid */	
+					
+					if ( catstr == NULL ) {
+						catstr = sieve_arg_catenated_string_create(*arg);
+					}
+				
+					/* Add the substring that is before the substitution to the 
+					 * variable-string AST.
+					 *
+					 * FIXME: For efficiency, if the variable is not found we should 
+					 * coalesce this substring with the one after the substitution.
+					 */
+					if ( substart > strstart ) {
+						string_t *newstr = str_new(pool, substart - strstart);
+						str_append_n(newstr, strstart, substart - strstart); 
+						
+						strarg = sieve_ast_argument_string_create_raw
+							((*arg)->ast, newstr, (*arg)->source_line);
+						sieve_arg_catenated_string_add_element(catstr, strarg);
+					
+						/* Give other substitution extensions a chance to do their work */
+						if ( !sieve_validator_argument_activate_super
+							(validator, cmd, strarg, FALSE) ) {
+							result = FALSE;
+							break;
+						}
+					}
+				
+					/* Find the variable */
+					if ( nelements == 1 ) {
+						const struct ext_variable_name *cur_element = 
+							array_idx(&substitution, 0);
+						
+						if ( cur_element->num_variable == -1 ) {
+							/* Add variable argument '${identifier}' */
+							string_t *cur_ident = cur_element->identifier; 
+						
+							strarg = ext_variables_variable_argument_create
+								(validator, (*arg)->ast, (*arg)->source_line, str_c(cur_ident));
+							if ( strarg != NULL )
+								sieve_arg_catenated_string_add_element(catstr, strarg);
+							else {
+								_ext_variables_scope_size_error
+									(validator, *arg, str_c(cur_element->identifier));
+								result = FALSE;
+								break;
+							}
+						} else {
+							/* Add match value argument '${000}' */
+							if ( cur_element->num_variable > SIEVE_VARIABLES_MAX_MATCH_INDEX ) {
+								_ext_variables_match_index_error
+									(validator, *arg, cur_element->num_variable);
+								result = FALSE;
+								break;
+							}
+
+							strarg = ext_variables_match_value_argument_create
+								(validator, (*arg)->ast, (*arg)->source_line, 
+								cur_element->num_variable);
+							if ( strarg != NULL )
+								sieve_arg_catenated_string_add_element(catstr, strarg);
+						}
+					} else {
+						const struct ext_variable_name *cur_element = 
+							array_idx(&substitution, 0);
+
+						/* FIXME: Namespaces are not supported. */
+
+						/* References to namespaces without a prior require 
+						 * statement for thecrelevant extension MUST cause an error.
+					 	 */
+						sieve_argument_validate_error(validator, *arg, 
+							"referring to variable in unknown namespace '%s'", 
+							str_c(cur_element->identifier));
+						result = FALSE;
+						break;
+					}
+				
+					strstart = p + 1;
+					substart = strstart;
+
+					p++;	
+				}
+		
+				/* Finished, reset for the next substitution */	
+				state = ST_NONE;
+			}
+		}
+	} T_END;
+
+	/* Bail out early if substitution is invalid */
+	if ( !result ) return FALSE;
+	
+	/* Check whether any substitutions were found */
+	if ( catstr == NULL ) {
+		/* No substitutions in this string, pass it on to any other substution
+		 * extension.
+		 */
+		return sieve_validator_argument_activate_super(validator, cmd, *arg, TRUE);
+	}
+	
+	/* Add the final substring that comes after the last substitution to the 
+	 * variable-string AST.
+	 */
+	if ( strend > strstart ) {
+		struct sieve_ast_argument *strarg;
+		string_t *newstr = str_new(pool, strend - strstart);
+		str_append_n(newstr, strstart, strend - strstart); 
+
+		strarg = sieve_ast_argument_string_create_raw
+			((*arg)->ast, newstr, (*arg)->source_line);
+		sieve_arg_catenated_string_add_element(catstr, strarg);
+			
+		/* Give other substitution extensions a chance to do their work */	
+		if ( !sieve_validator_argument_activate_super
+			(validator, cmd, strarg, FALSE) )
+			return FALSE;
+	}	
+	
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-arguments.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_ARGUMENTS_H
+#define __EXT_VARIABLES_ARGUMENTS_H
+
+#include "sieve-common.h"
+
+/* 
+ * Variable argument 
+ */
+
+extern const struct sieve_argument variable_argument;
+
+/* 
+ * Match value argument 
+ */
+
+extern const struct sieve_argument match_value_argument;
+
+/* 
+ * Variable string argument 
+ */
+
+extern const struct sieve_argument variable_string_argument;
+
+#endif /* __EXT_VARIABLES_ARGUMENTS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,90 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension variables 
+ * -------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: RFC 5229
+ * Implementation: mostly full; no support for future namespaces
+ * Status: experimental, not thoroughly tested
+ *
+ */
+ 
+/* FIXME: This implementation of the variables extension does not support 
+ * namespaces. It recognizes them, but there is currently no support to let
+ * an extension register a new namespace. Currently no such extension exists 
+ * and therefore this support has a very low implementation priority.
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "unichar.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-validator.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-arguments.h"
+#include "ext-variables-operands.h"
+#include "ext-variables-modifiers.h"
+#include "ext-variables-dump.h"
+
+/* 
+ * Operations 
+ */
+
+const struct sieve_operation *ext_variables_operations[] = {
+	&cmd_set_operation, 
+	&tst_string_operation
+};
+
+/* 
+ * Operands 
+ */
+
+const struct sieve_operand *ext_variables_operands[] = {
+	&variable_operand, 
+	&match_value_operand,
+	&modifier_operand
+};
+
+/* 
+ * Extension 
+ */
+
+static bool ext_variables_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+	
+const struct sieve_extension variables_extension = { 
+	"variables", 
+	&ext_my_id,
+	NULL, NULL,
+	ext_variables_validator_load, 
+	ext_variables_generator_load,
+	ext_variables_interpreter_load,
+	NULL, NULL, 
+	ext_variables_code_dump,
+	SIEVE_EXT_DEFINE_OPERATIONS(ext_variables_operations), 
+	SIEVE_EXT_DEFINE_OPERANDS(ext_variables_operands)
+};
+
+static bool ext_variables_validator_load
+	(struct sieve_validator *validator)
+{
+	sieve_validator_argument_override(validator, SAT_VAR_STRING, 
+		&variable_string_argument); 
+		
+	sieve_validator_register_command(validator, &cmd_set);
+	sieve_validator_register_command(validator, &tst_string);
+	
+	ext_variables_validator_initialize(validator);
+
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,567 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-objects.h"
+#include "sieve-match-types.h"
+
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-name.h"
+#include "ext-variables-modifiers.h"
+
+/*
+ * Variable scope 
+ */
+
+struct sieve_variable_scope {
+	pool_t pool;
+	int refcount;
+
+	struct sieve_variable *error_var;
+
+	const struct sieve_extension *ext;
+
+	struct hash_table *variables;
+	ARRAY_DEFINE(variable_index, struct sieve_variable *);
+};
+
+struct sieve_variable_scope_iter {
+	struct sieve_variable_scope *scope;
+	struct hash_iterate_context *hctx;
+};
+
+struct sieve_variable_scope *sieve_variable_scope_create
+	(const struct sieve_extension *ext) 
+{
+	struct sieve_variable_scope *scope;
+	pool_t pool;
+
+	pool = pool_alloconly_create("sieve_variable_scope", 4096);
+	scope = p_new(pool, struct sieve_variable_scope, 1);
+	scope->pool = pool;
+	scope->refcount = 1;
+
+	scope->ext = ext;
+	scope->variables = hash_table_create
+		(default_pool, pool, 0, strcase_hash, (hash_cmp_callback_t *)strcasecmp);
+	p_array_init(&scope->variable_index, pool, 128);
+		
+	return scope;
+}
+
+void sieve_variable_scope_ref(struct sieve_variable_scope *scope)
+{
+	scope->refcount++;
+}
+
+void sieve_variable_scope_unref(struct sieve_variable_scope **scope)
+{
+	i_assert((*scope)->refcount > 0);
+
+	if (--(*scope)->refcount != 0)
+		return;
+
+	hash_table_destroy(&(*scope)->variables);
+
+	pool_unref(&(*scope)->pool);
+    *scope = NULL;
+}
+
+pool_t sieve_variable_scope_pool(struct sieve_variable_scope *scope)
+{
+	return scope->pool;
+}
+
+struct sieve_variable *sieve_variable_scope_declare
+(struct sieve_variable_scope *scope, const char *identifier)
+{
+	struct sieve_variable *new_var;
+
+	new_var = p_new(scope->pool, struct sieve_variable, 1);
+	new_var->ext = scope->ext;
+
+	if ( array_count(&scope->variable_index) >= SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		if ( scope->error_var == NULL ) {
+			new_var->identifier = "@ERROR@";
+			new_var->index = 0;
+			
+			scope->error_var = new_var;
+			return NULL;
+		}
+
+		return scope->error_var;
+	}
+	
+	new_var->identifier = p_strdup(scope->pool, identifier);
+	new_var->index = array_count(&scope->variable_index);
+
+	hash_table_insert(scope->variables, (void *) new_var->identifier, (void *) new_var);
+	array_append(&scope->variable_index, &new_var, 1);
+	
+	return new_var;
+}
+
+struct sieve_variable *sieve_variable_scope_get_variable
+(struct sieve_variable_scope *scope, const char *identifier, bool declare)
+{
+	struct sieve_variable *var = 
+		(struct sieve_variable *) hash_table_lookup(scope->variables, identifier);
+
+	if ( var == NULL && declare ) {
+		var = sieve_variable_scope_declare(scope, identifier);
+	}
+
+	return var;
+}
+
+struct sieve_variable *sieve_variable_scope_import
+(struct sieve_variable_scope *scope, struct sieve_variable *var)
+{
+	struct sieve_variable *new_var = p_new(scope->pool, struct sieve_variable, 1);
+	memcpy(new_var, var, sizeof(struct sieve_variable));
+		
+	hash_table_insert(scope->variables, (void *) new_var->identifier, (void *) new_var);
+	
+	/* Not entered into the index because it is an external variable 
+	 * (This can be done unlimited; only limited by the size of the external scope)
+	 */
+
+	return new_var;
+}
+
+struct sieve_variable_scope_iter *sieve_variable_scope_iterate_init
+(struct sieve_variable_scope *scope)
+{
+	struct sieve_variable_scope_iter *iter = t_new(struct sieve_variable_scope_iter, 1);
+	iter->scope = scope;
+	iter->hctx = hash_table_iterate_init(scope->variables);
+
+	return iter;
+}
+
+bool sieve_variable_scope_iterate
+(struct sieve_variable_scope_iter *iter, struct sieve_variable **var_r)
+{
+	void *key, *value;
+
+	if ( !hash_table_iterate(iter->hctx, &key, &value) )
+		return FALSE; 
+	
+	*var_r = (struct sieve_variable *) value;
+	return TRUE;
+}
+
+void sieve_variable_scope_iterate_deinit
+(struct sieve_variable_scope_iter **iter)
+{
+	hash_table_iterate_deinit(&(*iter)->hctx);
+	*iter = NULL;
+}
+
+unsigned int sieve_variable_scope_declarations
+(struct sieve_variable_scope *scope)
+{
+	return hash_table_count(scope->variables);
+}
+
+unsigned int sieve_variable_scope_size
+(struct sieve_variable_scope *scope)
+{
+	return array_count(&scope->variable_index);
+}
+
+struct sieve_variable * const *sieve_variable_scope_get_variables
+(struct sieve_variable_scope *scope, unsigned int *size_r)
+{
+	return array_get(&scope->variable_index, size_r);
+}
+
+struct sieve_variable *sieve_variable_scope_get_indexed
+(struct sieve_variable_scope *scope, unsigned int index)
+{
+	struct sieve_variable * const *var;
+	
+	if ( index >= array_count(&scope->variable_index) ) 
+		return NULL;
+		
+	var = array_idx(&scope->variable_index, index); 
+	
+	return *var;
+}
+
+/* 
+ * Variable storage 
+ */
+
+struct sieve_variable_storage {
+	pool_t pool;
+	struct sieve_variable_scope *scope;
+	unsigned int max_size;
+	ARRAY_DEFINE(var_values, string_t *); 
+};
+
+struct sieve_variable_storage *sieve_variable_storage_create
+(pool_t pool, struct sieve_variable_scope *scope, unsigned int max_size)
+{
+	struct sieve_variable_storage *storage;
+	
+	storage = p_new(pool, struct sieve_variable_storage, 1);
+	storage->pool = pool;
+	storage->scope = scope;
+	
+	if ( scope != NULL )
+		storage->max_size = sieve_variable_scope_size(scope);
+	else
+		storage->max_size = max_size;
+		
+	p_array_init(&storage->var_values, pool, 4);
+
+	return storage;
+}
+
+static inline bool sieve_variable_valid
+(struct sieve_variable_storage *storage, unsigned int index)
+{
+	if ( storage->scope == NULL ) return TRUE;
+
+	return ( index < storage->max_size );
+}
+
+bool sieve_variable_get_identifier
+(struct sieve_variable_storage *storage, unsigned int index, const char **identifier)
+{
+	struct sieve_variable * const *var;
+	*identifier = NULL;
+
+	if ( storage->scope == NULL ) return TRUE;
+
+	/* FIXME: direct invasion of the scope object is a bit ugly */
+	if ( index >= array_count(&storage->scope->variable_index) )
+		return FALSE;
+
+	var = array_idx(&storage->scope->variable_index, index);
+
+	if ( *var != NULL )
+		*identifier = (*var)->identifier;
+
+	return TRUE;
+}
+
+bool sieve_variable_get
+(struct sieve_variable_storage *storage, unsigned int index, string_t **value)
+{
+	*value = NULL;
+	
+	if  ( index < array_count(&storage->var_values) ) {
+		string_t * const *varent;
+			
+		varent = array_idx(&storage->var_values, index);
+		
+		*value = *varent;
+	} else if ( !sieve_variable_valid(storage, index) )
+		return FALSE;
+
+	return TRUE;
+} 
+
+bool sieve_variable_get_modifiable
+(struct sieve_variable_storage *storage, unsigned int index, string_t **value)
+{
+	string_t *dummy;
+	
+	if ( value == NULL ) value = &dummy;
+	
+	if ( !sieve_variable_get(storage, index, value) )
+		return FALSE;
+	
+	if ( *value == NULL ) {
+		*value = str_new(storage->pool, 256);
+		array_idx_set(&storage->var_values, index, value);	
+	}
+
+	return TRUE; 
+}
+
+bool sieve_variable_assign
+(struct sieve_variable_storage *storage, unsigned int index, 
+	const string_t *value)
+{
+	string_t *varval;
+	
+	if ( !sieve_variable_get_modifiable(storage, index, &varval) ) 
+		return FALSE;
+
+	str_truncate(varval, 0);
+	str_append_str(varval, value);
+
+	/* Just a precaution, caller should prevent this in the first place */
+	if ( str_len(varval) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE )
+		str_truncate(varval, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+
+	return TRUE;
+}
+
+/*
+ * AST Context
+ */
+
+static void ext_variables_ast_free
+(struct sieve_ast *ast ATTR_UNUSED, void *context)
+{
+	struct sieve_variable_scope *main_scope =
+		(struct sieve_variable_scope *) context;
+
+	/* Unreference main variable scope */
+	sieve_variable_scope_unref(&main_scope);
+}
+
+static const struct sieve_ast_extension variables_ast_extension = {
+    &variables_extension,
+    ext_variables_ast_free
+};
+
+static struct sieve_variable_scope *ext_variables_create_main_scope
+(struct sieve_ast *ast)
+{
+	struct sieve_variable_scope *scope;
+
+	scope = sieve_variable_scope_create(NULL);
+
+	sieve_ast_extension_register(ast, &variables_ast_extension, (void *) scope);
+
+	return scope;
+}
+
+static struct sieve_variable_scope *ext_variables_ast_get_main_scope
+(struct sieve_ast *ast)
+{
+	struct sieve_variable_scope *main_scope =
+		(struct sieve_variable_scope *) sieve_ast_extension_get_context
+		(ast, &variables_extension);
+	
+	return main_scope;
+}
+
+/*
+ * Validator context 
+ */
+
+static struct ext_variables_validator_context *
+ext_variables_validator_context_create(struct sieve_validator *valdtr)
+{		
+	pool_t pool = sieve_validator_pool(valdtr);
+	struct ext_variables_validator_context *ctx;
+	struct sieve_ast *ast = sieve_validator_ast(valdtr);
+	
+	ctx = p_new(pool, struct ext_variables_validator_context, 1);
+	ctx->modifiers = sieve_validator_object_registry_create(valdtr);
+	ctx->main_scope = ext_variables_create_main_scope(ast);
+
+	sieve_validator_extension_set_context
+		(valdtr, &variables_extension, (void *) ctx);
+
+	return ctx;
+}
+
+struct ext_variables_validator_context *ext_variables_validator_context_get
+(struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx = 
+		(struct ext_variables_validator_context *)
+		sieve_validator_extension_get_context(valdtr, &variables_extension);
+	
+	if ( ctx == NULL ) {
+		ctx = ext_variables_validator_context_create(valdtr);
+	}
+	
+	return ctx;
+}
+
+void ext_variables_validator_initialize(struct sieve_validator *validator)
+{
+	struct ext_variables_validator_context *ctx;
+	
+	/* Create our context */
+	ctx = ext_variables_validator_context_get(validator);
+	
+	ext_variables_register_core_modifiers(ctx);
+	
+	ctx->active = TRUE;
+}
+
+struct sieve_variable *ext_variables_validator_get_variable
+(struct sieve_validator *validator, const char *variable, bool declare)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(validator);
+		
+	return sieve_variable_scope_get_variable(ctx->main_scope, variable, declare);
+}
+
+struct sieve_variable_scope *sieve_ext_variables_get_main_scope
+(struct sieve_validator *validator)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(validator);
+		
+	return ctx->main_scope;
+}
+
+bool sieve_ext_variables_is_active(struct sieve_validator *valdtr)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(valdtr);
+		
+	return ( ctx != NULL && ctx->active );
+}
+
+/*
+ * Code generation
+ */
+ 
+bool ext_variables_generator_load(const struct sieve_codegen_env *cgenv)
+{
+	struct sieve_variable_scope *main_scope = 
+		ext_variables_ast_get_main_scope(cgenv->ast);
+	unsigned int count = sieve_variable_scope_size(main_scope);
+	sieve_size_t jump;
+
+	sieve_binary_emit_unsigned(cgenv->sbin, count);
+
+	jump = sieve_binary_emit_offset(cgenv->sbin, 0);
+
+	if ( count > 0 ) {
+		unsigned int size, i;
+		struct sieve_variable *const *vars = 
+			sieve_variable_scope_get_variables(main_scope, &size);
+
+		for ( i = 0; i < size; i++ ) {			
+			sieve_binary_emit_cstring(cgenv->sbin, vars[i]->identifier);
+		}
+	}
+	
+	sieve_binary_resolve_offset(cgenv->sbin, jump);
+		
+	return TRUE;
+}
+
+/* 
+ * Interpreter context 
+ */
+
+struct ext_variables_interpreter_context {
+	struct sieve_variable_storage *local_storage;
+	ARRAY_DEFINE(ext_storages, struct sieve_variable_storage *);
+};
+
+static struct ext_variables_interpreter_context *
+ext_variables_interpreter_context_create
+(struct sieve_interpreter *interp, unsigned int max_size)
+{		
+	pool_t pool = sieve_interpreter_pool(interp);
+	struct ext_variables_interpreter_context *ctx;
+	
+	ctx = p_new(pool, struct ext_variables_interpreter_context, 1);
+	ctx->local_storage = sieve_variable_storage_create(pool, NULL, max_size);
+	p_array_init(&ctx->ext_storages, pool, sieve_extensions_get_count());
+
+	sieve_interpreter_extension_set_context
+		(interp, &variables_extension, (void *) ctx);
+
+	return ctx;
+}
+
+bool ext_variables_interpreter_load
+	(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	struct ext_variables_interpreter_context *ctx;
+	unsigned int scope_size;
+	sieve_size_t pc;
+	int end_offset;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &scope_size) ) {
+		sieve_sys_error("variables: failed to read main scope size");
+		return FALSE;
+	}
+
+	if ( scope_size > SIEVE_VARIABLES_MAX_SCOPE_SIZE ) {
+		sieve_sys_error("variables: scope size exceeds the limit (%u > %u)", 
+			scope_size, SIEVE_VARIABLES_MAX_SCOPE_SIZE );
+		return FALSE;
+	}
+	
+	pc = *address;
+	if ( !sieve_binary_read_offset(renv->sbin, address, &end_offset) )
+		return NULL;
+	*address = pc + end_offset;
+	
+	/* Create our context */
+	ctx = ext_variables_interpreter_context_create(renv->interp, scope_size);
+
+	/* Enable support for match values */
+	(void) sieve_match_values_set_enabled(renv->interp, TRUE);
+	
+	return TRUE;
+}
+
+static inline struct ext_variables_interpreter_context *
+ext_variables_interpreter_context_get(struct sieve_interpreter *interp)
+{
+	return (struct ext_variables_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, &variables_extension);
+}
+
+struct sieve_variable_storage *sieve_ext_variables_get_storage
+(struct sieve_interpreter *interp, const struct sieve_extension *ext)
+{
+	struct ext_variables_interpreter_context *ctx = 
+		ext_variables_interpreter_context_get(interp);
+	struct sieve_variable_storage * const *storage;
+	int ext_id;
+		
+	if ( ext == NULL )
+		return ctx->local_storage;
+
+	ext_id = SIEVE_EXT_ID(ext);
+	if ( ext_id >= (int) array_count(&ctx->ext_storages) ) {
+		storage = NULL;
+	} else {
+		storage = array_idx(&ctx->ext_storages, ext_id);
+	}
+	
+	if ( storage == NULL || *storage == NULL ) 
+		return NULL;
+	
+	return *storage;
+}
+
+void sieve_ext_variables_set_storage
+(struct sieve_interpreter *interp, struct sieve_variable_storage *storage,
+	const struct sieve_extension *ext)
+{
+	struct ext_variables_interpreter_context *ctx = 
+		ext_variables_interpreter_context_get(interp);
+		
+	if ( ctx == NULL || ext == NULL || storage == NULL )
+		return;
+		
+	array_idx_set(&ctx->ext_storages, (unsigned int) SIEVE_EXT_ID(ext), &storage);
+}
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,100 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_COMMON_H
+#define __EXT_VARIABLES_COMMON_H
+
+#include "sieve-common.h"
+#include "sieve-validator.h"
+
+#include "sieve-ext-variables.h"
+
+/*
+ * Extension
+ */
+
+extern const struct sieve_extension variables_extension;
+
+/* 
+ * Commands 
+ */
+
+extern const struct sieve_command cmd_set;
+extern const struct sieve_command tst_string;
+
+/* 
+ * Operands
+ */
+
+enum ext_variables_operand {
+	EXT_VARIABLES_OPERAND_VARIABLE,
+	EXT_VARIABLES_OPERAND_MATCH_VALUE,
+	EXT_VARIABLES_OPERAND_MODIFIER
+};
+
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation cmd_set_operation;
+extern const struct sieve_operation tst_string_operation;
+
+enum ext_variables_opcode {
+	EXT_VARIABLES_OPERATION_SET,
+	EXT_VARIABLES_OPERATION_STRING
+};
+
+/* 
+ * Validator context 
+ */
+
+struct ext_variables_validator_context {
+	bool active;
+	
+	struct sieve_validator_object_registry *modifiers;
+	
+	struct sieve_variable_scope *main_scope;
+};
+
+void ext_variables_validator_initialize(struct sieve_validator *validator);
+	
+struct ext_variables_validator_context *ext_variables_validator_context_get
+	(struct sieve_validator *valdtr);
+
+struct sieve_variable *ext_variables_validator_get_variable
+	(struct sieve_validator *validator, const char *variable, bool declare);
+
+/*
+ * Code generation
+ */
+ 
+bool ext_variables_generator_load
+	(const struct sieve_codegen_env *cgenv);
+
+/*
+ * Interpreter context
+ */	
+
+bool ext_variables_interpreter_load
+(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* 
+ * Variable coding 
+ */
+
+void ext_variables_opr_variable_emit
+	(struct sieve_binary *sbin, struct sieve_variable *var);
+void ext_variables_opr_match_value_emit
+	(struct sieve_binary *sbin, unsigned int index);
+bool ext_variables_opr_variable_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		struct sieve_variable_storage **storage, unsigned int *var_index);
+
+void ext_variables_opr_variable_string_emit
+	(struct sieve_binary *sbin, unsigned int elements);
+
+bool ext_variables_variable_assignment_activate
+(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+	struct sieve_command_context *cmd);
+	
+#endif /* __EXT_VARIABLES_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,156 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+ 
+#include "sieve-common.h"
+#include "sieve-dump.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-dump.h"
+
+/*
+ * Code dumper extension
+ */
+
+static void ext_variables_code_dumper_free
+	(struct sieve_code_dumper *dumper, void *context);
+
+const struct sieve_code_dumper_extension variables_dump_extension = {
+	&variables_extension,
+	ext_variables_code_dumper_free
+};
+
+/*
+ * Code dump context
+ */
+ 
+struct ext_variables_dump_context {
+	struct sieve_variable_scope *main_scope;
+	ARRAY_DEFINE(ext_scopes, struct sieve_variable_scope *);
+};
+
+static void ext_variables_code_dumper_free
+(struct sieve_code_dumper *dumper ATTR_UNUSED, void *context)
+{
+	struct ext_variables_dump_context *dctx = 
+		(struct ext_variables_dump_context *) context;
+
+	if ( dctx == NULL || dctx->main_scope == NULL )
+		return;
+
+	sieve_variable_scope_unref(&dctx->main_scope);
+}
+
+static struct ext_variables_dump_context *ext_variables_dump_get_context
+	(const struct sieve_dumptime_env *denv)
+{
+	struct sieve_code_dumper *dumper = denv->cdumper;
+	struct ext_variables_dump_context *dctx = sieve_dump_extension_get_context
+		(dumper, &variables_extension);
+	pool_t pool;
+
+	if ( dctx == NULL ) {
+		/* Create dumper context */
+		pool = sieve_code_dumper_pool(dumper);
+		dctx = p_new(pool, struct ext_variables_dump_context, 1);
+		p_array_init(&dctx->ext_scopes, pool, sieve_extensions_get_count());
+	
+		sieve_dump_extension_set_context(dumper, &variables_extension, dctx);
+	}
+
+	return dctx;
+} 
+ 
+bool ext_variables_code_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	struct ext_variables_dump_context *dctx;
+	struct sieve_variable_scope *main_scope;
+	unsigned int i, scope_size;
+	sieve_size_t pc;
+	int end_offset;
+	
+	sieve_code_mark(denv);
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &scope_size) )
+		return FALSE;
+		
+	pc = *address;	
+	if ( !sieve_binary_read_offset(denv->sbin, address, &end_offset) )
+		return FALSE;
+	
+	main_scope = sieve_variable_scope_create(NULL);
+	
+	sieve_code_dumpf(denv, "SCOPE [%u] (end: %08x)", 
+		scope_size, (unsigned int) (pc + end_offset));
+	
+	/* Read main variable scope */
+	
+	for ( i = 0; i < scope_size; i++ ) {
+		string_t *identifier;
+
+		sieve_code_mark(denv);
+		if (!sieve_binary_read_string(denv->sbin, address, &identifier) ) {
+			return FALSE;
+		}
+		
+		sieve_code_dumpf(denv, "%3d: '%s'", i, str_c(identifier));
+		
+		(void) sieve_variable_scope_declare(main_scope, str_c(identifier));
+	}
+	
+	dctx = ext_variables_dump_get_context(denv);
+	dctx->main_scope = main_scope;
+	
+	return TRUE;
+}
+
+/*
+ * Scope registry
+ */
+
+void sieve_ext_variables_dump_set_scope
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext, 
+	struct sieve_variable_scope *scope)
+{
+	struct ext_variables_dump_context *dctx = ext_variables_dump_get_context(denv);
+
+	array_idx_set(&dctx->ext_scopes, (unsigned int) SIEVE_EXT_ID(ext), &scope);	
+}
+
+/*
+ * Variable identifier dump
+ */
+
+const char *ext_variables_dump_get_identifier
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext,
+	unsigned int index)
+{
+	struct ext_variables_dump_context *dctx = ext_variables_dump_get_context(denv);	
+	struct sieve_variable_scope *scope;
+	struct sieve_variable *var;
+
+	if ( ext == NULL )
+		scope = dctx->main_scope;
+	else {
+		struct sieve_variable_scope *const *ext_scope;
+		int ext_id = SIEVE_EXT_ID(ext);
+
+		if  ( ext_id < 0 || ext_id >= (int) array_count(&dctx->ext_scopes) )
+			return NULL;
+	
+		ext_scope = array_idx(&dctx->ext_scopes, (unsigned int) ext_id);
+		scope = *ext_scope;			
+	}
+
+	if ( scope == NULL )
+		return NULL;
+			
+	var = sieve_variable_scope_get_indexed(scope, index);
+	
+	return var->identifier;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-dump.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_DUMP_H
+#define __EXT_VARIABLES_DUMP_H
+
+#include "sieve-common.h"
+
+/*
+ * Code dump context
+ */
+ 
+bool ext_variables_code_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/*
+ * Variable identifier dump
+ */
+ 
+const char *ext_variables_dump_get_identifier
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext,
+	unsigned int index);
+
+#endif /* __EXT_VARIABLES_DUMP_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-limits.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_LIMITS_H
+#define __EXT_VARIABLES_LIMITS_H
+
+#include "sieve-limits.h"
+
+/* From RFC 5229:
+ * 
+ * 6.  Implementation Limits
+ *
+ *  An implementation of this document MUST support at least 128 distinct
+ *  variables.  The supported length of variable names MUST be at least
+ *  32 characters.  Each variable MUST be able to hold at least 4000
+ *  characters.  Attempts to set the variable to a value larger than what
+ *  the implementation supports SHOULD be reported as an error at
+ *  compile-time if possible.  If the attempt is discovered during run-
+ *  time, the value SHOULD be truncated, and it MUST NOT be treated as an
+ *  error.
+
+ *  Match variables ${1} through ${9} MUST be supported.  References to
+ *  higher indices than those the implementation supports MUST be treated
+ *  as a syntax error, which SHOULD be discovered at compile-time.
+ */
+
+#define SIEVE_VARIABLES_MAX_SCOPE_SIZE              255
+#define SIEVE_VARIABLES_MAX_VARIABLE_NAME_LEN       64
+#define SIEVE_VARIABLES_MAX_VARIABLE_SIZE           (4 * 1024)
+#define SIEVE_VARIABLES_MAX_NAMESPACE_ELEMENTS      4
+
+#define SIEVE_VARIABLES_MAX_MATCH_INDEX             SIEVE_MAX_MATCH_VALUES
+
+#endif /* __EXT_VARIABLES_LIMITS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,241 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-modifiers.h"
+
+#include <ctype.h>
+
+/*
+ * Core modifiers
+ */
+ 
+extern const struct sieve_variables_modifier lower_modifier;
+extern const struct sieve_variables_modifier upper_modifier;
+extern const struct sieve_variables_modifier lowerfirst_modifier;
+extern const struct sieve_variables_modifier upperfirst_modifier;
+extern const struct sieve_variables_modifier quotewildcard_modifier;
+extern const struct sieve_variables_modifier length_modifier;
+
+enum ext_variables_modifier_code {
+    EXT_VARIABLES_MODIFIER_LOWER,
+    EXT_VARIABLES_MODIFIER_UPPER,
+    EXT_VARIABLES_MODIFIER_LOWERFIRST,
+    EXT_VARIABLES_MODIFIER_UPPERFIRST,
+    EXT_VARIABLES_MODIFIER_QUOTEWILDCARD,
+    EXT_VARIABLES_MODIFIER_LENGTH
+};
+
+const struct sieve_variables_modifier *ext_variables_core_modifiers[] = {
+	&lower_modifier,
+	&upper_modifier,
+	&lowerfirst_modifier,
+	&upperfirst_modifier,
+	&quotewildcard_modifier,
+	&length_modifier
+};
+
+const unsigned int ext_variables_core_modifiers_count =
+    N_ELEMENTS(ext_variables_core_modifiers);
+
+/*
+ * Modifier registry
+ */
+
+void sieve_variables_modifier_register
+(struct sieve_validator *valdtr, const struct sieve_variables_modifier *smodf) 
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(valdtr);
+	
+	sieve_validator_object_registry_add(ctx->modifiers, &smodf->object);
+}
+
+const struct sieve_variables_modifier *ext_variables_modifier_find
+(struct sieve_validator *valdtr, const char *identifier)
+{
+	struct ext_variables_validator_context *ctx = 
+		ext_variables_validator_context_get(valdtr);
+		
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(ctx->modifiers, identifier);
+
+	return (const struct sieve_variables_modifier *) object;
+}
+
+void ext_variables_register_core_modifiers
+(struct ext_variables_validator_context *ctx)
+{
+	unsigned int i;
+	
+	/* Register core modifiers*/
+	for ( i = 0; i < ext_variables_core_modifiers_count; i++ ) {
+		sieve_validator_object_registry_add
+			(ctx->modifiers, &(ext_variables_core_modifiers[i]->object));
+	}
+}
+
+/*
+ * Modifier coding
+ */
+ 
+const struct sieve_operand_class sieve_variables_modifier_operand_class = 
+	{ "modifier" };
+	
+static const struct sieve_extension_objects core_modifiers =
+	SIEVE_VARIABLES_DEFINE_MODIFIERS(ext_variables_core_modifiers);
+
+const struct sieve_operand modifier_operand = { 
+	"modifier", 
+	&variables_extension,
+	EXT_VARIABLES_OPERAND_MODIFIER, 
+	&sieve_variables_modifier_operand_class,
+	&core_modifiers
+};
+
+/* 
+ * Core modifiers 
+ */
+ 
+/* Forward declarations */
+
+bool mod_lower_modify(string_t *in, string_t **result);
+bool mod_upper_modify(string_t *in, string_t **result);
+bool mod_lowerfirst_modify(string_t *in, string_t **result);
+bool mod_upperfirst_modify(string_t *in, string_t **result);
+bool mod_length_modify(string_t *in, string_t **result);
+bool mod_quotewildcard_modify(string_t *in, string_t **result);
+
+/* Modifier objects */
+
+const struct sieve_variables_modifier lower_modifier = {
+	SIEVE_OBJECT("lower", &modifier_operand, EXT_VARIABLES_MODIFIER_LOWER),
+	40,
+	mod_lower_modify
+};
+
+const struct sieve_variables_modifier upper_modifier = {
+	SIEVE_OBJECT("upper", &modifier_operand, EXT_VARIABLES_MODIFIER_UPPER),
+	40,
+	mod_upper_modify
+};
+
+const struct sieve_variables_modifier lowerfirst_modifier = {
+	SIEVE_OBJECT
+		("lowerfirst", &modifier_operand, EXT_VARIABLES_MODIFIER_LOWERFIRST),
+	30,
+	mod_lowerfirst_modify
+};
+
+const struct sieve_variables_modifier upperfirst_modifier = {
+	SIEVE_OBJECT
+		("upperfirst", &modifier_operand,	EXT_VARIABLES_MODIFIER_UPPERFIRST),
+	30,
+	mod_upperfirst_modify
+};
+
+const struct sieve_variables_modifier quotewildcard_modifier = {
+	SIEVE_OBJECT
+		("quotewildcard", &modifier_operand, EXT_VARIABLES_MODIFIER_QUOTEWILDCARD),
+	20,
+	mod_quotewildcard_modify
+};
+
+const struct sieve_variables_modifier length_modifier = {
+	SIEVE_OBJECT("length", &modifier_operand, EXT_VARIABLES_MODIFIER_LENGTH),
+	10,
+	mod_length_modify
+};
+
+/* Modifier implementations */
+
+bool mod_upperfirst_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+		
+	content = str_c_modifiable(*result);
+	content[0] = i_toupper(content[0]);
+
+	return TRUE;
+}
+
+bool mod_lowerfirst_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+		
+	content = str_c_modifiable(*result);
+	content[0] = i_tolower(content[0]);
+
+	return TRUE;
+}
+
+bool mod_upper_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content = str_ucase(content);
+	
+	return TRUE;
+}
+
+bool mod_lower_modify(string_t *in, string_t **result)
+{
+	char *content;
+	
+	*result = t_str_new(str_len(in));
+	str_append_str(*result, in);
+
+	content = str_c_modifiable(*result);
+	content = str_lcase(content);
+
+	return TRUE;
+}
+
+bool mod_length_modify(string_t *in, string_t **result)
+{
+	*result = t_str_new(64);
+	str_printfa(*result, "%llu", (unsigned long long) str_len(in));
+
+	return TRUE;
+}
+
+bool mod_quotewildcard_modify(string_t *in, string_t **result)
+{
+	unsigned int i;
+	const char *content;
+	
+	*result = t_str_new(str_len(in) * 2);
+	content = (const char *) str_data(in);
+	
+	for ( i = 0; i < str_len(in); i++ ) {
+		if ( content[i] == '*' || content[i] == '?' || content[i] == '\\' ) {
+			str_append_c(*result, '\\');
+		}
+		str_append_c(*result, content[i]);
+	}
+	
+	return TRUE;
+}
+
+
+
+
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-modifiers.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,47 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_MODIFIERS_H
+#define __EXT_VARIABLES_MODIFIERS_H
+
+#include "ext-variables-common.h"
+#include "sieve-ext-variables.h"
+
+/*
+ * Modifier registry
+ */
+
+const struct sieve_variables_modifier *ext_variables_modifier_find
+	(struct sieve_validator *validator, const char *identifier);
+
+void ext_variables_register_core_modifiers
+	(struct ext_variables_validator_context *ctx);
+	
+/*
+ * Modifier operand
+ */
+
+extern const struct sieve_operand modifier_operand;
+
+static inline void ext_variables_opr_modifier_emit
+(struct sieve_binary *sbin, const struct sieve_variables_modifier *modf)
+{ 
+	sieve_opr_object_emit(sbin, &modf->object);
+}
+
+static inline const struct sieve_variables_modifier *
+	ext_variables_opr_modifier_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_variables_modifier *) sieve_opr_object_read
+		(renv, &sieve_variables_modifier_operand_class, address);
+}
+
+static inline bool ext_variables_opr_modifier_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_variables_modifier_operand_class, address, NULL);
+}
+	
+#endif /* __EXT_VARIABLES_MODIFIERS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,88 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-limits.h"
+#include "ext-variables-name.h"
+
+#include <ctype.h>
+
+int ext_variable_name_parse
+(ARRAY_TYPE(ext_variable_name) *vname, const char **str, const char *strend)
+{
+	const char *p = *str;
+	int nspace_used = 0;
+				
+	for (;;) { 
+		struct ext_variable_name *cur_element;
+		string_t *cur_ident;
+
+		/* Acquire current position in the substitution structure or allocate 
+		 * a new one if this substitution consists of more elements than before.
+		 */
+		if ( nspace_used < (int) array_count(vname) ) {
+			cur_element = array_idx_modifiable
+				(vname, (unsigned int) nspace_used);
+			cur_ident = cur_element->identifier;
+		} else {
+			if ( nspace_used >= SIEVE_VARIABLES_MAX_NAMESPACE_ELEMENTS )
+				return -1;
+			cur_element = array_append_space(vname);
+			cur_ident = cur_element->identifier = t_str_new(32);
+		}
+
+		/* Identifier */
+		if ( *p == '_' || i_isalpha(*p) ) {
+			cur_element->num_variable = -1;
+			str_truncate(cur_ident, 0);
+			str_append_c(cur_ident, *p);
+			p++;
+		
+			while ( p < strend && (*p == '_' || i_isalnum(*p)) ) {
+				if ( str_len(cur_ident) >= SIEVE_VARIABLES_MAX_VARIABLE_NAME_LEN )
+					return -1;
+				str_append_c(cur_ident, *p);
+				p++;
+			}
+		
+		/* Num-variable */
+		} else if ( i_isdigit(*p) ) {
+			cur_element->num_variable = *p - '0';
+			p++;
+			
+			while ( p < strend && i_isdigit(*p) ) {
+				cur_element->num_variable = cur_element->num_variable*10 + (*p - '0');
+				p++;
+			} 
+
+			/* If a num-variable is first, no more elements can follow because no
+			 * namespace is specified.
+			 */
+			if ( nspace_used == 0 ) {
+				*str = p;
+				return 1;
+			}
+		} else {
+			*str = p;
+			return -1;
+		}
+		
+		nspace_used++;
+		
+		if ( p < strend && *p == '.' ) 
+			p++;
+		else
+			break;
+	}
+	
+	*str = p;
+	return nspace_used;
+} 
+ 
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-name.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_NAME
+#define __EXT_VARIABLES_NAME
+
+/* Variable Substitution
+ * ---------------------
+ * 
+ * The variable strings are preprocessed into an AST list consisting of variable 
+ * substitutions and constant parts of the string. The variables to which
+ * the substitutions link are looked up and their index in their scope storage
+ * is what is added to the list and eventually emitted as byte code. So in byte
+ * code a variable string will look as a series of substrings interrupted by
+ * integer operands that refer to variables. During execution the strings and 
+ * the looked-up variables are concatenated to obtain the desired result. The 
+ * the variable references are simple indexes into an array of variables, so
+ * looking these up during execution is a trivial process.
+ * 
+ * However (RFC 5229):
+ *   Tests or actions in future extensions may need to access the
+ *   unexpanded version of the string argument and, e.g., do the expansion
+ *   after setting variables in its namespace.  The design of the
+ *   implementation should allow this.
+ *
+ * Various options exist to provide this feature. If the extension is entirely
+ * namespace-based there is actually not very much of a problem. The variable
+ * list can easily be extended with new argument-types that refer to a variable
+ * identifier in stead of an index in the variable's storage. 
+ */
+
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "ext-variables-common.h"
+
+/*
+ * Types
+ */ 
+
+struct ext_variable_name {
+	string_t *identifier;
+	int num_variable;
+};
+
+ARRAY_DEFINE_TYPE(ext_variable_name, struct ext_variable_name);
+
+/*
+ * Variable name parsing
+ */
+ 
+int ext_variable_name_parse
+	(ARRAY_TYPE(ext_variable_name) *vname, const char **str, const char *strend);
+
+#endif /* __EXT_VARIABLES_NAME */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,238 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-match-types.h"
+
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "ext-variables-common.h"
+#include "ext-variables-name.h"
+#include "ext-variables-dump.h"
+
+/* 
+ * Variable operand 
+ */
+
+static bool opr_variable_read_value
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+static bool opr_variable_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name);
+
+const struct sieve_opr_string_interface variable_interface = { 
+	opr_variable_dump,
+	opr_variable_read_value
+};
+		
+const struct sieve_operand variable_operand = { 
+	"variable", 
+	&variables_extension, 
+	EXT_VARIABLES_OPERAND_VARIABLE,
+	&string_class,
+	&variable_interface
+};
+
+void ext_variables_opr_variable_emit
+(struct sieve_binary *sbin, struct sieve_variable *var) 
+{
+	if ( var->ext == NULL ) {
+		/* Default variable storage */
+		(void) sieve_operand_emit_code(sbin, &variable_operand);
+		(void) sieve_binary_emit_byte(sbin, 0);
+		(void) sieve_binary_emit_unsigned(sbin, var->index);
+		return;
+	} 
+
+	(void) sieve_operand_emit_code(sbin, &variable_operand);
+	(void) sieve_binary_emit_extension(sbin, var->ext, 1);
+	(void) sieve_binary_emit_unsigned(sbin, var->index);
+}
+
+static bool opr_variable_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int index = 0;
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	const char *identifier;
+
+	if ( !sieve_binary_read_extension(denv->sbin, address, &code, &ext) )
+		return FALSE;
+	
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &index) )
+		return FALSE;
+		
+	identifier = ext_variables_dump_get_identifier(denv, ext, index);
+	identifier = identifier == NULL ? "??" : identifier;
+
+	if ( ext == NULL ) {		
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: VAR ${%s} (%ld)", 
+				field_name, identifier, (long) index);
+		else
+			sieve_code_dumpf(denv, "VAR ${%s} (%ld)", 
+				identifier, (long) index);
+	} else {
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: VAR [%s] ${%s} (%ld)", 
+				field_name, ext->name, identifier, (long) index);
+		else
+			sieve_code_dumpf(denv, "VAR [%s] ${%s} (%ld)", 
+				ext->name, identifier, (long) index);
+	}
+	return TRUE;
+}
+
+static bool opr_variable_read_value
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	struct sieve_variable_storage *storage;
+	unsigned int index = 0;
+	
+	if ( !sieve_binary_read_extension(renv->sbin, address, &code, &ext) )
+		return FALSE;
+
+	storage = sieve_ext_variables_get_storage(renv->interp, ext);
+	if ( storage == NULL ) 
+		return FALSE;
+	
+	if (sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+		/* Parameter str can be NULL if we are requested to only skip and not 
+		 * actually read the argument.
+		 */
+		if ( str != NULL ) {
+			if ( !sieve_variable_get(storage, index, str) )
+				return FALSE;
+		
+			if ( *str == NULL ) *str = t_str_new(0);
+		}
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+		
+bool sieve_variable_operand_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand, 
+	sieve_size_t *address, struct sieve_variable_storage **storage, 
+	unsigned int *var_index)
+{
+	const struct sieve_extension *ext;
+	unsigned int code = 1; /* Initially set to offset value */
+	unsigned int idx = 0;
+
+	if ( operand != &variable_operand ) {
+		return FALSE;
+	}
+
+	if ( !sieve_binary_read_extension(renv->sbin, address, &code, &ext) )
+        return FALSE;
+		
+	*storage = sieve_ext_variables_get_storage(renv->interp, ext);
+	if ( *storage == NULL )	
+		return FALSE;
+	
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &idx) )
+		return FALSE;		
+
+	*var_index = idx;
+	return TRUE;
+}
+
+bool sieve_variable_operand_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	struct sieve_variable_storage **storage, unsigned int *var_index)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+
+	return sieve_variable_operand_read_data
+		(renv, operand, address, storage, var_index);
+}
+	
+/* 
+ * Match value operand 
+ */
+
+static bool opr_match_value_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+static bool opr_match_value_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name);
+
+const struct sieve_opr_string_interface match_value_interface = { 
+	opr_match_value_dump,
+	opr_match_value_read
+};
+		
+const struct sieve_operand match_value_operand = { 
+	"match-value", 
+	&variables_extension, 
+	EXT_VARIABLES_OPERAND_MATCH_VALUE,
+	&string_class,
+	&match_value_interface
+};	
+
+void ext_variables_opr_match_value_emit
+(struct sieve_binary *sbin, unsigned int index) 
+{
+	(void) sieve_operand_emit_code(sbin, &match_value_operand);
+	(void) sieve_binary_emit_unsigned(sbin, index);
+}
+
+static bool opr_match_value_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int index = 0;
+	
+	if (sieve_binary_read_unsigned(denv->sbin, address, &index) ) {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: MATCHVAL %lu", field_name, (unsigned long) index);
+		else
+			sieve_code_dumpf(denv, "MATCHVAL %lu", (unsigned long) index);
+
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static bool opr_match_value_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	unsigned int index = 0;
+			
+	if (sieve_binary_read_unsigned(renv->sbin, address, &index) ) {
+		/* Parameter str can be NULL if we are requested to only skip and not 
+		 * actually read the argument.
+		 	*/
+		if ( str != NULL ) {
+			sieve_match_values_get(renv->interp, index, str);
+		
+			if ( *str == NULL ) 
+				*str = t_str_new(0);
+			else if ( str_len(*str) > SIEVE_VARIABLES_MAX_VARIABLE_SIZE ) 
+				str_truncate(*str, SIEVE_VARIABLES_MAX_VARIABLE_SIZE);
+		}
+		return TRUE;
+	}
+	
+	return FALSE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/ext-variables-operands.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __EXT_VARIABLES_OPERANDS_H
+#define __EXT_VARIABLES_OPERANDS_H
+
+#include "lib.h"
+#include "hash.h"
+#include "str.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "ext-variables-common.h"
+
+/* 
+ * Variable operand 
+ */
+		
+extern const struct sieve_operand variable_operand;	
+
+void ext_variables_opr_variable_emit
+	(struct sieve_binary *sbin, struct sieve_variable *var);
+
+/* 
+ * Match value operand 
+ */
+		
+extern const struct sieve_operand match_value_operand;	
+
+void ext_variables_opr_match_value_emit
+	(struct sieve_binary *sbin, unsigned int index);
+	
+#endif /* __EXT_VARIABLES_OPERANDS_H */
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,35 @@
+noinst_LTLIBRARIES = libsieve_ext_variables.la
+
+AM_CPPFLAGS = \
+	-I../../ \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+cmds = \
+	cmd-set.c
+
+tsts = \
+	tst-string.c
+
+libsieve_ext_variables_la_SOURCES = \
+	ext-variables-common.c \
+	ext-variables-name.c \
+	ext-variables-arguments.c \
+	ext-variables-operands.c \
+	ext-variables-modifiers.c \
+	ext-variables-dump.c \
+	$(cmds) \
+	$(tsts) \
+	ext-variables.c
+
+noinst_HEADERS = \
+	ext-variables-common.h \
+	ext-variables-limits.h \
+	ext-variables-name.h \
+	ext-variables-arguments.h \
+	ext-variables-operands.h \
+	ext-variables-modifiers.h \
+	ext-variables-dump.h \
+	sieve-ext-variables.h 
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/sieve-ext-variables.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,164 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* 
+ * Public interface for other extensions to use 
+ */
+ 
+#ifndef __SIEVE_EXT_VARIABLES_H
+#define __SIEVE_EXT_VARIABLES_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-objects.h"
+
+#include "ext-variables-limits.h"
+
+/*
+ * Variable scope
+ */
+
+struct sieve_variable {
+	const char *identifier;
+	unsigned int index;
+
+	const struct sieve_extension *ext;
+	void *context;
+};
+
+struct sieve_variable_scope;
+
+struct sieve_variable_scope *sieve_variable_scope_create
+	(const struct sieve_extension *ext);
+void sieve_variable_scope_ref
+	(struct sieve_variable_scope *scope);
+void sieve_variable_scope_unref
+	(struct sieve_variable_scope **scope);
+pool_t sieve_variable_scope_pool
+	(struct sieve_variable_scope *scope);
+
+struct sieve_variable *sieve_variable_scope_declare
+	(struct sieve_variable_scope *scope, const char *identifier);
+struct sieve_variable *sieve_variable_scope_import
+	(struct sieve_variable_scope *scope, struct sieve_variable *var);
+struct sieve_variable *sieve_variable_scope_get_variable
+	(struct sieve_variable_scope *scope, const char *identifier, bool create);
+struct sieve_variable *sieve_variable_scope_get_indexed
+	(struct sieve_variable_scope *scope, unsigned int index);
+
+/* Iteration over all declared variables */
+
+struct sieve_variable_scope_iter;
+
+struct sieve_variable_scope_iter *sieve_variable_scope_iterate_init
+	(struct sieve_variable_scope *scope);
+bool sieve_variable_scope_iterate
+	(struct sieve_variable_scope_iter *iter, struct sieve_variable **var_r);
+void sieve_variable_scope_iterate_deinit
+	(struct sieve_variable_scope_iter **iter);
+
+/* Statistics */
+
+unsigned int sieve_variable_scope_declarations
+	(struct sieve_variable_scope *scope);
+unsigned int sieve_variable_scope_size
+	(struct sieve_variable_scope *scope);
+
+/* Get all native variables */
+
+struct sieve_variable * const *sieve_variable_scope_get_variables
+	(struct sieve_variable_scope *scope, unsigned int *size_r);
+
+/* 
+ * Variable storage
+ */	
+	
+struct sieve_variable_storage;
+
+struct sieve_variable_storage *sieve_variable_storage_create
+	(pool_t pool, struct sieve_variable_scope *scope, unsigned int max_size);
+bool sieve_variable_get
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		string_t **value);
+bool sieve_variable_get_modifiable
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		string_t **value);
+bool sieve_variable_assign
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		const string_t *value);
+bool sieve_variable_get_identifier
+	(struct sieve_variable_storage *storage, unsigned int index, 
+		const char **identifier);
+
+/*
+ * Variables access
+ */
+
+bool sieve_ext_variables_is_active(struct sieve_validator *valdtr);
+
+struct sieve_variable_scope *sieve_ext_variables_get_main_scope
+	(struct sieve_validator *validator);
+	
+struct sieve_variable_storage *sieve_ext_variables_get_storage
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext);
+void sieve_ext_variables_set_storage
+	(struct sieve_interpreter *interp, struct sieve_variable_storage *storage,
+		const struct sieve_extension *ext);	
+		
+/* 
+ * Variable arguments 
+ */
+
+bool sieve_variable_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool assignment);
+	
+/* 
+ * Variable operands 
+ */
+
+extern const struct sieve_operand variable_operand;
+
+bool sieve_variable_operand_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand, 
+		sieve_size_t *address, struct sieve_variable_storage **storage, 
+		unsigned int *var_index);
+bool sieve_variable_operand_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		struct sieve_variable_storage **storage, unsigned int *var_index);
+		
+static inline bool sieve_operand_is_variable
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand == &variable_operand );
+}	
+
+/* 
+ * Modifiers 
+ */
+
+struct sieve_variables_modifier {
+	struct sieve_object object;
+	
+	unsigned int precedence;
+	
+	bool (*modify)(string_t *in, string_t **result);
+};
+
+extern const struct sieve_operand_class sieve_variables_modifier_operand_class;
+
+#define SIEVE_VARIABLES_DEFINE_MODIFIER(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_VARIABLES_DEFINE_MODIFIERS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+void sieve_variables_modifier_register
+	(struct sieve_validator *valdtr, const struct sieve_variables_modifier *smodf);
+
+/*
+ * Code dumping
+ */
+
+void sieve_ext_variables_dump_set_scope
+(const struct sieve_dumptime_env *denv, const struct sieve_extension *ext, 
+	struct sieve_variable_scope *scope);
+
+#endif /* __SIEVE_EXT_VARIABLES_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/plugins/variables/tst-string.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,242 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "ext-variables-common.h"
+
+/* 
+ * String test 
+ *
+ * Syntax:
+ *   string [COMPARATOR] [MATCH-TYPE]
+ *     <source: string-list> <key-list: string-list>
+ */
+
+static bool tst_string_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg);
+static bool tst_string_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_string = { 
+	"string", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_string_registered, 
+	NULL,
+	tst_string_validate, 
+	tst_string_generate, 
+	NULL 
+};
+
+/* 
+ * String operation
+ */
+
+static bool tst_string_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_string_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_string_operation = { 
+	"STRING",
+	&variables_extension, 
+	EXT_VARIABLES_OPERATION_STRING, 
+	tst_string_operation_dump, 
+	tst_string_operation_execute 
+};
+
+/* 
+ * Optional arguments 
+ */
+
+enum tst_string_optional {	
+	OPT_END,
+	OPT_COMPARATOR,
+	OPT_MATCH_TYPE
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_string_registered
+	(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(validator, cmd_reg, OPT_COMPARATOR);
+	sieve_match_types_link_tags(validator, cmd_reg, OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_string_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "source", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(validator, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(validator, tst, arg, &is_match_type, &i_octet_comparator);
+}
+
+/* 
+ * Test generation 
+ */
+
+static bool tst_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_string_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+	
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_string_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "STRING-TEST");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+		
+	return
+		sieve_opr_stringlist_dump(denv, address, "source") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_string_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	int ret, mret;
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_octet_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *source;
+	struct sieve_coded_stringlist *key_list;
+	string_t *src_item;
+	bool matched;
+
+	/*
+	 * Read operands 
+	 */
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read source */
+	if ( (source=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid source operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "STRING test");
+
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+	/* Iterate through all requested strings to match */
+	src_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(source, &src_item)) 
+		&& src_item != NULL ) {
+		const char *src = str_len(src_item) > 0 ? str_c(src_item) : NULL;
+
+		if ( (mret=sieve_match_value
+			(mctx, src, str_len(src_item))) < 0 ) {
+			result = FALSE;
+			break;
+		}
+		
+		matched = ( mret > 0 );				
+	}
+
+	if ( (mret=sieve_match_end(mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( mret > 0 || matched ); 	
+	
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid string list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/rfc2822.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/rfc2822.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/rfc2822.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/rfc2822.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,187 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+/* NOTE: much of the functionality implemented here should eventually appear
+ * somewhere in Dovecot itself.
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "rfc2822.h"
+
+#include <stdio.h>
+#include <ctype.h>
+ 
+bool rfc2822_header_field_name_verify
+(const char *field_name, unsigned int len) 
+{
+	const char *p = field_name;
+	const char *pend = p + len;
+
+	/* field-name   =   1*ftext
+	 * ftext        =   %d33-57 /               ; Any character except
+	 *                  %d59-126                ;  controls, SP, and
+	 *                                          ;  ":".
+	 */
+	 
+	while ( p < pend ) {
+		if ( *p < 33 || *p == ':' )
+			return FALSE;
+
+		p++;
+	}	
+	
+	return TRUE;
+}
+
+bool rfc2822_header_field_body_verify
+(const char *field_body, unsigned int len) 
+{
+	const char *p = field_body;
+	const char *pend = p + len;
+
+	/* unstructured    =       *([FWS] utext) [FWS]
+	 * FWS             =       ([*WSP CRLF] 1*WSP) /   ; Folding white space
+	 *                         obs-FWS
+	 * utext           =       NO-WS-CTL /     ; Non white space controls
+	 *                         %d33-126 /      ; The rest of US-ASCII
+	 *                         obs-utext
+	 * NO-WS-CTL       =       %d1-8 /         ; US-ASCII control characters
+	 *                         %d11 /          ;  that do not include the
+	 *                         %d12 /          ;  carriage return, line feed,
+	 *                         %d14-31 /       ;  and white space characters
+	 *                         %d127
+	 * WSP             =  SP / HTAB
+	 */
+
+	/* This verification does not allow content to be folded. This should done
+	 * automatically upon message composition.
+	 */
+
+	while ( p < pend ) {
+		if ( *p == '\0' || *p == '\r' || *p == '\n' || ((unsigned char)*p) > 127 )
+			return FALSE;
+
+		p++;
+	}	
+	
+	return TRUE;
+}
+
+/*
+ *
+ */
+
+const char *rfc2822_header_field_name_sanitize(const char *name)
+{
+	char *result = t_strdup_noconst(name);
+	char *p;
+	
+	/* Make the whole name lower case ... */
+	result = str_lcase(result);
+
+	/* ... except for the first letter and those that follow '-' */
+	p = result;
+	*p = i_toupper(*p);
+	while ( *p != '\0' ) {
+		if ( *p == '-' ) {
+			p++;
+			
+			if ( *p != '\0' )
+				*p = i_toupper(*p);
+			
+			continue;
+		}
+		
+		p++;
+	}
+	
+	return result;
+}
+
+/*
+ * Message construction
+ */
+ 
+/* FIXME: This should be collected into a Dovecot API for composing internet
+ * mail messages. These functions now use FILE * output streams, but this should
+ * be changed to proper dovecot streams.
+ */
+
+void rfc2822_header_field_write
+(FILE *f, const char *name, const char *body)
+{
+	static const unsigned int max_line = 80;
+	
+	const char *bp = body;  /* Pointer */ 
+	const char *sp = body;  /* Start pointer */
+	const char *wp = NULL;  /* Whitespace pointer */ 
+	const char *nlp = NULL; /* New-line pointer */
+	unsigned int len = strlen(name);
+	
+	/* Write header field name first */
+	fwrite(name, len, 1, f);
+	fwrite(": ", 2, 1, f);
+		
+	/* Add field body; fold it if necessary and account for existing folding */
+	len +=  2;
+	while ( *bp != '\0' ) {
+		while ( *bp != '\0' && nlp == NULL && (wp == NULL || len < max_line) ) {
+			if ( *bp == ' ' || *bp == '\t' ) {
+			 	wp = bp;
+			} else if ( *bp == '\r' || *bp == '\n' ) {
+				nlp = bp;			
+				break;
+			}
+
+			bp++; len++;
+		}
+		
+		if ( *bp == '\0' ) break;
+		
+		/* Existing newline ? */
+		if ( nlp != NULL ) {
+			/* Replace any sort of newline with LF */
+			while ( *bp == '\r' || *bp == '\n' )
+				bp++;
+			
+			fwrite(sp, nlp-sp, 1, f);
+			
+			if ( *bp != '\0' && *bp != ' ' && *bp != '\t' )
+				fwrite("\r\n\t", 3, 1, f);
+			else
+				fwrite("\r\n", 2, 1, f);
+				
+			sp = bp;
+		} else {
+			/* Insert newline at last whitespace within the max_line limit */
+			fwrite(sp, wp-sp, 1, f);
+			fwrite("\r\n", 2, 1, f);
+			sp = wp;
+		}
+		
+		len = bp - sp;		
+		wp = NULL;
+		nlp = NULL;
+	}
+	
+	if ( bp != sp ) {
+		fwrite(sp, bp-sp, 1, f);
+		fwrite("\r\n", 2, 1, f);
+	}
+}
+
+void rfc2822_header_field_printf
+(FILE *f, const char *name, const char *body_fmt, ...)
+{
+	string_t *body = t_str_new(256);
+	va_list args;
+
+	va_start(args, body_fmt);
+	str_vprintfa(body, body_fmt, args);
+	va_end(args);
+	
+	rfc2822_header_field_write(f, name, str_c(body));
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/rfc2822.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/rfc2822.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/rfc2822.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/rfc2822.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,36 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __RFC2822_H
+#define __RFC2822_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+/*
+ * Verification
+ */ 
+ 
+bool rfc2822_header_field_name_verify
+	(const char *field_name, unsigned int len);
+bool rfc2822_header_field_body_verify
+(const char *field_body, unsigned int len);
+
+/*
+ *
+ */
+
+const char *rfc2822_header_field_name_sanitize(const char *name);
+
+/*
+ * Message composition
+ */
+
+void rfc2822_header_field_write
+	(FILE *f, const char *name, const char *body);
+	
+void rfc2822_header_field_printf
+	(FILE *f, const char *name, const char *body_fmt, ...) ATTR_FORMAT(3, 4);
+
+#endif /* __RFC2822_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-actions.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-actions.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-actions.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-actions.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,462 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "strfuncs.h"
+#include "str-sanitize.h"
+#include "mail-storage.h"
+#include "mail-namespace.h"
+
+#include "sieve-code.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-result.h"
+#include "sieve-actions.h"
+
+/*
+ * Action execution environment
+ */
+
+const char *sieve_action_get_location(const struct sieve_action_exec_env *aenv)
+{
+	return t_strdup_printf("msgid=%s", aenv->msgdata->id == NULL ?
+		"unspecified" : str_sanitize(aenv->msgdata->id, 80));
+}
+
+/*
+ * Side-effect operand
+ */
+ 
+const struct sieve_operand_class sieve_side_effect_operand_class = 
+	{ "SIDE-EFFECT" };
+
+bool sieve_opr_side_effect_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	const struct sieve_object *obj;
+	const struct sieve_side_effect *seffect;
+	
+	if ( !sieve_opr_object_dump
+		(denv, &sieve_side_effect_operand_class, address, &obj) )
+		return FALSE;
+	
+	seffect = (const struct sieve_side_effect *) obj;
+
+	if ( seffect->dump_context != NULL ) {
+		sieve_code_descend(denv);
+		if ( !seffect->dump_context(seffect, denv, address) ) {
+			return FALSE;	
+		}
+		sieve_code_ascend(denv);
+	}
+
+	return TRUE;
+}
+
+/*
+ * Store action
+ */
+ 
+/* Forward declarations */
+
+static bool act_store_equals
+	(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2);
+	
+static int act_store_check_duplicate
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_action_data *act, 
+		const struct sieve_action_data *act_other);
+static void act_store_print
+	(const struct sieve_action *action, 
+		const struct sieve_result_print_env *rpenv, void *context, bool *keep);
+
+static bool act_store_start
+	(const struct sieve_action *action,
+		const struct sieve_action_exec_env *aenv, void *context, void **tr_context);
+static bool act_store_execute
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context);
+static bool act_store_commit
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+static void act_store_rollback
+	(const struct sieve_action *action, 
+		const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+		
+/* Action object */
+
+const struct sieve_action act_store = {
+	"store",
+	SIEVE_ACTFLAG_TRIES_DELIVER,
+	act_store_equals,
+	act_store_check_duplicate, 
+	NULL, 
+	act_store_print,
+	act_store_start,
+	act_store_execute,
+	act_store_commit,
+	act_store_rollback,
+};
+
+/* API */
+
+int sieve_act_store_add_to_result
+(const struct sieve_runtime_env *renv, 
+	struct sieve_side_effects_list *seffects, const char *folder,
+	unsigned int source_line)
+{
+	pool_t pool;
+	struct act_store_context *act;
+	
+	/* Add redirect action to the result */
+	pool = sieve_result_pool(renv->result);
+	act = p_new(pool, struct act_store_context, 1);
+	act->folder = p_strdup(pool, folder);
+
+	return sieve_result_add_action(renv, &act_store, seffects, 
+		source_line, (void *) act, 0);
+}
+
+/* Equality */
+
+static bool act_store_equals
+(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2)
+{
+	struct act_store_context *st_ctx1 = (struct act_store_context *) ctx1;
+	struct act_store_context *st_ctx2 = (struct act_store_context *) ctx2;
+	const char *folder1, *folder2;
+	
+	if ( st_ctx1 == NULL && st_ctx2 == NULL )
+		return TRUE;
+		
+	folder1 = ( st_ctx1 == NULL ? 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) : st_ctx1->folder );
+	folder2 = ( st_ctx2 == NULL ? 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) : st_ctx2->folder );
+	
+	if ( strcmp(folder1, folder2) == 0 ) 
+		return TRUE;
+		
+	return 
+		( strcasecmp(folder1, "INBOX") == 0 && strcasecmp(folder2, "INBOX") == 0 ); 
+
+}
+
+/* Result verification */
+
+static int act_store_check_duplicate
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action_data *act, 
+	const struct sieve_action_data *act_other)
+{
+	return ( act_store_equals(renv->scriptenv, act->context, act_other->context)
+		? 1 : 0 );
+}
+
+/* Result printing */
+
+static void act_store_print
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_result_print_env *rpenv, void *context, bool *keep)	
+{
+	struct act_store_context *ctx = (struct act_store_context *) context;
+	const char *folder;
+
+	folder = ( ctx == NULL ? 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(rpenv->scriptenv) : ctx->folder );	
+
+	sieve_result_action_printf(rpenv, "store message in folder: %s", 
+		str_sanitize(folder, 128));
+	
+	*keep = FALSE;
+}
+
+/* Action implementation */
+
+static void act_store_get_storage_error
+(const struct sieve_action_exec_env *aenv, struct act_store_transaction *trans)
+{
+	enum mail_error error;
+	pool_t pool = sieve_result_pool(aenv->result);
+	
+	trans->error = p_strdup(pool, 
+		mail_storage_get_last_error(trans->namespace->storage, &error));
+}
+
+static struct mailbox *act_store_mailbox_open
+(const struct sieve_action_exec_env *aenv, struct mail_namespace *ns, 
+	const char *folder)
+{
+	struct mail_storage **storage = &(aenv->exec_status->last_storage);
+	enum mailbox_open_flags open_flags = 
+		MAILBOX_OPEN_FAST | MAILBOX_OPEN_KEEP_RECENT | 
+		MAILBOX_OPEN_SAVEONLY | MAILBOX_OPEN_POST_SESSION;
+	struct mailbox *box;
+
+	if (strcasecmp(folder, "INBOX") == 0) {
+		/* Deliveries to INBOX must always succeed, regardless of ACLs */
+		open_flags |= MAILBOX_OPEN_IGNORE_ACLS;
+	}
+
+	*storage = ns->storage;
+
+	box = mailbox_open(storage, folder, NULL, open_flags);
+		
+	if ( box == NULL && aenv->scriptenv->mailbox_autocreate ) {
+		enum mail_error error;
+	
+		(void)mail_storage_get_last_error(*storage, &error);
+		if ( error != MAIL_ERROR_NOTFOUND )
+			return NULL;
+
+		/* Try creating it */
+		if ( mail_storage_mailbox_create(*storage, folder, FALSE) < 0 )
+			return NULL;
+   
+		if ( aenv->scriptenv->mailbox_autosubscribe ) {
+			/* Subscribe to it */
+			(void)mailbox_list_set_subscribed(ns->list, folder, TRUE);
+		}
+
+		/* Try opening again */
+		box = mailbox_open(storage, folder, NULL, open_flags);
+    
+		if (box == NULL)
+			return NULL;
+
+		if (mailbox_sync(box, 0, 0, NULL) < 0) {
+			mailbox_close(&box);
+			return NULL;
+		}
+	}
+
+	return box;
+}
+
+static bool act_store_start
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *context, void **tr_context)
+{  
+	struct act_store_context *ctx = (struct act_store_context *) context;
+	struct act_store_transaction *trans;
+	struct mail_namespace *ns = NULL;
+	struct mailbox *box = NULL;
+	pool_t pool = sieve_result_pool(aenv->result);
+
+	/* If context is NULL, the store action is the result of (implicit) keep */	
+	if ( ctx == NULL ) {
+		ctx = p_new(pool, struct act_store_context, 1);
+		ctx->folder = p_strdup(pool, SIEVE_SCRIPT_DEFAULT_MAILBOX(aenv->scriptenv));
+	}
+
+	/* Open the requested mailbox */
+
+	/* NOTE: The caller of the sieve library is allowed to leave namespaces set 
+	 * to NULL. This implementation will then skip actually storing the message.
+	 */
+	if ( aenv->scriptenv->namespaces != NULL ) {
+		ns = mail_namespace_find(aenv->scriptenv->namespaces, &ctx->folder);
+
+		if ( ns != NULL ) {		
+			box = act_store_mailbox_open(aenv, ns, ctx->folder);
+		}
+	}
+				
+	/* Create transaction context */
+	trans = p_new(pool, struct act_store_transaction, 1);
+	trans->context = ctx;
+	trans->namespace = ns;
+	trans->box = box;
+	trans->flags = 0;
+		
+	if ( ns != NULL && box == NULL ) 
+		act_store_get_storage_error(aenv, trans);	
+	
+	*tr_context = (void *)trans;
+
+	return ( aenv->scriptenv->namespaces == NULL || (box != NULL) );
+}
+
+static bool act_store_execute
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context)
+{   
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+	struct mail_keywords *keywords = NULL;
+	struct mail_save_context *save_ctx;
+	
+	/* Verify transaction */
+	if ( trans == NULL ) return FALSE;
+
+	/* Exit early if namespace is not available */
+	if ( trans->namespace == NULL ) {
+		if ( aenv->scriptenv->namespaces == NULL )
+			return TRUE;
+
+		return FALSE;
+	} else if ( trans->box == NULL ) return FALSE;
+
+	/* Mark attempt to store in default mailbox */
+	if ( strcmp(trans->context->folder, 
+		SIEVE_SCRIPT_DEFAULT_MAILBOX(aenv->scriptenv)) == 0 ) 
+		aenv->exec_status->tried_default_save = TRUE;
+
+	/* Mark attempt to use storage. Can only get here when all previous actions
+	 * succeeded. 
+	 */
+	aenv->exec_status->last_storage = trans->namespace->storage;
+	
+	/* Start mail transaction */
+	trans->mail_trans = mailbox_transaction_begin
+		(trans->box, MAILBOX_TRANSACTION_FLAG_EXTERNAL);
+
+	/* Create mail object for stored message */
+	trans->dest_mail = mail_alloc(trans->mail_trans, 0, NULL);
+
+	/* Collect keywords added by side-effects */
+	if ( array_is_created(&trans->keywords) && array_count(&trans->keywords) > 0 ) 
+	{
+		const char *const *kwds;
+		
+		(void)array_append_space(&trans->keywords);
+		kwds = array_idx(&trans->keywords, 0);
+				
+		/* FIXME: Do we need to clear duplicates? */
+		
+		if ( mailbox_keywords_create(trans->box, kwds, &keywords) < 0) {
+			sieve_result_error(aenv, "invalid keywords set for stored message");
+			keywords = NULL;
+		}
+	}
+	
+	/* Store the message */
+	save_ctx = mailbox_save_alloc(trans->mail_trans);
+	mailbox_save_set_flags(save_ctx, trans->flags, keywords);
+	mailbox_save_set_dest_mail(save_ctx, trans->dest_mail);
+	if ( mailbox_copy(&save_ctx, aenv->msgdata->mail) < 0 ) {
+		act_store_get_storage_error(aenv, trans);
+ 		return FALSE;
+ 	}
+ 	
+ 	if ( keywords != NULL ) {
+ 		mailbox_keywords_free(trans->box, &keywords);
+ 	}
+ 		 	
+	return TRUE;
+}
+
+static void act_store_log_status
+(struct act_store_transaction *trans, 
+	const struct sieve_action_exec_env *aenv, bool rolled_back, bool status )
+{
+	const char *mailbox_name;
+	
+	mailbox_name = str_sanitize(trans->context->folder, 128);
+
+	if ( trans->namespace == NULL ) {
+		if ( aenv->scriptenv->namespaces == NULL )
+			sieve_result_log(aenv, "store into mailbox '%s' skipped", mailbox_name);
+		else
+			sieve_result_error
+				(aenv, "failed to find namespace for mailbox '%s'", mailbox_name);
+	} else {	
+		if ( !rolled_back && status ) {
+			sieve_result_log(aenv, "stored mail into mailbox '%s'", mailbox_name);
+		} else {
+			const char *errstr;
+			enum mail_error error;
+		
+			if ( trans->error != NULL )
+				errstr = trans->error;
+			else
+				errstr = mail_storage_get_last_error(trans->namespace->storage, &error);
+			
+			if ( status )
+				sieve_result_log(aenv, "store into mailbox '%s' aborted", mailbox_name);
+			else
+				sieve_result_error(aenv, "failed to store into mailbox '%s': %s", 
+					mailbox_name, errstr);
+		}
+	}
+}
+
+static bool act_store_commit
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep)
+{  
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+	bool status = TRUE;
+
+	/* Verify transaction */
+	if ( trans == NULL ) return FALSE;
+
+	/* Exit early if namespace is not available */
+	if ( trans->namespace == NULL ) {
+		if ( aenv->scriptenv->namespaces == NULL ) {
+			act_store_log_status(trans, aenv, FALSE, status);
+			*keep = FALSE;
+			return TRUE;
+		}
+
+		return FALSE;
+	} else if ( trans->box == NULL ) return FALSE;
+
+	/* Mark attempt to use storage. Can only get here when all previous actions
+	 * succeeded. 
+	 */
+	aenv->exec_status->last_storage = trans->namespace->storage;
+
+	/* Free mail object for stored message */
+	if ( trans->dest_mail != NULL ) 
+		mail_free(&trans->dest_mail);	
+
+	/* Commit mailbox transaction */	
+	status = mailbox_transaction_commit(&trans->mail_trans) == 0;
+
+	/* Note the fact that the message was stored at least once */
+	if ( status )
+		aenv->exec_status->message_saved = TRUE;
+	
+	/* Log our status */
+	act_store_log_status(trans, aenv, FALSE, status);
+	
+	/* Cancel implicit keep if all went well */
+	*keep = !status;
+	
+	/* Close mailbox */	
+	if ( trans->box != NULL )
+		mailbox_close(&trans->box);
+
+	return status;
+}
+
+static void act_store_rollback
+(const struct sieve_action *action ATTR_UNUSED, 
+	const struct sieve_action_exec_env *aenv, void *tr_context, bool success)
+{
+	struct act_store_transaction *trans = 
+		(struct act_store_transaction *) tr_context;
+
+	/* Log status */
+	act_store_log_status(trans, aenv, TRUE, success);
+
+	/* Free mailobject for stored message */
+	if ( trans->dest_mail != NULL ) 
+		mail_free(&trans->dest_mail);	
+
+	/* Rollback mailbox transaction */
+	if ( trans->mail_trans != NULL )
+		mailbox_transaction_rollback(&trans->mail_trans);
+  
+	/* Close the mailbox */
+	if ( trans->box != NULL )  
+		mailbox_close(&trans->box);
+}
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-actions.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-actions.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-actions.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-actions.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,209 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_ACTIONS_H
+#define __SIEVE_ACTIONS_H
+
+#include "lib.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-objects.h"
+#include "sieve-extensions.h"
+
+/*
+ * Action execution environment
+ */
+
+struct sieve_action_exec_env { 
+	struct sieve_result *result;
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+	struct sieve_exec_status *exec_status;
+};
+
+const char *sieve_action_get_location(const struct sieve_action_exec_env *aenv);
+
+/*
+ * Action flags
+ */
+
+enum sieve_action_flags {
+	SIEVE_ACTFLAG_TRIES_DELIVER = (1 << 0),
+	SIEVE_ACTFLAG_SENDS_RESPONSE = (1 << 1)
+};
+
+/*
+ *
+ */
+ 
+struct sieve_action_data {
+	const struct sieve_action *action;
+	const char *location;
+	void *context;
+	bool executed;
+};
+
+/* 
+ * Action object
+ */
+
+struct sieve_action {
+	const char *name;
+	unsigned int flags;
+	
+	bool (*equals)
+		(const struct sieve_script_env *senv, const void *ctx1, const void *ctx2);
+
+	/* Result verification */
+	
+	int (*check_duplicate)	
+		(const struct sieve_runtime_env *renv,
+			const struct sieve_action_data *act, 
+			const struct sieve_action_data *act_other);	
+	int (*check_conflict)
+		(const struct sieve_runtime_env *renv, 
+			const struct sieve_action_data *act, 
+			const struct sieve_action_data *act_other);	
+
+	/* Result printing */
+	
+	void (*print)
+		(const struct sieve_action *action, 
+			const struct sieve_result_print_env *penv, void *context, bool *keep);	
+		
+	/* Result execution */	
+		
+	bool (*start)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *context, 
+			void **tr_context);		
+	bool (*execute)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *tr_context);
+	bool (*commit)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool *keep);
+	void (*rollback)
+		(const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *tr_context, bool success);
+};
+
+/* 
+ * Action side effects 
+ */
+
+/* Side effect object */
+
+struct sieve_side_effect {
+	struct sieve_object object;
+	
+	/* The action it is supposed to link to */
+	
+	const struct sieve_action *to_action;
+		
+	/* Context coding */
+	
+	bool (*dump_context)
+		(const struct sieve_side_effect *seffect, 
+			const struct sieve_dumptime_env *renv, sieve_size_t *address);
+	bool (*read_context)
+		(const struct sieve_side_effect *seffect, 
+			const struct sieve_runtime_env *renv, sieve_size_t *address,
+			void **se_context);
+		
+	/* Result verification */
+	
+	int (*merge)
+		(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+			const struct sieve_side_effect *seffect, 
+			void **old_context, void *new_context);
+
+	/* Result printing */	
+			
+	void (*print)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_result_print_env *penv, void *se_context, bool *keep);
+
+	/* Result execution */
+
+	bool (*pre_execute)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void **se_context, 
+			void *tr_context);
+	bool (*post_execute)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *se_context, 
+			void *tr_context);
+	void (*post_commit)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *se_context,
+			void *tr_context, bool *keep);
+	void (*rollback)
+		(const struct sieve_side_effect *seffect, const struct sieve_action *action, 
+			const struct sieve_action_exec_env *aenv, void *se_context,
+			void *tr_context, bool success);
+};
+
+/*
+ * Side effect operand
+ */
+ 
+#define SIEVE_EXT_DEFINE_SIDE_EFFECT(SEF) SIEVE_EXT_DEFINE_OBJECT(SEF)
+#define SIEVE_EXT_DEFINE_SIDE_EFFECTS(SEFS) SIEVE_EXT_DEFINE_OBJECTS(SEFS)
+
+#define SIEVE_OPT_SIDE_EFFECT -1
+
+extern const struct sieve_operand_class sieve_side_effect_operand_class;
+
+static inline void sieve_opr_side_effect_emit
+(struct sieve_binary *sbin, const struct sieve_side_effect *seff)
+{ 
+	sieve_opr_object_emit(sbin, &seff->object);
+}
+
+static inline const struct sieve_side_effect *sieve_opr_side_effect_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_side_effect *) sieve_opr_object_read
+		(renv, &sieve_side_effect_operand_class, address);
+}
+
+bool sieve_opr_side_effect_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/* 
+ * Core actions 
+ */
+
+extern const struct sieve_action act_redirect;
+extern const struct sieve_action act_store;
+extern const struct sieve_action act_discard;
+
+/* 
+ * Store action
+ */
+
+struct act_store_context {
+	/* Folder name represented in modified utf-7 */
+	const char *folder; 
+};
+
+struct act_store_transaction {
+	struct act_store_context *context;
+	struct mail_namespace *namespace;
+	struct mailbox *box;
+	struct mailbox_transaction_context *mail_trans;
+	struct mail *dest_mail;
+	const char *error;
+	
+	enum mail_flags flags;
+	ARRAY_DEFINE(keywords, const char *);
+};
+
+int sieve_act_store_add_to_result
+	(const struct sieve_runtime_env *renv, 
+		struct sieve_side_effects_list *seffects, const char *folder,
+		unsigned int source_line);
+		
+#endif /* __SIEVE_ACTIONS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,768 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "rfc822-parser.h"
+
+#include "sieve-common.h"
+#include "sieve-address.h"
+
+#include <ctype.h>
+
+/*
+ * RFC 2822 addresses
+ */
+
+/* Mail message address according to RFC 2822 and implemented in the Dovecot 
+ * message address parser:
+ *
+ *   address         =       mailbox / group
+ *   mailbox         =       name-addr / addr-spec
+ *   name-addr       =       [display-name] angle-addr
+ *   angle-addr      =       [CFWS] "<" addr-spec ">" [CFWS] / obs-angle-addr
+ *   group           =       display-name ":" [mailbox-list / CFWS] ";" [CFWS]
+ *   display-name    =       phrase
+ *
+ *   addr-spec       =       local-part "@" domain
+ *   local-part      =       dot-atom / quoted-string / obs-local-part
+ *   domain          =       dot-atom / domain-literal / obs-domain
+ *   domain-literal  =       [CFWS] "[" *([FWS] dcontent) [FWS] "]" [CFWS]
+ *   dcontent        =       dtext / quoted-pair
+ *   dtext           =       NO-WS-CTL /     ; Non white space controls
+ *                           %d33-90 /       ; The rest of the US-ASCII
+ *                           %d94-126        ;  characters not including "[",
+ *                                           ;  "]", or "\"
+ *
+ *   atext           =       ALPHA / DIGIT / ; Any character except controls,
+ *                           "!" / "#" /     ;  SP, and specials.
+ *                           "$" / "%" /     ;  Used for atoms
+ *                           "&" / "'" /
+ *                           "*" / "+" /
+ *                           "-" / "/" /
+ *                           "=" / "?" /
+ *                           "^" / "_" /
+ *                           "`" / "{" /
+ *                           "|" / "}" /
+ *                           "~"
+ *   atom            =       [CFWS] 1*atext [CFWS]
+ *   dot-atom        =       [CFWS] dot-atom-text [CFWS]
+ *   dot-atom-text   =       1*atext *("." 1*atext)
+ *   word            =       atom / quoted-string
+ *   phrase          =       1*word / obs-phrase
+ *
+ * Message address specification as allowed bij the RFC 5228 SIEVE 
+ * specification:
+ *   sieve-address   =       addr-spec                  ; simple address
+ *                           / phrase "<" addr-spec ">" ; name & addr-spec\
+ *
+ * Which concisely is about equal to:
+ *   sieve-address   =       mailbox
+ */ 
+
+/*
+ * Address parse context
+ */
+ 
+struct sieve_message_address_parser {
+	struct rfc822_parser_context parser;
+
+	string_t *str;
+	string_t *local_part;
+	string_t *domain;
+	
+	string_t *error;
+};
+
+/*
+ * Error handling
+ */
+
+static inline void sieve_address_error
+	(struct sieve_message_address_parser *ctx, const char *fmt, ...) 
+		ATTR_FORMAT(2, 3);
+
+static inline void sieve_address_error
+	(struct sieve_message_address_parser *ctx, const char *fmt, ...)
+{
+	va_list args;
+	
+	if ( str_len(ctx->error) == 0 ) {
+		va_start(args, fmt);
+		str_vprintfa(ctx->error, fmt, args);
+		va_end(args);
+	}
+}
+
+/*
+ * Partial RFC 2822 address parser
+ *
+ *   FIXME: lots of overlap with dovecot/src/lib-mail/message-parser.c
+ *          --> this implementation adds textual error reporting
+ *          MERGE!
+ */
+	
+static int parse_local_part(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+
+	/*
+	   local-part      = dot-atom / quoted-string / obs-local-part
+	   obs-local-part  = word *("." word)
+	*/
+	if (ctx->parser.data == ctx->parser.end) {
+		sieve_address_error(ctx, "empty local part");
+		return -1;
+	}
+
+	str_truncate(ctx->local_part, 0);
+	if (*ctx->parser.data == '"')
+		ret = rfc822_parse_quoted_string(&ctx->parser, ctx->local_part);
+	else
+		ret = rfc822_parse_dot_atom(&ctx->parser, ctx->local_part);
+		
+	if (ret < 0) {
+		sieve_address_error(ctx, "invalid local part");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int parse_domain(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+
+	str_truncate(ctx->domain, 0);
+	if ((ret = rfc822_parse_domain(&ctx->parser, ctx->domain)) < 0) {
+		sieve_address_error(ctx, "invalid or missing domain");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int parse_addr_spec(struct sieve_message_address_parser *ctx)
+{
+	/* addr-spec       = local-part "@" domain */
+	int ret;
+
+	if ((ret = parse_local_part(ctx)) < 0)
+		return ret;
+	
+	if ( ret > 0 && *ctx->parser.data == '@') {
+		return parse_domain(ctx);
+	} 
+
+	sieve_address_error(ctx, "invalid or lonely local part '%s' (expecting '@')", 
+		str_sanitize(str_c(ctx->local_part), 80));
+	return -1;
+}
+
+static int parse_mailbox(struct sieve_message_address_parser *ctx)
+{
+	int ret;
+	const unsigned char *start;
+	
+	/* sieve-address   =       addr-spec                  ; simple address
+	 *                         / phrase "<" addr-spec ">" ; name & addr-spec
+	 */
+ 
+	/* Record parser state in case we fail at our first attempt */
+	start = ctx->parser.data;   
+ 
+	/* First try: phrase "<" addr-spec ">" ; name & addr-spec */	
+	str_truncate(ctx->str, 0);
+	if (rfc822_parse_phrase(&ctx->parser, ctx->str) <= 0 ||
+	    *ctx->parser.data != '<') {
+	  /* Failed; try just bare addr-spec */
+	  ctx->parser.data = start;
+	  return parse_addr_spec(ctx);
+	} 
+
+	/* "<" addr-spec ">" */
+	ctx->parser.data++;
+
+	if ((ret = rfc822_skip_lwsp(&ctx->parser)) <= 0 ) {
+		if ( ret < 0 )	
+			sieve_address_error(ctx, "invalid characters after <");		
+		return ret;
+	} 
+
+	if ((ret = parse_addr_spec(ctx)) < 0)
+		return -1;
+
+	if (*ctx->parser.data != '>') {
+		sieve_address_error(ctx, "missing '>'");
+		return -1;
+	}
+	ctx->parser.data++;
+
+	if ( (ret=rfc822_skip_lwsp(&ctx->parser)) < 0 )
+		sieve_address_error(ctx, "address ends with invalid characters");
+		
+	return ret;
+}
+
+static bool parse_mailbox_address
+(struct sieve_message_address_parser *ctx, const unsigned char *address, 
+	unsigned int addr_size)
+{
+	int ret;
+	
+	/* Initialize parser */
+	
+	rfc822_parser_init(&ctx->parser, address, addr_size, NULL);
+
+	/* Parse */
+	
+	rfc822_skip_lwsp(&ctx->parser);
+
+	if (ctx->parser.data == ctx->parser.end) {
+		sieve_address_error(ctx, "empty address");
+		return FALSE;
+	}
+	
+	if ((ret = parse_mailbox(ctx)) < 0) {
+		return FALSE;
+	}
+
+	if (ctx->parser.data != ctx->parser.end) {
+		if ( *ctx->parser.data == ',' ) 
+			sieve_address_error(ctx, "not a single addres (found ',')");
+		else
+			sieve_address_error(ctx, "address ends in invalid characters");
+		return FALSE;
+	}
+			
+	if ( str_len(ctx->domain) == 0 ) {
+		/* Not gonna happen */
+		sieve_address_error(ctx, "missing domain");
+		return FALSE;
+	}
+
+	if ( str_len(ctx->local_part) == 0 ) {
+		sieve_address_error(ctx, "missing local part");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/* FIXME: change the names of these functions */
+bool sieve_rfc2822_mailbox_validate(const char *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+	
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, (const unsigned char *) address, 
+		strlen(address)) ) {
+		if ( error_r != NULL )	
+			*error_r = str_c(ctx.error);
+		return FALSE;
+	}
+
+	if ( error_r != NULL )
+		*error_r = NULL;
+
+	return TRUE;
+}
+
+const char *sieve_rfc2822_mailbox_normalize
+	(const char *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+	
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, (const unsigned char *) address, 
+		strlen(address)) ) {
+		if ( error_r != NULL )	
+			*error_r = str_c(ctx.error);
+		return NULL;
+	}
+
+	if ( error_r != NULL )
+		*error_r = NULL;
+		
+	(void)str_lcase(str_c_modifiable(ctx.domain));
+
+	return t_strconcat(str_c(ctx.local_part), "@", str_c(ctx.domain), NULL);
+}
+
+/*
+ * Sieve address
+ */
+
+const char *sieve_address_normalize
+(string_t *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+	
+	ctx.local_part = t_str_new(128);
+	ctx.domain = t_str_new(128);
+	ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, str_data(address), str_len(address)) )
+	{
+		*error_r = str_c(ctx.error);
+		return NULL;
+	}
+	
+	*error_r = NULL;
+	(void)str_lcase(str_c_modifiable(ctx.domain));
+
+	return t_strconcat(str_c(ctx.local_part), "@", str_c(ctx.domain), NULL);
+}
+
+bool sieve_address_validate
+(string_t *address, const char **error_r)
+{
+	struct sieve_message_address_parser ctx;
+
+	memset(&ctx, 0, sizeof(ctx));
+
+	ctx.local_part = ctx.domain = ctx.str = t_str_new(128);
+	ctx.error = t_str_new(128);
+
+	if ( !parse_mailbox_address(&ctx, str_data(address), str_len(address)) )
+	{
+		*error_r = str_c(ctx.error);
+		return FALSE;
+	}
+	
+	*error_r = NULL;
+	return TRUE;
+}
+
+int sieve_address_compare
+(const char *address1, const char *address2, bool normalized ATTR_UNUSED)
+{
+	/* NOTE: this deviates from RFC specification in that it compares the local 
+	 * part of the address case-insensitively. This however conforms to the 
+	 * consensus in mail software.
+	 */
+	 
+	/* FIXME: provided addresses are currently assumed to be normalized to 
+	 * local_part@domain
+	 */
+	 
+	return strcasecmp(address1, address2);
+}
+
+/*
+ * RFC 2821 addresses (envelope paths)
+ */
+ 
+/* FIXME: Quite a bit of this will overlap with the rfc822 parser
+ * dovecot already has and the rfc2821 parser that it probably will
+ * have once it implements LMTP. For now we implement things separately. 
+ */
+
+#define AB (1<<0)
+#define DB (1<<1)
+#define QB (1<<2)
+
+/* atext = ALPHA / DIGIT / "!" / "#" / "$" / "%"
+ *         / "&" / "'" / "*" / "+" / "-" / "/" / "="
+ *         / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~" 
+ */
+//#define IS_ATEXT(C) ((rfc2821_chars[C] & AB) != 0) 
+
+/* dtext = NO-WS-CTL / %d33-90 / %d94-126 
+ * NO-WS-CTL = %d1-8 / %d11 / %d12 / %d14-31 / %d127 
+ */
+#define IS_DTEXT(C) ((rfc2821_chars[C] & DB) != 0) 
+
+/* qtext= NO-WS-CTL  / %d33 / %d35-91 / %d93-126 */
+#define IS_QTEXT(C) ((rfc2821_chars[C] & QB) == 0) 
+
+/* text	= %d1-9 / %d11 / %d12 / %d14-127 / obs-text*/
+#define IS_TEXT(C) ((C) != '\r' && (C) != '\n' && (C) < 128)
+
+static unsigned char rfc2821_chars[256] = {
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 0
+	   DB,    QB,    QB,    DB,    DB,    QB,    DB,    DB, // 8
+     DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 16
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 24
+	   QB, DB|AB, QB|DB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 32
+	   DB,    DB, DB|AB, DB|AB,    DB, DB|AB,    DB, DB|AB, // 40
+	   DB,    DB,    DB,    DB,    DB,    DB,    DB,    DB, // 48
+	   DB,    DB,    DB,    DB,    DB, DB|AB,    DB, DB|AB, // 56
+	   DB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 64
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 72
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 80
+	DB|AB, DB|AB, DB|AB,     0,    QB,     0, DB|AB, DB|AB, // 88
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 96
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 104
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, // 112
+	DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|AB, DB|QB, // 120
+
+	0, 0, 0, 0, 0, 0, 0, 0, // 128
+	0, 0, 0, 0, 0, 0, 0, 0, // 136
+	0, 0, 0, 0, 0, 0, 0, 0, // 144
+	0, 0, 0, 0, 0, 0, 0, 0, // 152
+	0, 0, 0, 0, 0, 0, 0, 0, // 160
+	0, 0, 0, 0, 0, 0, 0, 0, // 168
+	0, 0, 0, 0, 0, 0, 0, 0, // 176
+	0, 0, 0, 0, 0, 0, 0, 0, // 184
+	0, 0, 0, 0, 0, 0, 0, 0, // 192
+	0, 0, 0, 0, 0, 0, 0, 0, // 200
+	0, 0, 0, 0, 0, 0, 0, 0, // 208
+	0, 0, 0, 0, 0, 0, 0, 0, // 216
+	0, 0, 0, 0, 0, 0, 0, 0, // 224
+	0, 0, 0, 0, 0, 0, 0, 0, // 232
+	0, 0, 0, 0, 0, 0, 0, 0, // 240
+	0, 0, 0, 0, 0, 0, 0, 0, // 248
+
+};
+
+struct sieve_envelope_address_parser {
+	const unsigned char *data;
+	const unsigned char *end;
+
+	string_t *str;
+
+	struct sieve_address *address;
+};
+
+static int path_skip_white_space(struct sieve_envelope_address_parser *parser)
+{
+	/* Not mentioned anywhere in the specification, but we do it any way
+	 * (e.g. Exim does so too)
+	 */
+	while ( parser->data < parser->end && 
+		(*parser->data == ' ' || *parser->data == '\t') )
+		parser->data++;
+
+	return parser->data < parser->end;
+}
+
+static int path_skip_address_literal
+(struct sieve_envelope_address_parser *parser)
+{
+	int count = 0;
+
+	/* Currently we are oblivious to address syntax:
+	 * address-literal = "[" 1*dcontent "]"
+	 * dcontent	= dtext / quoted-pair
+	 */
+
+	i_assert ( *parser->data == '[' );
+
+	str_append_c(parser->str, *parser->data);
+	parser->data++;
+
+	while ( parser->data < parser->end ) {
+		if ( *parser->data == '\\' ) {
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+				
+			if ( parser->data < parser->end ) {
+				if ( !IS_TEXT(*parser->data) ) 
+					return -1;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			} else return -1;
+		} else {
+			if ( !IS_DTEXT(*parser->data) )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+		}
+
+		count++;
+	}
+
+		
+	if ( count == 0 || parser->data >= parser->end || *parser->data != ']' )
+		return -1;
+
+	str_append_c(parser->str, *parser->data);
+	parser->data++;
+
+	return parser->data < parser->end;
+}
+
+static int path_parse_domain
+(struct sieve_envelope_address_parser *parser, bool skip)
+{
+	int ret;
+
+	/* Domain = (sub-domain 1*("." sub-domain)) / address-literal
+	 * sub-domain = Let-dig [Ldh-str]
+	 * Let-dig = ALPHA / DIGIT
+	 * Ldh-str = *( ALPHA / DIGIT / "-" ) Let-dig
+	 */
+	
+	str_truncate(parser->str, 0);
+	if ( *parser->data == '[' ) {
+		ret = path_skip_address_literal(parser);
+
+		if ( ret < 0 ) return ret;
+	} else {
+		for (;;) {
+			if ( !i_isalnum(*parser->data) )
+				return -1;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			while ( parser->data < parser->end ) {
+				if ( !i_isalnum(*parser->data) && *parser->data != '-' )
+					break;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+
+			if ( !i_isalnum(*(parser->data-1)) )
+				return -1;
+			
+			if ( (ret=path_skip_white_space(parser)) < 0 )
+				return ret;
+
+			if ( *parser->data != '.' )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+		}
+	}
+
+	if ( !skip )
+		parser->address->domain = t_strdup(str_c(parser->str));
+
+	return path_skip_white_space(parser);
+}
+
+static int path_skip_source_route(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+
+	/* Source-route = [ A-d-l ":" ] 
+	 * A-d-l = At-domain *( "," A-d-l )
+	 * At-domain = "@" domain
+	 */
+
+	if ( *parser->data == '@' ) {
+		parser->data++;
+	
+		for (;;) {
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;	
+
+			if ( (ret=path_parse_domain(parser, TRUE)) <= 0 )
+				return -1;	
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return ret;
+
+			/* Next? */
+			if ( *parser->data != ',' )
+				break;
+			parser->data++;
+
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+
+			if ( *parser->data != '@' )
+				return -1;
+			parser->data++;
+		}
+
+		if ( *parser->data != ':' )
+			return -1;
+		parser->data++;
+	}
+
+	return path_skip_white_space(parser);
+}
+
+static int path_parse_local_part(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+	/* Local-part = Dot-string / Quoted-string
+	 * Dot-string = Atom *("." Atom)
+	 * Atom = 1*atext
+	 * Quoted-string = DQUOTE *qcontent DQUOTE
+	 * qcontent = qtext / quoted-pair
+	 * quoted-pair  =   ("\" text)
+	 */
+
+	str_truncate(parser->str, 0);
+	if ( *parser->data == '"' ) {
+		str_append_c(parser->str, *parser->data);
+		parser->data++;
+
+		while ( parser->data < parser->end ) {
+			if ( *parser->data == '\\' ) {
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+
+				if ( parser->data < parser->end ) {
+					if ( !IS_TEXT(*parser->data) )
+						return -1;
+
+					str_append_c(parser->str, *parser->data);
+					parser->data++;
+				} else return -1;
+			} else {
+				if ( !IS_QTEXT(*parser->data) )
+					break;
+
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+		}
+		
+		if ( *parser->data != '"' )
+			return -1;
+
+		str_append_c(parser->str, *parser->data);
+		parser->data++;
+		
+		if ( (ret=path_skip_white_space(parser)) < 0 )
+			return ret;
+	} else {
+		for (;;) {
+			if ( !IS_ATEXT(*parser->data) ) 
+				return -1;
+			str_append_c(parser->str, *parser->data);
+			parser->data++;
+
+			while ( parser->data < parser->end && IS_ATEXT(*parser->data)) {
+				str_append_c(parser->str, *parser->data);
+				parser->data++;
+			}
+			
+			if ( (ret=path_skip_white_space(parser)) < 0 )
+				return ret;
+
+			if ( *parser->data != '.' )
+				break;
+
+			str_append_c(parser->str, *parser->data);
+				parser->data++;
+	
+			if ( (ret=path_skip_white_space(parser)) <= 0 )
+				return -1;
+		}
+	}
+
+	parser->address->local_part = t_strdup(str_c(parser->str));
+	return parser->data < parser->end;
+}
+
+static int path_parse_mailbox(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+
+	/* Mailbox = Local-part "@" Domain */
+	
+	if ( (ret=path_parse_local_part(parser)) <= 0 )
+		return -1;
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return -1;
+
+	if ( *parser->data != '@' )
+		return -1;
+	parser->data++;
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 )
+		return -1;
+
+	return path_parse_domain(parser, FALSE);
+}
+
+static int path_parse(struct sieve_envelope_address_parser *parser)
+{
+	int ret;
+	bool brackets = FALSE;
+
+	/* Path = "<" [ A-d-l ":" ] Mailbox ">" */
+
+	if ( (ret=path_skip_white_space(parser)) <= 0 ) 
+		return ret;
+	
+	/* We allow angle brackets to be missing */
+	if ( *parser->data == '<' ) {
+		parser->data++;
+		brackets = TRUE;
+
+		if ( (ret=path_skip_white_space(parser)) <= 0 ) 
+			return -1;
+
+		/* Null path? */
+		if ( *parser->data == '>' ) {
+			parser->data++;
+			return path_skip_white_space(parser);
+		}
+	}
+
+	/*  [ A-d-l ":" ] Mailbox */
+	if ( (ret=path_skip_source_route(parser)) <= 0 )
+		return -1;
+
+	if ( (ret=path_parse_mailbox(parser)) < 0 )
+		return -1;
+
+	if ( ret > 0 && (ret=path_skip_white_space(parser)) < 0 ) 
+		return -1;
+
+	if ( brackets ) {
+		if ( ret <= 0 ) return -1;
+
+		if ( *parser->data != '>' )
+			return -1;
+		parser->data++;
+	}
+
+	return parser->data < parser->end;
+}
+
+const struct sieve_address *sieve_address_parse_envelope_path
+(const char *field_value)
+{
+	struct sieve_envelope_address_parser parser;
+	int ret;
+
+	parser.data = (const unsigned char *) field_value;
+	parser.end = (const unsigned char *) field_value + strlen(field_value);
+	parser.address = t_new(struct sieve_address, 1);
+	parser.str = t_str_new(256);
+
+	if ( (ret=path_parse(&parser)) < 0 )
+		return NULL;
+	
+	if ( ret > 0 && path_skip_white_space(&parser) < 0 )
+		return NULL;
+
+	if ( parser.data != parser.end )
+		return NULL;
+
+	return parser.address;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,41 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_ADDRESS_H
+#define __SIEVE_ADDRESS_H
+ 
+/*
+ * Generic address representation
+ */ 
+ 
+struct sieve_address {
+	const char *local_part;
+	const char *domain;
+};
+
+/* 
+ * RFC 2822 addresses
+ */ 
+
+bool sieve_rfc2822_mailbox_validate
+	(const char *address, const char **error_r);
+const char *sieve_rfc2822_mailbox_normalize
+	(const char *address, const char **error_r);
+
+
+const char *sieve_address_normalize
+	(string_t *address, const char **error_r);
+bool sieve_address_validate
+	(string_t *address, const char **error_r);
+	
+int sieve_address_compare
+	(const char *address1, const char *address2, bool normalized);
+
+/*
+ * RFC 2821 addresses (paths)
+ */
+
+const struct sieve_address *sieve_address_parse_envelope_path
+	(const char *field_value);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address-parts.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,376 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+#include "message-address.h"
+
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-address.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include "sieve-address-parts.h"
+
+#include <string.h>
+
+/* 
+ * Default address parts
+ */
+
+const struct sieve_address_part *sieve_core_address_parts[] = {
+	&all_address_part, &local_address_part, &domain_address_part
+};
+
+const unsigned int sieve_core_address_parts_count = 
+	N_ELEMENTS(sieve_core_address_parts);
+
+/* 
+ * Address-part 'extension' 
+ */
+
+static int ext_my_id = -1;
+
+static bool addrp_validator_load(struct sieve_validator *validator);
+
+const struct sieve_extension address_part_extension = {
+	"@address-parts",
+	&ext_my_id,
+	NULL, NULL,
+	addrp_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS /* Defined as core operand */
+};
+
+static const struct sieve_extension *ext_this = &address_part_extension;
+	
+/* 
+ * Validator context:
+ *   name-based address-part registry. 
+ */
+ 
+void sieve_address_part_register
+(struct sieve_validator *validator, const struct sieve_address_part *addrp) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	
+	sieve_validator_object_registry_add(regs, &addrp->object);
+}
+
+const struct sieve_address_part *sieve_address_part_find
+(struct sieve_validator *validator, const char *identifier) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(regs, identifier);
+
+  return (const struct sieve_address_part *) object;
+}
+
+bool addrp_validator_load(struct sieve_validator *validator)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_init(validator, ext_this);
+	unsigned int i;
+
+	/* Register core address-parts */
+	for ( i = 0; i < sieve_core_address_parts_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, &(sieve_core_address_parts[i]->object));
+	}
+
+	return TRUE;
+}
+
+void sieve_address_parts_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code) 
+{	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &address_part_tag, id_code); 	
+}
+
+/* 
+ * Address-part tagged argument 
+ */
+ 
+/* Forward declarations */
+
+static bool tag_address_part_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *arg);
+static bool tag_address_part_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_address_part_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument object */
+
+const struct sieve_argument address_part_tag = { 
+	"ADDRESS-PART",
+	tag_address_part_is_instance_of, 
+	NULL,
+	tag_address_part_validate,
+	NULL, 
+	tag_address_part_generate 
+};
+
+/* Argument implementation */
+  
+static bool tag_address_part_is_instance_of
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg)
+{
+	struct sieve_address_part_context *adpctx;
+	const struct sieve_address_part *addrp = sieve_address_part_find
+		(validator, sieve_ast_argument_tag(arg));
+
+	if ( addrp == NULL ) return FALSE;
+
+	adpctx = p_new(sieve_command_pool(cmd), struct sieve_address_part_context, 1);
+	adpctx->command_ctx = cmd;
+	adpctx->address_part = addrp;
+
+	/* Store address-part in context */
+	arg->context = (void *) adpctx;
+
+	return TRUE;
+}
+ 
+static bool tag_address_part_validate
+(struct sieve_validator *validator ATTR_UNUSED, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	/* FIXME: Currenly trivial, but might need to allow for further validation for
+	 * future extensions.
+	 */
+	 
+	/* Syntax:   
+	 *   ":localpart" / ":domain" / ":all" (subject to extension)
+   */
+	
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+
+	return TRUE;
+}
+
+static bool tag_address_part_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_address_part_context *adpctx =
+		(struct sieve_address_part_context *) arg->context;
+		
+	sieve_opr_address_part_emit(cgenv->sbin, adpctx->address_part); 
+		
+	return TRUE;
+}
+
+/*
+ * Address-part operand
+ */
+ 
+const struct sieve_operand_class sieve_address_part_operand_class = 
+	{ "address part" };
+
+static const struct sieve_extension_objects core_address_parts =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(sieve_core_address_parts);
+
+const struct sieve_operand address_part_operand = { 
+	"address-part", 
+	NULL, SIEVE_OPERAND_ADDRESS_PART,
+	&sieve_address_part_operand_class,
+	&core_address_parts
+};
+
+/*
+ * Address Matching
+ */
+ 
+int sieve_address_match
+(const struct sieve_address_part *addrp, struct sieve_match_context *mctx, 		
+	const char *data)
+{
+	int result = FALSE;
+	const struct message_address *addr;
+
+	T_BEGIN {
+		bool valid = TRUE;
+		const struct message_address *aitem;
+
+		addr = message_address_parse
+			(pool_datastack_create(), (const unsigned char *) data, 
+				strlen(data), 256, FALSE);
+
+		/* Check validity of all addresses simultaneously. Unfortunately,
+		 * errorneous addresses cannot be extracted from the address list
+		 * and therefore :all will match against the whole header value
+		 * which is not entirely standard.
+		 */
+		aitem = addr;
+		while ( aitem != NULL) {
+			if ( aitem->invalid_syntax )
+				valid = FALSE;
+			aitem = aitem->next;
+		}
+
+		if ( !valid || addr == NULL ) {
+			if ( addrp == &all_address_part )
+				result = sieve_match_value(mctx, data, strlen(data));
+			else 
+				result = FALSE;
+		} else {
+			while ( result == 0 && addr != NULL) {
+				/* mailbox@domain */
+				struct sieve_address address;
+				const char *part;
+			
+				if ( addr->domain != NULL ) {
+					address.local_part = addr->mailbox;
+					address.domain = addr->domain;
+	
+					part = addrp->extract_from(&address);
+
+					if ( part != NULL )
+						result = sieve_match_value(mctx, part, strlen(part));
+				}
+				addr = addr->next;
+			}
+		}
+	} T_END;
+	
+	return result;
+}
+
+/* 
+ * Default ADDRESS-PART, MATCH-TYPE, COMPARATOR access
+ */
+ 
+bool sieve_addrmatch_default_dump_optionals
+(const struct sieve_dumptime_env *denv, sieve_size_t *address) 
+{
+	int opt_code = 1;
+	
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) 
+				return FALSE;
+
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case SIEVE_AM_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_ADDRESS_PART:
+				if ( !sieve_opr_address_part_dump(denv, address) )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+bool sieve_addrmatch_default_get_optionals
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	const struct sieve_address_part **addrp, const struct sieve_match_type **mtch, 
+	const struct sieve_comparator **cmp) 
+{
+	int opt_code = 1;
+	
+	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) )
+				return FALSE;
+				  
+			switch ( opt_code ) {
+			case 0:
+				break;
+			case SIEVE_AM_OPT_COMPARATOR:
+				if ( (*cmp = sieve_opr_comparator_read(renv, address)) == NULL )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_MATCH_TYPE:
+				if ( (*mtch = sieve_opr_match_type_read(renv, address)) == NULL )
+					return FALSE;
+				break;
+			case SIEVE_AM_OPT_ADDRESS_PART:
+				if ( (*addrp = sieve_opr_address_part_read(renv, address)) == NULL )
+					return FALSE;
+				break;
+			default:
+				return FALSE;
+			}
+		}
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Core address-part modifiers
+ */
+ 
+static const char *addrp_all_extract_from
+	(const struct sieve_address *address)
+{
+	const char *local_part = address->local_part;
+	const char *domain = address->domain;
+
+	return t_strconcat(local_part, "@", domain, NULL);
+}
+
+static const char *addrp_domain_extract_from
+	(const struct sieve_address *address)
+{
+	return address->domain;
+}
+
+static const char *addrp_localpart_extract_from
+	(const struct sieve_address *address)
+{
+	return address->local_part;
+}
+
+const struct sieve_address_part all_address_part = {
+	SIEVE_OBJECT("all", &address_part_operand, SIEVE_ADDRESS_PART_ALL),
+	addrp_all_extract_from
+};
+
+const struct sieve_address_part local_address_part = {
+	SIEVE_OBJECT("localpart", &address_part_operand, SIEVE_ADDRESS_PART_LOCAL),
+	addrp_localpart_extract_from
+};
+
+const struct sieve_address_part domain_address_part = {
+	SIEVE_OBJECT("domain", &address_part_operand,	SIEVE_ADDRESS_PART_DOMAIN),
+	addrp_domain_extract_from
+};
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-address-parts.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,116 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_ADDRESS_PARTS_H
+#define __SIEVE_ADDRESS_PARTS_H
+
+#include "message-address.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-objects.h"
+
+/*
+ * Address part object 
+ */
+
+struct sieve_address_part {
+	struct sieve_object object;		
+
+	const char *(*extract_from)(const struct sieve_address *address);
+};
+
+/*
+ * Core address parts
+ */
+ 
+enum sieve_address_part_code {
+	SIEVE_ADDRESS_PART_ALL,
+	SIEVE_ADDRESS_PART_LOCAL,
+	SIEVE_ADDRESS_PART_DOMAIN,
+	SIEVE_ADDRESS_PART_CUSTOM
+};
+
+extern const struct sieve_address_part all_address_part;
+extern const struct sieve_address_part local_address_part;
+extern const struct sieve_address_part domain_address_part;
+
+/*
+ * Address part tagged argument
+ */
+ 
+extern const struct sieve_argument address_part_tag;
+
+struct sieve_address_part_context {
+	struct sieve_command_context *command_ctx;
+	const struct sieve_address_part *address_part;
+};
+
+void sieve_address_parts_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code);
+
+/*
+ * Address part registry
+ */
+		
+void sieve_address_part_register
+	(struct sieve_validator *validator, 
+		const struct sieve_address_part *addrp);
+const struct sieve_address_part *sieve_address_part_find
+	(struct sieve_validator *validator, const char *identifier);
+		
+/*
+ * Address part operand
+ */
+
+extern const struct sieve_operand address_part_operand;
+extern const struct sieve_operand_class sieve_address_part_operand_class;
+
+#define SIEVE_EXT_DEFINE_ADDRESS_PART(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_ADDRESS_PARTS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+static inline void sieve_opr_address_part_emit
+(struct sieve_binary *sbin, const struct sieve_address_part *addrp)
+{ 
+	sieve_opr_object_emit(sbin, &addrp->object);
+}
+
+static inline const struct sieve_address_part *sieve_opr_address_part_read
+  (const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_address_part *) sieve_opr_object_read
+		(renv, &sieve_address_part_operand_class, address);
+}
+
+static inline bool sieve_opr_address_part_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_address_part_operand_class, address, NULL);
+}
+
+/* 
+ * Match utility 
+ */
+
+int sieve_address_match
+(const struct sieve_address_part *addrp, struct sieve_match_context *mctx,
+    const char *data);
+
+enum sieve_addrmatch_opt_operand {
+	SIEVE_AM_OPT_END,
+	SIEVE_AM_OPT_COMPARATOR,
+	SIEVE_AM_OPT_ADDRESS_PART,
+	SIEVE_AM_OPT_MATCH_TYPE
+};
+
+bool sieve_addrmatch_default_dump_optionals
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+bool sieve_addrmatch_default_get_optionals
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		const struct sieve_address_part **addp, 
+		const struct sieve_match_type **mtch, const struct sieve_comparator **cmp);
+
+#endif /* __SIEVE_ADDRESS_PARTS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-ast.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-ast.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-ast.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-ast.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1055 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-extensions.h"
+
+#include "sieve-ast.h"
+
+#include <stdio.h>
+
+/* 
+ * Forward declarations 
+ */
+
+static struct sieve_ast_node *sieve_ast_node_create
+	(struct sieve_ast *ast, struct sieve_ast_node *parent, 
+		enum sieve_ast_type type, unsigned int source_line);
+
+/*
+ * Types
+ */
+
+/* Extensions to the AST */
+
+struct sieve_ast_extension_reg {
+	const struct sieve_ast_extension *ast_ext;
+	void *context;
+};
+
+/* 
+ * AST object 
+ */
+
+struct sieve_ast {
+	pool_t pool;
+	int refcount;
+		
+	struct sieve_script *script;
+		
+	struct sieve_ast_node *root;
+	
+	ARRAY_DEFINE(linked_extensions, const struct sieve_extension *);
+	ARRAY_DEFINE(extensions, struct sieve_ast_extension_reg);
+};
+
+struct sieve_ast *sieve_ast_create(struct sieve_script *script) 
+{
+	pool_t pool;
+	struct sieve_ast *ast;
+	
+	pool = pool_alloconly_create("sieve_ast", 16384);	
+	ast = p_new(pool, struct sieve_ast, 1);
+	ast->pool = pool;
+	ast->refcount = 1;
+	
+	ast->script = script;
+	sieve_script_ref(script);
+		
+	ast->root = sieve_ast_node_create(ast, NULL, SAT_ROOT, 0);
+	ast->root->identifier = "ROOT";
+	
+	p_array_init(&ast->linked_extensions, pool, sieve_extensions_get_count());
+	p_array_init(&ast->extensions, pool, sieve_extensions_get_count());
+	
+	return ast;
+}
+
+void sieve_ast_ref(struct sieve_ast *ast) 
+{
+	ast->refcount++;
+}
+
+void sieve_ast_unref(struct sieve_ast **ast) 
+{
+	unsigned int i, ext_count;
+	const struct sieve_ast_extension_reg *extrs;
+	
+	i_assert((*ast)->refcount > 0);
+
+	if (--(*ast)->refcount != 0)
+		return;
+	
+	/* Release script reference */
+	sieve_script_unref(&(*ast)->script);
+	
+	/* Signal registered extensions that the AST is being destroyed */
+	extrs = array_get(&(*ast)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].ast_ext != NULL && 
+			extrs[i].ast_ext->free != NULL )
+			extrs[i].ast_ext->free(*ast, extrs[i].context);
+	}
+
+	/* Destroy AST */
+	pool_unref(&(*ast)->pool);
+	
+	*ast = NULL;
+}
+
+struct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast)
+{
+	return ast->root;
+}
+
+pool_t sieve_ast_pool(struct sieve_ast *ast)
+{
+	return ast->pool;
+}
+
+struct sieve_script *sieve_ast_script(struct sieve_ast *ast)
+{
+	return ast->script;
+}
+
+/* 
+ * Extension support 
+ */
+
+void sieve_ast_extension_link
+(struct sieve_ast *ast, const struct sieve_extension *ext)
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	unsigned int i, ext_count;
+	const struct sieve_extension *const *extensions;
+	
+	if ( ext_id < 0 ) return;
+	 
+	/* Prevent duplicates */
+	extensions = array_get(&ast->linked_extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extensions[i] == ext )
+			return;
+	}
+
+	/* Add extension */
+	array_append(&ast->linked_extensions, &ext, 1);	
+}
+
+const struct sieve_extension * const *sieve_ast_extensions_get
+(struct sieve_ast *ast, unsigned int *count_r)
+{
+	return array_get(&ast->linked_extensions, count_r);
+}
+
+void sieve_ast_extension_register
+(struct sieve_ast *ast, const struct sieve_ast_extension *ast_ext, 
+	void *context)
+{
+	int ext_id = SIEVE_EXT_ID(ast_ext->ext);
+	struct sieve_ast_extension_reg reg;
+
+	if ( ext_id < 0 ) return;
+
+	/* Initialize registration */
+	reg.ast_ext = ast_ext;
+	reg.context = context;	
+	array_idx_set(&ast->extensions, (unsigned int) ext_id, &reg);
+}
+
+void *sieve_ast_extension_get_context
+(struct sieve_ast *ast, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_ast_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&ast->extensions) )
+		return NULL;
+	
+	reg = array_idx(&ast->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/*
+ * AST list implementations
+ */
+ 
+/* Very simplistic linked list implementation
+ * FIXME: Move to separate file
+ */
+#define __LIST_CREATE(pool, type) { \
+		type *list = p_new(pool, type, 1); \
+		list->head = NULL; \
+		list->tail = NULL; \
+		list->len = 0;		\
+		return list; \
+	}
+
+#define __LIST_ADD(list, node) { \
+		if ( list->len + 1 < list->len ) \
+			return FALSE; \
+		\
+		node->next = NULL; \
+		if ( list->head == NULL ) { \
+			node->prev = NULL; \
+			list->head = node; \
+			list->tail = node; \
+		} else { \
+			list->tail->next = node; \
+			node->prev = list->tail; \
+			list->tail = node; \
+		} \
+		list->len++; \
+		node->list = list; \
+		return TRUE; \
+	}	 
+	
+#define __LIST_INSERT(list, before, node) { \
+		if ( list->len + 1 < list->len ) \
+			return FALSE; \
+		\
+		node->next = before; \
+		if ( list->head == before ) { \
+			node->prev = NULL; \
+			list->head = node; \
+		} else { \
+			before->prev->next = node; \
+		} \
+		node->prev = before->prev; \
+		before->prev = node; \
+		list->len++; \
+		node->list = list; \
+		\
+		return TRUE; \
+	}
+
+#define __LIST_JOIN(list, items) { \
+		typeof(items->head) node; \
+		\
+		if ( list->len + items->len < list->len ) \
+			return FALSE; \
+		\
+		if ( items->len == 0 ) return TRUE; \
+		\
+		if ( list->head == NULL ) { \
+			list->head = items->head; \
+			list->tail = items->tail; \
+		} else { \
+			list->tail->next = items->head; \
+			items->head->prev = list->tail; \
+			list->tail = items->tail; \
+		} \
+		list->len += items->len; \
+		\
+		node = items->head; \
+		while ( node != NULL ) { \
+			node->list = list; \
+			node = node->next; \
+		} \
+		return TRUE; \
+	}	 
+
+#define __LIST_DETACH(first, count) { \
+		typeof(*first) *last, *result; \
+		unsigned int left; \
+		\
+		i_assert(first->list != NULL); \
+		\
+		left = count - 1; \
+		last = first; \
+		while ( left > 0 && last->next != NULL ) { \
+			left--; \
+			last = last->next; \
+		} \
+		\
+		if ( first->list->head == first ) \
+			first->list->head = last->next; \
+		if ( first->list->tail == last ) \
+			first->list->tail = first->prev; \
+		\
+		if ( first->prev != NULL ) \
+			first->prev->next = last->next;	\
+		if ( last->next != NULL ) \
+			last->next->prev = first->prev; \
+		\
+		first->list->len -= count - left; \
+		\
+		result = last->next; \
+		first->prev = NULL; \
+		last->next = NULL; \
+		\
+		return result; \
+	}
+
+/* List of AST nodes */
+
+static struct sieve_ast_list *sieve_ast_list_create(pool_t pool) 
+	__LIST_CREATE(pool, struct sieve_ast_list)
+
+static bool sieve_ast_list_add
+(struct sieve_ast_list *list, struct sieve_ast_node *node) 
+	__LIST_ADD(list, node)
+
+static struct sieve_ast_node *sieve_ast_list_detach
+(struct sieve_ast_node *first, unsigned int count) 
+	__LIST_DETACH(first, count)
+
+/* List of argument AST nodes */
+
+struct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool) 
+	__LIST_CREATE(pool, struct sieve_ast_arg_list)
+	
+bool sieve_ast_arg_list_add
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument)
+	__LIST_ADD(list, argument)
+
+bool sieve_ast_arg_list_insert
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,
+	struct sieve_ast_argument *argument)
+	__LIST_INSERT(list, before, argument)
+
+static bool sieve_ast_arg_list_join
+(struct sieve_ast_arg_list *list, struct sieve_ast_arg_list *items)
+	__LIST_JOIN(list, items)
+
+static struct sieve_ast_argument *sieve_ast_arg_list_detach
+(struct sieve_ast_argument *first, const unsigned int count)
+	__LIST_DETACH(first, count)
+
+void sieve_ast_arg_list_substitute
+(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument, 
+	struct sieve_ast_argument *replacement)
+{
+	if ( list->head == argument )
+		list->head = replacement;
+	if ( list->tail == argument )
+		list->tail = replacement;
+		
+	if ( argument->prev != NULL )
+		argument->prev->next = replacement;
+	if ( argument->next != NULL )
+		argument->next->prev = replacement;
+	
+	replacement->prev = argument->prev;
+	replacement->next = argument->next;
+	replacement->list = argument->list;
+	
+	argument->next = NULL;
+	argument->prev = NULL;
+}
+	
+/* 
+ * AST node 
+ */
+
+static struct sieve_ast_node *sieve_ast_node_create
+(struct sieve_ast *ast, struct sieve_ast_node *parent, enum sieve_ast_type type, 
+	unsigned int source_line) 
+{
+	struct sieve_ast_node *node = p_new(ast->pool, struct sieve_ast_node, 1);
+	
+	node->ast = ast;
+	node->parent = parent;
+	node->type = type;
+	
+	node->prev = NULL;
+	node->next = NULL;
+	
+	node->arguments = NULL;
+	node->tests = NULL;
+	node->commands = NULL;		
+	
+	node->test_list = FALSE;
+	node->block = FALSE;
+	
+	node->source_line = source_line;
+	
+	return node;
+}
+
+static bool sieve_ast_node_add_command
+(struct sieve_ast_node *node, struct sieve_ast_node *command) 
+{
+	i_assert( command->type == SAT_COMMAND && 
+		(node->type == SAT_ROOT || node->type == SAT_COMMAND) );
+	
+	if (node->commands == NULL) 
+		node->commands = sieve_ast_list_create(node->ast->pool);
+	
+	return sieve_ast_list_add(node->commands, command);
+}
+
+static bool sieve_ast_node_add_test
+(struct sieve_ast_node *node, struct sieve_ast_node *test) 
+{
+	i_assert( test->type == SAT_TEST && 
+		(node->type == SAT_TEST || node->type == SAT_COMMAND) );
+	
+	if (node->tests == NULL) 
+		node->tests = sieve_ast_list_create(node->ast->pool);
+	
+	return sieve_ast_list_add(node->tests, test);
+}
+
+static bool sieve_ast_node_add_argument
+(struct sieve_ast_node *node, struct sieve_ast_argument *argument) 
+{
+	i_assert( node->type == SAT_TEST || node->type == SAT_COMMAND );
+	
+	if (node->arguments == NULL) 
+		node->arguments = sieve_ast_arg_list_create(node->ast->pool);
+	
+	return sieve_ast_arg_list_add(node->arguments, argument);
+}
+
+struct sieve_ast_node *sieve_ast_node_detach
+(struct sieve_ast_node *first) 
+{	
+	return sieve_ast_list_detach(first, 1);
+}
+
+const char *sieve_ast_type_name
+(enum sieve_ast_type ast_type) 
+{
+	switch ( ast_type ) {
+	
+	case SAT_NONE: return "none";
+	case SAT_ROOT: return "ast root node";
+	case SAT_COMMAND: return "command";
+	case SAT_TEST: return "test";
+	
+	default: return "??AST NODE??";
+	}
+}
+
+/* 
+ * Argument AST node 
+ */
+
+struct sieve_ast_argument *sieve_ast_argument_create
+(struct sieve_ast *ast, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *arg = 
+		p_new(ast->pool, struct sieve_ast_argument, 1);
+	
+	arg->ast = ast;
+	
+	arg->prev = NULL;
+	arg->next = NULL;
+	
+	arg->source_line = source_line;
+	arg->context = NULL;
+	
+	arg->argument = NULL;
+	arg->arg_id_code = 0;
+			
+	return arg;
+}
+
+static void sieve_ast_argument_substitute
+(struct sieve_ast_argument *argument, struct sieve_ast_argument *replacement) 
+{
+	sieve_ast_arg_list_substitute(argument->list, argument, replacement);
+}
+
+struct sieve_ast_argument *sieve_ast_argument_string_create_raw
+(struct sieve_ast *ast, string_t *str, unsigned int source_line) 
+{
+	struct sieve_ast_argument *argument = sieve_ast_argument_create
+		(ast, source_line);
+		
+	argument->type = SAAT_STRING;
+	argument->_value.str = str;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_string_create
+(struct sieve_ast_node *node, const string_t *str, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument;
+	string_t *newstr;
+	
+	/* Allocate new internal string buffer */
+	newstr = str_new(node->ast->pool, str_len(str));
+	
+	/* Clone string */
+	str_append_str(newstr, str);
+	 
+	/* Create string argument */
+	argument = sieve_ast_argument_string_create_raw
+		(node->ast, newstr, source_line);
+
+	/* Add argument to command/test node */
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_cstring_create
+(struct sieve_ast_node *node, const char *str, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument;
+	string_t *newstr;
+	
+	/* Allocate new internal string buffer */
+	newstr = str_new(node->ast->pool, strlen(str));
+	
+	/* Clone string */
+	str_append(newstr, str);
+	 
+	/* Create string argument */
+	argument = sieve_ast_argument_string_create_raw
+		(node->ast, newstr, source_line);
+
+	/* Add argument to command/test node */
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+void sieve_ast_argument_string_set
+(struct sieve_ast_argument *argument, string_t *newstr)
+{
+	i_assert( argument->type == SAAT_STRING);
+	argument->_value.str = newstr;
+}
+
+void sieve_ast_argument_string_setc
+(struct sieve_ast_argument *argument, const char *newstr)
+{
+	i_assert( argument->type == SAAT_STRING);
+	
+	str_truncate(argument->_value.str, 0);
+	str_append(argument->_value.str, newstr);
+}
+
+void sieve_ast_argument_number_substitute
+(struct sieve_ast_argument *argument, unsigned int number)
+{
+	argument->type = SAAT_NUMBER;
+	argument->_value.number = number;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_create
+(struct sieve_ast_node *node, unsigned int source_line) 
+{
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, source_line);
+	
+	argument->type = SAAT_STRING_LIST;
+	argument->_value.strlist = NULL;
+	
+	sieve_ast_node_add_argument(node, argument);
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_substitute
+(struct sieve_ast_node *node, struct sieve_ast_argument *arg) 
+{
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, arg->source_line);
+	
+	argument->type = SAAT_STRING_LIST;
+	argument->_value.strlist = NULL;
+	
+	sieve_ast_argument_substitute(arg, argument);
+
+	return argument;
+}
+
+static inline bool _sieve_ast_stringlist_add_item
+(struct sieve_ast_argument *list, struct sieve_ast_argument *item) 
+{
+	i_assert( list->type == SAAT_STRING_LIST );
+	
+	if ( list->_value.strlist == NULL ) 
+		list->_value.strlist = sieve_ast_arg_list_create(list->ast->pool);
+	
+	return sieve_ast_arg_list_add(list->_value.strlist, item);
+}
+
+static bool sieve_ast_stringlist_add_stringlist
+(struct sieve_ast_argument *list, struct sieve_ast_argument *items) 
+{
+	i_assert( list->type == SAAT_STRING_LIST );
+	i_assert( items->type == SAAT_STRING_LIST );
+
+	if ( list->_value.strlist == NULL ) 
+		list->_value.strlist = sieve_ast_arg_list_create(list->ast->pool);
+	
+	return sieve_ast_arg_list_join(list->_value.strlist, items->_value.strlist);
+}
+
+static bool _sieve_ast_stringlist_add_str
+(struct sieve_ast_argument *list, string_t *str, unsigned int source_line) 
+{
+	struct sieve_ast_argument *stritem;
+	
+	stritem = sieve_ast_argument_create(list->ast, source_line);		
+	stritem->type = SAAT_STRING;
+	stritem->_value.str = str;
+
+	return _sieve_ast_stringlist_add_item(list, stritem);
+}
+
+bool sieve_ast_stringlist_add
+(struct sieve_ast_argument *list, const string_t *str, unsigned int source_line) 
+{
+	string_t *copied_str = str_new(list->ast->pool, str_len(str));
+	str_append_str(copied_str, str);
+
+	return _sieve_ast_stringlist_add_str(list, copied_str, source_line);
+}
+
+bool sieve_ast_stringlist_add_strc
+(struct sieve_ast_argument *list, const char *str, unsigned int source_line) 
+{
+	string_t *copied_str = str_new(list->ast->pool, strlen(str));
+	str_append(copied_str, str);
+	
+	return _sieve_ast_stringlist_add_str(list, copied_str, source_line);
+}
+
+struct sieve_ast_argument *sieve_ast_argument_tag_create
+(struct sieve_ast_node *node, const char *tag, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, source_line);
+	
+	argument->type = SAAT_TAG;
+	argument->_value.tag = p_strdup(node->ast->pool, tag);
+
+	if ( !sieve_ast_node_add_argument(node, argument) )
+		return NULL;
+
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_tag_insert
+(struct sieve_ast_argument *before, const char *tag, unsigned int source_line) 
+{	
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(before->ast, source_line);
+	
+	argument->type = SAAT_TAG;
+	argument->_value.tag = p_strdup(before->ast->pool, tag);
+
+	if ( !sieve_ast_arg_list_insert(before->list, before, argument) )
+		return NULL;
+	
+	return argument;
+}
+
+struct sieve_ast_argument *sieve_ast_argument_number_create
+(struct sieve_ast_node *node, unsigned int number, unsigned int source_line) 
+{
+	
+	struct sieve_ast_argument *argument = 
+		sieve_ast_argument_create(node->ast, source_line);
+		
+	argument->type = SAAT_NUMBER;
+	argument->_value.number = number;
+	
+	if ( !sieve_ast_node_add_argument(node, argument) )
+		return NULL;
+	
+	return argument;
+}
+
+void sieve_ast_argument_number_set
+(struct sieve_ast_argument *argument, unsigned int newnum)
+{
+	i_assert( argument->type == SAAT_NUMBER );
+	argument->_value.number = newnum;
+}
+
+
+struct sieve_ast_argument *sieve_ast_arguments_detach
+(struct sieve_ast_argument *first, unsigned int count) 
+{	
+	return sieve_ast_arg_list_detach(first, count);
+}
+
+const char *sieve_ast_argument_type_name
+(enum sieve_ast_argument_type arg_type) 
+{
+	switch ( arg_type ) {
+	
+	case SAAT_NONE: return "none";
+	case SAAT_STRING_LIST: return "a string list";
+	case SAAT_STRING: return "a string";
+	case SAAT_NUMBER: return "a number";
+	case SAAT_TAG: return "a tag";
+	
+	default: return "??ARGUMENT??";
+	}
+}
+
+/* Test AST node */
+
+struct sieve_ast_node *sieve_ast_test_create
+(struct sieve_ast_node *parent, const char *identifier, 
+	unsigned int source_line) 
+{	
+	struct sieve_ast_node *test = sieve_ast_node_create
+		(parent->ast, parent, SAT_TEST, source_line);
+		
+	test->identifier = p_strdup(parent->ast->pool, identifier);
+	
+	if ( !sieve_ast_node_add_test(parent, test) )
+		return NULL;
+	
+	return test;
+}
+
+/* Command AST node */
+
+struct sieve_ast_node *sieve_ast_command_create
+(struct sieve_ast_node *parent, const char *identifier, 
+	unsigned int source_line) 
+{
+
+	struct sieve_ast_node *command = sieve_ast_node_create
+		(parent->ast, parent, SAT_COMMAND, source_line);
+	
+	command->identifier = p_strdup(parent->ast->pool, identifier);
+	
+	if ( !sieve_ast_node_add_command(parent, command) )
+		return NULL;
+	
+	return command;
+}
+
+/*
+ * Utility
+ */
+
+int sieve_ast_stringlist_map
+(struct sieve_ast_argument **listitem, void *context,
+	int (*map_function)(void *context, struct sieve_ast_argument *arg))
+{
+	if ( sieve_ast_argument_type(*listitem) == SAAT_STRING ) {
+		/* Single string */
+		return map_function(context, *listitem);
+	} else if ( sieve_ast_argument_type(*listitem) == SAAT_STRING_LIST ) {
+		int ret = 0; 
+		
+		/* String list */
+		*listitem = sieve_ast_strlist_first(*listitem);
+		
+		while ( *listitem != NULL ) {
+			
+			if ( (ret=map_function(context, *listitem)) <= 0 )
+				return ret;
+			
+			*listitem = sieve_ast_strlist_next(*listitem);
+		}
+		
+		return ret;
+	} 
+	
+	i_unreached();
+	return -1;
+}
+
+struct sieve_ast_argument *sieve_ast_stringlist_join
+(struct sieve_ast_argument *list, struct sieve_ast_argument *items)
+{
+	enum sieve_ast_argument_type list_type, items_type;
+	struct sieve_ast_argument *newlist;
+	
+	list_type = sieve_ast_argument_type(list);
+	items_type = sieve_ast_argument_type(items);
+	
+	switch ( list_type ) {
+	
+	case SAAT_STRING:
+		switch ( items_type ) {
+		
+		case SAAT_STRING:
+			newlist = 
+				sieve_ast_argument_create(list->ast, list->source_line);
+			newlist->type = SAAT_STRING_LIST;
+			newlist->_value.strlist = NULL;
+			
+			sieve_ast_argument_substitute(list, newlist);
+			sieve_ast_arguments_detach(items, 1);
+			
+			if ( !_sieve_ast_stringlist_add_item(newlist, list) ||
+				!_sieve_ast_stringlist_add_item(newlist, items) ) {
+				return NULL;
+			}
+			
+			return newlist;
+			
+		case SAAT_STRING_LIST:
+			/* Adding stringlist to string; make them swith places and add one to the
+			 * other.
+			 */
+			sieve_ast_arguments_detach(items, 1);
+			sieve_ast_argument_substitute(list, items);
+			if ( !_sieve_ast_stringlist_add_item(items, list) ) 
+				return NULL;
+			
+			return list;
+			
+		default:
+			i_unreached();
+		}
+		break;
+		
+	case SAAT_STRING_LIST:
+		switch ( items_type ) {
+		
+		case SAAT_STRING:
+			/* Adding string to stringlist; straightforward add */
+			sieve_ast_arguments_detach(items, 1);
+			if ( !_sieve_ast_stringlist_add_item(list, items) )
+				return NULL;
+			
+			return list;
+			
+		case SAAT_STRING_LIST:
+			/* Adding stringlist to stringlist; perform actual join */
+			sieve_ast_arguments_detach(items, 1);
+			if ( !sieve_ast_stringlist_add_stringlist(list, items) )
+				return NULL;
+			
+			return list;
+			
+		default:
+			i_unreached();
+		}
+		
+		break;
+	default:
+		i_unreached();
+	}
+	
+	return NULL;
+}
+
+
+/* Debug */
+
+/* Unparsing, currently implemented using plain printf()s */
+
+static void sieve_ast_unparse_string(const string_t *strval) 
+{
+	char *str = t_strdup_noconst(str_c((string_t *) strval));
+
+	if ( strchr(str, '\n') != NULL && str[strlen(str)-1] == '\n' ) {
+		/* Print it as a multi-line string and do required dotstuffing */
+		char *spos = str;
+		char *epos = strchr(str, '\n');
+		printf("text:\n");
+		
+		while ( epos != NULL ) {
+			*epos = '\0';
+			if ( *spos == '.' ) 
+				printf(".");
+			
+			printf("%s\n", spos);
+			
+			spos = epos+1;
+			epos = strchr(spos, '\n');
+		}
+		if ( *spos == '.' ) 
+				printf(".");
+		
+		printf("%s\n.\n", spos);	
+	} else {
+		/* Print it as a quoted string and escape " */
+		char *spos = str;
+		char *epos = strchr(str, '"');
+		printf("\"");
+		
+		while ( epos != NULL ) {
+			*epos = '\0';
+			printf("%s\\\"", spos);
+			
+			spos = epos+1;
+			epos = strchr(spos, '"');
+		}
+		
+		printf("%s\"", spos);
+	}
+}
+
+static void sieve_ast_unparse_argument
+	(struct sieve_ast_argument *argument, int level);
+
+static void sieve_ast_unparse_stringlist
+(struct sieve_ast_argument *strlist, int level) 
+{
+	struct sieve_ast_argument *stritem;
+	
+	if ( sieve_ast_strlist_count(strlist) > 1 ) { 
+		int i;
+		
+		printf("[\n");
+	
+		/* Create indent */
+		for ( i = 0; i < level+2; i++ ) 
+			printf("  ");	
+
+		stritem = sieve_ast_strlist_first(strlist);
+		sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+		
+		stritem = sieve_ast_strlist_next(stritem);
+		while ( stritem != NULL ) {
+			printf(",\n");
+			for ( i = 0; i < level+2; i++ ) 
+				printf("  ");
+			sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+		  stritem = sieve_ast_strlist_next(stritem);
+	  }
+ 
+		printf(" ]");
+	} else {
+		stritem = sieve_ast_strlist_first(strlist);
+		if ( stritem != NULL ) 
+			sieve_ast_unparse_string(sieve_ast_strlist_str(stritem));
+	}
+}
+
+static void sieve_ast_unparse_argument
+(struct sieve_ast_argument *argument, int level) 
+{
+	switch ( argument->type ) {
+	case SAAT_STRING:
+		sieve_ast_unparse_string(sieve_ast_argument_str(argument));
+		break;
+	case SAAT_STRING_LIST:
+		sieve_ast_unparse_stringlist(argument, level+1);
+		break;
+	case SAAT_NUMBER:
+		printf("%d", sieve_ast_argument_number(argument));
+		break;
+	case SAAT_TAG:
+		printf(":%s", sieve_ast_argument_tag(argument));
+		break;
+	default:
+		printf("??ARGUMENT??");
+		break;
+	}
+}
+
+static void sieve_ast_unparse_test
+	(struct sieve_ast_node *node, int level);
+
+static void sieve_ast_unparse_tests
+(struct sieve_ast_node *node, int level) 
+{
+	struct sieve_ast_node *test;
+	
+	if ( sieve_ast_test_count(node) > 1 ) { 
+		int i;
+		
+		printf(" (\n");
+	
+		/* Create indent */
+		for ( i = 0; i < level+2; i++ ) 
+			printf("  ");	
+
+		test = sieve_ast_test_first(node);
+		sieve_ast_unparse_test(test, level+1);
+		
+		test = sieve_ast_test_next(test);
+		while ( test != NULL ) {
+			printf(", \n");
+			for ( i = 0; i < level+2; i++ ) 
+				printf("  ");
+			sieve_ast_unparse_test(test, level+1);
+		  test = sieve_ast_test_next(test);
+	  }
+ 
+		printf(" )");
+	} else {
+		test = sieve_ast_test_first(node);
+		if ( test != NULL ) 
+			sieve_ast_unparse_test(test, level);
+	}
+}
+
+static void sieve_ast_unparse_test
+(struct sieve_ast_node *node, int level) 
+{
+	struct sieve_ast_argument *argument;
+		
+	printf(" %s", node->identifier);
+	
+	argument = sieve_ast_argument_first(node);
+	while ( argument != NULL ) {
+		printf(" ");
+		sieve_ast_unparse_argument(argument, level);
+		argument = sieve_ast_argument_next(argument);
+	}
+	
+	sieve_ast_unparse_tests(node, level);
+}
+
+static void sieve_ast_unparse_command
+(struct sieve_ast_node *node, int level) 
+{
+	struct sieve_ast_node *command;
+	struct sieve_ast_argument *argument;
+	
+	int i;
+	
+	/* Create indent */
+	for ( i = 0; i < level; i++ ) 
+		printf("  ");
+		
+	printf("%s", node->identifier);
+	
+	argument = sieve_ast_argument_first(node);
+	while ( argument != NULL ) {
+		printf(" ");
+		sieve_ast_unparse_argument(argument, level);
+		argument = sieve_ast_argument_next(argument);
+	}
+	
+	sieve_ast_unparse_tests(node, level);
+	
+	command = sieve_ast_command_first(node);
+	if ( command != NULL ) {
+		printf(" {\n");
+		
+		while ( command != NULL) {	
+			sieve_ast_unparse_command(command, level+1);
+			command = sieve_ast_command_next(command);
+		}
+		
+		for ( i = 0; i < level; i++ ) 
+			printf("  ");
+		printf("}\n");
+	} else 
+		printf(";\n");
+}
+
+void sieve_ast_unparse(struct sieve_ast *ast) 
+{
+	struct sieve_ast_node *command;
+
+	printf("Unparsing Abstract Syntax Tree:\n");
+
+	T_BEGIN {	
+		command = sieve_ast_command_first(sieve_ast_root(ast));
+		while ( command != NULL ) {	
+			sieve_ast_unparse_command(command, 0);
+			command = sieve_ast_command_next(command);
+		}		
+	} T_END;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-ast.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-ast.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-ast.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-ast.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,370 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_AST_H
+#define __SIEVE_AST_H
+
+#include "lib.h"
+#include "str.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+/*
+	Abstract Syntax Tree (AST) structure:
+	
+	sieve_ast (root)
+	[*command]
+	 |
+	 +-- command:
+	 |   ....
+	 +-- command:
+	 |	 [identifier *argument                      *test *command]
+	 |                +-- argument:                 |     \--> as from root
+	 |                |   ....                      |
+ 	 |                +-- argument:                 V (continued below)
+	 |                |   [number | tag | *string]
+	 |                .
+	 .
+	
+	 *test
+	 +-- test:
+	 |   ....
+	 +-- test:
+	 |   [identifier *argument                     *test]
+	 |               +-- argument:                 \-->  as from the top 
+	 .               |   ....                              of this tree
+	                 +-- argument:
+	                 |   [number | tag | *string]
+	                 .
+	                 
+	 Tests and commands are defined using the same structure: sieve_ast_node. 
+	 However, arguments and string-lists are described using sieve_ast_argument.  
+*/
+
+/* IMPORTANT NOTICE: Do not decorate the AST with objects other than those 
+ * allocated on the ast's pool or static const objects. Otherwise it is possible 
+ * that pointers in the tree become dangling which is highly undesirable.
+ */
+
+/*
+ * Forward declarations
+ */ 
+
+struct sieve_ast_list;
+struct sieve_ast_arg_list;
+
+/*
+ * Types
+ */
+ 
+enum sieve_ast_argument_type {
+	SAAT_NONE,
+	SAAT_NUMBER,
+	SAAT_STRING,
+	SAAT_STRING_LIST,
+	SAAT_TAG,
+};
+
+enum sieve_ast_type {
+	SAT_NONE,
+	SAT_ROOT,
+	SAT_COMMAND,
+	SAT_TEST,
+};
+
+/*
+ * AST Nodes
+ */
+ 
+/* Argument node */
+
+struct sieve_ast_argument {
+	enum sieve_ast_argument_type type;
+
+	/* Back reference to the AST object */
+	struct sieve_ast *ast;
+
+	/* List related */
+	struct sieve_ast_arg_list *list;
+	struct sieve_ast_argument *next;
+	struct sieve_ast_argument *prev;
+  
+	/* Parser-assigned data */
+  
+	union {	
+		string_t *str;
+		struct sieve_ast_arg_list *strlist;
+		const char *tag;
+		unsigned int number;
+	} _value;
+  
+	unsigned int source_line;
+  
+	/* Assigned during validation */
+
+	/* Argument associated with this ast element  */
+	const struct sieve_argument *argument;
+	int arg_id_code;
+
+	/* Parameters to this (tag) argument */
+	struct sieve_ast_argument *parameters;
+	
+	/* Context data associated with this ast element */
+	void *context;
+};
+
+struct sieve_ast_node {
+	enum sieve_ast_type type;
+
+	/* Back reference to the AST object */
+	struct sieve_ast *ast;
+	
+	/* Back reference to this node's parent */
+	struct sieve_ast_node *parent;
+	
+	/* Linked list references */
+	struct sieve_ast_list *list;
+	struct sieve_ast_node *next;
+	struct sieve_ast_node *prev;
+	
+	/* Commands (NULL if not allocated) */
+	bool block;
+	struct sieve_ast_list *commands;
+	
+	/* Tests (NULL if not allocated)*/
+	bool test_list;
+	struct sieve_ast_list *tests;
+
+	/* Arguments (NULL if not allocated) */
+	struct sieve_ast_arg_list *arguments;	
+
+	/* Identifier of command or test */
+	const char *identifier;		
+
+	/* The location in the file where this command was started */
+	unsigned int source_line;
+		
+	/* Assigned during validation */
+		
+	/* Context */
+	struct sieve_command_context *context;	
+};
+
+/*
+ * AST node lists
+ */
+ 
+struct sieve_ast_list {
+	struct sieve_ast_node *head;		
+	struct sieve_ast_node *tail;
+	unsigned int len; 	
+};
+
+struct sieve_ast_arg_list {
+	struct sieve_ast_argument *head;		
+	struct sieve_ast_argument *tail;
+	unsigned int len; 	
+};
+
+/*
+ * AST object 
+ */
+ 
+struct sieve_ast; 
+ 
+struct sieve_ast *sieve_ast_create(struct sieve_script *script);
+void sieve_ast_ref(struct sieve_ast *ast);
+void sieve_ast_unref(struct sieve_ast **ast);
+
+struct sieve_ast_node *sieve_ast_root(struct sieve_ast *ast);
+pool_t sieve_ast_pool(struct sieve_ast *ast);
+struct sieve_script *sieve_ast_script(struct sieve_ast *ast);
+
+/* Extension support */
+
+struct sieve_ast_extension {
+	const struct sieve_extension *ext;	
+
+	void (*free)(struct sieve_ast *ast, void *context);
+};
+
+void sieve_ast_extension_link
+	(struct sieve_ast *ast, const struct sieve_extension *ext);
+const struct sieve_extension * const *sieve_ast_extensions_get
+	(struct sieve_ast *ast, unsigned int *count_r);
+
+void sieve_ast_extension_register
+	(struct sieve_ast *ast, const struct sieve_ast_extension *ast_ext, 
+		void *context);
+void *sieve_ast_extension_get_context
+	(struct sieve_ast *ast, const struct sieve_extension *ext);
+
+/* 
+ * AST node manipulation
+ */
+ 
+/* Command nodes */
+
+struct sieve_ast_node *sieve_ast_test_create
+	(struct sieve_ast_node *parent, const char *identifier, 
+		unsigned int source_line);
+struct sieve_ast_node *sieve_ast_command_create
+	(struct sieve_ast_node *parent, const char *identifier, 
+		unsigned int source_line);
+
+struct sieve_ast_node *sieve_ast_node_detach
+	(struct sieve_ast_node *first);
+
+const char *sieve_ast_type_name(enum sieve_ast_type ast_type);
+	
+/* Argument nodes */
+
+struct sieve_ast_argument *sieve_ast_argument_create
+	(struct sieve_ast *ast, unsigned int source_line);
+
+struct sieve_ast_arg_list *sieve_ast_arg_list_create(pool_t pool);	
+bool sieve_ast_arg_list_add
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument);
+bool sieve_ast_arg_list_insert
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *before,
+		struct sieve_ast_argument *argument);
+void sieve_ast_arg_list_substitute
+	(struct sieve_ast_arg_list *list, struct sieve_ast_argument *argument, 
+		struct sieve_ast_argument *replacement);
+
+struct sieve_ast_argument *sieve_ast_argument_string_create_raw
+	(struct sieve_ast *ast, string_t *str, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_string_create
+	(struct sieve_ast_node *node, const string_t *str, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_cstring_create
+	(struct sieve_ast_node *node, const char *str, unsigned int source_line);
+	
+struct sieve_ast_argument *sieve_ast_argument_tag_create
+	(struct sieve_ast_node *node, const char *tag, unsigned int source_line);
+
+struct sieve_ast_argument *sieve_ast_argument_number_create
+	(struct sieve_ast_node *node, unsigned int number, unsigned int source_line);
+
+void sieve_ast_argument_string_set
+	(struct sieve_ast_argument *argument, string_t *newstr);
+void sieve_ast_argument_string_setc
+	(struct sieve_ast_argument *argument, const char *newstr);
+
+void sieve_ast_argument_number_set
+	(struct sieve_ast_argument *argument, unsigned int newnum);
+void sieve_ast_argument_number_substitute
+	(struct sieve_ast_argument *argument, unsigned int number);
+
+struct sieve_ast_argument *sieve_ast_argument_tag_insert
+(struct sieve_ast_argument *before, const char *tag, unsigned int source_line); 
+
+struct sieve_ast_argument *sieve_ast_argument_stringlist_create
+	(struct sieve_ast_node *node, unsigned int source_line);
+struct sieve_ast_argument *sieve_ast_argument_stringlist_substitute
+	(struct sieve_ast_node *node, struct sieve_ast_argument *arg);
+
+struct sieve_ast_argument *sieve_ast_arguments_detach
+	(struct sieve_ast_argument *first, unsigned int count);
+	
+const char *sieve_ast_argument_type_name(enum sieve_ast_argument_type arg_type);
+#define sieve_ast_argument_name(argument) \
+	sieve_ast_argument_type_name((argument)->type)
+
+bool sieve_ast_stringlist_add
+	(struct sieve_ast_argument *list, const string_t *str, 
+		unsigned int source_line);
+bool sieve_ast_stringlist_add_strc
+	(struct sieve_ast_argument *list, const char *str, 
+		unsigned int source_line);
+		
+/* 
+ * Utility
+ */
+
+int sieve_ast_stringlist_map
+	(struct sieve_ast_argument **listitem, void *context,
+		int (*map_function)(void *context, struct sieve_ast_argument *arg));
+struct sieve_ast_argument *sieve_ast_stringlist_join
+	(struct sieve_ast_argument *list, struct sieve_ast_argument *items);
+	
+/* 
+ * AST access macros 
+ */
+
+/* Generic list access macros */
+#define __AST_LIST_FIRST(list) \
+	((list) == NULL ? NULL : (list)->head)
+#define __AST_LIST_LAST(list) \
+	((list) == NULL ? NULL : (list)->tail)
+#define __AST_LIST_COUNT(list) \
+	((list) == NULL || (list)->head == NULL ? 0 : (list)->len)
+#define __AST_LIST_NEXT(item) ((item)->next)
+#define __AST_LIST_PREV(item) ((item)->prev)
+
+#define __AST_NODE_LIST_FIRST(node, list) __AST_LIST_FIRST((node)->list)
+#define __AST_NODE_LIST_LAST(node, list) __AST_LIST_LAST((node)->list)
+#define __AST_NODE_LIST_COUNT(node, list) __AST_LIST_COUNT((node)->list)
+
+/* AST macros */
+
+/* AST node macros */
+#define sieve_ast_node_pool(node) (sieve_ast_pool((node)->ast))
+#define sieve_ast_node_parent(node) ((node)->parent)
+#define sieve_ast_node_prev(node) __AST_LIST_PREV(node)
+#define sieve_ast_node_next(node) __AST_LIST_NEXT(node)
+#define sieve_ast_node_type(node) ((node) == NULL ? SAT_NONE : (node)->type)
+#define sieve_ast_node_line(node) ((node) == NULL ? 0 : (node)->source_line)
+
+/* AST command node macros */
+#define sieve_ast_command_first(node) __AST_NODE_LIST_FIRST(node, commands)
+#define sieve_ast_command_count(node) __AST_NODE_LIST_COUNT(node, commands)
+#define sieve_ast_command_prev(command) __AST_LIST_PREV(command)
+#define sieve_ast_command_next(command) __AST_LIST_NEXT(command)
+
+/* Compare the identifier of the previous command */
+#define sieve_ast_prev_cmd_is(cmd, id) \
+	( (cmd)->prev == NULL ? FALSE : \
+		strncasecmp((cmd)->prev->identifier, id, sizeof(id)-1) == 0 )
+	
+/* AST test macros */
+#define sieve_ast_test_count(node) __AST_NODE_LIST_COUNT(node, tests)
+#define sieve_ast_test_first(node) __AST_NODE_LIST_FIRST(node, tests)
+#define sieve_ast_test_next(test) __AST_LIST_NEXT(test)
+
+/* AST argument macros */
+#define sieve_ast_argument_first(node) __AST_NODE_LIST_FIRST(node, arguments)
+#define sieve_ast_argument_last(node) __AST_NODE_LIST_LAST(node, arguments)
+#define sieve_ast_argument_count(node) __AST_NODE_LIST_COUNT(node, arguments)
+#define sieve_ast_argument_prev(argument) __AST_LIST_PREV(argument)
+#define sieve_ast_argument_next(argument) __AST_LIST_NEXT(argument)
+#define sieve_ast_argument_type(argument) \
+	((argument) == NULL ? SAAT_NONE : (argument)->type)
+#define sieve_ast_argument_line(argument) \
+	((argument) == NULL ? 0 : (argument)->source_line)
+
+#define sieve_ast_argument_str(argument) ((argument)->_value.str)
+#define sieve_ast_argument_strc(argument) (str_c((argument)->_value.str))
+#define sieve_ast_argument_tag(argument) ((argument)->_value.tag)
+#define sieve_ast_argument_number(argument) ((argument)->_value.number)
+
+/* AST string list macros */
+// @UNSAFE: should check whether we are actually accessing a string list
+#define sieve_ast_strlist_first(list) \
+	__AST_NODE_LIST_FIRST(list, _value.strlist)
+#define sieve_ast_strlist_last(list) \
+	__AST_NODE_LIST_LAST(list, _value.strlist)
+#define sieve_ast_strlist_count(list) \
+	__AST_NODE_LIST_COUNT(list, _value.strlist)
+#define sieve_ast_strlist_next(str) __AST_LIST_NEXT(str)
+#define sieve_ast_strlist_prev(str) __AST_LIST_PREV(str)
+#define sieve_ast_strlist_str(str) sieve_ast_argument_str(str)
+#define sieve_ast_strlist_strc(str) sieve_ast_argument_strc(str)
+
+/* 
+ * Debug 
+ */
+
+void sieve_ast_unparse(struct sieve_ast *ast);
+
+#endif /* __SIEVE_AST_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1755 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "mempool.h"
+#include "buffer.h"
+#include "hash.h"
+#include "array.h"
+#include "ostream.h"
+
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-script.h"
+
+#include "sieve-binary.h"
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+/*
+ * Config
+ */
+ 
+#define SIEVE_BINARY_VERSION_MAJOR     0
+#define SIEVE_BINARY_VERSION_MINOR     1
+
+/*
+ * Macros
+ */
+
+#define SIEVE_BINARY_MAGIC              0xcafebabe
+#define SIEVE_BINARY_MAGIC_OTHER_ENDIAN 0xbebafeca 
+
+#define SIEVE_BINARY_ALIGN(offset) \
+	(((offset) + 3) & ~3)
+#define SIEVE_BINARY_ALIGN_PTR(ptr) \
+	((void *) SIEVE_BINARY_ALIGN(((size_t) ptr)))
+
+/* 
+ * Forward declarations 
+ */
+
+struct sieve_binary_file;
+
+static bool sieve_binary_file_open
+	(struct sieve_binary_file *file, const char *path);
+static void sieve_binary_file_close(struct sieve_binary_file **file);
+
+static struct sieve_binary_block *sieve_binary_load_block
+	(struct sieve_binary *sbin, unsigned int id);
+
+static inline struct sieve_binary_extension_reg *sieve_binary_extension_get_reg
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, 
+		bool create);
+static inline int sieve_binary_extension_register
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, 
+		struct sieve_binary_extension_reg **reg);
+
+static inline sieve_size_t sieve_binary_emit_dynamic_data
+	(struct sieve_binary *binary, const void *data, size_t size);
+
+/* 
+ * Internal structures
+ */
+
+/* Extension registration */
+
+struct sieve_binary_extension_reg {
+	/* The identifier of the extension within this binary */
+	int index;
+	
+	/* Global extension object */
+	const struct sieve_extension *extension; 
+	
+	/* Extension to the binary; typically used to manage extension-specific blocks 
+	 * in the binary and as a means to get a binary_free notification to release
+	 * references held by extensions. 
+	 */
+	const struct sieve_binary_extension *binext;	
+	
+	/* Context data associated to the binary by this extension */
+	void *context;
+	
+	/* Main block for this extension */
+	unsigned int block_id;
+};
+
+/* Block */
+
+struct sieve_binary_block {
+	buffer_t *buffer;
+	int ext_index;
+	
+	uoff_t offset;
+};
+
+/* File */
+
+/* FIXME: In essence this is an unbuffered stream implementation. Maybe this 
+ * can be merged with the generic dovecot istream interface.
+ */
+struct sieve_binary_file {
+	pool_t pool;
+	const char *path;
+	
+	struct stat st;
+	int fd;
+	off_t offset;
+
+	bool (*load)(struct sieve_binary_file *file);	
+	const void *(*load_data)
+		(struct sieve_binary_file *file, off_t *offset, size_t size);
+	buffer_t *(*load_buffer)
+		(struct sieve_binary_file *file, off_t *offset, size_t size);
+};
+
+/*
+ * Binary object
+ */
+
+struct sieve_binary {
+	pool_t pool;
+	int refcount;
+	
+	struct sieve_script *script;
+	
+	struct sieve_binary_file *file;
+	
+	/* When the binary is loaded into memory or when it is being constructed by
+	 * the generator, extensions can be associated to the binary. The extensions
+	 * array is a sequential list of all linked extensions. The extension_index 
+	 * array is a mapping ext_id -> binary_extension. This is used to obtain the 
+	 * index code associated with an extension for this particular binary. The 
+	 * linked_extensions list all extensions linked to this binary object other
+	 * than the preloaded language features implemented as 'extensions'. 
+	 * 
+	 * All arrays refer to the same extension registration objects. Upon loading 
+	 * a binary, the 'require'd extensions will sometimes need to associate 
+	 * context data to the binary object in memory. This is stored in these 
+	 * registration objects as well.
+	 */
+	ARRAY_DEFINE(extensions, struct sieve_binary_extension_reg *); 
+	ARRAY_DEFINE(extension_index, struct sieve_binary_extension_reg *); 
+	ARRAY_DEFINE(linked_extensions, struct sieve_binary_extension_reg *); 
+		
+	/* Attributes of a loaded binary */
+	const char *path;
+		
+	/* Blocks */
+	ARRAY_DEFINE(blocks, struct sieve_binary_block *); 
+	unsigned int active_block;
+	
+	/* Current block buffer: all emit and read functions act upon this buffer */
+	buffer_t *data;
+	const char *code;
+	size_t code_size;
+};
+
+static struct sieve_binary *sieve_binary_create(struct sieve_script *script) 
+{
+	pool_t pool;
+	struct sieve_binary *sbin;
+	unsigned int i;
+	
+	pool = pool_alloconly_create("sieve_binary", 8192);	
+	sbin = p_new(pool, struct sieve_binary, 1);
+	sbin->pool = pool;
+	sbin->refcount = 1;
+	sbin->script = script;
+	if ( script != NULL ) 
+		sieve_script_ref(script);
+	
+	p_array_init(&sbin->linked_extensions, pool, 5);
+	p_array_init(&sbin->extensions, pool, 5);
+	p_array_init(&sbin->extension_index, pool, sieve_extensions_get_count());
+	
+	p_array_init(&sbin->blocks, pool, 3);
+
+	/* Pre-load core language features implemented as 'extensions' */
+	for ( i = 0; i < sieve_preloaded_extensions_count; i++ ) {
+		const struct sieve_extension *ext = sieve_preloaded_extensions[i];
+		if ( ext->binary_load != NULL )
+			(void)ext->binary_load(sbin);		
+	}
+			
+	return sbin;
+}
+
+struct sieve_binary *sieve_binary_create_new(struct sieve_script *script) 
+{
+	struct sieve_binary *sbin = sieve_binary_create(script); 
+	
+	/* Extensions block */
+	(void) sieve_binary_block_create(sbin);
+	
+	/* Main program block */
+	(void) sieve_binary_block_set_active
+		(sbin, sieve_binary_block_create(sbin), NULL);
+	
+	return sbin;
+}
+
+void sieve_binary_ref(struct sieve_binary *sbin) 
+{
+	sbin->refcount++;
+}
+
+static inline void sieve_binary_extensions_free(struct sieve_binary *sbin) 
+{
+	unsigned int ext_count, i;
+	
+	/* Cleanup binary extensions */
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_free != NULL )
+			binext->binary_free(sbin);
+	}
+}
+
+void sieve_binary_unref(struct sieve_binary **sbin) 
+{
+	i_assert((*sbin)->refcount > 0);
+
+	if (--(*sbin)->refcount != 0)
+		return;
+
+	sieve_binary_extensions_free(*sbin);
+	
+	if ( (*sbin)->file != NULL )
+		sieve_binary_file_close(&(*sbin)->file);
+
+	if ( (*sbin)->script != NULL )
+		sieve_script_unref(&(*sbin)->script);
+	
+	pool_unref(&((*sbin)->pool));
+	
+	*sbin = NULL;
+}
+
+static inline sieve_size_t _sieve_binary_get_code_size
+(struct sieve_binary *sbin)
+{
+	return buffer_get_used_size(sbin->data);
+}
+
+sieve_size_t sieve_binary_get_code_size(struct sieve_binary *sbin)
+{
+	return _sieve_binary_get_code_size(sbin);
+}
+
+pool_t sieve_binary_pool(struct sieve_binary *sbin)
+{
+	return sbin->pool;
+}
+
+struct sieve_script *sieve_binary_script(struct sieve_binary *sbin)
+{
+	return sbin->script;
+}
+
+const char *sieve_binary_path(struct sieve_binary *sbin)
+{
+	return sbin->path;
+}
+
+bool sieve_binary_script_older
+(struct sieve_binary *sbin, struct sieve_script *script)
+{
+	i_assert(sbin->file != NULL);
+	return ( sieve_script_older(script, sbin->file->st.st_mtime) );
+}
+
+const char *sieve_binary_script_name(struct sieve_binary *sbin)
+{
+	struct sieve_script *script = sieve_binary_script(sbin);
+
+	return ( script == NULL ? NULL : sieve_script_name(script) );
+}
+
+const char *sieve_binary_script_path(struct sieve_binary *sbin)
+{
+	struct sieve_script *script = sieve_binary_script(sbin);
+
+	return ( script == NULL ? NULL : sieve_script_path(script) );
+}
+
+
+/* 
+ * Block management 
+ */
+
+static inline struct sieve_binary_block *sieve_binary_block_get
+(struct sieve_binary *sbin, unsigned int id) 
+{
+	struct sieve_binary_block * const *block;
+
+	if  ( id >= array_count(&sbin->blocks) )
+		return NULL;
+	
+	block = array_idx(&sbin->blocks, id);		
+
+	return *block;
+}
+
+static inline unsigned int sieve_binary_block_add
+(struct sieve_binary *sbin, struct sieve_binary_block *block)
+{
+	unsigned int id = array_count(&sbin->blocks);
+	
+	array_append(&sbin->blocks, &block, 1);	
+	return id;
+}
+
+static inline unsigned int sieve_binary_block_count
+(struct sieve_binary *sbin)
+{
+	return array_count(&sbin->blocks);
+}
+
+void sieve_binary_block_clear
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block = sieve_binary_block_get(sbin, id);
+	
+	buffer_reset(block->buffer);
+}
+
+bool sieve_binary_block_set_active
+(struct sieve_binary *sbin, unsigned int id, unsigned *old_id_r)
+{
+	struct sieve_binary_block *block = sieve_binary_block_get(sbin, id);
+			
+	if ( block == NULL ) return FALSE;
+	
+	if ( block->buffer == NULL ) {
+		if ( sbin->file ) {
+			/* Try to acces the block in the binary on disk (apperently we were lazy)
+			 */
+			if ( sieve_binary_load_block(sbin, id) == NULL || block->buffer == NULL )
+				return FALSE;
+		} else {
+			/* Block buffer is missing during code generation. This is what we would 
+			 * call a bug. FAIL. 
+			 */
+			return FALSE;
+		}
+	}
+	
+	if ( old_id_r != NULL ) 
+		*old_id_r = sbin->active_block;
+
+	sbin->data = block->buffer;
+	sbin->code = buffer_get_data(block->buffer, &sbin->code_size);
+	sbin->active_block = id;
+	
+	return TRUE;
+}
+
+unsigned int sieve_binary_block_create(struct sieve_binary *sbin)
+{
+	struct sieve_binary_block *block;
+	
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+	block->buffer = buffer_create_dynamic(sbin->pool, 64);
+
+	return sieve_binary_block_add(sbin, block);
+}
+
+static struct sieve_binary_block *sieve_binary_block_create_id
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+
+	if ( id >= SBIN_SYSBLOCK_LAST )
+		array_idx_set(&sbin->blocks, id, &block);		
+	else
+		(void)sieve_binary_block_add(sbin, block);
+	
+	return block;
+}
+
+/*
+ * Header and record structures of the binary on disk 
+ */
+ 
+struct sieve_binary_header {
+	uint32_t magic;
+	uint16_t version_major;
+	uint16_t version_minor;
+	uint32_t blocks;
+};
+
+struct sieve_binary_block_index {
+	uint32_t id;
+	uint32_t size;
+	uint32_t offset;
+	uint32_t ext_id;
+};
+
+struct sieve_binary_block_header {
+	uint32_t id; 
+	uint32_t size;
+};
+
+/* 
+ * Saving the binary to a file. 
+ */
+
+static inline bool _save_skip(struct ostream *stream, size_t size)
+{	
+	if ( (o_stream_seek(stream, stream->offset + size)) <= 0 ) 
+		return FALSE;
+		
+	return TRUE;
+}
+
+static inline bool _save_skip_aligned
+(struct ostream *stream, size_t size, uoff_t *offset)
+{
+	uoff_t aligned_offset = SIEVE_BINARY_ALIGN(stream->offset);
+	
+	if ( (o_stream_seek(stream, aligned_offset + size)) <= 0 ) 
+		return FALSE;
+		
+	if ( offset != NULL )
+		*offset = aligned_offset;
+		
+	return TRUE;
+}
+
+/* FIXME: Is this even necessary for a file? */
+static bool _save_full(struct ostream *stream, const void *data, size_t size)
+{
+	size_t bytes_left = size;
+	const void *pdata = data;
+	
+	while ( bytes_left > 0 ) {
+		ssize_t ret;
+		
+		if ( (ret=o_stream_send(stream, pdata, bytes_left)) <= 0 ) 
+			return FALSE;
+			
+		pdata = PTR_OFFSET(pdata, ret);
+		bytes_left -= ret;
+	}	
+	
+	return TRUE;
+}
+
+static bool _save_aligned
+(struct ostream *stream, const void *data, size_t size, uoff_t *offset)
+{	
+	uoff_t aligned_offset = SIEVE_BINARY_ALIGN(stream->offset);
+
+	o_stream_cork(stream);
+	
+	/* Align the data by adding zeroes to the output stream */
+	if ( stream->offset < aligned_offset ) {
+		if ( !_save_skip(stream, aligned_offset - stream->offset) ) 
+			return FALSE;
+	}
+	
+	if ( !_save_full(stream, data, size) )
+		return FALSE;
+	
+	o_stream_uncork(stream); 
+
+	if ( offset != NULL )
+		*offset = aligned_offset;
+
+	return TRUE;
+} 
+
+static bool _save_block
+(struct sieve_binary *sbin, struct ostream *stream, unsigned int id)
+{
+	struct sieve_binary_block_header block_header;
+	struct sieve_binary_block *block;
+	const void *data;
+	size_t size;
+		
+	block = sieve_binary_block_get(sbin, id);
+	if ( block == NULL )
+		return FALSE;
+		
+	data = buffer_get_data(block->buffer, &size);
+	
+	block_header.id = id;
+	block_header.size = size;
+	
+	if ( !_save_aligned(stream, &block_header,
+		sizeof(block_header), &block->offset) )
+		return FALSE;
+	
+	return _save_aligned(stream, data, size, NULL);
+}
+
+static bool _save_block_index_record
+(struct sieve_binary *sbin, struct ostream *stream, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	struct sieve_binary_block_index header;
+	
+	block = sieve_binary_block_get(sbin, id);
+	if ( block == NULL )
+		return FALSE;
+	
+	header.id = id;
+	header.size = buffer_get_used_size(block->buffer);
+	header.ext_id = block->ext_index;
+	header.offset = block->offset;
+	
+	if ( !_save_full(stream, &header, sizeof(header)) ) {
+		sieve_sys_error("failed to save block index header %d: %m", id);
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool _sieve_binary_save
+(struct sieve_binary *sbin, struct ostream *stream)
+{
+	struct sieve_binary_header header;
+	unsigned int ext_count, blk_count, i;
+	uoff_t block_index;
+	
+	blk_count = sieve_binary_block_count(sbin);
+	
+	/* Signal all extensions to finish generating their blocks */
+	
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_save != NULL )
+			binext->binary_save(sbin);
+	}
+		
+	/* Create header */
+	
+	header.magic = SIEVE_BINARY_MAGIC;
+	header.version_major = SIEVE_BINARY_VERSION_MAJOR;
+	header.version_minor = SIEVE_BINARY_VERSION_MINOR;
+	header.blocks = blk_count;
+
+	if ( !_save_aligned(stream, &header, sizeof(header), NULL) ) {
+		sieve_sys_error("failed to save binary header: %m");
+		return FALSE;
+	} 
+	
+	/* Skip block index for now */
+	
+	if ( !_save_skip_aligned(stream, 
+		sizeof(struct sieve_binary_block_index) * blk_count, &block_index) )
+		return FALSE;
+	
+	/* Create block containing all used extensions 
+	 *   FIXME: Per-extension this should also store binary version numbers.
+	 */
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_EXTENSIONS, NULL) )
+		return FALSE;
+		
+	ext_count = array_count(&sbin->linked_extensions);
+	sieve_binary_emit_unsigned(sbin, ext_count);
+	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ext
+			= array_idx(&sbin->linked_extensions, i);
+		
+		sieve_binary_emit_cstring(sbin, (*ext)->extension->name);
+		sieve_binary_emit_unsigned(sbin, (*ext)->block_id);
+	}
+	
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL) )
+		return FALSE;
+	
+	/* Save all blocks into the binary */
+	
+	for ( i = 0; i < blk_count; i++ ) {
+		if ( !_save_block(sbin, stream, i) ) 
+			return FALSE;
+	}
+	
+	/* Create the block index */
+	o_stream_seek(stream, block_index);
+	for ( i = 0; i < blk_count; i++ ) {
+		if ( !_save_block_index_record(sbin, stream, i) ) 
+			return FALSE;
+	}
+
+	return TRUE;
+} 
+
+bool sieve_binary_save
+(struct sieve_binary *sbin, const char *path)
+{
+	bool result = TRUE;
+	const char *temp_path;
+	struct ostream *stream;
+	int fd;
+	mode_t save_mode = sbin->script == NULL ? 0600 : sieve_script_permissions(sbin->script);
+	
+	/* Use default path if none is specified */
+	if ( path == NULL ) {
+		if ( sbin->script == NULL ) {
+			sieve_sys_error("cannot determine default binary save path "
+				"with missing script object");
+        	return FALSE;
+		}
+		path = sieve_script_binpath(sbin->script);
+	}
+
+	/* Open it as temp file first, as not to overwrite an existing just yet */
+	temp_path = t_strconcat(path, ".tmp", NULL);
+	fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, save_mode);
+	if ( fd < 0 ) {
+		sieve_sys_error("open(%s) failed for binary save: %m", temp_path);
+		return FALSE;
+	}
+
+	stream = o_stream_create_fd(fd, 0, FALSE);
+	result = _sieve_binary_save(sbin, stream);
+	o_stream_destroy(&stream);
+ 
+	if (close(fd) < 0)
+		sieve_sys_error("close(fd) failed for binary save: %m");
+
+	/* Replace any original binary atomically */
+	if (result && (rename(temp_path, path) < 0)) {
+		sieve_sys_error("rename(%s, %s) failed for binary save: %m",
+			temp_path, path);
+		result = FALSE;
+	}
+
+	if ( !result ) {
+		/* Get rid of temp output (if any) */
+		(void) unlink(temp_path);
+	} else {
+		if ( sbin->path == NULL || strcmp(sbin->path, path) != 0 ) {
+			sbin->path = p_strdup(sbin->pool, path);
+		}
+	}
+	
+	return result;
+}
+
+/* 
+ * Binary file management 
+ */
+
+static bool sieve_binary_file_open
+	(struct sieve_binary_file *file, const char *path)
+{
+	int fd;
+	struct stat st;
+	
+	if ( (fd=open(path, O_RDONLY)) < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_sys_error("binary open(%s) failed: %m", path);
+		}
+		return FALSE;
+	}
+
+	if ( fstat(fd, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_sys_error("binary stat(%s) failed: %m", path);
+		}
+		return FALSE;
+	}
+
+	if ( !S_ISREG(st.st_mode) ) {
+		sieve_sys_error("binary %s is not a regular file", path);
+		return FALSE;		
+	}
+	
+	file->fd = fd;
+	file->st = st;
+
+	return TRUE;
+}
+	
+static void sieve_binary_file_close(struct sieve_binary_file **file)
+{
+	if ( (*file)->fd != -1 ) {
+		if ( close((*file)->fd) < 0 ) {
+			sieve_sys_error("binary close(fd) failed: %m");
+		}
+	}
+
+	pool_unref(&(*file)->pool);
+	
+	*file = NULL;
+}
+
+#if 0 /* file_memory is currently unused */
+
+/* File loaded/mapped to memory */
+
+struct _file_memory {
+	struct sieve_binary_file binfile;
+
+	/* Pointer to the binary in memory */
+	const void *memory;
+	off_t memory_size;
+};
+
+static const void *_file_memory_load_data
+	(struct sieve_binary_file *file, off_t *offset, size_t size)
+{	
+	struct _file_memory *fmem = (struct _file_memory *) file;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	if ( (*offset) + size <= fmem->memory_size ) {
+		const void *data = PTR_OFFSET(fmem->memory, *offset);
+		*offset += size;
+		file->offset = *offset;
+		
+		return data;
+	}
+		
+	return NULL;
+}
+
+static buffer_t *_file_memory_load_buffer
+	(struct sieve_binary_file *file, off_t *offset, size_t size)
+{	
+	struct _file_memory *fmem = (struct _file_memory *) file;
+
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+
+	if ( (*offset) + size <= fmem->memory_size ) {
+		const void *data = PTR_OFFSET(fmem->memory, *offset);
+		*offset += size;
+		file->offset = *offset;
+		
+		return buffer_create_const_data(file->pool, data, size);
+	}
+	
+	return NULL;
+}
+
+static bool _file_memory_load(struct sieve_binary_file *file)
+{
+	struct _file_memory *fmem = (struct _file_memory *) file;
+	int ret;
+	size_t size;
+	void *indata;
+		
+	i_assert(file->fd > 0);
+		
+	/* Allocate memory buffer
+	 */
+	indata = p_malloc(file->pool, file->st.st_size);
+	size = file->st.st_size; 
+	
+	file->offset = 0; 
+	fmem->memory = indata;
+	fmem->memory_size = file->st.st_size;
+
+	/* Return to beginning of the file */
+	if ( lseek(file->fd, 0, SEEK_SET) == (off_t) -1 ) {
+		sieve_sys_error("failed to seek() in binary %s: %m", file->path);
+		return FALSE;
+	}	
+
+	/* Read the whole file into memory */
+	while (size > 0) {
+		if ( (ret=read(file->fd, indata, size)) <= 0 ) {
+			sieve_sys_error("failed to read from binary %s: %m", file->path);
+			break;
+		}
+		
+		indata = PTR_OFFSET(indata, ret);
+		size -= ret;
+	}	
+
+	if ( size != 0 ) {
+		/* Failed to read the whole file */
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static struct sieve_binary_file *_file_memory_open(const char *path)
+{
+	pool_t pool;
+	struct _file_memory *file;
+	
+	pool = pool_alloconly_create("sieve_binary_file_memory", 1024);
+	file = p_new(pool, struct _file_memory, 1);
+	file->binfile.pool = pool;
+	file->binfile.path = p_strdup(pool, path);
+	file->binfile.load = _file_memory_load;
+	file->binfile.load_data = _file_memory_load_data;
+	file->binfile.load_buffer = _file_memory_load_buffer;
+	
+	if ( !sieve_binary_file_open(&file->binfile, path) ) {
+		pool_unref(&pool);
+		return NULL;
+	}
+
+	return &file->binfile;
+}
+
+#endif /* file_memory is currently unused */
+
+/* File open in lazy mode (only read what is needed into memory) */
+
+static bool _file_lazy_read
+(struct sieve_binary_file *file, off_t *offset, void *buffer, size_t size)
+{
+	int ret;
+	void *indata = buffer;
+	size_t insize = size;
+	
+	*offset = SIEVE_BINARY_ALIGN(*offset);
+	
+	/* Seek to the correct position */ 
+	if ( *offset != file->offset && 
+		lseek(file->fd, *offset, SEEK_SET) == (off_t) -1 ) {
+		sieve_sys_error("failed to seek(fd, %lld, SEEK_SET) in binary %s: %m", 
+			(long long) *offset, file->path);
+		return FALSE;
+	}	
+
+	/* Read record into memory */
+	while (insize > 0) {
+		if ( (ret=read(file->fd, indata, insize)) <= 0 ) {
+			if ( ret == 0 ) 
+				sieve_sys_error("binary %s is truncated (more data expected)", 
+					file->path);
+			else
+				sieve_sys_error("failed to read from binary %s: %m", file->path);
+			break;
+		}
+		
+		indata = PTR_OFFSET(indata, ret);
+		insize -= ret;
+	}	
+
+	if ( insize != 0 ) {
+		/* Failed to read the whole requested record */
+		return FALSE;
+	}
+	
+	*offset += size;
+	file->offset = *offset;
+
+	return TRUE;
+}
+
+static const void *_file_lazy_load_data
+(struct sieve_binary_file *file, off_t *offset, size_t size)
+{	
+	void *data = t_malloc(size);
+
+	if ( _file_lazy_read(file, offset, data, size) ) {
+		return data;
+	}
+	
+	return NULL;
+}
+
+static buffer_t *_file_lazy_load_buffer
+(struct sieve_binary_file *file, off_t *offset, size_t size)
+{			
+	buffer_t *buffer = buffer_create_static_hard(file->pool, size);
+	
+	if ( _file_lazy_read
+		(file, offset, buffer_get_space_unsafe(buffer, 0, size), size) ) {
+		return buffer;
+	}
+	
+	return NULL;
+}
+
+static struct sieve_binary_file *_file_lazy_open(const char *path)
+{
+	pool_t pool;
+	struct sieve_binary_file *file;
+	
+	pool = pool_alloconly_create("sieve_binary_file_lazy", 4096);
+	file = p_new(pool, struct sieve_binary_file, 1);
+	file->pool = pool;
+	file->path = p_strdup(pool, path);
+	file->load_data = _file_lazy_load_data;
+	file->load_buffer = _file_lazy_load_buffer;
+	
+	if ( !sieve_binary_file_open(file, path) ) {
+		pool_unref(&pool);
+		return NULL;
+	}
+
+	return file;
+}
+
+/* 
+ * Load binary from a file
+ */
+
+#define LOAD_HEADER(sbin, offset, header) \
+	(header *) sbin->file->load_data(sbin->file, offset, sizeof(header))
+
+static struct sieve_binary_block *_load_block
+(struct sieve_binary *sbin, off_t *offset, unsigned int id)
+{
+	const struct sieve_binary_block_header *header = 
+		LOAD_HEADER(sbin, offset, const struct sieve_binary_block_header);
+	struct sieve_binary_block *block;
+		
+	if ( header == NULL ) {
+		sieve_sys_error("block %d of loaded binary %s is truncated", id, sbin->path);
+		return NULL;
+	}
+	
+	if ( header->id != id ) {
+		sieve_sys_error("block %d of loaded binary %s has unexpected id %d", id, 
+			sbin->path, header->id);
+		return NULL;
+	}
+	
+	block = sieve_binary_block_get(sbin, id);
+	
+	if ( block == NULL ) {
+		sieve_sys_error("!!BUG!!: block %d missing in index (impossible) "
+			"of binary %s",	id, sbin->path);
+		return NULL;
+	}
+	
+	block->buffer = sbin->file->load_buffer(sbin->file, offset, header->size);
+	if ( block->buffer == NULL ) {
+		sieve_sys_error("block %d of loaded binary %s has invalid size %d",
+			id, sbin->path, header->size);
+		return NULL;
+	}
+		
+	return block;
+}
+
+static struct sieve_binary_block *sieve_binary_load_block
+(struct sieve_binary *sbin, unsigned int id)
+{
+	struct sieve_binary_block *block;
+	off_t offset;
+	
+	block = sieve_binary_block_get(sbin, id);
+	
+	if ( block == NULL ) return NULL;
+	
+	offset = block->offset;
+	
+	return _load_block(sbin, &offset, id);
+}
+
+static bool _load_block_index_record
+(struct sieve_binary *sbin, off_t *offset, unsigned int id)
+{
+	const struct sieve_binary_block_index *record = 
+		LOAD_HEADER(sbin, offset, const struct sieve_binary_block_index);
+	struct sieve_binary_block *block;
+	
+	if ( record == NULL ) {
+		sieve_sys_error("failed to read index record for block %d in binary %s", 
+			id, sbin->path);
+		return FALSE;
+	}
+	
+	if ( record->id != id ) {
+		sieve_sys_error("block index record %d of loaded binary %s "
+			"has unexpected id %d", id, sbin->path, record->id);
+		return FALSE;
+	}
+	
+	block = sieve_binary_block_create_id(sbin, id);
+	block->ext_index = record->ext_id;
+	block->offset = record->offset;
+	
+	return TRUE;
+}
+
+static bool _sieve_binary_load_extensions(struct sieve_binary *sbin)
+{
+	sieve_size_t offset = 0;
+	unsigned int i, count;
+	bool result = TRUE;
+	
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_EXTENSIONS, NULL) ) 
+		return FALSE;
+
+	if ( !sieve_binary_read_unsigned(sbin, &offset, &count) )
+		return FALSE;
+	
+	for ( i = 0; result && i < count; i++ ) {
+		T_BEGIN {
+			string_t *extension;
+			const struct sieve_extension *ext;
+			
+			if ( sieve_binary_read_string(sbin, &offset, &extension) ) { 
+				ext = sieve_extension_get_by_name(str_c(extension));	
+			
+				if ( ext == NULL ) { 
+					sieve_sys_error("loaded binary %s requires unknown extension '%s'", 
+						sbin->path, str_sanitize(str_c(extension), 128));
+					result = FALSE;					
+				} else {
+					struct sieve_binary_extension_reg *ereg = NULL;
+					
+					(void) sieve_binary_extension_register(sbin, ext, &ereg);
+					if ( !sieve_binary_read_unsigned(sbin, &offset, &ereg->block_id) )
+						result = FALSE;
+				}
+			}	else
+				result = FALSE;
+		} T_END;
+	}		
+		
+	return result;
+}
+
+static bool _sieve_binary_open(struct sieve_binary *sbin)
+{
+	bool result = TRUE;
+	off_t offset = 0;
+	const struct sieve_binary_header *header;
+	struct sieve_binary_block *extensions;
+	unsigned int i, blk_count;
+	
+	/* Verify header */
+	
+	T_BEGIN {
+		header = LOAD_HEADER(sbin, &offset, const struct sieve_binary_header);
+		if ( header == NULL ) {
+			sieve_sys_error("opened binary %s is not even large enough "
+				"to contain a header.", sbin->path);
+			result = FALSE;
+
+		} else if ( header->magic != SIEVE_BINARY_MAGIC ) {
+			if ( header->magic != SIEVE_BINARY_MAGIC_OTHER_ENDIAN ) 
+				sieve_sys_error("opened binary %s has corrupted header (0x%08x)", 
+					sbin->path, header->magic);
+			result = FALSE;
+
+		} else if ( result && (
+		  header->version_major != SIEVE_BINARY_VERSION_MAJOR || 
+			header->version_minor != SIEVE_BINARY_VERSION_MINOR ) ) {
+
+			/* Binary is of different version. Caller will have to recompile */
+			result = FALSE;
+
+		} else if ( result && header->blocks == 0 ) {
+			sieve_sys_error("opened binary %s contains no blocks", sbin->path);
+			result = FALSE; 
+
+		} else {
+			blk_count = header->blocks;
+		}
+	} T_END;
+	
+	if ( !result ) return FALSE;
+	
+	/* Load block index */
+	
+	for ( i = 0; i < blk_count && result; i++ ) {	
+		T_BEGIN {
+			if ( !_load_block_index_record(sbin, &offset, i) ) {
+				sieve_sys_error(
+					"block index record %d of opened binary %s is corrupt", 
+					i, sbin->path);
+				result = FALSE;
+			}
+		} T_END;
+	}
+	
+	if ( !result ) return FALSE;
+	
+	/* Load extensions used by this binary */
+	
+	T_BEGIN {
+		extensions =_load_block(sbin, &offset, 0);
+		if ( extensions == NULL ) {
+			result = FALSE;
+		} else if ( !_sieve_binary_load_extensions(sbin) ) {
+			sieve_sys_error("extension block of opened binary %s is corrupt", 
+				sbin->path);
+			result = FALSE;
+		}
+	} T_END;
+		
+	return result;
+}
+
+static bool _sieve_binary_load(struct sieve_binary *sbin) 
+{	
+	bool result = TRUE;
+	unsigned int i, blk_count;
+	struct sieve_binary_block *block;
+	off_t offset;
+	
+	blk_count = array_count(&sbin->blocks);
+	if ( blk_count == 1 ) {
+		/* Binary is empty */
+		return TRUE;
+	}	
+
+	block = sieve_binary_block_get(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM);
+	offset = block->offset;
+	
+	/* Load the other blocks */
+	
+	for ( i = 1; result && i < blk_count; i++ ) {	
+		T_BEGIN {
+			if ( _load_block(sbin, &offset, i) == NULL ) {
+				sieve_sys_error("block %d of loaded binary %s is corrupt", 
+					i, sbin->path);
+				result = FALSE;
+			}
+		} T_END;
+	}
+				
+	return result;
+}
+
+struct sieve_binary *sieve_binary_open
+	(const char *path, struct sieve_script *script)
+{
+	unsigned int ext_count, i;
+	struct sieve_binary *sbin;
+	struct sieve_binary_file *file;
+		
+	//file = _file_memory_open(path);	
+	file = _file_lazy_open(path);
+	if ( file == NULL )
+		return NULL;
+		
+	/* Create binary object */
+	sbin = sieve_binary_create(script);
+	sbin->path = p_strdup(sbin->pool, path);
+	sbin->file = file;
+	
+	if ( !_sieve_binary_open(sbin) ) {
+		sieve_binary_unref(&sbin);
+		return NULL;
+	}
+	
+	sieve_binary_activate(sbin);
+	
+	/* Signal open event to extensions */
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_open != NULL && 
+			!binext->binary_open(sbin) ) {
+			/* Extension thinks its corrupt */
+			sieve_binary_unref(&sbin);
+			return NULL;
+		}
+	}	
+
+	return sbin;
+}
+
+bool sieve_binary_load(struct sieve_binary *sbin)
+{
+	i_assert(sbin->file != NULL);
+
+	/*
+	if ( sbin->file->load != NULL && !sbin->file->load(sbin->file) )
+		return FALSE;	*/		
+	
+	if ( !_sieve_binary_load(sbin) ) {
+		/* Failed to interpret binary header and/or block structure */
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Up-to-date checking
+ */
+
+bool sieve_binary_up_to_date(struct sieve_binary *sbin)
+{
+	unsigned int ext_count, i;
+	
+	i_assert(sbin->file != NULL);
+
+	if ( sbin->script == NULL || !sieve_script_older
+		(sbin->script, sbin->file->st.st_mtime) )
+		return FALSE;
+	
+	ext_count = array_count(&sbin->extensions);	
+	for ( i = 0; i < ext_count; i++ ) {
+		struct sieve_binary_extension_reg * const *ereg
+			= array_idx(&sbin->extensions, i);
+		const struct sieve_binary_extension *binext = (*ereg)->binext;
+		
+		if ( binext != NULL && binext->binary_up_to_date != NULL && 
+			!binext->binary_up_to_date(sbin) )
+			return FALSE;
+	}
+	
+	return TRUE;
+}
+
+/*
+ * Activate the binary (after code generation)
+ */
+ 
+void sieve_binary_activate(struct sieve_binary *sbin)
+{
+	unsigned int i;
+	
+	(void)sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL);
+	
+	/* Load other extensions into binary */
+	for ( i = 0; i < array_count(&sbin->linked_extensions); i++ ) {
+		struct sieve_binary_extension_reg * const *ereg = 
+			array_idx(&sbin->linked_extensions, i);
+		const struct sieve_extension *ext = (*ereg)->extension;
+		
+		if ( ext != NULL && ext->binary_load != NULL )
+			ext->binary_load(sbin);
+	}
+}
+
+/* 
+ * Extension handling 
+ */
+
+static inline struct sieve_binary_extension_reg *
+	sieve_binary_extension_create_reg
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	int index = array_count(&sbin->extensions);
+	struct sieve_binary_extension_reg *ereg;
+
+	if ( ext_id < 0 ) return NULL;
+
+	ereg = p_new(sbin->pool, struct sieve_binary_extension_reg, 1);
+	ereg->index = index;
+	ereg->extension = ext;
+	
+	array_idx_set(&sbin->extensions, (unsigned int) index, &ereg);
+	array_idx_set(&sbin->extension_index, (unsigned int) ext_id, &ereg);
+	
+	return ereg;
+}
+
+static inline struct sieve_binary_extension_reg *sieve_binary_extension_get_reg 
+(struct sieve_binary *sbin, const struct sieve_extension *ext, bool create) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	struct sieve_binary_extension_reg *reg = NULL;
+
+	if ( ext_id >= 0 && ext_id < (int) array_count(&sbin->extension_index) ) {
+		struct sieve_binary_extension_reg * const *ereg = 
+			array_idx(&sbin->extension_index, (unsigned int) ext_id);
+		
+		reg = *ereg;
+	}
+
+	/* Register if not known */
+	if ( reg == NULL && create )
+		return sieve_binary_extension_create_reg(sbin, ext);
+
+	return reg;
+}
+
+void sieve_binary_extension_set_context
+(struct sieve_binary *sbin, const struct sieve_extension *ext, void *context)
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+	
+	if ( ereg != NULL )
+		ereg->context = context;
+}
+
+const void *sieve_binary_extension_get_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext) 
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+
+	if ( ereg != NULL ) {
+		return ereg->context;
+	}
+		
+	return NULL;
+}
+
+void sieve_binary_extension_set
+(struct sieve_binary *sbin, const struct sieve_binary_extension *bext,
+	void *context)
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, bext->extension, TRUE);
+	
+	if ( ereg != NULL ) {
+		ereg->binext = bext;
+
+		if ( context != NULL )
+			ereg->context = context;
+	}
+}
+
+unsigned int sieve_binary_extension_create_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_block *block;	
+	unsigned int block_id;
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+	
+	i_assert(ereg != NULL);
+
+	block = p_new(sbin->pool, struct sieve_binary_block, 1);
+	block->buffer = buffer_create_dynamic(sbin->pool, 64);
+
+	block_id = sieve_binary_block_add(sbin, block);
+	
+	if ( ereg->block_id < SBIN_SYSBLOCK_LAST )
+		ereg->block_id = block_id;
+	block->ext_index = ereg->index;
+	
+	return block_id;
+}
+
+unsigned int sieve_binary_extension_get_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext)
+{
+	struct sieve_binary_extension_reg *ereg = 
+		sieve_binary_extension_get_reg(sbin, ext, TRUE);
+		
+	i_assert(ereg != NULL);
+
+	return ereg->block_id;
+}
+
+static inline int sieve_binary_extension_register
+(struct sieve_binary *sbin, const struct sieve_extension *ext, 
+	struct sieve_binary_extension_reg **reg_r) 
+{
+	struct sieve_binary_extension_reg *ereg;
+
+	if ( (ereg=sieve_binary_extension_get_reg(sbin, ext, FALSE)) == NULL ) {
+		ereg = sieve_binary_extension_create_reg(sbin, ext);
+		
+		if ( ereg == NULL ) return -1;
+
+		array_append(&sbin->linked_extensions, &ereg, 1);
+	}
+
+	if ( reg_r != NULL ) *reg_r = ereg;
+	return ereg->index;
+}
+
+int sieve_binary_extension_link
+(struct sieve_binary *sbin, const struct sieve_extension *ext) 
+{	
+	return sieve_binary_extension_register(sbin, ext, NULL);
+}
+
+static inline const struct sieve_extension *_sieve_binary_extension_get_by_index
+(struct sieve_binary *sbin, int index) 
+{
+	struct sieve_binary_extension_reg * const *ext;
+	
+	if ( index < (int) array_count(&sbin->extensions) ) {
+		ext = array_idx(&sbin->extensions, (unsigned int) index);
+		
+		return (*ext)->extension;
+	}
+	
+	return NULL;
+}
+
+const struct sieve_extension *sieve_binary_extension_get_by_index
+(struct sieve_binary *sbin, int index)
+{
+	return _sieve_binary_extension_get_by_index(sbin, index);
+}
+
+int sieve_binary_extension_get_index
+	(struct sieve_binary *sbin, const struct sieve_extension *ext) 
+{
+	struct sieve_binary_extension_reg *ereg =
+		sieve_binary_extension_get_reg(sbin, ext, FALSE);
+	
+	return ( ereg == NULL ? -1 : ereg->index );
+}
+
+int sieve_binary_extensions_count(struct sieve_binary *sbin) 
+{
+	return (int) array_count(&sbin->extensions);
+}
+
+/*
+ * Emission functions
+ */
+
+/* Low-level emission functions */
+
+static inline void _sieve_binary_emit_data
+(struct sieve_binary *sbin, const void *data, sieve_size_t size) 
+{	  
+	buffer_append(sbin->data, data, size);
+}
+
+static inline void _sieve_binary_emit_byte
+(struct sieve_binary *sbin, unsigned char byte)
+{
+    _sieve_binary_emit_data(sbin, &byte, 1);
+}
+
+static inline void _sieve_binary_update_data
+(struct sieve_binary *sbin, sieve_size_t address, const void *data, 
+	sieve_size_t size) 
+{
+	buffer_write(sbin->data, address, data, size);
+}
+
+sieve_size_t sieve_binary_emit_data
+(struct sieve_binary *sbin, const void *data, sieve_size_t size)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+
+	_sieve_binary_emit_data(sbin, data, size);
+
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_byte
+(struct sieve_binary *sbin, unsigned char byte) 
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+
+	_sieve_binary_emit_data(sbin, &byte, 1);
+	
+	return address;
+}
+
+void sieve_binary_update_data
+(struct sieve_binary *sbin, sieve_size_t address, const void *data, 
+	sieve_size_t size) 
+{
+	_sieve_binary_update_data(sbin, address, data, size);
+}
+
+/* Offset emission functions */
+
+sieve_size_t sieve_binary_emit_offset(struct sieve_binary *binary, int offset) 
+{
+	int i;
+	sieve_size_t address = _sieve_binary_get_code_size(binary);
+
+	for ( i = 3; i >= 0; i-- ) {
+		char c = (char) (offset >> (i * 8));
+		_sieve_binary_emit_data(binary, &c, 1);
+	}
+	
+	return address;
+}
+
+void sieve_binary_resolve_offset
+	(struct sieve_binary *binary, sieve_size_t address) 
+{
+	int i;
+	int offset = _sieve_binary_get_code_size(binary) - address; 
+	
+	for ( i = 3; i >= 0; i-- ) {
+		char c = (char) (offset >> (i * 8));	
+		_sieve_binary_update_data(binary, address + 3 - i, &c, 1);
+	}
+}
+
+/* Literal emission */
+
+/* FIXME: this integer format is compact, but it might be too slow. 
+ */
+
+sieve_size_t sieve_binary_emit_integer
+(struct sieve_binary *binary, sieve_number_t integer)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(binary);
+	int i;
+	char buffer[sizeof(sieve_number_t) + 1];
+	int bufpos = sizeof(buffer) - 1;
+  
+	buffer[bufpos] = integer & 0x7F;
+	bufpos--;
+	integer >>= 7;
+	while ( integer > 0 ) {
+		buffer[bufpos] = integer & 0x7F;
+		bufpos--;
+		integer >>= 7;  
+	}
+  
+	bufpos++;
+	if ( (sizeof(buffer) - bufpos) > 1 ) { 
+		for ( i = bufpos; i < ((int) sizeof(buffer) - 1); i++) {
+			buffer[i] |= 0x80;
+		}
+	} 
+  
+	_sieve_binary_emit_data(binary, buffer + bufpos, sizeof(buffer) - bufpos);
+
+	return address;
+}
+
+static inline sieve_size_t sieve_binary_emit_dynamic_data
+	(struct sieve_binary *binary, const void *data, sieve_size_t size)
+{
+	sieve_size_t address = sieve_binary_emit_integer(binary, (sieve_number_t) size);
+
+	_sieve_binary_emit_data(binary, data, size);
+  
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_cstring
+	(struct sieve_binary *binary, const char *str)
+{
+	sieve_size_t address = sieve_binary_emit_dynamic_data
+		(binary, (void *) str, (sieve_size_t) strlen(str));
+	_sieve_binary_emit_byte(binary, 0);
+  
+	return address;
+}
+
+sieve_size_t sieve_binary_emit_string
+	(struct sieve_binary *binary, const string_t *str)
+{
+	sieve_size_t address = sieve_binary_emit_dynamic_data
+		(binary, (void *) str_data(str), (sieve_size_t) str_len(str));
+	_sieve_binary_emit_byte(binary, 0);
+	
+	return address;
+}
+
+/*
+ * Extension emission
+ */
+
+sieve_size_t sieve_binary_emit_extension
+(struct sieve_binary *sbin, const struct sieve_extension *ext,
+	unsigned int offset)
+{
+	sieve_size_t address = _sieve_binary_get_code_size(sbin);
+	struct sieve_binary_extension_reg *ereg = NULL;
+
+	(void)sieve_binary_extension_register(sbin, ext, &ereg);
+
+	i_assert(ereg != NULL);
+
+   	_sieve_binary_emit_byte(sbin, offset + ereg->index);
+	return address;
+}
+
+void sieve_binary_emit_extension_object
+(struct sieve_binary *sbin, const struct sieve_extension_objects *objs,
+	unsigned int code)
+{
+	if ( objs->count > 1 )
+		_sieve_binary_emit_byte(sbin, code);
+}
+
+/*
+ * Code retrieval
+ */
+ 
+#define ADDR_CODE_AT(binary, address) (binary->code[*address])
+#define ADDR_DATA_AT(binary, address) ((unsigned char) (binary->code[*address]))
+#define ADDR_BYTES_LEFT(binary, address) (binary->code_size - (*address))
+#define ADDR_JUMP(address, offset) (*address) += offset
+
+/* Literals */
+
+bool sieve_binary_read_byte
+	(struct sieve_binary *binary, sieve_size_t *address, unsigned int *byte_r) 
+{	
+	if ( ADDR_BYTES_LEFT(binary, address) >= 1 ) {
+		if ( byte_r != NULL )
+			*byte_r = ADDR_DATA_AT(binary, address);
+		ADDR_JUMP(address, 1);
+			
+		return TRUE;
+	}
+	
+	*byte_r = 0;
+	return FALSE;
+}
+
+bool sieve_binary_read_code
+	(struct sieve_binary *binary, sieve_size_t *address, int *code_r) 
+{	
+	if ( ADDR_BYTES_LEFT(binary, address) >= 1 ) {
+		if ( code_r != NULL )
+			*code_r = ADDR_CODE_AT(binary, address);
+		ADDR_JUMP(address, 1);
+			
+		return TRUE;
+	}
+	
+	*code_r = 0;
+	return FALSE;
+}
+
+
+bool sieve_binary_read_offset
+	(struct sieve_binary *binary, sieve_size_t *address, int *offset_r) 
+{
+	uint32_t offs = 0;
+	
+	if ( ADDR_BYTES_LEFT(binary, address) >= 4 ) {
+		int i; 
+	  
+		for ( i = 0; i < 4; i++ ) {
+			offs = (offs << 8) + ADDR_DATA_AT(binary, address);
+			ADDR_JUMP(address, 1);
+		}
+	  
+		if ( offset_r != NULL )
+			*offset_r = (int) offs;
+			
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+/* FIXME: might need negative numbers in the future */
+bool sieve_binary_read_integer
+  (struct sieve_binary *binary, sieve_size_t *address, sieve_number_t *int_r) 
+{
+	int bits = sizeof(sieve_number_t) * 8;
+	*int_r = 0;
+  
+	if ( ADDR_BYTES_LEFT(binary, address) == 0 )
+		return FALSE;
+  
+	while ( (ADDR_DATA_AT(binary, address) & 0x80) > 0 ) {
+		if ( ADDR_BYTES_LEFT(binary, address) > 0 && bits > 0) {
+			*int_r |= ADDR_DATA_AT(binary, address) & 0x7F;
+			ADDR_JUMP(address, 1);
+    
+			*int_r <<= 7;
+			bits -= 7;
+		} else {
+			/* This is an error */
+			return FALSE;
+		}
+	}
+  
+	*int_r |= ADDR_DATA_AT(binary, address) & 0x7F;
+	ADDR_JUMP(address, 1);
+  
+	return TRUE;
+}
+
+bool sieve_binary_read_string
+(struct sieve_binary *binary, sieve_size_t *address, string_t **str_r) 
+{
+	unsigned int strlen = 0;
+  
+	if ( !sieve_binary_read_unsigned(binary, address, &strlen) ) 
+		return FALSE;
+    	  
+	if ( strlen > ADDR_BYTES_LEFT(binary, address) ) 
+		return FALSE;
+ 
+ 	if ( str_r != NULL )  
+		*str_r = t_str_new_const(&ADDR_CODE_AT(binary, address), strlen);
+	ADDR_JUMP(address, strlen);
+	
+	if ( ADDR_CODE_AT(binary, address) != 0 )
+		return FALSE;
+	
+	ADDR_JUMP(address, 1);
+  
+	return TRUE;
+}
+
+bool sieve_binary_read_extension
+(struct sieve_binary *sbin, sieve_size_t *address, unsigned int *offset_r,
+	const struct sieve_extension **ext_r)
+{
+	unsigned int code;
+	unsigned int offset = *offset_r;
+	const struct sieve_extension *ext = NULL;
+
+	if ( ADDR_BYTES_LEFT(sbin, address) <= 0 )
+		return FALSE;
+
+	(*offset_r) = code = ADDR_DATA_AT(sbin, address);
+	ADDR_JUMP(address, 1);
+
+	if ( code >= offset ) {
+		ext = _sieve_binary_extension_get_by_index(sbin, code - offset);
+		
+		if ( ext == NULL ) 
+			return FALSE;
+	}
+
+	(*ext_r) = ext;
+
+	return TRUE;
+}
+
+const void *sieve_binary_read_extension_object
+(struct sieve_binary *sbin, sieve_size_t *address, 
+	const struct sieve_extension_objects *objs)
+{
+	unsigned int code;
+
+	if ( objs->count == 0 ) 
+		return NULL;
+
+	if ( objs->count == 1 )
+		return objs->objects;
+
+	if ( ADDR_BYTES_LEFT(sbin, address) <= 0 )
+		return NULL;
+
+	code = ADDR_DATA_AT(sbin, address);
+	ADDR_JUMP(address, 1);	
+
+	if ( code >= objs->count )
+		return NULL;
+
+	return ((const void *const *) objs->objects)[code];
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,153 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+
+#include "sieve-dump.h"
+
+/*
+ * Binary dumper object
+ */ 
+ 
+struct sieve_binary_dumper {
+	pool_t pool;
+	
+	/* Dumptime environment */
+	struct sieve_dumptime_env dumpenv; 
+};
+
+struct sieve_binary_dumper *sieve_binary_dumper_create
+	(struct sieve_binary *sbin) 
+{
+	pool_t pool;
+	struct sieve_binary_dumper *dumper;
+	
+	pool = pool_alloconly_create("sieve_binary_dumper", 4096);	
+	dumper = p_new(pool, struct sieve_binary_dumper, 1);
+	dumper->pool = pool;
+	dumper->dumpenv.dumper = dumper;
+	
+	dumper->dumpenv.sbin = sbin;
+	sieve_binary_ref(sbin);
+	
+	return dumper;
+}
+
+void sieve_binary_dumper_free(struct sieve_binary_dumper **dumper) 
+{
+	sieve_binary_unref(&(*dumper)->dumpenv.sbin);
+	pool_unref(&((*dumper)->pool));
+	
+	*dumper = NULL;
+}
+
+pool_t sieve_binary_dumper_pool(struct sieve_binary_dumper *dumper)
+{
+	return dumper->pool;
+}
+
+/* 
+ * Formatted output 
+ */
+
+void sieve_binary_dumpf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{ 
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);			
+	str_vprintfa(outbuf, fmt, args);
+	va_end(args);
+	
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_binary_dump_sectionf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);			
+	str_printfa(outbuf, "\n* ");
+	str_vprintfa(outbuf, fmt, args);
+	str_printfa(outbuf, ":\n\n");
+	va_end(args);
+	
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+/* 
+ * Dumping the binary
+ */
+
+bool sieve_binary_dumper_run
+(struct sieve_binary_dumper *dumper, struct ostream *stream) 
+{	
+	struct sieve_binary *sbin = dumper->dumpenv.sbin;
+	struct sieve_dumptime_env *denv = &(dumper->dumpenv);
+	int count, i;
+	
+	dumper->dumpenv.stream = stream;
+	
+	/* Dump list of used extensions */
+	
+	count = sieve_binary_extensions_count(sbin);
+	if ( count > 0 ) {
+		sieve_binary_dump_sectionf(denv, "Required extensions");
+	
+		for ( i = 0; i < count; i++ ) {
+			const struct sieve_extension *ext = sieve_binary_extension_get_by_index
+				(sbin, i);
+			sieve_binary_dumpf(denv, "%3d: %s (%d)\n", i, ext->name, SIEVE_EXT_ID(ext));
+		}
+	}
+
+	/* Dump extension-specific elements of the binary */
+	
+	count = sieve_binary_extensions_count(sbin);
+	if ( count > 0 ) {	
+		for ( i = 0; i < count; i++ ) {
+			bool success = TRUE;
+
+			T_BEGIN { 
+				const struct sieve_extension *ext = sieve_binary_extension_get_by_index
+					(sbin, i);
+	
+				if ( ext->binary_dump != NULL ) {	
+					success = ext->binary_dump(denv);
+				}
+			} T_END;
+
+			if ( !success ) return FALSE;
+		}
+	}
+	
+	/* Dump main program */
+	
+	sieve_binary_dump_sectionf(denv, "Main program (block: %d)", SBIN_SYSBLOCK_MAIN_PROGRAM);
+
+	if ( !sieve_binary_block_set_active(sbin, SBIN_SYSBLOCK_MAIN_PROGRAM, NULL) ) {
+        return FALSE;
+	}
+
+	dumper->dumpenv.cdumper = sieve_code_dumper_create(&(dumper->dumpenv));
+
+	if ( dumper->dumpenv.cdumper != NULL ) {
+		sieve_code_dumper_run(dumper->dumpenv.cdumper);
+		
+		sieve_code_dumper_free(&dumper->dumpenv.cdumper);
+	}
+	
+	/* Finish with empty line */
+	sieve_binary_dumpf(denv, "\n");
+
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary-dumper.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_BINARY_DUMPER_H
+#define __SIEVE_BINARY_DUMPER_H
+
+#include "sieve-common.h"
+
+/*
+ * Binary dumper object
+ */
+
+struct sieve_binary_dumper;
+
+struct sieve_binary_dumper *sieve_binary_dumper_create
+	(struct sieve_binary *sbin);
+void sieve_binary_dumper_free
+	(struct sieve_binary_dumper **dumper);
+
+pool_t sieve_binary_dumper_pool
+	(struct sieve_binary_dumper *dumper);
+
+/* 
+ * Formatted output 
+ */
+
+void sieve_binary_dumpf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...);
+void sieve_binary_dump_sectionf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...);
+
+/*
+ * Dumping the binary
+ */
+
+bool sieve_binary_dumper_run
+	(struct sieve_binary_dumper *dumper, struct ostream *stream);
+
+
+#endif /* __SIEVE_BINARY_DUMPER_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-binary.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-binary.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,194 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_BINARY_H
+#define __SIEVE_BINARY_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+/*
+ * Binary object
+ */
+ 
+struct sieve_binary;
+
+struct sieve_binary *sieve_binary_create_new(struct sieve_script *script);
+void sieve_binary_ref(struct sieve_binary *sbin);
+void sieve_binary_unref(struct sieve_binary **sbin);
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_binary_pool(struct sieve_binary *sbin);
+struct sieve_script *sieve_binary_script(struct sieve_binary *sbin);
+const char *sieve_binary_path(struct sieve_binary *sbin);
+bool sieve_binary_script_older
+	(struct sieve_binary *sbin, struct sieve_script *script);
+
+const char *sieve_binary_script_name(struct sieve_binary *sbin);
+const char *sieve_binary_script_path(struct sieve_binary *sbin);
+
+/*
+ * Activation after code generation
+ */ 
+ 
+void sieve_binary_activate(struct sieve_binary *sbin);
+
+/* 
+ * Saving the binary
+ */
+ 
+bool sieve_binary_save
+	(struct sieve_binary *sbin, const char *path);
+	
+/* 
+ * Loading the binary
+ */ 
+	
+struct sieve_binary *sieve_binary_open
+	(const char *path, struct sieve_script *script);
+bool sieve_binary_up_to_date(struct sieve_binary *sbin);
+bool sieve_binary_load(struct sieve_binary *sbin);
+	
+/* 
+ * Block management 
+ */
+ 
+enum sieve_binary_system_block {
+	SBIN_SYSBLOCK_EXTENSIONS,
+	SBIN_SYSBLOCK_MAIN_PROGRAM,
+	SBIN_SYSBLOCK_LAST
+};
+
+bool sieve_binary_block_set_active
+	(struct sieve_binary *sbin, unsigned int id, unsigned *old_id_r);
+unsigned int sieve_binary_block_create(struct sieve_binary *sbin);
+void sieve_binary_block_clear
+	(struct sieve_binary *sbin, unsigned int id);
+	
+/* 
+ * Extension support 
+ */
+ 
+struct sieve_binary_extension {
+	const struct sieve_extension *extension;
+
+	bool (*binary_save)(struct sieve_binary *sbin);
+	bool (*binary_open)(struct sieve_binary *sbin);
+	
+	void (*binary_free)(struct sieve_binary *sbin);
+	
+	bool (*binary_up_to_date)(struct sieve_binary *sbin);
+};
+ 
+void sieve_binary_extension_set_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext, void *context);
+const void *sieve_binary_extension_get_context
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+	
+void sieve_binary_extension_set
+	(struct sieve_binary *sbin, const struct sieve_binary_extension *bext,
+		void *context);
+
+unsigned int sieve_binary_extension_create_block
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+unsigned int sieve_binary_extension_get_block
+(struct sieve_binary *sbin, const struct sieve_extension *ext);
+
+int sieve_binary_extension_link
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+const struct sieve_extension *sieve_binary_extension_get_by_index
+	(struct sieve_binary *sbin, int index);
+int sieve_binary_extension_get_index
+	(struct sieve_binary *sbin, const struct sieve_extension *ext);
+int sieve_binary_extensions_count(struct sieve_binary *sbin);
+
+	
+/* 
+ * Code emission 
+ */
+ 
+/* Low-level emission functions */
+
+sieve_size_t sieve_binary_emit_data
+	(struct sieve_binary *binary, const void *data, sieve_size_t size);
+sieve_size_t sieve_binary_emit_byte
+	(struct sieve_binary *binary, unsigned char byte);
+void sieve_binary_update_data
+	(struct sieve_binary *binary, sieve_size_t address, const void *data, 
+		sieve_size_t size);
+sieve_size_t sieve_binary_get_code_size(struct sieve_binary *binary);
+
+/* Offset emission functions */
+
+sieve_size_t sieve_binary_emit_offset
+	(struct sieve_binary *binary, int offset);
+void sieve_binary_resolve_offset
+	(struct sieve_binary *binary, sieve_size_t address);
+
+/* Literal emission functions */
+
+sieve_size_t sieve_binary_emit_integer
+	(struct sieve_binary *binary, sieve_number_t integer);
+sieve_size_t sieve_binary_emit_string
+	(struct sieve_binary *binary, const string_t *str);
+sieve_size_t sieve_binary_emit_cstring
+	(struct sieve_binary *binary, const char *str);
+
+static inline sieve_size_t sieve_binary_emit_unsigned
+	(struct sieve_binary *binary, unsigned int count)
+{
+	return sieve_binary_emit_integer(binary, count);
+}
+
+
+/* Extension emission functions */
+
+sieve_size_t sieve_binary_emit_extension
+	(struct sieve_binary *sbin, const struct sieve_extension *ext,
+		unsigned int offset);
+void sieve_binary_emit_extension_object
+	(struct sieve_binary *sbin, const struct sieve_extension_objects *objs,
+    	unsigned int code);
+
+/* 
+ * Code retrieval 
+ */
+
+/* Literals */
+bool sieve_binary_read_byte
+	(struct sieve_binary *binary, sieve_size_t *address, unsigned int *byte_r);
+bool sieve_binary_read_code
+	(struct sieve_binary *binary, sieve_size_t *address, int *code_r);
+bool sieve_binary_read_offset
+	(struct sieve_binary *binary, sieve_size_t *address, int *offset_r);
+bool sieve_binary_read_integer
+  (struct sieve_binary *binary, sieve_size_t *address, sieve_number_t *int_r); 
+bool sieve_binary_read_string
+  (struct sieve_binary *binary, sieve_size_t *address, string_t **str_r);
+
+static inline bool sieve_binary_read_unsigned
+  (struct sieve_binary *binary, sieve_size_t *address, unsigned int *count_r)
+{
+	sieve_number_t integer;
+
+	if ( !sieve_binary_read_integer(binary, address, &integer) )
+		return FALSE;
+
+	*count_r = integer;
+
+	return TRUE;
+}
+
+/* Extension */
+bool sieve_binary_read_extension
+	(struct sieve_binary *sbin, sieve_size_t *address, unsigned int *offset_r,
+		const struct sieve_extension **ext_r);
+const void *sieve_binary_read_extension_object
+	(struct sieve_binary *binary, sieve_size_t *address,
+    	const struct sieve_extension_objects *objs);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,576 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "istream.h"
+#include "buffer.h"
+
+#include "sieve-extensions.h"
+
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-binary.h"
+#include "sieve-actions.h"
+#include "sieve-result.h"
+
+#include "sieve-parser.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-binary-dumper.h"
+
+#include "sieve.h"
+#include "sieve-common.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <dirent.h>
+
+/* 
+ * Main Sieve library interface
+ */
+
+bool sieve_init(void)
+{
+	return sieve_extensions_init();
+}
+
+void sieve_deinit(void)
+{
+	sieve_extensions_deinit();
+}
+
+void sieve_set_extensions(const char *extensions)
+{
+	sieve_extensions_set_string(extensions);
+}
+
+const char *sieve_get_capabilities(const char *name) 
+{
+	if ( name == NULL || *name == '\0' )
+		return sieve_extensions_get_string();
+	
+	return sieve_extension_capabilities_get_string(name);
+}
+
+/*
+ * Low-level compiler functions 
+ */
+
+struct sieve_ast *sieve_parse
+	(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_parser *parser;
+	struct sieve_ast *ast = NULL;
+	
+	/* Parse */
+	parser = sieve_parser_create(script, ehandler);
+
+ 	if ( !sieve_parser_run(parser, &ast) || sieve_get_errors(ehandler) > 0 ) {
+ 		ast = NULL;
+ 	} else 
+		sieve_ast_ref(ast);
+	
+	sieve_parser_free(&parser); 	
+	
+	return ast;
+}
+
+bool sieve_validate(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	bool result = TRUE;
+	struct sieve_validator *validator = sieve_validator_create(ast, ehandler);
+		
+	if ( !sieve_validator_run(validator) || sieve_get_errors(ehandler) > 0 ) 
+		result = FALSE;
+	
+	sieve_validator_free(&validator);	
+		
+	return result;
+}
+
+static struct sieve_binary *sieve_generate
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler)
+{
+	struct sieve_generator *generator = sieve_generator_create(ast, ehandler);
+	struct sieve_binary *sbin = NULL;
+		
+	(void) sieve_generator_run(generator, &sbin);
+	
+	sieve_generator_free(&generator);
+	
+	return sbin;
+}
+
+/*
+ * Sieve compilation
+ */
+
+struct sieve_binary *sieve_compile_script
+(struct sieve_script *script, struct sieve_error_handler *ehandler) 
+{
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin;		
+  	
+	/* Parse */
+	if ( (ast = sieve_parse(script, ehandler)) == NULL ) {
+ 		sieve_error(ehandler, sieve_script_name(script), "parse failed");
+		return NULL;
+	}
+
+	/* Validate */
+	if ( !sieve_validate(ast, ehandler) ) {
+		sieve_error(ehandler, sieve_script_name(script), "validation failed");
+		
+ 		sieve_ast_unref(&ast);
+ 		return NULL;
+ 	}
+ 	
+	/* Generate */
+	if ( (sbin=sieve_generate(ast, ehandler)) == NULL ) {
+		sieve_error(ehandler, sieve_script_name(script), "code generation failed");
+		
+		sieve_ast_unref(&ast);
+		return NULL;
+	}
+	
+	/* Cleanup */
+	sieve_ast_unref(&ast);
+
+	return sbin;
+}
+
+struct sieve_binary *sieve_compile
+(const char *script_path, const char *script_name, 
+	struct sieve_error_handler *ehandler)
+{
+	struct sieve_script *script;
+	struct sieve_binary *sbin;
+
+	if ( (script = sieve_script_create
+		(script_path, script_name, ehandler, NULL)) == NULL )
+		return NULL;
+	
+	sbin = sieve_compile_script(script, ehandler);
+	
+	sieve_script_unref(&script);
+	
+	return sbin;
+}
+
+/*
+ * Sieve runtime
+ */
+
+static int sieve_run
+(struct sieve_binary *sbin, struct sieve_result **result, 
+	const struct sieve_message_data *msgdata, const struct sieve_script_env *senv, 
+	struct sieve_error_handler *ehandler)
+{
+	struct sieve_interpreter *interp;
+	int ret = 0;
+
+	/* Create the interpreter */
+	if ( (interp=sieve_interpreter_create(sbin, ehandler)) == NULL )
+		return SIEVE_EXEC_BIN_CORRUPT;
+
+	/* Reset execution status */
+	if ( senv->exec_status != NULL )
+		memset(senv->exec_status, 0, sizeof(*senv->exec_status));
+	
+	/* Create result object */
+	if ( *result == NULL )
+		*result = sieve_result_create(ehandler);
+	else {
+		sieve_result_ref(*result);
+		sieve_result_set_error_handler(*result, ehandler);
+	}
+							
+	/* Run the interpreter */
+	ret = sieve_interpreter_run(interp, msgdata, senv, *result);
+	
+	/* Free the interpreter */
+	sieve_interpreter_free(&interp);
+
+	return ret;
+}
+
+/*
+ * Reading/writing sieve binaries
+ */
+
+struct sieve_binary *sieve_open
+(const char *script_path, const char *script_name,
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	struct sieve_script *script;
+	struct sieve_binary *sbin;
+	const char *binpath;
+	
+	/* First open the scriptfile itself */
+	script = sieve_script_create(script_path, script_name, ehandler, exists_r);
+
+	if ( script == NULL ) {
+		/* Failed */
+		return NULL;
+	}
+
+	T_BEGIN {
+		/* Then try to open the matching binary */
+		binpath = sieve_script_binpath(script);	
+		sbin = sieve_binary_open(binpath, script);
+	
+		if (sbin != NULL) {
+			/* Ok, it exists; now let's see if it is up to date */
+			if ( !sieve_binary_up_to_date(sbin) ) {
+				/* Not up to date */
+				sieve_binary_unref(&sbin);
+				sbin = NULL;
+			} else if ( !sieve_binary_load(sbin) ) {
+				/* Failed to load */
+				sieve_binary_unref(&sbin);
+				sbin = NULL;
+			}
+		}
+		
+		/* If the binary does not exist, is not up-to-date or fails to load, we need
+		 * to (re-)compile.
+		 */
+		if ( sbin == NULL ) {	
+			sbin = sieve_compile_script(script, ehandler);
+
+			/* Save the binary if compile was successful */
+			if ( sbin != NULL ) 
+				(void) sieve_binary_save(sbin, binpath);	
+		}
+	} T_END;
+	
+	/* Drop script reference, if sbin != NULL it holds a reference of its own. 
+	 * Otherwise the script object is freed here.
+	 */
+	sieve_script_unref(&script);
+
+	return sbin;
+} 
+
+bool sieve_save
+    (struct sieve_binary *sbin, const char *path)
+{
+	return sieve_binary_save(sbin, path);
+}
+
+void sieve_close(struct sieve_binary **sbin)
+{
+	sieve_binary_unref(sbin);
+}
+
+/*
+ * Debugging
+ */
+
+void sieve_dump(struct sieve_binary *sbin, struct ostream *stream) 
+{
+	struct sieve_binary_dumper *dumpr = sieve_binary_dumper_create(sbin);			
+
+	sieve_binary_dumper_run(dumpr, stream);	
+	
+	sieve_binary_dumper_free(&dumpr);
+}
+
+int sieve_test
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	struct ostream *stream) 	
+{
+	struct sieve_result *result = NULL;
+	int ret;
+	
+	/* Run the script */
+	ret = sieve_run(sbin, &result, msgdata, senv, ehandler);
+				
+	/* Print result if successful */
+	if ( ret > 0 ) 
+		ret = sieve_result_print(result, senv, stream, NULL);
+	
+	/* Cleanup */
+	sieve_result_unref(&result);
+	
+	return ret;
+}
+
+/*
+ * Script execution
+ */
+
+int sieve_execute
+(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_error_handler *ehandler)
+{
+	struct sieve_result *result = NULL;
+	int ret;
+	
+	/* Run the script */
+	ret = sieve_run(sbin, &result, msgdata, senv, ehandler);
+		
+	/* Evaluate status and execute the result:
+	 *   Strange situations, e.g. currupt binaries, must be handled by the caller. 
+	 *   In that case no implicit keep is attempted, because the situation may be 
+	 *   resolved.
+	 */
+	if ( ret >= 0 ) {
+		if ( ret > 0 ) 
+			/* Execute result */
+			ret = sieve_result_execute(result, msgdata, senv, NULL);
+		else {
+			/* Perform implicit keep if script failed with a normal runtime error */
+			if ( !sieve_result_implicit_keep(result, msgdata, senv) )
+				ret = SIEVE_EXEC_KEEP_FAILED;
+		}
+	}
+	
+	/* Cleanup */
+	sieve_result_unref(&result);
+
+	return ret;
+}
+
+/*
+ * Multiscript support
+ */
+ 
+struct sieve_multiscript {
+	struct sieve_result *result;
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+
+	int status;
+	bool active;
+	bool ended;
+
+	struct ostream *teststream;
+};
+ 
+struct sieve_multiscript *sieve_multiscript_start_execute
+(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv)
+{
+	pool_t pool;
+	struct sieve_result *result;
+	struct sieve_multiscript *mscript;
+	
+	result = sieve_result_create(NULL);
+	pool = sieve_result_pool(result);
+	
+	sieve_result_set_keep_action(result, NULL);
+	
+	mscript = p_new(pool, struct sieve_multiscript, 1);
+	mscript->result = result;
+	mscript->msgdata = msgdata;
+	mscript->scriptenv = senv;
+	mscript->status = SIEVE_EXEC_OK;
+	mscript->active = TRUE;
+	
+	return mscript;
+}
+
+struct sieve_multiscript *sieve_multiscript_start_test
+(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+	struct ostream *stream)
+{
+	struct sieve_multiscript *mscript = 
+		sieve_multiscript_start_execute(msgdata, senv);
+	
+	mscript->teststream = stream;
+
+	return mscript;
+}
+
+static void sieve_multiscript_test
+(struct sieve_multiscript *mscript, struct sieve_error_handler *ehandler)
+{						
+	bool keep = FALSE;
+
+	sieve_result_set_error_handler(mscript->result, ehandler);
+
+	mscript->status = sieve_result_print
+		(mscript->result, mscript->scriptenv, mscript->teststream, &keep);
+		
+	mscript->active = ( mscript->active && keep );
+
+	sieve_result_mark_executed(mscript->result);
+}
+
+static void sieve_multiscript_execute
+(struct sieve_multiscript *mscript, struct sieve_error_handler *ehandler)
+{
+	bool keep = FALSE;
+			
+	sieve_result_set_error_handler(mscript->result, ehandler);
+
+	if ( mscript->status > 0 )
+		mscript->status = sieve_result_execute
+			(mscript->result, mscript->msgdata, mscript->scriptenv, &keep);
+	else {
+		if ( !sieve_result_implicit_keep
+			(mscript->result, mscript->msgdata, mscript->scriptenv) )
+			mscript->status = SIEVE_EXEC_KEEP_FAILED;
+	}
+	
+	mscript->active = ( mscript->active && keep );
+}
+
+bool sieve_multiscript_run
+(struct sieve_multiscript *mscript, struct sieve_binary *sbin,
+	struct sieve_error_handler *ehandler, bool final)
+{
+	if ( !mscript->active ) return FALSE;
+	
+	if ( final )
+		sieve_result_set_keep_action(mscript->result, &act_store);
+	
+	/* Run the script */
+	mscript->status = sieve_run(sbin, &mscript->result, mscript->msgdata, 
+		mscript->scriptenv, ehandler);
+
+	if ( mscript->status >= 0 ) {
+		if ( mscript->teststream != NULL ) 
+			sieve_multiscript_test(mscript, ehandler);
+		else
+			sieve_multiscript_execute(mscript, ehandler);
+
+		if ( final ) mscript->active = FALSE;
+	}	
+
+	if ( mscript->status <= 0 )
+		return FALSE;
+
+	return mscript->active;
+}
+
+int sieve_multiscript_status(struct sieve_multiscript *mscript)
+{
+	return mscript->status;
+}
+
+int sieve_multiscript_finish(struct sieve_multiscript **mscript, 
+	struct sieve_error_handler *ehandler)
+{
+	struct sieve_result *result = (*mscript)->result;
+	int ret = (*mscript)->status;
+
+	if ( ehandler != NULL )
+		sieve_result_set_error_handler((*mscript)->result, ehandler);	
+
+	if ( (*mscript)->active ) {
+		ret = SIEVE_EXEC_FAILURE;
+
+		if ( (*mscript)->teststream ) {
+		} else {
+			if ( !sieve_result_implicit_keep
+				((*mscript)->result, (*mscript)->msgdata, (*mscript)->scriptenv) )
+				ret = SIEVE_EXEC_KEEP_FAILED;
+		}
+	}
+	
+	/* Cleanup */
+	sieve_result_unref(&result);
+	*mscript = NULL;
+	
+	return ret;
+}
+
+/*
+ * Script directory
+ */
+
+struct sieve_directory {
+		DIR *dirp;
+
+		const char *path;
+};
+
+struct sieve_directory *sieve_directory_open(const char *path)
+{ 
+	struct sieve_directory *sdir = NULL;
+	DIR *dirp;
+	struct stat st;
+
+	/* Specified path can either be a regular file or a directory */
+	if ( stat(path, &st) != 0 )
+		return NULL;
+
+	if ( S_ISDIR(st.st_mode) ) {
+	 	
+		/* Open the directory */
+		if ( (dirp = opendir(path)) == NULL ) {
+			sieve_sys_error("opendir(%s) failed: %m", path);
+			return NULL;		
+		}
+	
+		/* Create object */
+		sdir = t_new(struct sieve_directory, 1);
+		sdir->path = path;
+		sdir->dirp = dirp;
+	} else {
+		sdir = t_new(struct sieve_directory, 1);
+		sdir->path = path;
+		sdir->dirp = NULL;
+	}
+
+	return sdir;
+}
+
+const char *sieve_directory_get_scriptfile(struct sieve_directory *sdir)
+{
+	const char *script = NULL;
+	struct dirent *dp;
+	
+	if ( sdir->dirp != NULL ) {
+		while ( script == NULL ) {
+			const char *file;
+			struct stat st;
+
+			errno = 0;
+			if ( (dp = readdir(sdir->dirp)) == NULL ) {
+				if ( errno != 0 ) { 
+					sieve_sys_error("readdir(%s) failed: %m", sdir->path);
+					continue;
+				} else 
+					return NULL;
+			}
+
+			if ( !sieve_script_file_has_extension(dp->d_name) )
+				continue;
+
+			if ( sdir->path[strlen(sdir->path)-1] == '/' )
+				file = t_strconcat(sdir->path, dp->d_name, NULL);
+			else
+				file = t_strconcat(sdir->path, "/", dp->d_name, NULL);
+
+			if ( stat(file, &st) != 0 || !S_ISREG(st.st_mode) )
+				continue;
+
+			script = file;
+		}
+	} else {
+		script = sdir->path;
+		sdir->path = NULL;		
+	}
+							
+	return script;
+}
+
+void sieve_directory_close(struct sieve_directory **sdir)
+{
+	/* Close the directory */
+	if ( (*sdir)->dirp != NULL && closedir((*sdir)->dirp) < 0 ) 
+		sieve_sys_error("closedir(%s) failed: %m", (*sdir)->path);
+		
+	*sdir = NULL;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1026 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-extensions.h"
+#include "sieve-actions.h"
+#include "sieve-binary.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-code.h"
+
+#include <stdio.h>
+
+/* 
+ * Coded stringlist
+ */
+
+struct sieve_coded_stringlist {
+	const struct sieve_runtime_env *runenv;
+	sieve_size_t start_address;
+	sieve_size_t end_address;
+	sieve_size_t current_offset;
+	unsigned int length;
+	unsigned int index;
+};
+
+static struct sieve_coded_stringlist *sieve_coded_stringlist_create
+(const struct sieve_runtime_env *renv, 
+	 sieve_size_t start_address, unsigned int length, sieve_size_t end)
+{
+	struct sieve_coded_stringlist *strlist;
+	
+	if ( end > sieve_binary_get_code_size(renv->sbin) ) 
+  		return NULL;
+    
+	strlist = t_new(struct sieve_coded_stringlist, 1);
+	strlist->runenv = renv;
+	strlist->start_address = start_address;
+	strlist->current_offset = start_address;
+	strlist->end_address = end;
+	strlist->length = length;
+	strlist->index = 0;
+  
+	return strlist;
+}
+
+bool sieve_coded_stringlist_next_item
+(struct sieve_coded_stringlist *strlist, string_t **str_r) 
+{
+	sieve_size_t address;
+	*str_r = NULL;
+  
+	if ( strlist->index >= strlist->length ) 
+		return TRUE;
+	else {
+		address = strlist->current_offset;
+  	
+		if ( sieve_opr_string_read(strlist->runenv, &address, str_r) ) {
+			strlist->index++;
+			strlist->current_offset = address;
+			return TRUE;
+		}
+	}  
+  
+	return FALSE;
+}
+
+void sieve_coded_stringlist_reset(struct sieve_coded_stringlist *strlist) 
+{  
+	strlist->current_offset = strlist->start_address;
+	strlist->index = 0;
+}
+
+unsigned int sieve_coded_stringlist_get_length
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->length;
+}
+
+sieve_size_t sieve_coded_stringlist_get_end_address
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->end_address;
+}
+
+sieve_size_t sieve_coded_stringlist_get_current_offset
+(struct sieve_coded_stringlist *strlist)
+{
+	return strlist->current_offset;
+}
+
+bool sieve_coded_stringlist_read_all
+(struct sieve_coded_stringlist *strlist, pool_t pool,
+	const char * const **list_r)
+{
+	bool result = FALSE;
+	ARRAY_DEFINE(items, const char *);
+	string_t *item;
+	
+	sieve_coded_stringlist_reset(strlist);
+	
+	p_array_init(&items, pool, 4);
+	
+	item = NULL;
+	while ( (result=sieve_coded_stringlist_next_item(strlist, &item)) && 
+		item != NULL ) {
+		const char *stritem = p_strdup(pool, str_c(item));
+		
+		array_append(&items, &stritem, 1);
+	}
+	
+	(void)array_append_space(&items);
+	*list_r = array_idx(&items, 0);
+
+	return result;
+}
+
+static bool sieve_coded_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+	unsigned int length, sieve_size_t end, const char *field_name)
+{
+	unsigned int i;
+	
+	if ( end > sieve_binary_get_code_size(denv->sbin) ) 
+  		return FALSE;
+    
+	if ( field_name != NULL )
+		sieve_code_dumpf(denv, "%s: STRLIST [%u] (end: %08llx)", 
+			field_name, length, (unsigned long long) end);
+	else
+		sieve_code_dumpf(denv, "STRLIST [%u] (end: %08llx)", 
+			length, (unsigned long long) end);
+	
+	sieve_code_descend(denv);
+	
+	for ( i = 0; i < length; i++ ) {
+		bool success = TRUE;
+
+		T_BEGIN { 		
+			success = sieve_opr_string_dump(denv, address, NULL);
+		} T_END;
+
+		if ( !success || *address > end ) 
+			return FALSE;
+	}
+
+	if ( *address != end ) return FALSE;
+	
+	sieve_code_ascend(denv);
+		
+	return TRUE;
+}
+	
+/*
+ * Source line coding
+ */
+
+void sieve_code_source_line_emit
+(struct sieve_binary *sbin, unsigned int source_line)
+{
+    (void)sieve_binary_emit_unsigned(sbin, source_line);
+}
+
+bool sieve_code_source_line_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    unsigned int number = 0;
+
+	sieve_code_mark(denv);
+    if (sieve_binary_read_unsigned(denv->sbin, address, &number) ) {
+        sieve_code_dumpf(denv, "(source line: %lu)", (unsigned long) number);
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+bool sieve_code_source_line_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	unsigned int *source_line_r)
+{
+	return sieve_binary_read_unsigned(renv->sbin, address, source_line_r);
+}
+
+/*
+ * Core operands
+ */
+ 
+extern const struct sieve_operand comparator_operand;
+extern const struct sieve_operand match_type_operand;
+extern const struct sieve_operand address_part_operand;
+
+const struct sieve_operand *sieve_operands[] = {
+	&omitted_operand, /* SIEVE_OPERAND_OPTIONAL */
+	&number_operand,
+	&string_operand,
+	&stringlist_operand,
+	&comparator_operand,
+	&match_type_operand,
+	&address_part_operand,
+	&catenated_string_operand
+}; 
+
+const unsigned int sieve_operand_count =
+	N_ELEMENTS(sieve_operands);
+
+/* 
+ * Operand functions 
+ */
+
+sieve_size_t sieve_operand_emit_code
+(struct sieve_binary *sbin, const struct sieve_operand *opr)
+{
+	sieve_size_t address;
+
+	if ( opr->extension != NULL ) {
+		address = sieve_binary_emit_extension
+			(sbin, opr->extension, sieve_operand_count);
+	
+		sieve_binary_emit_extension_object
+			(sbin, &opr->extension->operands, opr->code);
+
+		return address;
+	}
+
+	return  sieve_binary_emit_byte(sbin, opr->code);
+}
+
+const struct sieve_operand *sieve_operand_read
+(struct sieve_binary *sbin, sieve_size_t *address) 
+{
+	const struct sieve_extension *ext;
+	unsigned int code = sieve_operand_count;
+
+	if ( !sieve_binary_read_extension(sbin, address, &code, &ext) )
+		return NULL;
+
+	if ( !ext )
+		return code < sieve_operand_count ? sieve_operands[code] : NULL;
+
+	return (const struct sieve_operand *) sieve_binary_read_extension_object
+		(sbin, address, &ext->operands);
+}
+
+bool sieve_operand_optional_present
+(struct sieve_binary *sbin, sieve_size_t *address)
+{	
+	sieve_size_t tmp_addr = *address;
+	unsigned int op = -1;
+	
+	if ( sieve_binary_read_byte(sbin, &tmp_addr, &op) && 
+		(op == SIEVE_OPERAND_OPTIONAL) ) {
+		*address = tmp_addr;
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+bool sieve_operand_optional_read
+(struct sieve_binary *sbin, sieve_size_t *address, int *id_code)
+{
+	if ( sieve_binary_read_code(sbin, address, id_code) ) 
+		return TRUE;
+	
+	*id_code = 0;
+
+	return FALSE;
+}
+
+/* 
+ * Operand definitions
+ */
+
+/* Omitted */
+
+const struct sieve_operand_class omitted_class =
+	{ "OMITTED" };
+
+const struct sieve_operand omitted_operand = {
+	"@OMITTED",
+	NULL, SIEVE_OPERAND_OPTIONAL,	
+	&omitted_class, NULL
+};
+ 
+/* Number */
+
+static bool opr_number_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static bool opr_number_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		sieve_number_t *number_r);
+
+const struct sieve_opr_number_interface number_interface = { 
+	opr_number_dump, 
+	opr_number_read
+};
+
+const struct sieve_operand_class number_class = 
+	{ "number" };
+	
+const struct sieve_operand number_operand = { 
+	"@number", 
+	NULL, SIEVE_OPERAND_NUMBER,
+	&number_class,
+	&number_interface 
+};
+
+/* String */
+
+static bool opr_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static bool opr_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r);
+
+const struct sieve_opr_string_interface string_interface ={ 
+	opr_string_dump,
+	opr_string_read
+};
+	
+const struct sieve_operand_class string_class = 
+	{ "string" };
+	
+const struct sieve_operand string_operand = { 
+	"@string", 
+	NULL, SIEVE_OPERAND_STRING,
+	&string_class,
+	&string_interface
+};	
+
+/* String List */
+
+static bool opr_stringlist_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+static struct sieve_coded_stringlist *opr_stringlist_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_opr_stringlist_interface stringlist_interface = { 
+	opr_stringlist_dump, 
+	opr_stringlist_read
+};
+
+const struct sieve_operand_class stringlist_class = 
+	{ "string-list" };
+
+const struct sieve_operand stringlist_operand =	{ 
+	"@string-list", 
+	NULL, SIEVE_OPERAND_STRING_LIST,
+	&stringlist_class, 
+	&stringlist_interface
+};
+
+/* Catenated String */
+
+static bool opr_catenated_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str);
+static bool opr_catenated_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+
+const struct sieve_opr_string_interface catenated_string_interface = { 
+	opr_catenated_string_dump,
+	opr_catenated_string_read
+};
+		
+const struct sieve_operand catenated_string_operand = { 
+	"@catenated-string", 
+	NULL, SIEVE_OPERAND_CATENATED_STRING,
+	&string_class,
+	&catenated_string_interface
+};	
+	
+/* 
+ * Operand implementations 
+ */
+
+/* Omitted */
+
+void sieve_opr_omitted_emit(struct sieve_binary *sbin)
+{
+    (void) sieve_operand_emit_code(sbin, &omitted_operand);
+}
+ 
+/* Number */
+
+void sieve_opr_number_emit(struct sieve_binary *sbin, sieve_number_t number) 
+{
+	(void) sieve_operand_emit_code(sbin, &number_operand);
+	(void) sieve_binary_emit_integer(sbin, number);
+}
+
+bool sieve_opr_number_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name) 
+{
+	const struct sieve_opr_number_interface *intf;
+
+	if ( !sieve_operand_is_number(operand) ) 
+		return FALSE;
+		
+	intf = (const struct sieve_opr_number_interface *) operand->interface; 
+	
+	if ( intf->dump == NULL )
+		return FALSE;
+
+	return intf->dump(denv, address, field_name);  
+}
+
+bool sieve_opr_number_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	const struct sieve_operand *operand;
+	
+	sieve_code_mark(denv);
+	
+	operand = sieve_operand_read(denv->sbin, address);
+
+	return sieve_opr_number_dump_data(denv, operand, address, field_name);
+}
+
+bool sieve_opr_number_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t *address, sieve_number_t *number_r)
+{
+	const struct sieve_opr_number_interface *intf;
+		
+	if ( !sieve_operand_is_number(operand) ) 
+		return FALSE;	
+		
+	intf = (const struct sieve_opr_number_interface *) operand->interface; 
+	
+	if ( intf->read == NULL )
+		return FALSE;
+
+	return intf->read(renv, address, number_r);  
+}
+
+bool sieve_opr_number_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	sieve_number_t *number_r)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+		
+	return sieve_opr_number_read_data(renv, operand, address, number_r);
+}
+
+static bool opr_number_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	sieve_number_t number = 0;
+	
+	if (sieve_binary_read_integer(denv->sbin, address, &number) ) {
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: NUM %llu", field_name, (unsigned long long) number);
+		else
+			sieve_code_dumpf(denv, "NUM %llu", (unsigned long long) number);
+
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+static bool opr_number_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	sieve_number_t *number_r)
+{ 
+	return sieve_binary_read_integer(renv->sbin, address, number_r);
+}
+
+/* String */
+
+void sieve_opr_string_emit(struct sieve_binary *sbin, string_t *str)
+{
+	(void) sieve_operand_emit_code(sbin, &string_operand);
+	(void) sieve_binary_emit_string(sbin, str);
+}
+
+bool sieve_opr_string_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name) 
+{
+	const struct sieve_opr_string_interface *intf;
+	
+	if ( !sieve_operand_is_string(operand) ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID STRING OPERAND %s", operand->name);
+		return FALSE;
+	}
+		
+	intf = (const struct sieve_opr_string_interface *) operand->interface; 
+	
+	if ( intf->dump == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: DUMP STRING OPERAND");
+		return FALSE;
+	}
+
+	return intf->dump(denv, address, field_name);  
+}
+
+bool sieve_opr_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	const struct sieve_operand *operand;
+	
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+	
+	if ( operand == NULL ) {
+		sieve_code_dumpf(denv, "ERROR: INVALID OPERAND");
+		return FALSE;
+	}
+
+	return sieve_opr_string_dump_data(denv, operand, address, field_name);
+}
+
+bool sieve_opr_string_dump_ex
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+	const char *field_name, bool *literal_r)
+{
+	const struct sieve_operand *operand;
+	
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+
+	*literal_r = ( operand == &string_operand );	
+
+	return sieve_opr_string_dump_data(denv, operand, address, field_name);
+} 
+
+bool sieve_opr_string_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t *address, string_t **str_r)
+{
+	const struct sieve_opr_string_interface *intf;
+	
+	if ( operand == NULL || operand->class != &string_class ) 
+		return FALSE;
+		
+	intf = (const struct sieve_opr_string_interface *) operand->interface; 
+	
+	if ( intf->read == NULL )
+		return FALSE;
+
+	return intf->read(renv, address, str_r);  
+}
+
+bool sieve_opr_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+
+	return sieve_opr_string_read_data(renv, operand, address, str_r);
+}
+
+bool sieve_opr_string_read_ex
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r,
+	bool *literal_r)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+
+	*literal_r = ( operand == &string_operand );
+
+	return sieve_opr_string_read_data(renv, operand, address, str_r);
+}
+
+static void _dump_string
+(const struct sieve_dumptime_env *denv, string_t *str, 
+	const char *field_name) 
+{
+	if ( str_len(str) > 80 ) {
+		if ( field_name != NULL ) 
+			sieve_code_dumpf(denv, "%s: STR[%ld] \"%s", 
+				field_name, (long) str_len(str), str_sanitize(str_c(str), 80));
+		else
+			sieve_code_dumpf(denv, "STR[%ld] \"%s", 
+				(long) str_len(str), str_sanitize(str_c(str), 80));
+	} else {
+		if ( field_name != NULL )
+			sieve_code_dumpf(denv, "%s: STR[%ld] \"%s\"", 
+				field_name, (long) str_len(str), str_sanitize(str_c(str), 80));		
+		else
+			sieve_code_dumpf(denv, "STR[%ld] \"%s\"", 
+				(long) str_len(str), str_sanitize(str_c(str), 80));		
+	}
+}
+
+bool opr_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	string_t *str; 
+	
+	if ( sieve_binary_read_string(denv->sbin, address, &str) ) {
+		_dump_string(denv, str, field_name);   		
+		
+		return TRUE;
+	}
+  
+	return FALSE;
+}
+
+static bool opr_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r)
+{ 	
+	return sieve_binary_read_string(renv->sbin, address, str_r);
+}
+
+/* String list */
+
+void sieve_opr_stringlist_emit_start
+	(struct sieve_binary *sbin, unsigned int listlen, void **context)
+{
+	sieve_size_t *end_offset = t_new(sieve_size_t, 1);
+
+	/* Emit byte identifying the type of operand */	  
+	(void) sieve_operand_emit_code(sbin, &stringlist_operand);
+  
+	/* Give the interpreter an easy way to skip over this string list */
+	*end_offset = sieve_binary_emit_offset(sbin, 0);
+	*context = (void *) end_offset;
+
+	/* Emit the length of the list */
+	(void) sieve_binary_emit_unsigned(sbin, listlen);
+}
+
+void sieve_opr_stringlist_emit_item
+(struct sieve_binary *sbin, void *context ATTR_UNUSED, string_t *item)
+{
+	(void) sieve_opr_string_emit(sbin, item);
+}
+
+void sieve_opr_stringlist_emit_end
+(struct sieve_binary *sbin, void *context)
+{
+	sieve_size_t *end_offset = (sieve_size_t *) context;
+
+	(void) sieve_binary_resolve_offset(sbin, *end_offset);
+}
+
+bool sieve_opr_stringlist_dump_data
+(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+	sieve_size_t *address, const char *field_name) 
+{
+	if ( operand == NULL )
+		return FALSE;
+	
+	if ( operand->class == &stringlist_class ) {
+		const struct sieve_opr_stringlist_interface *intf =
+			(const struct sieve_opr_stringlist_interface *) operand->interface; 
+		
+		if ( intf->dump == NULL )
+			return FALSE;
+
+		return intf->dump(denv, address, field_name); 
+	} else if ( operand->class == &string_class ) {
+		const struct sieve_opr_string_interface *intf =
+			(const struct sieve_opr_string_interface *) operand->interface; 
+	
+		if ( intf->dump == NULL ) 
+			return FALSE;
+
+		return intf->dump(denv, address, field_name);  
+	}
+	
+	return FALSE;
+}
+
+bool sieve_opr_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	const struct sieve_operand *operand;
+
+	sieve_code_mark(denv);
+	operand = sieve_operand_read(denv->sbin, address);
+
+	return sieve_opr_stringlist_dump_data(denv, operand, address, field_name);
+}
+
+struct sieve_coded_stringlist *sieve_opr_stringlist_read_data
+(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+	sieve_size_t op_address, sieve_size_t *address)
+{
+	if ( operand == NULL )
+		return NULL;
+		
+	if ( operand->class == &stringlist_class ) {
+		const struct sieve_opr_stringlist_interface *intf = 
+			(const struct sieve_opr_stringlist_interface *) operand->interface;
+			
+		if ( intf->read == NULL ) 
+			return NULL;
+
+		return intf->read(renv, address);  
+	} else if ( operand->class == &string_class ) {
+		/* Special case, accept single string as string list as well. */
+		const struct sieve_opr_string_interface *intf = 
+			(const struct sieve_opr_string_interface *) operand->interface;
+				
+		if ( intf->read == NULL || !intf->read(renv, address, NULL) ) {
+			return NULL;
+		}
+		
+		return sieve_coded_stringlist_create(renv, op_address, 1, *address); 
+	}	
+	
+	return NULL;
+}
+
+struct sieve_coded_stringlist *sieve_opr_stringlist_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	sieve_size_t op_address = *address;
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+	
+	return sieve_opr_stringlist_read_data(renv, operand, op_address, address);
+}
+
+static bool opr_stringlist_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+	const char *field_name) 
+{
+	sieve_size_t pc = *address;
+	sieve_size_t end; 
+	unsigned int length = 0; 
+ 	int end_offset;
+
+	if ( !sieve_binary_read_offset(denv->sbin, address, &end_offset) )
+		return FALSE;
+
+	end = pc + end_offset;
+
+	if ( !sieve_binary_read_unsigned(denv->sbin, address, &length) ) 
+		return FALSE;	
+  	
+	return sieve_coded_stringlist_dump(denv, address, length, end, field_name); 
+}
+
+static struct sieve_coded_stringlist *opr_stringlist_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address )
+{
+	struct sieve_coded_stringlist *strlist;
+	sieve_size_t pc = *address;
+	sieve_size_t end; 
+	unsigned int length = 0;  
+	int end_offset;
+	
+	if ( !sieve_binary_read_offset(renv->sbin, address, &end_offset) )
+		return NULL;
+
+	end = pc + end_offset;
+
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &length) ) 
+	  	return NULL;	
+  	
+	strlist = sieve_coded_stringlist_create(renv, *address, (unsigned int) length, end); 
+
+	/* Skip over the string list for now */
+	*address = end;
+  
+	return strlist;
+}  
+
+/* Catenated String */
+
+void sieve_opr_catenated_string_emit
+(struct sieve_binary *sbin, unsigned int elements) 
+{
+	(void) sieve_operand_emit_code(sbin, &catenated_string_operand);
+	(void) sieve_binary_emit_unsigned(sbin, elements);
+}
+
+static bool opr_catenated_string_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+	const char *field_name) 
+{
+	unsigned int elements = 0;
+	unsigned int i;
+	
+	if (!sieve_binary_read_unsigned(denv->sbin, address, &elements) )
+		return FALSE;
+	
+	if ( field_name != NULL ) 
+		sieve_code_dumpf(denv, "%s: CAT-STR [%ld]:", 
+			field_name, (long) elements);
+	else
+		sieve_code_dumpf(denv, "CAT-STR [%ld]:", (long) elements);
+
+	sieve_code_descend(denv);
+	for ( i = 0; i < (unsigned int) elements; i++ ) {
+		if ( !sieve_opr_string_dump(denv, address, NULL) )
+			return FALSE;
+	}
+	sieve_code_ascend(denv);
+	
+	return TRUE;
+}
+
+static bool opr_catenated_string_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str)
+{ 
+	unsigned int elements = 0;
+	unsigned int i;
+		
+	if ( !sieve_binary_read_unsigned(renv->sbin, address, &elements) )
+		return FALSE;
+
+	/* Parameter str can be NULL if we are requested to only skip and not 
+	 * actually read the argument.
+	 */
+	if ( str == NULL ) {
+		for ( i = 0; i < (unsigned int) elements; i++ ) {		
+			if ( !sieve_opr_string_read(renv, address, NULL) ) 
+				return FALSE;
+		}
+	} else {
+		string_t *strelm;
+		string_t **elm = &strelm;
+
+		*str = t_str_new(128);
+		for ( i = 0; i < (unsigned int) elements; i++ ) {
+		
+			if ( !sieve_opr_string_read(renv, address, elm) ) 
+				return FALSE;
+		
+			if ( elm != NULL ) {
+				str_append_str(*str, strelm);
+
+				if ( str_len(*str) > SIEVE_MAX_STRING_LEN ) {
+					str_truncate(*str, SIEVE_MAX_STRING_LEN);
+					elm = NULL;
+				}
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Core operations
+ */
+ 
+/* Forward declarations */
+
+static bool opc_jmp_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+static int opc_jmp_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+static int opc_jmptrue_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+static int opc_jmpfalse_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+/* Operation objects defined in this file */
+
+const struct sieve_operation sieve_jmp_operation = { 
+	"JMP",
+	NULL,
+	SIEVE_OPERATION_JMP,
+	opc_jmp_dump, 
+	opc_jmp_execute 
+};
+
+const struct sieve_operation sieve_jmptrue_operation = { 
+	"JMPTRUE",
+	NULL,
+	SIEVE_OPERATION_JMPTRUE,
+	opc_jmp_dump, 
+	opc_jmptrue_execute 
+};
+
+const struct sieve_operation sieve_jmpfalse_operation = { 
+	"JMPFALSE",
+	NULL,
+	SIEVE_OPERATION_JMPFALSE,
+	opc_jmp_dump, 
+	opc_jmpfalse_execute 
+};
+
+/* Operation objects defined in other files */
+	
+extern const struct sieve_operation cmd_stop_operation;
+extern const struct sieve_operation cmd_keep_operation;
+extern const struct sieve_operation cmd_discard_operation;
+extern const struct sieve_operation cmd_redirect_operation;
+
+extern const struct sieve_operation tst_address_operation;
+extern const struct sieve_operation tst_header_operation;
+extern const struct sieve_operation tst_exists_operation;
+extern const struct sieve_operation tst_size_over_operation;
+extern const struct sieve_operation tst_size_under_operation;
+
+const struct sieve_operation *sieve_operations[] = {
+	NULL, 
+	
+	&sieve_jmp_operation,
+	&sieve_jmptrue_operation, 
+	&sieve_jmpfalse_operation,
+	
+	&cmd_stop_operation,
+	&cmd_keep_operation,
+	&cmd_discard_operation,
+	&cmd_redirect_operation,
+
+	&tst_address_operation,
+	&tst_header_operation,
+	&tst_exists_operation,
+	&tst_size_over_operation,
+	&tst_size_under_operation
+}; 
+
+const unsigned int sieve_operation_count =
+	N_ELEMENTS(sieve_operations);
+
+/* 
+ * Operation functions 
+ */
+
+sieve_size_t sieve_operation_emit_code
+(struct sieve_binary *sbin, const struct sieve_operation *op)
+{
+	sieve_size_t address;
+
+    if ( op->extension != NULL ) {
+        address = sieve_binary_emit_extension
+            (sbin, op->extension, sieve_operation_count);
+
+        sieve_binary_emit_extension_object
+            (sbin, &op->extension->operations, op->code);
+
+        return address;
+    }
+
+    return  sieve_binary_emit_byte(sbin, op->code);
+}
+
+const struct sieve_operation *sieve_operation_read
+(struct sieve_binary *sbin, sieve_size_t *address) 
+{
+	const struct sieve_extension *ext;
+	unsigned int code = sieve_operation_count;
+
+	if ( !sieve_binary_read_extension(sbin, address, &code, &ext) )
+		return NULL;
+
+	if ( !ext )
+		return code < sieve_operation_count ? sieve_operations[code] : NULL;
+
+    return (const struct sieve_operation *) sieve_binary_read_extension_object
+        (sbin, address, &ext->operations);
+}
+
+/*
+ * Jump operations
+ */
+	
+/* Code dump */
+
+static bool opc_jmp_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	unsigned int pc = *address;
+	int offset;
+	
+	if ( sieve_binary_read_offset(denv->sbin, address, &offset) ) 
+		sieve_code_dumpf(denv, "%s %d [%08x]", 
+			op->mnemonic, offset, pc + offset);
+	else
+		return FALSE;
+	
+	return TRUE;
+}	
+			
+/* Code execution */
+
+static int opc_jmp_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED) 
+{
+	sieve_runtime_trace(renv, "JMP");
+	
+	return sieve_interpreter_program_jump(renv->interp, TRUE);
+}	
+		
+static int opc_jmptrue_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{	
+	bool result = sieve_interpreter_get_test_result(renv->interp);
+	
+	sieve_runtime_trace(renv, "JMPTRUE (%s)", result ? "true" : "false");
+	
+	return sieve_interpreter_program_jump(renv->interp, result);
+}
+
+static int opc_jmpfalse_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address ATTR_UNUSED)
+{	
+	bool result = sieve_interpreter_get_test_result(renv->interp);
+	
+	sieve_runtime_trace(renv, "JMPFALSE (%s)", result ? "true" : "false" );
+	
+	return sieve_interpreter_program_jump(renv->interp, !result);
+}	
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,292 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-comparators.h"
+
+#include "sieve-dump.h"
+
+/* 
+ * Code dumper extension
+ */
+
+struct sieve_code_dumper_extension_reg {
+	const struct sieve_code_dumper_extension *val_ext;
+	void *context;
+};
+
+struct sieve_code_dumper {
+	pool_t pool;
+					
+	/* Dump status */
+	sieve_size_t pc;          /* Program counter */
+	
+	const struct sieve_operation *operation;
+	sieve_size_t mark_address;
+	unsigned int indent;
+	
+	/* Dump environment */
+	struct sieve_dumptime_env *dumpenv; 
+	
+	ARRAY_DEFINE(extensions, struct sieve_code_dumper_extension_reg);
+};
+
+struct sieve_code_dumper *sieve_code_dumper_create
+	(struct sieve_dumptime_env *denv) 
+{
+	pool_t pool;
+	struct sieve_code_dumper *dumper;
+	
+	pool = pool_alloconly_create("sieve_code_dumper", 4096);	
+	dumper = p_new(pool, struct sieve_code_dumper, 1);
+	dumper->pool = pool;
+	dumper->dumpenv = denv;
+	dumper->pc = 0;
+	
+	/* Setup storage for extension contexts */		
+	p_array_init(&dumper->extensions, pool, sieve_extensions_get_count());
+
+	return dumper;
+}
+
+void sieve_code_dumper_free(struct sieve_code_dumper **dumper) 
+{
+	pool_unref(&((*dumper)->pool));
+	
+	*dumper = NULL;
+}
+
+pool_t sieve_code_dumper_pool(struct sieve_code_dumper *dumper)
+{
+	return dumper->pool;
+}
+
+/* EXtension support */
+
+void sieve_dump_extension_register
+(struct sieve_code_dumper *dumper, 
+	const struct sieve_code_dumper_extension *dump_ext, void *context)
+{
+	struct sieve_code_dumper_extension_reg reg = { dump_ext, context };
+	int ext_id = SIEVE_EXT_ID(dump_ext->ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&dumper->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void sieve_dump_extension_set_context
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext, 
+	void *context)
+{
+	struct sieve_code_dumper_extension_reg reg = { NULL, context };
+	int ext_id = SIEVE_EXT_ID(ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&dumper->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void *sieve_dump_extension_get_context
+(struct sieve_code_dumper *dumper, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_code_dumper_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&dumper->extensions) )
+		return NULL;
+	
+	reg = array_idx(&dumper->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/* Dump functions */
+
+void sieve_code_dumpf
+(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+{
+	struct sieve_code_dumper *cdumper = denv->cdumper;	
+	unsigned tab = cdumper->indent;
+	 
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_printfa(outbuf, "%08llx: ", (unsigned long long) cdumper->mark_address);
+	
+	while ( tab > 0 )	{
+		str_append(outbuf, "  ");
+		tab--;
+	}
+	
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(denv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_code_mark(const struct sieve_dumptime_env *denv)
+{
+	denv->cdumper->mark_address = denv->cdumper->pc;
+}
+
+void sieve_code_mark_specific
+(const struct sieve_dumptime_env *denv, sieve_size_t location)
+{
+	denv->cdumper->mark_address = location;
+}
+
+void sieve_code_descend(const struct sieve_dumptime_env *denv)
+{
+	denv->cdumper->indent++;
+}
+
+void sieve_code_ascend(const struct sieve_dumptime_env *denv)
+{
+	if ( denv->cdumper->indent > 0 )
+		denv->cdumper->indent--;
+}
+
+/* Operations and operands */
+
+bool sieve_code_dumper_print_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = -1;
+	
+	if ( sieve_operand_optional_present(denv->sbin, address) ) {
+		
+		while ( opt_code != 0 ) {			
+			if ( !sieve_operand_optional_read(denv->sbin, address, &opt_code) ) {
+				return FALSE;
+			}
+
+			if ( opt_code == SIEVE_OPT_SIDE_EFFECT ) {
+				if ( !sieve_opr_side_effect_dump(denv, address) )
+					return FALSE;
+			}
+		}
+	} 
+	return TRUE;
+}
+ 
+/* Code Dump */
+
+static bool sieve_code_dumper_print_operation
+	(struct sieve_code_dumper *dumper) 
+{	
+	const struct sieve_operation *op;
+	struct sieve_dumptime_env *denv = dumper->dumpenv;
+	sieve_size_t address;
+	
+	/* Mark start address of operation */
+	dumper->indent = 0;
+	address = dumper->mark_address = dumper->pc;
+
+	/* Read operation */
+	dumper->operation = op = 
+		sieve_operation_read(denv->sbin, &(dumper->pc));
+
+	/* Try to dump it */
+	if ( op != NULL ) {
+		if ( op->dump != NULL )
+			return op->dump(op, denv, &(dumper->pc));
+		else if ( op->mnemonic != NULL )
+			sieve_code_dumpf(denv, "%s", op->mnemonic);
+		else
+			return FALSE;
+			
+		return TRUE;
+	}		
+	
+	sieve_code_dumpf(denv, "Failed to read opcode.");
+	return FALSE;
+}
+
+void sieve_code_dumper_run(struct sieve_code_dumper *dumper) 
+{
+	const struct sieve_dumptime_env *denv = dumper->dumpenv;
+	struct sieve_binary *sbin = denv->sbin;
+	unsigned int ext_count;
+	bool success = TRUE;
+
+	dumper->pc = 0;
+	
+	/* Load and dump extensions listed in code */
+	sieve_code_mark(denv);
+	
+	if ( sieve_binary_read_unsigned(sbin, &dumper->pc, &ext_count) ) {
+		unsigned int i;
+		
+		sieve_code_dumpf(denv, "EXTENSIONS [%d]:", ext_count);
+		sieve_code_descend(denv);
+		
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int code = 0;
+			const struct sieve_extension *ext;
+			
+			T_BEGIN {
+				sieve_code_mark(denv);
+			
+				if ( !sieve_binary_read_extension(sbin, &dumper->pc, &code, &ext) ) {
+					success = FALSE;
+					break;
+				}
+      	
+				sieve_code_dumpf(denv, "%s", ext->name);
+      
+				if ( ext->code_dump != NULL ) {
+					sieve_code_descend(denv);
+					if ( !ext->code_dump(denv, &dumper->pc) ) {
+						success = FALSE;
+						break;
+					}
+					sieve_code_ascend(denv);
+				}
+			} T_END;
+		}
+		
+		sieve_code_ascend(denv);
+	}	else
+		success = FALSE;
+		
+	if ( !success ) {
+		sieve_code_dumpf(denv, "Binary code header is corrupt.");
+		return;
+	}
+	
+	while ( dumper->pc < 
+		sieve_binary_get_code_size(sbin) ) {
+
+		T_BEGIN {
+			success = sieve_code_dumper_print_operation(dumper);
+		} T_END;
+
+		if ( !success ) {
+			sieve_code_dumpf(dumper->dumpenv, "Binary is corrupt.");
+			return;
+		}
+	}
+	
+	/* Mark end of the binary */
+	dumper->indent = 0;
+	dumper->mark_address = sieve_binary_get_code_size(sbin);
+	sieve_code_dumpf(dumper->dumpenv, "[End of code]");	
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code-dumper.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,58 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_CODE_DUMPER_H
+#define __SIEVE_CODE_DUMPER_H
+
+#include "sieve-common.h"
+
+struct sieve_code_dumper;
+
+struct sieve_code_dumper *sieve_code_dumper_create
+	(struct sieve_dumptime_env *denv);
+void sieve_code_dumper_free
+	(struct sieve_code_dumper **dumper);
+pool_t sieve_code_dumper_pool
+	(struct sieve_code_dumper *dumper);
+	
+/* 
+ * Extension support
+ */
+
+struct sieve_code_dumper_extension {
+	const struct sieve_extension *ext;	
+
+	void (*free)(struct sieve_code_dumper *dumper, void *context);
+};
+
+void sieve_dump_extension_register
+(struct sieve_code_dumper *dumper, 
+	const struct sieve_code_dumper_extension *dump_ext, void *context);
+void sieve_dump_extension_set_context
+	(struct sieve_code_dumper *dumper, const struct sieve_extension *ext, 
+		void *context);
+void *sieve_dump_extension_get_context
+	(struct sieve_code_dumper *dumper, const struct sieve_extension *ext); 
+	
+/* Dump functions */	
+	
+void sieve_code_dumpf
+	(const struct sieve_dumptime_env *denv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+void sieve_code_mark(const struct sieve_dumptime_env *denv);
+void sieve_code_mark_specific
+	(const struct sieve_dumptime_env *denv, sieve_size_t location);
+void sieve_code_descend(const struct sieve_dumptime_env *denv);
+void sieve_code_ascend(const struct sieve_dumptime_env *denv);
+
+/* Operations and operands */
+	
+bool sieve_code_dumper_print_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+/* Code dump (debugging purposes) */
+
+void sieve_code_dumper_run(struct sieve_code_dumper *dumper);
+
+#endif /* __SIEVE_CODE_DUMPER_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-code.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-code.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,294 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_CODE_H
+#define __SIEVE_CODE_H
+
+#include "lib.h"
+#include "buffer.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+
+/* 
+ * Coded string list 
+ */
+
+struct sieve_coded_stringlist;
+
+bool sieve_coded_stringlist_next_item
+	(struct sieve_coded_stringlist *strlist, string_t **str_r);
+void sieve_coded_stringlist_reset
+	(struct sieve_coded_stringlist *strlist);
+bool sieve_coded_stringlist_read_all
+	(struct sieve_coded_stringlist *strlist, pool_t pool,
+		const char * const **list_r);
+
+unsigned int sieve_coded_stringlist_get_length
+	(struct sieve_coded_stringlist *strlist);
+sieve_size_t sieve_coded_stringlist_get_end_address
+	(struct sieve_coded_stringlist *strlist);
+sieve_size_t sieve_coded_stringlist_get_current_offset
+	(struct sieve_coded_stringlist *strlist);
+
+/* 
+ * Source line coding
+ */
+
+void sieve_code_source_line_emit
+	(struct sieve_binary *sbin, unsigned int source_line);
+bool sieve_code_source_line_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+bool sieve_code_source_line_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+    	unsigned int *source_line_r);
+
+/* 
+ * Operand object
+ */
+
+struct sieve_operand_class {
+	const char *name;
+};
+
+struct sieve_operand {
+	const char *name;
+	
+	const struct sieve_extension *extension;
+	unsigned int code;
+	
+	const struct sieve_operand_class *class;
+	const void *interface;
+};
+
+sieve_size_t sieve_operand_emit_code
+	(struct sieve_binary *sbin, const struct sieve_operand *opr);
+const struct sieve_operand *sieve_operand_read
+	(struct sieve_binary *sbin, sieve_size_t *address);
+
+bool sieve_operand_optional_present
+	(struct sieve_binary *sbin, sieve_size_t *address);
+bool sieve_operand_optional_read	
+	(struct sieve_binary *sbin, sieve_size_t *address, int *id_code);
+
+/*
+ * Core operands
+ */
+ 
+/* Operand codes */
+
+enum sieve_core_operand {
+	SIEVE_OPERAND_OPTIONAL,
+	SIEVE_OPERAND_NUMBER,
+	SIEVE_OPERAND_STRING,
+	SIEVE_OPERAND_STRING_LIST,
+	SIEVE_OPERAND_COMPARATOR,
+	SIEVE_OPERAND_MATCH_TYPE,
+	SIEVE_OPERAND_ADDRESS_PART,
+	SIEVE_OPERAND_CATENATED_STRING,
+
+	SIEVE_OPERAND_CUSTOM
+};
+
+/* Operand classes */
+
+extern const struct sieve_operand_class number_class;
+extern const struct sieve_operand_class string_class;
+extern const struct sieve_operand_class stringlist_class;
+
+/* Operand objects */
+
+extern const struct sieve_operand omitted_operand;
+extern const struct sieve_operand number_operand;
+extern const struct sieve_operand string_operand;
+extern const struct sieve_operand stringlist_operand;
+extern const struct sieve_operand catenated_string_operand;
+
+extern const struct sieve_operand *sieve_operands[];
+extern const unsigned int sieve_operand_count;
+
+/* Operand object interfaces */
+
+struct sieve_opr_number_interface {
+	bool (*dump)	
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	bool (*read)
+	  (const struct sieve_runtime_env *renv, sieve_size_t *address, 
+	  	sieve_number_t *number_r);
+};
+
+struct sieve_opr_string_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	bool (*read)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+			string_t **str_r);
+};
+
+struct sieve_opr_stringlist_interface {
+	bool (*dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+			const char *field_name);
+	struct sieve_coded_stringlist *(*read)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address);
+};
+
+/* 
+ * Core operand functions 
+ */
+
+/* Omitted */
+
+void sieve_opr_omitted_emit(struct sieve_binary *sbin);
+
+static inline bool sieve_operand_is_omitted
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand == &omitted_operand );
+}
+
+/* Number */
+
+void sieve_opr_number_emit(struct sieve_binary *sbin, sieve_number_t number);
+bool sieve_opr_number_dump_data	
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name); 
+bool sieve_opr_number_dump	
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name); 
+bool sieve_opr_number_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, sieve_number_t *number_r);
+bool sieve_opr_number_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, 
+		sieve_number_t *number_r);
+
+static inline bool sieve_operand_is_number
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->class == &number_class );
+}
+
+/* String */
+
+void sieve_opr_string_emit(struct sieve_binary *sbin, string_t *str);
+bool sieve_opr_string_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand,
+		sieve_size_t *address, const char *field_name); 
+bool sieve_opr_string_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name); 
+bool sieve_opr_string_dump_ex
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address, 
+		const char *field_name, bool *literal_r); 
+bool sieve_opr_string_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand,
+		sieve_size_t *address, string_t **str_r);
+bool sieve_opr_string_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r);
+bool sieve_opr_string_read_ex
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, string_t **str_r,
+		bool *literal_r);
+
+static inline bool sieve_operand_is_string
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && operand->class == &string_class );
+}
+
+/* String list */
+
+void sieve_opr_stringlist_emit_start
+	(struct sieve_binary *sbin, unsigned int listlen, void **context);
+void sieve_opr_stringlist_emit_item
+	(struct sieve_binary *sbin, void *context ATTR_UNUSED, string_t *item);
+void sieve_opr_stringlist_emit_end
+	(struct sieve_binary *sbin, void *context);
+bool sieve_opr_stringlist_dump_data
+	(const struct sieve_dumptime_env *denv, const struct sieve_operand *operand, 
+		sieve_size_t *address, const char *field_name);
+bool sieve_opr_stringlist_dump
+	(const struct sieve_dumptime_env *denv, sieve_size_t *address,
+		const char *field_name);
+struct sieve_coded_stringlist *sieve_opr_stringlist_read_data
+	(const struct sieve_runtime_env *renv, const struct sieve_operand *operand, 
+		sieve_size_t op_address, sieve_size_t *address);
+struct sieve_coded_stringlist *sieve_opr_stringlist_read
+	(const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+static inline bool sieve_operand_is_stringlist
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && 
+		(operand->class == &stringlist_class || operand->class == &string_class) );
+}
+
+/* Catenated string */
+
+void sieve_opr_catenated_string_emit
+	(struct sieve_binary *sbin, unsigned int elements);
+	
+/*
+ * Operation object
+ */
+ 
+struct sieve_operation {
+	const char *mnemonic;
+	
+	const struct sieve_extension *extension;
+	unsigned int code;
+	
+	bool (*dump)
+		(const struct sieve_operation *op, 
+			const struct sieve_dumptime_env *denv, sieve_size_t *address);
+	int (*execute)
+		(const struct sieve_operation *op, 
+			const struct sieve_runtime_env *renv, sieve_size_t *address);
+};
+
+sieve_size_t sieve_operation_emit_code
+	(struct sieve_binary *sbin, const struct sieve_operation *op);	
+const struct sieve_operation *sieve_operation_read
+	(struct sieve_binary *sbin, sieve_size_t *address);
+const char *sieve_operation_read_string
+    (struct sieve_binary *sbin, sieve_size_t *address);
+
+/* 
+ * Core operations 
+ */
+
+/* Opcodes */
+
+enum sieve_operation_code {
+	SIEVE_OPERATION_INVALID,
+	SIEVE_OPERATION_JMP,
+	SIEVE_OPERATION_JMPTRUE,
+	SIEVE_OPERATION_JMPFALSE,
+	
+	SIEVE_OPERATION_STOP,
+	SIEVE_OPERATION_KEEP,
+	SIEVE_OPERATION_DISCARD,
+	SIEVE_OPERATION_REDIRECT,
+	
+	SIEVE_OPERATION_ADDRESS,
+	SIEVE_OPERATION_HEADER, 
+	SIEVE_OPERATION_EXISTS, 
+	SIEVE_OPERATION_SIZE_OVER,
+	SIEVE_OPERATION_SIZE_UNDER,
+	
+	SIEVE_OPERATION_CUSTOM
+};
+
+/* Operation objects */
+
+extern const struct sieve_operation sieve_jmp_operation;
+extern const struct sieve_operation sieve_jmptrue_operation;
+extern const struct sieve_operation sieve_jmpfalse_operation; 
+
+extern const struct sieve_operation *sieve_operations[];
+extern const unsigned int sieve_operations_count;
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-commands.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-commands.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-commands.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-commands.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,371 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "rfc2822.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-interpreter.h"
+
+/* 
+ * Literal arguments
+ */
+
+/* Forward declarations */
+
+static bool arg_number_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+static bool arg_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+static bool arg_string_list_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *context);
+static bool arg_string_list_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+/* Argument objects */
+
+const struct sieve_argument number_argument = { 
+	"@number", 
+	NULL, NULL, NULL, NULL,
+	arg_number_generate 
+};
+
+const struct sieve_argument string_argument = { 
+	"@string", 
+	NULL, NULL, NULL, NULL,
+	arg_string_generate 
+};
+
+const struct sieve_argument string_list_argument = { 
+	"@string-list", 
+	NULL, NULL,
+	arg_string_list_validate, 
+	NULL, 
+	arg_string_list_generate 
+};	
+
+/* Argument implementations */
+
+static bool arg_number_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	sieve_opr_number_emit(cgenv->sbin, sieve_ast_argument_number(arg));
+
+	return TRUE;
+}
+
+static bool arg_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context ATTR_UNUSED)
+{
+	sieve_opr_string_emit(cgenv->sbin, sieve_ast_argument_str(arg));
+  
+	return TRUE;
+}
+
+static bool arg_string_list_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *context)
+{
+	struct sieve_ast_argument *stritem;
+
+	stritem = sieve_ast_strlist_first(*arg);	
+	while ( stritem != NULL ) {
+		if ( !sieve_validator_argument_activate(validator, context, stritem, FALSE) )
+			return FALSE;
+			
+		stritem = sieve_ast_strlist_next(stritem);
+	}
+
+	return TRUE;	
+}
+
+static bool emit_string_list_operand
+(const struct sieve_codegen_env *cgenv, const struct sieve_ast_argument *strlist,
+	struct sieve_command_context *context)
+{	
+	void *list_context;
+	struct sieve_ast_argument *stritem;
+   	
+	sieve_opr_stringlist_emit_start
+		(cgenv->sbin, sieve_ast_strlist_count(strlist), &list_context);
+
+	stritem = sieve_ast_strlist_first(strlist);
+	while ( stritem != NULL ) {
+		if ( !sieve_generate_argument(cgenv, stritem, context) )
+			return FALSE;
+			
+		stritem = sieve_ast_strlist_next(stritem);
+	}
+
+	sieve_opr_stringlist_emit_end(cgenv->sbin, list_context);
+	
+	return TRUE;
+}
+
+static bool arg_string_list_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *context)
+{
+	if ( sieve_ast_argument_type(arg) == SAAT_STRING ) {
+		return ( sieve_generate_argument(cgenv, arg, context) );
+
+	} else if ( sieve_ast_argument_type(arg) == SAAT_STRING_LIST ) {
+		bool result = TRUE;
+		
+		if ( sieve_ast_strlist_count(arg) == 1 ) 
+			return ( sieve_generate_argument
+				(cgenv, sieve_ast_strlist_first(arg), context) );
+		else {
+			T_BEGIN { 
+				result=emit_string_list_operand(cgenv, arg, context);
+			} T_END;
+		}
+
+		return result;
+	}
+	
+	return FALSE;
+}
+
+/*
+ * Abstract arguments 
+ *
+ *   (Generated by processing and not by parsing the grammar)
+ */
+ 
+/* Catenated string */
+
+struct sieve_arg_catenated_string {
+	struct sieve_ast_arg_list *str_parts;
+};
+ 
+struct sieve_arg_catenated_string *sieve_arg_catenated_string_create
+(struct sieve_ast_argument *orig_arg)
+{
+	pool_t pool = sieve_ast_pool(orig_arg->ast);
+	struct sieve_ast_arg_list *arglist;
+	struct sieve_arg_catenated_string *catstr;
+
+	arglist = sieve_ast_arg_list_create(pool);
+					
+	catstr = p_new(pool, struct sieve_arg_catenated_string, 1);
+	catstr->str_parts = arglist;
+	(orig_arg)->context = (void *) catstr;
+	
+	return catstr;
+}
+
+void sieve_arg_catenated_string_add_element
+(struct sieve_arg_catenated_string *catstr, 
+	struct sieve_ast_argument *element)
+{
+	sieve_ast_arg_list_add(catstr->str_parts, element);
+}
+
+#define _cat_string_first(catstr) __AST_LIST_FIRST((catstr)->str_parts)
+#define _cat_string_count(catstr) __AST_LIST_COUNT((catstr)->str_parts)
+#define _cat_string_next(item) __AST_LIST_NEXT(item)
+
+bool sieve_arg_catenated_string_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd) 
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_arg_catenated_string *catstr = 
+		(struct sieve_arg_catenated_string *) arg->context;
+	struct sieve_ast_argument *strpart;
+	
+	if ( _cat_string_count(catstr) == 1 )
+		sieve_generate_argument(cgenv, _cat_string_first(catstr), cmd);
+	else {
+		sieve_opr_catenated_string_emit(sbin, _cat_string_count(catstr));
+
+		strpart = _cat_string_first(catstr);
+		while ( strpart != NULL ) {
+			if ( !sieve_generate_argument(cgenv, strpart, cmd) )
+				return FALSE;
+			
+			strpart = _cat_string_next(strpart);
+		}
+	}
+	
+	return TRUE;
+}
+
+/* 
+ * Core tests and commands 
+ */
+
+const struct sieve_command *sieve_core_tests[] = {
+	&tst_false, &tst_true,
+	&tst_not, &tst_anyof, &tst_allof,
+	&tst_address, &tst_header, &tst_exists, &tst_size
+};
+
+const unsigned int sieve_core_tests_count = N_ELEMENTS(sieve_core_tests);
+
+const struct sieve_command *sieve_core_commands[] = {
+	&cmd_require, 
+	&cmd_stop, &cmd_if, &cmd_elsif, &cmd_else, 
+	&cmd_keep, &cmd_discard, &cmd_redirect
+};
+
+const unsigned int sieve_core_commands_count = N_ELEMENTS(sieve_core_commands);
+	
+/* 
+ * Command context 
+ */
+
+struct sieve_command_context *sieve_command_prev_context	
+	(struct sieve_command_context *context) 
+{
+	struct sieve_ast_node *node = sieve_ast_node_prev(context->ast_node);
+	
+	if ( node != NULL ) {
+		return node->context;
+	}
+	
+	return NULL;
+}
+
+struct sieve_command_context *sieve_command_parent_context	
+	(struct sieve_command_context *context) 
+{
+	struct sieve_ast_node *node = sieve_ast_node_parent(context->ast_node);
+	
+	if ( node != NULL ) {
+		return node->context;
+	}
+	
+	return NULL;
+}
+
+struct sieve_command_context *sieve_command_context_create
+	(struct sieve_ast_node *cmd_node, const struct sieve_command *command,
+		struct sieve_command_registration *reg)
+{
+	struct sieve_command_context *cmd;
+	
+	cmd = p_new(sieve_ast_node_pool(cmd_node), struct sieve_command_context, 1);
+	
+	cmd->ast_node = cmd_node;	
+	cmd->command = command;
+	cmd->cmd_reg = reg;
+	
+	cmd->block_exit_command = NULL;
+	
+	return cmd;
+}
+
+const char *sieve_command_type_name(const struct sieve_command *command) {
+	switch ( command->type ) {
+	case SCT_NONE: return "command of unspecified type (bug)";
+	case SCT_TEST: return "test";
+	case SCT_COMMAND: return "command";
+	default:
+		break;
+	}
+	return "??COMMAND-TYPE??";
+}
+
+struct sieve_ast_argument *sieve_command_add_dynamic_tag
+(struct sieve_command_context *cmd, const struct sieve_argument *tag, 
+	int id_code)
+{
+	struct sieve_ast_argument *arg;
+	
+	if ( cmd->first_positional != NULL )
+		arg = sieve_ast_argument_tag_insert
+			(cmd->first_positional, tag->identifier, cmd->ast_node->source_line);
+	else
+		arg = sieve_ast_argument_tag_create
+			(cmd->ast_node, tag->identifier, cmd->ast_node->source_line);
+	
+	arg->argument = tag;
+	arg->arg_id_code = id_code;
+	
+	return arg;
+}
+
+struct sieve_ast_argument *sieve_command_find_argument
+(struct sieve_command_context *cmd, const struct sieve_argument *argument)
+{
+	struct sieve_ast_argument *arg = sieve_ast_argument_first(cmd->ast_node);
+		
+	/* Visit tagged and optional arguments */
+	while ( arg != NULL ) {
+		if ( arg->argument == argument ) 
+			return arg;
+			
+		arg = sieve_ast_argument_next(arg);
+	}
+	
+	return arg;
+}
+
+/* Use this function with caution. The command commits to exiting the block.
+ * When it for some reason does not, the interpretation will break later on, 
+ * because exiting jumps are not generated when they would otherwise be 
+ * necessary.
+ */
+void sieve_command_exit_block_unconditionally
+	(struct sieve_command_context *cmd)
+{
+	struct sieve_command_context *parent = sieve_command_parent_context(cmd);
+
+	/* Only the first unconditional exit is of importance */
+	if ( parent != NULL && parent->block_exit_command == NULL ) 
+		parent->block_exit_command = cmd;
+}
+
+bool sieve_command_block_exits_unconditionally
+	(struct sieve_command_context *cmd)
+{
+	return ( cmd->block_exit_command != NULL );
+}
+
+/*
+ * Command utility functions
+ */
+
+/* NOTE: this may be moved */
+
+static int _verify_header_name_item
+(void *context, struct sieve_ast_argument *header)
+{
+	struct sieve_validator *valdtr = (struct sieve_validator *) context;
+	string_t *name = sieve_ast_argument_str(header);
+
+	if ( sieve_argument_is_string_literal(header) &&
+		!rfc2822_header_field_name_verify(str_c(name), str_len(name)) ) {
+		sieve_argument_validate_warning
+			(valdtr, header, "specified header field name '%s' is invalid",
+				str_sanitize(str_c(name), 80));
+
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+bool sieve_command_verify_headers_argument
+(struct sieve_validator *valdtr, struct sieve_ast_argument *headers)
+{	
+	return ( sieve_ast_stringlist_map
+		(&headers, (void *) valdtr, _verify_header_name_item) >= 0 );
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-commands.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-commands.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-commands.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-commands.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,221 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMANDS_H
+#define __SIEVE_COMMANDS_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-ast.h"
+
+/* 
+ * Argument object
+ */
+
+struct sieve_argument {
+	const char *identifier;
+	
+	bool (*is_instance_of)
+		(struct sieve_validator *validator, struct sieve_command_context *cmdctx,
+			struct sieve_ast_argument *arg);
+	
+	bool (*validate_persistent) // FIXME: this method must be moved down
+		(struct sieve_validator *validator, struct sieve_command_context *cmdctx);
+	bool (*validate)
+		(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+			struct sieve_command_context *context);
+	bool (*validate_context)
+		(struct sieve_validator *validator, struct sieve_ast_argument *arg, 
+			struct sieve_command_context *context);
+		
+	bool (*generate)
+		(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+			struct sieve_command_context *context);
+};
+
+/* Utility macros */
+
+#define sieve_argument_is_string_literal(arg) \
+	( (arg)->argument == &string_argument )
+
+/* Error handling */
+
+#define sieve_argument_validate_error(validator, arg_node, ...) \
+	sieve_validator_error(validator, (arg_node)->source_line, __VA_ARGS__)
+#define sieve_argument_validate_warning(validator, arg_node, ...) \
+	sieve_validator_warning(validator, (arg_node)->source_line, __VA_ARGS__)
+
+/* Literal arguments */
+
+extern const struct sieve_argument number_argument;
+extern const struct sieve_argument string_argument;
+extern const struct sieve_argument string_list_argument;
+
+/* Catenated string argument */
+
+bool sieve_arg_catenated_string_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *context);
+
+struct sieve_arg_catenated_string;		
+
+struct sieve_arg_catenated_string *sieve_arg_catenated_string_create
+	(struct sieve_ast_argument *orig_arg);
+void sieve_arg_catenated_string_add_element
+	(struct sieve_arg_catenated_string *strdata, 
+		struct sieve_ast_argument *element);
+
+/* 
+ * Command object
+ */
+
+enum sieve_command_type {
+	SCT_NONE,
+	SCT_COMMAND,
+	SCT_TEST,
+	SCT_HYBRID
+};
+
+struct sieve_command {
+	const char *identifier;
+	enum sieve_command_type type;
+	
+	/* High-level command syntax */
+	int positional_arguments;
+	int subtests;
+	bool block_allowed;
+	bool block_required;
+	
+	bool (*registered)
+		(struct sieve_validator *validator, 
+			struct sieve_command_registration *cmd_reg); 
+	bool (*pre_validate)
+		(struct sieve_validator *validator, struct sieve_command_context *context); 
+	bool (*validate)
+		(struct sieve_validator *validator, struct sieve_command_context *context); 
+	bool (*generate) 
+		(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+	bool (*control_generate) 
+		(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+};
+
+/*
+ * Command context
+ */
+
+struct sieve_command_context {
+	const struct sieve_command *command;
+	
+	/* The registration of this command in the validator (sieve-validator.h) */
+	struct sieve_command_registration *cmd_reg;
+
+	/* The ast node of this command */
+	struct sieve_ast_node *ast_node;
+			
+	/* First positional argument, found during argument validation */
+	struct sieve_ast_argument *first_positional;
+
+	/* The child ast node that unconditionally exits this command's block */
+	struct sieve_command_context *block_exit_command;
+
+	/* Command-specific context data*/
+	void *data;
+};
+
+/* Context API */
+
+struct sieve_command_context *sieve_command_context_create
+	(struct sieve_ast_node *cmd_node, const struct sieve_command *command,
+		struct sieve_command_registration *reg);
+		
+const char *sieve_command_type_name(const struct sieve_command *command);		
+
+struct sieve_command_context *sieve_command_prev_context	
+	(struct sieve_command_context *context); 
+struct sieve_command_context *sieve_command_parent_context	
+	(struct sieve_command_context *context);
+	
+struct sieve_ast_argument *sieve_command_add_dynamic_tag
+	(struct sieve_command_context *cmd, const struct sieve_argument *tag,
+		int id_code);
+struct sieve_ast_argument *sieve_command_find_argument
+	(struct sieve_command_context *cmd, const struct sieve_argument *argument);	
+	
+void sieve_command_exit_block_unconditionally
+	(struct sieve_command_context *cmd);
+bool sieve_command_block_exits_unconditionally
+	(struct sieve_command_context *cmd);
+	
+/* Error handling */
+		
+#define sieve_command_validate_error(validator, context, ...) \
+	sieve_validator_error(validator, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_validate_warning(validator, context, ...) \
+	sieve_validator_warning(validator, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_validate_critical(validator, context, ...) \
+	sieve_validator_critical(validator, (context)->ast_node->source_line, __VA_ARGS__)
+
+#define sieve_command_generate_error(gentr, context, ...) \
+	sieve_generator_error(gentr, (context)->ast_node->source_line, __VA_ARGS__)
+#define sieve_command_generate_critical(gentr, context, ...) \
+	sieve_generator_critical(gentr, (context)->ast_node->source_line, __VA_ARGS__)
+
+/* Utility macros */
+
+#define sieve_command_pool(context) \
+	sieve_ast_node_pool((context)->ast_node)
+
+#define sieve_command_source_line(context) \
+	(context)->ast_node->source_line
+
+#define sieve_command_first_argument(context) \
+	sieve_ast_argument_first((context)->ast_node)
+	
+#define sieve_command_is_toplevel(context) \
+	( sieve_ast_node_type(sieve_ast_node_parent((context)->ast_node)) == SAT_ROOT )
+#define sieve_command_is_first(context) \
+	( sieve_ast_node_prev((context)->ast_node) == NULL )	
+
+/*
+ * Core commands
+ */
+ 
+extern const struct sieve_command cmd_require;
+extern const struct sieve_command cmd_stop;
+extern const struct sieve_command cmd_if;
+extern const struct sieve_command cmd_elsif;
+extern const struct sieve_command cmd_else;
+extern const struct sieve_command cmd_redirect;
+extern const struct sieve_command cmd_keep;
+extern const struct sieve_command cmd_discard;
+
+extern const struct sieve_command *sieve_core_commands[];
+extern const unsigned int sieve_core_commands_count;
+
+/* 
+ * Core tests 
+ */
+
+extern const struct sieve_command tst_true;
+extern const struct sieve_command tst_false;
+extern const struct sieve_command tst_not;
+extern const struct sieve_command tst_anyof;
+extern const struct sieve_command tst_allof;
+extern const struct sieve_command tst_address;
+extern const struct sieve_command tst_header;
+extern const struct sieve_command tst_exists;
+extern const struct sieve_command tst_size;
+
+extern const struct sieve_command *sieve_core_tests[];
+extern const unsigned int sieve_core_tests_count;
+
+/*
+ * Command utility functions
+ */
+
+bool sieve_command_verify_headers_argument
+(struct sieve_validator *valdtr, struct sieve_ast_argument *headers);
+
+#endif /* __SIEVE_COMMANDS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,124 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMON_H
+#define __SIEVE_COMMON_H
+
+#include "sieve-config.h"
+#include "sieve-types.h"
+
+#include <sys/types.h>
+#include <stdint.h>
+
+/* 
+ * Types
+ */
+
+typedef size_t        sieve_size_t; 
+typedef uint32_t      sieve_offset_t;
+typedef uint32_t      sieve_number_t;
+
+#define SIEVE_MAX_NUMBER ((sieve_number_t) -1)
+
+/*
+ * Forward declarations
+ */
+
+/* sieve-error.h */
+struct sieve_error_handler;
+
+/* sieve-ast.h */
+enum sieve_ast_argument_type;
+
+struct sieve_ast;
+struct sieve_ast_node;
+struct sieve_ast_argument;
+
+/* sieve-commands.h */
+struct sieve_argument;
+struct sieve_command;
+struct sieve_command_context;
+struct sieve_command_registration;
+
+/* sieve-code.h */
+struct sieve_operation_extension;
+
+/* sieve-lexer.h */
+struct sieve_lexer;
+
+/* sieve-parser.h */
+struct sieve_parser;
+
+/* sieve-validator.h */
+struct sieve_validator;
+
+/* sieve-generator.h */
+struct sieve_jumplist;
+struct sieve_generator;
+struct sieve_codegen_env;
+
+/* sieve-interpreter.h */
+struct sieve_runtime_env;
+struct sieve_interpreter;
+
+/* sieve-binary-dumper.h */
+struct sieve_dumptime_env;
+struct sieve_binary_dumper;
+
+/* sieve-code-dumper.h */
+struct sieve_code_dumper;
+
+/* sieve-extension.h */
+struct sieve_extension;
+struct sieve_extension_objects;
+
+/* sieve-code.h */
+struct sieve_operand;
+struct sieve_operand_class;
+struct sieve_operation;
+struct sieve_coded_stringlist;
+
+/* sieve-binary.h */
+struct sieve_binary;
+
+/* sieve-objects.h */
+struct sieve_object;
+
+/* sieve-comparator.h */
+struct sieve_comparator;
+
+/* sieve-match-types.h */
+struct sieve_match_type;
+
+/* sieve-match.h */
+struct sieve_match_context;
+
+/* sieve-address.h */
+struct sieve_address;
+
+/* sieve-address-parts.h */
+struct sieve_address_part;
+
+/* sieve-result.h */
+struct sieve_result;
+struct sieve_side_effects_list;
+struct sieve_result_print_env;
+
+/* sieve-actions.h */
+struct sieve_action_exec_env;
+struct sieve_action;
+struct sieve_side_effect;
+
+/* sieve-script.h */
+struct sieve_script;
+
+/* sieve-message.h */
+struct sieve_message_context;
+
+/* sieve.c */
+struct sieve_ast *sieve_parse
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+bool sieve_validate
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);	
+
+#endif /* __SIEVE_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-comparators.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-comparators.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-comparators.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-comparators.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,272 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-binary.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-comparators.h"
+
+#include <string.h>
+#include <stdio.h>
+
+/* 
+ * Core comparators
+ */
+ 
+const struct sieve_comparator *sieve_core_comparators[] = {
+	&i_octet_comparator, &i_ascii_casemap_comparator
+};
+
+const unsigned int sieve_core_comparators_count =
+	N_ELEMENTS(sieve_core_comparators);
+
+/*
+ * Forward declarations
+ */
+ 
+static void sieve_opr_comparator_emit
+	(struct sieve_binary *sbin, const struct sieve_comparator *cmp);
+
+/* 
+ * Comparator 'extension' 
+ */
+
+static int ext_my_id = -1;
+
+static bool cmp_validator_load(struct sieve_validator *validator);
+
+const struct sieve_extension comparator_extension = {
+	"@comparators",
+	&ext_my_id,
+	NULL, NULL,
+	cmp_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS    /* Defined as core operand */
+};
+
+static const struct sieve_extension *ext_this = &comparator_extension;
+	
+/* 
+ * Validator context:
+ *   name-based comparator registry. 
+ */
+ 
+void sieve_comparator_register
+(struct sieve_validator *validator, const struct sieve_comparator *cmp) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	
+	sieve_validator_object_registry_add(regs, &cmp->object);
+}
+
+const struct sieve_comparator *sieve_comparator_find
+(struct sieve_validator *validator, const char *identifier) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(regs, identifier);
+
+  return (const struct sieve_comparator *) object;
+}
+
+bool cmp_validator_load(struct sieve_validator *validator)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_init(validator, ext_this);
+	unsigned int i;
+		
+	/* Register core comparators */
+	for ( i = 0; i < sieve_core_comparators_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, &(sieve_core_comparators[i]->object));
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Comparator tagged argument 
+ */
+ 
+/* Context data */
+
+struct sieve_comparator_context {
+	struct sieve_command_context *command_ctx;
+	const struct sieve_comparator *comparator;
+};
+ 
+/* Forward declarations */
+
+static bool tag_comparator_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd);
+static bool tag_comparator_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd);
+
+/* Argument object */
+
+const struct sieve_argument comparator_tag = { 
+	"comparator", 
+	NULL, NULL,
+	tag_comparator_validate, 
+	NULL,
+	tag_comparator_generate 
+};
+
+/* Argument implementation */
+
+static bool tag_comparator_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd)
+{
+	struct sieve_comparator_context *cmpctx;
+	struct sieve_ast_argument *tag = *arg;
+	const struct sieve_comparator *cmp;
+	
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	/* Check syntax:
+	 *   ":comparator" <comparator-name: string>
+	 */
+	if ( (*arg)->type != SAAT_STRING ) {
+		sieve_argument_validate_error(validator, *arg, 
+			":comparator tag requires one string argument, but %s was found", 
+			sieve_ast_argument_name(*arg) );
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(validator, cmd, *arg, FALSE) )
+		return FALSE;
+
+	/* FIXME: We can currently only handle string literal argument, so
+	 * variables are not allowed.
+	 */
+	if ( !sieve_argument_is_string_literal(*arg) ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"this Sieve implementation currently only supports "
+			"a literal string argument for the :comparator tag");
+		return FALSE;
+	}
+	
+	/* Get comparator from registry */
+	cmp = sieve_comparator_find(validator, sieve_ast_argument_strc(*arg));
+	
+	if ( cmp == NULL ) {
+		sieve_argument_validate_error(validator, *arg, 
+			"unknown comparator '%s'", 
+			str_sanitize(sieve_ast_argument_strc(*arg),80));
+
+		return FALSE;
+	}
+	
+	/* String argument not needed during code generation, so detach it from 
+	 * argument list 
+	 */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+
+	/* Create context */
+	cmpctx = p_new(sieve_command_pool(cmd), struct sieve_comparator_context, 1);
+	cmpctx->command_ctx = cmd;
+	cmpctx->comparator = cmp;
+
+	/* Store comparator in context */
+	tag->context = (void *) cmpctx;
+	
+	return TRUE;
+}
+
+static bool tag_comparator_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_comparator_context *cmpctx = 
+		(struct sieve_comparator_context *) arg->context;
+	const struct sieve_comparator *cmp = cmpctx->comparator;
+	
+	sieve_opr_comparator_emit(cgenv->sbin, cmp);
+		
+	return TRUE;
+}
+
+/* Functions to enable and evaluate comparator tag for commands */
+
+void sieve_comparators_link_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg,	
+	int id_code) 
+{
+	sieve_validator_register_tag(validator, cmd_reg, &comparator_tag, id_code); 	
+}
+
+bool sieve_comparator_tag_is
+(struct sieve_ast_argument *tag, const struct sieve_comparator *cmp)
+{
+	const struct sieve_comparator_context *cmpctx = 
+		(const struct sieve_comparator_context *) tag->context;
+
+	if ( cmpctx == NULL ) return FALSE;
+	
+	return ( tag->argument == &comparator_tag && cmpctx->comparator == cmp );
+}
+
+const struct sieve_comparator *sieve_comparator_tag_get
+(struct sieve_ast_argument *tag)
+{
+	const struct sieve_comparator_context *cmpctx;
+	
+	if ( tag->argument != &comparator_tag ) 
+		return NULL;
+		
+	cmpctx = (const struct sieve_comparator_context *) tag->context;
+		 
+	return cmpctx->comparator;
+}
+
+/*
+ * Comparator coding
+ */
+ 
+const struct sieve_operand_class sieve_comparator_operand_class = 
+	{ "comparator" };
+	
+static const struct sieve_extension_objects core_comparators =
+	SIEVE_EXT_DEFINE_COMPARATORS(sieve_core_comparators);
+
+const struct sieve_operand comparator_operand = { 
+	"comparator", 
+	NULL,
+	SIEVE_OPERAND_COMPARATOR, 
+	&sieve_comparator_operand_class,
+	&core_comparators
+};
+
+/*
+ * Trivial/Common comparator method implementations
+ */
+
+bool sieve_comparator_octet_skip
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end)
+{
+	if ( *val < val_end ) {
+		(*val)++;
+		return TRUE;
+	}
+	
+	return FALSE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-comparators.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-comparators.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-comparators.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-comparators.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,124 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_COMPARATORS_H
+#define __SIEVE_COMPARATORS_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-objects.h"
+#include "sieve-code.h"
+
+/* 
+ * Core comparators 
+ */
+ 
+enum sieve_comparator_code {
+	SIEVE_COMPARATOR_I_OCTET,
+	SIEVE_COMPARATOR_I_ASCII_CASEMAP,
+	SIEVE_COMPARATOR_CUSTOM
+};
+
+extern const struct sieve_comparator i_octet_comparator;
+extern const struct sieve_comparator i_ascii_casemap_comparator;
+
+/*
+ * Comparator flags
+ */
+
+enum sieve_comparator_flags {
+	SIEVE_COMPARATOR_FLAG_ORDERING = (1 << 0),
+	SIEVE_COMPARATOR_FLAG_EQUALITY = (1 << 1),
+	SIEVE_COMPARATOR_FLAG_PREFIX_MATCH = (1 << 2),
+	SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH = (1 << 3),	
+};
+
+/*
+ * Comparator object
+ */
+
+struct sieve_comparator {
+	struct sieve_object object;	
+		
+	unsigned int flags;
+	
+	/* Equality and ordering */
+
+	int (*compare)(const struct sieve_comparator *cmp, 
+		const char *val1, size_t val1_size, 
+		const char *val2, size_t val2_size);
+	
+	/* Prefix and substring match */
+	
+	bool (*char_match)(const struct sieve_comparator *cmp, 
+		const char **val, const char *val_end,
+		const char **key, const char *key_end);
+	bool (*char_skip)(const struct sieve_comparator *cmp, 
+		const char **val, const char *val_end);
+};
+
+/*
+ * Comparator tagged argument
+ */
+ 
+extern const struct sieve_argument comparator_tag;
+
+static inline bool sieve_argument_is_comparator
+	(struct sieve_ast_argument *arg) 
+{
+	return arg->argument == &comparator_tag;
+}
+
+void sieve_comparators_link_tag
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg,	int id_code);
+bool sieve_comparator_tag_is
+	(struct sieve_ast_argument *tag, const struct sieve_comparator *cmp);
+const struct sieve_comparator *sieve_comparator_tag_get
+	(struct sieve_ast_argument *tag);
+
+void sieve_comparator_register
+	(struct sieve_validator *validator, const struct sieve_comparator *cmp); 
+const struct sieve_comparator *sieve_comparator_find
+	(struct sieve_validator *validator, const char *identifier);
+		
+/*
+ * Comparator operand
+ */
+
+#define SIEVE_EXT_DEFINE_COMPARATOR(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_COMPARATORS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+extern const struct sieve_operand_class sieve_comparator_operand_class;
+extern const struct sieve_operand comparator_operand;
+
+static inline void sieve_opr_comparator_emit
+(struct sieve_binary *sbin, const struct sieve_comparator *cmp)
+{ 
+	sieve_opr_object_emit(sbin, &cmp->object);
+}
+
+static inline const struct sieve_comparator *sieve_opr_comparator_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_comparator *) sieve_opr_object_read
+		(renv, &sieve_comparator_operand_class, address);
+}
+
+static inline bool sieve_opr_comparator_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_comparator_operand_class, address, NULL);
+}
+	
+/*
+ * Trivial/Common comparator method implementations
+ */
+
+bool sieve_comparator_octet_skip
+	(const struct sieve_comparator *cmp ATTR_UNUSED, 
+		const char **val, const char *val_end);
+
+#endif /* __SIEVE_COMPARATORS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-config.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-config.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-config.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-config.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,11 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_CONFIG_H
+#define __SIEVE_CONFIG_H
+
+#include "dsieve-config.h"
+
+#define SIEVE_IMPLEMENTATION SIEVE_NAME " " SIEVE_VERSION
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-dump.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-dump.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-dump.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-dump.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_DUMP_H
+#define __SIEVE_DUMP_H
+
+#include "sieve-common.h"
+
+#include "sieve-binary-dumper.h"
+#include "sieve-code-dumper.h"
+
+/*
+ * Dumptime environment
+ */
+
+struct sieve_dumptime_env {
+	struct sieve_binary_dumper *dumper;
+	struct sieve_code_dumper *cdumper;
+	struct sieve_binary *sbin;
+	
+	struct ostream *stream;
+};
+
+#endif /* __SIEVE_DUMP_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-error.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-error.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-error.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-error.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,687 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error-private.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Definitions
+ */
+
+#define CRITICAL_MSG \
+	"internal error occurred: refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+/* Logfile error handler will rotate log when it exceeds 10k bytes */
+#define LOGFILE_MAX_SIZE (10 * 1024)
+
+/*
+ * Utility
+ */
+
+const char *sieve_error_script_location
+(const struct sieve_script *script, unsigned int source_line)
+{
+    const char *sname = sieve_script_name(script);
+
+    if ( sname == NULL || *sname == '\0' )
+        return t_strdup_printf("line %d", source_line);
+
+    return t_strdup_printf("%s: line %d", sname, source_line);
+}
+
+/*
+ * Main error functions
+ */
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+	
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_error("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	if ( sieve_errors_more_allowed(ehandler) ) {
+		if ( ehandler->verror != NULL )
+			ehandler->verror(ehandler, location, fmt, args);
+		
+		if ( ehandler->pool != NULL )
+			ehandler->errors++;
+	}
+}
+
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_warning("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_warning("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	if ( ehandler->vwarning != NULL )	
+		ehandler->vwarning(ehandler, location, fmt, args);
+
+	if ( ehandler->pool != NULL )
+		ehandler->warnings++;
+}
+
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_info("%s", t_strdup_vprintf(fmt, args_copy));
+		else	
+			sieve_sys_info("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	if ( ehandler->log_info && ehandler->vinfo != NULL )	
+		ehandler->vinfo(ehandler, location, fmt, args);
+}
+
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	char str[256];
+	struct tm *tm; 
+	
+	tm = localtime(&ioloop_time);
+	
+	if ( location == NULL || *location == '\0' )
+		sieve_sys_error("%s", t_strdup_vprintf(fmt, args));
+	else
+		sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args));
+		
+	if ( ehandler == NULL ) return;
+	
+	sieve_error(ehandler, location, "%s", 
+		strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ? 
+			str : CRITICAL_MSG );	
+}
+
+/*
+ * Error statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler) 
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return 0;
+	
+	return ehandler->errors;
+}
+
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler) 
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return 0;
+
+	return ehandler->errors;
+}
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler) 
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) 
+		return TRUE;
+
+	return ehandler->max_errors == 0 || ehandler->errors < ehandler->max_errors;
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_info = enable;	
+}
+
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_master = enable;
+}
+
+/*
+ * Error handler init
+ */
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors)
+{
+	ehandler->pool = pool;
+	ehandler->refcount = 1;
+	ehandler->max_errors = max_errors;
+	
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return;
+
+	ehandler->refcount++;
+}
+
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler)
+{
+	if ( *ehandler == NULL || (*ehandler)->pool == NULL ) return;
+
+	i_assert((*ehandler)->refcount > 0);
+
+	if (--(*ehandler)->refcount != 0)
+        	return;
+
+	if ( (*ehandler)->free != NULL )
+		(*ehandler)->free(*ehandler);
+
+	pool_unref(&((*ehandler)->pool));
+
+	*ehandler = NULL;
+}
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL || ehandler->pool == NULL ) return;
+
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+/* 
+ * Master/System error handler
+ *
+ * - Output errors directly to Dovecot master log
+ */
+
+static void sieve_master_verror
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_error("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_error("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_master_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_warning("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_warning("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_master_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( ehandler->log_master ) return;
+
+	if ( location == NULL || *location == '\0' )
+		i_info("sieve: %s", t_strdup_vprintf(fmt, args));
+	else
+		i_info("sieve: %s: %s", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_master_ehandler_create
+(unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+	
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("master_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_master_verror;
+	ehandler->vwarning = sieve_master_vwarning;
+	ehandler->vinfo = sieve_master_vinfo;
+	
+	return ehandler;	
+}
+
+struct sieve_error_handler _sieve_system_ehandler_object = {
+	NULL, 0, 0, 0, 0,
+	FALSE,
+	TRUE,
+	sieve_master_verror,
+	sieve_master_vwarning,
+	sieve_master_vinfo,
+	NULL
+};
+
+struct sieve_error_handler *_sieve_system_ehandler = &_sieve_system_ehandler_object;
+
+void sieve_system_ehandler_set(struct sieve_error_handler *ehandler)
+{
+	sieve_error_handler_unref(&_sieve_system_ehandler);
+	_sieve_system_ehandler = ehandler;
+	sieve_error_handler_ref(_sieve_system_ehandler);
+}
+
+void sieve_system_ehandler_reset(void)
+{
+	sieve_error_handler_unref(&_sieve_system_ehandler);
+	_sieve_system_ehandler = &_sieve_system_ehandler_object;	
+}
+
+/* 
+ * STDERR error handler
+ *
+ * - Output errors directly to stderror 
+ */
+
+static void sieve_stderr_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "error: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: error: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "warning: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: warning: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "info: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: info: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_stderr_ehandler_create
+(unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+	
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("stderr_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_stderr_verror;
+	ehandler->vwarning = sieve_stderr_vwarning;
+	ehandler->vinfo = sieve_stderr_vinfo;
+	
+	return ehandler;	
+}
+
+/* String buffer error handler
+ *
+ * - Output errors to a string buffer 
+ */
+
+struct sieve_strbuf_ehandler {
+	struct sieve_error_handler handler;
+
+	string_t *errors;
+	bool crlf;
+};
+
+static void sieve_strbuf_verror
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_append(handler->errors, "error: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vwarning
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_printfa(handler->errors, "warning: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vinfo
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);	
+	str_printfa(handler->errors, "info: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+(string_t *strbuf, bool crlf, unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_strbuf_ehandler *ehandler;
+
+	pool = pool_alloconly_create("strbuf_error_handler", 256);
+	ehandler = p_new(pool, struct sieve_strbuf_ehandler, 1);
+	ehandler->errors = strbuf;
+    
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_strbuf_verror;
+	ehandler->handler.vwarning = sieve_strbuf_vwarning;
+	ehandler->handler.vinfo = sieve_strbuf_vinfo;
+
+	ehandler->crlf = crlf;
+
+	return &(ehandler->handler);
+}
+
+/* 
+ * Logfile error handler
+ * 
+ * - Output errors to a log file 
+ */
+
+struct sieve_logfile_ehandler {
+	struct sieve_error_handler handler;
+	
+	const char *logfile;
+	bool started;
+	int fd;
+	struct ostream *stream;
+};
+
+static void sieve_logfile_vprintf
+(struct sieve_logfile_ehandler *ehandler, const char *location, 
+	const char *prefix, const char *fmt, va_list args) 
+{
+	string_t *outbuf;
+	ssize_t ret = 0, remain;
+	const char *data;
+	
+	if ( ehandler->stream == NULL ) return;
+	
+	T_BEGIN {
+		outbuf = t_str_new(256);
+		if ( location != NULL && *location != '\0' )
+			str_printfa(outbuf, "%s: ", location);
+		str_printfa(outbuf, "%s: ", prefix);	
+		str_vprintfa(outbuf, fmt, args);
+		str_append(outbuf, ".\n");
+	
+		remain = str_len(outbuf);
+		data = (const char *) str_data(outbuf);
+
+		while ( remain > 0 ) { 
+			if ( (ret=o_stream_send(ehandler->stream, data, remain)) < 0 )
+				break;
+
+			remain -= ret;
+			data += ret;
+		}
+	} T_END;
+
+	if ( ret < 0 ) {
+		sieve_sys_error(
+			"o_stream_send() failed on logfile %s: %m", ehandler->logfile);		
+	}
+}
+
+inline static void sieve_logfile_printf
+(struct sieve_logfile_ehandler *ehandler, const char *location, const char *prefix,
+	const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	sieve_logfile_vprintf(ehandler, location, prefix, fmt, args);
+	
+	va_end(args);
+}
+
+static void sieve_logfile_start(struct sieve_logfile_ehandler *ehandler)
+{
+	int fd;
+	struct ostream *ostream = NULL;
+	struct stat st;
+	struct tm *tm;
+	char buf[256];
+	time_t now;
+
+	/* Open the logfile */
+
+	fd = open(ehandler->logfile, O_CREAT | O_APPEND | O_WRONLY, 0600);
+	if (fd == -1) {
+		sieve_sys_error("failed to open logfile %s (logging to STDERR): %m", 
+			ehandler->logfile);
+		fd = STDERR_FILENO;
+	} else {
+		/* fd_close_on_exec(fd, TRUE); Necessary? */
+
+		/* Stat the log file to obtain size information */
+		if ( fstat(fd, &st) != 0 ) {
+			sieve_sys_error(
+				"failed to fstat opened logfile %s (logging to STDERR): %m", 
+				ehandler->logfile);
+			
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("close(fd) failed for logfile '%s': %m",
+					ehandler->logfile);
+			}
+
+			fd = STDERR_FILENO;
+		}
+		
+		/* Rotate log when it has grown too large */
+		if ( st.st_size >= LOGFILE_MAX_SIZE ) {
+			const char *rotated;
+			
+			/* Close open file */
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("close(fd) failed for logfile '%s': %m",
+					ehandler->logfile);
+			}
+			
+			/* Rotate logfile */
+			rotated = t_strconcat(ehandler->logfile, ".0", NULL);
+			if ( rename(ehandler->logfile, rotated) < 0 ) {
+				sieve_sys_error(
+					"failed to rename logfile %s to %s: %m", 
+					ehandler->logfile, rotated);
+			}
+			
+			/* Open clean logfile (overwrites existing if rename() failed earlier) */
+			fd = open(ehandler->logfile, O_CREAT | O_WRONLY | O_TRUNC, 0600);
+			if (fd == -1) {
+				sieve_sys_error("failed to open logfile %s (logging to STDERR): %m", 
+					ehandler->logfile);
+				fd = STDERR_FILENO;
+			}
+		}
+	}
+
+	ostream = o_stream_create_fd(fd, 0, FALSE);
+	if ( ostream == NULL ) {
+		/* Can't we do anything else in this most awkward situation? */
+		sieve_sys_error("failed to open log stream on open file %s: "
+			"non-critical messages will not be logged!", ehandler->logfile);
+	} 
+
+	ehandler->fd = fd;
+	ehandler->stream = ostream;
+	ehandler->started = TRUE;
+	
+	if ( ostream != NULL ) {
+		now = time(NULL);	
+		tm = localtime(&now);
+
+		if (strftime(buf, sizeof(buf), "%b %d %H:%M:%S", tm) > 0) {
+			sieve_logfile_printf(ehandler, "sieve", "info",
+				"started log at %s", buf);
+		}
+	}
+}
+
+static void sieve_logfile_verror
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "error", fmt, args);
+}
+
+static void sieve_logfile_vwarning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "warning", fmt, args);
+}
+
+static void sieve_logfile_vinfo
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "info", fmt, args);
+}
+
+static void sieve_logfile_free
+(struct sieve_error_handler *ehandler)
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+		
+	if ( handler->stream != NULL ) {
+		o_stream_destroy(&(handler->stream));
+		if ( handler->fd != STDERR_FILENO ){
+			if ( close(handler->fd) < 0 ) {
+				sieve_sys_error("close(fd) failed for logfile '%s': %m",
+					handler->logfile);
+			}
+		}
+	}
+}
+
+struct sieve_error_handler *sieve_logfile_ehandler_create
+(const char *logfile, unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_logfile_ehandler *ehandler;
+	
+	pool = pool_alloconly_create("logfile_error_handler", 256);	
+	ehandler = p_new(pool, struct sieve_logfile_ehandler, 1);
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_logfile_verror;
+	ehandler->handler.vwarning = sieve_logfile_vwarning;
+	ehandler->handler.vinfo = sieve_logfile_vinfo;
+	ehandler->handler.free = sieve_logfile_free;
+	
+	/* Don't open logfile until something is actually logged. 
+	 * Let's not pullute the sieve directory with useless logfiles.
+	 */
+	ehandler->logfile = p_strdup(pool, logfile);
+	ehandler->started = FALSE;
+	ehandler->stream = NULL;
+	ehandler->fd = -1;
+	
+	return &(ehandler->handler);	
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-error.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-error.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-error.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-error.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,172 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_H
+#define __SIEVE_ERROR_H
+
+#include "lib.h"
+#include "compat.h"
+
+#include <stdarg.h>
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_script;
+struct sieve_error_handler;
+
+/*
+ * Types
+ */
+
+typedef void (*sieve_error_vfunc_t)
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+
+/*
+ * System errors
+ */
+
+extern struct sieve_error_handler *_sieve_system_ehandler;
+
+#define sieve_sys_error(...) sieve_error(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+#define sieve_sys_warning(...) sieve_warning(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+#define sieve_sys_info(...) sieve_info(_sieve_system_ehandler, NULL, __VA_ARGS__ )
+
+void sieve_system_ehandler_set(struct sieve_error_handler *ehandler);
+void sieve_system_ehandler_reset(void);
+
+/*
+ * Main error functions
+ */
+
+/* For these functions it is the responsibility of the caller to
+ * manage the datastack.
+ */
+
+const char *sieve_error_script_location
+	(const struct sieve_script *script, unsigned int source_line);
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_verror(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vwarning(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vinfo(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vcritical(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable);
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable);
+
+/*
+ * Error handler statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler);
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler);
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler);
+
+/*
+ * Error handler object
+ */
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler);
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler);
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler);
+
+/* 
+ * Error handlers 
+ */
+
+/* Write errors to dovecot master log */
+struct sieve_error_handler *sieve_master_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors to stderr */
+struct sieve_error_handler *sieve_stderr_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors into a string buffer */
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+	(string_t *strbuf, bool crlf, unsigned int max_errors);
+
+/* Write errors to a logfile */
+struct sieve_error_handler *sieve_logfile_ehandler_create
+	(const char *logfile, unsigned int max_errors);  
+
+#endif /* __SIEVE_ERROR_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-error-private.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-error-private.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-error-private.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-error-private.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,47 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_PRIVATE_H
+#define __SIEVE_ERROR_PRIVATE_H
+
+#include "sieve-error.h"
+
+/*
+ * Error handler object
+ */
+
+struct sieve_error_handler {
+	pool_t pool;
+	int refcount;
+
+	unsigned int max_errors;
+
+	unsigned int errors;
+	unsigned int warnings;
+
+	/* Should we copy log to i_error, i_warning and i_info? */
+	bool log_master;
+
+	/* Should the errorhandler handle or discard info log?
+	 * (This does not influence the previous setting)
+	 */
+	bool log_info;
+
+	void (*verror)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vwarning)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vinfo)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+
+	void (*free)
+		(struct sieve_error_handler *ehandler);
+};
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors);
+
+#endif /* __SIEVE_ERROR_PRIVATE_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-extensions.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-extensions.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-extensions.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-extensions.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,535 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+
+/*
+ * Forward declarations 
+ */
+
+static void sieve_extensions_init_registry(void);
+static void sieve_extensions_deinit_registry(void);
+
+static void sieve_extensions_init_capabilities(void);
+static void sieve_extensions_deinit_capabilities(void);
+
+/* 
+ * Pre-loaded 'extensions' 
+ */
+
+extern const struct sieve_extension comparator_extension;
+extern const struct sieve_extension match_type_extension;
+extern const struct sieve_extension address_part_extension;
+
+const struct sieve_extension *sieve_preloaded_extensions[] = {
+	&comparator_extension, &match_type_extension, &address_part_extension
+};
+
+const unsigned int sieve_preloaded_extensions_count = 
+	N_ELEMENTS(sieve_preloaded_extensions);
+
+/* 
+ * Dummy extensions 
+ */
+ 
+/* FIXME: This is stupid. Define a comparator-* extension and be done with it */
+
+static const struct sieve_extension comparator_i_octet_extension = {
+	"comparator-i;octet", 
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static const struct sieve_extension comparator_i_ascii_casemap_extension = {
+	"comparator-i;ascii-casemap", 
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
+	SIEVE_EXT_DEFINE_NO_OPERATIONS, 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+/* 
+ * Core extensions 
+ */
+
+extern const struct sieve_extension fileinto_extension;
+extern const struct sieve_extension reject_extension;
+extern const struct sieve_extension envelope_extension;
+extern const struct sieve_extension encoded_character_extension;
+
+/* 
+ * Native 'plugin' extensions 
+ */
+
+extern const struct sieve_extension vacation_extension;
+extern const struct sieve_extension subaddress_extension;
+extern const struct sieve_extension comparator_i_ascii_numeric_extension;
+extern const struct sieve_extension relational_extension;
+extern const struct sieve_extension regex_extension;
+extern const struct sieve_extension imap4flags_extension;
+extern const struct sieve_extension copy_extension;
+extern const struct sieve_extension include_extension;
+extern const struct sieve_extension body_extension;
+extern const struct sieve_extension variables_extension;
+extern const struct sieve_extension enotify_extension;
+extern const struct sieve_extension environment_extension;
+
+/*
+ * Extensions under development
+ */
+
+// None
+
+/*
+ * List of native extensions
+ */
+
+const struct sieve_extension *sieve_core_extensions[] = {
+	/* Preloaded 'extensions' */
+	&comparator_extension, &match_type_extension, &address_part_extension,
+	
+	/* Dummy extensions */ 
+	&comparator_i_octet_extension, &comparator_i_ascii_casemap_extension, 
+	
+	/* Core extensions */
+	&fileinto_extension, &reject_extension, &envelope_extension, 
+	&encoded_character_extension,
+
+	/* Extensions under development */
+	
+	/* 'Plugins' */
+	&vacation_extension, &subaddress_extension, 
+	&comparator_i_ascii_numeric_extension, 
+	&relational_extension, &regex_extension, &imap4flags_extension,
+	&copy_extension, &include_extension, &body_extension,
+	&variables_extension, &enotify_extension, &environment_extension
+};
+
+const unsigned int sieve_core_extensions_count =
+	N_ELEMENTS(sieve_core_extensions);
+
+/*
+ * Depricated extensions
+ */
+
+extern const struct sieve_extension imapflags_extension;
+
+const struct sieve_extension *sieve_depricated_extensions[] = {
+	/* Depricated extensions */
+	&imapflags_extension
+};
+
+const unsigned int sieve_depricated_extensions_count =
+	N_ELEMENTS(sieve_depricated_extensions);
+
+/* 
+ * Extensions init/deinit
+ */
+
+bool sieve_extensions_init(void) 
+{
+	unsigned int i;
+	
+	sieve_extensions_init_registry();
+	sieve_extensions_init_capabilities();
+	
+	/* Pre-load core extensions */
+	for ( i = 0; i < sieve_core_extensions_count; i++ ) {
+		(void)sieve_extension_register(sieve_core_extensions[i], TRUE);
+	}
+
+	/* Register depricated extensions */
+	for ( i = 0; i < sieve_depricated_extensions_count; i++ ) {
+		(void)sieve_extension_register(sieve_depricated_extensions[i], FALSE);
+	}
+
+	/* More extensions can be added through plugins */
+	
+	return TRUE;
+}
+
+void sieve_extensions_deinit(void)
+{	
+	sieve_extensions_deinit_capabilities();
+	sieve_extensions_deinit_registry();
+}
+
+/* 
+ * Extension registry
+ */
+ 
+struct sieve_extension_registration {
+	const struct sieve_extension *extension;
+	int id;
+	bool required;
+	bool loaded;
+};
+
+static ARRAY_DEFINE(extensions, struct sieve_extension_registration); 
+static struct hash_table *extension_index; 
+
+static void sieve_extensions_init_registry(void)
+{	
+	i_array_init(&extensions, 30);
+	extension_index = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+static bool _sieve_extension_load
+(const struct sieve_extension *extension)
+{
+	/* Call load handler */
+	if ( extension->load != NULL && !extension->load() ) {
+		sieve_sys_error("failed to load '%s' extension support.", 
+			extension->name);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static struct sieve_extension_registration *_sieve_extension_register
+(const struct sieve_extension *extension, bool load)
+{
+	struct sieve_extension_registration *ereg = 
+		(struct sieve_extension_registration *)	
+		hash_table_lookup(extension_index, extension->name);
+
+	/* Register extension if it is not registered already */
+	if ( ereg == NULL ) {
+		int ext_id = array_count(&extensions);
+
+		/* Add extension to the registry */
+
+		ereg = array_append_space(&extensions);
+		ereg->id = ext_id;
+
+		hash_table_insert(extension_index, (void *) extension->name, (void *) ereg);
+	}
+
+	/* Enable extension */
+	if ( extension->_id != NULL && load ) {
+		/* Make sure extension is enabled */
+		*(extension->_id) = ereg->id;
+
+		/* Call load handler if extension was not loaded already */
+		if ( !ereg->loaded ) {
+			if ( !_sieve_extension_load(extension) )
+				return NULL;
+		}
+
+		ereg->loaded = TRUE;
+	}
+
+	ereg->extension = extension;
+
+	return ereg;
+}
+
+int sieve_extension_register
+(const struct sieve_extension *extension, bool load) 
+{
+	struct sieve_extension_registration *ereg;
+
+	/* Register the extension */
+	if ( (ereg=_sieve_extension_register(extension, load)) == NULL ) {
+		return -1;
+	}
+
+	return ereg->id;
+}
+
+int sieve_extension_require(const struct sieve_extension *extension)
+{
+	struct sieve_extension_registration *ereg;
+
+	/* Register (possibly unknown) extension */
+    if ( (ereg=_sieve_extension_register(extension, TRUE)) == NULL ) {
+        return -1;
+    }
+
+	ereg->required = TRUE;
+	return ereg->id;
+}
+
+int sieve_extensions_get_count(void)
+{
+	return array_count(&extensions);
+}
+
+const struct sieve_extension *sieve_extension_get_by_id(unsigned int ext_id) 
+{
+	const struct sieve_extension_registration *ereg;
+	
+	if ( ext_id < array_count(&extensions) ) {
+		ereg = array_idx(&extensions, ext_id);
+
+		if ( SIEVE_EXT_ENABLED(ereg->extension) )
+			return ereg->extension;
+	}
+	
+	return NULL;
+}
+
+const struct sieve_extension *sieve_extension_get_by_name(const char *name) 
+{
+	struct sieve_extension_registration *ereg;
+	
+	if ( *name == '@' )
+		return NULL;	
+		
+	ereg = (struct sieve_extension_registration *) 
+		hash_table_lookup(extension_index, name);
+
+	if ( ereg == NULL || !SIEVE_EXT_ENABLED(ereg->extension) )
+		return NULL;
+		
+	return ereg->extension;
+}
+
+static inline bool _list_extension
+	(const struct sieve_extension_registration *ereg)
+{
+	return 
+		( SIEVE_EXT_ENABLED(ereg->extension) && 
+			*(ereg->extension->name) != '@' );
+}
+
+const char *sieve_extensions_get_string(void)
+{
+	unsigned int i, ext_count;
+	const struct sieve_extension_registration *eregs;
+	string_t *extstr = t_str_new(256);
+
+	eregs = array_get(&extensions, &ext_count);
+
+	if ( ext_count > 0 ) {
+		i = 0;
+		
+		/* Find first listable extension */
+		while ( i < ext_count && !_list_extension(&eregs[i]) )
+			i++;
+
+		if ( i < ext_count ) {
+			/* Add first to string */
+			str_append(extstr, eregs[i].extension->name);
+			i++;	 
+
+	 		/* Add others */
+			for ( ; i < ext_count; i++ ) {
+				if ( _list_extension(&eregs[i]) ) {
+					str_append_c(extstr, ' ');
+					str_append(extstr, eregs[i].extension->name);
+				}
+			}
+		}
+	}
+
+	return str_c(extstr);
+}
+
+static void sieve_extension_enable(struct sieve_extension_registration *ereg)
+{
+	if ( ereg->extension->_id != NULL ) {
+		*(ereg->extension->_id) = ereg->id;
+	
+		if ( !ereg->loaded ) {
+			(void)_sieve_extension_load(ereg->extension);
+		}
+	}
+
+	ereg->loaded = TRUE;
+}
+
+static void sieve_extension_disable(struct sieve_extension_registration *ereg)
+{
+	if ( ereg->extension->_id != NULL )
+		*(ereg->extension->_id) = -1;	
+}
+
+void sieve_extensions_set_string(const char *ext_string)
+{
+	ARRAY_DEFINE(enabled_extensions, const struct sieve_extension *);
+	ARRAY_DEFINE(disabled_extensions, const struct sieve_extension *);
+	const struct sieve_extension *const *ext_enabled;
+	const struct sieve_extension *const *ext_disabled;
+	struct sieve_extension_registration *eregs;
+	const char **ext_names;
+	unsigned int i, ext_count, ena_count, dis_count;
+	bool relative = FALSE;
+
+	if ( ext_string == NULL ) {
+		/* Enable all */
+		eregs = array_get_modifiable(&extensions, &ext_count);
+		
+		for ( i = 0; i < ext_count; i++ )
+			sieve_extension_enable(&eregs[i]);
+
+		return;	
+	}
+
+	T_BEGIN {
+		t_array_init(&enabled_extensions, array_count(&extensions));
+		t_array_init(&disabled_extensions, array_count(&extensions));
+
+		ext_names = t_strsplit_spaces(ext_string, " \t");
+
+		while ( *ext_names != NULL ) {
+			const char *name = *ext_names;
+
+			ext_names++;
+
+			if ( *name != '\0' ) {
+				const struct sieve_extension_registration *ereg;
+				char op = '\0'; /* No add/remove operation */
+	
+				if ( *name == '+' 		/* Add to existing config */
+					|| *name == '-' ) {	/* Remove from existing config */
+				 	op = *name++;
+				 	relative = TRUE;
+				}
+
+				if ( *name == '@' )
+					ereg = NULL;
+				else
+					ereg = (const struct sieve_extension_registration *) 
+						hash_table_lookup(extension_index, name);
+	
+				if ( ereg == NULL ) {
+					sieve_sys_warning(
+						"ignored unknown extension '%s' while configuring "
+						"available extensions", name);
+					continue;
+				}
+
+				if ( op == '-' )
+					array_append(&disabled_extensions, &ereg->extension, 1);
+				else
+					array_append(&enabled_extensions, &ereg->extension, 1);
+			}
+		}
+
+		eregs = array_get_modifiable(&extensions, &ext_count);
+		ext_enabled = array_get(&enabled_extensions, &ena_count);
+		ext_disabled = array_get(&disabled_extensions, &dis_count);
+
+		/* Set new extension status */
+
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int j;
+			bool disabled = TRUE;
+
+			/* If extensions are specified relative to the default set,
+			 * we first need to check which ones are disabled 
+			 */
+
+			if ( relative ) {
+				/* Enable if core extension */
+				for ( j = 0; j < sieve_core_extensions_count; j++ ) {
+					if ( sieve_core_extensions[j] == eregs[i].extension ) {
+						disabled = FALSE;
+						break;
+					}
+    			}
+
+				/* Disable if explicitly disabled */
+				for ( j = 0; j < dis_count; j++ ) {
+					if ( ext_disabled[j] == eregs[i].extension ) {
+						disabled = TRUE;
+						break;
+					}
+				}
+			} 
+
+			/* Enable if listed with '+' or no prefix */
+	
+			for ( j = 0; j < ena_count; j++ ) {
+				if ( ext_enabled[j] == eregs[i].extension ) {
+					disabled = FALSE;
+					break;
+				}		
+			}
+
+			/* Perform actual activation/deactivation */
+
+			if ( eregs[i].extension->_id != NULL && 
+				*(eregs[i].extension->name) != '@' ) {
+				if ( disabled && !eregs[i].required )
+					sieve_extension_disable(&eregs[i]);
+				else
+					sieve_extension_enable(&eregs[i]);
+			}
+		}
+	} T_END;
+}
+
+static void sieve_extensions_deinit_registry(void) 
+{
+	struct hash_iterate_context *itx = 
+		hash_table_iterate_init(extension_index);
+	void *key; 
+	void *value;
+	
+	while ( hash_table_iterate(itx, &key, &value) ) {
+		struct sieve_extension_registration *ereg =
+			(struct sieve_extension_registration *) value;
+		const struct sieve_extension *ext = ereg->extension;
+		
+		if ( ext->unload != NULL )
+			ext->unload();
+	}
+
+	hash_table_iterate_deinit(&itx); 	
+
+	array_free(&extensions);
+	hash_table_destroy(&extension_index);
+}
+
+/*
+ * Extension capabilities
+ */
+
+static struct hash_table *capabilities_index; 
+
+static void sieve_extensions_init_capabilities(void)
+{	
+	capabilities_index = hash_table_create
+		(default_pool, default_pool, 0, str_hash, (hash_cmp_callback_t *)strcmp);
+}
+
+static void sieve_extensions_deinit_capabilities(void) 
+{
+	hash_table_destroy(&capabilities_index);
+}
+
+void sieve_extension_capabilities_register
+	(const struct sieve_extension_capabilities *cap) 
+{	
+	hash_table_insert
+		(capabilities_index, (void *) cap->name, (void *) cap);
+}
+
+const char *sieve_extension_capabilities_get_string
+	(const char *cap_name) 
+{
+  const struct sieve_extension_capabilities *cap = 
+		(const struct sieve_extension_capabilities *) 
+			hash_table_lookup(capabilities_index, cap_name);
+
+	if ( cap == NULL || cap->get_string == NULL || 
+		!SIEVE_EXT_ENABLED(cap->extension) )
+		return NULL;
+		
+	return cap->get_string();
+}
+
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-extensions.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-extensions.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-extensions.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-extensions.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,118 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_EXTENSIONS_H
+#define __SIEVE_EXTENSIONS_H
+
+#include "lib.h"
+#include "sieve-common.h"
+
+/* 
+ * Per-extension object registry 
+ */
+
+struct sieve_extension_objects {
+	const void *objects;
+	unsigned int count;
+};
+
+/* 
+ * Extension object 
+ */
+
+struct sieve_extension {
+	const char *name;
+
+	int *const _id;
+		
+	bool (*load)(void);
+	void (*unload)(void);
+
+	bool (*validator_load)
+		(struct sieve_validator *validator);	
+	bool (*generator_load)
+		(const struct sieve_codegen_env *cgenv);
+	bool (*interpreter_load)
+		(const struct sieve_runtime_env *renv, sieve_size_t *address);
+	bool (*binary_load)
+		(struct sieve_binary *binary);
+	
+	bool (*binary_dump)
+		(struct sieve_dumptime_env *denv);
+	bool (*code_dump)
+		(const struct sieve_dumptime_env *denv, sieve_size_t *address);
+
+	struct sieve_extension_objects operations;
+	struct sieve_extension_objects operands;
+};
+
+#define SIEVE_EXT_ID(EXT) (*((EXT)->_id))
+#define SIEVE_EXT_ENABLED(EXT) (((EXT)->_id != NULL) && (*((EXT)->_id) >= 0))
+
+#define SIEVE_EXT_DEFINE_NO_OBJECTS \
+	{ NULL, 0 }
+#define SIEVE_EXT_DEFINE_OBJECT(OBJ) \
+	{ &OBJ, 1 }
+#define SIEVE_EXT_DEFINE_OBJECTS(OBJS) \
+	{ OBJS, N_ELEMENTS(OBJS) }
+
+#define SIEVE_EXT_GET_OBJECTS_COUNT(ext, field) \
+	ext->field->count;
+
+/* 
+ * Defining opcodes and operands 
+ */
+
+#define SIEVE_EXT_DEFINE_NO_OPERATIONS SIEVE_EXT_DEFINE_NO_OBJECTS
+#define SIEVE_EXT_DEFINE_OPERATION(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_OPERATIONS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+#define SIEVE_EXT_DEFINE_NO_OPERANDS SIEVE_EXT_DEFINE_NO_OBJECTS
+#define SIEVE_EXT_DEFINE_OPERAND(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_OPERANDS(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+/* 
+ * Pre-loaded extensions 
+ */
+
+extern const struct sieve_extension *sieve_preloaded_extensions[];
+extern const unsigned int sieve_preloaded_extensions_count;
+
+/*  
+ * Extensions init/deinit 
+ */
+
+bool sieve_extensions_init(void);
+void sieve_extensions_deinit(void);
+
+/* 
+ * Extension registry 
+ */
+
+int sieve_extension_register(const struct sieve_extension *extension, bool load);
+int sieve_extension_require(const struct sieve_extension *extension);
+int sieve_extensions_get_count(void);
+const struct sieve_extension *sieve_extension_get_by_id(unsigned int ext_id);
+const struct sieve_extension *sieve_extension_get_by_name(const char *name);
+
+const char *sieve_extensions_get_string(void);
+void sieve_extensions_set_string(const char *ext_string);
+
+/*
+ * Capability registries
+ */
+
+struct sieve_extension_capabilities {
+	const char *name;
+
+	const struct sieve_extension *extension;
+
+	const char *(*get_string)(void);	
+};
+
+void sieve_extension_capabilities_register
+	(const struct sieve_extension_capabilities *cap);
+const char *sieve_extension_capabilities_get_string
+	(const char *cap_name);
+
+#endif /* __SIEVE_EXTENSIONS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-generator.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-generator.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-generator.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-generator.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,422 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+#include "sieve-generator.h"
+
+/* 
+ * Jump list 
+ */
+
+struct sieve_jumplist *sieve_jumplist_create
+	(pool_t pool, struct sieve_binary *sbin)
+{
+	struct sieve_jumplist *jlist;
+	
+	jlist = p_new(pool, struct sieve_jumplist, 1);
+	jlist->binary = sbin;
+	p_array_init(&jlist->jumps, pool, 4);
+	
+	return jlist;
+}
+
+void sieve_jumplist_init_temp
+	(struct sieve_jumplist *jlist, struct sieve_binary *sbin)
+{
+	jlist->binary = sbin;
+	t_array_init(&jlist->jumps, 4);
+}
+
+void sieve_jumplist_reset
+	(struct sieve_jumplist *jlist)
+{
+	array_clear(&jlist->jumps);
+}
+
+void sieve_jumplist_add(struct sieve_jumplist *jlist, sieve_size_t jump) 
+{
+	array_append(&jlist->jumps, &jump, 1);
+}
+
+void sieve_jumplist_resolve(struct sieve_jumplist *jlist) 
+{
+	unsigned int i;
+	
+	for ( i = 0; i < array_count(&jlist->jumps); i++ ) {
+		const sieve_size_t *jump = array_idx(&jlist->jumps, i);
+	
+		sieve_binary_resolve_offset(jlist->binary, *jump);
+	}
+}
+
+/* 
+ * Code Generator 
+ */
+
+struct sieve_generator {
+	pool_t pool;
+	
+	struct sieve_error_handler *ehandler;
+
+	struct sieve_codegen_env genenv;
+	
+	ARRAY_DEFINE(ext_contexts, void *);
+};
+
+struct sieve_generator *sieve_generator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler) 
+{
+	pool_t pool;
+	struct sieve_generator *gentr;
+	
+	pool = pool_alloconly_create("sieve_generator", 4096);	
+	gentr = p_new(pool, struct sieve_generator, 1);
+	gentr->pool = pool;
+
+	gentr->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+	
+	gentr->genenv.gentr = gentr;
+	gentr->genenv.ast = ast;	
+	gentr->genenv.script = sieve_ast_script(ast);
+	sieve_ast_ref(ast);
+
+	/* Setup storage for extension contexts */		
+	p_array_init(&gentr->ext_contexts, pool, sieve_extensions_get_count());
+		
+	return gentr;
+}
+
+void sieve_generator_free(struct sieve_generator **generator) 
+{
+	sieve_ast_unref(&(*generator)->genenv.ast);
+	
+	if ( (*generator)->genenv.sbin != NULL )
+		sieve_binary_unref(&(*generator)->genenv.sbin);
+	
+	sieve_error_handler_unref(&(*generator)->ehandler);
+
+	pool_unref(&((*generator)->pool));
+	
+	*generator = NULL;
+}
+
+/* 
+ * Accessors 
+ */
+
+struct sieve_error_handler *sieve_generator_error_handler
+(struct sieve_generator *gentr)
+{
+	return gentr->ehandler;
+}
+
+pool_t sieve_generator_pool(struct sieve_generator *gentr)
+{
+	return gentr->pool;
+}
+
+struct sieve_script *sieve_generator_script
+(struct sieve_generator *gentr)
+{
+	return gentr->genenv.script;
+}
+
+struct sieve_binary *sieve_generator_get_binary
+	(struct sieve_generator *gentr)
+{
+	return gentr->genenv.sbin;
+}
+
+/* 
+ * Error handling 
+ */
+
+void sieve_generator_warning
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) 
+{ 
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vwarning(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+ 
+void sieve_generator_error
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_verror(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+void sieve_generator_critical
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vwarning(gentr->ehandler,
+        sieve_error_script_location(gentr->genenv.script, source_line),
+        fmt, args);
+	va_end(args);
+}
+
+/* 
+ * Extension support 
+ */
+
+void sieve_generator_extension_set_context
+(struct sieve_generator *gentr, const struct sieve_extension *ext, void *context)
+{
+	array_idx_set(&gentr->ext_contexts, (unsigned int) SIEVE_EXT_ID(ext), &context);	
+}
+
+const void *sieve_generator_extension_get_context
+(struct sieve_generator *gentr, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	void * const *ctx;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&gentr->ext_contexts) )
+		return NULL;
+	
+	ctx = array_idx(&gentr->ext_contexts, (unsigned int) ext_id);		
+
+	return *ctx;
+}
+
+/* 
+ * Code generation API
+ */
+
+bool sieve_generate_argument
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd)
+{
+	const struct sieve_argument *argument = arg->argument;
+	
+	if ( argument == NULL ) return FALSE;
+	
+	return ( argument->generate == NULL || 	
+		argument->generate(cgenv, arg, cmd) );
+}
+
+bool sieve_generate_arguments
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument **last_arg)
+{
+	enum { ARG_START, ARG_OPTIONAL, ARG_POSITIONAL } state = ARG_START;
+	struct sieve_ast_argument *arg = sieve_ast_argument_first(cmd->ast_node);
+	
+	/* Generate all arguments with assigned generator function */
+	
+	while ( arg != NULL && arg->argument != NULL) {
+		const struct sieve_argument *argument = arg->argument;
+		
+		switch ( state ) {
+		case ARG_START: 
+			if ( arg->arg_id_code == 0 )
+				state = ARG_POSITIONAL;
+			else {
+				/* Mark start of optional operands with 0 operand identifier */
+				sieve_binary_emit_byte(cgenv->sbin, SIEVE_OPERAND_OPTIONAL);
+								
+				/* Emit argument id for optional operand */
+				sieve_binary_emit_byte(cgenv->sbin, (unsigned char) arg->arg_id_code);
+
+				state = ARG_OPTIONAL;
+			}
+			break;
+		case ARG_OPTIONAL: 
+			if ( arg->arg_id_code == 0 )
+				state = ARG_POSITIONAL;
+			
+			/* Emit argument id for optional operand (0 marks the end of the optionals) */
+			sieve_binary_emit_byte(cgenv->sbin, (unsigned char) arg->arg_id_code);
+
+			break;
+		case ARG_POSITIONAL:
+			if ( arg->arg_id_code != 0 )
+				return FALSE;
+			break;
+		}
+		
+		/* Call the generation function for the argument */ 
+		if ( argument->generate != NULL ) { 
+			if ( !argument->generate(cgenv, arg, cmd) ) 
+				return FALSE;
+		} else if ( state == ARG_POSITIONAL ) break;
+
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	/* Mark end of optional list if it is still open */
+	if ( state == ARG_OPTIONAL )
+		sieve_binary_emit_byte(cgenv->sbin, 0);
+	
+	if ( last_arg != NULL )
+		*last_arg = arg;
+	
+	return TRUE;
+}
+
+bool sieve_generate_argument_parameters
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *cmd, struct sieve_ast_argument *arg)
+{
+	struct sieve_ast_argument *param = arg->parameters;
+	
+	/* Generate all parameters with assigned generator function */
+	
+	while ( param != NULL && param->argument != NULL) {
+		const struct sieve_argument *parameter = param->argument;
+				
+		/* Call the generation function for the parameter */ 
+		if ( parameter->generate != NULL ) { 
+			if ( !parameter->generate(cgenv, param, cmd) ) 
+				return FALSE;
+		}
+
+		param = sieve_ast_argument_next(param);
+	}
+		
+	return TRUE;
+}
+
+bool sieve_generate_test
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *tst_node,
+	struct sieve_jumplist *jlist, bool jump_true) 
+{
+	i_assert( tst_node->context != NULL && tst_node->context->command != NULL );
+
+	if ( tst_node->context->command->control_generate != NULL ) {
+		if ( tst_node->context->command->control_generate
+			(cgenv, tst_node->context, jlist, jump_true) ) 
+			return TRUE;
+		
+		return FALSE;
+	}
+	
+	if ( tst_node->context->command->generate != NULL ) {
+
+		if ( tst_node->context->command->generate(cgenv, tst_node->context) ) {
+			
+			if ( jump_true ) 
+				sieve_operation_emit_code(cgenv->sbin, &sieve_jmptrue_operation);
+			else
+				sieve_operation_emit_code(cgenv->sbin, &sieve_jmpfalse_operation);
+			sieve_jumplist_add(jlist, sieve_binary_emit_offset(cgenv->sbin, 0));
+						
+			return TRUE;
+		}	
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool sieve_generate_command
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *cmd_node) 
+{
+	i_assert( cmd_node->context != NULL && cmd_node->context->command != NULL );
+
+	if ( cmd_node->context->command->generate != NULL ) {
+		return cmd_node->context->command->generate(cgenv, cmd_node->context);
+	}
+	
+	return TRUE;		
+}
+
+bool sieve_generate_block
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *block) 
+{
+	bool result = TRUE;
+	struct sieve_ast_node *command;
+
+	T_BEGIN {	
+		command = sieve_ast_command_first(block);
+		while ( result && command != NULL ) {	
+			result = sieve_generate_command(cgenv, command);	
+			command = sieve_ast_command_next(command);
+		}		
+	} T_END;
+	
+	return result;
+}
+
+bool sieve_generator_run
+(struct sieve_generator *gentr, struct sieve_binary **sbin) 
+{
+	bool topmost = ( *sbin == NULL );
+	bool result = TRUE;
+	const struct sieve_extension *const *extensions;
+	unsigned int i, ext_count;
+	
+	/* Initialize */
+	
+	if ( topmost )
+		*sbin = sieve_binary_create_new(sieve_ast_script(gentr->genenv.ast));
+	
+	sieve_binary_ref(*sbin);
+		
+	gentr->genenv.sbin = *sbin;
+		
+	/* Load extensions linked to the AST and emit a list in code */
+	extensions = sieve_ast_extensions_get(gentr->genenv.ast, &ext_count);
+	(void) sieve_binary_emit_unsigned(*sbin, ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		const struct sieve_extension *ext = extensions[i];
+
+		/* Link to binary */
+		(void)sieve_binary_extension_link(*sbin, ext);
+	
+		/* Emit */
+		sieve_binary_emit_extension(*sbin, ext, 0);
+	
+		/* Load */
+		if ( ext->generator_load != NULL && !ext->generator_load(&gentr->genenv) )
+			return FALSE;
+	}
+
+	/* Generate code */
+	
+	if ( !sieve_generate_block
+		(&gentr->genenv, sieve_ast_root(gentr->genenv.ast))) 
+		result = FALSE;
+	else if ( topmost ) 
+		sieve_binary_activate(*sbin);
+
+	/* Cleanup */
+		
+	gentr->genenv.sbin = NULL;
+	sieve_binary_unref(sbin);
+
+	if ( topmost && !result ) {
+		sieve_binary_unref(sbin);
+		*sbin = NULL;
+	}
+	
+	return result;
+}
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-generator.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-generator.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-generator.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-generator.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,106 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_GENERATOR_H
+#define __SIEVE_GENERATOR_H
+
+#include "sieve-common.h"
+
+/*
+ * Code generator
+ */
+
+struct sieve_generator;
+
+struct sieve_codegen_env {
+	struct sieve_generator *gentr;
+
+    struct sieve_script *script;
+	struct sieve_ast *ast;
+	struct sieve_binary *sbin;
+};
+
+struct sieve_generator *sieve_generator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+void sieve_generator_free(struct sieve_generator **generator);
+
+/* 
+ * Accessors 
+ */
+
+struct sieve_error_handler *sieve_generator_error_handler
+	(struct sieve_generator *gentr);
+pool_t sieve_generator_pool(struct sieve_generator *gentr);
+struct sieve_script *sieve_generator_script
+	(struct sieve_generator *gentr);
+struct sieve_binary *sieve_generator_get_binary
+	(struct sieve_generator *gentr);
+
+/* 
+ * Error handling 
+ */
+
+void sieve_generator_warning
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);; 
+void sieve_generator_error
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_generator_critical
+(struct sieve_generator *gentr, unsigned int source_line, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4); 
+
+/* 
+ * Extension support 
+ */
+
+void sieve_generator_extension_set_context
+	(struct sieve_generator *gentr, const struct sieve_extension *ext, 
+		void *context);
+const void *sieve_generator_extension_get_context
+	(struct sieve_generator *gentr, const struct sieve_extension *ext);
+    		
+/* 
+ * Jump list 
+ */
+
+struct sieve_jumplist {
+	pool_t pool;
+	struct sieve_binary *binary;
+	ARRAY_DEFINE(jumps, sieve_size_t);
+};
+
+struct sieve_jumplist *sieve_jumplist_create
+	(pool_t pool, struct sieve_binary *sbin);
+void sieve_jumplist_init_temp
+	(struct sieve_jumplist *jlist, struct sieve_binary *sbin);
+void sieve_jumplist_reset
+	(struct sieve_jumplist *jlist);
+void sieve_jumplist_add
+	(struct sieve_jumplist *jlist, sieve_size_t jump);
+void sieve_jumplist_resolve(struct sieve_jumplist *jlist);
+
+/* 
+ * Code generation API 
+ */
+
+bool sieve_generate_argument
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+bool sieve_generate_arguments
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd, 
+		struct sieve_ast_argument **arg);
+bool sieve_generate_argument_parameters
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd, 
+		struct sieve_ast_argument *arg);
+
+bool sieve_generate_block
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *block);
+bool sieve_generate_test
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_node *tst_node, 
+		struct sieve_jumplist *jlist, bool jump_true);
+bool sieve_generator_run
+	(struct sieve_generator *gentr, struct sieve_binary **sbin);
+
+#endif /* __SIEVE_GENERATOR_H */
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,148 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_H
+#define __SIEVE_H
+
+#include <stdio.h>
+
+struct sieve_script;
+struct sieve_binary;
+
+#include "sieve-config.h"
+#include "sieve-types.h"
+#include "sieve-error.h"
+
+/*
+ * Main Sieve library interface
+ */
+
+/* sieve_init(): 
+ *   Initializes the sieve engine. Must be called before any sieve functionality
+ *   is used.
+ */
+bool sieve_init(void);
+
+/* sieve_deinit():
+ *   Frees all memory allocated by the sieve engine. 
+ */
+void sieve_deinit(void);
+
+/* sieve_get_capabilities():
+ *
+ */
+const char *sieve_get_capabilities(const char *name);
+
+/* sieve_set_extensions():
+ *
+ */
+void sieve_set_extensions(const char *extensions);
+
+/*
+ * Script compilation
+ */
+
+/* sieve_compile_script:
+ */
+struct sieve_binary *sieve_compile_script
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+
+/* sieve_compile:
+ *
+ *   Compiles the script into a binary.
+ */
+struct sieve_binary *sieve_compile
+	(const char *script_path, const char *script_name, 
+		struct sieve_error_handler *ehandler);
+
+/* 
+ * Reading/writing Sieve binaries
+ */
+
+/* sieve_open:
+ *
+ *   First tries to open the binary version of the specified script and
+ *   if it does not exist or if it contains errors, the script is
+ *   (re-)compiled. The binary is updated if the script is recompiled.
+ *   Note that errors in the bytecode are not caught here.
+ *
+ */
+struct sieve_binary *sieve_open
+	(const char *scriptpath, const char *script_name, 
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+/* sieve_save:
+ *  Saves the binary as the file indicated by the path parameter.
+ */
+bool sieve_save
+    (struct sieve_binary *sbin, const char *path);
+
+/* sieve_close:
+ *
+ *   Closes a compiled/opened sieve binary.
+ */
+void sieve_close(struct sieve_binary **sbin);
+
+/*
+ * Debugging
+ */
+
+/* sieve_dump:
+ *
+ *   Dumps the byte code in human-readable form to the specified ostream.
+ */
+void sieve_dump(struct sieve_binary *sbin, struct ostream *stream);
+
+/* sieve_test:
+ *
+ *   Executes the bytecode, but only prints the result to the given stream.
+ */ 
+int sieve_test
+	(struct sieve_binary *sbin, const struct sieve_message_data *msgdata, 
+		const struct sieve_script_env *senv, struct sieve_error_handler *ehandler, 
+		struct ostream *stream);
+
+/*
+ * Script execution
+ */
+
+/* sieve_execute:
+ *
+ *   Executes the binary, including the result.  
+ */
+int sieve_execute
+	(struct sieve_binary *sbin, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_error_handler *ehandler);
+		
+/*
+ * Multiscript support
+ */
+ 
+struct sieve_multiscript;
+ 
+struct sieve_multiscript *sieve_multiscript_start_execute
+	(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv);
+struct sieve_multiscript *sieve_multiscript_start_test
+	(const struct sieve_message_data *msgdata, const struct sieve_script_env *senv,
+		struct ostream *stream);
+
+bool sieve_multiscript_run
+	(struct sieve_multiscript *mscript, struct sieve_binary *sbin, 
+		struct sieve_error_handler *ehandler, bool final);
+
+int sieve_multiscript_status(struct sieve_multiscript *mscript);
+
+int sieve_multiscript_finish
+	(struct sieve_multiscript **mscript, struct sieve_error_handler *ehandler);
+
+/*
+ * Script directory
+ */
+
+struct sieve_directory;
+
+struct sieve_directory *sieve_directory_open(const char *path);
+const char *sieve_directory_get_scriptfile(struct sieve_directory *sdir);
+void sieve_directory_close(struct sieve_directory **sdir);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-interpreter.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,538 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "mempool.h"
+#include "array.h"
+#include "hash.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error.h"
+#include "sieve-extensions.h"
+#include "sieve-message.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-actions.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-result.h"
+#include "sieve-comparators.h"
+
+#include "sieve-interpreter.h"
+
+#include <string.h>
+
+/* 
+ * Interpreter extension 
+ */
+
+struct sieve_interpreter_extension_reg {
+	const struct sieve_interpreter_extension *int_ext;
+	void *context;
+};
+
+/* 
+ * Interpreter 
+ */
+
+struct sieve_interpreter {
+	pool_t pool;
+			
+	struct sieve_error_handler *ehandler;
+
+	/* Runtime data for extensions */
+	ARRAY_DEFINE(extensions, struct sieve_interpreter_extension_reg); 
+	
+	sieve_size_t reset_vector;	
+		
+	/* Execution status */
+	
+	sieve_size_t pc;          /* Program counter */
+	bool interrupted;         /* Interpreter interrupt requested */
+	bool test_result;         /* Result of previous test command */
+
+	/* Current operation */ 
+	const struct sieve_operation *current_op;
+	
+	/* Start address of current operation */
+	sieve_size_t current_op_addr;             
+	
+	/* Runtime environment */
+	struct sieve_runtime_env runenv; 
+};
+
+struct sieve_interpreter *sieve_interpreter_create
+(struct sieve_binary *sbin, struct sieve_error_handler *ehandler) 
+{
+	unsigned int i, ext_count;
+	bool success = TRUE;
+
+	pool_t pool;
+	struct sieve_interpreter *interp;
+	
+	pool = pool_alloconly_create("sieve_interpreter", 4096);	
+	interp = p_new(pool, struct sieve_interpreter, 1);
+	interp->pool = pool;
+
+	interp->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	interp->runenv.interp = interp;	
+	interp->runenv.sbin = sbin;
+	interp->runenv.script = sieve_binary_script(sbin);
+	sieve_binary_ref(sbin);
+	
+	interp->pc = 0;
+
+	p_array_init(&interp->extensions, pool, sieve_extensions_get_count());
+
+	/* Pre-load core language features implemented as 'extensions' */
+	for ( i = 0; i < sieve_preloaded_extensions_count; i++ ) {
+		const struct sieve_extension *ext = sieve_preloaded_extensions[i];
+		
+		if ( ext->interpreter_load != NULL )
+			(void)ext->interpreter_load(&interp->runenv, &interp->pc);		
+	}
+
+	/* Load other extensions listed in code */
+	if ( sieve_binary_read_unsigned(sbin, &interp->pc, &ext_count) ) {
+		for ( i = 0; i < ext_count; i++ ) {
+			unsigned int code = 0;
+			const struct sieve_extension *ext;
+			
+			if ( !sieve_binary_read_extension(sbin, &interp->pc, &code, &ext) ) {
+				success = FALSE;
+				break;
+			}
+ 
+			if ( ext->interpreter_load != NULL && 
+				!ext->interpreter_load(&interp->runenv, &interp->pc) ) {
+				success = FALSE;
+				break;
+			}
+		}
+	}	else
+		success = FALSE;
+	
+	if ( !success ) {
+		sieve_interpreter_free(&interp);
+	} else {
+		interp->reset_vector = interp->pc;
+	}
+	
+	return interp;
+}
+
+void sieve_interpreter_free(struct sieve_interpreter **interp) 
+{
+	const struct sieve_interpreter_extension_reg *extrs;
+	unsigned int ext_count, i;
+
+	sieve_binary_unref(&(*interp)->runenv.sbin);
+
+	if ( (*interp)->runenv.msgctx != NULL )
+		 sieve_message_context_unref(&(*interp)->runenv.msgctx);
+
+	sieve_error_handler_unref(&(*interp)->ehandler);
+
+	/* Signal registered extensions that the interpreter is being destroyed */
+	extrs = array_get(&(*interp)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].int_ext != NULL && extrs[i].int_ext->free != NULL )
+			extrs[i].int_ext->free(*interp, extrs[i].context);
+	}
+		 
+	pool_unref(&((*interp)->pool));	
+	*interp = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_interpreter_pool(struct sieve_interpreter *interp)
+{
+	return interp->pool;
+}
+
+struct sieve_script *sieve_interpreter_script
+(struct sieve_interpreter *interp)
+{
+	return interp->runenv.script;
+}
+
+struct sieve_error_handler *sieve_interpreter_get_error_handler
+(struct sieve_interpreter *interp)
+{
+	return interp->ehandler;
+}
+
+/* Do not use this function for normal sieve extensions. This is intended for
+ * the testsuite only.
+ */
+void sieve_interpreter_set_result
+(struct sieve_interpreter *interp, struct sieve_result *result)
+{
+	sieve_result_unref(&interp->runenv.result);
+	interp->runenv.result = result;
+	sieve_result_ref(result);
+}
+
+/* 
+ * Error handling 
+ */
+
+/* This is not particularly user friendly, so avoid using this
+ */
+const char *sieve_runtime_location(const struct sieve_runtime_env *runenv)
+{
+	const char *op = runenv->interp->current_op == NULL ?
+		"<<NOOP>>" : runenv->interp->current_op->mnemonic;
+	return t_strdup_printf("%s: #%08llx: %s", sieve_script_name(runenv->script),
+		(unsigned long long) runenv->interp->current_op_addr, op);
+}
+
+void sieve_runtime_error
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_verror(runenv->interp->ehandler, location, fmt, args); 
+	} T_END;
+	va_end(args);
+}
+
+void sieve_runtime_warning
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{	
+	va_list args;
+	
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_vwarning(runenv->interp->ehandler, location, fmt, args);
+	} T_END; 
+	va_end(args);
+}
+
+void sieve_runtime_log
+(const struct sieve_runtime_env *runenv, const char *location,
+	const char *fmt, ...)
+{	
+	va_list args;
+	
+	va_start(args, fmt);
+	T_BEGIN {
+		sieve_vinfo(runenv->interp->ehandler, location, fmt, args); 
+	} T_END;
+	va_end(args);
+}
+
+/*
+ * Runtime trace
+ */
+
+#ifdef SIEVE_RUNTIME_TRACE
+void _sieve_runtime_trace
+(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+{	
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_printfa(outbuf, "%08llx: ", (unsigned long long) runenv->interp->current_op_addr); 
+	str_vprintfa(outbuf, fmt, args); 
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(runenv->trace_stream, str_data(outbuf), str_len(outbuf));	
+}
+
+void _sieve_runtime_trace_error
+(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+{
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+
+	va_start(args, fmt);
+	str_printfa(outbuf, "%08llx: [[ERROR: %s: ", 
+		(unsigned long long) runenv->interp->pc, 
+		runenv->interp->current_op->mnemonic);
+	str_vprintfa(outbuf, fmt, args);
+    str_append(outbuf, "]]\n");
+	va_end(args);
+
+	o_stream_send(runenv->trace_stream, str_data(outbuf), str_len(outbuf));
+}
+#endif
+
+/* 
+ * Extension support 
+ */
+
+void sieve_interpreter_extension_register
+(struct sieve_interpreter *interp, 
+	const struct sieve_interpreter_extension *int_ext, void *context)
+{
+	struct sieve_interpreter_extension_reg reg = { int_ext, context };
+	int ext_id = SIEVE_EXT_ID(int_ext->ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&interp->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void sieve_interpreter_extension_set_context
+(struct sieve_interpreter *interp, const struct sieve_extension *ext, 
+	void *context)
+{
+	struct sieve_interpreter_extension_reg reg = { NULL, context };
+	int ext_id = SIEVE_EXT_ID(ext);
+
+	if ( ext_id < 0 ) return;
+	
+	array_idx_set(&interp->extensions, (unsigned int) ext_id, &reg);	
+}
+
+void *sieve_interpreter_extension_get_context
+(struct sieve_interpreter *interp, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_interpreter_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&interp->extensions) )
+		return NULL;
+	
+	reg = array_idx(&interp->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/* 
+ * Program flow 
+ */
+
+void sieve_interpreter_reset(struct sieve_interpreter *interp) 
+{
+	interp->pc = interp->reset_vector;
+	interp->interrupted = FALSE;
+	interp->test_result = FALSE;
+	interp->runenv.msgdata = NULL;
+	interp->runenv.result = NULL;
+}
+
+void sieve_interpreter_interrupt(struct sieve_interpreter *interp)
+{
+	interp->interrupted = TRUE;
+}
+
+sieve_size_t sieve_interpreter_program_counter(struct sieve_interpreter *interp)
+{
+	return interp->pc;
+}
+
+int sieve_interpreter_program_jump
+(struct sieve_interpreter *interp, bool jump)
+{
+	const struct sieve_runtime_env *renv = &interp->runenv;
+	sieve_size_t pc = interp->pc;
+	int offset;
+	
+	if ( !sieve_binary_read_offset(renv->sbin, &(interp->pc), &offset) )
+	{
+		sieve_runtime_trace_error(renv, "invalid jump offset"); 
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	if ( pc + offset <= sieve_binary_get_code_size(renv->sbin) && 
+		pc + offset > 0 ) 
+	{	
+		if ( jump )
+			interp->pc = pc + offset;
+		
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "jump offset out of range");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
+
+/*
+ * Test results
+ */
+
+void sieve_interpreter_set_test_result
+(struct sieve_interpreter *interp, bool result)
+{
+	interp->test_result = result;
+}
+
+bool sieve_interpreter_get_test_result
+(struct sieve_interpreter *interp)
+{
+	return interp->test_result;
+}
+
+/* 
+ * Operations and operands 
+ */
+
+int sieve_interpreter_handle_optional_operands
+(const struct sieve_runtime_env *renv, sieve_size_t *address,
+	struct sieve_side_effects_list **list)
+{
+	int opt_code = -1;
+	
+	if ( sieve_operand_optional_present(renv->sbin, address) ) {
+		while ( opt_code != 0 ) {
+			if ( !sieve_operand_optional_read(renv->sbin, address, &opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			if ( opt_code == SIEVE_OPT_SIDE_EFFECT ) {
+				void *context = NULL;
+			
+				if ( list != NULL && *list == NULL ) 
+					*list = sieve_side_effects_list_create(renv->result);
+					
+				const struct sieve_side_effect *seffect = 
+					sieve_opr_side_effect_read(renv, address);
+
+				if ( seffect == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid side effect operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+			
+				if ( list != NULL ) {
+					if ( seffect->read_context != NULL && !seffect->read_context
+						(seffect, renv, address, &context) ) {
+						sieve_runtime_trace_error(renv, "invalid side effect context");
+						return SIEVE_EXEC_BIN_CORRUPT;
+					}
+				
+					sieve_side_effects_list_add(*list, seffect, context);
+				}
+			}
+		}
+	}
+	return TRUE;
+}
+ 
+/* 
+ * Code execute 
+ */
+
+static int sieve_interpreter_execute_operation
+(struct sieve_interpreter *interp) 
+{
+	const struct sieve_operation *op;
+
+	interp->current_op_addr = interp->pc;
+	interp->current_op = op =
+		sieve_operation_read(interp->runenv.sbin, &(interp->pc));
+
+	if ( op != NULL ) {
+		int result = SIEVE_EXEC_OK;
+
+		if ( op->execute != NULL ) { /* Noop ? */
+			T_BEGIN {
+				result = op->execute(op, &(interp->runenv), &(interp->pc));
+			} T_END;
+		} else {
+			sieve_runtime_trace(&interp->runenv, "OP: %s (NOOP)", op->mnemonic);
+		}
+
+		return result;
+	}
+	
+	sieve_runtime_trace(&interp->runenv, "Encountered invalid operation");	
+	return SIEVE_EXEC_BIN_CORRUPT;
+}		
+
+int sieve_interpreter_continue
+(struct sieve_interpreter *interp, bool *interrupted) 
+{
+	int ret = SIEVE_EXEC_OK;
+	
+	sieve_result_ref(interp->runenv.result);
+	interp->interrupted = FALSE;
+	
+	if ( interrupted != NULL )
+		*interrupted = FALSE;
+	
+	while ( ret == SIEVE_EXEC_OK && !interp->interrupted && 
+		interp->pc < sieve_binary_get_code_size(interp->runenv.sbin) ) {
+		
+		ret = sieve_interpreter_execute_operation(interp);
+
+		if ( ret != SIEVE_EXEC_OK ) {
+			sieve_runtime_trace(&interp->runenv, "[[EXECUTION ABORTED]]");
+		}
+	}
+	
+	if ( interrupted != NULL )
+		*interrupted = interp->interrupted;
+			
+	sieve_result_unref(&interp->runenv.result);
+	return ret;
+}
+
+int sieve_interpreter_start
+(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_message_context *msgctx, 
+	struct sieve_result *result, bool *interrupted) 
+{
+	const struct sieve_interpreter_extension_reg *extrs;
+	unsigned int ext_count, i;
+	
+	interp->runenv.msgdata = msgdata;
+	interp->runenv.result = result;		
+	interp->runenv.scriptenv = senv;
+	interp->runenv.trace_stream = senv->trace_stream;
+
+	if ( senv->exec_status == NULL ) 
+		interp->runenv.exec_status = p_new(interp->pool, struct sieve_exec_status, 1);
+	else
+		interp->runenv.exec_status = senv->exec_status;
+	
+	if ( msgctx == NULL )
+		interp->runenv.msgctx = sieve_message_context_create();
+	else {
+		interp->runenv.msgctx = msgctx;
+		sieve_message_context_ref(msgctx);
+	}
+
+	/* Signal registered extensions that the interpreter is being run */
+	extrs = array_get(&interp->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].int_ext != NULL && extrs[i].int_ext->run != NULL )
+			extrs[i].int_ext->run(&interp->runenv, extrs[i].context);
+	}
+
+	return sieve_interpreter_continue(interp, interrupted); 
+}
+
+int sieve_interpreter_run
+(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, struct sieve_result *result)
+{
+	int ret = 0;
+	
+	sieve_interpreter_reset(interp);
+	sieve_result_ref(result);
+	
+	ret = sieve_interpreter_start(interp, msgdata, senv, NULL, result, NULL);
+	
+	sieve_result_unref(&result);
+	
+	return ret;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-interpreter.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,174 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_INTERPRETER_H
+#define __SIEVE_INTERPRETER_H
+
+#include "lib.h"
+#include "array.h"
+#include "buffer.h"
+#include "mail-storage.h"
+
+#include "sieve-common.h"
+
+/*
+ * Forward declarations
+ */
+ 
+struct sieve_interpreter;
+
+/*
+ * Runtime environment
+ */
+
+struct sieve_runtime_env {
+	struct sieve_interpreter *interp;
+
+	struct sieve_script *script;
+	const struct sieve_script_env *scriptenv;
+	
+	const struct sieve_message_data *msgdata;
+	struct sieve_message_context *msgctx;
+
+	struct sieve_binary *sbin;
+	struct sieve_result *result;
+	
+	struct sieve_exec_status *exec_status;
+	struct ostream *trace_stream;
+};
+
+/* 
+ * Interpreter 
+ */
+
+struct sieve_interpreter *sieve_interpreter_create
+	(struct sieve_binary *sbin, struct sieve_error_handler *ehandler);
+void sieve_interpreter_free(struct sieve_interpreter **interp);
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_interpreter_pool
+	(struct sieve_interpreter *interp);
+struct sieve_script *sieve_interpreter_script
+	(struct sieve_interpreter *interp);
+struct sieve_error_handler *sieve_interpreter_get_error_handler
+	(struct sieve_interpreter *interp);
+
+/* Do not use this function for normal sieve extensions. This is intended for
+ * the testsuite only.
+ */
+void sieve_interpreter_set_result
+	(struct sieve_interpreter *interp, struct sieve_result *result);
+
+/*
+ * Program flow
+ */
+
+void sieve_interpreter_reset
+	(struct sieve_interpreter *interp);
+void sieve_interpreter_interrupt
+	(struct sieve_interpreter *interp);
+sieve_size_t sieve_interpreter_program_counter
+	(struct sieve_interpreter *interp);
+
+int sieve_interpreter_program_jump
+	(struct sieve_interpreter *interp, bool jump);
+	
+/*
+ * Test results
+ */	
+	
+void sieve_interpreter_set_test_result
+	(struct sieve_interpreter *interp, bool result);
+bool sieve_interpreter_get_test_result
+	(struct sieve_interpreter *interp);
+	
+/* 
+ * Error handling 
+ */
+
+/* This is not particularly user-friendly, so avoid using this.. */
+const char *sieve_runtime_location(const struct sieve_runtime_env *runenv);
+
+void sieve_runtime_error
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_runtime_warning
+	(const struct sieve_runtime_env *runenv, const char *location,
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_runtime_log
+	(const struct sieve_runtime_env *runenv, const char *location, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+/* 
+ * Runtime Trace 
+ */
+
+#ifdef SIEVE_RUNTIME_TRACE
+		
+void _sieve_runtime_trace
+	(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void _sieve_runtime_trace_error
+	(const struct sieve_runtime_env *runenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+		
+# define sieve_runtime_trace(runenv, ...) STMT_START { \
+		if ( (runenv)->trace_stream != NULL ) \
+			_sieve_runtime_trace((runenv), __VA_ARGS__); \
+	} STMT_END
+# define sieve_runtime_trace_error(runenv, ...) STMT_START { \
+		if ( (runenv)->trace_stream != NULL ) \
+			_sieve_runtime_trace_error((runenv), __VA_ARGS__); \
+		} STMT_END	
+
+#else
+# define sieve_runtime_trace(runenv, ...)
+# define sieve_runtime_trace_error(runenv, ...)
+#endif
+
+/* 
+ * Extension support 
+ */
+
+struct sieve_interpreter_extension {
+	const struct sieve_extension *ext;	
+
+	void (*run)(const struct sieve_runtime_env *renv, void *context);
+	void (*free)(struct sieve_interpreter *interp, void *context);
+};
+
+void sieve_interpreter_extension_register
+	(struct sieve_interpreter *interp, 
+		const struct sieve_interpreter_extension *int_ext, void *context);
+void sieve_interpreter_extension_set_context
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext, 
+		void *context);
+void *sieve_interpreter_extension_get_context
+	(struct sieve_interpreter *interp, const struct sieve_extension *ext); 
+
+/* 
+ * Opcodes and operands 
+ */
+	
+int sieve_interpreter_handle_optional_operands
+	(const struct sieve_runtime_env *renv, sieve_size_t *address,
+		struct sieve_side_effects_list **list);
+
+/* 
+ * Code execute 
+ */
+
+int sieve_interpreter_continue
+	(struct sieve_interpreter *interp, bool *interrupted);
+int sieve_interpreter_start
+	(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_message_context *msgctx, 
+		struct sieve_result *result, bool *interrupted);
+int sieve_interpreter_run
+	(struct sieve_interpreter *interp, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, struct sieve_result *result);
+
+#endif /* __SIEVE_INTERPRETER_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-lexer.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-lexer.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-lexer.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-lexer.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,808 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include "lib.h"
+#include "compat.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "istream.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-error.h"
+#include "sieve-script.h"
+
+#include "sieve-lexer.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+
+/* 
+ * Useful macros
+ */
+
+#define DIGIT_VAL(c) ( c - '0' )
+
+/*
+ * Forward declarations
+ */
+ 
+inline static void sieve_lexer_error
+	(struct sieve_lexer *lexer, const char *fmt, ...) ATTR_FORMAT(2, 3);
+inline static void sieve_lexer_warning
+	(struct sieve_lexer *lexer, const char *fmt, ...) ATTR_FORMAT(2, 3);
+
+/*
+ * Lexer object
+ */
+
+struct sieve_lexer {
+	pool_t pool;
+
+	struct sieve_script *script;
+	struct istream *input;
+		
+	int current_line;
+	
+	enum sieve_token_type token_type;
+	string_t *token_str_value;
+	int token_int_value;
+	
+	struct sieve_error_handler *ehandler;
+	
+	/* Currently scanned data */
+	const unsigned char *buffer;
+	size_t buffer_size;
+	size_t buffer_pos;
+};
+
+struct sieve_lexer *sieve_lexer_create
+(struct sieve_script *script, struct sieve_error_handler *ehandler) 
+{
+	pool_t pool;
+	struct sieve_lexer *lexer;
+	struct istream *stream;
+	
+	stream = sieve_script_open(script, NULL);
+	if ( stream == NULL )
+		return NULL;
+	
+	pool = pool_alloconly_create("sieve_lexer", 1024);	
+	lexer = p_new(pool, struct sieve_lexer, 1);
+	lexer->pool = pool;
+	
+	lexer->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+
+	lexer->input = stream;
+	i_stream_ref(lexer->input);
+	
+	lexer->script = script;
+	sieve_script_ref(script);
+	
+	lexer->buffer = NULL;
+	lexer->buffer_size = 0;
+	lexer->buffer_pos = 0;
+	
+	lexer->current_line = 1;	
+	lexer->token_type = STT_NONE;
+	lexer->token_str_value = str_new(pool, 256);
+	lexer->token_int_value = 0;
+		
+	return lexer;
+}
+
+void sieve_lexer_free(struct sieve_lexer **lexer) 
+{	
+	i_stream_unref(&(*lexer)->input);
+
+	sieve_script_close((*lexer)->script);
+	sieve_script_unref(&(*lexer)->script);
+
+	sieve_error_handler_unref(&(*lexer)->ehandler);
+
+	pool_unref(&(*lexer)->pool); 
+
+	*lexer = NULL;
+}
+
+/*
+ * Internal error handling
+ */
+
+inline static void sieve_lexer_error
+(struct sieve_lexer *lexer, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN {
+		sieve_verror(lexer->ehandler, 
+			sieve_error_script_location(lexer->script, lexer->current_line),
+			fmt, args);
+	} T_END;
+		
+	va_end(args);
+}
+
+inline static void sieve_lexer_warning
+(struct sieve_lexer *lexer, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN { 
+		sieve_vwarning(lexer->ehandler, 
+			sieve_error_script_location(lexer->script, lexer->current_line),
+			fmt, args);
+	} T_END;
+		
+	va_end(args);
+}
+
+const char *sieve_lexer_token_string(struct sieve_lexer *lexer) 
+{
+	switch ( lexer->token_type ) {
+		case STT_NONE: return "no token (bug)"; 		
+		case STT_WHITESPACE: return "whitespace (bug)";
+		case STT_EOF: return "end of file";
+  
+		case STT_NUMBER: return "number"; 
+		case STT_IDENTIFIER: return "identifier"; 
+		case STT_TAG: return "tag";
+		case STT_STRING: return "string"; 
+  
+		case STT_RBRACKET: return "')'"; 
+		case STT_LBRACKET: return "'('";
+		case STT_RCURLY: return "'}'"; 
+		case STT_LCURLY: return "'{'"; 
+		case STT_RSQUARE: return "']'"; 
+		case STT_LSQUARE: return "'['"; 
+		case STT_SEMICOLON: return "';'"; 
+		case STT_COMMA: return "','"; 
+  	
+		case STT_SLASH: return "'/'";  
+		case STT_COLON: return "':'";   
+  
+		case STT_GARBAGE: return "unknown characters"; 
+		case STT_ERROR: return "error token (bug)";
+	}
+   
+	return "unknown token (bug)";
+}
+	
+/* 
+ * Debug 
+ */
+ 
+void sieve_lexer_print_token(struct sieve_lexer *lexer) 
+{
+	switch ( lexer->token_type ) {
+		case STT_NONE: printf("??NONE?? "); break;		
+		case STT_WHITESPACE: printf("??WHITESPACE?? "); break;
+		case STT_EOF: printf("EOF\n"); break;
+  
+		case STT_NUMBER: printf("NUMBER "); break;
+		case STT_IDENTIFIER: printf("IDENTIFIER "); break;
+		case STT_TAG: printf("TAG "); break;
+		case STT_STRING: printf("STRING "); break;
+  
+		case STT_RBRACKET: printf(") "); break;
+		case STT_LBRACKET: printf("( "); break;
+		case STT_RCURLY: printf("}\n"); break;
+		case STT_LCURLY: printf("{\n"); break;
+		case STT_RSQUARE: printf("] "); break;
+		case STT_LSQUARE: printf("[ "); break;
+		case STT_SEMICOLON: printf(";\n"); break;
+		case STT_COMMA: printf(", "); break;
+  
+		case STT_SLASH: printf("/ "); break; 
+		case STT_COLON: printf(": "); break;  
+  	
+		case STT_GARBAGE: printf(">>GARBAGE<<"); break;
+		case STT_ERROR: printf(">>ERROR<<"); break;
+	default: 
+		printf("UNKNOWN ");
+		break;
+	}
+}
+
+/*
+ * Token access
+ */ 
+
+enum sieve_token_type sieve_lexer_current_token(struct sieve_lexer *lexer) 
+{
+	return lexer->token_type;
+}
+
+const string_t *sieve_lexer_token_str(struct sieve_lexer *lexer) 
+{
+	i_assert(	lexer->token_type == STT_STRING );
+		
+	return lexer->token_str_value;
+}
+
+const char *sieve_lexer_token_ident(struct sieve_lexer *lexer) 
+{
+	i_assert(
+		lexer->token_type == STT_TAG ||
+		lexer->token_type == STT_IDENTIFIER);
+		
+	return str_c(lexer->token_str_value);
+}
+
+int sieve_lexer_token_int(struct sieve_lexer *lexer) 
+{
+	i_assert(lexer->token_type == STT_NUMBER);
+		
+	return lexer->token_int_value;
+}
+
+bool sieve_lexer_eof(struct sieve_lexer *lexer) 
+{
+	return lexer->token_type == STT_EOF;
+}
+
+int sieve_lexer_current_line(struct sieve_lexer *lexer) 
+{
+	return lexer->current_line;
+}
+
+/*
+ * Lexical scanning 
+ */
+
+static void sieve_lexer_shift(struct sieve_lexer *lexer) 
+{
+	if ( lexer->buffer != NULL && lexer->buffer[lexer->buffer_pos] == '\n' ) 
+		lexer->current_line++;	
+	
+	if ( lexer->buffer != NULL && lexer->buffer_pos + 1 < lexer->buffer_size )
+		lexer->buffer_pos++;
+	else {
+		if ( lexer->buffer != NULL )
+			i_stream_skip(lexer->input, lexer->buffer_size);
+		
+		lexer->buffer = i_stream_get_data(lexer->input, &lexer->buffer_size);
+	  
+		if ( lexer->buffer == NULL && i_stream_read(lexer->input) > 0 )
+	  		lexer->buffer = i_stream_get_data(lexer->input, &lexer->buffer_size);
+	  	
+		lexer->buffer_pos = 0;
+	}
+}
+
+static inline int sieve_lexer_curchar(struct sieve_lexer *lexer) 
+{	
+	if ( lexer->buffer == NULL )
+		return -1;
+	
+	return lexer->buffer[lexer->buffer_pos];
+}
+
+static inline const char *_char_sanitize(int ch)
+{
+	if ( ch > 31 && ch < 127 )
+		return t_strdup_printf("'%c'", ch);
+	
+	return t_strdup_printf("0x%02x", ch);
+}
+
+/* sieve_lexer_scan_raw_token:
+ *   Scans valid tokens and whitespace 
+ */
+static bool sieve_lexer_scan_raw_token(struct sieve_lexer *lexer) 
+{
+	sieve_number_t start_line;
+	string_t *str;
+
+	/* Read first character */
+	if ( lexer->token_type == STT_NONE ) {
+		i_stream_read(lexer->input);
+		sieve_lexer_shift(lexer);
+	}
+  
+	switch ( sieve_lexer_curchar(lexer) ) {
+	
+	/* whitespace */
+	
+	// hash-comment = ( "#" *CHAR-NOT-CRLF CRLF )
+	case '#': 
+		sieve_lexer_shift(lexer);
+		while ( sieve_lexer_curchar(lexer) != '\n' ) {
+			switch( sieve_lexer_curchar(lexer) ) {
+			case -1:
+				sieve_lexer_error(lexer, "end of file before end of hash comment");
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			case '\0':
+				sieve_lexer_error(lexer, "encountered NUL character in hash comment");
+				lexer->token_type = STT_ERROR;
+				return FALSE;				
+			default:
+				break;
+			}
+						
+			/* Stray CR is ignored */
+			
+			sieve_lexer_shift(lexer);
+		} 
+
+		sieve_lexer_shift(lexer);
+		
+		lexer->token_type = STT_WHITESPACE;
+		return TRUE;
+		
+	// bracket-comment = "/*" *(CHAR-NOT-STAR / ("*" CHAR-NOT-SLASH)) "*/"
+	//        ;; No */ allowed inside a comment.
+	//        ;; (No * is allowed unless it is the last character,
+	//        ;; or unless it is followed by a character that isn't a
+	//        ;; slash.)
+	case '/': 
+		start_line = lexer->current_line;
+		sieve_lexer_shift(lexer);
+		
+		if ( sieve_lexer_curchar(lexer) == '*' ) { 
+			sieve_lexer_shift(lexer);
+			
+			while ( TRUE ) {
+				switch ( sieve_lexer_curchar(lexer) ) {
+				case -1:
+					sieve_lexer_error(lexer, 
+						"end of file before end of bracket comment ('/* ... */') "
+						"started at line %d", start_line);
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				case '*':
+					sieve_lexer_shift(lexer);
+					
+					if ( sieve_lexer_curchar(lexer) == '/' ) {
+						sieve_lexer_shift(lexer);
+						
+						lexer->token_type = STT_WHITESPACE;
+						return TRUE;
+						
+					} else if ( sieve_lexer_curchar(lexer) == -1 ) {
+						sieve_lexer_error(lexer, 
+							"end of file before end of bracket comment ('/* ... */') "
+							"started at line %d", start_line);
+						lexer->token_type = STT_ERROR;
+						return FALSE;
+					}
+					break;
+				case '\0':
+					sieve_lexer_error(lexer, 
+						"encountered NUL character in bracket comment");
+					lexer->token_type = STT_ERROR;
+					return FALSE;				
+				default:
+					sieve_lexer_shift(lexer);
+				}
+			}
+			
+			i_unreached();
+			return FALSE;
+		}
+		
+		lexer->token_type = STT_SLASH;
+		return TRUE;
+		
+	// comment = bracket-comment / hash-comment
+  	// white-space = 1*(SP / CRLF / HTAB) / comment
+	case '\t':
+	case '\r':
+	case '\n':
+	case ' ':
+		sieve_lexer_shift(lexer);
+		
+		while ( sieve_lexer_curchar(lexer) == '\t' ||
+			sieve_lexer_curchar(lexer) == '\r' ||
+			sieve_lexer_curchar(lexer) == '\n' ||
+			sieve_lexer_curchar(lexer) == ' ' ) {
+			
+			sieve_lexer_shift(lexer);
+		}
+		
+		lexer->token_type = STT_WHITESPACE;
+		return TRUE;
+		
+	/* quoted-string */
+	case '"':
+		start_line = lexer->current_line;
+		sieve_lexer_shift(lexer);
+		str_truncate(lexer->token_str_value, 0);
+		str = lexer->token_str_value;
+		
+		while ( sieve_lexer_curchar(lexer) != '"' ) {
+			if ( sieve_lexer_curchar(lexer) == '\\' ) {
+				sieve_lexer_shift(lexer);
+			}
+
+			switch ( sieve_lexer_curchar(lexer) ) {
+		
+			/* End of file */			
+			case -1:
+				sieve_lexer_error(lexer, 
+					"end of file before end of quoted string "
+					"started at line %d", start_line);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+
+			/* NUL character */
+			case '\0':
+				sieve_lexer_error(lexer,
+					"encountered NUL character in quoted string "
+					"started at line %d", start_line);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+
+			/* CR .. check for LF */
+			case '\r':
+				sieve_lexer_shift(lexer);
+
+				if ( sieve_lexer_curchar(lexer) != '\n' ) {
+					sieve_lexer_error(lexer, 
+						"found stray carriage-return (CR) character "
+						"in quoted string started at line %d", start_line);
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				}
+
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+					str_append(str, "\r\n");
+				break;
+
+			/* Loose LF is allowed (non-standard) and converted to CRLF */
+			case '\n':
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+					str_append(str, "\r\n");
+				break;
+
+			/* Other characters */
+			default:
+				if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+					str_append_c(str, sieve_lexer_curchar(lexer));
+			}
+
+			sieve_lexer_shift(lexer);							
+		}
+
+		sieve_lexer_shift(lexer);
+
+		if ( str_len(str) > SIEVE_MAX_STRING_LEN ) {
+			sieve_lexer_error(lexer, 
+				"quoted string started at line %d is too long "
+				"(longer than %llu bytes)", start_line,
+				(long long) SIEVE_MAX_STRING_LEN);
+			lexer->token_type = STT_ERROR;
+			return FALSE;
+		}
+		
+		lexer->token_type = STT_STRING;
+		return TRUE;
+		
+	/* single character tokens */
+	case ']':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RSQUARE;
+		return TRUE;
+	case '[':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LSQUARE;
+		return TRUE;
+	case '}':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RCURLY;
+		return TRUE;
+	case '{':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LCURLY;
+		return TRUE;
+	case ')':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_RBRACKET;
+		return TRUE;
+	case '(':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_LBRACKET;	
+		return TRUE;
+	case ';':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_SEMICOLON;
+		return TRUE;
+	case ',':
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_COMMA;
+		return TRUE;
+		
+	/* EOF */	
+	case -1: 
+	  lexer->token_type = STT_EOF;
+		return TRUE;
+		
+	default: 
+		/* number */
+		if ( i_isdigit(sieve_lexer_curchar(lexer)) ) {
+			sieve_number_t value = DIGIT_VAL(sieve_lexer_curchar(lexer));
+			bool overflow = FALSE;
+
+			sieve_lexer_shift(lexer);
+  		
+			while ( i_isdigit(sieve_lexer_curchar(lexer)) ) {
+				sieve_number_t valnew = 
+					value * 10 + DIGIT_VAL(sieve_lexer_curchar(lexer));
+			
+				/* Check for integer wrap */
+				if ( valnew < value )
+					overflow = TRUE;
+
+				value = valnew;
+				sieve_lexer_shift(lexer);
+ 			}
+  		
+			switch ( sieve_lexer_curchar(lexer) ) { 
+			case 'k':
+			case 'K': /* Kilo */
+				if ( value > (SIEVE_MAX_NUMBER >> 10) )
+					overflow = TRUE;
+				else
+					value = value << 10;
+				sieve_lexer_shift(lexer);
+				break;
+			case 'm': 
+			case 'M': /* Mega */
+				if ( value > (SIEVE_MAX_NUMBER >> 20) )
+					overflow = TRUE;
+				else
+					value = value << 20;
+				sieve_lexer_shift(lexer);
+				break;
+			case 'g':
+			case 'G': /* Giga */
+				if ( value > (SIEVE_MAX_NUMBER >> 30) )
+					overflow = TRUE;
+				else
+					value = value << 30;
+				sieve_lexer_shift(lexer);
+				break;
+			default:
+				/* Next token */
+				break;
+			}
+
+			/* Check for integer wrap */
+			if ( overflow ) {
+				sieve_lexer_error(lexer,
+					"number exceeds integer limits (max %llu)",
+					(long long) SIEVE_MAX_NUMBER);
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+  	
+			lexer->token_type = STT_NUMBER;
+			lexer->token_int_value = value;
+			return TRUE;	
+  		
+		/* identifier / tag */	
+		} else if ( i_isalpha(sieve_lexer_curchar(lexer)) ||
+			sieve_lexer_curchar(lexer) == '_' || 
+			sieve_lexer_curchar(lexer) == ':' ) {
+  		
+			enum sieve_token_type type = STT_IDENTIFIER;
+			str_truncate(lexer->token_str_value,0);
+			str = lexer->token_str_value;
+  		
+			/* If it starts with a ':' it is a tag and not an identifier */
+ 			if ( sieve_lexer_curchar(lexer) == ':' ) {
+				sieve_lexer_shift(lexer); // discard colon
+				type = STT_TAG;
+  			
+				/* First character still can't be a DIGIT */
+ 				if ( i_isalpha(sieve_lexer_curchar(lexer)) ||
+					sieve_lexer_curchar(lexer) == '_' ) { 
+					str_append_c(str, sieve_lexer_curchar(lexer));
+					sieve_lexer_shift(lexer);
+				} else {
+					/* Hmm, otherwise it is just a spurious colon */
+					lexer->token_type = STT_COLON;
+					return TRUE;
+				}
+			} else {
+				str_append_c(str, sieve_lexer_curchar(lexer));
+				sieve_lexer_shift(lexer);
+			}
+  		
+			/* Scan the rest of the identifier */
+			while ( i_isalnum(sieve_lexer_curchar(lexer)) ||
+				sieve_lexer_curchar(lexer) == '_' ) {
+
+				if ( str_len(str) <= SIEVE_MAX_IDENTIFIER_LEN ) {
+	 				str_append_c(str, sieve_lexer_curchar(lexer));
+				}
+				sieve_lexer_shift(lexer);
+			}
+
+			/* Is this in fact a multiline text string ? */
+			if ( sieve_lexer_curchar(lexer) == ':' &&
+				type == STT_IDENTIFIER && str_len(str) == 4 &&
+				strncasecmp(str_c(str), "text", 4) == 0 ) {
+				sieve_lexer_shift(lexer); // discard colon
+
+				start_line = lexer->current_line;
+  			
+				/* Discard SP and HTAB whitespace */
+				while ( sieve_lexer_curchar(lexer) == ' ' || 
+					sieve_lexer_curchar(lexer) == '\t' )
+ 					sieve_lexer_shift(lexer);
+  				
+				/* Discard hash comment or handle single CRLF */
+				switch ( sieve_lexer_curchar(lexer) ) {
+				case '#':
+					while ( sieve_lexer_curchar(lexer) != '\n' )
+						sieve_lexer_shift(lexer);
+					break;
+				case '\r':
+					sieve_lexer_shift(lexer);
+					break;
+				}
+  			
+				/* Terminating LF required */
+ 				switch ( sieve_lexer_curchar(lexer) ) {
+				case '\n':
+					sieve_lexer_shift(lexer);
+					break;
+				case -1:
+					sieve_lexer_error(lexer, 
+						"end of file before end of multi-line string");
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				default: 
+ 					sieve_lexer_error(lexer, 
+ 						"invalid character %s after 'text:' in multiline string",
+						_char_sanitize(sieve_lexer_curchar(lexer)));
+					lexer->token_type = STT_ERROR;
+					return FALSE;
+				}
+  			
+				/* Start over */
+				str_truncate(str, 0); 
+  			
+ 				/* Parse literal lines */
+				while ( TRUE ) {
+					bool cr_shifted = FALSE;
+
+					/* Remove dot-stuffing or detect end of text */
+					if ( sieve_lexer_curchar(lexer) == '.' ) {
+						sieve_lexer_shift(lexer);
+  					
+						/* Check for CR.. */
+						if ( sieve_lexer_curchar(lexer) == '\r' ) {
+							sieve_lexer_shift(lexer);
+							cr_shifted = TRUE;
+						}
+  				
+						/* ..LF */
+						if ( sieve_lexer_curchar(lexer) == '\n' ) {
+							sieve_lexer_shift(lexer);
+
+							/* End of multi-line string */
+
+							/* Check whether length limit was violated */
+							if ( str_len(str) > SIEVE_MAX_STRING_LEN ) {
+								sieve_lexer_error(lexer, 
+									"multi-line string started at line %d is too long "
+									"(longer than %llu bytes)", start_line,
+									(long long) SIEVE_MAX_STRING_LEN);
+									lexer->token_type = STT_ERROR;
+									return FALSE;
+							}
+
+							lexer->token_type = STT_STRING;
+							return TRUE;
+						} else if ( cr_shifted ) {
+							/* Seen CR, but no LF */
+							sieve_lexer_error(lexer, 
+								"found stray carriage-return (CR) character "
+								"in multi-line string started at line %d", start_line);
+							lexer->token_type = STT_ERROR;
+							return FALSE;
+						}
+
+						/* Handle dot-stuffing */
+						if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+							str_append_c(str, '.');
+						if ( sieve_lexer_curchar(lexer) == '.' )
+							sieve_lexer_shift(lexer);
+					}
+  				
+					/* Scan the rest of the line */
+					while ( sieve_lexer_curchar(lexer) != '\n' &&
+						sieve_lexer_curchar(lexer) != '\r' ) {
+
+						switch ( sieve_lexer_curchar(lexer) ) {
+						case -1:
+							sieve_lexer_error(lexer, 
+								"end of file before end of multi-line string");
+ 							lexer->token_type = STT_ERROR;
+ 							return FALSE;
+						case '\0':
+							sieve_lexer_error(lexer,
+								"encountered NUL character in quoted string "
+								"started at line %d", start_line);
+							lexer->token_type = STT_ERROR;
+							return FALSE;
+						default:
+							if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+  								str_append_c(str, sieve_lexer_curchar(lexer));
+						}
+
+						sieve_lexer_shift(lexer);
+					}
+
+					/* If exited loop due to CR, skip it */
+					if ( sieve_lexer_curchar(lexer) == '\r' ) {
+						sieve_lexer_shift(lexer);
+					}
+
+					/* Now we must see an LF */
+					if ( sieve_lexer_curchar(lexer) != '\n' ) {					
+						sieve_lexer_error(lexer, 
+							"found stray carriage-return (CR) character "
+							"in multi-line string started at line %d", start_line);
+ 						lexer->token_type = STT_ERROR;
+ 						return FALSE;
+					}
+						
+					if ( str_len(str) <= SIEVE_MAX_STRING_LEN ) 
+						str_append(str, "\r\n");
+
+					sieve_lexer_shift(lexer);
+				}
+  			
+ 				i_unreached();
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+
+			if ( str_len(str) > SIEVE_MAX_IDENTIFIER_LEN ) {
+				sieve_lexer_error(lexer, 
+					"encountered impossibly long %s%s'",
+					(type == STT_TAG ? "tag identifier ':" : "identifier '"), 
+					str_sanitize(str_c(str), SIEVE_MAX_IDENTIFIER_LEN));
+				lexer->token_type = STT_ERROR;
+				return FALSE;
+			}
+  			
+			lexer->token_type = type;
+			return TRUE;
+		}
+	
+		/* Error (unknown character and EOF handled already) */
+		if ( lexer->token_type != STT_GARBAGE ) 
+			sieve_lexer_error(lexer, "unexpected character(s) starting with %s", 
+				_char_sanitize(sieve_lexer_curchar(lexer)));
+		sieve_lexer_shift(lexer);
+		lexer->token_type = STT_GARBAGE;
+		return FALSE;
+	}
+}
+
+bool sieve_lexer_skip_token(struct sieve_lexer *lexer) 
+{
+	/* Scan token */
+	if ( !sieve_lexer_scan_raw_token(lexer) ) return FALSE;
+	
+	/* Skip any whitespace */	
+	while ( lexer->token_type == STT_WHITESPACE ) {
+		if ( !sieve_lexer_scan_raw_token(lexer) ) return FALSE;
+	}
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-lexer.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-lexer.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-lexer.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-lexer.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,62 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_LEXER_H
+#define __SIEVE_LEXER_H
+
+#include "sieve-common.h"
+
+enum sieve_token_type {
+	STT_NONE,
+	STT_WHITESPACE,
+	STT_EOF,
+  
+	STT_NUMBER,
+	STT_IDENTIFIER,
+	STT_TAG,
+	STT_STRING,
+  
+	STT_RBRACKET,
+	STT_LBRACKET,
+	STT_RCURLY,
+	STT_LCURLY,
+	STT_RSQUARE,
+	STT_LSQUARE,
+	STT_SEMICOLON,
+	STT_COMMA,
+  
+	/* These are currently not used in the lexical specification, but a token
+	 * is assigned to these to generate proper error messages (these are
+	 * technically not garbage and possibly part of mistyped but otherwise
+	 * valid tokens).
+	 */
+	STT_SLASH, 
+	STT_COLON, 
+  
+	/* Error tokens */
+	STT_GARBAGE, /* Error reporting deferred to parser */ 
+	STT_ERROR    /* Lexer is responsible for error, parser won't report additional 
+	                errors */
+};
+
+struct sieve_lexer;
+
+/* Lexer object */
+struct sieve_lexer *sieve_lexer_create
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+void sieve_lexer_free(struct sieve_lexer **lexer);
+
+/* Scanning */
+bool sieve_lexer_skip_token(struct sieve_lexer *lexer);
+const char *sieve_lexer_token_string(struct sieve_lexer *lexer);
+void sieve_lexer_print_token(struct sieve_lexer *lexer);
+
+/* Token access */
+enum sieve_token_type sieve_lexer_current_token(struct sieve_lexer *lexer);
+const string_t *sieve_lexer_token_str(struct sieve_lexer *lexer);
+const char *sieve_lexer_token_ident(struct sieve_lexer *lexer);
+int sieve_lexer_token_int(struct sieve_lexer *lexer);
+int sieve_lexer_current_line(struct sieve_lexer *lexer);
+bool sieve_lexer_eof(struct sieve_lexer *lexer);
+
+#endif /* __SIEVE_LEXER_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-limits.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-limits.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-limits.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-limits.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,9 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+
+unsigned int sieve_max_actions = SIEVE_DEFAULT_MAX_ACTIONS;
+unsigned int sieve_max_redirects = SIEVE_DEFAULT_MAX_REDIRECTS;
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-limits.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-limits.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-limits.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-limits.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,38 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_LIMITS_H
+#define __SIEVE_LIMITS_H
+
+/*
+ * Lexer
+ */
+
+#define SIEVE_MAX_STRING_LEN        (1 << 20)
+#define SIEVE_MAX_IDENTIFIER_LEN    32
+
+/*
+ * AST
+ */
+
+#define SIEVE_MAX_COMMAND_ARGUMENTS 32
+#define SIEVE_MAX_BLOCK_NESTING     32
+#define SIEVE_MAX_TEST_NESTING      32
+
+/*
+ * Runtime
+ */
+
+#define SIEVE_MAX_MATCH_VALUES      32
+
+/*
+ * Actions
+ */
+
+#define SIEVE_DEFAULT_MAX_ACTIONS   32
+#define SIEVE_DEFAULT_MAX_REDIRECTS 4
+
+extern unsigned int sieve_max_actions;
+extern unsigned int sieve_max_redirects;
+
+#endif /* __SIEVE_LIMITS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,186 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+
+#include "sieve-match.h"
+
+/*
+ * Matching implementation
+ */
+
+struct sieve_match_context *sieve_match_begin
+(struct sieve_interpreter *interp, const struct sieve_match_type *mtch, 
+	const struct sieve_comparator *cmp, 
+	const struct sieve_match_key_extractor *kextract,
+	struct sieve_coded_stringlist *key_list)
+{
+	struct sieve_match_context *mctx = t_new(struct sieve_match_context, 1);  
+
+	mctx->interp = interp;
+	mctx->match_type = mtch;
+	mctx->comparator = cmp;
+	mctx->kextract = kextract;
+	mctx->key_list = key_list;
+
+	if ( mtch->match_init != NULL ) {
+		mtch->match_init(mctx);
+	}
+
+	return mctx;
+}
+
+int sieve_match_value
+	(struct sieve_match_context *mctx, const char *value, size_t val_size)
+{
+	const struct sieve_match_type *mtch = mctx->match_type;
+	sieve_coded_stringlist_reset(mctx->key_list);
+	bool ok = TRUE;
+
+	/* Reject unimplemented match-type */
+	if ( mtch->match == NULL )
+		return FALSE;
+				
+	/* Match to all key values */
+	if ( mtch->is_iterative ) {
+		unsigned int key_index = 0;
+		string_t *key_item = NULL;
+	
+		while ( (ok=sieve_coded_stringlist_next_item(mctx->key_list, &key_item)) && 
+			key_item != NULL ) 
+		{	
+			int ret;
+			
+			if ( mctx->kextract != NULL && mtch->allow_key_extract ) {
+				const struct sieve_match_key_extractor *kext = mctx->kextract;
+				void *kctx;
+				
+				if ( (ret=kext->init(&kctx, key_item)) > 0 ) {
+					const char *key;
+					size_t key_size;
+					 			
+					while ( (ret=kext->extract_key(kctx, &key, &key_size)) > 0 ) {				
+						ret = mtch->match(mctx, value, val_size, key, key_size, key_index);
+						
+						if ( ret != 0 ) break;
+					}
+				}  
+			} else {
+				ret = mtch->match(mctx, value, val_size, str_c(key_item), 
+						str_len(key_item), key_index);
+			}
+			
+			if ( ret < 0 ) 
+				return ret;
+
+			if ( ret > 0 )
+				return TRUE;
+	
+			key_index++;
+		}
+
+		if ( !ok ) 
+			return -1;
+
+	} else {
+		return mtch->match(mctx, value, val_size, NULL, 0, -1);
+	}
+
+	return FALSE;
+}
+
+int sieve_match_end(struct sieve_match_context *mctx)
+{
+	const struct sieve_match_type *mtch = mctx->match_type;
+
+	if ( mtch->match_deinit != NULL ) {
+		return mtch->match_deinit(mctx);
+	}
+
+	return FALSE;
+}
+
+/*
+ * Reading match operands
+ */
+ 
+bool sieve_match_dump_optional_operands
+(const struct sieve_dumptime_env *denv, sieve_size_t *address, int *opt_code)
+{
+	if ( *opt_code != SIEVE_MATCH_OPT_END || 
+		sieve_operand_optional_present(denv->sbin, address) ) {
+		do {
+			if ( !sieve_operand_optional_read(denv->sbin, address, opt_code) ) 
+				return FALSE;
+
+			switch ( *opt_code ) {
+			case SIEVE_MATCH_OPT_END:
+				break;
+			case SIEVE_MATCH_OPT_COMPARATOR:
+				if ( !sieve_opr_comparator_dump(denv, address) )
+					return FALSE;
+				break;
+			case SIEVE_MATCH_OPT_MATCH_TYPE:
+				if ( !sieve_opr_match_type_dump(denv, address) )
+					return FALSE;
+				break;
+			default: 
+				return TRUE;
+			}
+ 		} while ( *opt_code != SIEVE_MATCH_OPT_END );
+	}
+	
+	return TRUE;
+}
+
+int sieve_match_read_optional_operands
+(const struct sieve_runtime_env *renv, sieve_size_t *address, int *opt_code,
+	const struct sieve_comparator **cmp_r, const struct sieve_match_type **mtch_r)
+{	 
+	/* Handle any optional arguments */
+	if ( *opt_code != SIEVE_MATCH_OPT_END || 
+		sieve_operand_optional_present(renv->sbin, address) ) {
+		do {
+			if ( !sieve_operand_optional_read(renv->sbin, address, opt_code) ) {
+				sieve_runtime_trace_error(renv, "invalid optional operand");
+				return SIEVE_EXEC_BIN_CORRUPT;
+			}
+
+			switch ( *opt_code ) {
+			case SIEVE_MATCH_OPT_END: 
+				break;
+			case SIEVE_MATCH_OPT_COMPARATOR:
+				if ( (*cmp_r = sieve_opr_comparator_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid comparator operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			case SIEVE_MATCH_OPT_MATCH_TYPE:
+				if ( (*mtch_r = sieve_opr_match_type_read(renv, address)) == NULL ) {
+					sieve_runtime_trace_error(renv, "invalid match type operand");
+					return SIEVE_EXEC_BIN_CORRUPT;
+				}
+				break;
+			default:
+				return SIEVE_EXEC_OK;
+			}
+		} while ( *opt_code != SIEVE_MATCH_OPT_END );
+	}
+	
+	return SIEVE_EXEC_OK;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,62 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_MATCH_H
+#define __SIEVE_MATCH_H
+
+#include "sieve-common.h"
+
+/*
+ * Matching context
+ */
+ 
+struct sieve_match_key_extractor {
+	int (*init)(void **context, string_t *raw_key);
+	int (*extract_key)(void *context, const char **key, size_t *size);
+};
+
+struct sieve_match_context {
+	struct sieve_interpreter *interp;
+	const struct sieve_match_type *match_type;
+	const struct sieve_comparator *comparator;
+	const struct sieve_match_key_extractor *kextract;
+
+	struct sieve_coded_stringlist *key_list;
+
+
+	void *data;
+};
+
+/*
+ * Matching implementation
+ */
+
+struct sieve_match_context *sieve_match_begin
+	(struct sieve_interpreter *interp, const struct sieve_match_type *mtch, 
+		const struct sieve_comparator *cmp, 
+		const struct sieve_match_key_extractor *kextract,
+		struct sieve_coded_stringlist *key_list);
+int sieve_match_value
+	(struct sieve_match_context *mctx, const char *value, size_t val_size);
+int sieve_match_end(struct sieve_match_context *mctx);
+
+/*
+ * Read matching operands
+ */
+ 
+enum sieve_match_opt_operand {
+	SIEVE_MATCH_OPT_END,
+	SIEVE_MATCH_OPT_COMPARATOR,
+	SIEVE_MATCH_OPT_MATCH_TYPE,
+	SIEVE_MATCH_OPT_LAST
+};
+
+bool sieve_match_dump_optional_operands
+	(const struct sieve_dumptime_env *denv, sieve_size_t *addres, int *opt_code);
+
+int sieve_match_read_optional_operands
+	(const struct sieve_runtime_env *renv, sieve_size_t *address, int *opt_code,
+		const struct sieve_comparator **cmp_r, 
+		const struct sieve_match_type **mtch_r);
+
+#endif /* __SIEVE_MATCH_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match-types.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match-types.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match-types.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match-types.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,514 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include <stdio.h>
+
+#include "lib.h"
+#include "compat.h"
+#include "mempool.h"
+#include "hash.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-comparators.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "sieve-match-types.h"
+
+#include <string.h>
+
+/*
+ * Types
+ */
+ 
+struct sieve_match_values {
+	pool_t pool;
+	ARRAY_DEFINE(values, string_t *);
+	unsigned count;
+};
+
+/* 
+ * Default match types
+ */ 
+
+const struct sieve_match_type *sieve_core_match_types[] = {
+	&is_match_type, &contains_match_type, &matches_match_type
+};
+
+const unsigned int sieve_core_match_types_count = 
+	N_ELEMENTS(sieve_core_match_types);
+
+/* 
+ * Match-type 'extension' 
+ */
+
+static bool mtch_validator_load(struct sieve_validator *validator);
+
+static int ext_my_id = -1;
+
+const struct sieve_extension match_type_extension = {
+	"@match-types",
+	&ext_my_id,
+	NULL, NULL,
+	mtch_validator_load,
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_NO_OPERATIONS,
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static const struct sieve_extension *ext_this = &match_type_extension;
+	
+/* 
+ * Validator context:
+ *   name-based match-type registry. 
+ */
+ 
+void sieve_match_type_register
+(struct sieve_validator *validator, const struct sieve_match_type *mtch) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	
+	sieve_validator_object_registry_add(regs, &mtch->object);
+}
+
+const struct sieve_match_type *sieve_match_type_find
+(struct sieve_validator *validator, const char *identifier) 
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_get(validator, ext_this);
+	const struct sieve_object *object = 
+		sieve_validator_object_registry_find(regs, identifier);
+
+  return (const struct sieve_match_type *) object;
+}
+
+bool mtch_validator_load(struct sieve_validator *validator)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_init(validator, ext_this);
+	unsigned int i;
+
+	/* Register core match-types */
+	for ( i = 0; i < sieve_core_match_types_count; i++ ) {
+		sieve_validator_object_registry_add
+			(regs, &(sieve_core_match_types[i]->object));
+	}
+
+	return TRUE;
+}
+
+/* 
+ * Interpreter context
+ */
+
+struct mtch_interpreter_context {
+	struct sieve_match_values *match_values;
+	bool match_values_enabled;
+};
+
+static void mtch_interpreter_free
+(struct sieve_interpreter *interp ATTR_UNUSED, void *context)
+{
+	struct mtch_interpreter_context *mctx = 
+		(struct mtch_interpreter_context *) context;
+	
+	if ( mctx->match_values != NULL ) {
+		pool_unref(&mctx->match_values->pool);
+	}
+}
+
+struct sieve_interpreter_extension mtch_interpreter_extension = {
+	&match_type_extension,
+	NULL,
+	mtch_interpreter_free
+};
+
+static inline struct mtch_interpreter_context *
+get_interpreter_context(struct sieve_interpreter *interp)
+{
+	return (struct mtch_interpreter_context *)
+		sieve_interpreter_extension_get_context(interp, ext_this);
+}
+
+static struct mtch_interpreter_context *
+mtch_interpreter_context_init(struct sieve_interpreter *interp)
+{		
+	pool_t pool = sieve_interpreter_pool(interp);
+	struct mtch_interpreter_context *ctx;
+	
+	ctx = p_new(pool, struct mtch_interpreter_context, 1);
+
+	sieve_interpreter_extension_register
+		(interp, &mtch_interpreter_extension, (void *) ctx);
+
+	return ctx;
+}
+
+/*
+ * Match values
+ */
+
+bool sieve_match_values_set_enabled
+(struct sieve_interpreter *interp, bool enable)
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+	
+	if ( ctx == NULL && enable ) 
+		ctx = mtch_interpreter_context_init(interp);
+	
+	if ( ctx != NULL ) {
+		bool previous = ctx->match_values_enabled;
+		
+		ctx->match_values_enabled = enable;
+		return previous;
+	}
+	
+	return FALSE;
+}
+
+bool sieve_match_values_are_enabled
+(struct sieve_interpreter *interp)
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+		
+	return ( ctx == NULL ? FALSE : ctx->match_values_enabled );
+}
+
+struct sieve_match_values *sieve_match_values_start
+(struct sieve_interpreter *interp)
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+	struct sieve_match_values *match_values;
+	
+	if ( ctx == NULL || !ctx->match_values_enabled )
+		return NULL;
+	
+	pool_t pool = pool_alloconly_create("sieve_match_values", 1024);
+		
+	match_values = p_new(pool, struct sieve_match_values, 1);
+	match_values->pool = pool;
+	match_values->count = 0;
+	
+	p_array_init(&match_values->values, pool, 4);
+
+	return match_values;
+}
+
+static string_t *sieve_match_values_add_entry
+(struct sieve_match_values *mvalues) 
+{
+	string_t *entry;
+	
+	if ( mvalues == NULL ) return NULL;	
+
+	if ( mvalues->count >= SIEVE_MAX_MATCH_VALUES ) return NULL;
+		
+	if ( mvalues->count >= array_count(&mvalues->values) ) {
+		entry = str_new(mvalues->pool, 64);
+		array_append(&mvalues->values, &entry, 1);	} else {
+		string_t * const *ep = array_idx(&mvalues->values, mvalues->count);
+		entry = *ep;
+		str_truncate(entry, 0);
+	}
+	
+	mvalues->count++;
+
+	return entry;
+}
+
+void sieve_match_values_set
+(struct sieve_match_values *mvalues, unsigned int index, string_t *value)
+{
+	if ( mvalues != NULL && index < array_count(&mvalues->values) ) {
+		string_t * const *ep = array_idx(&mvalues->values, index);
+    	string_t *entry = *ep;
+
+	    if ( entry != NULL && value != NULL ) {
+			str_truncate(entry, 0);
+        	str_append_str(entry, value);
+		}
+	}
+}
+	
+void sieve_match_values_add
+(struct sieve_match_values *mvalues, string_t *value) 
+{
+	string_t *entry = sieve_match_values_add_entry(mvalues); 
+
+	if ( entry != NULL && value != NULL )
+		str_append_str(entry, value);
+}
+
+void sieve_match_values_add_char
+(struct sieve_match_values *mvalues, char c) 
+{
+	string_t *entry = sieve_match_values_add_entry(mvalues); 
+
+	if ( entry != NULL )
+		str_append_c(entry, c);
+}
+
+void sieve_match_values_skip
+(struct sieve_match_values *mvalues, int num) 
+{
+	int i;
+	
+	for ( i = 0; i < num; i++ )
+		(void) sieve_match_values_add_entry(mvalues); 
+}
+
+void sieve_match_values_commit
+(struct sieve_interpreter *interp, struct sieve_match_values **mvalues)
+{
+	struct mtch_interpreter_context *ctx;
+	
+	if ( (*mvalues) == NULL ) return;
+	
+	ctx = get_interpreter_context(interp);
+	if ( ctx == NULL || !ctx->match_values_enabled )
+		return;	
+		
+	if ( ctx->match_values != NULL ) {
+		pool_unref(&ctx->match_values->pool);
+		ctx->match_values = NULL;
+	}
+
+	ctx->match_values = *mvalues;
+	*mvalues = NULL;
+}
+
+void sieve_match_values_abort
+(struct sieve_match_values **mvalues)
+{		
+	if ( (*mvalues) == NULL ) return;
+	
+	pool_unref(&(*mvalues)->pool);
+	*mvalues = NULL;
+}
+
+void sieve_match_values_get
+(struct sieve_interpreter *interp, unsigned int index, string_t **value_r) 
+{
+	struct mtch_interpreter_context *ctx = get_interpreter_context(interp);
+	struct sieve_match_values *mvalues;
+
+	if ( ctx == NULL || ctx->match_values == NULL ) {
+		*value_r = NULL;
+		return;
+	}
+	
+	mvalues = ctx->match_values;
+	if ( index < array_count(&mvalues->values) && index < mvalues->count ) {
+		string_t * const *entry = array_idx(&mvalues->values, index);
+		
+		*value_r = *entry;
+		return;
+	}
+
+	*value_r = NULL;	
+}
+
+/* 
+ * Match-type tagged argument 
+ */
+ 
+/* Forward declarations */
+
+static bool tag_match_type_is_instance_of
+	(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+		struct sieve_ast_argument *arg);
+static bool tag_match_type_validate
+	(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+		struct sieve_command_context *cmd);
+static bool tag_match_type_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+		struct sieve_command_context *cmd);
+
+/* Argument object */
+ 
+const struct sieve_argument match_type_tag = { 
+	"MATCH-TYPE",
+	tag_match_type_is_instance_of,
+	NULL, 
+	tag_match_type_validate, 
+	NULL,
+	tag_match_type_generate 
+};
+
+/* Argument implementation */
+
+static bool tag_match_type_is_instance_of
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg)
+{
+	struct sieve_match_type_context *mtctx;
+	const struct sieve_match_type *mtch = 
+		sieve_match_type_find(validator, sieve_ast_argument_tag(arg));
+		
+	if ( mtch == NULL ) return FALSE;	
+		
+	/* Create context */
+	mtctx = p_new(sieve_command_pool(cmd), struct sieve_match_type_context, 1);
+	mtctx->match_type = mtch;
+	mtctx->match_type_arg = arg;
+	mtctx->command_ctx = cmd;
+	mtctx->comparator = NULL; /* Can be filled in later */
+	
+	arg->context = (void *) mtctx;
+	
+	return TRUE;
+}
+ 
+static bool tag_match_type_validate
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_match_type_context *mtctx = 
+		(struct sieve_match_type_context *) (*arg)->context;
+	const struct sieve_match_type *mtch = mtctx->match_type;
+
+	/* Syntax:   
+	 *   ":is" / ":contains" / ":matches" (subject to extension)
+	 */
+		
+	/* Skip tag */
+	*arg = sieve_ast_argument_next(*arg);
+	
+	/* Check whether this match type requires additional validation. 
+	 * Additional validation can override the match type recorded in the context 
+	 * for later code generation. 
+	 */
+	if ( mtch->validate != NULL ) {
+		return mtch->validate(validator, arg, mtctx);
+	}
+	
+	return TRUE;
+}
+
+static bool tag_match_type_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_ast_argument *arg, 
+	struct sieve_command_context *cmd ATTR_UNUSED)
+{
+	struct sieve_match_type_context *mtctx =
+		(struct sieve_match_type_context *) arg->context;
+	
+	(void) sieve_opr_match_type_emit(cgenv->sbin, mtctx->match_type);
+			
+	return TRUE;
+}
+
+void sieve_match_types_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code) 
+{	
+	sieve_validator_register_tag
+		(validator, cmd_reg, &match_type_tag, id_code); 	
+}
+
+/*
+ * Validation
+ */
+
+bool sieve_match_type_validate
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *key_arg, 
+	const struct sieve_match_type *mcht_default, 
+	const struct sieve_comparator *cmp_default)
+{
+	struct sieve_ast_argument *arg = sieve_command_first_argument(cmd);
+	struct sieve_ast_argument *mt_arg = NULL;
+	struct sieve_match_type_context *mtctx;
+	const struct sieve_match_type *mcht = NULL;
+	const struct sieve_comparator *cmp = NULL;
+
+	/* Find match type and comparator among the arguments */
+	while ( arg != NULL && arg != cmd->first_positional ) {
+		if ( sieve_argument_is_comparator(arg) ) {
+			cmp = sieve_comparator_tag_get(arg);
+			if ( mt_arg != NULL ) break;
+		}
+
+		if ( sieve_argument_is_match_type(arg) ) {
+			mt_arg = arg;
+			if ( cmp != NULL ) break;
+		}
+		arg = sieve_ast_argument_next(arg);
+	}
+	
+	/* Verify using the default comparator if none is specified explicitly */
+	if ( cmp == NULL )
+		cmp = cmp_default;
+	
+	/* Verify the default match type if none is specified explicitly */
+	if ( mt_arg == NULL || mt_arg->context == NULL ) {
+		mtctx = NULL;
+		mcht = mcht_default;
+	} else {
+		mtctx = (struct sieve_match_type_context *) mt_arg->context;
+		mcht = mtctx->match_type;
+		mtctx->comparator = cmp;
+	}
+
+	/* Check whether this match type requires additional validation. 
+	 * Additional validation can override the match type recorded in the context 
+	 * for later code generation. 
+	 */
+	if ( mcht != NULL && mcht->validate_context != NULL ) {
+		return mcht->validate_context(validator, mt_arg, mtctx, key_arg);
+	}
+	
+	return TRUE;	
+}
+
+/*
+ * Match-type operand
+ */
+ 
+const struct sieve_operand_class sieve_match_type_operand_class = 
+	{ "match type" };
+	
+static const struct sieve_extension_objects core_match_types =
+	SIEVE_EXT_DEFINE_MATCH_TYPES(sieve_core_match_types);
+
+const struct sieve_operand match_type_operand = { 
+	"match-type", 
+	NULL,
+	SIEVE_OPERAND_MATCH_TYPE,
+	&sieve_match_type_operand_class,
+	&core_match_types
+};
+
+/*
+ * Common validation implementation
+ */
+
+bool sieve_match_substring_validate_context
+(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+	struct sieve_match_type_context *ctx,
+	struct sieve_ast_argument *key_arg ATTR_UNUSED)
+{
+	const struct sieve_comparator *cmp = ctx->comparator;
+		
+	if ( cmp == NULL )
+		return TRUE;
+			
+	if ( (cmp->flags & SIEVE_COMPARATOR_FLAG_SUBSTRING_MATCH) == 0 ) {
+		sieve_argument_validate_error(validator, arg,
+			"the specified %s comparator does not support "
+			"sub-string matching as required by the :%s match type",
+			cmp->object.identifier, ctx->match_type->object.identifier );
+
+		return FALSE;
+	}
+	
+	return TRUE;
+} 
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match-types.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match-types.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-match-types.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-match-types.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,201 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_MATCH_TYPES_H
+#define __SIEVE_MATCH_TYPES_H
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-objects.h"
+
+/*
+ * Types
+ */
+
+struct sieve_match_type_context;
+
+/*
+ * Core match types 
+ */
+ 
+enum sieve_match_type_code {
+	SIEVE_MATCH_TYPE_IS,
+	SIEVE_MATCH_TYPE_CONTAINS,
+	SIEVE_MATCH_TYPE_MATCHES,
+	SIEVE_MATCH_TYPE_CUSTOM
+};
+
+extern const struct sieve_match_type is_match_type;
+extern const struct sieve_match_type contains_match_type;
+extern const struct sieve_match_type matches_match_type;
+
+/*
+ * Match type object
+ */
+ 
+struct sieve_match_type {
+	struct sieve_object object;
+
+	/* Match function called for every key value or should it be called once
+	 * for every tested value? (TRUE = first alternative)
+	 */
+	bool is_iterative;
+	
+	/* Is the key value allowed to contain formatting to extract multiple keys
+	 * out of the same string?
+	 */
+	bool allow_key_extract;
+		
+	bool (*validate)
+		(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+			struct sieve_match_type_context *ctx);
+	bool (*validate_context)
+		(struct sieve_validator *validator, struct sieve_ast_argument *arg, 
+			struct sieve_match_type_context *ctx, struct sieve_ast_argument *key_arg);
+			
+	/*
+	 * Matching
+ 	 */
+
+	void (*match_init)(struct sieve_match_context *mctx);
+
+	/* WARNING: some tests may pass a val == NULL parameter indicating that the 
+	 * passed value has no significance. For string-type matches this should map 
+	 * to the empty string "", but for match types that consider the passed values 
+	 * as objects rather than strings (e.g. :count) this means that the passed 
+	 * value should be skipped. 
+	 */
+	int (*match)
+		(struct sieve_match_context *mctx, const char *val, size_t val_size, 
+			const char *key, size_t key_size, int key_index);
+	int (*match_deinit)(struct sieve_match_context *mctx);
+};
+
+struct sieve_match_type_context {
+	struct sieve_command_context *command_ctx;
+	struct sieve_ast_argument *match_type_arg;
+
+	const struct sieve_match_type *match_type;
+	
+	/* Only filled in when match_type->validate_context() is called */
+	const struct sieve_comparator *comparator;
+	
+	/* Context data could be used in the future to pass data between validator and
+	 * generator in match types that use extra parameters. Currently not 
+	 * necessary, not even for the relational extension.
+	 */
+	void *ctx_data;
+};
+
+/*
+ * Match type registration
+ */
+
+void sieve_match_type_register
+	(struct sieve_validator *validator, const struct sieve_match_type *mcht);
+const struct sieve_match_type *sieve_match_type_find
+	(struct sieve_validator *validator, const char *identifier);
+
+/* 
+ * Match values 
+ */
+
+struct sieve_match_values;
+
+bool sieve_match_values_set_enabled
+	(struct sieve_interpreter *interp, bool enable);
+bool sieve_match_values_are_enabled
+	(struct sieve_interpreter *interp);	
+	
+struct sieve_match_values *sieve_match_values_start
+	(struct sieve_interpreter *interp);
+void sieve_match_values_set
+	(struct sieve_match_values *mvalues, unsigned int index, string_t *value);
+void sieve_match_values_add
+	(struct sieve_match_values *mvalues, string_t *value);
+void sieve_match_values_add_char
+	(struct sieve_match_values *mvalues, char c);	
+void sieve_match_values_skip
+	(struct sieve_match_values *mvalues, int num);
+	
+void sieve_match_values_commit
+	(struct sieve_interpreter *interp, struct sieve_match_values **mvalues);
+void sieve_match_values_abort
+	(struct sieve_match_values **mvalues);
+	
+void sieve_match_values_get
+	(struct sieve_interpreter *interp, unsigned int index, string_t **value_r);
+
+/*
+ * Match type tagged argument 
+ */
+
+extern const struct sieve_argument match_type_tag;
+
+static inline bool sieve_argument_is_match_type
+	(struct sieve_ast_argument *arg)
+{
+	return ( arg->argument == &match_type_tag );
+}
+
+void sieve_match_types_link_tags
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, int id_code);
+
+/*
+ * Validation
+ */
+
+bool sieve_match_type_validate
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *key_arg, 
+		const struct sieve_match_type *mcht_default, 
+		const struct sieve_comparator *cmp_default);
+
+/*
+ * Match type operand
+ */
+ 
+extern const struct sieve_operand match_type_operand;
+extern const struct sieve_operand_class sieve_match_type_operand_class;
+
+#define SIEVE_EXT_DEFINE_MATCH_TYPE(OP) SIEVE_EXT_DEFINE_OBJECT(OP)
+#define SIEVE_EXT_DEFINE_MATCH_TYPES(OPS) SIEVE_EXT_DEFINE_OBJECTS(OPS)
+
+static inline bool sieve_operand_is_match_type
+(const struct sieve_operand *operand)
+{
+	return ( operand != NULL && 
+		operand->class == &sieve_match_type_operand_class );
+}
+
+static inline void sieve_opr_match_type_emit
+(struct sieve_binary *sbin, const struct sieve_match_type *mtch)
+{ 
+	sieve_opr_object_emit(sbin, &mtch->object);
+}
+
+static inline const struct sieve_match_type *sieve_opr_match_type_read
+(const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	return (const struct sieve_match_type *) sieve_opr_object_read
+		(renv, &sieve_match_type_operand_class, address);
+}
+
+static inline bool sieve_opr_match_type_dump
+(const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	return sieve_opr_object_dump
+		(denv, &sieve_match_type_operand_class, address, NULL);
+}
+
+/* Common validation implementation */
+
+bool sieve_match_substring_validate_context
+	(struct sieve_validator *validator, struct sieve_ast_argument *arg,
+		struct sieve_match_type_context *ctx, 
+		struct sieve_ast_argument *key_arg);
+
+#endif /* __SIEVE_MATCH_TYPES_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-message.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-message.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-message.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-message.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,110 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "mempool.h"
+#include "array.h"
+
+#include "sieve-common.h"
+#include "sieve-message.h"
+#include "sieve-extensions.h"
+
+/*
+ * Message transmission
+ */
+ 
+const char *sieve_message_get_new_id
+(const struct sieve_script_env *senv)
+{
+	static int count = 0;
+	
+	return t_strdup_printf("<dovecot-sieve-%s-%s-%d@%s>",
+		dec2str(ioloop_timeval.tv_sec), dec2str(ioloop_timeval.tv_usec),
+    count++, senv->hostname);
+}
+
+/* 
+ * Message context 
+ */
+
+struct sieve_message_context {
+	pool_t pool;
+	int refcount;
+	
+	/* Context data for extensions */
+	ARRAY_DEFINE(ext_contexts, void *); 
+};
+
+struct sieve_message_context *sieve_message_context_create(void)
+{
+	struct sieve_message_context *msgctx;
+	
+	msgctx = i_new(struct sieve_message_context, 1);
+	msgctx->refcount = 1;
+		
+	sieve_message_context_flush(msgctx);
+
+	return msgctx;
+}
+
+void sieve_message_context_ref(struct sieve_message_context *msgctx)
+{
+	msgctx->refcount++;
+}
+
+void sieve_message_context_unref(struct sieve_message_context **msgctx)
+{
+	i_assert((*msgctx)->refcount > 0);
+
+	if (--(*msgctx)->refcount != 0)
+		return;
+	
+	pool_unref(&((*msgctx)->pool));
+		
+	i_free(*msgctx);
+	*msgctx = NULL;
+}
+
+void sieve_message_context_flush(struct sieve_message_context *msgctx)
+{
+	pool_t pool;
+
+	if ( msgctx->pool != NULL ) {
+		pool_unref(&msgctx->pool);
+	}
+
+	pool = pool_alloconly_create("sieve_message_context", 1024);
+	msgctx->pool = pool;
+
+	p_array_init(&msgctx->ext_contexts, pool, sieve_extensions_get_count());
+}
+
+pool_t sieve_message_context_pool(struct sieve_message_context *msgctx)
+{
+	return msgctx->pool;
+}
+
+/* Extension support */
+
+void sieve_message_context_extension_set
+(struct sieve_message_context *msgctx, const struct sieve_extension *ext, 
+	void *context)
+{
+	array_idx_set(&msgctx->ext_contexts, (unsigned int) SIEVE_EXT_ID(ext), &context);	
+}
+
+const void *sieve_message_context_extension_get
+(struct sieve_message_context *msgctx, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	void * const *ctx;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&msgctx->ext_contexts) )
+		return NULL;
+	
+	ctx = array_idx(&msgctx->ext_contexts, (unsigned int) ext_id);		
+
+	return *ctx;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-message.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-message.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-message.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-message.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,37 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_MESSAGE_H
+#define __SIEVE_MESSAGE_H
+
+/* 
+ * Message transmission
+ */
+
+const char *sieve_message_get_new_id
+	(const struct sieve_script_env *senv);
+
+/* 
+ * Message context 
+ */
+
+struct sieve_message_context;
+
+struct sieve_message_context *sieve_message_context_create(void);
+void sieve_message_context_ref(struct sieve_message_context *msgctx);
+void sieve_message_context_unref(struct sieve_message_context **msgctx);
+
+void sieve_message_context_flush(struct sieve_message_context *msgctx);
+
+pool_t sieve_message_context_pool
+	(struct sieve_message_context *msgctx);
+
+/* Extension support */
+
+void sieve_message_context_extension_set
+	(struct sieve_message_context *msgctx, const struct sieve_extension *ext, 
+		void *context);
+const void *sieve_message_context_extension_get
+	(struct sieve_message_context *msgctx, const struct sieve_extension *ext);
+	
+#endif /* __SIEVE_MESSAGE_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-objects.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-objects.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-objects.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-objects.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,96 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+#include "sieve-dump.h"
+#include "sieve-interpreter.h"
+
+#include "sieve-objects.h"
+
+/*
+ * Object coding
+ */
+
+void sieve_opr_object_emit
+(struct sieve_binary *sbin, const struct sieve_object *obj)
+{
+	struct sieve_extension_objects *objs = 
+		(struct sieve_extension_objects *) obj->operand->interface;
+		 
+	(void) sieve_operand_emit_code(sbin, obj->operand);
+	
+	if ( objs->count > 1 ) {	
+		(void) sieve_binary_emit_byte(sbin, obj->code);
+	} 
+}
+
+const struct sieve_object *sieve_opr_object_read_data
+(struct sieve_binary *sbin, const struct sieve_operand *operand,
+	const struct sieve_operand_class *opclass, sieve_size_t *address)
+{
+	const struct sieve_extension_objects *objs;
+	unsigned int obj_code; 
+
+	if ( operand == NULL || operand->class != opclass )
+		return NULL;
+	
+	objs = (struct sieve_extension_objects *) operand->interface;
+	if ( objs == NULL ) 
+		return NULL;
+			
+	if ( objs->count > 1 ) {
+		if ( !sieve_binary_read_byte(sbin, address, &obj_code) ) 
+			return NULL;
+
+		if ( obj_code < objs->count ) {
+			const struct sieve_object *const *objects = 
+				(const struct sieve_object* const *) objs->objects;
+			return objects[obj_code]; 
+		}
+	}
+	
+	return (const struct sieve_object *) objs->objects; 
+}
+
+const struct sieve_object *sieve_opr_object_read
+(const struct sieve_runtime_env *renv, 
+	const struct sieve_operand_class *opclass, sieve_size_t *address)
+{
+	const struct sieve_operand *operand = sieve_operand_read(renv->sbin, address);
+	
+	return sieve_opr_object_read_data(renv->sbin, operand, opclass, address);
+}
+
+bool sieve_opr_object_dump
+(const struct sieve_dumptime_env *denv, 
+	const struct sieve_operand_class *opclass, sieve_size_t *address,
+	const struct sieve_object **object_r)
+{
+	const struct sieve_operand *operand;
+	const struct sieve_object *obj;
+	const char *class;
+	
+	sieve_code_mark(denv);
+	
+	operand = sieve_operand_read(denv->sbin, address); 
+	obj = sieve_opr_object_read_data(denv->sbin, operand, opclass, address);
+	
+	if ( obj == NULL )
+		return FALSE;
+		
+	if ( operand->class == NULL )
+		class = "OBJECT";
+	else
+		class = operand->class->name;
+			
+	sieve_code_dumpf(denv, "%s: %s", class, obj->identifier);
+	
+	if ( object_r != NULL )
+		*object_r = obj;
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-objects.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-objects.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-objects.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-objects.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,41 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_OBJECTS_H
+#define __SIEVE_OBJECTS_H
+
+/*
+ * Object
+ */
+
+struct sieve_object {
+	const char *identifier;
+	const struct sieve_operand *operand;
+	unsigned int code;
+};
+
+#define SIEVE_OBJECT(identifier, operand, code) \
+	{ identifier, operand, code }
+
+/*
+ * Object coding
+ */
+ 
+void sieve_opr_object_emit
+	(struct sieve_binary *sbin, const struct sieve_object *obj);
+
+const struct sieve_object *sieve_opr_object_read_data
+	(struct sieve_binary *sbin, const struct sieve_operand *operand,
+		const struct sieve_operand_class *opclass, sieve_size_t *address);
+
+const struct sieve_object *sieve_opr_object_read
+	(const struct sieve_runtime_env *renv, 
+		const struct sieve_operand_class *opclass, sieve_size_t *address);
+
+bool sieve_opr_object_dump
+	(const struct sieve_dumptime_env *denv, 
+		const struct sieve_operand_class *opclass, sieve_size_t *address,
+		const struct sieve_object **object_r);
+
+
+#endif /* __SIEVE_OBJECTS_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-parser.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-parser.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-parser.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-parser.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,655 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#include <stdio.h>
+
+#include "lib.h"
+#include "istream.h"
+#include "failures.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-script.h"
+#include "sieve-lexer.h"
+#include "sieve-parser.h"
+#include "sieve-error.h"
+#include "sieve-ast.h"
+
+/*
+ * Forward declarations
+ */
+ 
+inline static void sieve_parser_error
+	(struct sieve_parser *parser, const char *fmt, ...) ATTR_FORMAT(2, 3);
+inline static void sieve_parser_warning
+	(struct sieve_parser *parser, const char *fmt, ...) ATTR_FORMAT(2, 3); 
+ 
+static int sieve_parser_recover
+	(struct sieve_parser *parser, enum sieve_token_type end_token);
+
+/*
+ * Parser object
+ */
+
+struct sieve_parser {
+	pool_t pool;
+	
+	bool valid;
+	
+	struct sieve_script *script;
+		
+	struct sieve_error_handler *ehandler;
+	
+	struct sieve_lexer *lexer;
+	struct sieve_ast *ast;
+};
+
+struct sieve_parser *sieve_parser_create
+(struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	struct sieve_parser *parser;
+	struct sieve_lexer *lexer;
+	
+	lexer = sieve_lexer_create(script, ehandler);
+  
+	if ( lexer != NULL ) {
+		pool_t pool = pool_alloconly_create("sieve_parser", 4096);	
+
+		parser = p_new(pool, struct sieve_parser, 1);
+		parser->pool = pool;
+		parser->valid = TRUE;
+		
+		parser->ehandler = ehandler;
+		sieve_error_handler_ref(ehandler);
+
+		parser->script = script;
+		sieve_script_ref(script);
+				
+		parser->lexer = lexer;
+		parser->ast = NULL;
+				
+		return parser;
+	}
+	
+	return NULL;
+}
+
+void sieve_parser_free(struct sieve_parser **parser)
+{
+	if ((*parser)->ast != NULL)	  
+		sieve_ast_unref(&(*parser)->ast);
+
+	sieve_lexer_free(&(*parser)->lexer);
+	sieve_script_unref(&(*parser)->script);
+
+	sieve_error_handler_unref(&(*parser)->ehandler);
+
+	pool_unref(&(*parser)->pool);
+	
+	*parser = NULL;
+}
+
+/*
+ * Internal error handling
+ */
+
+inline static void sieve_parser_error
+(struct sieve_parser *parser, const char *fmt, ...)
+{ 
+	va_list args;
+	va_start(args, fmt);
+
+	/* Don't report a parse error if the lexer complained already */ 
+	if ( sieve_lexer_current_token(parser->lexer) != STT_ERROR )  
+	{
+		T_BEGIN {
+			sieve_verror(parser->ehandler,
+				sieve_error_script_location(parser->script, 
+					sieve_lexer_current_line(parser->lexer)),
+				fmt, args);
+		} T_END; 
+	}
+	
+	parser->valid = FALSE;
+	
+	va_end(args);
+}
+
+inline static void sieve_parser_warning
+(struct sieve_parser *parser, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+
+	T_BEGIN	{
+		sieve_vwarning(parser->ehandler, 
+			sieve_error_script_location(parser->script, 
+				sieve_lexer_current_line(parser->lexer)),
+			fmt, args);
+	} T_END;
+		
+	va_end(args);
+} 
+
+/*
+ * Sieve grammar parsing
+ */
+
+/* sieve_parse_arguments():
+ *
+ * Parses both command arguments and sub-tests:
+ *   arguments = *argument [test / test-list]
+ *   argument = string-list / number / tag
+ *   string = quoted-string / multi-line   [[implicitly handled in lexer]]
+ *   string-list = "[" string *("," string) "]" / string         ;; if
+ *     there is only a single string, the brackets are optional
+ *   test-list = "(" test *("," test) ")"
+ *   test = identifier arguments
+ */
+static int sieve_parse_arguments
+(struct sieve_parser *parser, struct sieve_ast_node *node, unsigned int depth) 
+{	
+	struct sieve_lexer *lexer = parser->lexer;
+	struct sieve_ast_node *test = NULL;
+	bool test_present = TRUE;
+	bool arg_present = TRUE;
+	int result = TRUE; /* Indicates whether the parser is in a defined, not 
+	                       necessarily error-free state */
+
+	/* Parse arguments */
+	while ( arg_present && result > 0 && 
+		(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+		struct sieve_ast_argument *arg;
+		
+		switch ( sieve_lexer_current_token(lexer) ) {
+		
+		/* String list */
+		case STT_LSQUARE:
+			/* Create stinglist object */
+			arg = sieve_ast_argument_stringlist_create
+				(node, sieve_lexer_current_line(parser->lexer));
+
+			if ( arg == NULL ) break;
+				
+			sieve_lexer_skip_token(lexer);			
+			
+			if ( sieve_lexer_current_token(lexer) == STT_STRING ) {
+				bool add_failed = FALSE;
+
+				/* Add the string to the list */
+				if ( !sieve_ast_stringlist_add
+					(arg, sieve_lexer_token_str(lexer), 
+						sieve_lexer_current_line(parser->lexer)) )
+					add_failed = TRUE;
+				
+				sieve_lexer_skip_token(lexer);
+				 
+				while ( !add_failed && sieve_lexer_current_token(lexer) == STT_COMMA &&
+					(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+			
+					sieve_lexer_skip_token(lexer);
+				
+					if ( sieve_lexer_current_token(lexer) == STT_STRING ) {
+						/* Add the string to the list */
+						if ( !sieve_ast_stringlist_add
+							(arg, sieve_lexer_token_str(lexer), 
+								sieve_lexer_current_line(parser->lexer)) )
+							add_failed = TRUE;
+							
+						sieve_lexer_skip_token(lexer);
+					} else {
+						sieve_parser_error(parser, 
+							"expecting string after ',' in string list, but found %s",
+							sieve_lexer_token_string(lexer));
+					
+						result = sieve_parser_recover(parser, STT_RSQUARE);
+						break;
+					}
+				}
+				
+				if ( add_failed ) {
+					sieve_parser_error(parser, 
+						"failed to accept more items in string list");
+					return -1;
+				}
+			} else {
+				sieve_parser_error(parser, 
+					"expecting string after '[' in string list, but found %s",
+					sieve_lexer_token_string(lexer));
+			
+				result = sieve_parser_recover(parser, STT_RSQUARE);
+			}
+		
+			/* Finish the string list */
+			if ( sieve_lexer_current_token(lexer) == STT_RSQUARE ) {
+				sieve_lexer_skip_token(lexer);
+			} else {
+				sieve_parser_error(parser, 
+					"expecting ',' or end of string list ']', but found %s",
+					sieve_lexer_token_string(lexer));
+			
+				if ( (result=sieve_parser_recover(parser, STT_RSQUARE)) == TRUE ) 
+					sieve_lexer_skip_token(lexer);
+			}
+	
+			break;
+			
+		/* Single string */
+		case STT_STRING: 
+			arg = sieve_ast_argument_string_create
+				(node, sieve_lexer_token_str(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+
+			sieve_lexer_skip_token(lexer);
+			break;
+		
+		/* Number */
+		case STT_NUMBER:
+			arg = sieve_ast_argument_number_create
+				(node, sieve_lexer_token_int(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+			break;
+			
+		/* Tag */
+		case STT_TAG:
+			arg = sieve_ast_argument_tag_create
+				(node, sieve_lexer_token_ident(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+			break;
+			
+		/* End of argument list, continue with tests */
+		default:
+			arg_present = FALSE;
+			break;
+		}
+
+		if ( arg_present && arg == NULL ) {
+			sieve_parser_error(parser, 
+				"failed to accept more arguments for command '%s'", node->identifier);
+			return -1;
+		}
+
+		if ( sieve_ast_argument_count(node) > SIEVE_MAX_COMMAND_ARGUMENTS ) {
+			sieve_parser_error(parser, 
+				"too many arguments for command '%s'", node->identifier);
+			return FALSE;
+		}
+	}
+	
+	if ( result <= 0 ) return result; /* Defer recovery to caller */
+	
+	/* --> [ test / test-list ] 
+ 	 * test-list = "(" test *("," test) ")"
+	 * test = identifier arguments
+	 */
+	switch ( sieve_lexer_current_token(lexer) ) {
+
+	/* Single test */
+	case STT_IDENTIFIER:
+		if ( depth+1 > SIEVE_MAX_TEST_NESTING ) {
+			sieve_parser_error(parser, 
+				"cannot nest tests deeper than %u levels",
+				SIEVE_MAX_TEST_NESTING);
+			return FALSE;
+		}
+
+		test = sieve_ast_test_create
+			(node, sieve_lexer_token_ident(lexer), 
+				sieve_lexer_current_line(parser->lexer));
+		sieve_lexer_skip_token(lexer);
+		
+		/* Theoretically, test can be NULL */
+		if ( test == NULL ) break;
+
+		/* Parse test arguments, which may include more tests (recurse) */
+		if ( !sieve_parse_arguments(parser, test, depth+1) ) {
+			return FALSE; /* Defer recovery to caller */
+		}
+		
+		break;
+		
+	/* Test list */
+	case STT_LBRACKET:	
+		sieve_lexer_skip_token(lexer);
+
+		if ( depth+1 > SIEVE_MAX_TEST_NESTING ) {
+			sieve_parser_error(parser, 
+				"cannot nest tests deeper than %u levels",
+				SIEVE_MAX_TEST_NESTING);
+			result = sieve_parser_recover(parser, STT_RBRACKET);
+
+			if ( result ) sieve_lexer_skip_token(lexer);
+			return result;
+		}
+
+		node->test_list = TRUE;
+		
+		/* Test starts with identifier */
+		if ( sieve_lexer_current_token(lexer) == STT_IDENTIFIER ) {
+			test = sieve_ast_test_create
+				(node, sieve_lexer_token_ident(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+			sieve_lexer_skip_token(lexer);
+		
+			if ( test == NULL ) break;
+
+			/* Parse test arguments, which may include more tests (recurse) */
+			if ( (result=sieve_parse_arguments(parser, test, depth+1)) > 0 ) {
+			
+				/* More tests ? */
+				while ( sieve_lexer_current_token(lexer) == STT_COMMA && 
+					(parser->valid && sieve_errors_more_allowed(parser->ehandler)) ) {
+					sieve_lexer_skip_token(lexer);
+					
+					/* Test starts with identifier */
+					if ( sieve_lexer_current_token(lexer) == STT_IDENTIFIER ) {
+						test = sieve_ast_test_create
+							(node, sieve_lexer_token_ident(lexer), 
+								sieve_lexer_current_line(parser->lexer));
+						sieve_lexer_skip_token(lexer);
+
+						if ( test == NULL ) break;
+						
+						/* Parse test arguments, which may include more tests (recurse) */
+						if ( (result=sieve_parse_arguments(parser, test, depth+1)) <= 0 ) {
+							if ( result < 0 ) return result;
+
+							result = sieve_parser_recover(parser, STT_RBRACKET);
+							break;
+						}
+					} else {
+						sieve_parser_error(parser, 
+							"expecting test identifier after ',' in test list, but found %s",
+							sieve_lexer_token_string(lexer));
+										
+						result = sieve_parser_recover(parser, STT_RBRACKET);
+						break;
+					}
+				}
+
+				if ( test == NULL ) break;
+			} else { 
+				if ( result < 0 ) return result;
+
+				result = sieve_parser_recover(parser, STT_RBRACKET);
+			}
+		} else {
+			sieve_parser_error(parser, 
+				"expecting test identifier after '(' in test list, but found %s",
+				sieve_lexer_token_string(lexer));
+			
+			result = sieve_parser_recover(parser, STT_RBRACKET);
+		}
+		
+		/* The next token should be a ')', indicating the end of the test list
+		 *   --> previous sieve_parser_recover calls try to restore this situation 
+		 *       after parse errors.  
+		 */
+ 		if ( sieve_lexer_current_token(lexer) == STT_RBRACKET ) {
+			sieve_lexer_skip_token(lexer);
+		} else {
+			sieve_parser_error(parser, 
+				"expecting ',' or end of test list ')', but found %s",
+				sieve_lexer_token_string(lexer));
+			
+			/* Recover function tries to make next token equal to ')'. If it succeeds 
+			 * we need to skip it.
+			 */
+			if ( (result=sieve_parser_recover(parser, STT_RBRACKET)) == TRUE ) 
+				sieve_lexer_skip_token(lexer);
+		}
+		break;
+		
+	default:
+		/* Not an error: test / test-list is optional
+		 *   --> any errors are detected by the caller  
+		 */
+		test_present = FALSE;
+		break;
+	}
+
+	if ( test_present && test == NULL ) {
+		sieve_parser_error(parser, 
+			"failed to accept more tests for command '%s'", node->identifier);
+		return -1;
+	}			
+	
+	return result;
+}
+
+/* commands = *command
+ * command = identifier arguments ( ";" / block )
+ * block = "{" commands "}"
+ */
+static int sieve_parse_commands
+(struct sieve_parser *parser, struct sieve_ast_node *block, unsigned int depth) 
+{ 
+	struct sieve_lexer *lexer = parser->lexer;
+	int result = TRUE;
+
+	while ( result > 0 && 
+		sieve_lexer_current_token(lexer) == STT_IDENTIFIER && 
+		(parser->valid || sieve_errors_more_allowed(parser->ehandler)) ) {
+		struct sieve_ast_node *command = 
+			sieve_ast_command_create
+				(block, sieve_lexer_token_ident(lexer), 
+					sieve_lexer_current_line(parser->lexer));
+	
+		if ( command == NULL ) {
+			sieve_parser_error(parser, 
+				"failed to accept more commands inside the block of command '%s'", 
+				block->identifier);
+			return -1;
+		}
+
+		/* Defined state */
+		result = TRUE;		
+		
+		sieve_lexer_skip_token(lexer);
+		
+		result = sieve_parse_arguments(parser, command, 1);
+
+		/* Check whether the command is properly terminated 
+		 * (i.e. with ; or a new block) 
+		 */
+		if ( result > 0 &&
+			sieve_lexer_current_token(lexer) != STT_SEMICOLON &&
+			sieve_lexer_current_token(lexer) != STT_LCURLY ) {
+			
+			sieve_parser_error(parser, 
+				"expected end of command ';' or the beginning of a compound block '{', "
+				"but found %s",
+				sieve_lexer_token_string(lexer));	
+			result = FALSE;
+		}
+		
+		/* Try to recover from parse errors to reacquire a defined state */
+		if ( result == 0 ) {
+			result = sieve_parser_recover(parser, STT_SEMICOLON);
+		}
+
+		/* Don't bother to continue if we are not in a defined state */
+		if ( result <= 0 ) return result;
+			
+		switch ( sieve_lexer_current_token(lexer) ) {
+		
+		/* End of the command */
+		case STT_SEMICOLON:
+			sieve_lexer_skip_token(lexer);
+			break;
+
+		/* Command has a block {...} */		
+		case STT_LCURLY:
+			sieve_lexer_skip_token(lexer);
+			
+			/* Check current depth first */
+			if ( depth+1 > SIEVE_MAX_BLOCK_NESTING ) {
+				sieve_parser_error(parser, 
+					"cannot nest command blocks deeper than %u levels",
+					SIEVE_MAX_BLOCK_NESTING);
+				result = sieve_parser_recover(parser, STT_RCURLY);
+
+				if ( result > 0 )
+					sieve_lexer_skip_token(lexer);
+				break;
+			}
+
+			command->block = TRUE;
+			
+			if ( (result=sieve_parse_commands(parser, command, depth+1)) > 0 ) {
+			
+				if ( sieve_lexer_current_token(lexer) != STT_RCURLY ) {
+					sieve_parser_error(parser, 
+						"expected end of compound block '}', but found %s",
+						sieve_lexer_token_string(lexer));
+					result = sieve_parser_recover(parser, STT_RCURLY);				
+				} else 
+					sieve_lexer_skip_token(lexer);
+			} else {
+				if ( result < 0 ) return result;
+
+				if ( (result=sieve_parser_recover(parser, STT_RCURLY)) == 0 ) 
+					sieve_lexer_skip_token(lexer);
+			}
+
+			break;
+			
+		default:
+			/* Recovered previously, so this cannot happen */
+			i_unreached();
+		}
+	}
+
+	return result;
+}
+
+bool sieve_parser_run
+(struct sieve_parser *parser, struct sieve_ast **ast) 
+{
+	if ( parser->ast != NULL )
+		sieve_ast_unref(&parser->ast);
+	
+	/* Create AST object if none is provided */
+	if ( *ast == NULL )
+		*ast = sieve_ast_create(parser->script);
+	else 
+		sieve_ast_ref(*ast);
+		
+	parser->ast = *ast;
+
+	/* Scan first token */
+	sieve_lexer_skip_token(parser->lexer);
+
+	/* Parse */
+	if ( sieve_parse_commands(parser, sieve_ast_root(parser->ast), 1) > 0 && 
+		parser->valid ) {
+		 
+		/* Parsed right to EOF ? */
+		if ( sieve_lexer_current_token(parser->lexer) != STT_EOF ) { 
+			sieve_parser_error(parser, 
+				"unexpected %s found at (the presumed) end of file",
+				sieve_lexer_token_string(parser->lexer));
+			parser->valid = FALSE;
+		}
+	} else parser->valid = FALSE;
+	
+	/* Clean up AST if parse failed */
+	if ( !parser->valid ) {
+		parser->ast = NULL;
+		sieve_ast_unref(ast);
+	}
+	
+	return parser->valid;
+}	
+
+/* Error recovery:
+ *   To continue parsing after an error it is important to find the next 
+ *   parsible item in the stream. The recover function skips over the remaining 
+ *   garbage after an error. It tries  to find the end of the failed syntax 
+ *   structure and takes nesting of structures into account. 
+ */
+
+/* Assign useful names to priorities for readability */ 
+enum sieve_grammatical_prio {
+	SGP_BLOCK = 3,
+	SGP_COMMAND = 2,
+	SGP_TEST_LIST = 1,
+	SGP_STRING_LIST = 0,
+  
+	SGP_OTHER = -1
+};
+
+static inline enum sieve_grammatical_prio __get_token_priority
+(enum sieve_token_type token) 
+{
+	switch ( token ) {
+	case STT_LCURLY:
+	case STT_RCURLY: 
+		return SGP_BLOCK;
+	case STT_SEMICOLON: 
+		return SGP_COMMAND;
+	case STT_LBRACKET:
+	case STT_RBRACKET: 
+		return SGP_TEST_LIST;
+	case STT_LSQUARE:
+	case STT_RSQUARE: 
+		return SGP_STRING_LIST;
+	default:
+		break;
+	}
+	
+	return SGP_OTHER;
+}
+
+static int sieve_parser_recover
+(struct sieve_parser *parser, enum sieve_token_type end_token) 
+{
+	/* The tokens that begin/end a specific block/command/list in order 
+ 	 * of ascending grammatical priority.
+ 	 */ 
+ 	static const enum sieve_token_type begin_tokens[4] = 
+ 		{ STT_LSQUARE, STT_LBRACKET, STT_NONE, STT_LCURLY };
+	static const enum sieve_token_type end_tokens[4] = 
+		{ STT_RSQUARE, STT_RBRACKET, STT_SEMICOLON, STT_RCURLY};
+
+	struct sieve_lexer *lexer = parser->lexer;
+	int nesting = 1;
+	enum sieve_grammatical_prio end_priority = __get_token_priority(end_token);
+			
+	i_assert( end_priority != SGP_OTHER );
+			
+	while ( sieve_lexer_current_token(lexer) != STT_EOF && 
+		__get_token_priority(sieve_lexer_current_token(lexer)) <= end_priority ) {
+			
+		if ( sieve_lexer_current_token(lexer) == begin_tokens[end_priority] ) {
+			nesting++;
+			sieve_lexer_skip_token(lexer);
+			continue;
+		}
+		
+		if ( sieve_lexer_current_token(lexer) == end_tokens[end_priority] ) {
+			nesting--;
+
+			if ( nesting == 0 ) {
+				/* Next character is the end */
+				return TRUE; 
+			}
+		}
+		
+		sieve_lexer_skip_token(lexer);
+	}
+	
+	/* Special case: COMMAND */
+	if (end_token == STT_SEMICOLON && 
+		sieve_lexer_current_token(lexer) == STT_LCURLY)
+		return TRUE;
+	
+	/* End not found before eof or end of surrounding grammatical structure 
+	 */
+	return FALSE; 
+}
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-parser.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-parser.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-parser.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-parser.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,18 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_PARSER_H
+#define __SIEVE_PARSER_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+struct sieve_parser;
+
+struct sieve_parser *sieve_parser_create
+	(struct sieve_script *script, struct sieve_error_handler *ehandler);
+void sieve_parser_free(struct sieve_parser **parser);
+bool sieve_parser_run(struct sieve_parser *parser, struct sieve_ast **ast);
+
+#endif /* __SIEVE_PARSER_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-result.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-result.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-result.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-result.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1174 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "mempool.h"
+#include "ostream.h"
+#include "hash.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-limits.h"
+#include "sieve-script.h"
+#include "sieve-error.h"
+#include "sieve-interpreter.h"
+#include "sieve-actions.h"
+#include "sieve-result.h"
+
+#include <stdio.h>
+
+/*
+ * Types
+ */
+ 
+struct sieve_result_action {
+	struct sieve_result *result;
+	struct sieve_action_data data;
+	
+	void *tr_context;
+	bool success;
+	
+	bool keep;
+
+	struct sieve_side_effects_list *seffects;
+	
+	struct sieve_result_action *prev, *next; 
+};
+
+struct sieve_side_effects_list {
+	struct sieve_result *result;
+
+	struct sieve_result_side_effect *first_effect;
+	struct sieve_result_side_effect *last_effect;
+};
+
+struct sieve_result_side_effect {
+	const struct sieve_side_effect *seffect;
+	void *context;
+	struct sieve_result_side_effect *prev, *next; 
+};
+
+struct sieve_result_action_context {
+	const struct sieve_action *action;
+	struct sieve_side_effects_list *seffects;
+};
+
+/*
+ * Result object
+ */
+
+struct sieve_result {
+	pool_t pool;
+	int refcount;
+
+	/* Context data for extensions */
+	ARRAY_DEFINE(ext_contexts, void *); 
+
+	struct sieve_error_handler *ehandler;
+		
+	struct sieve_action_exec_env action_env;
+	
+	const struct sieve_action *keep_action;
+	const struct sieve_action *failure_action;
+
+	unsigned int action_count;
+	struct sieve_result_action *first_action;
+	struct sieve_result_action *last_action;
+	
+	struct sieve_result_action *last_attempted_action;
+	
+	struct hash_table *action_contexts;
+};
+
+struct sieve_result *sieve_result_create
+(struct sieve_error_handler *ehandler) 
+{
+	pool_t pool;
+	struct sieve_result *result;
+	 
+	pool = pool_alloconly_create("sieve_result", 4096);	
+	result = p_new(pool, struct sieve_result, 1);
+	result->refcount = 1;
+	result->pool = pool;
+	
+	p_array_init(&result->ext_contexts, pool, 4);
+
+	if ( ehandler != NULL )
+		sieve_error_handler_ref(ehandler);	
+	result->ehandler = ehandler;
+
+	result->action_env.result = result;
+		
+	result->keep_action = &act_store;
+	result->failure_action = &act_store;
+	
+	result->action_count = 0;
+	result->first_action = NULL;
+	result->last_action = NULL;
+
+	result->action_contexts = NULL;
+	return result;
+}
+
+void sieve_result_ref(struct sieve_result *result) 
+{
+	result->refcount++;
+}
+
+void sieve_result_unref(struct sieve_result **result) 
+{
+	i_assert((*result)->refcount > 0);
+
+	if (--(*result)->refcount != 0)
+		return;
+
+	if ( (*result)->action_contexts != NULL )
+        hash_table_destroy(&(*result)->action_contexts);
+
+	if ( (*result)->ehandler != NULL )
+		sieve_error_handler_unref(&(*result)->ehandler);
+
+	pool_unref(&(*result)->pool);
+
+ 	*result = NULL;
+}
+
+pool_t sieve_result_pool(struct sieve_result *result)
+{
+	return result->pool;
+}
+
+struct sieve_error_handler *sieve_result_get_error_handler
+(struct sieve_result *result)
+{
+	return result->ehandler;
+}
+
+void sieve_result_set_error_handler
+(struct sieve_result *result, struct sieve_error_handler *ehandler)
+{
+	if ( result->ehandler != ehandler ) {
+		sieve_error_handler_ref(ehandler);
+		sieve_error_handler_unref(&result->ehandler);
+		result->ehandler = ehandler;
+	}
+}
+
+/*
+ * Extension support
+ */
+
+void sieve_result_extension_set_context
+(struct sieve_result *result, const struct sieve_extension *ext, void *context)
+{
+	array_idx_set(&result->ext_contexts, (unsigned int) SIEVE_EXT_ID(ext), 
+		&context);	
+}
+
+const void *sieve_result_extension_get_context
+(struct sieve_result *result, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	void * const *ctx;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&result->ext_contexts) )
+		return NULL;
+	
+	ctx = array_idx(&result->ext_contexts, (unsigned int) ext_id);		
+
+	return *ctx;
+}
+
+/* 
+ * Error handling 
+ */
+
+void sieve_result_error
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+	
+	if ( aenv->result->ehandler == NULL ) return;
+
+	va_start(args, fmt);	
+	sieve_verror(aenv->result->ehandler, sieve_action_get_location(aenv), fmt, 
+		args); 
+	va_end(args);
+}
+
+void sieve_result_warning
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+
+	if ( aenv->result->ehandler == NULL ) return;
+	
+	va_start(args, fmt);	
+	sieve_vwarning(aenv->result->ehandler, sieve_action_get_location(aenv), fmt, 
+		args); 
+	va_end(args);
+}
+
+void sieve_result_log
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+{
+	va_list args;
+	
+	if ( aenv->result->ehandler == NULL ) return;
+
+	va_start(args, fmt);	
+	sieve_vinfo(aenv->result->ehandler, sieve_action_get_location(aenv), fmt, 
+		args); 
+	va_end(args);
+}
+
+/* 
+ * Result composition 
+ */
+
+void sieve_result_add_implicit_side_effect
+(struct sieve_result *result, const struct sieve_action *to_action, 
+	const struct sieve_side_effect *seffect, void *context)
+{
+	struct sieve_result_action_context *actctx = NULL;
+	
+	if ( result->action_contexts == NULL ) {
+		result->action_contexts = hash_table_create
+			(default_pool, result->pool, 0, NULL, NULL);
+	} else {
+		actctx = (struct sieve_result_action_context *) 
+			hash_table_lookup(result->action_contexts, to_action);
+	}
+
+	if ( actctx == NULL ) {
+		actctx = p_new
+			(result->pool, struct sieve_result_action_context, 1);
+		actctx->action = to_action;
+		actctx->seffects = sieve_side_effects_list_create(result);
+		
+		hash_table_insert(result->action_contexts, (void *) to_action, 
+			(void *) actctx);
+	}	
+	
+	sieve_side_effects_list_add(actctx->seffects, seffect, context);
+}
+
+static int sieve_result_side_effects_merge
+(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+	struct sieve_side_effects_list *old_seffects,
+	struct sieve_side_effects_list *new_seffects)
+{
+	int ret;
+	struct sieve_result_side_effect *rsef, *nrsef;
+
+	/* Allow side-effects to merge with existing copy */
+		
+	/* Merge existing side effects */
+	rsef = old_seffects != NULL ? old_seffects->first_effect : NULL;
+	while ( rsef != NULL ) {
+		const struct sieve_side_effect *seffect = rsef->seffect;
+		bool found = FALSE;
+		
+		if ( seffect->merge != NULL ) {
+
+			/* Try to find it among the new */
+			nrsef = new_seffects != NULL ? new_seffects->first_effect : NULL;
+			while ( nrsef != NULL ) {
+				if ( nrsef->seffect == seffect ) {
+					if ( seffect->merge
+						(renv, action, seffect, &rsef->context, nrsef->context) < 0 )
+						return -1;
+			
+					found = TRUE;
+					break;
+				}
+		
+				nrsef = nrsef->next;
+			}
+	
+			/* Not found? */
+			if ( !found && seffect->merge
+				(renv, action, seffect, &rsef->context, NULL) < 0 )
+				return -1;
+		}
+	
+		rsef = rsef->next;
+	}
+
+	/* Merge new Side effects */
+	nrsef = new_seffects != NULL ? new_seffects->first_effect : NULL;
+	while ( nrsef != NULL ) {
+		const struct sieve_side_effect *seffect = nrsef->seffect;
+		bool found = FALSE;
+		
+		if ( seffect->merge != NULL ) {
+		
+			/* Try to find it among the exising */
+			rsef = old_seffects != NULL ? old_seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				if ( rsef->seffect == seffect ) {
+					found = TRUE;
+					break;
+				}
+				rsef = rsef->next;
+			}
+	
+			/* Not found? */
+			if ( !found ) {
+				void *new_context = NULL; 
+		
+				if ( (ret=seffect->merge
+					(renv, action, seffect, &new_context, nrsef->context)) < 0 ) 
+					return -1;
+					
+				if ( ret != 0 ) {
+					/* Add side effect */
+					sieve_side_effects_list_add(old_seffects, seffect, new_context);
+				}
+			}
+		}
+	
+		nrsef = nrsef->next;
+	}
+	
+	return 1;
+}
+
+static void sieve_result_action_detach(struct sieve_result_action *raction)
+{
+	struct sieve_result *result = raction->result;
+	
+	if ( result->first_action == raction ) 
+		result->first_action = raction->next;
+		
+	if ( result->last_action == raction ) 
+		result->last_action = raction->prev;
+		
+	if ( raction->next != NULL ) raction->next->prev = raction->prev;
+	if ( raction->prev != NULL ) raction->prev->next = raction->next;
+	
+	raction->next = NULL;
+	raction->prev = NULL;
+	
+	if ( result->action_count > 0 )
+		result->action_count--;
+}
+
+static int _sieve_result_add_action
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *action, struct sieve_side_effects_list *seffects,
+	unsigned int source_line, void *context, unsigned int instance_limit, 
+	bool keep)		
+{
+	int ret = 0;
+	unsigned int instance_count = 0;
+	struct sieve_result *result = renv->result;
+	struct sieve_result_action *raction = NULL, *kaction = NULL;
+	struct sieve_action_data act_data;
+			
+	act_data.action = action;
+	act_data.location = sieve_error_script_location(renv->script, source_line);
+	act_data.context = context;
+	act_data.executed = FALSE;
+		
+	/* First, check for duplicates or conflicts */
+	raction = result->first_action;
+	while ( raction != NULL ) {
+		const struct sieve_action *oact = raction->data.action;
+		
+		if ( keep && raction->keep ) {
+		
+			/* Duplicate keep */
+			if ( raction->data.executed ) {
+				/* Keep action from preceeding execution */
+			
+				/* Detach existing keep action */
+				sieve_result_action_detach(raction);
+
+				/* Merge existing side-effects with new keep action */
+				if ( kaction == NULL )
+					kaction = raction;
+			
+				if ( (ret=sieve_result_side_effects_merge
+					(renv, action, kaction->seffects, seffects)) <= 0 )	 
+					return ret;				
+			} else {
+				/* True duplicate */
+				
+				return sieve_result_side_effects_merge
+					(renv, action, raction->seffects, seffects);
+			}
+			
+		} if ( raction->data.action == action ) {
+			instance_count++;
+
+			/* Possible duplicate */
+			if ( action->check_duplicate != NULL ) {
+				if ( (ret=action->check_duplicate(renv, &act_data, &raction->data)) 
+					< 0 )
+					return ret;
+				
+				/* Duplicate */	
+				if ( ret == 1 ) {
+					if ( keep && !raction->keep ) {
+						/* New keep has higher precedence than existing duplicate non-keep 
+						 * action. So, take over the result action object and transform it
+						 * into a keep.
+						 */
+						 
+						if ( (ret=sieve_result_side_effects_merge
+							(renv, action, raction->seffects, seffects)) < 0 ) 
+							return ret;
+						 
+						if ( kaction == NULL ) {								
+							raction->data.context = NULL;
+							raction->data.location = p_strdup(result->pool, act_data.location);
+							
+							/* Note that existing execution status is retained, making sure 
+							 * that keep is not executed multiple times.
+							 */
+							
+							kaction = raction;
+												
+						} else {
+							sieve_result_action_detach(raction);
+
+							if ( (ret=sieve_result_side_effects_merge
+								(renv, action, kaction->seffects, raction->seffects)) < 0 ) 
+								return ret;
+						}
+					} else {
+						/* Merge side-effects, but don't add new action */
+						return sieve_result_side_effects_merge
+							(renv, action, raction->seffects, seffects);
+					}
+				}
+			}
+		} else {
+			if ( action != NULL && oact != NULL ) {
+				/* Check conflict */
+				if ( action->check_conflict != NULL &&
+					(ret=action->check_conflict(renv, &act_data, &raction->data)) != 0 ) 
+					return ret;
+			
+				if ( !raction->data.executed && oact->check_conflict != NULL &&
+					(ret=oact->check_conflict(renv, &raction->data, &act_data)) != 0 )
+					return ret;
+			}
+		}
+		raction = raction->next;
+	}
+
+	/* Check policy limit on total number of actions */
+	if ( sieve_max_actions > 0 && result->action_count >= sieve_max_actions ) {
+		sieve_runtime_error(renv, act_data.location, 
+			"total number of actions exceeds policy limit");
+		return -1;
+	}
+
+	/* Check policy limit on number of this class of actions */
+	if ( instance_limit > 0 && instance_count >= instance_limit ) {
+		sieve_runtime_error(renv, act_data.location, 
+			"number of %s actions exceeds policy limit", action->name);
+		return -1;
+	}	
+		
+	if ( kaction != NULL )
+		/* Use existing keep action to define new one */
+		raction = kaction;
+	else {
+		/* Create new action object */
+		raction = p_new(result->pool, struct sieve_result_action, 1);
+		raction->data.executed = FALSE;
+		raction->result = result;
+		raction->seffects = seffects;
+		raction->tr_context = NULL;
+		raction->success = FALSE;
+	}
+	
+	raction->data.context =	context;
+	raction->data.action = action;
+	raction->data.location = p_strdup(result->pool, act_data.location);
+	raction->keep = keep;
+
+	if ( raction->prev == NULL ) {
+		/* Add */
+		if ( result->first_action == NULL ) {
+			result->first_action = raction;
+			result->last_action = raction;
+			raction->prev = NULL;
+			raction->next = NULL;
+		} else {
+			result->last_action->next = raction;
+			raction->prev = result->last_action;
+			result->last_action = raction;
+			raction->next = NULL;
+		}
+		result->action_count++;
+	
+		/* Apply any implicit side effects */
+		if ( result->action_contexts != NULL ) {
+			struct sieve_result_action_context *actctx;
+		
+			/* Check for implicit side effects to this particular action */
+			actctx = (struct sieve_result_action_context *) 
+					hash_table_lookup(result->action_contexts, action);
+		
+			if ( actctx != NULL ) {
+				struct sieve_result_side_effect *iseff;
+			
+				/* Iterate through all implicit side effects and add those that are 
+				 * missing.
+				 */
+				iseff = actctx->seffects->first_effect;
+				while ( iseff != NULL ) {
+					struct sieve_result_side_effect *seff;
+					bool exists = FALSE;
+				
+					/* Scan for presence */
+					if ( seffects != NULL ) {
+						seff = seffects->first_effect;
+						while ( seff != NULL ) {
+							if ( seff->seffect == iseff->seffect ) {
+								exists = TRUE;
+								break;
+							}
+					
+							seff = seff->next;
+						}
+					} else {
+						raction->seffects = seffects = 
+							sieve_side_effects_list_create(result);
+					}
+				
+					/* If not present, add it */
+					if ( !exists ) {
+						sieve_side_effects_list_add
+							(seffects, iseff->seffect, iseff->context);
+					}
+				
+					iseff = iseff->next;
+				}
+			}
+		}
+	}
+	
+	return 0;
+}
+
+int sieve_result_add_action
+(const struct sieve_runtime_env *renv,
+	const struct sieve_action *action, struct sieve_side_effects_list *seffects,
+	unsigned int source_line, void *context, unsigned int instance_limit)
+{
+	return _sieve_result_add_action
+		(renv, action, seffects, source_line, context, instance_limit, FALSE);
+}
+
+int sieve_result_add_keep
+(const struct sieve_runtime_env *renv, struct sieve_side_effects_list *seffects,
+	unsigned int source_line)
+{
+	return _sieve_result_add_action
+		(renv, renv->result->keep_action, seffects, source_line, NULL, 0, TRUE);
+}
+
+void sieve_result_set_keep_action
+(struct sieve_result *result, const struct sieve_action *action)
+{
+	result->keep_action = action;
+}
+
+void sieve_result_set_failure_action
+(struct sieve_result *result, const struct sieve_action *action)
+{
+	result->failure_action = action;
+}
+
+/*
+ * Result printing
+ */
+
+void sieve_result_vprintf
+(const struct sieve_result_print_env *penv, const char *fmt, va_list args)
+{	
+	string_t *outbuf = t_str_new(128);
+
+	str_vprintfa(outbuf, fmt, args);
+	
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_result_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{	
+	va_list args;
+	
+	va_start(args, fmt);	
+	sieve_result_vprintf(penv, fmt, args);
+	va_end(args);	
+}
+
+void sieve_result_action_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{	
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_append(outbuf, " * ");
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+void sieve_result_seffect_printf
+(const struct sieve_result_print_env *penv, const char *fmt, ...)
+{	
+	string_t *outbuf = t_str_new(128);
+	va_list args;
+	
+	va_start(args, fmt);	
+	str_append(outbuf, "        + ");
+	str_vprintfa(outbuf, fmt, args);
+	str_append_c(outbuf, '\n');
+	va_end(args);
+	
+	o_stream_send(penv->stream, str_data(outbuf), str_len(outbuf));
+}
+
+static void sieve_result_print_side_effect
+(struct sieve_result_print_env *rpenv, const struct sieve_action *action,
+	struct sieve_side_effects_list *slist, bool *implicit_keep)
+{
+	struct sieve_result_side_effect *rsef;
+	const struct sieve_side_effect *sef;
+	
+	/* Print side effects */
+	rsef = slist != NULL ? slist->first_effect : NULL;
+	while ( rsef != NULL ) {
+		sef = rsef->seffect;
+		if ( sef->print != NULL ) 
+			sef->print(sef, action, rpenv, rsef->context, implicit_keep);
+		rsef = rsef->next;
+	}
+}
+
+bool sieve_result_print
+(struct sieve_result *result, const struct sieve_script_env *senv, 
+	struct ostream *stream, bool *keep)
+{
+	const struct sieve_action *act_keep = result->keep_action;
+	struct sieve_result_print_env penv;
+	bool implicit_keep = TRUE;
+	struct sieve_result_action *rac, *first_action;
+	
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	
+	if ( keep != NULL ) *keep = FALSE;
+	
+	/* Prepare environment */
+	
+	penv.result = result;
+	penv.stream = stream;
+	penv.scriptenv = senv;
+	
+	sieve_result_printf(&penv, "\nPerformed actions:\n\n");
+	
+	if ( first_action == NULL ) {
+		sieve_result_printf(&penv, "  (none)\n");
+	} else {		
+		rac = first_action;
+		while ( rac != NULL ) {		
+			bool impl_keep = TRUE;
+			const struct sieve_action *act = rac->data.action;
+
+			if ( rac->keep && keep != NULL ) *keep = TRUE;
+
+			if ( act != NULL ) {
+				if ( act->print != NULL )
+					act->print(act, &penv, rac->data.context, &impl_keep);
+				else
+					sieve_result_action_printf(&penv, "%s", act->name); 
+			} else {
+				if ( rac->keep ) {
+					sieve_result_action_printf(&penv, "keep");
+					impl_keep = FALSE;
+				} else {
+					sieve_result_action_printf(&penv, "[NULL]");
+				}
+			}
+	
+			/* Print side effects */
+			sieve_result_print_side_effect
+				(&penv, rac->data.action, rac->seffects, &impl_keep);
+			
+			implicit_keep = implicit_keep && impl_keep;		
+		
+			rac = rac->next;	
+		}
+	}
+	
+	if ( implicit_keep && keep != NULL ) *keep = TRUE;
+		
+	sieve_result_printf(&penv, "\nImplicit keep:\n\n");
+		
+	if ( implicit_keep ) {
+		bool dummy = TRUE;
+			
+		if ( act_keep == NULL ) 
+			sieve_result_action_printf(&penv, "keep");
+		else {
+			/* Scan for execution of keep-equal actions */	
+			rac = result->first_action;
+			while ( act_keep != NULL && rac != NULL ) {
+				if ( rac->data.action == act_keep && act_keep->equals != NULL && 
+					act_keep->equals(senv, NULL, rac->data.context) 
+						&& rac->data.executed ) {
+					act_keep = NULL;
+				}
+	 		
+				rac = rac->next;	
+			}
+			
+			if ( act_keep == NULL ) {
+				sieve_result_printf(&penv, 
+					"  (none; keep or equivalent action executed earlier)\n");
+			} else {
+				act_keep->print(act_keep, &penv, NULL, &dummy);
+			
+				/* Apply any implicit side effects if applicable */
+				if ( result->action_contexts != NULL ) {
+					struct sieve_result_action_context *actctx;
+		
+					/* Check for implicit side effects to keep action */
+					actctx = (struct sieve_result_action_context *) 
+							hash_table_lookup(result->action_contexts, act_keep);
+		
+					if ( actctx != NULL && actctx->seffects != NULL ) 
+						sieve_result_print_side_effect
+							(&penv, act_keep, actctx->seffects, &dummy);
+				}
+			}
+		}
+	} else 
+		sieve_result_printf(&penv, "  (none)\n");
+	
+	sieve_result_printf(&penv, "\n");
+	
+	return TRUE;
+}
+
+/*
+ * Result execution
+ */
+
+static bool _sieve_result_implicit_keep
+	(struct sieve_result *result, bool rollback)
+{	
+	struct sieve_result_action *rac;
+	bool success = TRUE;
+	bool dummy = TRUE;
+	struct sieve_result_side_effect *rsef, *rsef_first = NULL;
+	void *tr_context = NULL;
+	const struct sieve_action *act_keep;
+	
+	if ( rollback )
+		act_keep = result->failure_action;
+	else 
+		act_keep = result->keep_action;
+	
+	/* If keep is a non-action, return right away */
+	if ( act_keep == NULL ) return TRUE; 
+
+	/* Scan for execution of keep-equal actions */	
+	rac = result->first_action;
+	while ( rac != NULL ) {
+		if ( rac->data.action == act_keep && act_keep->equals != NULL && 
+			act_keep->equals(result->action_env.scriptenv, NULL, rac->data.context) &&
+			rac->data.executed )
+			return TRUE;
+ 		
+		rac = rac->next;	
+	}
+	
+	/* Apply any implicit side effects if applicable */
+	if ( !rollback && result->action_contexts != NULL ) {
+		struct sieve_result_action_context *actctx;
+		
+		/* Check for implicit side effects to keep action */
+		actctx = (struct sieve_result_action_context *) 
+				hash_table_lookup(result->action_contexts, act_keep);
+		
+		if ( actctx != NULL && actctx->seffects != NULL ) 
+			rsef_first = actctx->seffects->first_effect;
+	}
+	
+	/* Start keep action */
+	if ( act_keep->start != NULL ) 
+		success = act_keep->start
+			(act_keep, &result->action_env, NULL, &tr_context);
+
+	/* Execute keep action */
+	if ( success ) {
+		rsef = rsef_first;
+		while ( success && rsef != NULL ) {
+			const struct sieve_side_effect *sef = rsef->seffect;
+			if ( sef->pre_execute != NULL ) 
+				success = success && sef->pre_execute
+					(sef, act_keep, &result->action_env, &rsef->context, tr_context);
+			rsef = rsef->next;
+		}
+
+		if ( act_keep->execute != NULL )
+			success = success && act_keep->execute
+				(act_keep, &result->action_env, tr_context);
+
+		rsef = rsef_first;
+		while ( success && rsef != NULL ) {
+			const struct sieve_side_effect *sef = rsef->seffect;
+			if ( sef->post_execute != NULL ) 
+				success = success && sef->post_execute
+					(sef, act_keep, &result->action_env, rsef->context, tr_context);
+			rsef = rsef->next;
+		}
+	}
+	
+	/* Finish keep action */
+	if ( success ) {
+		if ( act_keep->commit != NULL ) 
+			success = act_keep->commit
+				(act_keep, &result->action_env, tr_context, &dummy);
+
+		rsef = rsef_first;
+		while ( rsef != NULL ) {
+			const struct sieve_side_effect *sef = rsef->seffect;
+			bool keep = TRUE;
+			
+			if ( sef->post_commit != NULL ) 
+				sef->post_commit
+					(sef, act_keep, &result->action_env, rsef->context, tr_context, 
+						&keep);
+			rsef = rsef->next;
+		}
+			
+		return success; 
+	}
+	
+	/* Failed, rollback */
+	if ( act_keep->rollback != NULL )
+		act_keep->rollback(act_keep, &result->action_env, tr_context, success);
+
+	return FALSE;
+}
+
+bool sieve_result_implicit_keep
+(struct sieve_result *result, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv)
+{
+	struct sieve_exec_status dummy_status;
+
+	result->action_env.msgdata = msgdata;
+	result->action_env.scriptenv = senv;
+	result->action_env.exec_status = 
+		( senv->exec_status == NULL ? &dummy_status : senv->exec_status );
+
+	return _sieve_result_implicit_keep(result, TRUE);	
+}
+
+void sieve_result_mark_executed(struct sieve_result *result)
+{
+	struct sieve_result_action *first_action, *rac;
+	
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	result->last_attempted_action = result->last_action;
+
+	rac = first_action;
+	while ( rac != NULL ) {
+		if ( rac->data.action != NULL )
+			rac->data.executed = TRUE;
+ 		
+		rac = rac->next;	
+	}
+}
+
+int sieve_result_execute
+(struct sieve_result *result, const struct sieve_message_data *msgdata,
+	const struct sieve_script_env *senv, bool *keep)
+{
+	struct sieve_exec_status dummy_status;
+	bool implicit_keep = TRUE;
+	bool success = TRUE, commit_ok;
+	struct sieve_result_action *rac, *first_action;
+	struct sieve_result_action *last_attempted;
+
+	if ( keep != NULL ) *keep = FALSE;
+
+	/* Prepare environment */
+
+	result->action_env.msgdata = msgdata;
+	result->action_env.scriptenv = senv;
+	result->action_env.exec_status = 
+		( senv->exec_status == NULL ? &dummy_status : senv->exec_status );
+	
+	/* Make notice of this attempt */
+	
+	first_action = ( result->last_attempted_action == NULL ?
+		result->first_action : result->last_attempted_action->next );
+	result->last_attempted_action = result->last_action;
+		
+	/* 
+	 * Transaction start 
+	 */
+	
+	rac = first_action;
+	while ( success && rac != NULL ) {
+		const struct sieve_action *act = rac->data.action;
+	
+		/* Skip non-actions (inactive keep) and executed ones */
+		if ( act == NULL || rac->data.executed ) {
+			rac = rac->next;	
+			continue;
+		}
+	
+		if ( act->start != NULL ) {
+			rac->success = act->start(act, &result->action_env, rac->data.context, 
+				&rac->tr_context);
+			success = success && rac->success;
+		} else {
+			rac->tr_context = rac->data.context;
+		}
+ 
+		rac = rac->next;	
+	}
+	
+	/* 
+	 * Transaction execute 
+	 */
+	
+	last_attempted = rac;
+	rac = first_action;
+	while ( success && rac != NULL ) {
+		const struct sieve_action *act = rac->data.action;
+		struct sieve_result_side_effect *rsef;
+		const struct sieve_side_effect *sef;
+		
+		/* Skip non-actions (inactive keep) and executed ones */
+		if ( act == NULL || rac->data.executed ) {
+			rac = rac->next;	
+			continue;
+		}
+				
+		/* Execute pre-execute event of side effects */
+		rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+		while ( success && rsef != NULL ) {
+			sef = rsef->seffect;
+			if ( sef->pre_execute != NULL ) 
+				success = success & sef->pre_execute
+					(sef, act, &result->action_env, &rsef->context, rac->tr_context);
+			rsef = rsef->next;
+		}
+	
+		/* Execute the action itself */
+		if ( success && act->execute != NULL ) {
+			rac->success = act->execute(act, &result->action_env, rac->tr_context);
+			success = success && rac->success;
+		}
+		
+		/* Execute post-execute event of side effects */
+		rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+		while ( success && rsef != NULL ) {
+			sef = rsef->seffect;
+			if ( sef->post_execute != NULL ) 
+				success = success && sef->post_execute
+					(sef, act, &result->action_env, rsef->context, rac->tr_context);
+			rsef = rsef->next;
+		}
+		 
+		rac = rac->next;	
+	}
+	
+	/* 
+	 * Transaction commit/rollback 
+	 */
+
+	commit_ok = success;
+	rac = first_action;
+	while ( rac != NULL && rac != last_attempted ) {
+		const struct sieve_action *act = rac->data.action;
+		struct sieve_result_side_effect *rsef;
+		const struct sieve_side_effect *sef;
+		
+		if ( success ) {
+			bool impl_keep = TRUE;
+			
+			if ( rac->keep && keep != NULL ) *keep = TRUE;
+
+			/* Skip non-actions (inactive keep) and executed ones */
+			if ( act == NULL || rac->data.executed ) {
+				rac = rac->next;	
+				continue;
+			}
+			
+			if ( act->commit != NULL ) { 
+				rac->data.executed = act->commit
+					(act, &result->action_env, rac->tr_context, &impl_keep);
+				commit_ok = rac->data.executed && commit_ok;
+			}
+	
+			/* Execute post_commit event of side effects */
+			rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				sef = rsef->seffect;
+				if ( sef->post_commit != NULL ) 
+					sef->post_commit
+						(sef, act, &result->action_env, rsef->context, rac->tr_context, 
+							&impl_keep);
+				rsef = rsef->next;
+			}
+			
+			implicit_keep = implicit_keep && impl_keep;
+		} else {
+			/* Skip non-actions (inactive keep) and executed ones */
+			if ( act == NULL || rac->data.executed ) {
+				rac = rac->next;	
+				continue;
+			}
+		
+			if ( act->rollback != NULL ) 
+				act->rollback(act, &result->action_env, rac->tr_context, rac->success);
+				
+			/* Rollback side effects */
+			rsef = rac->seffects != NULL ? rac->seffects->first_effect : NULL;
+			while ( rsef != NULL ) {
+				sef = rsef->seffect;
+				if ( sef->rollback != NULL ) 
+					sef->rollback
+						(sef, act, &result->action_env, rsef->context, rac->tr_context, 
+						rac->success);
+				rsef = rsef->next;
+			}
+		}
+		
+		rac = rac->next;	
+	}
+	
+	if ( implicit_keep && keep != NULL ) *keep = TRUE;
+	
+	/* Return value indicates whether the caller should attempt an implicit keep 
+	 * of its own. So, if the above transaction fails, but the implicit keep below
+	 * succeeds, the return value is still true. An error is/should be logged 
+	 * though.
+	 */
+	
+	/* Execute implicit keep if the transaction failed or when the implicit keep
+	 * was not canceled during transaction. 
+	 */
+	if ( !commit_ok || implicit_keep ) {		
+		if ( !_sieve_result_implicit_keep(result, !commit_ok) ) 
+			return SIEVE_EXEC_KEEP_FAILED;
+			
+		return ( commit_ok ? 
+			SIEVE_EXEC_OK            /* Success */ :
+			SIEVE_EXEC_FAILURE       /* Implicit keep executed */ );
+	}
+	
+	/* Unconditional success */
+	return SIEVE_EXEC_OK;
+}
+
+/*
+ * Result evaluation
+ */
+
+struct sieve_result_iterate_context {
+	struct sieve_result *result;
+	struct sieve_result_action *action;
+};
+
+struct sieve_result_iterate_context *sieve_result_iterate_init
+(struct sieve_result *result)
+{
+	struct sieve_result_iterate_context *rictx = 
+		t_new(struct sieve_result_iterate_context, 1);
+	
+	rictx->result = result;
+	rictx->action = result->first_action;
+
+	return rictx;
+}
+
+const struct sieve_action *sieve_result_iterate_next
+	(struct sieve_result_iterate_context *rictx, bool *keep, void **context)
+{
+	struct sieve_result_action *rac;
+
+	if ( rictx == NULL )
+		return  NULL;
+
+	rac = rictx->action;
+	if ( rac != NULL ) {
+		rictx->action = rac->next;
+		
+		if ( keep != NULL )
+			*keep = rac->keep;
+
+		if ( context != NULL )
+			*context = rac->data.context;
+	
+		return rac->data.action;
+	}
+
+	return NULL;
+}
+
+/*
+ * Side effects list
+ */
+ 
+struct sieve_side_effects_list *sieve_side_effects_list_create
+	(struct sieve_result *result)
+{
+	struct sieve_side_effects_list *list = 
+		p_new(result->pool, struct sieve_side_effects_list, 1);
+	
+	list->result = result;
+	list->first_effect = NULL;
+	list->last_effect = NULL;
+	
+	return list;
+};
+
+void sieve_side_effects_list_add
+(struct sieve_side_effects_list *list, const struct sieve_side_effect *seffect, 
+	void *context)		
+{
+	struct sieve_result_side_effect *reffect;
+	
+	/* Create new side effect object */
+	reffect = p_new(list->result->pool, struct sieve_result_side_effect, 1);
+	reffect->seffect = seffect;
+	reffect->context = context;
+	
+	/* Add */
+	if ( list->first_effect == NULL ) {
+		list->first_effect = reffect;
+		list->last_effect = reffect;
+		reffect->prev = NULL;
+		reffect->next = NULL;
+	} else {
+		list->last_effect->next = reffect;
+		reffect->prev = list->last_effect;
+		list->last_effect = reffect;
+		reffect->next = NULL;
+	}	
+}	
+
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-result.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-result.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-result.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-result.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,141 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_RESULT_H
+#define __SIEVE_RESULT_H
+
+#include "sieve-common.h"
+
+/*
+ * Types
+ */
+ 
+struct sieve_side_effects_list;
+
+/*
+ * Result object
+ */
+
+struct sieve_result;
+
+struct sieve_result *sieve_result_create
+	(struct sieve_error_handler *ehandler);
+
+void sieve_result_ref(struct sieve_result *result); 
+
+void sieve_result_unref(struct sieve_result **result); 
+
+pool_t sieve_result_pool(struct sieve_result *result);
+
+struct sieve_error_handler *sieve_result_get_error_handler
+	(struct sieve_result *result);
+void sieve_result_set_error_handler
+	(struct sieve_result *result, struct sieve_error_handler *ehandler);
+
+/*
+ * Extension support
+ */
+
+void sieve_result_extension_set_context
+	(struct sieve_result *result, const struct sieve_extension *ext,
+		void *context);
+const void *sieve_result_extension_get_context
+	(struct sieve_result *result, const struct sieve_extension *ext); 
+
+/* 
+ * Result printing 
+ */
+
+struct sieve_result_print_env {
+	struct sieve_result *result;
+	const struct sieve_script_env *scriptenv;
+	struct ostream *stream;
+};
+
+void sieve_result_vprintf
+	(const struct sieve_result_print_env *penv, const char *fmt, va_list args);
+void sieve_result_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_action_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_seffect_printf
+	(const struct sieve_result_print_env *penv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+bool sieve_result_print
+	(struct sieve_result *result, const struct sieve_script_env *senv, 
+		struct ostream *stream, bool *keep);
+
+/* 
+ * Error handling 
+ */
+
+void sieve_result_log
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_warning
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+void sieve_result_error
+	(const struct sieve_action_exec_env *aenv, const char *fmt, ...)
+		ATTR_FORMAT(2, 3);
+
+/*
+ * Result composition
+ */
+ 
+void sieve_result_add_implicit_side_effect
+(struct sieve_result *result, const struct sieve_action *to_action, 
+	const struct sieve_side_effect *seffect, void *context);
+	
+int sieve_result_add_action
+	(const struct sieve_runtime_env *renv, const struct sieve_action *action, 
+		struct sieve_side_effects_list *seffects, unsigned int source_line, 
+		void *context, unsigned int instance_limit);
+int sieve_result_add_keep
+	(const struct sieve_runtime_env *renv, 
+		struct sieve_side_effects_list *seffects, unsigned int source_line);
+
+void sieve_result_set_keep_action
+	(struct sieve_result *result, const struct sieve_action *action);
+void sieve_result_set_failure_action
+	(struct sieve_result *result, const struct sieve_action *action);
+
+/*
+ * Result execution
+ */
+ 
+bool sieve_result_implicit_keep
+	(struct sieve_result *result, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv);
+
+void sieve_result_mark_executed(struct sieve_result *result);
+
+int sieve_result_execute
+	(struct sieve_result *result, const struct sieve_message_data *msgdata,
+		const struct sieve_script_env *senv, bool *keep);
+
+/*
+ * Result evaluation
+ */
+
+struct sieve_result_iterate_context;
+
+struct sieve_result_iterate_context *sieve_result_iterate_init
+	(struct sieve_result *result);
+const struct sieve_action *sieve_result_iterate_next
+	(struct sieve_result_iterate_context *rictx, bool *keep, void **context);
+	
+/*
+ * Side effects list
+ */
+ 
+struct sieve_side_effects_list *sieve_side_effects_list_create
+	(struct sieve_result *result);
+void sieve_side_effects_list_add
+(struct sieve_side_effects_list *list, const struct sieve_side_effect *seffect, 
+	void *context);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-script.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-script.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-script.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-script.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,340 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "istream.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+#include "sieve-script-private.h"
+
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/*
+ * Configuration
+ */
+ 
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+/*
+ * Filename to name/name to filename
+ */
+
+static inline const char *_sieve_scriptfile_get_basename(const char *filename)
+{
+	const char *ext;
+
+	/* Extract the script name */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return filename;
+	
+	return t_strdup_until(filename, ext);	
+}
+
+bool sieve_script_file_has_extension(const char *filename)
+{
+	const char *ext;
+
+ 	/* See if it ends in .sieve already */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return FALSE;
+
+	return TRUE;
+}
+
+static inline const char *_sieve_scriptfile_from_name(const char *name)
+{
+	if ( !sieve_script_file_has_extension(name) )
+		return t_strconcat(name, ".sieve", NULL);
+
+	return name;
+}
+
+
+/* 
+ * Script object 
+ */
+ 
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	int ret;
+	pool_t pool;
+	struct stat st;
+	struct stat lnk_st;
+	const char *filename, *dirpath, *basename, *binpath;
+
+	if ( exists_r != NULL )
+		*exists_r = TRUE;
+
+	T_BEGIN {
+
+		/* Extract filename from path */
+
+		filename = strrchr(path, '/');
+		if ( filename == NULL ) {
+			dirpath = "";
+			filename = path;
+		} else {
+			dirpath = t_strdup_until(path, filename);
+			filename++;
+		}
+
+		basename = _sieve_scriptfile_get_basename(filename);
+		binpath = t_strconcat(dirpath, "/", basename, ".svbin", NULL);
+				
+		if ( name == NULL ) {
+			name = basename; 
+		} else if ( *name == '\0' ) {
+			name = NULL;
+		} else {
+			basename = name;
+		}
+			
+		/* First obtain stat data from the system */
+		
+		if ( (ret=lstat(path, &st)) < 0 ) {
+			if ( errno == ENOENT ) {
+				if ( exists_r == NULL ) 
+					sieve_error(ehandler, basename, "sieve script does not exist");
+				else
+					*exists_r = FALSE;
+			} else
+				sieve_critical(ehandler, basename, 
+					"failed to lstat sieve script file '%s': %m", path);
+
+			script = NULL;
+			ret = 1;
+
+		} else {
+			/* Record stat information from the symlink */
+			lnk_st = st;
+
+			/* Only create/init the object if it stat()s without problems */
+			if (S_ISLNK(st.st_mode)) {
+				if ( (ret=stat(path, &st)) < 0 ) { 
+					if ( errno == ENOENT ) {
+						if ( exists_r == NULL )
+							sieve_error(ehandler, basename, "sieve script does not exist");
+						else
+							*exists_r = FALSE;
+					} else
+						sieve_critical(ehandler, basename, 
+							"failed to stat sieve script file '%s': %m", path);
+
+					script = NULL;	
+					ret = 1;
+				}
+			}
+
+			if ( ret == 0 && !S_ISREG(st.st_mode) ) {
+				sieve_critical(ehandler, basename, 
+					"sieve script file '%s' is not a regular file.", path);
+				script = NULL;
+				ret = 1;
+			} 
+		}
+
+		if ( ret <= 0 ) {
+			if ( script == NULL ) {
+				pool = pool_alloconly_create("sieve_script", 1024);
+				script = p_new(pool, struct sieve_script, 1);
+				script->pool = pool;
+			} else 
+				pool = script->pool;
+		
+			script->refcount = 1;
+			script->ehandler = ehandler;
+			sieve_error_handler_ref(ehandler);
+		
+			script->st = st;
+			script->lnk_st = lnk_st;
+			script->path = p_strdup(pool, path);
+			script->filename = p_strdup(pool, filename);
+			script->dirpath = p_strdup(pool, dirpath);
+			script->binpath = p_strdup(pool, binpath);
+			script->basename = p_strdup(pool, basename);
+
+			if ( name != NULL )
+				script->name = p_strdup(pool, name);
+			else
+				script->name = NULL;
+		}
+	} T_END;	
+
+	return script;
+}
+
+struct sieve_script *sieve_script_create
+(const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+struct sieve_script *sieve_script_create_in_directory
+(const char *dirpath, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	const char *path;
+
+	if ( dirpath[strlen(dirpath)-1] == '/' )
+		path = t_strconcat(dirpath, 
+			_sieve_scriptfile_from_name(name), NULL);
+	else
+		path = t_strconcat(dirpath, "/",
+			_sieve_scriptfile_from_name(name), NULL);
+
+	return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+void sieve_script_ref(struct sieve_script *script)
+{
+	script->refcount++;
+}
+
+void sieve_script_unref(struct sieve_script **script)
+{
+	i_assert((*script)->refcount > 0);
+
+	if (--(*script)->refcount != 0)
+		return;
+
+	if ( (*script)->stream != NULL )
+		i_stream_destroy(&(*script)->stream);
+
+	sieve_error_handler_unref(&(*script)->ehandler);
+
+	pool_unref(&(*script)->pool);
+
+	*script = NULL;
+}
+
+/* 
+ * Accessors 
+ */
+
+const char *sieve_script_name(const struct sieve_script *script)
+{
+	return script->name;
+}
+
+const char *sieve_script_filename(const struct sieve_script *script)
+{
+	return script->filename;
+}
+
+const char *sieve_script_path(const struct sieve_script *script)
+{
+	return script->path;
+}
+
+const char *sieve_script_dirpath(const struct sieve_script *script)
+{
+	return script->dirpath;
+}
+
+const char *sieve_script_binpath(const struct sieve_script *script)
+{
+	return script->binpath;
+}
+
+mode_t sieve_script_permissions(const struct sieve_script *script)
+{
+	return script->st.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO);
+}
+
+/* 
+ * Stream manageement 
+ */
+
+struct istream *sieve_script_open
+(struct sieve_script *script, bool *deleted_r)
+{
+	int fd;
+	struct stat st;
+	struct istream *result;
+
+	if ( deleted_r != NULL )
+		*deleted_r = FALSE;
+
+	if ( (fd=open(script->path, O_RDONLY)) < 0 ) {
+		if ( errno == ENOENT ) 
+			if ( deleted_r == NULL ) 
+				/* Not supposed to occur, create() does stat already */
+				sieve_error(script->ehandler, script->basename, 
+					"sieve script does not exist");
+			else 
+				*deleted_r = TRUE;
+		else
+			sieve_critical(script->ehandler, script->path, 
+				"failed to open sieve script: %m");
+		return NULL;
+	}	
+	
+	if ( fstat(fd, &st) != 0 ) {
+		sieve_critical(script->ehandler, script->path, 
+			"failed to fstat opened sieve script: %m");
+		result = NULL;
+	} else {
+		/* Re-check the file type just to be sure */
+		if ( !S_ISREG(st.st_mode) ) {
+			sieve_critical(script->ehandler, script->path,
+				"opened sieve script file is not a regular file");
+			result = NULL;
+		} else {
+			result = script->stream = 
+				i_stream_create_fd(fd, SIEVE_READ_BLOCK_SIZE, TRUE);
+			script->st = script->lnk_st = st;
+		}
+	}
+
+	if ( result == NULL ) {
+		/* Something went wrong, close the fd */
+		if ( close(fd) != 0 ) {
+			sieve_sys_error(
+				"close(fd) failed for sieve script %s: %m", 
+				script->path);
+		}
+	}
+	
+	return result;
+}
+
+void sieve_script_close(struct sieve_script *script)
+{
+	i_stream_destroy(&script->stream);
+}
+
+uoff_t sieve_script_get_size(const struct sieve_script *script)
+{
+	return script->st.st_size;
+}
+
+/* 
+ * Comparison 
+ */
+
+int sieve_script_cmp
+(const struct sieve_script *script1, const struct sieve_script *script2)
+{	
+	return ( script1->st.st_ino == script2->st.st_ino ) ? 0 : -1;
+}
+
+unsigned int sieve_script_hash(const struct sieve_script *script)
+{	
+	return (unsigned int) script->st.st_ino;
+}
+
+bool sieve_script_older
+(const struct sieve_script *script, time_t time)
+{
+	return ( script->st.st_mtime < time && script->lnk_st.st_mtime < time );
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-script.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-script.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-script.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-script.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,70 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_H
+#define __SIEVE_SCRIPT_H
+
+#include "sieve-common.h"
+
+#include <sys/types.h>
+
+/*
+ * Sieve script object
+ */
+
+struct sieve_script;
+
+struct sieve_script *sieve_script_create
+	(const char *path, const char *name, 
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+struct sieve_script *sieve_script_create_in_directory
+	(const char *dirpath, const char *name,
+    	struct sieve_error_handler *ehandler, bool *exists_r);
+
+void sieve_script_ref(struct sieve_script *script);
+void sieve_script_unref(struct sieve_script **script);
+
+/*
+ * Filename filter
+ */
+ 
+bool sieve_script_file_has_extension(const char *filename);
+
+/*
+ * Accessors
+ */
+ 
+const char *sieve_script_name(const struct sieve_script *script);
+const char *sieve_script_filename(const struct sieve_script *script);
+const char *sieve_script_path(const struct sieve_script *script);
+const char *sieve_script_binpath(const struct sieve_script *script);
+const char *sieve_script_dirpath(const struct sieve_script *script);
+
+mode_t sieve_script_permissions(const struct sieve_script *script);
+
+/* 
+ * Stream management 
+ */
+
+struct istream *sieve_script_open(struct sieve_script *script, bool *deleted_r);
+void sieve_script_close(struct sieve_script *script);
+
+uoff_t sieve_script_get_size(const struct sieve_script *script);
+
+/*
+ * Comparison
+ */
+ 
+int sieve_script_cmp
+	(const struct sieve_script *script1, const struct sieve_script *script2);
+unsigned int sieve_script_hash(const struct sieve_script *script);
+bool sieve_script_older(const struct sieve_script *script, time_t time);
+
+static inline bool sieve_script_equals
+	(const struct sieve_script *script1, const struct sieve_script *script2)
+{
+	return ( sieve_script_cmp(script1, script2) == 0 );
+}
+
+#endif /* __SIEVE_SCRIPT_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-script-private.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-script-private.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-script-private.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-script-private.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,40 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_PRIVATE_H
+#define __SIEVE_SCRIPT_PRIVATE_H
+
+#include "sieve-script.h"
+
+/*
+ * Script object
+ */
+
+struct sieve_script {
+	pool_t pool;
+	unsigned int refcount;
+
+	struct stat st;
+	struct stat lnk_st;
+	time_t mtime;
+
+	struct sieve_error_handler *ehandler;
+
+	/* Parameters */
+	const char *name;
+	const char *basename;
+	const char *filename;
+	const char *path;
+	const char *dirpath;
+	const char *binpath;
+
+	/* Stream */
+	int fd; /* FIXME: we could use the stream's autoclose facility */
+	struct istream *stream;
+};
+
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r);
+
+#endif /* __SIEVE_SCRIPT_PRIVATE_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-types.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-types.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-types.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-types.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,98 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#ifndef __SIEVE_TYPES_H
+#define __SIEVE_TYPES_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+/* Enable runtime trace functionality */
+#define SIEVE_RUNTIME_TRACE
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_script;
+struct sieve_binary;
+
+/* 
+ * Message data
+ *
+ * - The mail message + envelope data 
+ */
+
+struct sieve_message_data {
+	struct mail *mail;
+	const char *return_path;
+	const char *to_address;
+	const char *auth_user;
+	const char *id;
+};
+
+/* 
+ * Script environment
+ *
+ * - Environment for currently executing script 
+ */
+
+struct sieve_script_env {
+	/* Mail-related */
+	struct mail_namespace *namespaces;
+	const char *default_mailbox;
+	bool mailbox_autocreate;
+	bool mailbox_autosubscribe;
+	
+	/* System-related */
+	const char *username;
+	const char *hostname;
+	const char *postmaster_address;
+		
+	/* Callbacks */
+	
+	/* Interface for sending mail */
+	void *(*smtp_open)
+		(const char *destination, const char *return_path, FILE **file_r);
+	bool (*smtp_close)(void *handle);
+	
+	/* Interface for marking and checking duplicates */
+	int (*duplicate_check)
+		(const void *id, size_t id_size, const char *user);
+	void (*duplicate_mark)
+		(const void *id, size_t id_size, const char *user, time_t time);
+	
+	/* Execution status record */	
+	struct sieve_exec_status *exec_status;
+		
+	/* Trace stream */
+	struct ostream *trace_stream;
+};
+
+#define SIEVE_SCRIPT_DEFAULT_MAILBOX(senv) \
+	(senv->default_mailbox == NULL ? "INBOX" : senv->default_mailbox )
+
+/*
+ * Script executionstatus
+ */	
+
+struct sieve_exec_status {
+	bool message_saved;
+	bool message_forwarded;
+	bool tried_default_save;
+	struct mail_storage *last_storage;
+};
+
+/*
+ * Execution exit codes
+ */
+
+enum sieve_execution_exitcode {
+	SIEVE_EXEC_OK          = 1,
+	SIEVE_EXEC_FAILURE     = 0,
+	SIEVE_EXEC_BIN_CORRUPT = -1,
+	SIEVE_EXEC_KEEP_FAILED = -2
+};
+
+#endif /* __SIEVE_TYPES_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-validator.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-validator.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-validator.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-validator.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,1291 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "array.h"
+#include "buffer.h"
+#include "mempool.h"
+#include "hash.h"
+
+#include "sieve-common.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-ast.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+
+#include "sieve-comparators.h"
+#include "sieve-address-parts.h"
+
+/*
+ * Forward declarations
+ */
+ 
+static void sieve_validator_register_core_commands
+	(struct sieve_validator *validator);
+static void sieve_validator_register_core_tests
+	(struct sieve_validator *validator);
+	
+/*
+ * Types
+ */
+ 
+/* Tag registration */
+
+struct sieve_tag_registration {
+	const struct sieve_argument *tag;
+	const char *identifier;	
+	int id_code;
+};
+
+/* Command registration */
+
+struct sieve_command_registration {
+	const struct sieve_command *command;
+	
+	ARRAY_DEFINE(normal_tags, struct sieve_tag_registration *); 
+	ARRAY_DEFINE(instanced_tags, struct sieve_tag_registration *); 
+	ARRAY_DEFINE(persistent_tags, struct sieve_tag_registration *); 
+};
+ 
+/* Default (literal) arguments */
+
+struct sieve_default_argument {
+	const struct sieve_argument *argument;
+	struct sieve_default_argument *overrides;
+};
+
+/* 
+ * Validator extension
+ */
+
+struct sieve_validator_extension_reg {
+	const struct sieve_validator_extension *val_ext;
+	struct sieve_ast_argument *arg;
+	void *context;
+
+	bool loaded;
+};
+
+/* 
+ * Validator
+ */
+
+struct sieve_validator {
+	pool_t pool;
+
+	struct sieve_ast *ast;
+	struct sieve_script *script;
+	
+	struct sieve_error_handler *ehandler;
+
+	bool finished_require;
+	
+	/* Registries */
+	
+	struct hash_table *commands;
+	
+	ARRAY_DEFINE(extensions, struct sieve_validator_extension_reg);
+	
+	/* This is currently a wee bit ugly and needs more thought */
+	struct sieve_default_argument default_arguments[SAT_COUNT];
+
+	/* Default argument processing state (FIXME: ugly) */
+	struct sieve_default_argument *current_defarg;
+	enum sieve_argument_type current_defarg_type;
+	bool current_defarg_constant;
+};
+
+/* 
+ * Error handling 
+ */
+
+void sieve_validator_warning
+(struct sieve_validator *validator, unsigned int source_line, 
+	const char *fmt, ...) 
+{ 
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vwarning(validator->ehandler, 
+		sieve_error_script_location(validator->script, source_line),
+		fmt, args);
+	va_end(args);
+	
+}
+ 
+void sieve_validator_error
+(struct sieve_validator *validator, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_verror(validator->ehandler, 
+		sieve_error_script_location(validator->script, source_line),
+		fmt, args);
+	va_end(args);
+}
+
+void sieve_validator_critical
+(struct sieve_validator *validator, unsigned int source_line, 
+	const char *fmt, ...) 
+{
+	va_list args;
+	
+	va_start(args, fmt);
+	sieve_vcritical(validator->ehandler, 
+		sieve_error_script_location(validator->script, source_line),
+		fmt, args);
+	va_end(args);
+}
+
+/* 
+ * Validator object 
+ */
+
+struct sieve_validator *sieve_validator_create
+(struct sieve_ast *ast, struct sieve_error_handler *ehandler) 
+{
+	unsigned int i;
+	pool_t pool;
+	struct sieve_validator *validator;
+	
+	pool = pool_alloconly_create("sieve_validator", 8192);	
+	validator = p_new(pool, struct sieve_validator, 1);
+	validator->pool = pool;
+	
+	validator->ehandler = ehandler;
+	sieve_error_handler_ref(ehandler);
+	
+	validator->ast = ast;	
+	validator->script = sieve_ast_script(ast);
+	sieve_ast_ref(ast);
+
+	/* Setup default arguments */
+	validator->default_arguments[SAT_NUMBER].
+		argument = &number_argument;
+	validator->default_arguments[SAT_VAR_STRING].
+		argument = &string_argument;
+	validator->default_arguments[SAT_CONST_STRING].
+		argument = &string_argument;
+	validator->default_arguments[SAT_STRING_LIST].
+		argument = &string_list_argument;
+
+	/* Setup storage for extension contexts */		
+	p_array_init(&validator->extensions, pool, sieve_extensions_get_count());
+		
+	/* Setup command registry */
+	validator->commands = hash_table_create
+		(default_pool, pool, 0, strcase_hash, (hash_cmp_callback_t *)strcasecmp);
+	sieve_validator_register_core_commands(validator);
+	sieve_validator_register_core_tests(validator);
+	
+	/* Pre-load core language features implemented as 'extensions' */
+	for ( i = 0; i < sieve_preloaded_extensions_count; i++ ) {
+		const struct sieve_extension *ext = sieve_preloaded_extensions[i];
+		
+		if ( ext->validator_load != NULL )
+			(void)ext->validator_load(validator);
+	}
+	
+	return validator;
+}
+
+void sieve_validator_free(struct sieve_validator **validator) 
+{
+	const struct sieve_validator_extension_reg *extrs;
+	unsigned int ext_count, i;
+
+	hash_table_destroy(&(*validator)->commands);
+	sieve_ast_unref(&(*validator)->ast);
+
+	sieve_error_handler_unref(&(*validator)->ehandler);
+
+	/* Signal registered extensions that the validator is being destroyed */
+	extrs = array_get(&(*validator)->extensions, &ext_count);
+	for ( i = 0; i < ext_count; i++ ) {
+		if ( extrs[i].val_ext != NULL && extrs[i].val_ext->free != NULL )
+			extrs[i].val_ext->free(*validator, extrs[i].context);
+	}
+
+	pool_unref(&(*validator)->pool);
+
+	*validator = NULL;
+}
+
+/*
+ * Accessors
+ */
+
+pool_t sieve_validator_pool(struct sieve_validator *validator)
+{
+	return validator->pool;
+}
+
+struct sieve_error_handler *sieve_validator_error_handler
+(struct sieve_validator *validator)
+{
+	return validator->ehandler;
+}
+
+struct sieve_ast *sieve_validator_ast
+(struct sieve_validator *validator)
+{
+	return validator->ast;
+}
+
+struct sieve_script *sieve_validator_script
+(struct sieve_validator *validator)
+{
+	return validator->script;
+}
+
+/* 
+ * Command registry 
+ */
+
+/* Dummy command object to mark unknown commands in the registry */
+
+static bool _cmd_unknown_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *cmd ATTR_UNUSED) 
+{
+	i_unreached();
+	return FALSE;
+}
+
+static const struct sieve_command unknown_command = { 
+	"", SCT_NONE, 0, 0, FALSE, FALSE , 
+	NULL, NULL, _cmd_unknown_validate, NULL, NULL 
+};
+
+/* Registration of the core commands of the language */
+
+static void sieve_validator_register_core_tests
+(struct sieve_validator *validator) 
+{
+	unsigned int i;
+	
+	for ( i = 0; i < sieve_core_tests_count; i++ ) {
+		sieve_validator_register_command(validator, sieve_core_tests[i]); 
+	}
+}
+
+static void sieve_validator_register_core_commands
+(struct sieve_validator *validator) 
+{
+	unsigned int i;
+	
+	for ( i = 0; i < sieve_core_commands_count; i++ ) {
+		sieve_validator_register_command(validator, sieve_core_commands[i]); 
+	}
+}
+
+/* Registry functions */
+
+static struct sieve_command_registration *
+sieve_validator_find_command_registration
+(struct sieve_validator *validator, const char *command) 
+{
+	return (struct sieve_command_registration *) 
+		hash_table_lookup(validator->commands, command);
+}
+
+static struct sieve_command_registration *_sieve_validator_register_command
+(struct sieve_validator *validator, const struct sieve_command *command,
+	const char *identifier) 
+{
+	struct sieve_command_registration *record = 
+		p_new(validator->pool, struct sieve_command_registration, 1);
+	record->command = command;
+	hash_table_insert(validator->commands, (void *) identifier, (void *) record);
+		
+	return record;
+}
+
+void sieve_validator_register_command
+(struct sieve_validator *validator, const struct sieve_command *command) 
+{
+	struct sieve_command_registration *cmd_reg =
+		sieve_validator_find_command_registration(validator, command->identifier);
+		
+	if ( cmd_reg == NULL ) 
+		cmd_reg = _sieve_validator_register_command
+			(validator, command, command->identifier);
+	else
+		cmd_reg->command = command;
+	
+	if ( command->registered != NULL ) 
+		command->registered(validator, cmd_reg);
+}
+
+static void sieve_validator_register_unknown_command
+(struct sieve_validator *validator, const char *command) 
+{
+	(void)_sieve_validator_register_command(validator, &unknown_command, command);		
+}
+
+const struct sieve_command *sieve_validator_find_command
+(struct sieve_validator *validator, const char *command) 
+{
+  struct sieve_command_registration *record = 
+  	sieve_validator_find_command_registration(validator, command);
+  
+  return ( record == NULL ? NULL : record->command );
+}
+
+/* 
+ * Per-command tagged argument registry 
+ */
+
+/* Dummy argument object to mark unknown arguments in the registry */
+
+static bool _unknown_tag_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *tst ATTR_UNUSED)
+{
+	i_unreached();
+	return FALSE;
+}
+
+static const struct sieve_argument _unknown_tag = { 
+	"", 
+	NULL, NULL, 
+	_unknown_tag_validate, 
+	NULL, NULL 
+};
+
+/* Registry functions */
+
+static void _sieve_validator_register_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg, 
+	const struct sieve_argument *tag, const char *identifier, int id_code) 
+{
+	struct sieve_tag_registration *reg;
+
+	reg = p_new(validator->pool, struct sieve_tag_registration, 1);
+	reg->tag = tag;
+	reg->id_code = id_code;
+	if ( identifier == NULL )
+		reg->identifier = tag->identifier;
+	else
+		reg->identifier = p_strdup(validator->pool, identifier);
+	
+	if ( !array_is_created(&cmd_reg->normal_tags) )
+		p_array_init(&cmd_reg->normal_tags, validator->pool, 4);
+
+	array_append(&cmd_reg->normal_tags, &reg, 1);
+}
+
+void sieve_validator_register_persistent_tag
+(struct sieve_validator *validator, const struct sieve_argument *tag, 
+	const char *command)
+{
+	struct sieve_command_registration *cmd_reg = 
+		sieve_validator_find_command_registration(validator, command);
+	struct sieve_tag_registration *reg = 
+		p_new(validator->pool, struct sieve_tag_registration, 1);
+	
+	reg->tag = tag;
+	reg->id_code = -1;
+	
+	if ( cmd_reg == NULL ) {
+		cmd_reg = _sieve_validator_register_command(validator, NULL, command);
+	}	
+		
+	/* Add the tag to the persistent tags list if necessary */
+	if ( tag->validate_persistent != NULL ) {
+		if ( !array_is_created(&cmd_reg->persistent_tags) ) 
+			p_array_init(&cmd_reg->persistent_tags, validator->pool, 4);
+				
+		array_append(&cmd_reg->persistent_tags, &reg, 1);
+	}
+}
+
+void sieve_validator_register_external_tag
+(struct sieve_validator *validator, const struct sieve_argument *tag, 
+	const char *command, int id_code) 
+{
+	struct sieve_command_registration *cmd_reg = 
+		sieve_validator_find_command_registration(validator, command);
+		
+	if ( cmd_reg == NULL ) {
+		cmd_reg = _sieve_validator_register_command(validator, NULL, command);
+	}
+	
+	_sieve_validator_register_tag
+		(validator, cmd_reg, tag, NULL, id_code);
+}
+
+void sieve_validator_register_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg, 
+	const struct sieve_argument *tag, int id_code) 
+{
+	if ( tag->is_instance_of == NULL )
+		_sieve_validator_register_tag(validator, cmd_reg, tag, NULL, id_code);
+	else {
+		struct sieve_tag_registration *reg = 
+			p_new(validator->pool, struct sieve_tag_registration, 1);
+		reg->tag = tag;
+		reg->id_code = id_code;
+
+		if ( !array_is_created(&cmd_reg->instanced_tags) ) 
+				p_array_init(&cmd_reg->instanced_tags, validator->pool, 4);
+				
+		array_append(&cmd_reg->instanced_tags, &reg, 1);
+	}
+}
+
+static void sieve_validator_register_unknown_tag
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg, 
+	const char *tag) 
+{
+	_sieve_validator_register_tag(validator, cmd_reg, &_unknown_tag, tag, 0);
+}
+
+static const struct sieve_argument *sieve_validator_find_tag
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, int *id_code) 
+{
+	struct sieve_command_registration *cmd_reg = cmd->cmd_reg;
+	const char *tag = sieve_ast_argument_tag(arg);
+	unsigned int i;
+			
+	if ( id_code != NULL )
+		*id_code = 0;
+	
+	/* First check normal tags */
+	if ( array_is_created(&cmd_reg->normal_tags) ) {
+		for ( i = 0; i < array_count(&cmd_reg->normal_tags); i++ ) {
+			struct sieve_tag_registration * const *reg =
+				array_idx(&cmd_reg->normal_tags, i);
+
+			if ( (*reg)->tag != NULL && strcasecmp((*reg)->identifier,tag) == 0) {
+				if ( id_code != NULL )				
+					*id_code = (*reg)->id_code;
+
+				return (*reg)->tag;
+			}
+		}
+	}	
+  
+	/* Not found so far, try the instanced tags */
+	if ( array_is_created(&cmd_reg->instanced_tags) ) {
+		for ( i = 0; i < array_count(&cmd_reg->instanced_tags); i++ ) {
+			struct sieve_tag_registration * const *reg = 
+				array_idx(&cmd_reg->instanced_tags, i);
+  	
+			if ( (*reg)->tag != NULL && 
+				(*reg)->tag->is_instance_of(valdtr, cmd, arg) ) {
+				if ( id_code != NULL )
+					*id_code = (*reg)->id_code;
+				
+				return (*reg)->tag;
+			}
+		}
+	}
+	
+	return NULL;
+}
+
+static const struct sieve_argument *sieve_validator_find_tag_by_identifier
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	const char *tag) 
+{
+	struct sieve_ast_argument *arg;
+
+	/* Construct dummy argument */
+	arg = t_new(struct sieve_ast_argument, 1);
+	arg->type = SAAT_TAG;
+	arg->_value.tag = tag; 
+
+	return sieve_validator_find_tag(valdtr, cmd, arg, NULL);  
+}
+
+/* 
+ * Extension support 
+ */
+
+const struct sieve_extension *sieve_validator_extension_load
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *ext_arg, string_t *ext_name) 
+{
+	int ext_id;
+	struct sieve_validator_extension_reg *reg;
+	const struct sieve_extension *ext;
+	const char *name = str_c(ext_name);
+
+	if ( str_len(ext_name) > 128 ) {
+		sieve_argument_validate_error(valdtr, ext_arg, 
+			"%s %s: unknown Sieve capability '%s' (name is impossibly long)",
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			str_sanitize(name, 128));
+		return NULL;
+	}
+
+	ext = sieve_extension_get_by_name(name); 
+	
+	if ( ext == NULL ) {
+		unsigned int i;
+		bool core_test = FALSE;
+		bool core_command = FALSE;
+
+		for ( i = 0; !core_command && i < sieve_core_commands_count; i++ ) {
+			if ( strcasecmp(sieve_core_commands[i]->identifier, name) == 0 )
+				core_command = TRUE;
+		}
+
+		for ( i = 0; !core_test && i < sieve_core_tests_count; i++ ) {
+			if ( strcasecmp(sieve_core_tests[i]->identifier, name) == 0 )
+				core_test = TRUE;
+		}
+
+		if ( core_test || core_command ) {
+			sieve_argument_validate_error(valdtr, ext_arg,
+                "%s %s: '%s' is not known as a Sieve capability, "
+				"but it is known as a Sieve %s that is always available",
+                cmd->command->identifier, sieve_command_type_name(cmd->command),
+                name, ( core_test ? "test" : "command" ));
+		} else {
+			sieve_argument_validate_error(valdtr, ext_arg,
+				"%s %s: unknown Sieve capability '%s'", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command),
+				name);
+		}
+		return NULL;
+	}
+	
+	sieve_ast_extension_link(valdtr->ast, ext);
+
+	if ( ext->validator_load != NULL && !ext->validator_load(valdtr) ) {
+		sieve_argument_validate_error(valdtr, ext_arg, 
+			"%s %s: failed to load Sieve capability '%s'",
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			ext->name);
+		return NULL;
+	}
+
+	/* Register extension no matter what and store the AST argument registering it */
+	ext_id = SIEVE_EXT_ID(ext);
+	if ( ext_id >= 0 ) {
+		reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext_id);
+		reg->arg = ext_arg;
+		reg->loaded = TRUE;
+	}
+
+	return ext;
+}
+
+void sieve_validator_extension_register
+(struct sieve_validator *valdtr, 
+	const struct sieve_validator_extension *val_ext, void *context)
+{
+	struct sieve_validator_extension_reg *reg;
+	int ext_id = SIEVE_EXT_ID(val_ext->ext);
+
+	if ( ext_id < 0 ) return;
+	
+	reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext_id);
+	reg->val_ext = val_ext;
+	reg->context = context;
+}
+
+bool sieve_validator_extension_loaded
+	(struct sieve_validator *valdtr, const struct sieve_extension *ext)
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_validator_extension_reg *reg;
+
+	if ( ext_id < 0 || ext_id >= (int) array_count(&valdtr->extensions))
+		return FALSE;
+
+	reg = array_idx(&valdtr->extensions, (unsigned int) ext_id);
+
+	return ( reg->loaded );
+}
+
+void sieve_validator_extension_set_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext, 
+	void *context)
+{
+	struct sieve_validator_extension_reg *reg;
+	int ext_id = SIEVE_EXT_ID(ext);
+
+	if ( ext_id < 0 ) return;
+	
+	reg = array_idx_modifiable(&valdtr->extensions, (unsigned int) ext_id);
+	reg->context = context;
+}
+
+void *sieve_validator_extension_get_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext) 
+{
+	int ext_id = SIEVE_EXT_ID(ext);
+	const struct sieve_validator_extension_reg *reg;
+
+	if  ( ext_id < 0 || ext_id >= (int) array_count(&valdtr->extensions) )
+		return NULL;
+	
+	reg = array_idx(&valdtr->extensions, (unsigned int) ext_id);		
+
+	return reg->context;
+}
+
+/* 
+ * Overriding the default literal arguments
+ */
+
+void sieve_validator_argument_override
+(struct sieve_validator *validator, enum sieve_argument_type type, 
+	const struct sieve_argument *argument)
+{
+	struct sieve_default_argument *arg;
+	
+	if ( validator->default_arguments[type].argument != NULL ) {
+		arg = p_new(validator->pool, struct sieve_default_argument, 1);
+		*arg = validator->default_arguments[type];	
+		
+		validator->default_arguments[type].overrides = arg;
+	}
+	
+	validator->default_arguments[type].argument = argument;
+}
+
+static bool sieve_validator_argument_default_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_default_argument *defarg, struct sieve_ast_argument *arg)
+{
+	bool result = TRUE;
+	struct sieve_default_argument *prev_defarg;
+	
+	prev_defarg = validator->current_defarg;
+	validator->current_defarg = defarg;
+	
+	arg->argument = defarg->argument;
+	if (defarg->argument != NULL && defarg->argument->validate != NULL )
+		result = defarg->argument->validate(validator, &arg, cmd); 
+		
+	validator->current_defarg = prev_defarg;	
+		
+	return result;
+}
+
+bool sieve_validator_argument_activate_super
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool constant ATTR_UNUSED)
+{
+	struct sieve_default_argument *defarg;
+
+	if ( validator->current_defarg == NULL ||	
+		validator->current_defarg->overrides == NULL )
+		return FALSE;
+	
+	if ( validator->current_defarg->overrides->argument == &string_argument ) {
+		switch ( validator->current_defarg_type) {
+		case SAT_CONST_STRING:
+			if ( !validator->current_defarg_constant ) {
+				validator->current_defarg_type = SAT_VAR_STRING;
+				defarg = &validator->default_arguments[SAT_VAR_STRING];
+			} else
+				defarg = validator->current_defarg->overrides;
+			break;
+		case SAT_VAR_STRING:
+			defarg = validator->current_defarg->overrides;
+			break;
+		default:
+			return FALSE;
+		}
+	} else
+		defarg = validator->current_defarg->overrides;
+	
+	return sieve_validator_argument_default_activate
+		(validator, cmd, defarg, arg);
+}
+
+/* 
+ * Argument Validation API 
+ */
+
+bool sieve_validator_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool constant)
+{
+	struct sieve_default_argument *defarg;
+	
+	switch ( sieve_ast_argument_type(arg) ) {
+	case SAAT_NUMBER:	
+		validator->current_defarg_type = SAT_NUMBER;
+		break;
+	case SAAT_STRING:
+		validator->current_defarg_type = SAT_CONST_STRING;
+		break;
+	case SAAT_STRING_LIST:
+		validator->current_defarg_type = SAT_STRING_LIST;
+		break;
+	default:
+		return FALSE;
+	}
+
+	validator->current_defarg_constant = constant;
+	defarg = &validator->default_arguments[validator->current_defarg_type];
+
+	if ( !constant && defarg->argument == &string_argument ) {
+		validator->current_defarg_type = SAT_VAR_STRING;
+		defarg = &validator->default_arguments[SAT_VAR_STRING];
+	}
+	
+	return sieve_validator_argument_default_activate(validator, cmd, defarg, arg);
+}
+
+bool sieve_validate_positional_argument
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg, const char *arg_name, unsigned int arg_pos,
+	enum sieve_ast_argument_type req_type)
+{
+	if ( sieve_ast_argument_type(arg) != req_type && 
+		(sieve_ast_argument_type(arg) != SAAT_STRING || 
+			req_type != SAAT_STRING_LIST) ) 
+	{
+		sieve_argument_validate_error(validator, arg, 
+			"the %s %s expects %s as argument %d (%s), but %s was found", 
+			cmd->command->identifier, sieve_command_type_name(cmd->command), 
+			sieve_ast_argument_type_name(req_type),
+			arg_pos, arg_name, sieve_ast_argument_name(arg));
+		return FALSE; 
+	}
+	
+	return TRUE;
+}
+
+bool sieve_validate_tag_parameter
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *tag, struct sieve_ast_argument *param,
+	enum sieve_ast_argument_type req_type)
+{
+	if ( sieve_ast_argument_type(param) != req_type && 
+		(sieve_ast_argument_type(param) != SAAT_STRING || 
+			req_type != SAAT_STRING_LIST) ) 
+	{
+		sieve_argument_validate_error(validator, param, 
+			"the :%s tag for the %s %s requires %s as parameter, "
+			"but %s was found", sieve_ast_argument_tag(tag), 
+			cmd->command->identifier, sieve_command_type_name(cmd->command),
+			sieve_ast_argument_type_name(req_type),	sieve_ast_argument_name(param));
+		return FALSE;
+	}
+
+	param->arg_id_code = tag->arg_id_code;
+
+	return sieve_validator_argument_activate(validator, cmd, param, FALSE);
+}
+
+/* 
+ * Command argument validation 
+ */
+
+static bool sieve_validate_command_arguments
+(struct sieve_validator *validator, struct sieve_command_context *cmd) 
+{
+	int arg_count = cmd->command->positional_arguments;
+	int real_count = 0;
+	struct sieve_ast_argument *arg;
+	struct sieve_command_registration *cmd_reg = cmd->cmd_reg;
+
+	/* Validate any tags that might be present */
+	arg = sieve_ast_argument_first(cmd->ast_node);
+		
+	/* Visit tagged and optional arguments */
+	while ( sieve_ast_argument_type(arg) == SAAT_TAG ) {
+		int id_code;
+		struct sieve_ast_argument *parg; 
+		const struct sieve_argument *tag = 
+			sieve_validator_find_tag(validator, cmd, arg, &id_code);
+		
+		if ( tag == NULL ) {
+			sieve_argument_validate_error(validator, arg, 
+				"unknown tagged argument ':%s' for the %s %s "
+				"(reported only once at first occurence)",
+				sieve_ast_argument_tag(arg), cmd->command->identifier, 
+				sieve_command_type_name(cmd->command));
+			sieve_validator_register_unknown_tag
+				(validator, cmd_reg, sieve_ast_argument_tag(arg));
+			return FALSE;					
+		}
+		
+		/* Check whether previously tagged as unknown */
+		if ( tag->identifier != NULL && *(tag->identifier) == '\0' ) 
+			return FALSE;
+		
+		/* Assign the tagged argument type to the ast for later reference 
+		 * (in generator) 
+		 */
+		arg->argument = tag;
+		arg->arg_id_code = id_code;  
+			
+		/* Scan backwards for any duplicates */
+		parg = sieve_ast_argument_prev(arg);
+		while ( parg != NULL ) {
+			if ( (sieve_ast_argument_type(parg) == SAAT_TAG && parg->argument == tag) 
+				|| (id_code > 0 && parg->arg_id_code == id_code) ) 
+			{
+				const char *tag_id = sieve_ast_argument_tag(arg);
+				const char *tag_desc =
+					strcmp(tag->identifier, tag_id) != 0 ?
+					t_strdup_printf("%s argument (:%s)", tag->identifier, tag_id) : 
+					t_strdup_printf(":%s argument", tag->identifier); 	 
+				
+				sieve_argument_validate_error(validator, arg, 
+					"encountered duplicate %s for the %s %s",
+					tag_desc, cmd->command->identifier, 
+					sieve_command_type_name(cmd->command));
+					
+				return FALSE;	
+			}
+			
+			parg = sieve_ast_argument_prev(parg);
+		}
+		
+		/* Call the validation function for the tag (if present)
+		 *   Fail if the validation fails:
+		 *     Let's not whine multiple	times about a single command having multiple 
+		 *     bad arguments...
+		 */ 
+		if ( tag->validate != NULL ) { 
+			if ( !tag->validate(validator, &arg, cmd) ) 
+				return FALSE;
+		} else
+			arg = sieve_ast_argument_next(arg);
+	} 
+	
+	/* Remaining arguments should be positional (tags are not allowed here) */
+	cmd->first_positional = arg;
+	
+	while ( arg != NULL ) {
+		if ( sieve_ast_argument_type(arg) == SAAT_TAG ) {
+			sieve_argument_validate_error(validator, arg, 
+				"encountered an unexpected tagged argument ':%s' "
+				"while validating positional arguments for the %s %s",
+				sieve_ast_argument_tag(arg), cmd->command->identifier, 
+				sieve_command_type_name(cmd->command));
+			return FALSE;
+		}
+		
+		real_count++;
+	 
+		arg = sieve_ast_argument_next(arg);
+	}
+	
+	/* Check the required count versus the real number of arguments */
+	if ( arg_count >= 0 && real_count != arg_count ) {
+		sieve_command_validate_error(validator, cmd, 
+			"the %s %s requires %d positional argument(s), but %d is/are specified",
+			cmd->command->identifier, sieve_command_type_name(cmd->command), 
+			arg_count, real_count);
+		return FALSE;
+	}
+	
+	/* Call initial validation for persistent arguments */
+	if ( array_is_created(&cmd_reg->persistent_tags) ) {
+  		unsigned int i;
+  	
+		for ( i = 0; i < array_count(&cmd_reg->persistent_tags); i++ ) {
+			struct sieve_tag_registration * const *reg = 
+	  			array_idx(&cmd_reg->persistent_tags, i);
+			const struct sieve_argument *tag = (*reg)->tag;
+  
+			if ( tag != NULL && tag->validate_persistent != NULL ) { /* To be sure */
+				if ( !tag->validate_persistent(validator, cmd) )
+	  				return FALSE;
+			}
+		}
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_arguments_context
+(struct sieve_validator *validator, struct sieve_command_context *cmd)
+{ 
+	struct sieve_ast_argument *arg = 
+		sieve_command_first_argument(cmd);
+	
+	while ( arg != NULL ) {
+		const struct sieve_argument *argument = arg->argument;
+		
+		if ( argument != NULL && argument->validate_context != NULL ) { 
+			if ( !argument->validate_context(validator, arg, cmd) ) 
+				return FALSE;
+		}
+		
+		arg = sieve_ast_argument_next(arg);
+	}
+
+	return TRUE;
+}
+ 
+/* 
+ * Command Validation API 
+ */ 
+                 
+static bool sieve_validate_command_subtests
+(struct sieve_validator *valdtr, struct sieve_command_context *cmd, 
+	const unsigned int count) 
+{
+	switch ( count ) {
+	
+	case 0:
+	 	if ( sieve_ast_test_count(cmd->ast_node) > 0 ) {
+			/* Unexpected command specified */
+			enum sieve_command_type ctype = SCT_NONE;
+			struct sieve_command_registration *cmd_reg;
+			struct sieve_ast_node *test = sieve_ast_test_first(cmd->ast_node);
+
+			cmd_reg = sieve_validator_find_command_registration
+				(valdtr, test->identifier);
+	
+			/* First check what we are dealing with */
+			if ( cmd_reg != NULL && cmd_reg->command != NULL )
+				ctype = cmd_reg->command->type;
+
+			switch ( ctype ) {
+			case SCT_TEST: /* Spurious test */
+			case SCT_HYBRID:
+				sieve_command_validate_error(valdtr, cmd, 
+					"the %s %s accepts no sub-tests, but tests are specified", 
+					cmd->command->identifier, sieve_command_type_name(cmd->command));
+				break;
+
+			case SCT_NONE: /* Unknown command */
+
+				/* Is it perhaps a tag for which the ':' was omitted ? */
+				if ( 	sieve_validator_find_tag_by_identifier
+					(valdtr, cmd, test->identifier) != NULL ) {
+					sieve_command_validate_error(valdtr, cmd, 
+						"missing colon ':' before ':%s' tag in %s %s", test->identifier, 
+						cmd->command->identifier, sieve_command_type_name(cmd->command));
+					break;
+				} 
+				/* Fall through */
+			
+			case SCT_COMMAND:
+				sieve_command_validate_error(valdtr, cmd, 
+					"missing semicolon ';' after %s %s", 
+					cmd->command->identifier, sieve_command_type_name(cmd->command));
+				break;
+			}
+			return FALSE;
+		}
+		break;
+	case 1:
+		if ( sieve_ast_test_count(cmd->ast_node) == 0 ) {
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires one sub-test, but none is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+				
+			return FALSE;
+			
+		} else if ( sieve_ast_test_count(cmd->ast_node) > 1 || 
+			cmd->ast_node->test_list ) {
+			
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires one sub-test, but a list of tests is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+				
+			return FALSE;
+		}
+		break;
+		
+	default:
+		if ( sieve_ast_test_count(cmd->ast_node) == 0 ) {
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires a list of sub-tests, but none is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command));
+			
+			return FALSE;
+			
+		} else if ( sieve_ast_test_count(cmd->ast_node) == 1 && 
+			!cmd->ast_node->test_list ) {
+			
+			sieve_command_validate_error(valdtr, cmd, 
+				"the %s %s requires a list of sub-tests, "
+				"but a single test is specified", 
+				cmd->command->identifier, sieve_command_type_name(cmd->command) );
+			
+			return FALSE;
+		}
+		break;		
+	}
+
+	return TRUE;
+}
+
+static bool sieve_validate_command_block
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	bool block_allowed, bool block_required) 
+{
+	i_assert( cmd->ast_node->type == SAT_COMMAND );
+	
+	if ( block_required ) {
+		if ( !cmd->ast_node->block ) {
+			sieve_command_validate_error(validator, cmd, 
+				"the %s command requires a command block, but it is missing", 
+				cmd->command->identifier);
+			
+			return FALSE;
+		}
+	} else if ( !block_allowed && cmd->ast_node->block ) {
+		sieve_command_validate_error(validator, cmd, 
+			"the %s command does not accept a command block, "
+			"but one is specified anyway", 
+			cmd->command->identifier );
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+} 
+
+/* 
+ * AST Validation 
+ */
+
+static bool sieve_validate_test_list
+	(struct sieve_validator *validator, struct sieve_ast_node *test_list); 
+static bool sieve_validate_block
+	(struct sieve_validator *validator, struct sieve_ast_node *block);
+static bool sieve_validate_command
+	(struct sieve_validator *validator, struct sieve_ast_node *cmd_node);
+	
+static bool sieve_validate_command
+(struct sieve_validator *valdtr, struct sieve_ast_node *cmd_node) 
+{
+	enum sieve_ast_type ast_type = sieve_ast_node_type(cmd_node);
+	bool result = TRUE;
+	struct sieve_command_registration *cmd_reg;
+	const struct sieve_command *command = NULL;
+	
+	i_assert( ast_type == SAT_TEST || ast_type == SAT_COMMAND );
+	
+	/* Verify the command specified by this node */
+	
+	cmd_reg = sieve_validator_find_command_registration
+		(valdtr, cmd_node->identifier);
+	
+	if ( cmd_reg != NULL && cmd_reg->command != NULL ) {
+		command = cmd_reg->command;
+
+		/* Identifier = "" when the command was previously marked as unknown */
+		if ( *(command->identifier) != '\0' ) {
+			if ( (command->type == SCT_COMMAND && ast_type == SAT_TEST) || 
+				(command->type == SCT_TEST && ast_type == SAT_COMMAND) ) 
+			{
+				sieve_validator_error(
+					valdtr, cmd_node->source_line, "attempted to use %s '%s' as %s", 
+					sieve_command_type_name(command), cmd_node->identifier,
+					sieve_ast_type_name(ast_type));
+			
+			 	return FALSE;
+			} 
+			 
+			struct sieve_command_context *ctx = 
+				sieve_command_context_create(cmd_node, command, cmd_reg); 
+			cmd_node->context = ctx;
+		
+			/* If pre-validation fails, don't bother to validate further 
+			 * as context might be missing and doing so is not very useful for 
+			 * further error reporting anyway
+			 */
+			if ( command->pre_validate == NULL || 
+				command->pre_validate(valdtr, ctx) ) {
+		
+				/* Check syntax */
+				if ( !sieve_validate_command_arguments(valdtr, ctx) ) {
+					result = FALSE;
+
+					/* A missing ':' causes a tag to become a test. This can be the cause
+					 * of the arguments validation failing. Therefore we must produce an
+					 * error for the sub-tests as well if appropriate.
+					 */
+					(void)sieve_validate_command_subtests(valdtr, ctx, command->subtests);
+				} else if (
+					!sieve_validate_command_subtests
+ 						(valdtr, ctx, command->subtests) || 
+ 					(ast_type == SAT_COMMAND && !sieve_validate_command_block
+ 						(valdtr, ctx, command->block_allowed, 
+ 							command->block_required)) ) {
+ 					result = FALSE;
+ 				} else {
+					/* Call command validation function if specified */
+					if ( command->validate != NULL )
+						result = command->validate(valdtr, ctx) && result;
+				}
+			} else
+				result = FALSE;
+				
+			result = result && sieve_validate_arguments_context(valdtr, ctx);
+				
+		} else 
+			result = FALSE;
+				
+	} else {
+		sieve_validator_error(
+			valdtr, cmd_node->source_line, 
+			"unknown %s '%s' (only reported once at first occurence)", 
+			sieve_ast_type_name(ast_type), cmd_node->identifier);
+			
+		sieve_validator_register_unknown_command(valdtr, cmd_node->identifier);
+		
+		result = FALSE;
+	}
+
+	/*  
+	 * Descend further into the AST 
+	 */
+	
+	if ( command != NULL ) {
+		/* Tests */
+		if ( command->subtests > 0 && 
+			(result || sieve_errors_more_allowed(valdtr->ehandler)) )
+			result = sieve_validate_test_list(valdtr, cmd_node) && result;
+
+		/* Command block */
+		if ( command->block_allowed && ast_type == SAT_COMMAND && 
+			(result || sieve_errors_more_allowed(valdtr->ehandler)) )
+			result = sieve_validate_block(valdtr, cmd_node) && result;
+	}
+	
+	return result;
+}
+
+static bool sieve_validate_test_list
+(struct sieve_validator *valdtr, struct sieve_ast_node *test_list) 
+{
+	bool result = TRUE;
+	struct sieve_ast_node *test;
+
+	test = sieve_ast_test_first(test_list);
+	while ( test != NULL && (result || 
+		sieve_errors_more_allowed(valdtr->ehandler))) {	
+		result = sieve_validate_command(valdtr, test) && result;	
+		test = sieve_ast_test_next(test);
+	}		
+	
+	return result;
+}
+
+static bool sieve_validate_block
+(struct sieve_validator *valdtr, struct sieve_ast_node *block) 
+{
+	bool result = TRUE;
+	struct sieve_ast_node *command, *next;
+
+	T_BEGIN {	
+		command = sieve_ast_command_first(block);
+		while ( command != NULL && (result || 
+			sieve_errors_more_allowed(valdtr->ehandler)) ) {	
+
+			next = sieve_ast_command_next(command);
+			result = sieve_validate_command(valdtr, command) && result;	
+
+			/* Check if this is the first non-require command */
+	
+			if ( result && !valdtr->finished_require && command->context != NULL &&
+				command->context->command != &cmd_require ) {
+				const struct sieve_validator_extension_reg *extrs;
+			    unsigned int ext_count, i;
+	
+				valdtr->finished_require = TRUE;
+	
+			    /* Validate all 'require'd extensions */
+
+			    extrs = array_get(&valdtr->extensions, &ext_count);
+			    for ( i = 0; i < ext_count; i++ ) {
+					if ( extrs[i].val_ext != NULL && extrs[i].val_ext->validate != NULL ) {
+						if ( !extrs[i].val_ext->validate
+							(valdtr, extrs[i].context, extrs[i].arg) )
+						result = FALSE;
+						break;
+					} 
+				}
+			}
+
+			command = next;
+		}		
+	} T_END;
+	
+	return result;
+}
+
+bool sieve_validator_run(struct sieve_validator *validator) 
+{	
+	return sieve_validate_block(validator, sieve_ast_root(validator->ast));
+}
+
+/*
+ * Validator object registry
+ */
+
+struct sieve_validator_object_registry {
+	struct sieve_validator *validator;
+	ARRAY_DEFINE(registrations, const struct sieve_object *);
+};
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_get
+(struct sieve_validator *validator, const struct sieve_extension *ext)
+{
+	return (struct sieve_validator_object_registry *) 
+		sieve_validator_extension_get_context(validator, ext);
+}
+
+void sieve_validator_object_registry_add
+(struct sieve_validator_object_registry *regs, 
+	const struct sieve_object *object) 
+{
+    array_append(&regs->registrations, &object, 1);
+}
+
+const struct sieve_object *sieve_validator_object_registry_find
+(struct sieve_validator_object_registry *regs, const char *identifier) 
+{
+	unsigned int i;
+
+	for ( i = 0; i < array_count(&regs->registrations); i++ ) {
+		const struct sieve_object * const *obj = array_idx(&regs->registrations, i);
+
+		if ( strcasecmp((*obj)->identifier, identifier) == 0)
+			return *obj;
+	}
+
+	return NULL;
+}
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_create
+(struct sieve_validator *validator)
+{
+	pool_t pool = validator->pool;
+	struct sieve_validator_object_registry *regs = 
+		p_new(pool, struct sieve_validator_object_registry, 1);
+	
+	/* Setup registry */        
+	p_array_init(&regs->registrations, validator->pool, 4);
+
+	regs->validator = validator;
+
+	return regs;
+}
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_init
+(struct sieve_validator *validator, const struct sieve_extension *ext)
+{
+	struct sieve_validator_object_registry *regs = 
+		sieve_validator_object_registry_create(validator);
+	
+	sieve_validator_extension_set_context(validator, ext, regs);
+	return regs;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-validator.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-validator.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/sieve-validator.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/sieve-validator.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,164 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+ 
+#ifndef __SIEVE_VALIDATOR_H
+#define __SIEVE_VALIDATOR_H
+
+#include "lib.h"
+
+#include "sieve-common.h"
+
+/*
+ * Types
+ */
+
+enum sieve_argument_type {
+	SAT_NUMBER,
+	SAT_CONST_STRING,
+	SAT_VAR_STRING,
+	SAT_STRING_LIST,
+	
+	SAT_COUNT
+};
+
+struct sieve_command_registration;
+
+/*
+ * Validator
+ */
+ 
+struct sieve_validator;
+
+struct sieve_validator *sieve_validator_create
+	(struct sieve_ast *ast, struct sieve_error_handler *ehandler);
+void sieve_validator_free(struct sieve_validator **validator);
+pool_t sieve_validator_pool(struct sieve_validator *validator);
+
+bool sieve_validator_run(struct sieve_validator *validator);
+
+/*
+ * Accessors
+ */
+ 
+struct sieve_error_handler *sieve_validator_error_handler
+	(struct sieve_validator *validator);
+struct sieve_ast *sieve_validator_ast
+	(struct sieve_validator *validator);
+struct sieve_script *sieve_validator_script
+	(struct sieve_validator *validator);
+
+/*
+ * Error handling
+ */
+
+void sieve_validator_warning
+	(struct sieve_validator *validator, unsigned int source_line, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_validator_error
+	(struct sieve_validator *validator, unsigned int source_line, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+void sieve_validator_critical
+	(struct sieve_validator *validator, unsigned int source_line, 
+		const char *fmt, ...) ATTR_FORMAT(3, 4);
+		
+/* 
+ * Command/Test registry
+ */
+ 
+void sieve_validator_register_command
+	(struct sieve_validator *validator, const struct sieve_command *command);
+const struct sieve_command *sieve_validator_find_command
+	(struct sieve_validator *validator, const char *command);	
+	
+void sieve_validator_register_external_tag
+	(struct sieve_validator *validator, const struct sieve_argument *tag, 
+		const char *command, int id_code);
+
+/* 
+ * Per-command tagged argument registry
+ */
+
+void sieve_validator_register_tag
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg, 
+		const struct sieve_argument *argument, int id_code);
+void sieve_validator_register_persistent_tag
+	(struct sieve_validator *validator, const struct sieve_argument *tag, 
+		const char *command);
+	
+/*
+ * Overriding the default literal arguments
+ */	
+ 
+void sieve_validator_argument_override
+(struct sieve_validator *validator, enum sieve_argument_type type, 
+	const struct sieve_argument *argument);
+bool sieve_validator_argument_activate_super
+(struct sieve_validator *validator, struct sieve_command_context *cmd, 
+	struct sieve_ast_argument *arg, bool constant);
+		
+/* 
+ * Argument validation API
+ */
+
+bool sieve_validate_positional_argument
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg, const char *arg_name, unsigned int arg_pos,
+	enum sieve_ast_argument_type req_type);
+bool sieve_validator_argument_activate
+(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *arg, bool constant);
+		
+bool sieve_validate_tag_parameter
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+	struct sieve_ast_argument *tag, struct sieve_ast_argument *param,
+	enum sieve_ast_argument_type req_type);
+	
+/* 
+ * Extension support
+ */
+
+struct sieve_validator_extension {
+	const struct sieve_extension *ext;	
+
+	bool (*validate)(struct sieve_validator *valdtr, void *context,
+		struct sieve_ast_argument *require_arg);
+
+	void (*free)(struct sieve_validator *valdtr, void *context);
+};
+
+const struct sieve_extension *sieve_validator_extension_load
+	(struct sieve_validator *validator, struct sieve_command_context *cmd,
+		struct sieve_ast_argument *ext_arg, string_t *ext_name); 
+
+void sieve_validator_extension_register
+	(struct sieve_validator *valdtr, 
+		const struct sieve_validator_extension *val_ext, void *context);
+bool sieve_validator_extension_loaded
+    (struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+void sieve_validator_extension_set_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext, 
+	void *context);
+void *sieve_validator_extension_get_context
+(struct sieve_validator *valdtr, const struct sieve_extension *ext);
+
+/*
+ * Validator object registry
+ */
+
+struct sieve_validator_object_registry;
+
+struct sieve_validator_object_registry *sieve_validator_object_registry_get
+	(struct sieve_validator *validator, const struct sieve_extension *ext);
+void sieve_validator_object_registry_add
+	(struct sieve_validator_object_registry *regs,
+		const struct sieve_object *object);
+const struct sieve_object *sieve_validator_object_registry_find
+	(struct sieve_validator_object_registry *regs, const char *identifier);
+struct sieve_validator_object_registry *sieve_validator_object_registry_create
+	(struct sieve_validator *validator);
+struct sieve_validator_object_registry *sieve_validator_object_registry_init
+	(struct sieve_validator *validator, const struct sieve_extension *ext);
+
+#endif /* __SIEVE_VALIDATOR_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-address.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-address.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-address.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-address.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,287 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str-sanitize.h"
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+#include <stdio.h>
+
+/* 
+ * Address test
+ *
+ * Syntax:
+ *    address [ADDRESS-PART] [COMPARATOR] [MATCH-TYPE]
+ *       <header-list: string-list> <key-list: string-list>
+ */
+
+static bool tst_address_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+static bool tst_address_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_address_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_address = { 
+	"address", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_address_registered,
+	NULL, 
+	tst_address_validate, 
+	tst_address_generate, 
+	NULL 
+};
+
+/* 
+ * Address operation 
+ */
+
+static bool tst_address_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_address_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_address_operation = { 
+	"ADDRESS",
+	NULL,
+	SIEVE_OPERATION_ADDRESS,
+	tst_address_operation_dump, 
+	tst_address_operation_execute 
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_address_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_AM_OPT_COMPARATOR );
+	sieve_address_parts_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_ADDRESS_PART);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_AM_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+/* List of valid headers:
+ *   Implementations MUST restrict the address test to headers that
+ *   contain addresses, but MUST include at least From, To, Cc, Bcc,
+ *   Sender, Resent-From, and Resent-To, and it SHOULD include any other
+ *   header that utilizes an "address-list" structured header body.
+ *
+ * This list explicitly does not contain the envelope-to and return-path 
+ * headers. The envelope test must be used to test against these addresses.
+ */
+static const char * const _allowed_headers[] = {
+	/* Required */
+	"from", "to", "cc", "bcc", "sender", "resent-from", "resent-to",
+
+	/* Additional (RFC 2822) */
+	"reply-to", "resent-reply-to", 
+	
+	/* Non-standard (draft-palme-mailext-headers-08.txt) */
+	"for-approval", "for-handling", "for-comment", "apparently-to", "errors-to", 
+	"delivered-to", "return-receipt-to", "x-admin", "read-receipt-to", 
+	"x-confirm-reading-to", "return-receipt-requested", 
+	"registered-mail-reply-requested-by", "mail-followup-to", "mail-reply-to",
+	"abuse-reports-to", "x-complaints-to", "x-report-abuse-to",
+	
+	NULL  
+};
+
+static int _header_is_allowed
+(void *context ATTR_UNUSED, struct sieve_ast_argument *arg)
+{
+	if ( sieve_argument_is_string_literal(arg) ) {
+		const char *header = sieve_ast_strlist_strc(arg);
+
+		const char * const *hdsp = _allowed_headers;
+		while ( *hdsp != NULL ) {
+			if ( strcasecmp( *hdsp, header ) == 0 ) 
+				return TRUE;
+
+			hdsp++;
+		}
+		
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+static bool tst_address_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+	struct sieve_ast_argument *header;
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header list", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+        return FALSE;
+
+	/* Check if supplied header names are allowed
+	 *   FIXME: verify dynamic header names at runtime 
+	 */
+	header = arg;
+	if ( !sieve_ast_stringlist_map(&header, NULL, _header_is_allowed) ) {		
+		sieve_argument_validate_error(valdtr, header, 
+			"specified header '%s' is not allowed for the address test", 
+			str_sanitize(sieve_ast_strlist_strc(header), 64));
+		return FALSE;
+	}
+
+	/* Check key list */
+	
+	arg = sieve_ast_argument_next(arg);
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+	
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_ascii_casemap_comparator); 
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_address_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_address_operation);
+	
+	/* Generate arguments */  	
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_address_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,	
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "ADDRESS");
+	sieve_code_descend(denv);
+	
+	/* Handle any optional arguments */
+	if ( !sieve_addrmatch_default_dump_optionals(denv, address) )
+		return FALSE;
+
+	return
+		sieve_opr_stringlist_dump(denv, address, "header list") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_address_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{	
+	bool result = TRUE;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	const struct sieve_address_part *addrp = &all_address_part;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *hdr_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *hdr_item;
+	bool matched;
+	int ret;
+	
+	/* Read optional operands */
+	if ( (ret=sieve_addrmatch_default_get_optionals
+		(renv, address, &addrp, &mtch, &cmp)) <= 0 ) 
+		return ret;
+		
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "ADDRESS test");
+
+	/* Initialize match context */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list);
+	
+	/* Iterate through all requested headers to match */
+	hdr_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item)) 
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+			
+		if ( mail_get_headers_utf8(renv->msgdata->mail, str_c(hdr_item), &headers) >= 0 ) {	
+			int i;
+
+			for ( i = 0; !matched && headers[i] != NULL; i++ ) {
+				if ( (ret=sieve_address_match(addrp, mctx, headers[i])) < 0 ) {
+					result = FALSE;
+					break;
+				}
+				
+				matched = ret > 0;				
+			} 
+		}
+	}
+	
+	/* Finish match */
+
+	if ( (ret=sieve_match_end(mctx)) < 0 )
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");	
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-allof.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-allof.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-allof.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-allof.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,86 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/* 
+ * Allof test 
+ * 
+ * Syntax 
+ *   allof <tests: test-list>   
+ */
+
+static bool tst_allof_generate
+	(const struct sieve_codegen_env *cgenv, 
+		struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_allof = { 
+	"allof", 
+	SCT_TEST, 
+	0, 2, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_allof_generate 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_allof_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *ctx,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist false_jumps;
+
+	if ( sieve_ast_test_count(ctx->ast_node) > 1 ) {	
+		if ( jump_true ) {
+			/* Prepare jumplist */
+			sieve_jumplist_init_temp(&false_jumps, sbin);
+		}
+	
+		test = sieve_ast_test_first(ctx->ast_node);
+		while ( test != NULL ) {	
+			bool result; 
+
+			/* If this test list must jump on false, all sub-tests can simply add their jumps
+			 * to the caller's jump list, otherwise this test redirects all false jumps to the 
+			 * end of the currently generated code. This is just after a final jump to the true
+			 * case 
+			 */
+			if ( jump_true ) 
+				result = sieve_generate_test(cgenv, test, &false_jumps, FALSE);
+			else
+				result = sieve_generate_test(cgenv, test, jumps, FALSE);
+		
+			if ( !result ) return FALSE;
+
+			test = sieve_ast_test_next(test);
+		}	
+	
+		if ( jump_true ) {
+			/* All tests succeeded, jump to case TRUE */
+			sieve_operation_emit_code(cgenv->sbin, &sieve_jmp_operation);
+			sieve_jumplist_add(jumps, sieve_binary_emit_offset(sbin, 0));
+			
+			/* All false exits jump here */
+			sieve_jumplist_resolve(&false_jumps);
+		}
+	} else {
+		/* Script author is being inefficient; we can optimize the allof test away */
+		test = sieve_ast_test_first(ctx->ast_node);
+		sieve_generate_test(cgenv, test, jumps, jump_true);
+	}
+		
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-anyof.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-anyof.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-anyof.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-anyof.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,83 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-generator.h"
+#include "sieve-validator.h"
+#include "sieve-binary.h"
+#include "sieve-code.h"
+#include "sieve-binary.h"
+
+/* 
+ * Anyof test 
+ *
+ * Syntax 
+ *   anyof <tests: test-list>   
+ */
+
+static bool tst_anyof_generate	
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_anyof = { 
+	"anyof", 
+	SCT_TEST, 
+	0, 2, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_anyof_generate 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_anyof_generate	
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_binary *sbin = cgenv->sbin;
+	struct sieve_ast_node *test;
+	struct sieve_jumplist true_jumps;
+
+	if ( sieve_ast_test_count(ctx->ast_node) > 1 ) {	
+		if ( !jump_true ) {
+			/* Prepare jumplist */
+			sieve_jumplist_init_temp(&true_jumps, sbin);
+		}
+	
+		test = sieve_ast_test_first(ctx->ast_node);
+		while ( test != NULL ) {	
+			bool result;
+
+			/* If this test list must jump on true, all sub-tests can simply add their jumps
+			 * to the caller's jump list, otherwise this test redirects all true jumps to the 
+			 * end of the currently generated code. This is just after a final jump to the false
+			 * case 
+			 */
+			if ( !jump_true ) 
+				result = sieve_generate_test(cgenv, test, &true_jumps, TRUE);
+			else
+				result = sieve_generate_test(cgenv, test, jumps, TRUE);
+
+			if ( !result ) return FALSE;
+		
+			test = sieve_ast_test_next(test);
+		}	
+	
+		if ( !jump_true ) {
+			/* All tests failed, jump to case FALSE */
+			sieve_operation_emit_code(sbin, &sieve_jmp_operation);
+			sieve_jumplist_add(jumps, sieve_binary_emit_offset(sbin, 0));
+			
+			/* All true exits jump here */
+			sieve_jumplist_resolve(&true_jumps);
+		}
+	} else {
+		/* Script author is being inefficient; we can optimize the allof test away */
+        test = sieve_ast_test_first(ctx->ast_node);
+        sieve_generate_test(cgenv, test, jumps, jump_true);
+    }		
+		
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-exists.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-exists.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-exists.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-exists.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,145 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+
+/* 
+ * Exists test
+ *  
+ * Syntax:
+ *    exists <header-names: string-list>
+ */
+
+static bool tst_exists_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_exists_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_exists = { 
+	"exists", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	NULL, 
+	NULL,
+	tst_exists_validate, 
+	tst_exists_generate, 
+	NULL 
+};
+
+/* 
+ * Exists operation 
+ */
+
+static bool tst_exists_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_exists_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_exists_operation = { 
+	"EXISTS",
+	NULL,
+	SIEVE_OPERATION_EXISTS,
+	tst_exists_operation_dump, 
+	tst_exists_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+
+static bool tst_exists_validate
+  (struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{
+	struct sieve_ast_argument *arg = tst->first_positional;
+		
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	return sieve_command_verify_headers_argument(valdtr, arg);
+}
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_exists_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_exists_operation);
+
+ 	/* Generate arguments */
+    return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_exists_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "EXISTS");
+	sieve_code_descend(denv);
+
+	return sieve_opr_stringlist_dump(denv, address, "header names");
+}
+
+/* 
+ * Code execution 
+ */
+
+static int tst_exists_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	struct sieve_coded_stringlist *hdr_list;
+	string_t *hdr_item;
+	bool matched;
+	
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "EXISTS test");
+		
+	/* Iterate through all requested headers to match (must find all specified) */
+	hdr_item = NULL;
+	matched = TRUE;
+	while ( matched &&
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item)) 
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+			
+		if ( mail_get_headers
+			(renv->msgdata->mail, str_c(hdr_item), &headers) < 0 ||
+			headers[0] == NULL ) {	
+			matched = FALSE;				 
+		}
+	}
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}
+	
+	sieve_runtime_trace_error(renv, "invalid header-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-header.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-header.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-header.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-header.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,249 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+#include "sieve-match.h"
+
+/* 
+ * Header test 
+ *
+ * Syntax:
+ *   header [COMPARATOR] [MATCH-TYPE]
+ *     <header-names: string-list> <key-list: string-list>
+ */
+
+static bool tst_header_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg);
+static bool tst_header_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst);
+static bool tst_header_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx);
+
+const struct sieve_command tst_header = { 
+	"header", 
+	SCT_TEST, 
+	2, 0, FALSE, FALSE,
+	tst_header_registered, 
+	NULL,
+	tst_header_validate, 
+	tst_header_generate, 
+	NULL 
+};
+
+/* 
+ * Header operation 
+ */
+
+static bool tst_header_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_header_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_header_operation = { 
+	"HEADER",
+	NULL,
+	SIEVE_OPERATION_HEADER,
+	tst_header_operation_dump, 
+	tst_header_operation_execute 
+};
+
+/* 
+ * Test registration 
+ */
+
+static bool tst_header_registered
+	(struct sieve_validator *valdtr, struct sieve_command_registration *cmd_reg) 
+{
+	/* The order of these is not significant */
+	sieve_comparators_link_tag(valdtr, cmd_reg, SIEVE_MATCH_OPT_COMPARATOR);
+	sieve_match_types_link_tags(valdtr, cmd_reg, SIEVE_MATCH_OPT_MATCH_TYPE);
+
+	return TRUE;
+}
+
+/* 
+ * Validation 
+ */
+ 
+static bool tst_header_validate
+	(struct sieve_validator *valdtr, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "header names", 1, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	if ( !sieve_command_verify_headers_argument(valdtr, arg) )
+		return FALSE;
+	
+	arg = sieve_ast_argument_next(arg);
+
+	if ( !sieve_validate_positional_argument
+		(valdtr, tst, arg, "key list", 2, SAAT_STRING_LIST) ) {
+		return FALSE;
+	}
+	
+	if ( !sieve_validator_argument_activate(valdtr, tst, arg, FALSE) )
+		return FALSE;
+
+	/* Validate the key argument to a specified match type */
+	return sieve_match_type_validate
+		(valdtr, tst, arg, &is_match_type, &i_ascii_casemap_comparator);
+}
+
+/*
+ * Code generation 
+ */
+
+static bool tst_header_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	sieve_operation_emit_code(cgenv->sbin, &tst_header_operation);
+
+ 	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_header_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	int opt_code = 0;
+
+	sieve_code_dumpf(denv, "HEADER");
+	sieve_code_descend(denv);
+
+	/* Handle any optional arguments */
+	if ( !sieve_match_dump_optional_operands(denv, address, &opt_code) )
+		return FALSE;
+
+	if ( opt_code != SIEVE_MATCH_OPT_END )
+		return FALSE;
+	
+	return
+		sieve_opr_stringlist_dump(denv, address, "header names") &&
+		sieve_opr_stringlist_dump(denv, address, "key list");
+}
+
+/* 
+ * Code execution 
+ */
+
+static inline string_t *_header_right_trim(const char *raw) 
+{
+	string_t *result;
+	int i;
+	
+	for ( i = strlen(raw)-1; i >= 0; i-- ) {
+		if ( raw[i] != ' ' && raw[i] != '\t' ) break;
+	}
+	
+	result = t_str_new(i+1);
+	str_append_n(result, raw, i + 1);
+	return result;
+}
+
+static int tst_header_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	bool result = TRUE;
+	int opt_code = 0;
+	const struct sieve_comparator *cmp = &i_ascii_casemap_comparator;
+	const struct sieve_match_type *mtch = &is_match_type;
+	struct sieve_match_context *mctx;
+	struct sieve_coded_stringlist *hdr_list;
+	struct sieve_coded_stringlist *key_list;
+	string_t *hdr_item;
+	bool matched;
+	int ret;
+	
+	/* Handle match-type and comparator operands */
+	if ( (ret=sieve_match_read_optional_operands
+		(renv, address, &opt_code, &cmp, &mtch)) <= 0 )
+		return ret;
+	
+	/* Check whether we neatly finished the list of optional operands*/
+	if ( opt_code != SIEVE_MATCH_OPT_END) {
+		sieve_runtime_trace_error(renv, "invalid optional operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+		
+	/* Read header-list */
+	if ( (hdr_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid header-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/* Read key-list */
+	if ( (key_list=sieve_opr_stringlist_read(renv, address)) == NULL ) {
+		sieve_runtime_trace_error(renv, "invalid key-list operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+
+	sieve_runtime_trace(renv, "HEADER test");
+
+	/* Initialize match */
+	mctx = sieve_match_begin(renv->interp, mtch, cmp, NULL, key_list); 	
+
+	/* Iterate through all requested headers to match */
+	hdr_item = NULL;
+	matched = FALSE;
+	while ( result && !matched && 
+		(result=sieve_coded_stringlist_next_item(hdr_list, &hdr_item)) 
+		&& hdr_item != NULL ) {
+		const char *const *headers;
+			
+		if ( mail_get_headers_utf8
+			(renv->msgdata->mail, str_c(hdr_item), &headers) >= 0 ) {	
+			int i;
+
+			for ( i = 0; !matched && headers[i] != NULL; i++ ) {
+				string_t *theader = _header_right_trim(headers[i]);
+			
+				if ( (ret=sieve_match_value(mctx, str_c(theader), str_len(theader))) 
+					< 0 ) 
+				{
+					result = FALSE;
+					break;
+				}
+
+				matched = ret > 0;				
+			} 
+		}
+	}
+
+	/* Finish match */
+	if ( (ret=sieve_match_end(mctx)) < 0 ) 
+		result = FALSE;
+	else
+		matched = ( ret > 0 || matched );
+	
+	/* Set test result for subsequent conditional jump */
+	if ( result ) {
+		sieve_interpreter_set_test_result(renv->interp, matched);
+		return SIEVE_EXEC_OK;
+	}	
+
+	sieve_runtime_trace_error(renv, "invalid string-list item");
+	return SIEVE_EXEC_BIN_CORRUPT;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-not.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-not.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-not.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-not.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,43 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-common.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+
+/* 
+ * Not test 
+ *
+ * Syntax:
+ *   not <tests: test-list>   
+ */
+
+static bool tst_not_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_not = { 
+	"not", 
+	SCT_TEST, 
+	0, 1, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_not_generate 
+};
+
+/* 
+ * Code generation 
+ */
+
+static bool tst_not_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	struct sieve_ast_node *test;
+	
+	/* Validator verified the existance of the single test already */
+	test = sieve_ast_test_first(ctx->ast_node); 
+	
+	return sieve_generate_test(cgenv, test, jumps, !jump_true);
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-size.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-size.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-size.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-size.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,276 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve-common.h"
+#include "sieve-code.h"
+#include "sieve-commands.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-interpreter.h"
+#include "sieve-code-dumper.h"
+
+/* 
+ * Size test 
+ *
+ * Syntax:
+ *    size <":over" / ":under"> <limit: number>
+ */
+
+static bool tst_size_registered
+	(struct sieve_validator *validator, 
+		struct sieve_command_registration *cmd_reg);
+static bool tst_size_pre_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_size_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool tst_size_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx); 
+
+const struct sieve_command tst_size = { 
+	"size", 
+	SCT_TEST, 
+	1, 0, FALSE, FALSE,
+	tst_size_registered, 
+	tst_size_pre_validate,
+	tst_size_validate, 
+	tst_size_generate, 
+	NULL 
+};
+
+/* 
+ * Size operations 
+ */
+
+static bool tst_size_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int tst_size_operation_execute
+	(const struct sieve_operation *op, 
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation tst_size_over_operation = { 
+	"SIZE-OVER",
+	NULL, 
+	SIEVE_OPERATION_SIZE_OVER,
+	tst_size_operation_dump, 
+	tst_size_operation_execute 
+};
+
+const struct sieve_operation tst_size_under_operation = {
+	"SIZE-UNDER",
+	NULL, 
+	SIEVE_OPERATION_SIZE_UNDER,
+	tst_size_operation_dump, 
+	tst_size_operation_execute 
+};
+
+/* 
+ * Context data
+ */
+
+struct tst_size_context_data {
+	enum { SIZE_UNASSIGNED, SIZE_UNDER, SIZE_OVER } type;
+};
+
+#define TST_SIZE_ERROR_DUP_TAG \
+	"exactly one of the ':under' or ':over' tags must be specified " \
+	"for the size test, but more were found"
+
+/* 
+ * Tag validation 
+ */
+
+static bool tst_size_validate_over_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg, 
+	struct sieve_command_context *tst)
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) tst->data;	
+	
+	if ( ctx_data->type != SIZE_UNASSIGNED ) {
+		sieve_argument_validate_error(validator, *arg, TST_SIZE_ERROR_DUP_TAG);
+		return FALSE;		
+	}
+	
+	ctx_data->type = SIZE_OVER;
+	
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+	
+	return TRUE;
+}
+
+static bool tst_size_validate_under_tag
+(struct sieve_validator *validator, struct sieve_ast_argument **arg ATTR_UNUSED, 
+	struct sieve_command_context *tst)
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) tst->data;	
+	
+	if ( ctx_data->type != SIZE_UNASSIGNED ) {
+		sieve_argument_validate_error(validator, *arg, TST_SIZE_ERROR_DUP_TAG);
+		return FALSE;		
+	}
+	
+	ctx_data->type = SIZE_UNDER;
+	
+	/* Delete this tag */
+	*arg = sieve_ast_arguments_detach(*arg, 1);
+		
+	return TRUE;
+}
+
+/* 
+ * Test registration 
+ */
+
+static const struct sieve_argument size_over_tag = { 
+	"over", 
+	NULL, NULL,
+	tst_size_validate_over_tag, 
+	NULL, NULL 
+};
+
+static const struct sieve_argument size_under_tag = { 
+	"under", 
+	NULL, NULL, 
+	tst_size_validate_under_tag, 
+	NULL, NULL 
+};
+
+static bool tst_size_registered
+(struct sieve_validator *validator, struct sieve_command_registration *cmd_reg) 
+{
+	/* Register our tags */
+	sieve_validator_register_tag(validator, cmd_reg, &size_over_tag, 0); 	
+	sieve_validator_register_tag(validator, cmd_reg, &size_under_tag, 0); 	
+
+	return TRUE;
+}
+
+/* 
+ * Test validation 
+ */
+
+static bool tst_size_pre_validate
+(struct sieve_validator *validator ATTR_UNUSED, 
+	struct sieve_command_context *tst) 
+{
+	struct tst_size_context_data *ctx_data;
+	
+	/* Assign context */
+	ctx_data = p_new(sieve_command_pool(tst), struct tst_size_context_data, 1);
+	ctx_data->type = SIZE_UNASSIGNED;
+	tst->data = ctx_data;
+
+	return TRUE;
+}
+
+static bool tst_size_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) tst->data;
+	struct sieve_ast_argument *arg = tst->first_positional;
+	
+	if ( ctx_data->type == SIZE_UNASSIGNED ) {
+		sieve_command_validate_error(validator, tst, 
+			"the size test requires either the :under or the :over tag "
+			"to be specified");
+		return FALSE;		
+	}
+		
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "limit", 1, SAAT_NUMBER) ) {
+		return FALSE;
+	}
+	
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/* 
+ * Code generation 
+ */
+
+bool tst_size_generate
+(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	struct tst_size_context_data *ctx_data = 
+		(struct tst_size_context_data *) ctx->data;
+
+	if ( ctx_data->type == SIZE_OVER ) 
+		sieve_operation_emit_code(cgenv->sbin, &tst_size_over_operation);
+	else
+		sieve_operation_emit_code(cgenv->sbin, &tst_size_under_operation);
+
+ 	/* Generate arguments */
+	if ( !sieve_generate_arguments(cgenv, ctx, NULL) )
+		return FALSE;
+	  
+	return TRUE;
+}
+
+/* 
+ * Code dump 
+ */
+
+static bool tst_size_operation_dump
+(const struct sieve_operation *op,
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+    sieve_code_dumpf(denv, "%s", op->mnemonic);
+	sieve_code_descend(denv);
+	
+	return 
+		sieve_opr_number_dump(denv, address, "limit");
+}
+
+/* 
+ * Code execution 
+ */
+
+static inline bool tst_size_get
+(const struct sieve_runtime_env *renv, sieve_number_t *size) 
+{
+	uoff_t psize;
+
+	if ( mail_get_physical_size(renv->msgdata->mail, &psize) < 0 )
+		return FALSE;
+
+	*size = psize;
+  
+	return TRUE;
+}
+
+static int tst_size_operation_execute
+(const struct sieve_operation *op,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	sieve_number_t mail_size, limit;
+		
+	/* Read size limit */
+	if ( !sieve_opr_number_read(renv, address, &limit) ) {
+		sieve_runtime_trace_error(renv, "invalid limit operand");
+		return SIEVE_EXEC_BIN_CORRUPT;	
+	}
+
+	sieve_runtime_trace(renv, "%s test", op->mnemonic);
+	
+	/* Get the size of the message */
+	if ( !tst_size_get(renv, &mail_size) ) {
+		/* FIXME: improve this error */
+		sieve_sys_error("failed to assess message size");
+		return SIEVE_EXEC_FAILURE;
+	}
+	
+	/* Perform the test */
+	if ( op == &tst_size_over_operation )
+		sieve_interpreter_set_test_result(renv->interp, (mail_size > limit));
+	else
+		sieve_interpreter_set_test_result(renv->interp, (mail_size < limit));
+
+	return SIEVE_EXEC_OK;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-truefalse.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-truefalse.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve/tst-truefalse.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve/tst-truefalse.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,65 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "sieve-ast.h"
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+
+#include "sieve-commands.h"
+#include "sieve-code.h"
+#include "sieve-interpreter.h"
+
+/*
+ * True/False test command
+ */
+
+static bool tst_false_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+static bool tst_true_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *cmd,
+		struct sieve_jumplist *jumps, bool jump_true);
+
+const struct sieve_command tst_false = { 
+	"false", 
+	SCT_TEST, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_false_generate 
+};
+
+const struct sieve_command tst_true = { 
+	"true", 
+	SCT_TEST, 
+	0, 0, FALSE, FALSE,
+	NULL, NULL, NULL, NULL, 
+	tst_true_generate 
+};
+
+static bool tst_false_generate
+(const struct sieve_codegen_env *cgenv, 
+	struct sieve_command_context *cmd ATTR_UNUSED,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	if ( !jump_true ) {
+		sieve_operation_emit_code(cgenv->sbin, &sieve_jmp_operation);
+		sieve_jumplist_add(jumps, sieve_binary_emit_offset(cgenv->sbin, 0));
+	}
+	
+	return TRUE;
+}
+
+static bool tst_true_generate
+(const struct sieve_codegen_env *cgenv,	
+	struct sieve_command_context *cmd ATTR_UNUSED,
+	struct sieve_jumplist *jumps, bool jump_true)
+{
+	if ( jump_true ) {
+		sieve_operation_emit_code(cgenv->sbin, &sieve_jmp_operation);
+		sieve_jumplist_add(jumps, sieve_binary_emit_offset(cgenv->sbin, 0));
+	}
+	
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/mail-raw.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,284 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: This file was gratefully stolen from dovecot/src/deliver/deliver.c and 
+ * altered to suit our needs. So, this contains lots and lots of duplicated 
+ * code. 
+ */
+
+#include "lib.h"
+#include "istream.h"
+#include "istream-seekable.h"
+#include "fd-set-nonblock.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "strescape.h"
+#include "safe-mkstemp.h"
+#include "close-keep-errno.h"
+#include "mkdir-parents.h"
+#include "message-address.h"
+#include "mbox-from.h"
+#include "raw-storage.h"
+#include "mail-namespace.h"
+
+#include "mail-raw.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Configuration
+ */
+
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/* After buffer grows larger than this, create a temporary file to /tmp
+   where to read the mail. */
+#define MAIL_MAX_MEMORY_BUFFER (1024*128)
+
+static const char *wanted_headers[] = {
+	"From", "Message-ID", "Subject", "Return-Path",
+	NULL
+};
+
+/*
+ * Global data
+ */
+
+static struct mail_namespace *raw_ns;
+static struct mail_user *raw_mail_user;
+
+/*
+ * Raw mail implementation
+ */
+
+static int seekable_fd_callback
+(const char **path_r, void *context ATTR_UNUSED)
+{
+	const char *dir, *p;
+	string_t *path;
+	int fd;
+
+	path = t_str_new(128);
+	str_append(path, "/tmp/dovecot.sieve-tool.");
+	fd = safe_mkstemp(path, 0600, (uid_t)-1, (gid_t)-1);
+	if (fd == -1 && errno == ENOENT) {
+		dir = str_c(path);
+		p = strrchr(dir, '/');
+		if (p != NULL) {
+			dir = t_strdup_until(dir, p);
+			if ( mkdir_parents(dir, 0600) < 0 ) {
+				i_error("mkdir_parents(%s) failed: %m", dir);
+				return -1;
+			}
+			fd = safe_mkstemp(path, 0600, (uid_t)-1, (gid_t)-1);
+		}
+	}
+
+	if (fd == -1) {
+		i_error("safe_mkstemp(%s) failed: %m", str_c(path));
+		return -1;
+	}
+
+	/* we just want the fd, unlink it */
+	if (unlink(str_c(path)) < 0) {
+		/* shouldn't happen.. */
+		i_error("unlink(%s) failed: %m", str_c(path));
+		close_keep_errno(fd);
+		return -1;
+	}
+
+	*path_r = str_c(path);
+	return fd;
+}
+
+static struct istream *create_raw_stream
+(int fd, time_t *mtime_r, const char **sender)
+{
+	struct istream *input, *input2, *input_list[2];
+	const unsigned char *data;
+	size_t i, size;
+	int ret, tz;
+	char *env_sender;
+
+	*mtime_r = (time_t)-1;
+	fd_set_nonblock(fd, FALSE);
+
+	input = i_stream_create_fd(fd, 4096, FALSE);
+	input->blocking = TRUE;
+	/* If input begins with a From-line, drop it */
+	ret = i_stream_read_data(input, &data, &size, 5);
+	if (ret > 0 && size >= 5 && memcmp(data, "From ", 5) == 0) {
+		/* skip until the first LF */
+		i_stream_skip(input, 5);
+		while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+			for (i = 0; i < size; i++) {
+				if (data[i] == '\n')
+					break;
+			}
+			if (i != size) {
+				(void)mbox_from_parse(data, i, mtime_r, &tz, &env_sender);
+				i_stream_skip(input, i + 1);
+				break;
+			}
+			i_stream_skip(input, size);
+		}
+	}
+
+	if (sender != NULL) {
+		*sender = t_strdup(env_sender);
+	}
+	i_free(env_sender);
+
+	if (input->v_offset == 0) {
+		input2 = input;
+		i_stream_ref(input2);
+	} else {
+		input2 = i_stream_create_limit(input, (uoff_t)-1);
+	}
+	i_stream_unref(&input);
+
+    input_list[0] = input2; input_list[1] = NULL;
+    input = i_stream_create_seekable(input_list, MAIL_MAX_MEMORY_BUFFER,
+                     seekable_fd_callback, raw_mail_user);
+    i_stream_unref(&input2);
+    return input;
+
+}
+
+/*
+ * Init/Deinit
+ */
+
+void mail_raw_init(const char *user) 
+{
+	const char *error;
+
+	raw_mail_user = mail_user_init(user);
+	mail_user_set_home(raw_mail_user, NULL);
+	raw_ns = mail_namespaces_init_empty(raw_mail_user);
+	raw_ns->flags |= NAMESPACE_FLAG_NOQUOTA | NAMESPACE_FLAG_NOACL;
+	
+	if ( mail_storage_create(raw_ns, "raw", "/tmp",
+		MAIL_STORAGE_FLAG_FULL_FS_ACCESS,
+		FILE_LOCK_METHOD_FCNTL, &error) < 0 ) {
+ 		i_fatal("Couldn't create internal raw storage: %s", error);
+	}
+}
+
+void mail_raw_deinit(void)
+{
+	mail_user_unref(&raw_mail_user);
+}
+
+
+/*
+ * Open raw mail data
+ */
+
+static struct mail_raw *mail_raw_create
+(struct istream *input, const char *mailfile, const char *sender,
+	time_t mtime)
+{
+	pool_t pool;
+	struct raw_mailbox *raw_box;
+	struct mail_raw *mailr;
+	enum mail_error error;
+
+	if ( mailfile != NULL ) {
+		if ( *mailfile != '/') {
+			char cwd[PATH_MAX];
+
+			/* Expand relative paths */
+			if (getcwd(cwd, sizeof(cwd)) == NULL)
+				i_fatal("getcwd() failed: %m");
+
+			mailfile = t_strconcat(cwd, "/", mailfile, NULL);		
+		} 
+	}
+
+	pool = pool_alloconly_create("mail_raw", 1024);
+	mailr = p_new(pool, struct mail_raw, 1);
+	mailr->pool = pool;
+
+	if ( mailfile == NULL ) {
+		mailr->box = mailbox_open(&raw_ns->storage, "Dovecot Raw Mail",
+				   input, MAILBOX_OPEN_NO_INDEX_FILES);
+	} else {
+		mtime = (time_t)-1;
+		mailr->box = mailbox_open(&raw_ns->storage, mailfile, NULL,
+				   MAILBOX_OPEN_NO_INDEX_FILES);
+	}
+
+	if ( mailr->box == NULL ) {
+		i_fatal("Can't open mail stream as raw: %s",
+			mail_storage_get_last_error(raw_ns->storage, &error));
+	}
+
+	if ( mailbox_sync(mailr->box, 0, 0, NULL ) < 0) {
+		enum mail_error error;
+
+		i_fatal("Can't sync delivery mail: %s",
+			mail_storage_get_last_error(raw_ns->storage, &error));
+	}
+
+	raw_box = (struct raw_mailbox *)mailr->box;
+	raw_box->envelope_sender = sender != NULL ? sender : DEFAULT_ENVELOPE_SENDER;
+	raw_box->mtime = mtime;
+
+	mailr->trans = mailbox_transaction_begin(mailr->box, 0);
+	mailr->headers_ctx = mailbox_header_lookup_init(mailr->box, wanted_headers);
+	mailr->mail = mail_alloc(mailr->trans, 0, mailr->headers_ctx);
+	mail_set_seq(mailr->mail, 1);
+
+	return mailr;
+}
+
+struct mail_raw *mail_raw_open_data(string_t *mail_data)
+{
+	struct mail_raw *mailr;
+	struct istream *input;
+
+	input = i_stream_create_from_data(str_data(mail_data), str_len(mail_data));
+	
+	mailr = mail_raw_create(input, NULL, NULL, (time_t)-1);
+
+	i_stream_unref(&input);
+
+	return mailr;
+}
+	
+struct mail_raw *mail_raw_open_file(const char *path)
+{
+	struct mail_raw *mailr;
+	struct istream *input = NULL;
+	time_t mtime;
+	const char *sender = NULL;
+	
+	if ( path == NULL || strcmp(path, "-") == 0 ) {
+		path = NULL;
+		input = create_raw_stream(0, &mtime, &sender);
+	}
+
+	mailr = mail_raw_create(input, path, sender, mtime);
+
+	if ( input != NULL )
+		i_stream_unref(&input);
+
+	return mailr;
+}
+
+void mail_raw_close(struct mail_raw *mailr) 
+{
+	mailbox_header_lookup_unref(&mailr->headers_ctx);
+
+	mail_free(&mailr->mail);
+	mailbox_transaction_rollback(&mailr->trans);
+	mailbox_close(&mailr->box);
+
+	pool_unref(&mailr->pool);
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/mail-raw.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,24 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MAIL_RAW_H
+#define __MAIL_RAW_H
+
+struct mail_raw {
+	pool_t pool;
+	struct mail *mail;
+
+	struct mailbox *box;
+	struct mailbox_header_lookup_ctx *headers_ctx;
+	struct mailbox_transaction_context *trans;
+};
+
+void mail_raw_init(const char *user);
+void mail_raw_deinit(void);
+
+struct mail_raw *mail_raw_open_file(const char *path);
+struct mail_raw *mail_raw_open_data(string_t *mail_data);
+void mail_raw_close(struct mail_raw *mailr);
+
+
+#endif /* __MAIL_RAW_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve-tool.la
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/lib-storage/index \
+	-I$(dovecot_incdir)/src/lib-storage/index/raw
+
+libsieve_tool_la_SOURCES = \
+	sieve-tool.c \
+	mail-raw.c
+
+noinst_HEADERS = \
+	sieve-tool.h \
+	mail-raw.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,190 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "lib-signals.h"
+#include "ioloop.h"
+#include "ostream.h"
+#include "hostpid.h"
+#include "mail-storage.h"
+
+#include "sieve.h"
+#include "sieve-tool.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Global state
+ */
+
+static struct ioloop *ioloop;
+
+/*
+ * Signal handlers
+ */
+
+static void sig_die(const siginfo_t *si, void *context ATTR_UNUSED)
+{
+	/* warn about being killed because of some signal, except SIGINT (^C)
+	 * which is too common at least while testing :) 
+	 */
+        if (si->si_signo != SIGINT) {
+		/* FIMXE: strange error for a command line tool */
+		i_warning("Killed with signal %d (by pid=%s uid=%s code=%s)",
+ 			si->si_signo, dec2str(si->si_pid),
+			dec2str(si->si_uid),
+			lib_signal_code_to_str(si->si_signo, si->si_code));
+        }
+        io_loop_stop(current_ioloop);
+}
+
+/*
+ * Initialization
+ */
+
+void sieve_tool_init(void) 
+{
+	lib_init();
+
+	ioloop = io_loop_create();
+
+	lib_signals_init();
+	lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+	lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+	lib_signals_ignore(SIGPIPE, TRUE);
+	lib_signals_ignore(SIGALRM, FALSE);
+
+	if ( !sieve_init() ) 
+		i_fatal("failed to initialize sieve implementation\n");
+}
+
+void sieve_tool_deinit(void)
+{
+	sieve_deinit();
+	
+	lib_signals_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+}
+
+/*
+ * Commonly needed functionality
+ */
+
+const char *sieve_tool_get_user(void)
+{
+	const char *user;
+	uid_t process_euid;
+	struct passwd *pw;
+
+	user = getenv("USER");
+
+	if ( user == NULL || *user == '\0' ) {
+		process_euid = geteuid();
+
+		if ((pw = getpwuid(process_euid)) != NULL) {
+			user = t_strdup(pw->pw_name);
+		}
+
+		if ( user == NULL || *user == '\0' ) {
+			i_fatal("couldn't lookup our username (uid=%s)", dec2str(process_euid));
+		}
+	}
+	
+	return user;
+}
+
+void sieve_tool_get_envelope_data
+	(struct mail *mail, const char **recipient, const char **sender)
+{
+	/* Get recipient address */
+	if ( *recipient == NULL ) 
+		(void)mail_get_first_header(mail, "Envelope-To", recipient);
+	if ( *recipient == NULL ) 
+		(void)mail_get_first_header(mail, "To", recipient);
+	if ( *recipient == NULL ) 
+		*recipient = "recipient@example.com";
+	
+	/* Get sender address */
+	if ( *sender == NULL ) 
+		(void)mail_get_first_header(mail, "Return-path", sender);
+	if ( *sender == NULL ) 
+		(void)mail_get_first_header(mail, "Sender", sender);
+	if ( *sender == NULL ) 
+		(void)mail_get_first_header(mail, "From", sender);
+	if ( *sender == NULL ) 
+		*sender = "sender@example.com";
+}
+
+/*
+ * Sieve script handling
+ */
+
+struct sieve_binary *sieve_tool_script_compile
+(const char *filename, const char *name)
+{
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	if ( (sbin = sieve_compile(filename, name, ehandler)) == NULL )
+		i_error("failed to compile sieve script '%s'\n", filename);
+
+	sieve_error_handler_unref(&ehandler);
+		
+	return sbin;
+}
+	
+struct sieve_binary *sieve_tool_script_open(const char *filename)
+{
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	if ( (sbin = sieve_open(filename, NULL, ehandler, NULL)) == NULL ) {
+		sieve_error_handler_unref(&ehandler);
+		i_fatal("Failed to compile sieve script\n");
+	}
+
+	sieve_error_handler_unref(&ehandler);
+		
+	return sbin;
+}
+	
+void sieve_tool_dump_binary_to(struct sieve_binary *sbin, const char *filename)	
+{
+	int dfd = -1;
+	struct ostream *dumpstream;
+	
+	if ( filename == NULL ) return;
+	
+	if ( strcmp(filename, "-") == 0 ) 
+		dumpstream = o_stream_create_fd(1, 0, FALSE);
+	else {
+		if ( (dfd = open(filename, O_WRONLY | O_TRUNC | O_CREAT, 0600)) < 0 ) {
+			i_fatal("failed to open dump-file for writing: %m");
+		}
+		
+		dumpstream = o_stream_create_fd(dfd, 0, FALSE);
+	}
+	
+	if ( dumpstream != NULL ) {
+		(void) sieve_dump(sbin, dumpstream);
+		o_stream_destroy(&dumpstream);
+	} else {
+		i_fatal("Failed to create stream for sieve code dump.");
+	}
+	
+	if ( dfd != -1 )
+		close(dfd);
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h
--- dovecot-1.2.0/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/lib-sieve-tool/sieve-tool.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_TOOL_H
+#define __SIEVE_TOOL_H
+
+/* Functionality common to all Sieve command line tools. */
+
+/*
+ * Initialization
+ */
+
+void sieve_tool_init(void);
+void sieve_tool_deinit(void);
+
+/*
+ * Commonly needed functionality
+ */
+
+const char *sieve_tool_get_user(void);
+
+void sieve_tool_get_envelope_data
+	(struct mail *mail, const char **recipient, const char **sender);
+
+/*
+ * Sieve script handling
+ */
+
+struct sieve_binary *sieve_tool_script_compile
+	(const char *filename, const char *name);
+struct sieve_binary *sieve_tool_script_open(const char *filename);
+void sieve_tool_dump_binary_to(struct sieve_binary *sbin, const char *filename);
+
+#endif /* __SIEVE_TOOL_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,6 @@
+if HAVE_DOVECOT_LIBS
+LIB_DEPEND_DIRS=lib-sieve-tool sieve-tools
+endif
+
+SUBDIRS = lib-sieve plugins $(LIB_DEPEND_DIRS)
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c
--- dovecot-1.2.0/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,664 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file 
+ */
+
+#include "lib.h"
+#include "array.h"
+#include "home-expand.h"
+#include "deliver.h"
+#include "duplicate.h"
+#include "smtp-client.h"
+
+#include "sieve.h"
+
+#include "lda-sieve-plugin.h"
+
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+/*
+ * Configuration
+ */
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define LDA_SIEVE_MAX_USER_ERRORS 10
+#define LDA_SIEVE_MAX_SYSTEM_ERRORS 100
+
+/*
+ * Global variables 
+ */
+
+static deliver_mail_func_t *next_deliver_mail;
+
+static bool lda_sieve_debug = FALSE;
+
+/*
+ * Mail transmission
+ */
+
+static void *lda_sieve_smtp_open(const char *destination,
+	const char *return_path, FILE **file_r)
+{
+	return (void *) smtp_client_open(destination, return_path, file_r);
+}
+
+static bool lda_sieve_smtp_close(void *handle)
+{
+	struct smtp_client *smtp_client = (struct smtp_client *) handle;
+
+	return ( smtp_client_close(smtp_client) == 0 );
+}
+
+/*
+ * Plugin implementation
+ */
+
+struct lda_sieve_run_context {
+	const char *const *script_files;
+	unsigned int script_count;
+
+	const char *user_script;
+	const char *main_script;
+
+	const struct sieve_message_data *msgdata;
+	const struct sieve_script_env *scriptenv;
+
+	struct sieve_error_handler *user_ehandler;
+	struct sieve_error_handler *master_ehandler;
+	const char *userlog;
+};
+
+static const char *lda_sieve_get_personal_path(void)
+{
+	const char *script_path, *home;
+
+	home = getenv("HOME");
+
+	/* userdb may specify Sieve path */
+	script_path = getenv("SIEVE");
+	if (script_path != NULL) {
+		if (*script_path == '\0') {
+			/* disabled */
+			if ( lda_sieve_debug )
+				sieve_sys_info("empty script path, disabled");
+			return NULL;
+		}
+
+		script_path = home_expand(script_path);
+
+		if (*script_path != '/' && *script_path != '\0') {
+			/* relative path. change to absolute. */
+			script_path = t_strconcat(getenv("HOME"), "/",
+						  script_path, NULL);
+		}
+	} else {
+		if (home == NULL) {
+			sieve_sys_error("per-user script path is unknown. See "
+				"http://wiki.dovecot.org/LDA/Sieve#location");
+			return NULL;
+		}
+
+		script_path = home_expand(SIEVE_SCRIPT_PATH);
+	}
+
+	return script_path;
+}
+
+static const char *lda_sieve_get_default_path(void)
+{
+	const char *script_path;
+
+	/* Use global script path, if one exists */
+	script_path = getenv("SIEVE_GLOBAL_PATH");
+	if (script_path == NULL) {
+		/* For backwards compatibility */
+		script_path = getenv("GLOBAL_SCRIPT_PATH");
+	}
+
+	return script_path;
+}
+
+static void lda_sieve_multiscript_get_scriptfiles
+(const char *script_path, ARRAY_TYPE(const_string) *scriptfiles)
+{
+	struct sieve_directory *sdir = sieve_directory_open(script_path);
+
+	if ( sdir != NULL ) {
+		const char *file;
+
+		while ( (file=sieve_directory_get_scriptfile(sdir)) != NULL ) {
+			const char *const *scripts;
+			unsigned int count, i;
+
+			/* Insert into sorted array */
+
+			scripts = array_get(scriptfiles, &count);
+			for ( i = 0; i < count; i++ ) {
+				if ( strcmp(file, scripts[i]) < 0 )
+					break;			
+			}
+	
+			if ( i == count ) 
+				array_append(scriptfiles, &file, 1);
+			else
+				array_insert(scriptfiles, i, &file, 1);
+		}
+
+		sieve_directory_close(&sdir);
+	} 
+}
+
+static int lda_sieve_open
+(struct lda_sieve_run_context *srctx, unsigned int script_index,
+	struct sieve_binary **sbin)
+{
+	const char *script_path = srctx->script_files[script_index];
+	const char *script_name = 
+		( script_path == srctx->main_script ? "main_script" : NULL );
+	struct sieve_error_handler *ehandler;
+	bool exists = TRUE;
+	int ret = 0;
+
+	if ( script_path == srctx->user_script )
+		ehandler = srctx->user_ehandler;
+	else
+		ehandler = srctx->master_ehandler;
+
+	if ( lda_sieve_debug )
+		sieve_sys_info("opening script %s", script_path);		
+
+	sieve_error_handler_reset(ehandler);
+
+	if ( (*sbin=sieve_open(script_path, script_name, ehandler, &exists)) 
+		== NULL ) {
+
+		ret = sieve_get_errors(ehandler) > 0 ? -1 : 0;
+
+		if ( !exists && ret == 0 ) {
+			if ( lda_sieve_debug )
+				sieve_sys_info("script file %s is missing", script_path);
+		} else {
+			if ( script_path == srctx->user_script && srctx->userlog != NULL ) {
+				sieve_sys_error
+					("failed to open script %s "
+						"(view logfile %s for more information)", 
+						script_path, srctx->userlog);
+			} else {
+				sieve_sys_error
+					("failed to open script %s", 
+						script_path);
+			}
+		}
+
+		return ret;
+	}
+
+	return 1;
+}
+
+static struct sieve_binary *lda_sieve_recompile
+(struct lda_sieve_run_context *srctx, unsigned int script_index)
+{
+	const char *script_path = srctx->script_files[script_index];
+    const char *script_name = 
+		( script_path == srctx->main_script ? "main_script" : NULL );
+    struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+
+	/* Warn */
+
+	sieve_sys_warning("encountered corrupt binary: recompiling script %s", 
+		script_path);
+
+	/* Recompile */	
+
+	if ( script_path == srctx->user_script )
+		ehandler = srctx->user_ehandler;
+	else
+		ehandler = srctx->master_ehandler;
+
+	if ( (sbin=sieve_compile(script_path, script_name, ehandler)) == NULL ) {
+
+		if ( script_path == srctx->user_script && srctx->userlog != NULL ) {
+			sieve_sys_error
+				("failed to re-compile script %s "
+					"(view logfile %s for more information)",
+					script_path, srctx->userlog);
+		} else {
+			sieve_sys_error
+				("failed to re-compile script %s", script_path);
+		}
+
+		return NULL;
+	}
+
+	return sbin;
+}
+
+static int lda_sieve_handle_exec_status(const char *script_path, int status)
+{
+	int ret; 
+
+	switch ( status ) {
+	case SIEVE_EXEC_FAILURE:
+		sieve_sys_error
+			("execution of script %s failed, but implicit keep was successful", 
+				script_path);
+		ret = 1;
+		break;
+	case SIEVE_EXEC_BIN_CORRUPT:		
+		sieve_sys_error
+			("!!BUG!!: binary compiled from %s is still corrupt; "
+				"bailing out and reverting to default delivery", 
+				script_path);
+		ret = -1;
+		break;
+	case SIEVE_EXEC_KEEP_FAILED:
+		sieve_sys_error
+			("script %s failed with unsuccessful implicit keep", script_path);
+		ret = -1;
+		break;
+	default:
+		ret = status > 0 ? 1 : -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int lda_sieve_singlescript_execute
+(struct lda_sieve_run_context *srctx)
+{
+	const char *script_file = srctx->script_files[0];
+    bool user_script = ( script_file == srctx->user_script );
+	struct sieve_error_handler *ehandler;
+	struct sieve_binary *sbin;
+	int ret;
+
+	/* Open the script */
+
+	if ( (ret=lda_sieve_open(srctx, 0, &sbin)) <= 0 )
+		return ret;
+
+	/* Execute */
+
+	if ( lda_sieve_debug )
+		sieve_sys_info("executing compiled script %s", script_file);
+
+	if ( user_script ) {
+		ehandler = srctx->user_ehandler;
+		sieve_error_handler_copy_masterlog(ehandler, TRUE);	
+	} else {
+		ehandler = srctx->master_ehandler;
+	}
+
+	ret = sieve_execute(sbin, srctx->msgdata, srctx->scriptenv, ehandler);
+
+	sieve_error_handler_copy_masterlog(ehandler, FALSE);	
+
+	/* Recompile if corrupt binary */
+
+	if ( ret == SIEVE_EXEC_BIN_CORRUPT ) {
+		/* Close corrupt script */
+
+		sieve_close(&sbin);
+
+		/* Recompile */
+
+		if ( (sbin=lda_sieve_recompile(srctx, 0)) == NULL ) {
+			return -1;
+		}
+
+		/* Execute again */
+
+		if ( user_script )
+        	sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+		ret = sieve_execute(sbin, srctx->msgdata, srctx->scriptenv, ehandler);
+
+		sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+		/* Save new version */
+
+		if ( ret != SIEVE_EXEC_BIN_CORRUPT )
+			sieve_save(sbin, NULL);
+	}
+
+	sieve_close(&sbin);
+
+	/* Report status */
+	return lda_sieve_handle_exec_status(script_file, ret);
+}
+
+static int lda_sieve_multiscript_execute
+(struct lda_sieve_run_context *srctx)
+{
+	const char *const *scripts = srctx->script_files;
+	unsigned int count = srctx->script_count;
+	struct sieve_multiscript *mscript;
+	struct sieve_error_handler *ehandler = srctx->master_ehandler;
+	const char *last_script = NULL;
+	bool user_script = FALSE;
+	unsigned int i;
+	int ret = 1; 
+	bool more = TRUE;
+
+	/* Start execution */
+
+	mscript = sieve_multiscript_start_execute(srctx->msgdata, srctx->scriptenv);
+
+	/* Execute scripts before main script */
+
+	for ( i = 0; i < count && more; i++ ) {
+		struct sieve_binary *sbin = NULL;
+		const char *script_file = scripts[i];
+		bool final = ( i == count - 1 );
+
+		user_script = ( script_file == srctx->user_script );
+		last_script = script_file;		
+
+		if ( user_script )
+			ehandler = srctx->user_ehandler;
+		else
+			ehandler = srctx->master_ehandler;
+
+		/* Open */
+	
+		if ( (ret=lda_sieve_open(srctx, i, &sbin)) <= 0 )
+			break;
+
+		/* Execute */
+
+		if ( user_script )	
+			sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+		more = sieve_multiscript_run(mscript, sbin, ehandler, final);
+
+		sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+		if ( !more ) {
+			if ( sieve_multiscript_status(mscript) == SIEVE_EXEC_BIN_CORRUPT ) {
+				/* Close corrupt script */
+
+				sieve_close(&sbin);
+
+				/* Recompile */
+
+				if ( (sbin=lda_sieve_recompile(srctx, i))
+					== NULL ) {
+					ret = -1;
+					break;
+				}
+
+				/* Execute again */
+
+				if ( user_script )
+					sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+				more = sieve_multiscript_run(mscript, sbin, ehandler, final);
+
+				sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+				/* Save new version */
+
+				if ( more && 
+					sieve_multiscript_status(mscript) != SIEVE_EXEC_BIN_CORRUPT )
+					sieve_save(sbin, NULL);
+			}
+		}
+
+		sieve_close(&sbin);
+	}
+
+	/* Finish execution */
+
+	if ( user_script )	
+		sieve_error_handler_copy_masterlog(ehandler, TRUE);
+
+	ret = sieve_multiscript_finish(&mscript, ehandler);
+
+	sieve_error_handler_copy_masterlog(ehandler, FALSE);
+
+	return lda_sieve_handle_exec_status(last_script, ret);
+}
+
+static int lda_sieve_run
+(struct mail_namespace *namespaces, struct mail *mail, 
+	const char *user_script, const char *default_script,
+	const ARRAY_TYPE (const_string) *scripts_before, 
+	const ARRAY_TYPE (const_string) *scripts_after, 
+	const char *destaddr, const char *username, const char *mailbox, 
+	struct mail_storage **storage_r)
+{
+	ARRAY_TYPE (const_string) scripts;
+
+	struct lda_sieve_run_context srctx;
+	struct sieve_message_data msgdata;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	int ret = 0;
+
+	*storage_r = NULL;
+
+	/* Initialize */
+
+	memset(&srctx, 0, sizeof(srctx));
+
+	/* Compose execution sequence */
+
+	t_array_init(&scripts, 32);
+
+	array_append_array(&scripts, scripts_before);
+
+	if ( user_script != NULL ) {
+		array_append(&scripts, &user_script, 1);
+		srctx.user_script = user_script;
+		srctx.main_script = user_script;
+	} else if ( default_script != NULL ) {
+		array_append(&scripts, &default_script, 1);
+		srctx.user_script = NULL;
+		srctx.main_script = default_script;
+	} else {
+		srctx.user_script = NULL;
+        srctx.main_script = NULL;
+	}
+
+	array_append_array(&scripts, scripts_after);
+
+	/* Create error handlers */
+
+	if ( user_script != NULL ) {
+		srctx.userlog = t_strconcat(user_script, ".log", NULL);
+		srctx.user_ehandler = sieve_logfile_ehandler_create(srctx.userlog, LDA_SIEVE_MAX_USER_ERRORS);
+	}
+
+	srctx.master_ehandler = sieve_master_ehandler_create(LDA_SIEVE_MAX_SYSTEM_ERRORS);
+	sieve_error_handler_accept_infolog(srctx.master_ehandler, TRUE);
+
+	/* Collect necessary message data */
+
+	memset(&msgdata, 0, sizeof(msgdata));
+
+	msgdata.mail = mail;
+	msgdata.return_path = deliver_get_return_address(mail);
+	msgdata.to_address = destaddr;
+	msgdata.auth_user = username;
+	(void)mail_get_first_header(mail, "Message-ID", &msgdata.id);
+
+	srctx.msgdata = &msgdata;
+
+	/* Compose script execution environment */
+
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	memset(&estatus, 0, sizeof(estatus));
+
+	scriptenv.default_mailbox = mailbox;
+	scriptenv.mailbox_autocreate = deliver_set->mailbox_autocreate;
+	scriptenv.mailbox_autosubscribe = deliver_set->mailbox_autosubscribe;
+	scriptenv.namespaces = namespaces;
+	scriptenv.username = username;
+	scriptenv.hostname = deliver_set->hostname;
+	scriptenv.postmaster_address = deliver_set->postmaster_address;
+	scriptenv.smtp_open = lda_sieve_smtp_open;
+	scriptenv.smtp_close = lda_sieve_smtp_close;
+	scriptenv.duplicate_mark = duplicate_mark;
+	scriptenv.duplicate_check = duplicate_check;
+	scriptenv.exec_status = &estatus;
+
+	srctx.scriptenv = &scriptenv;
+
+	/* Assign script sequence */
+
+	srctx.script_files = array_get(&scripts, &srctx.script_count);
+
+	/* Execute script(s) */
+
+	if ( srctx.script_count == 1 )
+		ret = lda_sieve_singlescript_execute(&srctx);
+	else
+		ret = lda_sieve_multiscript_execute(&srctx);	
+
+	/* Record status */
+
+	tried_default_save = estatus.tried_default_save;
+	*storage_r = estatus.last_storage;
+
+	/* Clean up */
+
+	if ( srctx.user_ehandler != NULL )
+		sieve_error_handler_unref(&srctx.user_ehandler);
+	sieve_error_handler_unref(&srctx.master_ehandler);
+
+	return ret;
+}
+
+static int lda_sieve_deliver_mail
+(struct mail_namespace *namespaces, struct mail_storage **storage_r, 
+	struct mail *mail, const char *destaddr, const char *mailbox)
+{
+	const char *user_script, *default_script, *sieve_before, *sieve_after;
+	ARRAY_TYPE (const_string) scripts_before;
+	ARRAY_TYPE (const_string) scripts_after;
+	int ret = 0;
+
+	*storage_r = NULL;
+
+	T_BEGIN { 
+		struct stat st;
+
+		/* Find the personal script to execute */
+	
+		user_script = lda_sieve_get_personal_path();
+		default_script = lda_sieve_get_default_path();
+
+		if ( stat(user_script, &st) < 0 ) {
+			if (errno != ENOENT)
+				sieve_sys_error("stat(%s) failed: %m "
+					"(using global script path in stead)", user_script);
+			else if (getenv("DEBUG") != NULL)
+				sieve_sys_info("local script path %s doesn't exist "
+					"(using global script path in stead)", user_script);
+
+			user_script = NULL;
+		}
+
+		if ( lda_sieve_debug ) {
+			const char *script = user_script == NULL ? default_script : user_script;
+
+			if ( script == NULL )
+				sieve_sys_info("user has no valid personal script");
+			else
+				sieve_sys_info("using sieve path for user's script: %s", script);
+		}
+
+		/* Check for multiscript */
+
+		t_array_init(&scripts_before, 16);
+		t_array_init(&scripts_after, 16);
+
+		sieve_before = getenv("SIEVE_BEFORE");
+		sieve_after = getenv("SIEVE_AFTER");
+
+		if ( sieve_before != NULL && *sieve_before != '\0' ) {
+			lda_sieve_multiscript_get_scriptfiles(sieve_before, &scripts_before);
+		}
+
+		if ( sieve_after != NULL && *sieve_after != '\0' ) {
+			lda_sieve_multiscript_get_scriptfiles(sieve_after, &scripts_after);
+		}
+
+		if ( lda_sieve_debug ) {
+			const char *const *scriptfiles;
+			unsigned int count, i;
+
+			scriptfiles = array_get(&scripts_before, &count);
+			for ( i = 0; i < count; i ++ ) {
+				sieve_sys_info("executed before user's script(%d): %s", i+1, scriptfiles[i]);				
+			}
+
+			scriptfiles = array_get(&scripts_after, &count);
+			for ( i = 0; i < count; i ++ ) {
+				sieve_sys_info("executed after user's script(%d): %s", i+1, scriptfiles[i]);				
+			}
+		}
+
+		/* Check whether there are any scripts to execute */
+
+		if ( array_count(&scripts_before) == 0 && array_count(&scripts_before) == 0 &&
+			user_script == NULL && default_script == NULL ) {
+			if ( lda_sieve_debug )
+				sieve_sys_info("no scripts to execute: reverting to default delivery.");
+
+			/* No error, but no delivery by this plugin either. A return value of <= 0 for a 
+			 * deliver plugin is is considered a failure. In deliver itself, saved_mail and 
+			 * tried_default_save remain unset, meaning that deliver will then attempt the 
+			 * default delivery. We return 0 to signify the lack of a real error. 
+			 */
+			ret = 0; 
+		} else {
+			/* Run the script(s) */
+				
+			ret = lda_sieve_run
+				(namespaces, mail, user_script,	default_script,
+					&scripts_before, &scripts_after, 
+					destaddr, getenv("USER"), mailbox, storage_r);
+		}
+
+	} T_END;
+
+	return ret; 
+}
+
+/*
+ * Plugin interface
+ */
+
+void sieve_plugin_init(void)
+{
+	const char *extensions = NULL;
+
+	/* Initialize Sieve engine */
+	sieve_init();
+
+	extensions = getenv("SIEVE_EXTENSIONS");
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Debug mode */
+	lda_sieve_debug = getenv("DEBUG");
+
+	/* Hook into the delivery process */
+	next_deliver_mail = deliver_mail;
+	deliver_mail = lda_sieve_deliver_mail;
+}
+
+void sieve_plugin_deinit(void)
+{
+	/* Remove hook */
+	deliver_mail = next_deliver_mail;
+
+	/* Deinitialize Sieve engine */
+	sieve_deinit();
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h
--- dovecot-1.2.0/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/lda-sieve/lda-sieve-plugin.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,14 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __LDA_SIEVE_PLUGIN_H
+#define __LDA_SIEVE_PLUGIN_H
+
+/*
+ * Plugin interface
+ */
+
+void sieve_plugin_init(void);
+void sieve_plugin_deinit(void);
+
+#endif /* __LDA_SIEVE_PLUGIN_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/lda-sieve/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,23 @@
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+lda_moduledir = $(moduledir)/lda
+
+lib90_sieve_plugin_la_LDFLAGS = -module -avoid-version
+
+lda_module_LTLIBRARIES = lib90_sieve_plugin.la
+
+lib90_sieve_plugin_la_LIBADD = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la
+
+lib90_sieve_plugin_la_SOURCES = \
+	lda-sieve-plugin.c 
+
+noinst_HEADERS = \
+	lda-sieve-plugin.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/plugins/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/plugins/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/plugins/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1 @@
+SUBDIRS = lda-sieve
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/cmd-debug-print.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,133 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-code.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-debug-common.h"
+
+/* 
+ * Debug_print command
+ *
+ * Syntax
+ *   debug_print <message: string>
+ */
+
+static bool cmd_debug_print_validate
+	(struct sieve_validator *validator, struct sieve_command_context *tst);
+static bool cmd_debug_print_generate
+	(const struct sieve_codegen_env *cgenv,	struct sieve_command_context *ctx);
+
+const struct sieve_command debug_print_command = { 
+	"debug_print", 
+	SCT_COMMAND, 
+	1, 0, FALSE, FALSE,
+	NULL, NULL,
+	cmd_debug_print_validate, 
+	cmd_debug_print_generate, 
+	NULL 
+};
+
+/* 
+ * Body operation 
+ */
+
+static bool cmd_debug_print_operation_dump
+	(const struct sieve_operation *op, 
+		const struct sieve_dumptime_env *denv, sieve_size_t *address);
+static int cmd_debug_print_operation_execute
+	(const struct sieve_operation *op,
+		const struct sieve_runtime_env *renv, sieve_size_t *address);
+
+const struct sieve_operation debug_print_operation = { 
+	"debug_print",
+	&debug_extension,
+	0,
+	cmd_debug_print_operation_dump, 
+	cmd_debug_print_operation_execute 
+};
+
+/* 
+ * Validation 
+ */
+ 
+static bool cmd_debug_print_validate
+(struct sieve_validator *validator, struct sieve_command_context *tst) 
+{ 		
+	struct sieve_ast_argument *arg = tst->first_positional;
+					
+	if ( !sieve_validate_positional_argument
+		(validator, tst, arg, "message", 1, SAAT_STRING) ) {
+		return FALSE;
+	}
+
+	return sieve_validator_argument_activate(validator, tst, arg, FALSE);
+}
+
+/*
+ * Code generation
+ */
+ 
+static bool cmd_debug_print_generate
+	(const struct sieve_codegen_env *cgenv, struct sieve_command_context *ctx) 
+{
+	(void)sieve_operation_emit_code(cgenv->sbin, &debug_print_operation);
+
+	/* Generate arguments */
+	return sieve_generate_arguments(cgenv, ctx, NULL);
+}
+
+/* 
+ * Code dump 
+ */
+ 
+static bool cmd_debug_print_operation_dump
+(const struct sieve_operation *op ATTR_UNUSED, 
+	const struct sieve_dumptime_env *denv, sieve_size_t *address)
+{
+	sieve_code_dumpf(denv, "DEBUG_PRINT");
+	sieve_code_descend(denv);
+
+	return sieve_opr_string_dump(denv, address, "key list");
+}
+
+/*
+ * Interpretation
+ */
+
+static int cmd_debug_print_operation_execute
+(const struct sieve_operation *op ATTR_UNUSED,
+	const struct sieve_runtime_env *renv, sieve_size_t *address)
+{
+	string_t *message;
+	int ret = SIEVE_EXEC_OK;
+
+	/*
+	 * Read operands
+	 */
+	
+	/* Read message */
+
+	if ( sieve_opr_string_read(renv, address, &message) < 0 ) {
+		sieve_runtime_trace_error(renv, "invalid message operand");
+		return SIEVE_EXEC_BIN_CORRUPT;
+	}
+	
+	/*
+	 * Perform operation
+	 */
+
+	sieve_runtime_trace(renv, "DEBUG_PRINT");
+	
+	/* FIXME: give this proper source location */
+	sieve_runtime_log(renv, "DEBUG", "%s", str_c(message));
+
+	return ret;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/ext-debug.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* Extension debug 
+ * ------------------
+ *
+ * Authors: Stephan Bosch
+ * Specification: vendor-defined
+ * Implementation: full
+ * Status: experimental
+ *
+ */
+ 
+#include "lib.h"
+#include "array.h"
+
+#include "sieve-extensions.h"
+#include "sieve-commands.h"
+#include "sieve-comparators.h"
+#include "sieve-match-types.h"
+#include "sieve-address-parts.h"
+
+#include "sieve-validator.h"
+#include "sieve-generator.h"
+#include "sieve-binary.h"
+#include "sieve-interpreter.h"
+#include "sieve-dump.h"
+
+#include "ext-debug-common.h"
+
+/* 
+ * Extension 
+ */
+
+static bool ext_debug_validator_load(struct sieve_validator *validator);
+
+int ext_debug_my_id = -1;
+
+const struct sieve_extension debug_extension = { 
+	"vnd.dovecot.debug", 
+	&ext_debug_my_id,
+	NULL, NULL,
+	ext_debug_validator_load, 
+	NULL, NULL, NULL, NULL, NULL,
+	SIEVE_EXT_DEFINE_OPERATION(debug_print_operation), 
+	SIEVE_EXT_DEFINE_NO_OPERANDS
+};
+
+static bool ext_debug_validator_load(struct sieve_validator *validator)
+{
+	/* Register new test */
+	sieve_validator_register_command(validator, &debug_print_command);
+
+	return TRUE;
+}
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/ext-debug-common.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,21 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __EXT_DEBUG_COMMON_H
+#define __EXT_DEBUG_COMMON_H
+
+#include "sieve-ext-debug.h"
+
+/* 
+ * Commands
+ */
+
+extern const struct sieve_command debug_print_command;
+ 
+/*
+ * Operations
+ */
+
+extern const struct sieve_operation debug_print_operation;
+
+#endif /* __EXT_DEBUG_COMMON_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,19 @@
+noinst_LTLIBRARIES = libsieve_ext_debug.la
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage 
+
+commands = \
+	cmd-debug-print.c
+
+libsieve_ext_debug_la_SOURCES = \
+	$(commands) \
+	ext-debug.c
+
+noinst_HEADERS = \
+	sieve-ext-debug.h \
+	ext-debug-common.h
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/debug/sieve-ext-debug.h	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#ifndef __SIEVE_EXT_DEBUG_H
+#define __SIEVE_EXT_DEBUG_H
+
+/*
+ * Extension
+ */
+ 
+extern const struct sieve_extension debug_extension;
+
+#endif /* __SIEVE_EXT_DEBUG_H */
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/Makefile.am dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/Makefile.am
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/Makefile.am	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,57 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+SUBDIRS = debug
+
+bin_PROGRAMS = sievec sieved sieve-test sieve-filter
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/lib-sieve \
+	-I$(top_srcdir)/src/lib-sieve-tool \
+	-I./debug \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+sievec_LDFLAGS = -export-dynamic 
+sieved_LDFLAGS = -export-dynamic 
+sieve_test_LDFLAGS = -export-dynamic
+sieve_filter_LDFLAGS = -export-dynamic
+
+libs = \
+	$(top_srcdir)/src/lib-sieve/libsieve.la \
+	$(top_srcdir)/src/lib-sieve-tool/libsieve-tool.la \
+	./debug/libsieve_ext_debug.la \
+	$(STORAGE_LIBS) 
+
+ldadd = \
+	$(libs) \
+ 	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+sievec_LDADD = $(ldadd)
+sieved_LDADD = $(ldadd)
+sieve_test_LDADD = $(ldadd)
+sieve_filter_LDADD = $(ldadd)
+
+sievec_DEPENDENCIES = $(libs)
+sieved_DEPENDENCIES = $(libs)
+sieve_test_DEPENDENCIES = $(libs)
+sieve_filter_DEPENDENCIES = $(libs)
+
+sievec_SOURCES = \
+	sievec.c 
+
+sieved_SOURCES = \
+	sieved.c 
+
+sieve_test_SOURCES = \
+	sieve-test.c 
+
+sieve_filter_SOURCES = \
+	sieve-filter.c 
+
+noinst_HEADERS =
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sievec.c dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sievec.c
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sievec.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sievec.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,153 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-script.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <dirent.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sievec [-d] [-x <extensions>] <script-file> [<out-file>]\n"
+	);
+}
+
+/* 
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) {
+	int i;
+	struct stat st;
+	struct sieve_binary *sbin;
+	bool dump = FALSE;
+	const char *scriptfile, *outfile, *extensions;
+		
+	sieve_tool_init();	
+		
+	scriptfile = outfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			dump = TRUE;
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( outfile == NULL ) {
+			outfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <script-file> argument");
+	}
+	
+	if ( outfile == NULL && dump )
+		outfile = "-";
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+
+	if ( stat(scriptfile, &st) == 0 && S_ISDIR(st.st_mode) ) {
+		/* Script directory */
+		DIR *dirp;
+		struct dirent *dp;
+		
+		/* Sanity checks on some of the arguments */
+		
+		if ( dump )
+			i_fatal("the -d option is not allowed when scriptfile is a directory."); 
+		
+		if ( outfile != NULL )
+			i_fatal("the outfile argument is not allowed when scriptfile is a "
+				"directory."); 
+		
+		/* Open the directory */
+		if ( (dirp = opendir(scriptfile)) == NULL )
+			i_fatal("opendir(%s) failed: %m", scriptfile);
+			
+		/* Compile each sieve file */
+		for (;;) {
+		
+			errno = 0;
+			if ( (dp = readdir(dirp)) == NULL ) {
+				if ( errno != 0 ) 
+					i_fatal("readdir(%s) failed: %m", scriptfile);
+				break;
+			}
+											
+			if ( sieve_script_file_has_extension(dp->d_name) ) {
+				const char *file;
+				
+				if ( scriptfile[strlen(scriptfile)-1] == '/' )
+					file = t_strconcat(scriptfile, dp->d_name, NULL);
+				else
+					file = t_strconcat(scriptfile, "/", dp->d_name, NULL);
+
+				sbin = sieve_tool_script_compile(file, dp->d_name);
+
+				if ( sbin != NULL ) {
+					sieve_save(sbin, NULL);
+		
+					sieve_close(&sbin);
+				}
+			}
+		}
+   
+		/* Close the directory */
+		if ( closedir(dirp) < 0 ) 
+			i_fatal("closedir(%s) failed: %m", scriptfile);
+ 	
+	} else {
+		/* Script file (i.e. not a directory)
+		 * 
+		 *   NOTE: For consistency, stat errors are handled here as well 
+		 */	
+		sbin = sieve_tool_script_compile(scriptfile, NULL);
+
+		if ( sbin != NULL ) {
+			if ( dump ) 
+				sieve_tool_dump_binary_to(sbin, outfile);
+			else {
+				sieve_save(sbin, outfile);
+			}
+		
+			sieve_close(&sbin);
+		}
+	}
+		
+	sieve_tool_deinit();
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sieved.c dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sieved.c
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sieved.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sieved.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,91 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieved [-x <extensions>] <sieve-binary> [<out-file>]\n"
+	);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) {
+	int i;
+	struct sieve_binary *sbin;
+	const char *binfile, *outfile, *extensions;
+	
+	sieve_tool_init();
+	
+	binfile = outfile = extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if ( binfile == NULL ) {
+			binfile = argv[i];
+		} else if ( outfile == NULL ) {
+			outfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( binfile == NULL ) {
+		print_help();
+		i_fatal("missing <sieve-binary> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+		
+	sbin = sieve_binary_open(binfile, NULL);
+
+	if ( sbin != NULL && !sieve_binary_load(sbin) ) {
+		sieve_binary_unref(&sbin);
+		sbin = NULL;
+	}
+
+	if ( sbin != NULL ) {
+		sieve_tool_dump_binary_to(sbin, outfile == NULL ? "-" : outfile);
+	
+		sieve_binary_unref(&sbin);
+	} else 
+		i_error("failed to load binary: %s", binfile);
+	
+	sieve_tool_deinit();
+}
+
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sieve-filter.c dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sieve-filter.c
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sieve-filter.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sieve-filter.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,282 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "array.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+#include "mail-search-build.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-extensions.h"
+#include "sieve-binary.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieve-filter [-m <mailbox>] [-x <extensions>]\n"
+"                    [-s <script-file>] [-c]\n"
+"                    <script-file> <mail-store>\n"
+	);
+}
+
+static int filter_message
+(struct mail *mail, struct sieve_binary *main_sbin, 
+	struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	const char *user)
+{
+	struct sieve_binary *sbin;
+	struct sieve_message_data msgdata;
+	const char *recipient, *sender;
+
+	sieve_tool_get_envelope_data(mail, &recipient, &sender);
+
+	/* Collect necessary message data */
+	memset(&msgdata, 0, sizeof(msgdata));
+	msgdata.mail = mail;
+	msgdata.return_path = sender;
+	msgdata.to_address = recipient;
+	msgdata.auth_user = user;
+	(void)mail_get_first_header(mail, "Message-ID", &msgdata.id);
+
+	/* Single script */
+	sbin = main_sbin;
+	main_sbin = NULL;
+
+	/* Execute script */
+	return sieve_execute(sbin, &msgdata, senv, ehandler);
+}
+
+static int filter_mailbox
+(struct mailbox *box, struct sieve_binary *main_sbin, 
+	struct sieve_script_env *senv, struct sieve_error_handler *ehandler,
+	const char *user)
+{
+	struct mail_search_args *search_args;
+	struct mailbox_transaction_context *t;
+	struct mail_search_context *search_ctx;
+	struct mail *mail;
+	int ret = 1;
+
+	search_args = mail_search_build_init();
+	mail_search_build_add_all(search_args);
+
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FAST, 0, NULL) < 0 ) {
+		i_fatal("sync failed");
+	}
+		
+	t = mailbox_transaction_begin(box, 0);
+	search_ctx = mailbox_search_init(t, search_args, NULL);
+	mail_search_args_unref(&search_args);
+
+	mail = mail_alloc(t, 0, NULL);
+	while ( ret > 0 && mailbox_search_next(search_ctx, mail) > 0 ) {
+		const char *subject, *date;
+		uoff_t size = 0;
+		
+		if ( mail->expunged )
+			continue;
+			
+		if ( mail_get_virtual_size(mail, &size) < 0 )
+			i_fatal("failed to get size");
+		
+		(void)mail_get_first_header(mail, "date", &date);
+		(void)mail_get_first_header(mail, "subject", &subject);
+		
+		printf("MAIL: [%s; %"PRIuUOFF_T" bytes] %s\n", date, size, subject);
+	
+		ret = filter_message(mail, main_sbin, senv, ehandler, user);
+	}
+	mail_free(&mail);
+	
+	if ( mailbox_search_deinit(&search_ctx) < 0 ) {
+		i_error("failed to deinit search");
+	}
+
+	if ( mailbox_transaction_commit(&t) < 0 ) {
+		i_fatal("failed to commit transaction");
+	}
+	
+	if ( mailbox_sync(box, MAILBOX_SYNC_FLAG_FAST, 0, NULL) < 0 ) {
+		i_fatal("sync failed");
+	}
+	
+	return FALSE;
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) 
+{
+	const char *scriptfile, *recipient, *sender, *mailbox, *mailstore, 
+		*extensions;
+	bool force_compile;
+	struct mail_namespace *ns = NULL;
+	struct mail_user *mail_user = NULL;
+	struct sieve_binary *main_sbin;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	struct sieve_error_handler *ehandler;
+	struct mail_storage *storage;
+	struct mailbox *box;
+	enum mail_error error;
+	enum mailbox_open_flags open_flags = 
+		MAILBOX_OPEN_KEEP_RECENT | MAILBOX_OPEN_IGNORE_ACLS;
+	const char *user, *home;
+	int i;
+
+	sieve_tool_init();
+	
+	/* Parse arguments */
+	scriptfile = recipient = sender = mailstore = extensions = NULL;
+	mailbox = "INBOX";
+	force_compile = FALSE;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-m") == 0) {
+			/* default mailbox (keep box) */
+			i++;
+			if (i == argc) 
+				i_fatal("Missing -m argument");
+			mailbox = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc)
+				i_fatal("Missing -x argument");
+			extensions = argv[i];
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* force compile */
+			force_compile = TRUE;
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( mailstore == NULL ) {
+			mailstore = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <scriptfile> argument");
+	}
+	
+	if ( mailstore == NULL ) {
+		print_help();
+		i_fatal("Missing <mailstore> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+
+	/* Create error handler */
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_system_ehandler_set(ehandler);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	/* Compile main sieve script */
+	if ( force_compile ) {
+		main_sbin = sieve_tool_script_compile(scriptfile, NULL);
+		(void) sieve_save(main_sbin, NULL);
+	} else {
+		main_sbin = sieve_tool_script_open(scriptfile);
+	}
+	
+	user = sieve_tool_get_user();
+	home = getenv("HOME");
+
+	/* Initialize mail storages */
+	mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+	mail_storage_init();
+	mail_storage_register_all();
+	mailbox_list_register_all();
+
+	/* Obtain mail namespaces from -l argument */
+	if ( mailstore != NULL ) {
+		env_put(t_strdup_printf("NAMESPACE_1=%s", mailstore));
+		env_put("NAMESPACE_1_INBOX=1");
+		env_put("NAMESPACE_1_LIST=1");
+		env_put("NAMESPACE_1_SEP=.");
+		env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+		mail_user = mail_user_init(user);
+		mail_user_set_home(mail_user, home);
+		if (mail_namespaces_init(mail_user) < 0)
+			i_fatal("Namespace initialization failed");	
+
+		ns = mail_user->namespaces;
+	}
+
+	storage = ns->storage;
+
+	/* Open the mailbox */	
+	box = mailbox_open(&storage, mailbox, NULL, open_flags);
+	if ( box == NULL ) {
+		i_fatal("Couldn't open mailbox '%s': %s", 
+			mailbox, mail_storage_get_last_error(storage, &error));
+	}
+
+	if ( mailbox == NULL )
+		mailbox = "INBOX";
+
+	/* Compose script environment */
+	memset(&scriptenv, 0, sizeof(scriptenv));
+	scriptenv.default_mailbox = "INBOX";
+	scriptenv.namespaces = ns;
+	scriptenv.username = user;
+	scriptenv.hostname = "host.example.com";
+	scriptenv.postmaster_address = "postmaster@example.com";
+	scriptenv.smtp_open = NULL;
+	scriptenv.smtp_close = NULL;
+	scriptenv.duplicate_mark = NULL;
+	scriptenv.duplicate_check = NULL;
+	scriptenv.trace_stream = NULL;
+	scriptenv.exec_status = &estatus;
+
+	/* Apply Sieve filter to all messages found */
+	filter_mailbox(box, main_sbin, &scriptenv, ehandler, user);
+	
+	/* Close the mailbox */
+	if ( box != NULL )
+		mailbox_close(&box);
+
+	/* Cleanup error handler */
+	sieve_error_handler_unref(&ehandler);
+	sieve_system_ehandler_reset();	
+
+	/* De-initialize mail user object */
+	if ( mail_user != NULL )
+		mail_user_unref(&mail_user);
+
+	/* De-initialize mail storages */
+	mail_storage_deinit();
+	mail_users_deinit();	
+	
+	sieve_tool_deinit();
+	
+	return 0;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sieve-test.c dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sieve-test.c
--- dovecot-1.2.0/dovecot-libsieve/src/sieve-tools/sieve-test.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/src/sieve-tools/sieve-test.c	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,416 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ostream.h"
+#include "array.h"
+#include "mail-namespace.h"
+#include "mail-storage.h"
+#include "env-util.h"
+
+#include "sieve.h"
+#include "sieve-binary.h"
+#include "sieve-extensions.h"
+
+#include "mail-raw.h"
+#include "sieve-tool.h"
+
+#include "sieve-ext-debug.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+
+/* 
+ * Configuration
+ */
+
+#define DEFAULT_SENDMAIL_PATH "/usr/lib/sendmail"
+#define DEFAULT_ENVELOPE_SENDER "MAILER-DAEMON"
+
+/*
+ * Print help
+ */
+
+static void print_help(void)
+{
+	printf(
+"Usage: sieve-test [-c] [-d <dump-filename>] [-e] [-f <envelope-sender>]\n"
+"                  [-l <mail-location>] [-m <default-mailbox>]\n" 
+"                  [-r <recipient-address>] [-s <script-file>]\n"
+"                  [-t] [-x <extensions>] <script-file> <mail-file>\n"
+	);
+}
+
+/*
+ * Dummy SMTP session
+ */
+
+static void *sieve_smtp_open(const char *destination,
+	const char *return_path, FILE **file_r)
+{
+	i_info("sending message from <%s> to <%s>:",
+		return_path == NULL || *return_path == '\0' ? "" : return_path, 
+		destination);
+	printf("\nSTART MESSAGE:\n");
+	
+	*file_r = stdout;
+	
+	return NULL;	
+}
+
+static bool sieve_smtp_close(void *handle ATTR_UNUSED)
+{
+	printf("END MESSAGE\n\n");
+	return TRUE;
+}
+
+/*
+ * Dummy duplicate check implementation
+ */
+
+static int duplicate_check(const void *id ATTR_UNUSED, size_t id_size ATTR_UNUSED, 
+	const char *user)
+{
+	i_info("checked duplicate for user %s.\n", user);
+	return 0;
+}
+
+static void duplicate_mark
+(const void *id ATTR_UNUSED, size_t id_size ATTR_UNUSED, const char *user, 
+	time_t time ATTR_UNUSED)
+{
+	i_info("marked duplicate for user %s.\n", user);
+}
+
+/*
+ * Tool implementation
+ */
+
+int main(int argc, char **argv) 
+{
+	ARRAY_DEFINE(scriptfiles, const char *);
+	const char *scriptfile, *recipient, *sender, *mailbox, *dumpfile, *mailfile, 
+		*mailloc, *extensions; 
+	const char *user, *home;
+	int i;
+	struct mail_raw *mailr;
+	struct mail_namespace *ns = NULL;
+	struct mail_user *mail_user = NULL;
+	struct sieve_binary *main_sbin, *sbin = NULL;
+	struct sieve_message_data msgdata;
+	struct sieve_script_env scriptenv;
+	struct sieve_exec_status estatus;
+	struct sieve_error_handler *ehandler;
+	struct ostream *teststream = NULL;
+	bool force_compile = FALSE, execute = FALSE;
+	bool trace = FALSE;
+	int ret;
+
+	sieve_tool_init();
+	
+	t_array_init(&scriptfiles, 16);
+
+	/* Parse arguments (ugly) */
+	scriptfile = recipient = sender = mailbox = dumpfile = mailfile = mailloc = 
+		extensions = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-r") == 0) {
+			/* recipient address */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -r argument");
+			}
+			recipient = argv[i];
+		} else if (strcmp(argv[i], "-f") == 0) {
+			/* envelope sender */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -f argument");
+			}
+			sender = argv[i];
+		} else if (strcmp(argv[i], "-m") == 0) {
+			/* default mailbox (keep box) */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -m argument");
+			}
+			mailbox = argv[i];
+		} else if (strcmp(argv[i], "-d") == 0) {
+			/* dump file */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -d argument");
+			}
+			dumpfile = argv[i];
+		} else if (strcmp(argv[i], "-l") == 0) {
+			/* mail location */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -l argument");
+			}
+			mailloc = argv[i];
+		} else if (strcmp(argv[i], "-x") == 0) {
+			/* extensions */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -x argument");
+			}
+			extensions = argv[i];
+		} else if (strcmp(argv[i], "-s") == 0) {
+			const char *file;
+			
+			/* scriptfile executed before main script */
+			i++;
+			if (i == argc) {
+				print_help();
+				i_fatal("Missing -s argument");
+			}
+				
+			file = t_strdup(argv[i]);
+			array_append(&scriptfiles, &file, 1);
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* force compile */
+			force_compile = TRUE;
+		} else if (strcmp(argv[i], "-e") == 0) {
+			/* execute */
+			execute = TRUE;
+#ifdef SIEVE_RUNTIME_TRACE
+		} else if (strcmp(argv[i], "-t") == 0) {
+			/* runtime trace */
+			trace = TRUE;
+#endif
+		} else if ( scriptfile == NULL ) {
+			scriptfile = argv[i];
+		} else if ( mailfile == NULL ) {
+			mailfile = argv[i];
+		} else {
+			print_help();
+			i_fatal("Unknown argument: %s", argv[i]);
+		}
+	}
+	
+	if ( scriptfile == NULL ) {
+		print_help();
+		i_fatal("Missing <script-file> argument");
+	}
+	
+	if ( mailfile == NULL ) {
+		print_help();
+		i_fatal("Missing <mail-file> argument");
+	}
+
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Register tool-specific extensions */
+	(void) sieve_extension_register(&debug_extension, TRUE);
+	
+	/* Create error handler */
+	ehandler = sieve_stderr_ehandler_create(0);
+	sieve_system_ehandler_set(ehandler);
+	sieve_error_handler_accept_infolog(ehandler, TRUE);
+
+	/* Compile main sieve script */
+	if ( force_compile ) {
+		main_sbin = sieve_tool_script_compile(scriptfile, NULL);
+		(void) sieve_save(main_sbin, NULL);
+	} else {
+		main_sbin = sieve_tool_script_open(scriptfile);
+	}
+
+	if ( main_sbin != NULL ) {
+		/* Dump script */
+		sieve_tool_dump_binary_to(main_sbin, dumpfile);
+	
+		user = sieve_tool_get_user();
+		home = getenv("HOME");
+
+		/* Initialize mail storages */
+		mail_users_init(getenv("AUTH_SOCKET_PATH"), getenv("DEBUG") != NULL);
+		mail_storage_init();
+		mail_storage_register_all();
+		mailbox_list_register_all();
+	
+		/* Obtain mail namespaces from -l argument */
+		if ( mailloc != NULL ) {
+			env_put(t_strdup_printf("NAMESPACE_1=%s", mailloc));
+			env_put("NAMESPACE_1_INBOX=1");
+			env_put("NAMESPACE_1_LIST=1");
+			env_put("NAMESPACE_1_SEP=.");
+			env_put("NAMESPACE_1_SUBSCRIPTIONS=1");
+
+			mail_user = mail_user_init(user);
+			mail_user_set_home(mail_user, home);
+			if (mail_namespaces_init(mail_user) < 0)
+				i_fatal("Namespace initialization failed");	
+
+			ns = mail_user->namespaces;
+		}
+
+		/* Initialize raw mail object */
+		mail_raw_init(user);
+		mailr = mail_raw_open_file(mailfile);
+
+		sieve_tool_get_envelope_data(mailr->mail, &recipient, &sender);
+
+		if ( mailbox == NULL )
+			mailbox = "INBOX";
+
+		/* Collect necessary message data */
+		memset(&msgdata, 0, sizeof(msgdata));
+		msgdata.mail = mailr->mail;
+		msgdata.return_path = sender;
+		msgdata.to_address = recipient;
+		msgdata.auth_user = user;
+		(void)mail_get_first_header(mailr->mail, "Message-ID", &msgdata.id);
+
+		/* Create stream for test and trace output */
+		if ( !execute || trace )
+			teststream = o_stream_create_fd(1, 0, FALSE);	
+		
+		/* Compose script environment */
+		memset(&scriptenv, 0, sizeof(scriptenv));
+		scriptenv.default_mailbox = "INBOX";
+		scriptenv.namespaces = ns;
+		scriptenv.username = user;
+		scriptenv.hostname = "host.example.com";
+		scriptenv.postmaster_address = "postmaster@example.com";
+		scriptenv.smtp_open = sieve_smtp_open;
+		scriptenv.smtp_close = sieve_smtp_close;
+		scriptenv.duplicate_mark = duplicate_mark;
+		scriptenv.duplicate_check = duplicate_check;
+		scriptenv.trace_stream = ( trace ? teststream : NULL );
+		scriptenv.exec_status = &estatus;
+	
+		/* Run the test */
+		ret = 1;
+		if ( array_count(&scriptfiles) == 0 ) {
+			/* Single script */
+			sbin = main_sbin;
+			main_sbin = NULL;
+	
+			/* Execute/Test script */
+			if ( execute )
+				ret = sieve_execute(sbin, &msgdata, &scriptenv, ehandler);
+			else
+				ret = sieve_test(sbin, &msgdata, &scriptenv, ehandler, teststream);				
+		} else {
+			/* Multiple scripts */
+			const char *const *sfiles;
+			unsigned int i, count;
+			struct sieve_multiscript *mscript;
+			bool more = TRUE;
+			int result;
+
+			if ( execute )
+				mscript = sieve_multiscript_start_execute
+					(&msgdata, &scriptenv);
+			else
+				mscript = sieve_multiscript_start_test
+					(&msgdata, &scriptenv, teststream);
+		
+			/* Execute scripts sequentially */
+			sfiles = array_get(&scriptfiles, &count); 
+			for ( i = 0; i < count && more; i++ ) {
+				if ( teststream != NULL ) 
+					o_stream_send_str(teststream, 
+						t_strdup_printf("\n## Executing script: %s\n", sfiles[i]));
+			
+				/* Close previous script */
+				if ( sbin != NULL )						
+					sieve_close(&sbin);
+		
+				/* Compile sieve script */
+				if ( force_compile ) {
+					sbin = sieve_tool_script_compile(sfiles[i], sfiles[i]);
+					(void) sieve_save(sbin, NULL);
+				} else {
+					sbin = sieve_tool_script_open(sfiles[i]);
+				}
+			
+				if ( sbin == NULL ) {
+					ret = SIEVE_EXEC_FAILURE;
+					break;
+				}
+			
+				/* Execute/Test script */
+				more = sieve_multiscript_run(mscript, sbin, ehandler, FALSE);
+			}
+		
+			/* Execute/Test main script */
+			if ( more && ret > 0 ) {
+				if ( teststream != NULL ) 
+					o_stream_send_str(teststream, 
+						t_strdup_printf("## Executing script: %s\n", scriptfile));
+				
+				/* Close previous script */
+				if ( sbin != NULL )						
+					sieve_close(&sbin);	
+				
+				sbin = main_sbin;
+				main_sbin = NULL;
+			
+				sieve_multiscript_run(mscript, sbin, ehandler, TRUE);
+			}
+			
+			result = sieve_multiscript_finish(&mscript, ehandler);
+			
+			ret = ret > 0 ? result : ret;
+		}
+	
+		/* Run */
+		switch ( ret ) {
+		case SIEVE_EXEC_OK:
+			i_info("final result: success");
+			break;
+		case SIEVE_EXEC_BIN_CORRUPT:
+			i_info("corrupt binary deleted.");
+			(void) unlink(sieve_binary_path(sbin));
+		case SIEVE_EXEC_FAILURE:
+			i_info("final result: failed; resolved with successful implicit keep");
+			break;
+		case SIEVE_EXEC_KEEP_FAILED:
+			i_info("final result: utter failure");
+			break;
+		default:
+			i_info("final result: unrecognized return value?!");	
+		}
+
+		if ( teststream != NULL )
+			o_stream_destroy(&teststream);
+
+		/* Cleanup remaining binaries */
+		sieve_close(&sbin);
+		if ( main_sbin != NULL ) sieve_close(&main_sbin);
+		
+		/* De-initialize raw mail object */
+		mail_raw_close(mailr);
+		mail_raw_deinit();
+
+		/* De-initialize mail user object */
+		if ( mail_user != NULL )
+			mail_user_unref(&mail_user);
+
+		/* De-initialize mail storages */
+		mail_storage_deinit();
+		mail_users_deinit();
+	}
+
+	/* Cleanup error handler */
+	sieve_error_handler_unref(&ehandler);
+	sieve_system_ehandler_reset();
+
+	sieve_tool_deinit();
+	
+	return 0;
+}
diff -urN dovecot-1.2.0/dovecot-libsieve/stamp.h.in dovecot-1.2.0-sieve/dovecot-libsieve/stamp.h.in
--- dovecot-1.2.0/dovecot-libsieve/stamp.h.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/stamp.h.in	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,2 @@
+
+
diff -urN dovecot-1.2.0/dovecot-libsieve/TODO dovecot-1.2.0-sieve/dovecot-libsieve/TODO
--- dovecot-1.2.0/dovecot-libsieve/TODO	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-sieve/dovecot-libsieve/TODO	2009-07-05 19:09:57.000000000 +0000
@@ -0,0 +1,94 @@
+Current:
+
+* Build a sieve tool to filter an entire existing mailbox through a Sieve 
+  script.
+
+Next (in order of descending priority/precedence):
+
+* Improve error handling. Now it is not very consistent, especially for the Sieve
+  command line tools. 
+* Detect permission errors when writing global script binaries and advise the 
+  administrator on using sievec to precompile the scripts. 
+* Improve debugging support in the sieve-test tool:
+	- Improve trace debugging towards something more intuitively readable.
+	- Give trace debugging multiple levels of verbosity (e.g. to include more messy
+	  output like value matching).
+* Implement dropping errors in the user's mailbox as a mail message.
+* Implement a better way to encode source line numbers into a binary for reporting 
+  errors at runtime. Currently, this is done explicitly for each command that adds 
+  actions to the result. However, some tests, match types etc. will also need this 
+  when the variables extension is active. Many of the RFC deviations listed below 
+  depend on this. Also trace debugging will benefit.
+* Fix remaining RFC deviations:
+	- Fix issues listed in doc/rfc/RFC-questions.txt based on answers
+	- Allow for the existance of dynamic comparators (i.e. specified by 
+	  variables). 
+	- Allow for :regex matching with variable key.
+	- Detect assignment of too large constant values to variables at compile
+	  time.
+	- Verify outgoing mail addresses at runtime when necessary
+	  (e.g. after variables substitution)
+	- Vacation: the ":subject" parameter specifies a subject line to attach to 
+	  any vacation response that is generated. UTF-8 characters can be used in
+	  the string argument; implementations MUST convert the string to [RFC2047]
+ 	  encoded words if and only if non-ASCII characters are present.
+	- Body: contains various issues that need to be resolved for standards
+	  compliance. Body test support currently matches but barely exceeds the
+	  original CMU Sieve implentation in terms of standards compliance.
+	- Improve handling of invalid addresses in headers (requires Dovecot changes)
+* Implement namespace support for variables extension (to complete include 
+  extension)
+* Add normalize() method to comparators to normalize the string before matching
+  (for efficiency).
+* Implement mechanism for implicitly including an account's aliases in the vacation
+  command's :addresses list.
+* Properly implement Sieve internationalization support (utf-8 handling), currently
+  it is not complete:
+	- Make this implementation conform section 2.7.2 of RFC5228 (Comparisons 
+	  Across Character Sets). 
+	- Verify validity of utf8 where necessary.
+	- Implement comparator-i;unicode-casemap.
+* Make testsuite much more exhaustive:
+	- add support for testing delivered messages by looping these back as the 
+	  tested mail message
+	- add support for testing the content of result actions
+	- test as many error/warning/info conditions as possible. 
+	- review the specification documents and check whether the given conditions
+	  are tested at least once.
+* Code cleanup:
+	- Make address handling more uniform. 
+
+* Build a server with test mail accounts that processes lots and lots of mail 
+  (e.g. spam, mailing lists etc.)
+
+* ## MAKE A SECOND RELEASE (0.2.x) ##
+
+* Provide a solution for mail_get_headers_utf8 reparsing the whole message each
+  time it is called (header and address test; Timo might provide solution from
+  within Dovecot)
+* Implement date and index extensions
+* Optimize code containing true/false tests to omit explicit JMP opcodes
+  (i.e. optimize the test away and any code that negatively depends on it)
+* Use lib/str-find.h for :contains and :matches match types 
+* Warn during compile if using non-existent folders.
+
+* Implement IMAP plugin for IMAPSieve support:
+	- This may include support for manually running a script on a set of messages
+	  through IMAP (no specification for something like this is available; we will 
+	  have to provide our own)
+* Implement editheader extension
+* Implement mimeloop extension
+* Variables extension: implement compile time evaluation of constant values
+* Enotify extension: detect use of variable values extracted from the message 
+  that are used in the method argument. RFC reports this as a security issue.
+* Import ManageSieve into this package and provide support for alternate types
+  of script storage like LDAP or SQL database.
+* Make the engine and its extensions much more configurable. Possibly this can 
+  be merged with Dovecot's new master config implementation.
+* Add development documentation, i.e. comment on library functions and document
+  the binary and byte-code format. 
+* Give the byte code format some more thought, it is currently quite rough and
+  to the point. 
+* Try to implement proposed notify mechanisms other than mailto. Currently: xmpp
+  and sip
+
