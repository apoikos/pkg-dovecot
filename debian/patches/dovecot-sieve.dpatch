#! /bin/sh -e
## DP: Include SIEVE support in dovecot LDA
## DP: Author: Timo Sirainen
## DP: Version: 1.1.5

. $(dirname $0)/DPATCH
exit 0
@DPATCH@
diff -urN dovecot-1.1.1/dovecot-sieve/AUTHORS dovecot-1.1.1-sieve/dovecot-sieve/AUTHORS
--- dovecot-1.1.1/dovecot-sieve/AUTHORS	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/AUTHORS	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,2 @@
+Timo Sirainen <tss@iki.fi>
+CMU Sieve people, see src/libsieve/AUTHORS
diff -urN dovecot-1.1.1/dovecot-sieve/ChangeLog dovecot-1.1.1-sieve/dovecot-sieve/ChangeLog
--- dovecot-1.1.1/dovecot-sieve/ChangeLog	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/ChangeLog	2008-05-16 07:25:46.000000000 -0600
@@ -0,0 +1,375 @@
+2008-05-16  Timo Sirainen  <tss@iki.fi>
+
+	* .hgtags:
+	Added tag 1.1.5 for changeset 5ebdbdd084f4
+	[bfed165c4db2] [tip]
+
+	* configure.in:
+	Released v1.1.5.
+	[5ebdbdd084f4] [1.1.5]
+
+	* src/sieve-cmu.c:
+	If sieve path is a directory instead of a file, give a clear error
+	message instead of "input in flex scanner failed".
+	[25b786f5b3c0]
+
+2008-04-25  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Unfold multiline headers before comparing them.
+	[486736da7e4c]
+
+2008-04-18  Timo Sirainen  <tss@iki.fi>
+
+	* src/cmusieve-plugin.c:
+	If mail_debug is enabled, log also if the script isn't found.
+	[af18c7215bde]
+
+2008-04-01  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	If compiled script has the exact same mtime as the source, assume
+	the script hasn't changed.
+	[841220f564e4]
+
+2008-02-25  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Fixed error message. Patch by Anders.
+	[a9e43a2cb235]
+
+	* src/cmusieve-plugin.c:
+	Expand ~ to home in sieve path.
+	[e0a053a4ca84]
+
+2008-02-16  Timo Sirainen  <tss@iki.fi>
+
+	* configure.in:
+	Released v1.1.4.
+	[dff41cab0623]
+
+	* src/sieve-cmu.c:
+	Fixed to compile with changed message_parser_deinit() API.
+	[ef20d7a75cd2]
+
+2008-01-01  Timo Sirainen  <tss@iki.fi>
+
+	* configure.in:
+	Released v1.1.3.
+	[62f96e333d61]
+
+	* src/sieve-cmu.c:
+	Adding keywords crashed. Also fixed a memory leak.
+	[281aade4b591]
+
+2007-09-30  Timo Sirainen  <tss@iki.fi>
+
+	* .hgtags:
+	Added tag 1.1.2 for changeset 8dbe745fa69d
+	[2027b51f4332]
+
+	* configure.in:
+	Released v1.1.2.
+	[8dbe745fa69d] [1.1.2]
+
+	* src/sieve-cmu.c:
+	If script is compiled successfully, unlink .err file.
+	[48c4f168da70]
+
+	* src/cmusieve-plugin.c, src/cmusieve-plugin.h, src/sieve-cmu.c:
+	Deliver API now passes destination address instead of username.
+	Separate these so that getenvelope("to") returns the address and
+	getenvelope("auth") returns the username.
+	[485f4449e3ae]
+
+	* .hgtags:
+	Added tag 1.1.1 for changeset ae26edc369f1
+	[1bb37e36a468]
+
+	* configure.in:
+	Released v1.1.1.
+	[ae26edc369f1] [1.1.1]
+
+	* src/sieve-cmu.c:
+	getheader() didn't return SIEVE_FAIL if no headers were found.
+	[ea1942bc565b]
+
+2007-09-23  Timo Sirainen  <tss@iki.fi>
+
+	* .hgtags:
+	Added tag 1.1.0 for changeset 127e423b7df4
+	[fe11e5bfbd7c]
+
+	* configure.in:
+	Released v1.1.0.
+	[127e423b7df4] [1.1.0]
+
+2007-09-16  Timo Sirainen  <tss@iki.fi>
+
+	* src/libsieve/comparator.c, src/libsieve/message.c,
+	src/libsieve/sievec.c, src/map.c, src/sieve-cmu.c, src/xmalloc.h:
+	Use the updated APIs
+	[57c65bac08b3]
+
+2007-09-09  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Informational logging of vacation response outcome. Based on patch
+	by <pod@sysdev.oucs.ox.ac.uk>
+	[0eb93cd3b462]
+
+2007-08-15  Timo Sirainen  <tss@iki.fi>
+
+	* src/cmusieve-plugin.c:
+	Better error message for "per-user script location not set."
+	[39e2131dc592]
+
+2007-08-13  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Fixed to compile with new API
+	[0367450c9382]
+
+2007-08-09  Timo Sirainen  <tss@iki.fi>
+
+	* src/libsieve/sieve.y:
+	Code cleanup
+	[8f6830cf7b75]
+
+	* src/libsieve/bc_eval.c:
+	Minor fix
+	[0d7f8f2dd9c4]
+
+2007-07-20  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Lookup headers using mail_get_headers_utf8() so non-ASCII headers
+	can be compared.
+	[131e25f6862b]
+
+	* src/cmusieve-plugin.c, src/sieve-cmu.c:
+	global_script_path -> sieve_global_path global_script_dir ->
+	sieve_global_dir Also added sieve_dir setting which overrides home
+	directory.
+	[fae7f0d39827]
+
+	* src/sieve-cmu.c:
+	Use sieve_dir instead of home if it exists for finding personal
+	scripts.
+	[3d36c3f1f755]
+
+	* src/sieve-cmu.c:
+	Added support for include extension.
+	[48178539087b]
+
+	* src/sieve-cmu.c:
+	We weren't supposed to log first error immediately.
+	[978a6225ecd7]
+
+	* src/sieve-cmu.c:
+	Another memory leak fix for body.
+	[7fbc683f2587]
+
+	* src/sieve-cmu.c:
+	Memory leak fix with body extension.
+	[c75b2da3fd3b]
+
+	* src/cmusieve-plugin.c, src/cmusieve-plugin.h,
+	src/libsieve/Makefile.am, src/libsieve/bc_dump.c,
+	src/libsieve/bc_emit.c, src/libsieve/bc_eval.c,
+	src/libsieve/bc_generate.c, src/libsieve/bytecode.h,
+	src/libsieve/comparator.c, src/libsieve/comparator.h,
+	src/libsieve/interp.c, src/libsieve/interp.h,
+	src/libsieve/message.c, src/libsieve/message.h,
+	src/libsieve/script.c, src/libsieve/script.h, src/libsieve/sieve-
+	lex.l, src/libsieve/sieve.y, src/libsieve/sieve_err.c,
+	src/libsieve/sieve_err.h, src/libsieve/sieve_interface.h,
+	src/libsieve/sievec.c, src/libsieve/sieved.c, src/libsieve/tree.c,
+	src/libsieve/tree.h, src/sieve-cmu.c:
+	Upgraded to Cyrus Sieve v2.3 and changed code to compile against
+	Dovecot v1.1. Sieve body extension works now, but include doesn't
+	yet.
+	[09f894d3cc84]
+
+2007-07-13  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Added support for mailto notify. Patch by Uldis Pakuls.
+	[0ddc99d4b747]
+
+	* src/sieve-cmu.c:
+	If sieve_execute_bytecode() fails, log an error.
+	[f8f207198d09]
+
+2007-06-19  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Log a bit more if debug is enabled.
+	[64a7986b5e55]
+
+2007-06-16  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Vacation crashfix: If there's no return path (or it's broken),
+	getenvelope() returns SIEVE_FAIL now.
+	[c41e5970e2dc]
+
+2007-05-19  Timo Sirainen  <tss@iki.fi>
+
+	* .cvsignore, src/.cvsignore, src/libsieve/.cvsignore:
+	We no longer need .cvsignore files
+	[8ac0d2217a46]
+
+	* .hgignore, Makefile.am, autogen.sh:
+	Mercurify the repository
+	[2cbb35f2443f]
+
+2007-05-19  convert-repo  <convert-repo>
+
+	* .hgtags:
+	update tags
+	[eb09390f96fa]
+
+2007-02-22  Timo Sirainen  <tss@iki.fi>
+
+	* configure.in, src/Makefile.am, src/libsieve/Makefile.am:
+	Support compiling against installed dovecot-config and headers. This
+	way sievec and sieved aren't compiled though because liblib.a
+	doesn't exist.
+	[ea5fc9277fbd]
+
+2007-02-16  Timo Sirainen  <tss@iki.fi>
+
+	* src/map.c:
+	Don't crash if the .sievec file is zero bytes.
+	[4b1a6ae4e7fb]
+
+2007-01-18  Timo Sirainen  <tss@iki.fi>
+
+	* configure.in:
+	We never include dsieve-config.h, so regexp defines didn't work in
+	there. Added them to CFLAGS at least for now.
+
+	Relased 1.0.1
+	[8b6df1256798]
+
+2006-11-05  Timo Sirainen  <tss@iki.fi>
+
+	* .cvsignore, INSTALL, NEWS, README, configure.in,
+	src/libsieve/.cvsignore:
+	Doing an actual v1.0 release.
+	[ca81eb8c2d16]
+
+2006-10-16  Timo Sirainen  <tss@iki.fi>
+
+	* src/xmalloc.h:
+	Include sys/types.h. Fixes compile problems with some systems.
+	[52cb8af83763]
+
+2006-10-13  Timo Sirainen  <tss@iki.fi>
+
+	* src/cmusieve-plugin.c:
+	If debug is enabled, log the sieve path. Also log an error if home
+	dir isn't given and no specific sieve script path is given.
+	[42e40d6258d3]
+
+	* src/deliver.c:
+	Not needed anymore
+	[b03918f5884c]
+
+2006-10-10  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	More __attribute__((unused)) -> __attr_unused__
+	[68b8b5faf129]
+
+	* src/libsieve/comparator.c, src/libsieve/message.c,
+	src/libsieve/sievec.c:
+	__attribute__((unused)) -> __attr_unused__ so it now compiles with
+	non-gcc
+	[018ca3d92aa4]
+
+2006-10-08  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Unified logging formats. Everything beings now with msgid=<id>.
+	[b730321798a1]
+
+2006-09-01  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	Log message ID when saving mails
+	[8a0a93971e2d]
+
+2006-07-01  Timo Sirainen  <tss@iki.fi>
+
+	* src/libsieve/Makefile.am, src/libsieve/bc_eval.c,
+	src/libsieve/bytecode.h, src/libsieve/sieved.c:
+	Build sieve decompiler (sieved) also.
+	[5c779d4ba6b2]
+
+2006-06-17  Timo Sirainen  <tss@iki.fi>
+
+	* src/Makefile.am, src/libsieve/Makefile.am:
+	Build libsieve as a shared library so it can be portably linked with
+	the plugin.
+	[4e1cd37102db]
+
+2006-06-12  Timo Sirainen  <tss@iki.fi>
+
+	* src/sieve-cmu.c:
+	"saved mail to" logging printed always INBOX
+	[7f4e1c2fbffb]
+
+2006-06-11  Timo Sirainen  <tss@iki.fi>
+
+	* src/libsieve/sieve.y:
+	Unsupported feature -> Unsupported features in require line
+	[f503bc3fb371]
+
+	* .cvsignore, AUTHORS, COPYING.LGPL, Makefile.am, NEWS, README,
+	autogen.sh, configure.in, src/.cvsignore, src/Makefile.am, src
+	/cmusieve-plugin.c, src/cmusieve-plugin.h, src/deliver.c,
+	src/imparse.c, src/imparse.h, src/libconfig.h,
+	src/libsieve/.cvsignore, src/libsieve/AUTHORS, src/libsieve/COPYING,
+	src/libsieve/ChangeLog, src/libsieve/Makefile.am, src/libsieve/NEWS,
+	src/libsieve/README, src/libsieve/addr-lex.l, src/libsieve/addr.y,
+	src/libsieve/bc_dump.c, src/libsieve/bc_emit.c,
+	src/libsieve/bc_eval.c, src/libsieve/bc_generate.c,
+	src/libsieve/bytecode.h, src/libsieve/comparator.c,
+	src/libsieve/comparator.h, src/libsieve/interp.c,
+	src/libsieve/interp.h, src/libsieve/message.c,
+	src/libsieve/message.h, src/libsieve/parseaddr.c,
+	src/libsieve/parseaddr.h, src/libsieve/script.c,
+	src/libsieve/script.h, src/libsieve/sieve-lex.l,
+	src/libsieve/sieve.y, src/libsieve/sieve_err.c,
+	src/libsieve/sieve_err.et, src/libsieve/sieve_err.h,
+	src/libsieve/sieve_interface.h, src/libsieve/sievec.c,
+	src/libsieve/sieved.c, src/libsieve/tree.c, src/libsieve/tree.h,
+	src/map.c, src/map.h, src/sieve-cmu.c, src/xmalloc.h, stamp.h.in:
+	Initial import of dovecot-lda's Sieve code to a deliver plugin.
+	[c8819160e67c] [r_1_0_0]
+
+	* .cvsignore, AUTHORS, COPYING.LGPL, Makefile.am, NEWS, README,
+	autogen.sh, configure.in, src/.cvsignore, src/Makefile.am, src
+	/cmusieve-plugin.c, src/cmusieve-plugin.h, src/deliver.c,
+	src/imparse.c, src/imparse.h, src/libconfig.h,
+	src/libsieve/.cvsignore, src/libsieve/AUTHORS, src/libsieve/COPYING,
+	src/libsieve/ChangeLog, src/libsieve/Makefile.am, src/libsieve/NEWS,
+	src/libsieve/README, src/libsieve/addr-lex.l, src/libsieve/addr.y,
+	src/libsieve/bc_dump.c, src/libsieve/bc_emit.c,
+	src/libsieve/bc_eval.c, src/libsieve/bc_generate.c,
+	src/libsieve/bytecode.h, src/libsieve/comparator.c,
+	src/libsieve/comparator.h, src/libsieve/interp.c,
+	src/libsieve/interp.h, src/libsieve/message.c,
+	src/libsieve/message.h, src/libsieve/parseaddr.c,
+	src/libsieve/parseaddr.h, src/libsieve/script.c,
+	src/libsieve/script.h, src/libsieve/sieve-lex.l,
+	src/libsieve/sieve.y, src/libsieve/sieve_err.c,
+	src/libsieve/sieve_err.et, src/libsieve/sieve_err.h,
+	src/libsieve/sieve_interface.h, src/libsieve/sievec.c,
+	src/libsieve/sieved.c, src/libsieve/tree.c, src/libsieve/tree.h,
+	src/map.c, src/map.h, src/sieve-cmu.c, src/xmalloc.h, stamp.h.in:
+	Initial revision
+	[7d85833eff96]
+
diff -urN dovecot-1.1.1/dovecot-sieve/configure.in dovecot-1.1.1-sieve/dovecot-sieve/configure.in
--- dovecot-1.1.1/dovecot-sieve/configure.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/configure.in	2008-05-16 07:14:07.000000000 -0600
@@ -0,0 +1,68 @@
+AC_INIT(dovecot-sieve, 1.1.5, [dovecot@dovecot.org])
+AC_CONFIG_SRCDIR([src])
+
+AC_CONFIG_HEADERS([dsieve-config.h])
+AM_INIT_AUTOMAKE
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_LEX
+AC_PROG_YACC
+AM_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[  --with-dovecot[=DIR]    Dovecot base directory (../dovecot)],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+old=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $old
+AC_SUBST(dovecotdir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+dnl * Regexp library check, from Cyrus IMAP
+AC_SEARCH_LIBS(regcomp, rx regex, [
+  CFLAGS="$CFLAGS -DENABLE_REGEX"
+  AC_CHECK_HEADER(rxposix.h, CFLAGS="$CFLAGS -DHAVE_RX")])
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/libsieve/Makefile
+stamp.h])
+
+AC_OUTPUT
diff -urN dovecot-1.1.1/dovecot-sieve/COPYING dovecot-1.1.1-sieve/dovecot-sieve/COPYING
--- dovecot-1.1.1/dovecot-sieve/COPYING	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/COPYING	2007-07-19 19:18:12.000000000 -0600
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urN dovecot-1.1.1/dovecot-sieve/COPYING.LGPL dovecot-1.1.1-sieve/dovecot-sieve/COPYING.LGPL
--- dovecot-1.1.1/dovecot-sieve/COPYING.LGPL	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/COPYING.LGPL	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,510 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -urN dovecot-1.1.1/dovecot-sieve/dsieve-config.h.in dovecot-1.1.1-sieve/dovecot-sieve/dsieve-config.h.in
--- dovecot-1.1.1/dovecot-sieve/dsieve-config.h.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/dsieve-config.h.in	2008-05-16 07:14:17.000000000 -0600
@@ -0,0 +1,59 @@
+/* dsieve-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+#undef YYTEXT_POINTER
diff -urN dovecot-1.1.1/dovecot-sieve/INSTALL dovecot-1.1.1-sieve/dovecot-sieve/INSTALL
--- dovecot-1.1.1/dovecot-sieve/INSTALL	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/INSTALL	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,16 @@
+Compiling
+---------
+
+First of all you'll need to have built Dovecot sources available. It's also
+not a good idea to build the plugin against self-compiled Dovecot sources,
+but then actually use a prebuilt binary package of Dovecot. That might work
+if the Dovecot versions are the same, but it's not guaranteed.
+
+./configure --with-dovecot=../dovecot-1.0
+make
+sudo make install
+
+Configuring
+-----------
+
+See the wiki page: http://wiki.dovecot.org/LDA/Sieve
diff -urN dovecot-1.1.1/dovecot-sieve/Makefile.am dovecot-1.1.1-sieve/dovecot-sieve/Makefile.am
--- dovecot-1.1.1/dovecot-sieve/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/Makefile.am	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,10 @@
+SUBDIRS = src
+
+EXTRA_DIST = \
+	COPYING.LGPL \
+	ChangeLog
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
diff -urN dovecot-1.1.1/dovecot-sieve/NEWS dovecot-1.1.1-sieve/dovecot-sieve/NEWS
--- dovecot-1.1.1/dovecot-sieve/NEWS	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/NEWS	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,3 @@
+v1.0 2006-11-05  Timo Sirainen <tss@iki.fi>
+
+	* The first actual release
diff -urN dovecot-1.1.1/dovecot-sieve/README dovecot-1.1.1-sieve/dovecot-sieve/README
--- dovecot-1.1.1/dovecot-sieve/README	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/README	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,3 @@
+See INSTALL on how to install this plugin.
+
+The libsieve is based on Cyrus v2.2's libsieve.
diff -urN dovecot-1.1.1/dovecot-sieve/src/cmusieve-plugin.c dovecot-1.1.1-sieve/dovecot-sieve/src/cmusieve-plugin.c
--- dovecot-1.1.1/dovecot-sieve/src/cmusieve-plugin.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/cmusieve-plugin.c	2008-04-18 04:32:23.000000000 -0600
@@ -0,0 +1,94 @@
+/* Copyright (C) 2006 Timo Sirainen */
+
+#include "lib.h"
+#include "home-expand.h"
+#include "deliver.h"
+#include "cmusieve-plugin.h"
+
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+static deliver_mail_func_t *next_deliver_mail;
+struct et_list *_et_list = NULL;
+
+static const char *get_sieve_path(void)
+{
+	const char *script_path, *home;
+	struct stat st;
+
+	home = getenv("HOME");
+
+	/* userdb may specify Sieve path */
+	script_path = getenv("SIEVE");
+	if (script_path != NULL) {
+		if (*script_path == '\0') {
+			/* disabled */
+			if (getenv("DEBUG") != NULL)
+				i_info("cmusieve: Empty script path, disabled");
+			return NULL;
+		}
+		script_path = home_expand(script_path);
+
+		if (*script_path != '/' && *script_path != '\0') {
+			/* relative path. change to absolute. */
+			script_path = t_strconcat(getenv("HOME"), "/",
+						  script_path, NULL);
+		}
+	} else {
+		if (home == NULL) {
+			i_error("Per-user script path is unknown. See "
+				"http://wiki.dovecot.org/LDA/Sieve#location");
+			return NULL;
+		}
+
+		script_path = home_expand(SIEVE_SCRIPT_PATH);
+	}
+
+	if (stat(script_path, &st) < 0) {
+		if (errno != ENOENT)
+			i_error("stat(%s) failed: %m", script_path);
+		else if (getenv("DEBUG") != NULL)
+			i_info("cmusieve: %s doesn't exist", script_path);
+
+		/* use global script instead, if one exists */
+		script_path = getenv("SIEVE_GLOBAL_PATH");
+		if (script_path == NULL) {
+			/* for backwards compatibility */
+			script_path = getenv("GLOBAL_SCRIPT_PATH");
+		}
+	}
+
+	return script_path;
+}
+
+static int
+cmusieve_deliver_mail(struct mail_namespace *namespaces,
+		      struct mail_storage **storage_r,
+		      struct mail *mail,
+		      const char *destaddr, const char *mailbox)
+{
+	const char *script_path;
+
+	script_path = get_sieve_path();
+	if (script_path == NULL)
+		return 0;
+
+	if (getenv("DEBUG") != NULL)
+		i_info("cmusieve: Using sieve path: %s", script_path);
+
+	return cmu_sieve_run(namespaces, storage_r, mail, script_path,
+			     destaddr, getenv("USER"), mailbox);
+}
+
+void cmusieve_plugin_init(void)
+{
+	next_deliver_mail = deliver_mail;
+	deliver_mail = cmusieve_deliver_mail;
+}
+
+void cmusieve_plugin_deinit(void)
+{
+	deliver_mail = next_deliver_mail;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/cmusieve-plugin.h dovecot-1.1.1-sieve/dovecot-sieve/src/cmusieve-plugin.h
--- dovecot-1.1.1/dovecot-sieve/src/cmusieve-plugin.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/cmusieve-plugin.h	2007-09-30 08:28:02.000000000 -0600
@@ -0,0 +1,12 @@
+#ifndef __CMUSIEVE_PLUGIN_H
+#define __CMUSIEVE_PLUGIN_H
+
+int cmu_sieve_run(struct mail_namespace *namespaces,
+		  struct mail_storage **storage_r, struct mail *mail,
+		  const char *script_path, const char *destaddr,
+		  const char *username, const char *mailbox);
+
+void cmusieve_plugin_init(void);
+void cmusieve_plugin_deinit(void);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/imparse.c dovecot-1.1.1-sieve/dovecot-sieve/src/imparse.c
--- dovecot-1.1.1/dovecot-sieve/src/imparse.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/imparse.c	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+#include "imparse.h"
+
+int imparse_isatom(const char *s)
+{
+    int len = 0;
+
+    if (!*s) return 0;
+    for (; *s; s++) {
+	len++;
+	if (*s & 0x80 || *s < 0x1f || *s == 0x7f ||
+	    *s == ' ' || *s == '{' || *s == '(' || *s == ')' ||
+	    *s == '\"' || *s == '%' || *s == '*' || *s == '\\') return 0;
+    }
+    if (len >= 1024) return 0;
+    return 1;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/imparse.h dovecot-1.1.1-sieve/dovecot-sieve/src/imparse.h
--- dovecot-1.1.1/dovecot-sieve/src/imparse.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/imparse.h	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,6 @@
+#ifndef __IMPARSE_H
+#define __IMPARSE_H
+
+extern int imparse_isatom (const char *s);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libconfig.h dovecot-1.1.1-sieve/dovecot-sieve/src/libconfig.h
--- dovecot-1.1.1/dovecot-sieve/src/libconfig.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libconfig.h	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,8 @@
+#ifndef __LIBCONFIG_H
+#define __LIBCONFIG_H
+
+#define IMAPOPT_RFC3028_STRICT 1
+
+#define config_getswitch(n) 1
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/addr.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/addr.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr.c	2007-07-19 19:59:59.000000000 -0600
@@ -0,0 +1,1596 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse addrparse
+#define yylex   addrlex
+#define yyerror addrerror
+#define yylval  addrlval
+#define yychar  addrchar
+#define yydebug addrdebug
+#define yynerrs addrnerrs
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ATOM = 258,
+     QTEXT = 259,
+     DTEXT = 260
+   };
+#endif
+/* Tokens.  */
+#define ATOM 258
+#define QTEXT 259
+#define DTEXT 260
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "addr.y"
+
+/*
+ * addr.y -- RFC 822 address parser
+ * Ken Murchison
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "addr.h"
+#include "script.h"
+#include "xmalloc.h"
+    
+int addrerror(char *msg);
+extern int yylex(void);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 166 "addr.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  10
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   26
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  13
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  11
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  17
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  31
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   260
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    12,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     9,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       6,     2,     7,     2,     8,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    10,     2,    11,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     5,    10,    14,    16,    20,    22,    26,
+      28,    30,    32,    36,    38,    41,    43,    45
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      14,     0,    -1,    15,    -1,    21,     6,    15,     7,    -1,
+      16,     8,    17,    -1,    22,    -1,    22,     9,    16,    -1,
+      18,    -1,    18,     9,    17,    -1,    19,    -1,    20,    -1,
+       3,    -1,    10,     5,    11,    -1,    22,    -1,    22,    21,
+      -1,     3,    -1,    23,    -1,    12,     4,    12,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    46,    46,    47,    50,    53,    54,    57,    58,    61,
+      62,    65,    68,    71,    72,    75,    76,    79
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ATOM", "QTEXT", "DTEXT", "'<'", "'>'",
+  "'@'", "'.'", "'['", "']'", "'\"'", "$accept", "sieve_address",
+  "addrspec", "localpart", "domain", "subdomain", "domainref", "domainlit",
+  "phrase", "word", "qstring", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,    60,    62,    64,    46,
+      91,    93,    34
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    13,    14,    14,    15,    16,    16,    17,    17,    18,
+      18,    19,    20,    21,    21,    22,    22,    23
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     4,     3,     1,     3,     1,     3,     1,
+       1,     1,     3,     1,     2,     1,     1,     3
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,    15,     0,     0,     2,     0,     0,     5,    16,     0,
+       1,     0,     0,     0,    14,    13,    17,    11,     0,     4,
+       7,     9,    10,     0,     5,     6,     0,     0,     3,    12,
+       8
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     3,     4,     5,    19,    20,    21,    22,    14,    15,
+       8
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -7
+static const yytype_int8 yypact[] =
+{
+      -1,    -7,     1,     3,    -7,     6,    10,    -2,    -7,    -6,
+      -7,     5,    -1,    -1,    -7,    -1,    -7,    -7,     4,    -7,
+       8,    -7,    -7,    11,    12,    -7,     9,     5,    -7,    -7,
+      -7
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+      -7,    -7,     7,    13,    -5,    -7,    -7,    -7,    23,     0,
+      -7
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -14
+static const yytype_int8 yytable[] =
+{
+       7,     1,     1,    10,   -13,     9,    16,    13,    17,    26,
+       2,     2,    24,    24,    11,    18,    12,    27,    28,    23,
+      29,    13,    30,     6,     0,     0,    25
+};
+
+static const yytype_int8 yycheck[] =
+{
+       0,     3,     3,     0,     6,     4,    12,     9,     3,     5,
+      12,    12,    12,    13,     8,    10,     6,     9,     7,    12,
+      11,     9,    27,     0,    -1,    -1,    13
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    12,    14,    15,    16,    21,    22,    23,     4,
+       0,     8,     6,     9,    21,    22,    12,     3,    10,    17,
+      18,    19,    20,    15,    22,    16,     5,     9,     7,    11,
+      17
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+      
+/* Line 1267 of yacc.c.  */
+#line 1372 "addr.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 82 "addr.y"
+
+
+/* copy address error message into buffer provided by sieve parser */
+int addrerror(char *s)
+{
+    extern char addrerr[ADDRERR_SIZE];
+    
+    strlcpy(addrerr, s, sizeof(addrerr));
+    return 0;
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/addr.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/addr.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr.h	2007-07-19 19:59:59.000000000 -0600
@@ -0,0 +1,63 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ATOM = 258,
+     QTEXT = 259,
+     DTEXT = 260
+   };
+#endif
+/* Tokens.  */
+#define ATOM 258
+#define QTEXT 259
+#define DTEXT 260
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE addrlval;
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/addr-lex.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr-lex.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/addr-lex.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr-lex.c	2007-07-19 19:59:59.000000000 -0600
@@ -0,0 +1,1843 @@
+
+#line 3 "<stdout>"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE addrrestart(addrin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int addrleng;
+
+extern FILE *addrin, *addrout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up addrtext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up addrtext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via addrrestart()), so that the user can continue scanning by
+	 * just pointing addrin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when addrtext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int addrleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow addrwrap()'s to do buffer switches
+ * instead of setting up a fresh addrin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void addrrestart (FILE *input_file  );
+void addr_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE addr_create_buffer (FILE *file,int size  );
+void addr_delete_buffer (YY_BUFFER_STATE b  );
+void addr_flush_buffer (YY_BUFFER_STATE b  );
+void addrpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void addrpop_buffer_state (void );
+
+static void addrensure_buffer_stack (void );
+static void addr_load_buffer_state (void );
+static void addr_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER addr_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE addr_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE addr_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE addr_scan_bytes (yyconst char *bytes,int len  );
+
+void *addralloc (yy_size_t  );
+void *addrrealloc (void *,yy_size_t  );
+void addrfree (void *  );
+
+#define yy_new_buffer addr_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        addrensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            addr_create_buffer(addrin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        addrensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            addr_create_buffer(addrin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define addrwrap() 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *addrin = (FILE *) 0, *addrout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int addrlineno;
+
+int addrlineno = 1;
+
+extern char *addrtext;
+#define yytext_ptr addrtext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up addrtext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	addrleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 15
+#define YY_END_OF_BUFFER 16
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[40] =
+    {   0,
+        0,    0,    8,    8,   10,   10,   12,   12,   16,    5,
+        5,    6,    6,    1,    3,    4,    7,    2,    8,   15,
+        9,   15,   10,   15,   11,   12,   13,   14,   15,    5,
+        5,    6,    8,    0,   10,    0,   12,    0,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    5,    1,    6,    1,    1,    1,    1,    1,    7,
+        8,    1,    1,    9,    1,    9,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    9,    9,    9,
+        1,    9,    1,    9,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+       10,   11,   12,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[14] =
+    {   0,
+        1,    2,    3,    4,    5,    6,    7,    7,    8,    9,
+        8,    9,   10
+    } ;
+
+static yyconst flex_int16_t yy_base[48] =
+    {   0,
+        0,    0,   11,   20,   29,   39,   49,   60,   27,    0,
+       73,    0,    0,  182,  182,  182,  182,  182,   14,  182,
+      182,   83,   10,   86,  182,    9,  182,  182,   92,    0,
+        0,    0,    8,  102,    7,    0,    5,    0,  182,  108,
+      118,  128,  138,  147,  152,  162,  172
+    } ;
+
+static yyconst flex_int16_t yy_def[48] =
+    {   0,
+       39,    1,   40,   40,   41,   41,   42,   42,   39,   43,
+       39,   44,   44,   39,   39,   39,   39,   39,   45,   39,
+       39,   45,   46,   46,   39,   47,   39,   39,   47,   43,
+       11,   44,   45,   45,   46,   24,   47,   29,    0,   39,
+       39,   39,   39,   39,   39,   39,   39
+    } ;
+
+static yyconst flex_int16_t yy_nxt[196] =
+    {   0,
+       10,   11,   12,   13,   13,   14,   15,   16,   17,   18,
+       17,   17,   10,   20,   20,   38,   21,   36,   34,   38,
+       36,   22,   20,   20,   34,   21,   39,   39,   39,   39,
+       22,   20,   20,   39,   39,   39,   39,   39,   20,   24,
+       25,   20,   20,   39,   39,   39,   39,   39,   20,   24,
+       25,   20,   39,   39,   39,   27,   28,   39,   39,   29,
+       39,   20,   20,   39,   39,   39,   27,   28,   39,   39,
+       29,   39,   20,   30,   31,   32,   32,   32,   39,   39,
+       39,   39,   39,   39,   39,   30,   33,   39,   33,   35,
+       39,   39,   39,   39,   39,   35,   39,   35,   37,   37,
+
+       39,   39,   39,   39,   37,   33,   39,   33,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   23,   23,
+       23,   23,   23,   23,   23,   23,   23,   23,   26,   26,
+       26,   26,   26,   26,   26,   26,   26,   26,   30,   30,
+       39,   39,   39,   39,   39,   39,   39,   30,   32,   32,
+       32,   32,   33,   33,   39,   39,   33,   39,   33,   33,
+       33,   33,   35,   35,   39,   39,   35,   35,   35,   35,
+       39,   35,   37,   37,   39,   37,   37,   37,   39,   37,
+       37,    9,   39,   39,   39,   39,   39,   39,   39,   39,
+       39,   39,   39,   39,   39
+
+    } ;
+
+static yyconst flex_int16_t yy_chk[196] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    3,    3,   37,    3,   35,   33,   26,
+       23,    3,    4,    4,   19,    4,    9,    0,    0,    0,
+        4,    5,    5,    0,    0,    0,    0,    0,    5,    5,
+        5,    6,    6,    0,    0,    0,    0,    0,    6,    6,
+        6,    7,    0,    0,    0,    7,    7,    0,    0,    7,
+        0,    7,    8,    0,    0,    0,    8,    8,    0,    0,
+        8,    0,    8,   11,   11,   11,   11,   11,    0,    0,
+        0,    0,    0,    0,    0,   11,   22,    0,   22,   24,
+        0,    0,    0,    0,    0,   24,    0,   24,   29,   29,
+
+        0,    0,    0,    0,   29,   34,    0,   34,   40,   40,
+       40,   40,   40,   40,   40,   40,   40,   40,   41,   41,
+       41,   41,   41,   41,   41,   41,   41,   41,   42,   42,
+       42,   42,   42,   42,   42,   42,   42,   42,   43,   43,
+        0,    0,    0,    0,    0,    0,    0,   43,   44,   44,
+       44,   44,   45,   45,    0,    0,   45,    0,   45,   45,
+       45,   45,   46,   46,    0,    0,   46,   46,   46,   46,
+        0,   46,   47,   47,    0,   47,   47,   47,    0,   47,
+       47,   39,   39,   39,   39,   39,   39,   39,   39,   39,
+       39,   39,   39,   39,   39
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int addr_flex_debug;
+int addr_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *addrtext;
+#line 1 "addr-lex.l"
+#line 2 "addr-lex.l"
+/*
+ * addr-lex.l -- RFC 822 address lexer
+ * Ken Murchison
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include "addr.h"
+#include <string.h>
+
+#undef YY_INPUT
+#define YY_INPUT(b, r, ms) (r = addrinput(b, ms))
+
+int addrinput(char *buf, int max_size);
+void addrerror(const char *);
+
+static int ncom;	/* number of open comments */
+
+#line 550 "<stdout>"
+
+#define INITIAL 0
+#define QSTRING 1
+#define DOMAINLIT 2
+#define COMMENT 3
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int addrwrap (void );
+#else
+extern int addrwrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( addrtext, addrleng, 1, addrout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( addrin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( addrin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, addrin))==0 && ferror(addrin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(addrin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int addrlex (void);
+
+#define YY_DECL int addrlex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after addrtext and addrleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 48 "addr-lex.l"
+
+
+#line 707 "<stdout>"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! addrin )
+			addrin = stdin;
+
+		if ( ! addrout )
+			addrout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			addrensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				addr_create_buffer(addrin,YY_BUF_SIZE );
+		}
+
+		addr_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of addrtext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 40 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 182 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 50 "addr-lex.l"
+{ BEGIN QSTRING; return addrtext[0]; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 51 "addr-lex.l"
+{ BEGIN DOMAINLIT; return addrtext[0]; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 52 "addr-lex.l"
+{ ncom = 1; BEGIN COMMENT; }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 53 "addr-lex.l"
+{ addrerror("address parse error, "
+					  "unexpected `')'' "
+					  "(unbalanced comment)");
+				  yyterminate(); }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 58 "addr-lex.l"
+return ATOM;
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 60 "addr-lex.l"
+/* ignore whitespace */
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 61 "addr-lex.l"
+return addrtext[0];
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 63 "addr-lex.l"
+return QTEXT;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 64 "addr-lex.l"
+{ BEGIN INITIAL; return addrtext[0]; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 66 "addr-lex.l"
+return DTEXT;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 67 "addr-lex.l"
+{ BEGIN INITIAL; return addrtext[0]; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 69 "addr-lex.l"
+/* ignore comments */
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 70 "addr-lex.l"
+ncom++;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 71 "addr-lex.l"
+{ ncom--; if (ncom == 0) BEGIN INITIAL; }
+	YY_BREAK
+case YY_STATE_EOF(COMMENT):
+#line 72 "addr-lex.l"
+{ addrerror("address parse error, "
+					  "expecting `')'' "
+					  "(unterminated comment)");
+				  yyterminate(); }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 77 "addr-lex.l"
+ECHO;
+	YY_BREAK
+#line 876 "<stdout>"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(QSTRING):
+case YY_STATE_EOF(DOMAINLIT):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed addrin at a new source and called
+			 * addrlex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = addrin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( addrwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * addrtext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of addrlex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					addrrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			addrrestart(addrin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 13);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 40 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 13;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 40 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 39);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					addrrestart(addrin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( addrwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve addrtext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void addrrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        addrensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            addr_create_buffer(addrin,YY_BUF_SIZE );
+	}
+
+	addr_init_buffer(YY_CURRENT_BUFFER,input_file );
+	addr_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void addr_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		addrpop_buffer_state();
+	 *		addrpush_buffer_state(new_buffer);
+     */
+	addrensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	addr_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (addrwrap()) processing, but the only time this flag
+	 * is looked at is after addrwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void addr_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	addrin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE addr_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) addralloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in addr_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) addralloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in addr_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	addr_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with addr_create_buffer()
+ * 
+ */
+    void addr_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		addrfree((void *) b->yy_ch_buf  );
+
+	addrfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a addrrestart() or at EOF.
+ */
+    static void addr_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	addr_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then addr_init_buffer was _probably_
+     * called from addrrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void addr_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		addr_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void addrpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	addrensure_buffer_stack();
+
+	/* This block is copied from addr_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from addr_switch_to_buffer. */
+	addr_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void addrpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	addr_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		addr_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void addrensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)addralloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)addrrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE addr_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) addralloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in addr_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	addr_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to addrlex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       addr_scan_bytes() instead.
+ */
+YY_BUFFER_STATE addr_scan_string (yyconst char * yystr )
+{
+    
+	return addr_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to addrlex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE addr_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) addralloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in addr_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = addr_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in addr_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up addrtext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		addrtext[addrleng] = (yy_hold_char); \
+		(yy_c_buf_p) = addrtext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		addrleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int addrget_lineno  (void)
+{
+        
+    return addrlineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *addrget_in  (void)
+{
+        return addrin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *addrget_out  (void)
+{
+        return addrout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int addrget_leng  (void)
+{
+        return addrleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *addrget_text  (void)
+{
+        return addrtext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void addrset_lineno (int  line_number )
+{
+    
+    addrlineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see addr_switch_to_buffer
+ */
+void addrset_in (FILE *  in_str )
+{
+        addrin = in_str ;
+}
+
+void addrset_out (FILE *  out_str )
+{
+        addrout = out_str ;
+}
+
+int addrget_debug  (void)
+{
+        return addr_flex_debug;
+}
+
+void addrset_debug (int  bdebug )
+{
+        addr_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from addrlex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    addrin = stdin;
+    addrout = stdout;
+#else
+    addrin = (FILE *) 0;
+    addrout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * addrlex_init()
+     */
+    return 0;
+}
+
+/* addrlex_destroy is for both reentrant and non-reentrant scanners. */
+int addrlex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		addr_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		addrpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	addrfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * addrlex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *addralloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *addrrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void addrfree (void * ptr )
+{
+	free( (char *) ptr );	/* see addrrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 77 "addr-lex.l"
+
+
+
+/* take input from address string provided by sieve parser */
+int addrinput(char *buf, int max_size)
+{
+    extern char *addrptr;	/* current position in address string */
+    size_t n;			/* number of characters to read from string */
+
+    n = (int)strlen(addrptr) < max_size ? (int)strlen(addrptr) : max_size;
+    if (n > 0) {
+	memcpy(buf, addrptr, n);
+	addrptr += n;
+    }
+    return n;
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/addr-lex.l dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr-lex.l
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/addr-lex.l	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr-lex.l	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,91 @@
+%{
+/*
+ * addr-lex.l -- RFC 822 address lexer
+ * Ken Murchison
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include "addr.h"
+#include <string.h>
+
+#undef YY_INPUT
+#define YY_INPUT(b, r, ms) (r = addrinput(b, ms))
+
+int addrinput(char *buf, int max_size);
+void addrerror(const char *);
+
+static int ncom;	/* number of open comments */
+%}
+
+%option noyywrap
+%option nounput
+%option prefix="addr"
+
+%x QSTRING DOMAINLIT COMMENT
+
+%%
+
+\"				{ BEGIN QSTRING; return yytext[0]; }
+\[				{ BEGIN DOMAINLIT; return yytext[0]; }
+\(				{ ncom = 1; BEGIN COMMENT; }
+\)				{ addrerror("address parse error, "
+					  "unexpected `')'' "
+					  "(unbalanced comment)");
+				  yyterminate(); }
+
+[^\(\)<>@,;:\\".\[\] \n\r]+	return ATOM;
+
+[\t \n\r]+			/* ignore whitespace */
+.				return yytext[0];
+
+<QSTRING>([^\n\r"\\]|\\.)*	return QTEXT;
+<QSTRING>\"			{ BEGIN INITIAL; return yytext[0]; }
+
+<DOMAINLIT>([^\[\]\n\r\\]|\\.)*	return DTEXT;
+<DOMAINLIT>\]			{ BEGIN INITIAL; return yytext[0]; }
+
+<COMMENT>([^\(\)\n\0\\]|\\.)*	/* ignore comments */
+<COMMENT>\(			ncom++;
+<COMMENT>\)			{ ncom--; if (ncom == 0) BEGIN INITIAL; }
+<COMMENT><<EOF>>		{ addrerror("address parse error, "
+					  "expecting `')'' "
+					  "(unterminated comment)");
+				  yyterminate(); }
+
+%%
+
+/* take input from address string provided by sieve parser */
+int addrinput(char *buf, int max_size)
+{
+    extern char *addrptr;	/* current position in address string */
+    size_t n;			/* number of characters to read from string */
+
+    n = (int)strlen(addrptr) < max_size ? (int)strlen(addrptr) : max_size;
+    if (n > 0) {
+	memcpy(buf, addrptr, n);
+	addrptr += n;
+    }
+    return n;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/addr.y dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr.y
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/addr.y	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/addr.y	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,91 @@
+%{
+/*
+ * addr.y -- RFC 822 address parser
+ * Ken Murchison
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "addr.h"
+#include "script.h"
+#include "xmalloc.h"
+    
+int addrerror(char *msg);
+extern int yylex(void);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+%}
+
+%token ATOM QTEXT DTEXT
+
+%%
+sieve_address: addrspec			/* simple address */
+	| phrase '<' addrspec '>'	/* name & addr-spec */
+	;
+
+addrspec: localpart '@' domain		/* global-address */
+	;
+
+localpart: word				/* uninterpreted, case-preserved */
+	| word '.' localpart
+	;
+
+domain: subdomain
+	| subdomain '.' domain
+	;
+
+subdomain: domainref
+	| domainlit
+	;
+
+domainref: ATOM				/* symbolic reference */
+	;
+
+domainlit: '[' DTEXT ']'
+	;
+
+phrase: word
+	| word phrase
+	;
+
+word: ATOM
+	| qstring
+	;
+
+qstring: '"' QTEXT '"'
+	;
+
+%%
+
+/* copy address error message into buffer provided by sieve parser */
+int addrerror(char *s)
+{
+    extern char addrerr[ADDRERR_SIZE];
+    
+    strlcpy(addrerr, s, sizeof(addrerr));
+    return 0;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/AUTHORS dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/AUTHORS
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/AUTHORS	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/AUTHORS	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,9 @@
+$Id$
+
+Larry Greenfield <leg+sieve@andrew.cmu.edu> wrote the first pass.
+
+Alexy Melnikov <alexey.melnikov@isode.com> submitted some bug fixes and 
+improvements.
+
+Ken Murchison <ken@oceana.com> took the ball, added more extensions
+than existed in the known world, and overall improved the code mightily.
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_dump.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_dump.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_dump.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_dump.c	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,338 @@
+/* bc_generate.c -- sieve bytecode- almost flattened bytecode
+ * Rob Siemborski
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+ 
+#include "sieve_interface.h"
+#include "bytecode.h"
+
+ 
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+#if DUMPCODE
+
+/*this would work a lot better if we actually could tell how many levels deep in if statements we were.  currently it doesn't know*/
+
+static void print_spaces(int n)
+{
+    int temp_n=0;
+    while(temp_n++ < (n))
+	putchar(' ');
+}
+
+
+/* Dump a stringlist.  Return the last address used by the list */
+static int dump_sl(bytecode_info_t *d, int ip, int level) 
+{
+    int numstr = d->data[ip].listlen;
+    int i;
+    
+    for(i=0; i<numstr; i++) {
+	print_spaces(level*4);
+	printf(" {%d}",d->data[++ip].len);
+	printf("%s\n",d->data[++ip].str);
+    }
+    
+    return ip;
+}
+
+static int dump_test(bytecode_info_t *d, int ip, int level);
+
+/* Dump a testlist.  Return the last address used by the list */
+static int dump_tl(bytecode_info_t *d, int ip, int level) 
+{
+    int numtest = d->data[ip].listlen;
+    int i;
+    
+    for(i=0; i<numtest; i++) {
+	print_spaces(level*4);
+	printf(" (until %d)\n", d->data[++ip].jump);
+	ip = dump_test(d, ++ip, level);
+    }
+    
+    return ip;
+}
+
+/* Dump a test, return the last address used by the test */
+static int dump_test(bytecode_info_t *d, int ip, int level ) {
+
+    print_spaces(level*4);
+    switch(d->data[ip].op) {
+    case BC_TRUE:
+	printf("%d: TRUE\n",ip);
+	break;
+
+    case BC_FALSE:
+	printf("%d: FALSE\n",ip);
+	break;
+
+    case BC_NOT:
+	printf("%d: NOT TEST(\n",ip++);
+	/*   printf("  (until %d)\n", d->data[ip++].jump);*/
+	ip = dump_test(d,ip, level);
+	print_spaces(level*4);
+	printf("    )\n");
+	break;
+
+    case BC_SIZE:
+	printf("%d: SIZE TAG(%d) NUM(%d)\n",ip,
+	       d->data[ip+1].value, d->data[ip+2].value);
+	ip+=2;
+	break;
+
+    case BC_EXISTS:
+	printf("%d: EXISTS\n",ip++);
+	ip = dump_sl(d,ip,level);
+	break;
+
+    case BC_ALLOF:
+	printf("%d: ALLOF (\n",ip++);
+	ip = dump_tl(d,ip,level);
+	print_spaces(level*4);
+	printf(")\n");
+	break;
+
+    case BC_ANYOF:
+	printf("%d: ANYOF (\n",ip++);
+	ip = dump_tl(d,ip, level);
+	  print_spaces(level*4);
+	printf(")\n");
+	break;
+	    
+    case BC_HEADER:
+	printf("%d: HEADER (\n",ip++);
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d  RELATION:%d  COMP:%d HEADERS:\n", 
+		   d->data[ip].value, d->data[ip+1].value,d->data[ip+2].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d HEADERS:\n",d->data[ip].value, d->data[ip+2].value);
+	}
+	ip+=3;
+	ip = dump_sl(d,ip,level);
+	ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+	
+    case BC_ADDRESS:
+    case BC_ENVELOPE:
+	printf("%d: %s (\n",ip++,
+	       d->data[ip].op == BC_ADDRESS ? "ADDRESS" : "ENVELOPE");
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d RELATION: %d COMP: %d TYPE: %d HEADERS:\n", 
+		   d->data[ip].value, d->data[ip+1].value, d->data[ip+2].value, d->data[ip+3].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d TYPE:%d HEADERS:\n",
+		   d->data[ip].value,d->data[ip+1].value,d->data[ip+3].value);
+	}
+	ip+=4;
+	ip = dump_sl(d,ip,level); ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+
+    case BC_BODY:
+	printf("%d: BODY (\n",ip++);
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d RELATION: %d COMP: %d TRANSFORM: %d OFFSET: %d CONTENT-TYPES:\n", 
+		   d->data[ip].value,d->data[ip+1].value,d->data[ip+2].value,
+		   d->data[ip+3].value,d->data[ip+4].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d TRANSFORM:%d OFFSET: %d CONTENT-TYPES:\n",
+		   d->data[ip].value,d->data[ip+1].value,d->data[ip+3].value,
+		   d->data[ip+4].value);
+	}
+	ip+=5;
+	ip = dump_sl(d,ip,level); ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+
+    default:
+	printf("%d: TEST(%d)\n",ip,d->data[ip].op);
+	break;
+    }
+
+    return ip;
+}
+
+void dump(bytecode_info_t *d, int level) 
+{
+    int i;
+    printf("Dumping almost flattened bytecode\n\n");
+    
+    if(!d) return;
+    
+    for(i=0; i<d->scriptend; i++) {
+	print_spaces(level*4);
+	switch(d->data[i].op) {
+	case B_REJECT:
+	    printf("%d: REJECT {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+	case B_IF:
+	    if (d->data[i+3].jump== -1)
+	    {
+		printf("%d: IF THEN(%d) POST(%d) TEST(\n",i,
+		       d->data[i+1].jump,d->data[i+2].jump);
+	    }
+	    else
+	    {
+		printf("%d: IF THEN(%d) ELSE(%d) POST(%d) TEST(\n",i,
+		       d->data[i+1].jump,d->data[i+2].jump,
+		       d->data[i+3].jump);
+	    }
+	    i = dump_test(d,i+4, level+1);
+	    printf(")\n");
+	    break;
+
+	case B_STOP:
+	    printf("%d: STOP\n",i);
+	    break;
+
+	case B_DISCARD:
+	    printf("%d: DISCARD\n",i);
+	    break;
+	    
+	case B_KEEP:
+	    printf("%d: KEEP\n",i);
+	    break;
+
+	case B_MARK:
+	    printf("%d: MARK\n",i);
+	    break;
+
+	case B_UNMARK:
+	    printf("%d: UNMARK\n",i);
+	    break;
+
+	case B_FILEINTO:
+	    printf("%d: FILEINTO COPY(%d) FOLDER({%d}%s)\n",i,
+		   d->data[i+1].value,d->data[i+2].len,d->data[i+3].str);
+	    i+=3;
+	    break;
+
+	case B_REDIRECT:
+	    printf("%d: REDIRECT COPY(%d) ADDRESS({%d}%s)\n",i,
+		   d->data[i+1].value,d->data[i+2].len,d->data[i+3].str);
+	    i+=3;
+	    break;
+
+	case B_SETFLAG:
+	    printf("%d: SETFLAG\n",i);
+	    i=dump_sl(d,++i, level);
+	    break;
+
+	case B_ADDFLAG:
+	    printf("%d: ADDFLAG\n",i);
+	    i=dump_sl(d,++i,level);
+	    break;
+
+	case B_REMOVEFLAG:
+	    printf("%d: REMOVEFLAG\n",i);
+	    i=dump_sl(d,++i,level);
+	    break;
+
+	case B_DENOTIFY:
+	    printf("%d: DENOTIFY priority %d,comp %d %d  %s\n", 
+		   i,
+		   d->data[i+1].value,
+		   d->data[i+2].value,
+		   d->data[i+3].value,
+		   (d->data[i+4].len == -1 ? "[nil]" : d->data[i+5].str));
+	    i+=5;
+	    break;
+
+	case B_NOTIFY: 
+	    printf("%d: NOTIFY\n   METHOD(%s),\n   ID(%s),\n   OPTIONS",
+		   i,
+		   d->data[i+2].str,
+		   (d->data[i+3].len == -1 ? "[nil]" : d->data[i+4].str));
+	    i+=5;
+	    i=dump_sl(d,i,level);
+	    printf("   PRIORITY(%d),\n   MESSAGE({%d}%s)\n", 
+		   d->data[i+1].value, d->data[i+2].len,d->data[i+3].str);
+	    i+=3;
+	    break;
+
+	case B_VACATION:
+	    printf("%d:VACATION\n",i);
+	    i++;
+	    i=dump_sl(d,i,level);
+	    printf("SUBJ({%d}%s) MESG({%d}%s)\n DAYS(%d) MIME(%d)\n"
+		   " FROM({%d}%s) HANDLE({%d}%s)\n",
+		   d->data[i+1].len, (d->data[i+1].len == -1 ? "[nil]" : d->data[i+2].str),
+		   d->data[i+3].len, (d->data[i+3].len == -1 ? "[nil]" : d->data[i+4].str),
+		   d->data[i+5].value, d->data[i+6].value,
+		   d->data[i+7].len, (d->data[i+7].len == -1 ? "[nil]" : d->data[i+8].str),
+		   d->data[i+9].len, (d->data[i+9].len == -1 ? "[nil]" : d->data[i+10].str));
+	    i+=10;
+	
+	    break;
+	case B_JUMP:
+	    printf("%d: JUMP HUH?  this shouldn't be here>?!",i);
+	    break;
+	case B_NULL:
+	    printf("%d: NULL\n",i);
+	    break;
+
+	case B_INCLUDE:
+	    printf("%d: INCLUDE LOCATION:%d {%d}%s\n",i,
+		   d->data[i+1].value,d->data[i+2].len,d->data[i+3].str);
+	    i+=3;
+	    break;
+
+	case B_RETURN:
+	    printf("%d: RETURN\n",i);
+	    break;
+
+	default:
+	    printf("%d: %d\n",i,d->data[i].op);
+	    break;
+	}
+    }
+    printf("full len is: %d\n", d->scriptend);
+}
+#endif
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_emit.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_emit.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_emit.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_emit.c	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,788 @@
+/* bc_emit.c -- sieve bytecode - pass 2 of the compiler
+ * Rob Siemborski
+ * Jen Smith
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xmalloc.h"
+#include "sieve_interface.h"
+
+ 
+#include "bytecode.h"
+
+#include <sys/types.h>
+#include <unistd.h>
+
+
+#if DUMPCODE
+void dump(bytecode_info_t *d);
+#endif
+
+static inline int write_int (int fd, int x)
+{
+    int y=htonl(x);
+    return (write(fd, &y, sizeof(int)));
+}
+ 
+    
+
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode  */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+/* Pad null bytes onto the end of the string we just wrote */
+/* returns -1 on failure or number of bytes written on success */
+static int align_string(int fd, int string_len) 
+{
+    /* Keep in mind that we always want to pad a string with *at least*
+     * one zero, that's why sometimes we have to pad with 4 */
+    int needed = sizeof(int) - (string_len % sizeof(int));
+    if (needed>= 0 && needed <=4)
+    {
+    	if(write(fd, "\0\0\0\0", needed) == -1) return -1;
+    }
+    return needed;
+}
+
+/*all functions keep codep up to date as they use it.
+  the amount that has been written to the file is maintained by the
+  filelen variable in bc_action_emit
+  the other bc_xxx_emit funtions keep track of how much they (and any functions they call) have written and return this value
+*/
+
+
+/* Write out a stringlist to a given file descriptor.
+ * return # of bytes written on success and -1 on error */
+
+/* stringlist: <# listitems>
+               <pos of listend (bytes)>
+               <string:(size)(aligned string)>
+*/
+static int bc_stringlist_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int len = bc->data[(*codep)++].len;
+    int i;
+    int ret;
+    int wrote = 2*sizeof(int);
+    int begin,end;
+
+    /* Write out number of items in the list */
+    if (write_int(fd, len)== -1) return -1 ;
+    
+    /* skip one spot end of list position*/
+    begin=lseek(fd,0,SEEK_CUR);
+    lseek(fd,sizeof(int),SEEK_CUR);
+    
+    /* Loop through all the items of the list, writing out length and string
+     * in sequence */
+    for(i=0; i < len; i++)
+    {
+	int datalen = bc->data[(*codep)++].len;
+	
+	if(write_int(fd, datalen) == -1) return -1;
+	wrote += sizeof(int);
+	
+	if(write(fd, bc->data[(*codep)++].str, datalen) == -1) return -1;
+	wrote += datalen;
+	
+	ret = align_string(fd,datalen);
+	if(ret == -1) return -1;
+	
+	wrote+=ret;
+    }
+    end=lseek(fd,0,SEEK_CUR);
+ 
+    /* go back and write end of list position */
+    lseek(fd,begin,SEEK_SET);
+    if(write_int(fd, end) == -1) return -1;
+
+    /* return to the end */
+    lseek(fd,end,SEEK_SET);
+    return wrote;
+}
+
+static int bc_test_emit(int fd, int *codep, bytecode_info_t *bc);
+
+/* Write out a testlist to a given file descriptor.
+ * return # of bytes written on success and -1 on error */
+static int bc_testlist_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int len = bc->data[(*codep)++].len;
+    int i;
+    int ret;
+    int begin, end;
+    int wrote = 2*sizeof(int);
+        
+    /* Write out number of items in the list */
+    if(write_int(fd, len)== -1) return -1;
+
+    /* skip one spot for end of list position*/
+    begin = lseek(fd, 0, SEEK_CUR);
+    lseek(fd, sizeof(int), SEEK_CUR);
+      
+    /* Loop through all the items of the list, writing out each
+     * test as we reach it in sequence. */
+    for(i=0; i < len; i++) {
+	int nextcodep = bc->data[(*codep)++].jump;
+	
+	ret = bc_test_emit(fd, codep, bc);
+	if(ret < 0 ) return -1;
+	
+	wrote+=ret;
+	*codep = nextcodep;
+    }
+    end = lseek(fd, 0, SEEK_CUR);
+
+    /* go back and write the end of list position */
+    lseek(fd,begin,SEEK_SET);
+    if(write_int(fd, end) == -1) return -1;
+
+    /*return to the end */
+    lseek(fd,end,SEEK_SET);
+
+    return wrote;
+}
+
+/* emit the bytecode for a test.  returns -1 on failure or size of
+ * emitted bytecode on success */
+static int bc_test_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int wrote=0;/* Relative offset to account for interleaved strings */
+    
+    
+    int ret; /* Temporary Return Value Variable */
+    
+    /* Output this opcode */
+    if(write_int(fd, bc->data[(*codep)].op) == -1)
+	return -1;
+    wrote += sizeof(int);
+    
+    switch(bc->data[(*codep)++].op) {
+    case BC_TRUE:
+    case BC_FALSE:
+	/* No parameter opcodes */
+	break;
+	
+    case BC_NOT:
+    {
+	/* Single parameter: another test */
+	ret = bc_test_emit(fd, codep, bc);
+	if(ret < 0)
+	    return -1;
+	else
+	    wrote+=ret;
+	break;
+    }
+    
+    case BC_ALLOF:
+    case BC_ANYOF:
+	/*where we jump to?*/
+	/* Just drop a testlist */
+	ret = bc_testlist_emit(fd, codep, bc);
+	if(ret < 0)
+	    return -1;
+	else
+	    wrote+=ret;
+	break;
+	
+    case BC_SIZE:
+	/* Drop tag and number */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	if(write_int(fd, bc->data[(*codep)+1].value) == -1)
+	    return -1;
+	
+	wrote += 2 * sizeof(int);
+	(*codep) += 2;
+	break;
+	
+    case BC_EXISTS:
+    {
+	int ret;
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote += ret;
+	break;
+    }
+    
+    case BC_HEADER:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;    
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/* Now drop headers */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    case BC_ADDRESS:
+    case BC_ENVELOPE:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop address part*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/* Now drop headers */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    case BC_BODY:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop transform*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop offset*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop content-types*/
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    default:
+	/* Unknown testcode? */
+	return -1;
+    }
+    return wrote;
+}
+
+/* emit the bytecode to a file descriptor given a flattened parse tree
+ * returns -1 on failure, size of emitted bytecode on success.
+ *
+ * this takes care of everything except the comparisons */
+static int bc_action_emit(int fd, int codep, int stopcodep,
+			  bytecode_info_t *bc, int filelen) 
+{
+    int len; /* Temporary Length Variable */
+    int ret; /* Temporary Return Value Variable */
+    int start_filelen = filelen;
+    int i;
+    
+    /*debugging variable to check filelen*/
+    /*int location;*/
+    
+    /*syslog(LOG_DEBUG, "entered bc_action_emit with filelen: %d", filelen);*/
+    
+    /* All non-string data MUST be sizeof(int)
+       byte alligned so the end of each string may require a pad */
+    /*
+     * Note that for purposes of jumps you must multiply codep by sizeof(int)
+     */
+    while(codep < stopcodep) {
+	/* Output this opcode */
+	if(write_int(fd, bc->data[codep].op) == -1)
+	    return -1; 
+	
+	filelen+=sizeof(int);
+	
+	switch(bc->data[codep++].op) {
+
+	case B_IF:
+	{
+	    /* IF
+	     *  test
+	     *  jump (false condition)
+	     *  then
+	     * (if there is an else) jump(finish) 
+	     * (if there is an else) else
+	     */
+
+	    int testEndLoc=-1;
+	    int testdist, thendist, elsedist;
+	    int c;
+	    
+	    int jumpFalseLoc=-1;/*this is the location that is being reserved
+				  for the first jump command
+				  we jump to the false condition of the test*/
+	    
+	    int jumpEndLoc=-1; /* this is the location that is being reserved
+				  for the optional jump command
+				  it jumps over the else statement to the end*/
+	    int jumpto=-1;
+	    int jumpop= B_JUMP;
+
+	    /*leave space to store the location of end of the test*/
+	    ret = lseek(fd, sizeof(int), SEEK_CUR);
+	    if(ret == -1) return ret;
+	    
+	    testEndLoc=filelen;
+	    filelen+=sizeof(int);
+	    
+	    /* spew the test */
+
+	    c=codep+3;
+	    testdist = bc_test_emit(fd, &c, bc);
+	    if(testdist == -1)return -1;
+	    filelen +=testdist;
+	    
+            /*store the location for hte end of the test
+	     *this is important for short circuiting of allof/anyof*/
+	    jumpto=filelen/4;
+	    if(lseek(fd, testEndLoc, SEEK_SET) == -1)
+		return -1;
+	    if(write_int(fd,jumpto) == -1)
+		return -1;
+
+	    if(lseek(fd,filelen,SEEK_SET) == -1)
+		return -1;
+
+	    /* leave space for jump */
+	    if(write_int(fd, jumpop) == -1)
+		return -1;
+	    ret = lseek(fd, sizeof(int), SEEK_CUR);
+	    if(ret == -1)
+		return ret;
+	    jumpFalseLoc=filelen+sizeof(int);
+	    
+	    filelen +=2*sizeof(int); /*jumpop + jump*/
+	    
+	    /* spew the then code */ 
+	    thendist = bc_action_emit(fd, bc->data[codep].value,
+				      bc->data[codep+1].value, bc,
+				      filelen);
+	 
+	    filelen+=thendist;
+	  	    
+	    /* there is an else case */
+	    if(bc->data[codep+2].value != -1)
+	    {
+		/* leave space for jump */
+		if(write_int(fd, jumpop) == -1)
+		    return -1;
+		ret = lseek(fd, sizeof(int), SEEK_CUR);
+		if(ret == -1)
+		    return ret;
+
+		jumpEndLoc=filelen+sizeof(int);
+		filelen+=2*sizeof(int);/*jumpop + jump*/
+	    }
+	  
+	    /*put previous jump to the end of the then code,
+	     *or the end of the jump if there is an else case */
+	    jumpto=filelen/4;
+	    if(lseek(fd, jumpFalseLoc, SEEK_SET) == -1)
+		return -1;
+	    if(write_int(fd,jumpto) == -1)
+		return -1;
+	    if(lseek(fd,filelen,SEEK_SET) == -1)
+		return -1;
+	    
+	    /* there is an else case */
+	    if(bc->data[codep+2].value != -1) {
+		/* spew the else code */
+		elsedist = bc_action_emit(fd, bc->data[codep+1].value,
+					 bc->data[codep+2].value, bc,
+					 filelen);
+	
+		filelen+=elsedist;
+		
+		/*put jump to the end of the else code*/
+	        jumpto=filelen/4;
+		if(lseek(fd, jumpEndLoc, SEEK_SET) == -1)
+		    return -1;
+		if(write_int(fd,jumpto) == -1)
+		    return -1;
+		if(lseek(fd,filelen,SEEK_SET) == -1)
+		    return -1;
+		
+		codep = bc->data[codep+2].value;
+	    } else {
+		codep = bc->data[codep+1].value;
+	    }
+	    
+	    break;
+	}
+	
+	case B_FILEINTO:
+	case B_REDIRECT:
+	    /* Copy (word), Folder/Address String */
+
+	    if(write_int(fd,bc->data[codep++].value) == -1)
+		return -1;
+
+	    filelen += sizeof(int);
+
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+
+	    filelen+=sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1)
+		return -1;
+
+	    filelen += len + ret;
+
+	    break;
+
+	case B_REJECT:
+	    /*just a string*/
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+
+	    filelen+=sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1)
+		return -1;
+
+	    filelen += len + ret;
+	    
+	    break; 
+
+	case B_SETFLAG:
+	case B_ADDFLAG:
+	case B_REMOVEFLAG:
+	    /* Dump just a stringlist */
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0)
+		return -1;
+	    filelen += ret;
+	    break;
+	    
+	case B_NOTIFY:
+	    /* method string, id string, options string list,
+	       priotity, Message String */
+	    /*method and id*/
+	    for(i=0; i<2; i++) {
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		if(len == -1)
+		{
+                    /* this will probably only happen for the id */
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{	
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1)
+			return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    /*options */
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0)
+		return -1;
+	    filelen+=ret;
+	    
+	    /*priority*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+	    
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1) return -1;
+	    
+ 	    filelen += len + ret;
+	    break;
+
+		
+	case B_DENOTIFY:
+	    /* priority num,comptype  num,relat num, comp string*/ 
+
+	    /* priority*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* comptype */
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* relational*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* comp string*/
+	    
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    
+	    if(len == -1)
+	    {
+		/* this is a nil string */
+		/* skip the null pointer and make up for it 
+		 * by adjusting the offset */
+		codep++;
+	    }
+	    else
+	    {
+		if(write(fd,bc->data[codep++].str,len) == -1)
+		    return -1;
+		
+		ret = align_string(fd, len);
+		if(ret == -1) return -1;
+		
+		filelen += len + ret;
+	    }
+	    	    break;
+	case B_VACATION:
+	    /* Address list, Subject String, Message String,
+	       Days (word), Mime (word), From String, Handle String */
+	   
+	        /*new code-this might be broken*/
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0) return -1;
+	    filelen += ret;
+	    /*end of new code*/
+
+	    for(i=0; i<2; i++) {/*writing strings*/
+
+		/*write length of string*/
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		    
+		if(len == -1)
+		{
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{
+		    /*write string*/
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1) return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    /* Days*/
+	    if(write_int(fd,bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+            /*Mime */
+	    if(write_int(fd,bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+
+	    for(i=0; i<2; i++) {/*writing strings*/
+
+		/*write length of string*/
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		    
+		if(len == -1)
+		{
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{
+		    /*write string*/
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1) return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    filelen += sizeof(int);
+	    
+	    break;
+	case B_INCLUDE:
+	    /* Location (word), Filename String */ 
+
+	    /* Location */
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* Filename */
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+
+	    filelen += sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+		
+	    ret = align_string(fd, len);
+	    if(ret == -1) return -1;
+		
+	    filelen += len + ret;
+	    break;
+	case B_NULL:
+	case B_STOP:
+	case B_DISCARD:
+	case B_KEEP:
+	case B_MARK:
+	case B_UNMARK:
+	case B_RETURN:
+	    /* No Parameters! */
+	    break;
+
+	default:
+	    /* Unknown opcode? */
+	    return -1;
+	}
+    }
+    return filelen - start_filelen;
+}
+
+/* spew the bytecode to disk */
+int sieve_emit_bytecode(int fd, bytecode_info_t *bc)  
+{
+    /* First output version number (4 bytes) */
+    int data = BYTECODE_VERSION;
+
+    /*this is a string, so it is happy*/
+    if(write(fd, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN) == -1)
+	return -1;
+
+    if(write_int(fd, data) == -1) return -1;
+
+#if DUMPCODE
+    dump(bc);
+#endif
+
+    /*the sizeof(int) is to account for the version # at the begining*/
+    return bc_action_emit(fd, 0, bc->scriptend, bc, sizeof(int) + BYTECODE_MAGIC_LEN);
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_eval.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_eval.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_eval.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_eval.c	2007-09-30 08:20:02.000000000 -0600
@@ -0,0 +1,1371 @@
+/* bc_eval.c - evaluate the bytecode
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "message.h"
+#include "script.h"
+
+#include "bytecode.h"
+
+#include "xmalloc.h"
+
+#include <string.h>
+#include <ctype.h>
+
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************EXECUTING BYTECODE******************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+
+/* Given a bytecode_input_t at the beginning of a string (the len block),
+ * return the string, the length, and the bytecode index of the NEXT
+ * item */
+int unwrap_string(bytecode_input_t *bc, int pos, const char **str, int *len) 
+{
+    int local_len = ntohl(bc[pos].value);
+
+    pos++;
+    
+    if(local_len == -1) {
+	/* -1 length indicates NULL */
+	*str = NULL;
+    } else {
+	/* This cast is ugly, but necessary */
+	*str = (const char *)&bc[pos].str;
+	
+	/* Compute the next index */
+	pos += ((ROUNDUP(local_len+1))/sizeof(bytecode_input_t));
+    }
+    
+    if(len) *len = local_len;
+    
+    return pos;
+}
+
+
+/* this is used by notify to pass the options list to do_notify
+ * do_notify needs null-terminated (char *)[],
+ *  we have a stringlist, the beginning of which is pointed at by pos */
+static const char ** bc_makeArray(bytecode_input_t *bc, int *pos)
+{
+    int i;
+    const char** array;
+    int len = ntohl(bc[*pos].value);
+
+    (*pos)+=2; /* Skip # Values and Total Byte Length */
+  
+    array=(const char **)xmalloc((len+1) * sizeof(char *));
+
+    for (i=0; i<len; i++) {
+	*pos = unwrap_string(bc, *pos, &(array[i]), NULL);
+    }
+
+    array[i] = NULL;
+  
+    return array;
+}
+
+/* Compile a regular expression for use during parsing */
+static regex_t * bc_compile_regex(const char *s, int ctag,
+				  char *errmsg, size_t errsiz)
+{
+    int ret;
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+    
+    if ( (ret=regcomp(reg, s, ctag)) != 0)
+    {
+	(void) regerror(ret, reg, errmsg, errsiz);
+	free(reg);
+	return NULL;
+    }
+    return reg;
+}
+
+/* Determine if addr is a system address */
+static int sysaddr(const char *addr)
+{
+    if (!strncasecmp(addr, "MAILER-DAEMON", 13))
+	return 1;
+
+    if (!strncasecmp(addr, "LISTSERV", 8))
+	return 1;
+
+    if (!strncasecmp(addr, "majordomo", 9))
+	return 1;
+
+    if (strstr(addr, "-request@"))
+	return 1;
+
+    if (!strncmp(addr, "owner-", 6))
+	return 1;
+
+    return 0;
+}
+
+/* look for myaddr and myaddrs in the body of a header - return the match */
+static char* look_for_me(char *myaddr, int numaddresses,
+			       bytecode_input_t *bc, int i, const char **body)
+{
+    char *found = NULL;
+    int l;
+    int curra,x ;
+
+    /* loop through each TO header */
+    for (l = 0; body[l] != NULL && !found; l++) {
+	void *data = NULL, *marker = NULL;
+	char *addr;
+	
+	parse_address(body[l], &data, &marker);
+
+	/* loop through each address in the header */
+	while (!found &&
+	       ((addr = get_address(ADDRESS_ALL,&data, &marker, 1))!= NULL)) {
+
+	    if (!strcasecmp(addr, myaddr)) {
+		found = xstrdup(myaddr);
+		break;
+	    }
+
+	    curra=i;
+
+	    for(x=0; x<numaddresses; x++)
+	    {
+		void *altdata = NULL, *altmarker = NULL;
+		char *altaddr;
+		const char *str;
+
+		curra = unwrap_string(bc, curra, &str, NULL);
+		
+		/* is this address one of my addresses? */
+      		parse_address(str, &altdata, &altmarker);
+
+		altaddr = get_address(ADDRESS_ALL, &altdata, &altmarker, 1);
+
+		if (!strcasecmp(addr,altaddr)) {
+		    found=xstrdup(str);
+		    break;
+		}
+
+		free_address(&altdata, &altmarker);
+	    }
+
+	}
+	free_address(&data, &marker);
+    }
+
+    return found;
+}
+
+static char *list_fields[] = {
+    "list-id",
+    "list-help",
+    "list-subscribe",
+    "list-unsubscribe",
+    "list-post",
+    "list-owner",
+    "list-archive",
+    NULL
+};
+ 
+/* Determine if we should respond to a vacation message */
+static int shouldRespond(void * m, sieve_interp_t *interp,
+			 int numaddresses, bytecode_input_t* bc,
+			 int i, char **from, char **to)
+{
+    const char **body;
+    char buf[128];
+    char *myaddr = NULL;
+    int l = SIEVE_OK, j;
+    void *data = NULL, *marker = NULL;
+    char *tmp;
+    int curra, x;
+    char *found=NULL;
+    char *reply_to=NULL;
+  
+    /* Implementations SHOULD NOT respond to any message that contains a
+       "List-Id" [RFC2919], "List-Help", "List-Subscribe", "List-
+       Unsubscribe", "List-Post", "List-Owner" or "List-Archive" [RFC2369]
+       header field. */
+    for (j = 0; list_fields[j]; j++) {
+	strcpy(buf, list_fields[j]);
+	if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	    l = SIEVE_DONE;
+	    break;
+	}
+    }
+
+    /* Implementations SHOULD NOT respond to any message that has an
+       "Auto-submitted" header field with a value other than "no".
+       This header field is described in [RFC3834]. */
+    strcpy(buf, "auto-submitted");
+    if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	/* we don't deal with comments, etc. here */
+	/* skip leading white-space */
+	while (*body[0] && isspace((int) *body[0])) body[0]++;
+	if (strcasecmp(body[0], "no")) l = SIEVE_DONE;
+    }
+
+    /* is there a Precedence keyword of "junk | bulk | list"? */
+    /* XXX  non-standard header, but worth checking */
+    strcpy(buf, "precedence");
+    if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	/* we don't deal with comments, etc. here */
+	/* skip leading white-space */
+	while (*body[0] && isspace((int) *body[0])) body[0]++;
+	if (!strcasecmp(body[0], "junk") ||
+	    !strcasecmp(body[0], "bulk") ||
+	    !strcasecmp(body[0], "list"))
+	    l = SIEVE_DONE;
+    }
+
+    /* Note: the domain-part of all addresses are canonicalized */
+    /* grab my address from the envelope */
+    if (l == SIEVE_OK) {
+	strcpy(buf, "to");
+	l = interp->getenvelope(m, buf, &body);
+	
+	if (body[0]) {  
+	    parse_address(body[0], &data, &marker);
+	    tmp = get_address(ADDRESS_ALL, &data, &marker, 1);
+	    myaddr = (tmp != NULL) ? xstrdup(tmp) : NULL;
+	    free_address(&data, &marker);
+	}  
+    }  
+  
+    if (l == SIEVE_OK) {
+	strcpy(buf, "from");
+	l = interp->getenvelope(m, buf, &body);
+    }
+    if (l == SIEVE_OK && body[0]) {
+	/* we have to parse this address & decide whether we
+	   want to respond to it */
+	parse_address(body[0], &data, &marker);
+	tmp = get_address(ADDRESS_ALL, &data, &marker, 1);
+	reply_to = (tmp != NULL) ? xstrdup(tmp) : NULL;
+	free_address(&data, &marker);
+
+	/* first, is there a reply-to address? */
+	if (reply_to == NULL) {
+	    l = SIEVE_DONE;
+	}
+    
+	/* first, is it from me? */
+	if (l == SIEVE_OK && !strcmp(myaddr, reply_to)) {
+	    l = SIEVE_DONE;
+	}
+   
+	/* ok, is it any of the other addresses i've
+	   specified? */
+	if (l == SIEVE_OK)
+	{
+	    curra=i;
+	    for(x=0; x<numaddresses; x++) {
+		const char *address;
+
+		curra = unwrap_string(bc, curra, &address, NULL);
+		
+		if (!strcmp(address, reply_to))
+		    l=SIEVE_DONE;
+	    }
+	}
+   
+	/* ok, is it a system address? */
+	if (l == SIEVE_OK && sysaddr(reply_to)) {
+	    l = SIEVE_DONE;
+	}
+    }
+    if (l == SIEVE_OK) {
+	/* ok, we're willing to respond to the sender.
+	   but is this message to me?  that is, is my address
+	   in the [Resent]-To, [Resent]-Cc or [Resent]-Bcc fields? */
+	if (strcpy(buf, "to"), 
+	    interp->getheader(m, buf, &body) == SIEVE_OK)
+	    found = look_for_me(myaddr, numaddresses ,bc, i, body);
+	if (!found && (strcpy(buf, "cc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found && (strcpy(buf, "bcc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found && (strcpy(buf, "resent-to"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses ,bc, i, body);
+	if (!found && (strcpy(buf, "resent-cc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found && (strcpy(buf, "resent-bcc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found)
+	    l = SIEVE_DONE;
+    }
+    /* ok, ok, if we got here maybe we should reply */
+    if (myaddr) free(myaddr);
+    *from=found;
+    *to=reply_to;
+    return l;
+}
+
+/* Evaluate a bytecode test */
+static int eval_bc_test(sieve_interp_t *interp,
+			struct hash_table *body_cache, void* m,
+			bytecode_input_t * bc, int * ip)
+{
+    int res=0; 
+    int i=*ip;
+    int x,y,z;/* loop variable */
+    int list_len; /* for allof/anyof/exists */
+    int list_end; /* for allof/anyof/exists */
+    int address=0;/*to differentiate between address and envelope*/
+    comparator_t * comp=NULL;
+    void * comprock=NULL;
+    int op= ntohl(bc[i].op);
+    
+    switch(op)
+    {
+    case BC_FALSE:
+	res=0; i++; break;
+
+    case BC_TRUE:
+	res=1; i++; break;
+
+    case BC_NOT:/*2*/
+	i+=1;
+	res = eval_bc_test(interp, body_cache, m, bc, &i);
+	if(res >= 0) res = !res; /* Only invert in non-error case */
+	break;
+
+    case BC_EXISTS:/*3*/
+    {
+	int headersi=i+1;
+	const char** val;
+	int currh;
+
+	res=1;
+
+	list_len=ntohl(bc[headersi].len);
+	list_end=ntohl(bc[headersi+1].value)/4;
+
+	currh=headersi+2;
+
+	for(x=0; x<list_len && res; x++)
+	{
+	    const char *str;
+
+	    currh = unwrap_string(bc, currh, &str, NULL);
+	    
+	    if(interp->getheader(m,str, &val) != SIEVE_OK)
+		res = 0;
+	}
+
+	i=list_end; /* adjust for short-circuit */
+	break;
+    }
+    case BC_SIZE:/*4*/
+    {
+	int s;
+	int sizevar=ntohl(bc[i+1].value);
+	int x=ntohl(bc[i+2].value);
+	
+	if (interp->getsize(m, &s) != SIEVE_OK)
+	    break;
+	
+	if (sizevar ==B_OVER) {
+	    /* over */
+	    res= s > x;
+	} else {
+            /* under */
+	    res= s < x;
+	}
+	i+=3;
+	break;
+    }
+    case BC_ANYOF:/*5*/
+	res = 0;
+	list_len=ntohl(bc[i+1].len);
+	list_end=ntohl(bc[i+2].len)/4;
+	i+=3;
+
+	/* need to process all of them, to ensure our instruction pointer stays
+	 * in the right place */
+	for (x=0; x<list_len && !res; x++) { 
+	    int tmp;
+	    tmp = eval_bc_test(interp,body_cache,m,bc,&i);
+	    if(tmp < 0) {
+		res = tmp;
+		break;
+	    }
+	    res = res || tmp;
+	}
+
+	i = list_end; /* handle short-circuting */
+
+	break; 
+    case BC_ALLOF:/*6*/ 
+        res = 1;     
+	list_len=ntohl(bc[i+1].len);
+	list_end=ntohl(bc[i+2].len)/4;
+	i+=3;
+
+	/* return 1 unless you find one that isn't true, then return 0 */
+	for (x=0; x<list_len && res; x++) {
+	    int tmp;
+	    tmp = eval_bc_test(interp,body_cache,m,bc,&i);
+	    if(tmp < 0) {
+		res = tmp;
+		break;
+	    }
+	    res = res && tmp; 
+	}
+
+	i = list_end; /* handle short-circuiting */
+	
+	break;
+    case BC_ADDRESS:/*7*/
+	address=1;
+	/* fall through */
+    case BC_ENVELOPE:/*8*/
+    {
+	const char ** val;
+	void * data=NULL;
+	void * marker=NULL;
+	char * addr;
+	int addrpart=ADDRESS_ALL;/* XXX correct default behavior?*/
+
+ 	int headersi=i+5;/* the i value for the begining of the headers */
+	int datai=(ntohl(bc[headersi+1].value)/4);
+
+	int numheaders=ntohl(bc[headersi].len);
+	int numdata=ntohl(bc[datai].len);
+
+	int currh, currd; /* current header, current data */
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int apart=ntohl(bc[i+4].value);
+	int count=0;
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, as regexps are tested at compile */
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB;
+	    }
+	}
+
+	/*find the correct comparator fcn*/
+	comp = lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+	
+	/*find the part of the address that we want*/
+	switch(apart)
+	{
+	case B_ALL:
+	    addrpart = ADDRESS_ALL; break;
+	case B_LOCALPART:
+	    addrpart = ADDRESS_LOCALPART; break;
+	case B_DOMAIN:
+	    addrpart = ADDRESS_DOMAIN; break;
+	case B_USER:
+	    addrpart = ADDRESS_USER; break;
+	case B_DETAIL:
+	    addrpart = ADDRESS_DETAIL; break;
+	default:
+	    /* this shouldn't happen with correcct bytecode */
+	    res = SIEVE_RUN_ERROR;
+	}
+
+	if(res == SIEVE_RUN_ERROR) break;
+
+	/*loop through all the headers*/
+	currh=headersi+2;
+#if VERBOSE
+	printf("about to process %d headers\n", numheaders);
+#endif
+	for (x=0; x<numheaders && !res; x++)
+	{
+	    const char *this_header;
+
+	    currh = unwrap_string(bc, currh, &this_header, NULL);
+	    
+	    /* Try the next string if we don't have this one */
+	    if(address) {
+		/* Header */
+		if(interp->getheader(m, this_header, &val) != SIEVE_OK)
+		    continue;
+#if VERBOSE
+                printf(" [%d] header %s is %s\n", x, this_header, val[0]);
+#endif
+	    } else {
+		/* Envelope */
+		if(interp->getenvelope(m, this_header, &val) != SIEVE_OK)
+		    continue;
+	    }
+	
+	    /*header exists, now to test it*/
+	    /*search through all the headers that match*/
+	    
+	    for (y=0; val[y]!=NULL && !res; y++) {
+		
+#if VERBOSE
+		printf("about to parse %s\n", val[y]);
+#endif
+		    
+		if (parse_address(val[y], &data, &marker)!=SIEVE_OK) 
+		    return 0;
+		    
+		while (!res &&
+		       (addr = get_address(addrpart, &data, &marker, 0))) {
+#if VERBOSE
+		    printf("working addr %s\n", (addr ? addr : "[nil]"));
+#endif
+			
+		    if (match == B_COUNT) {
+			count++;
+		    } else {
+			/*search through all the data*/ 
+			currd=datai+2;
+			for (z=0; z<numdata && !res; z++)
+			{
+			    const char *data_val;
+			    
+			    currd = unwrap_string(bc, currd, &data_val, NULL);
+
+			    if (isReg) {
+				reg = bc_compile_regex(data_val, ctag,
+						       errbuf, sizeof(errbuf));
+				if (!reg) {
+				    /* Oops */
+				    res=-1;
+				    goto alldone;
+				}
+
+				res |= comp(val[y], strlen(val[y]),
+					    (const char *)reg, comprock);
+				free(reg);
+			    } else {
+#if VERBOSE
+				printf("%s compared to %s(from script)\n",
+				       addr, data_val);
+#endif 
+				res |= comp(addr, strlen(addr),
+					    data_val, comprock);
+			    }
+			} /* For each data */
+		    }
+		} /* For each address */
+
+		free_address(&data, &marker);
+	    }/* For each message header */
+	    
+#if VERBOSE
+	    printf("end of loop, res is %d, x is %d (%d)\n", res, x, numheaders);
+#endif	    
+	} /* For each script header */
+     
+	if  (match == B_COUNT)
+	{
+	    sprintf(scount, "%u", count);
+	    /* search through all the data */ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    {
+		const char *data_val;
+		
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+
+		res |= comp(scount, strlen(scount), data_val, comprock);
+	    }
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    case BC_HEADER:/*9*/
+    {
+	const char** val;
+
+	int headersi=i+4;/*the i value for the begining of hte headers*/
+	int datai=(ntohl(bc[headersi+1].value)/4);
+
+	int numheaders=ntohl(bc[headersi].len);
+	int numdata=ntohl(bc[datai].len);
+
+	int currh, currd; /*current header, current data*/
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int count=0;	
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, regexps tested at compile */ 
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag= REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag= REG_EXTENDED | REG_NOSUB;
+	    }
+     
+	}
+	
+	/*find the correct comparator fcn*/
+	comp=lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+
+	/*search through all the flags for the header*/
+	currh=headersi+2;
+	for(x=0; x<numheaders && !res; x++)
+	{
+	    const char *this_header;
+	    
+	    currh = unwrap_string(bc, currh, &this_header, NULL);
+	   
+	    if(interp->getheader(m, this_header, &val) != SIEVE_OK) {
+		continue; /*this header does not exist, search the next*/ 
+	    }
+#if VERBOSE
+	    printf ("val %s %s %s\n", val[0], val[1], val[2]);
+#endif
+	    
+	    /* search through all the headers that match */
+	    
+	    for (y=0; val[y]!=NULL && !res; y++)
+	    {
+		if  (match == B_COUNT) {
+		    count++;
+		} else {
+		    /*search through all the data*/ 
+		    currd=datai+2;
+		    for (z=0; z<numdata && !res; z++)
+		    {
+			const char *data_val;
+			
+			currd = unwrap_string(bc, currd, &data_val, NULL);
+			
+			if (isReg) {
+			    reg= bc_compile_regex(data_val, ctag, errbuf,
+						  sizeof(errbuf));
+			    if (!reg)
+			    {
+				/* Oops */
+				res=-1;
+				goto alldone;
+			    }
+			    
+			    res |= comp(val[y], strlen(val[y]),
+					(const char *)reg, comprock);
+			    free(reg);
+			} else {
+			    res |= comp(val[y], strlen(val[y]),
+					data_val, comprock);
+			}
+		    }
+		}
+	    }
+	}
+	
+	if  (match == B_COUNT )
+	{
+	    sprintf(scount, "%u", count);
+	    /*search through all the data*/ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    { 	
+		const char *data_val;
+			
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+#if VERBOSE
+		printf("%d, %s \n", count, data_val);
+#endif
+		res |= comp(scount, strlen(scount), data_val, comprock);
+	    }
+	      
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    case BC_BODY:/*10*/
+    {
+	sieve_bodypart_t *val;
+	const char **content_types = NULL;
+
+	int typesi=i+6;/* the i value for the begining of the content-types */
+ 	int datai=(ntohl(bc[typesi+1].value)/4);
+
+	int numdata=ntohl(bc[datai].len);
+
+	int currd; /* current data */
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int transform=ntohl(bc[i+4].value);
+	/*int offset=ntohl(bc[i+5].value);*/
+	int count=0;
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, as regexps are tested at compile */
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB;
+	    }
+	}
+
+	/*find the correct comparator fcn*/
+	comp = lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+	
+	/*find the part(s) of the body that we want*/
+	content_types = bc_makeArray(bc, &typesi);
+	if(interp->getbody(m, content_types, transform != B_RAW, &val) != SIEVE_OK) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+	free(content_types);
+	
+	/* bodypart(s) exist, now to test them */
+	    
+	for (y=0; val[y].content!=NULL && !res; y++) {
+
+	    if (match == B_COUNT) {
+		count++;
+	    } else {
+		const char *content = val[y].content;
+		size_t size = val[y].size;
+
+		/* search through all the data */ 
+		currd=datai+2;
+		for (z=0; z<numdata && !res; z++)
+		{
+		    const char *data_val;
+			    
+		    currd = unwrap_string(bc, currd, &data_val, NULL);
+
+		    if (isReg) {
+			reg = bc_compile_regex(data_val, ctag,
+					       errbuf, sizeof(errbuf));
+			if (!reg) {
+			    /* Oops */
+			    res=-1;
+			    goto alldone;
+			}
+
+			res |= comp(content, size, (const char *)reg, comprock);
+			free(reg);
+		    } else {
+			res |= comp(content, size, data_val, comprock);
+		    }
+		} /* For each data */
+	    }
+
+	} /* For each body part */
+
+	if  (match == B_COUNT)
+	{
+	    sprintf(scount, "%u", count);
+	    /* search through all the data */ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    {
+		const char *data_val;
+		
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+
+		res |= comp(scount, strlen(scount), data_val, comprock);
+	    }
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    default:
+#if VERBOSE
+	printf("WERT, can't evaluate if statement. %d is not a valid command",
+	       op);
+#endif     
+	return SIEVE_RUN_ERROR;
+    }
+    
+  
+ alldone:
+    
+    *ip=i;
+    return res;
+}
+
+/* The entrypoint for bytecode evaluation */
+int sieve_eval_bc(sieve_execute_t *exe, int is_incl, sieve_interp_t *i,
+		  struct hash_table *body_cache, void *sc, void *m,
+		  sieve_imapflags_t * imapflags, action_list_t *actions,
+		  notify_list_t *notify_list, const char **errmsg) 
+{
+    const char *data;
+    int res=0;
+    int op;
+    int version;
+  
+    sieve_bytecode_t *bc_cur = exe->bc_cur;
+    bytecode_input_t *bc = (bytecode_input_t *) bc_cur->data;
+    int ip = 0, ip_max = (bc_cur->len/sizeof(bytecode_input_t));
+
+    if (bc_cur->is_executing) {
+	*errmsg = "Recursive Include";
+	return SIEVE_RUN_ERROR;
+    }
+    bc_cur->is_executing = 1;
+    
+    /* Check that we
+     * a) have bytecode
+     * b) it is atleast long enough for the magic number, the version
+     *    and one opcode */
+    if(!bc) return SIEVE_FAIL;
+    if(bc_cur->len < (BYTECODE_MAGIC_LEN + 2*sizeof(bytecode_input_t)))
+       return SIEVE_FAIL;
+
+    if(memcmp(bc, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	*errmsg = "Not a bytecode file";
+	return SIEVE_FAIL;
+    }
+
+    ip = BYTECODE_MAGIC_LEN / sizeof(bytecode_input_t);
+
+    version= ntohl(bc[ip].op);
+
+    /* this is because there was a time where integers were not network byte
+       order.  all the scripts written then would have version 0x01 written
+       in host byte order.*/
+
+     if(version == (int)ntohl(1)) {
+	if(errmsg) {
+	    *errmsg =
+		"Incorrect Bytecode Version, please recompile (use sievec)";
+	    
+	}
+	return SIEVE_FAIL;
+    }
+    
+    if((version < BYTECODE_MIN_VERSION) || (version > BYTECODE_VERSION)) {
+	if(errmsg) {
+	    *errmsg =
+		"Incorrect Bytecode Version, please recompile (use sievec)";
+	}
+	return SIEVE_FAIL;
+    }
+
+#if VERBOSE
+    printf("version number %d\n",version); 
+#endif
+
+    for(ip++; ip<ip_max; ) { 
+	int copy = 0;
+
+	op=ntohl(bc[ip].op);
+	switch(op) {
+	case B_STOP:/*0*/
+	    res=1;
+	    break;
+
+	case B_KEEP:/*1*/
+	    res = do_keep(actions, imapflags);
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Keep can not be used with Reject";
+	    ip++;
+	    break;
+
+	case B_DISCARD:/*2*/
+	    res=do_discard(actions);
+	    ip++;
+	    break;
+
+	case B_REJECT:/*3*/
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+	    
+	    res = do_reject(actions, data);
+	
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Reject can not be used with any other action";  
+
+	    break;
+
+	case B_FILEINTO:/*19*/
+	    copy = ntohl(bc[ip+1].value);
+	    ip+=1;
+
+	case B_FILEINTO_ORIG:/*4*/
+	{
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+
+	    res = do_fileinto(actions, data, !copy, imapflags);
+
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Fileinto can not be used with Reject";
+
+	    break;
+	}
+
+	case B_REDIRECT:/*20*/
+	    copy = ntohl(bc[ip+1].value);
+	    ip+=1;
+
+	case B_REDIRECT_ORIG:/*5*/
+	{
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+
+	    res = do_redirect(actions, data, !copy);
+
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Redirect can not be used with Reject";
+
+	    break;
+	}
+
+	case B_IF:/*6*/
+	{
+	    int testend=ntohl(bc[ip+1].value);
+	    int result;
+	   
+	    ip+=2;
+	    result=eval_bc_test(i, body_cache, m, bc, &ip);
+	    
+	    if (result<0) {
+		*errmsg = "Invalid test";
+		return SIEVE_FAIL;
+	    } else if (result) {
+	    	/*skip over jump instruction*/
+		testend+=2;
+	    }
+	    ip=testend;
+	    
+	    break;
+	}
+
+	case B_MARK:/*8*/
+	    res = do_mark(actions);
+	    ip++;
+	    break;
+
+	case B_UNMARK:/*9*/
+	    res = do_unmark(actions);
+	    ip++;
+	    break;
+
+	case B_ADDFLAG:/*10*/ 
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    for (x=0; x<list_len; x++) {
+		ip = unwrap_string(bc, ip, &data, NULL);
+		
+		res = do_addflag(actions, data);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "addflag can not be used with Reject";
+	    } 
+	    break;
+	}
+
+	case B_SETFLAG:
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    ip = unwrap_string(bc, ip, &data, NULL);
+
+	    res = do_setflag(actions, data);
+
+	    if (res == SIEVE_RUN_ERROR) {
+		*errmsg = "setflag can not be used with Reject";
+	    } else {
+		for (x=1; x<list_len; x++) {
+		    ip = unwrap_string(bc, ip, &data, NULL);
+
+		    res = do_addflag(actions, data);
+
+		    if (res == SIEVE_RUN_ERROR)
+			*errmsg = "setflag can not be used with Reject";
+		} 
+	    }
+	    
+	    break;
+	}
+
+	case B_REMOVEFLAG:
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    for (x=0; x<list_len; x++) {
+		ip = unwrap_string(bc, ip, &data, NULL);
+
+		res = do_removeflag(actions, data);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "removeflag can not be used with Reject";
+	    } 
+	    break;
+	}
+
+	case B_NOTIFY:
+	{
+	    const char * id;
+	    const char * method;
+	    const char **options = NULL;
+	    const char *priority = NULL;
+	    const char * message;
+	    int pri;
+	    
+	    ip++;
+
+	    /* method */
+	    ip = unwrap_string(bc, ip, &method, NULL);
+
+	    /* id */
+	    ip = unwrap_string(bc, ip, &id, NULL);
+
+	    /*options*/
+	    options=bc_makeArray(bc, &ip); 
+
+	    /* priority */
+	    pri=ntohl(bc[ip].value);
+	    ip++;
+	    
+	    switch (pri)
+	    {
+	    case B_LOW:
+		priority="low";
+	    case B_NORMAL:
+		priority="normal";
+		break;
+	    case B_HIGH: 
+		priority="high";
+		break; 
+	    case B_ANY:
+		priority="any";
+		break;
+	    default:
+		res=SIEVE_RUN_ERROR;
+	    }
+
+	    /* message */
+	    ip = unwrap_string(bc, ip, &message, NULL);
+	  
+	    res = do_notify(notify_list, id, method, options,
+			    priority, message);
+
+	    break;
+	}
+	case B_DENOTIFY:
+	{
+         /*
+	  * i really have no idea what the count matchtype should do here.
+	  * the sanest thing would be to use 1.
+	  * however that would require passing on the match type to do_notify.
+	  *  -jsmith2
+	  */
+
+	    comparator_t *comp = NULL;
+	    
+	    const char *pattern;
+	    regex_t *reg;
+	    
+	    const char *priority = NULL;
+	    void *comprock = NULL;
+	    
+	    int comparator;
+	    int pri;
+	    
+	    ip++;
+	    pri=ntohl(bc[ip].value);
+	    ip++;
+	    
+	    switch (pri)
+	    {
+	    case B_LOW:
+		priority="low";		
+	    case B_NORMAL:
+		priority="normal";
+		break;
+	    case B_HIGH: 
+		priority="high";
+		break; 
+	    case B_ANY:
+		priority="any";
+		break;
+	    default:
+		res=SIEVE_RUN_ERROR;
+	    }
+
+	    if(res == SIEVE_RUN_ERROR)
+		break;
+	   
+	    comparator =ntohl( bc[ip].value);
+	    ip++;
+	    
+	    if (comparator == B_ANY)
+	    { 
+		ip++;/* skip placeholder this has no comparator function */
+		comp=NULL;
+	    } else {
+		int x= ntohl(bc[ip].value);
+		ip++;
+		
+		comp=lookup_comp(B_ASCIICASEMAP,comparator,
+				 x, &comprock);
+	    }
+	    
+	    ip = unwrap_string(bc, ip, &pattern, NULL);
+	  
+	    if (comparator == B_REGEX)
+	    {	
+		char errmsg[1024]; /* Basically unused */
+		
+		reg=bc_compile_regex(pattern,
+				     REG_EXTENDED | REG_NOSUB | REG_ICASE,
+				     errmsg, sizeof(errmsg));
+		if (!reg) {
+		    res = SIEVE_RUN_ERROR;
+		} else {
+		    res = do_denotify(notify_list, comp, reg,
+				      comprock, priority);
+		    free(reg);
+		}
+	    } else {
+		res = do_denotify(notify_list, comp, pattern,
+				  comprock, priority);
+	    }
+	    
+	    break;
+	}
+	case B_VACATION:
+	{
+	    int respond;
+	    char *fromaddr = NULL; /* relative to message we send */
+	    char *toaddr = NULL; /* relative to message we send */
+	    const char *handle = NULL;
+	    const char *message = NULL;
+	    int days, mime;
+	    char buf[128];
+	    char subject[1024];
+	    int x;
+	    
+	    ip++;
+
+	    x=ntohl( bc[ip].len);
+	    
+	    respond=shouldRespond(m, i, x, bc, ip+2,
+				  &fromaddr, &toaddr);
+	    
+	    ip=(ntohl(bc[ip+1].value)/4);	
+	    if (respond==SIEVE_OK)
+	    {	 
+		ip = unwrap_string(bc, ip, &data, NULL);
+		
+		if (!data) 
+		{
+		    /* we have to generate a subject */
+		    const char **s;	    
+		    strlcpy(buf, "subject", sizeof(buf));
+		    if (i->getheader(m, buf, &s) != SIEVE_OK ||
+			s[0] == NULL) {
+			strlcpy(subject, "Automated reply", sizeof(subject));
+		    } else {
+			/* s[0] contains the original subject */
+			const char *origsubj = s[0];
+
+			snprintf(subject, sizeof(subject), "Auto: %s", origsubj);
+		    }
+		} else {
+		    /* user specified subject */
+		    strlcpy(subject, data, sizeof(subject));
+		}
+		
+		ip = unwrap_string(bc, ip, &message, NULL);
+
+		days = ntohl(bc[ip].value);
+		mime = ntohl(bc[ip+1].value);
+
+		ip+=2;	
+
+		if (version >= 0x05) {
+		    ip = unwrap_string(bc, ip, &data, NULL);
+
+		    if (data) {
+			/* user specified from address */
+			free(fromaddr);
+			fromaddr = xstrdup(data);
+		    }
+
+		    ip = unwrap_string(bc, ip, &data, NULL);
+
+		    if (data) {
+			/* user specified handle */
+			handle = data;
+		    }
+		}
+
+		res = do_vacation(actions, toaddr, fromaddr, xstrdup(subject),
+				  message, days, mime, handle);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "Vacation can not be used with Reject or Vacation";
+	    } else if (respond == SIEVE_DONE) {
+                /* skip subject and message */
+
+		ip = unwrap_string(bc, ip, &data, NULL);
+		ip = unwrap_string(bc, ip, &data, NULL);
+
+		ip+=2;/*skip days and mime flag*/
+
+		if (version >= 0x05) {
+		    /* skip from and handle */
+		    ip = unwrap_string(bc, ip, &data, NULL);
+		    ip = unwrap_string(bc, ip, &data, NULL);
+		}
+	    } else {
+		res = SIEVE_RUN_ERROR; /* something is bad */ 
+	    }
+
+	    break;
+	}
+	case B_NULL:/*15*/
+	    ip++;
+	    break;
+
+	case B_JUMP:/*16*/
+	    ip= ntohl(bc[ip+1].jump);
+	    break;
+	    
+	case B_INCLUDE:/*17*/
+	{
+	    int isglobal = (ntohl(bc[ip+1].value) == B_GLOBAL);
+	    char fpath[4096];
+
+	    ip = unwrap_string(bc, ip+2, &data, NULL);
+
+	    res = i->getinclude(sc, data, isglobal, fpath, sizeof(fpath));
+	    if (res != SIEVE_OK)
+		*errmsg = "Include can not find script";
+
+	    if (!res) {
+		res = sieve_script_load(fpath, &exe);
+		if (res != SIEVE_OK)
+		*errmsg = "Include can not load script";
+	    }
+
+	    if (!res)
+		res = sieve_eval_bc(exe, 1, i, body_cache,
+				    sc, m, imapflags, actions,
+				    notify_list, errmsg);
+
+	    break;
+	}
+
+	case B_RETURN:/*18*/
+	    if (is_incl)
+		goto done;
+	    else
+		res=1;
+	    break;
+
+	default:
+	    if(errmsg) *errmsg = "Invalid sieve bytecode";
+	    return SIEVE_FAIL;
+	}
+      
+	if (res) /* we've either encountered an error or a stop */
+	    break;
+    }
+
+  done:
+    bc_cur->is_executing = 0;
+
+    return res;      
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_generate.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_generate.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/bc_generate.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bc_generate.c	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,808 @@
+/* bc_generate.c -- sieve bytecode- almost flattened bytecode
+ * Rob Siemborski
+ * $Id$
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xmalloc.h"
+#include "sieve_interface.h"
+
+#include "script.h"
+#include "tree.h"
+#include "sieve.h"
+
+#include "bytecode.h"
+
+#include <assert.h>
+#include <string.h>
+
+
+
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+static int bc_test_generate(int codep, bytecode_info_t *retval, test_t *t);
+
+/* returns false if the request can't be satisfied, true if it can. */
+
+static int atleast(bytecode_info_t *arr, size_t len) 
+{
+    if(arr->reallen < len) {
+	/* too small; double if that's big enough, otherwise increase to the
+	   requested size. */
+	arr->reallen = (len > arr->reallen * 2 ? len : arr->reallen * 2);
+	arr->data = xrealloc(arr->data, arr->reallen*sizeof(bytecode_t));
+	if(!arr->data) 
+	{ /* out of memory? */
+	    return 0;
+	}
+    }
+    
+    return 1;
+}
+
+/*
+ * functions of the form bc_XXX_generate have the following properties:
+ * on success they return an int that corresponds to the next empty location
+ * for code, and on failure they return -1.
+ *
+ *  they will take a  bytecode_info_t as a parameter and modify it by
+ *  making it larger and adding more bytecommands in the pass 1 form
+ */
+
+/* given a location and a string list, compile it into almost-flat form.
+ * <list len> <string len><string ptr><string len><string ptr> etc... */
+static int bc_stringlist_generate(int codep, bytecode_info_t *retval,
+				  stringlist_t *sl) 
+{
+    int len_codep = codep;
+    int strcount = 0;
+    stringlist_t *cur;
+    
+    codep++;
+
+    /* Bounds check the string list length */
+    if(!atleast(retval,codep+1)) 
+	return -1;
+
+    for(cur=sl; cur; cur=cur->next) 
+    {
+	strcount++;
+	assert((cur->s)!=NULL);
+	
+	/* Bounds check for each string before we allocate it */
+	if(!atleast(retval,codep+2)) 
+	    return -1;
+
+	retval->data[codep++].len = strlen(cur->s);
+	retval->data[codep++].str = cur->s;
+    }
+    
+    retval->data[len_codep].listlen = strcount;
+    return codep;
+}
+
+
+/* write a list of tests into almost-flat form, starting at codep.
+ * returns the next code location, -1 on error. */
+
+/* <list len> <next test ptr> <test ...> <next test ptr> <test ...> ... */
+static int bc_testlist_generate(int codep, bytecode_info_t *retval, 
+				testlist_t *tl) 
+{
+    int len_codep = codep;
+    int testcount = 0;
+    testlist_t *cur;
+    
+    codep++;
+
+    /* Bounds check the test list length */
+    if(!atleast(retval,codep+1)) 
+	return -1;
+       
+    for(cur=tl; cur; cur=cur->next) {
+	int oldcodep = codep;
+
+	/* Make room for tail marker */
+	if(!atleast(retval,codep+1)) 
+	    return -1;
+
+	testcount++;
+	codep = bc_test_generate(codep+1, retval, cur->t);
+
+	retval->data[oldcodep].jump = codep;
+    }
+
+    retval->data[len_codep].listlen = testcount;
+        
+    return codep;
+}
+/* output a relation into almost-flat form at codep.
+ * returns new codep on success, -1 on failure. */
+static int bc_relation_generate(int codep, bytecode_info_t *retval, int relat)
+{
+    if (!atleast(retval, codep + 1)) return -1;
+    switch (relat)
+    {
+    case GT:
+	retval->data[codep++].value= B_GT;
+	break;
+    case GE:
+	retval->data[codep++].value= B_GE;
+	break; 
+    case LT:
+	retval->data[codep++].value= B_LT;
+	break;
+    case LE:
+	retval->data[codep++].value= B_LE;
+	break;
+    case EQ:
+	retval->data[codep++].value= B_EQ;
+	break;
+    case NE:
+	retval->data[codep++].value= B_NE;
+	break;
+    default:
+	/* comparator has no relational field */
+	retval->data[codep++].value=  -1;
+	break;
+    }
+    return codep;
+}
+/* writes a single comparator into almost-flat form starting at codep.
+ * will always write out 3 words
+ * returns the next code location or -1 on error. */
+static int bc_comparator_generate(int codep, bytecode_info_t *retval,
+                                  int comptag, int relat,
+                                  const char *comparator)
+{
+    assert(retval != NULL);
+
+    /* comptag */
+    if (!atleast(retval, codep + 1)) return -1;
+
+    switch (comptag) {
+    case IS:
+        retval->data[codep++].value = B_IS;
+        break;
+    case CONTAINS:
+        retval->data[codep++].value = B_CONTAINS;
+        break;
+    case MATCHES:
+        retval->data[codep++].value = B_MATCHES;
+        break;
+#ifdef ENABLE_REGEX
+    case REGEX:
+        retval->data[codep++].value = B_REGEX;
+        break;
+#endif
+    case COUNT:
+        retval->data[codep++].value = B_COUNT;
+        break;
+    case VALUE:
+        retval->data[codep++].value = B_VALUE;
+        break;
+
+    default:
+        return -1;
+    }
+  
+    /*relation*/
+    codep = bc_relation_generate(codep, retval, relat);
+  
+    /* comparator (value specified with :comparator) */
+    if (!atleast(retval, codep + 1)) return -1;
+  
+    /* xxx perhaps extend comparator.h to have
+       lookup_comp return an index, and then
+       lookup_by_index return the actual comparator?
+       
+       we can then eliminate the comptag above, too. */
+    
+    if (!strcmp (comparator, "i;octet"))
+        retval->data[codep++].value = B_OCTET;
+    else if (!strcmp (comparator, "i;ascii-casemap"))
+        retval->data[codep++].value = B_ASCIICASEMAP;
+    else if (!strcmp (comparator, "i;ascii-numeric"))
+        retval->data[codep++].value = B_ASCIINUMERIC;
+
+    return codep;
+}
+
+
+
+/* writes a single test into almost-flat form starting at codep.
+ * returns the next code location or -1 on error. */
+static int bc_test_generate(int codep, bytecode_info_t *retval, test_t *t)
+{
+    if(!retval) return -1;
+    switch(t->type) {
+    case STRUE: /* BC_TRUE */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_TRUE;
+	break;
+    case SFALSE:/* BC_FALSE */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_FALSE;
+	break;
+    case NOT: /* BC_NOT {subtest : test} */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_NOT;
+	codep = bc_test_generate(codep, retval, t->u.t);
+	if (codep == -1) return -1;
+	break;
+    case SIZE: /* BC_SIZE (B_OVER | B_UNDER) {size : int} */
+	if(!atleast(retval,codep+3)) return -1;
+	retval->data[codep++].op = BC_SIZE;
+	retval->data[codep++].value = (t->u.sz.t == OVER
+				       ? B_OVER : B_UNDER);
+	retval->data[codep++].value = t->u.sz.n;
+	break;
+    case EXISTS:/* BC_EXISTS { headers : string list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_EXISTS;
+	codep= bc_stringlist_generate(codep, retval, t->u.sl);
+	break;
+    case ANYOF:/* BC_ANYOF { tests : test list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_ANYOF;
+	codep=bc_testlist_generate(codep, retval, t->u.tl);
+	if (codep == -1) return -1;
+	break;
+    case ALLOF: /* BC_ALLOF { tests : test list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_ALLOF;
+	codep= bc_testlist_generate(codep, retval, t->u.tl);
+	if (codep == -1) return -1;
+	break;
+    case HEADER:
+	/* BC_HEADER { c: comparator } { headers : string list }
+	   { patterns : string list } 
+	*/
+      
+	if(!atleast(retval,codep + 1)) return -1;
+	retval->data[codep++].op = BC_HEADER;
+      
+	/* comparator */
+	codep = bc_comparator_generate(codep, retval,
+				       t->u.h.comptag,
+				       t->u.h.relation,
+				       t->u.h.comparator);
+	if (codep == -1) return -1;
+      
+	/* headers */
+	codep = bc_stringlist_generate(codep, retval, t->u.h.sl);
+	if (codep == -1) return -1;
+      
+	/* pattern */
+	codep = bc_stringlist_generate(codep, retval, t->u.h.pl);
+	if (codep == -1) return -1;
+	break;
+    case ADDRESS:
+    case ENVELOPE:
+	/* (BC_ADDRESS | BC_ENVELOPE) {c : comparator} 
+	   (B_ALL | B_LOCALPART | ...) { header : string list }
+	   { pattern : string list } */
+      
+	if(!atleast(retval,codep+1)) return -1;
+      
+	retval->data[codep++].op = (t->type == ADDRESS)
+	    ? BC_ADDRESS : BC_ENVELOPE;
+            
+	codep = bc_comparator_generate(codep, retval,t->u.ae.comptag,
+				       t->u.ae.relation, 
+				       t->u.ae.comparator);
+	if (codep == -1) return -1;
+
+	if(!atleast(retval,codep+1)) return -1;
+
+	/*address part*/
+	switch(t->u.ae.addrpart) {
+	case ALL:
+	    retval->data[codep++].value = B_ALL;
+	    break;
+	case LOCALPART:
+	    retval->data[codep++].value = B_LOCALPART;
+	    break;
+	case DOMAIN:
+	    retval->data[codep++].value = B_DOMAIN;
+	    break;
+	case USER:
+	    retval->data[codep++].value = B_USER;
+	    break;
+	case DETAIL:
+	    retval->data[codep++].value = B_DETAIL;
+	    break;
+	default:
+	    return -1;
+	}
+
+	/*headers*/
+	codep = bc_stringlist_generate(codep, retval, t->u.ae.sl);
+	if (codep == -1) return -1;
+
+	/*patterns*/
+	codep = bc_stringlist_generate(codep, retval, t->u.ae.pl);
+	if (codep == -1) return -1;
+     
+	break;
+    case BODY:
+	/* BC_BODY {c : comparator} (B_RAW | B_TEXT | ...)
+	   { content-types : stringlist }
+	   { offset : int }
+	   { pattern : string list } */
+      
+	if(!atleast(retval,codep+1)) return -1;
+      
+	retval->data[codep++].op = BC_BODY;
+            
+	codep = bc_comparator_generate(codep, retval,t->u.b.comptag,
+				       t->u.b.relation, 
+				       t->u.b.comparator);
+	if (codep == -1) return -1;
+
+	if(!atleast(retval,codep+2)) return -1;
+
+	/*transform*/
+	switch(t->u.b.transform) {
+	case RAW:
+	    retval->data[codep++].value = B_RAW;
+	    break;
+	case TEXT:
+	    retval->data[codep++].value = B_TEXT;
+	    break;
+	case CONTENT:
+	    retval->data[codep++].value = B_CONTENT;
+	    break;
+	default:
+	    return -1;
+	}
+
+	/*offset*/
+	retval->data[codep++].value = t->u.b.offset;
+
+	/*content-types*/
+	codep = bc_stringlist_generate(codep, retval, t->u.b.content_types);
+	if (codep == -1) return -1;
+
+	/*patterns*/
+	codep = bc_stringlist_generate(codep, retval, t->u.b.pl);
+	if (codep == -1) return -1;
+     
+	break;
+    default:
+	return -1;
+      
+    }
+    return codep;
+}
+
+
+/* generate a not-quite-flattened bytecode */
+/* returns address of next instruction or -1 on error*/
+/* needs current instruction, buffer for the code, and a current parse tree */
+/* sieve is cool because everything is immediate! */
+static int bc_action_generate(int codep, bytecode_info_t *retval,
+			      commandlist_t *c) 
+{
+    int jumploc,baseloc;
+
+    if(!retval) return -1;
+    if (c==NULL)
+    {
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = B_NULL;
+    }
+    else
+    {
+	do {
+	    switch(c->type) {
+	    case STOP:
+		/* STOP (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_STOP;
+		break;
+	    case DISCARD:
+		/* DISCARD (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_DISCARD;
+		break;
+	    case KEEP:
+		/* KEEP (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_KEEP;
+		break;
+	    case MARK:
+		/* MARK (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_MARK;
+		break;
+	    case UNMARK:
+		/* UNMARK (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_UNMARK;
+		break;
+
+	    case RETURN:
+		/* RETURN (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_RETURN;
+		break;
+
+	    case DENOTIFY:
+		/* DENOTIFY  */
+		if(!atleast(retval,codep+6)) return -1;
+		retval->data[codep++].op = B_DENOTIFY;
+		switch(c->u.d.priority) {
+		case LOW:
+		    retval->data[codep++].value = B_LOW;
+		    break;
+		case NORMAL:
+		    retval->data[codep++].value = B_NORMAL;
+		    break;
+		case HIGH:
+		    retval->data[codep++].value = B_HIGH;
+		    break;
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break;
+		default:
+		    return -1;
+		}
+		switch(c->u.d.comptag) {
+		case IS:
+		    retval->data[codep++].value = B_IS;
+		    break;
+		case CONTAINS:
+		    retval->data[codep++].value = B_CONTAINS;
+		    break;
+		case MATCHES:
+		    retval->data[codep++].value = B_MATCHES;
+		    break;
+#ifdef ENABLE_REGEX
+		case REGEX:
+		    retval->data[codep++].value = B_REGEX;
+		    break;
+#endif
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break; 
+		default:
+		    return -1;
+		}
+		codep = bc_relation_generate(codep, retval, c->u.d.relation);
+	
+		if(c->u.d.pattern)
+		{
+		    retval->data[codep++].len = strlen(c->u.d.pattern);
+		    retval->data[codep++].str = c->u.d.pattern;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		break;
+	    case REJCT:
+		/* REJECT (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_REJECT;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case FILEINTO:
+		/* FILEINTO
+		   VALUE copy
+		   STRING folder
+		*/
+		if(!atleast(retval,codep+4)) return -1;
+		retval->data[codep++].op = B_FILEINTO;
+		retval->data[codep++].value = c->u.f.copy;
+		retval->data[codep++].len = strlen(c->u.f.folder);
+		retval->data[codep++].str = c->u.f.folder;
+		break;
+	    case REDIRECT:
+		/* REDIRECT
+		   VALUE copy
+		   STRING address
+		*/
+		if(!atleast(retval,codep+4)) return -1;
+		retval->data[codep++].op = B_REDIRECT;
+		retval->data[codep++].value = c->u.r.copy;
+		retval->data[codep++].len = strlen(c->u.r.address);
+		retval->data[codep++].str = c->u.r.address;
+		break;
+	    case ADDFLAG:
+		/* ADDFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_ADDFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case SETFLAG:
+		/* SETFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_SETFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case REMOVEFLAG:
+		/* REMOVEFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_REMOVEFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case NOTIFY:
+		/* NOTIFY 
+		   (STRING: len + dataptr)
+		   (STRING: len + dataptr)
+		   stringlist
+		   (STRING: len + dataptr)
+		   (STRING: len + dataptr)
+		   method/id /options list/priority/message 
+		*/
+			
+		if(!atleast(retval,codep+5)) return -1;
+		retval->data[codep++].op = B_NOTIFY;
+		
+		retval->data[codep++].len = strlen(c->u.n.method);
+		retval->data[codep++].str = c->u.n.method;
+				
+		if (c->u.n.id)
+		{
+		    retval->data[codep++].len = strlen(c->u.n.id);
+		    retval->data[codep++].str = c->u.n.id;
+		}
+		else
+		{
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+		
+		codep = bc_stringlist_generate(codep,retval,c->u.n.options);
+		if(codep == -1) return -1;
+
+		if(!atleast(retval,codep+3)) return -1;
+
+		switch(c->u.n.priority) {
+		case LOW:
+		    retval->data[codep++].value = B_LOW;
+		    break;
+		case NORMAL:
+		    retval->data[codep++].value = B_NORMAL;
+		    break;
+		case HIGH:
+		    retval->data[codep++].value = B_HIGH;
+		    break;
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break;
+		default:
+		    return -1;
+		}
+		
+		retval->data[codep++].len = strlen(c->u.n.message);
+		retval->data[codep++].str = c->u.n.message;
+		break;
+	    case VACATION:
+		/* VACATION
+		   STRINGLIST addresses
+		   STRING subject (if len is -1, then subject was NULL)
+		   STRING message (again, len == -1 means message was NULL)
+		   VALUE days
+		   VALUE mime
+		   STRING from (if len is -1, then from was NULL)
+		   STRING handle (again, len == -1 means handle was NULL)
+		*/
+
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_VACATION;
+	    
+		codep = bc_stringlist_generate(codep,retval,c->u.v.addresses);
+		if (codep == -1) return -1;
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.subject) {
+		    retval->data[codep++].len = strlen(c->u.v.subject);
+		    retval->data[codep++].str = c->u.v.subject;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.message) {
+		    retval->data[codep++].len = strlen(c->u.v.message);
+		    retval->data[codep++].str = c->u.v.message;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		retval->data[codep++].value = c->u.v.days;
+		retval->data[codep++].value = c->u.v.mime;
+	    
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.from) {
+		    retval->data[codep++].len = strlen(c->u.v.from);
+		    retval->data[codep++].str = c->u.v.from;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.handle) {
+		    retval->data[codep++].len = strlen(c->u.v.handle);
+		    retval->data[codep++].str = c->u.v.handle;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+
+		if(codep == -1) return -1;
+		break;
+	    case INCLUDE:
+		/* INCLUDE
+		   VALUE location
+		   STRING filename */
+		if(!atleast(retval,codep+4)) return -1;
+		retval->data[codep++].op = B_INCLUDE;
+
+		switch(c->u.inc.location) {
+		case PERSONAL:
+		    retval->data[codep++].value = B_PERSONAL;
+		    break;
+		case GLOBAL:
+		    retval->data[codep++].value = B_GLOBAL;
+		    break;
+		default:
+		    return -1;
+		}
+		
+		retval->data[codep++].len = strlen(c->u.inc.script);
+		retval->data[codep++].str = c->u.inc.script;
+		break;
+	    case IF:
+	    {
+		int jumpVal; 	    
+		/* IF
+		   (int: begin then block)
+		   (int: end then block/begin else block)
+		   (int:end else block) (-1 if no else block)
+		   (test)
+		   (then block)
+		   (else block)(optional)
+		*/
+		baseloc = codep;
+	    
+		/* Allocate operator + jump table offsets */
+		if(!atleast(retval,codep+4)) return -1;
+		
+		jumploc = codep+4;
+		retval->data[codep++].op = B_IF;
+		    
+		/* begining of then  code */
+		jumpVal= bc_test_generate(jumploc,retval,c->u.i.t);
+		if(jumpVal == -1) 
+		    return -1;
+		else {
+		    retval->data[codep].jump = jumpVal;
+		    codep++;
+		}
+	    
+		/* find then code and offset to else code,
+		 * we want to write this code starting at the offset we
+		 * just found */
+	
+		jumpVal= bc_action_generate(jumpVal,retval, c->u.i.do_then);
+		if(jumpVal == -1) 
+		    return -1;
+		else 
+		    retval->data[codep].jump = jumpVal;
+		
+		codep++;
+		/* write else code if its there*/
+		if(c->u.i.do_else) {
+	
+		    jumpVal= bc_action_generate(jumpVal,retval, c->u.i.do_else);
+		    if(jumpVal == -1) 
+		    {
+			return -1;
+		    } else 
+		    {
+			retval->data[codep].jump = jumpVal;
+		    }
+		    
+		    /* Update code pointer to end of else code */
+		    codep = retval->data[codep].jump;
+		} else {
+		    /*there is no else block, so its -1*/
+		    retval->data[codep].jump = -1;
+		    /* Update code pointer to end of then code */
+		    codep = retval->data[codep-1].jump;
+		}
+	    
+		break;
+	    }
+	    default:
+		/* no such action known */
+		return -1;
+	    }
+	  
+	    /* generate from next command */
+	    c = c->next;
+	} while(c);
+    }
+    /*scriptend may be updated before the end, but it will be updated at the end, which is what matters.*/
+    retval->scriptend=codep;
+    return codep;
+   
+}
+
+
+
+/* Entry point to the bytecode emitter module */	
+int sieve_generate_bytecode(bytecode_info_t **retval, sieve_script_t *s) 
+{
+    commandlist_t *c;
+
+    if(!retval) return -1;
+    if(!s) return -1;
+    c = s->cmds;
+    /* if c is NULL, it is handled in bc_action_generate and a script
+       with only BC_NULL is returned
+    */
+
+    
+    *retval = xmalloc(sizeof(bytecode_info_t));
+    if(!(*retval)) return -1;
+
+    memset(*retval, 0, sizeof(bytecode_info_t));
+
+    return bc_action_generate(0, *retval, c);
+}
+
+
+void sieve_free_bytecode(bytecode_info_t **p) 
+{
+    if(!p || !*p) return;
+    if((*p)->data) free((*p)->data);
+    free(*p);
+    *p = NULL;
+}
+ 
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/bytecode.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bytecode.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/bytecode.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/bytecode.h	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,227 @@
+/* bytecode.h -- bytecode definition
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+#ifndef SIEVE_BYTECODE_H
+#define SIEVE_BYTECODE_H
+
+
+/* for debugging*/
+#define DUMPCODE 0
+#define VERBOSE 0
+
+/*for finding correctly aligned bytes on strings*/
+/* bump to the next multiple of 4 bytes */
+#define ROUNDUP(num) (((num) + 3) & 0xFFFFFFFC)
+
+
+/* yes, lots of these are superfluous, it's for clarity */
+typedef union 
+{
+    int op; /* OPTYPE */
+    int value;
+
+    int jump;
+
+    int listlen;
+
+    /* store strings (need 2 consecutive bytecodes) */
+    int len;
+    char *str;
+} bytecode_t;
+
+/* For sanity during input on 64-bit platforms.
+ * str should only be accessed as (char *)&str, but given the use of
+ * unwrap_string, this should be OK */
+typedef union 
+{
+    int op; /* OPTYPE */
+    int value;
+
+    int jump;
+
+    int listlen;
+
+    /* store strings (need 2 consecutive bytecodes) */
+    int len;
+    int str;
+} bytecode_input_t;
+
+
+/* version 0x01 scripts were written in host byte order.
+ * we don't want to use this version number again and cause a mess
+ * this isn't a huge concern, since this is version ntohl(1), or 16777216
+ *
+ * version 0x02 scripts started using network byte order (recompile)
+ * version 0x03 scripts implemented short-circuiting of testlists (recompile)
+ * version 0x04 scripts implemented BODY, INCLUDE and COPY extensions
+ * version 0x05 scripts implemented updated VACATION (:from and :handle)
+ */
+#define BYTECODE_VERSION 0x05
+#define BYTECODE_MIN_VERSION 0x03 /* minimum supported version */
+#define BYTECODE_MAGIC "CyrSBytecode"
+#define BYTECODE_MAGIC_LEN 12 /* Should be multiple of 4 */
+
+/* IMPORTANT: To maintain forward compatibility of bytecode, please only add
+ * new instructions to the end of these enums.  (The reason these values
+ * are all duplicated here is to avoid silliness if this caveat is forgotten
+ * about in the other tables.) */
+enum bytecode {
+    B_STOP,
+
+    B_KEEP,
+    B_DISCARD,
+    B_REJECT,		/* require reject */
+    B_FILEINTO_ORIG,	/* legacy fileinto w/o support for :copy */
+    B_REDIRECT_ORIG,	/* legacy redirect w/o support for :copy */
+
+    B_IF,
+  
+    B_MARK,		/* require imapflags */
+    B_UNMARK,		/* require imapflags */
+
+    B_ADDFLAG,		/* require imapflags */
+    B_SETFLAG,		/* require imapflags */
+    B_REMOVEFLAG,	/* require imapflags */
+
+    B_NOTIFY,		/* require notify */
+    B_DENOTIFY,		/* require notify */
+
+    B_VACATION,		/* require vacation */
+    B_NULL,
+    B_JUMP,
+
+    B_INCLUDE,		/* require include */
+    B_RETURN,		/* require include */
+
+    B_FILEINTO,		/* require fileinto */
+    B_REDIRECT
+};
+
+enum bytecode_comps {
+    BC_FALSE,
+    BC_TRUE,
+    BC_NOT,
+    BC_EXISTS,
+    BC_SIZE,
+    BC_ANYOF,
+    BC_ALLOF,
+    BC_ADDRESS,
+    BC_ENVELOPE,	/* require envelope */
+    BC_HEADER,
+    BC_BODY		/* require body */
+};
+
+/* currently one enum so as to help determine where values are being misused.
+ * we have left placeholders incase we need to add more later to the middle */
+enum bytecode_tags {
+    /* Size Tests */
+    B_OVER,
+    B_UNDER,
+
+    B_SIZE_PLACEHOLDER_1,
+    B_SIZE_PLACEHOLDER_2,
+     
+    /* Relational Match Types */
+    B_GT,		/* require relational */
+    B_GE,		/* require relational */
+    B_LT,		/* require relational */
+    B_LE,		/* require relational */
+    B_EQ,		/* require relational */
+    B_NE,		/* require relational */
+ 
+    B_RELATIONAL_PLACEHOLDER_1,
+    B_RELATIONAL_PLACEHOLDER_2,
+   
+    /* Priorities */
+    B_LOW,		/* require notify */
+    B_NORMAL,		/* require notify */
+    B_HIGH,		/* require notify */
+    B_ANY,		/* require notify */
+
+    B_PRIORITY_PLACEHOLDER_1,
+    B_PRIORITY_PLACEHOLDER_2,
+    B_PRIORITY_PLACEHOLDER_3,
+    B_PRIORITY_PLACEHOLDER_4,
+    
+    /* Address Parts */
+    B_ALL,
+    B_LOCALPART,
+    B_DOMAIN,
+    B_USER,		/* require subaddress */
+    B_DETAIL,		/* require subaddress */
+    
+    B_ADDRESS_PLACEHOLDER_1,
+    B_ADDRESS_PLACEHOLDER_2,
+    B_ADDRESS_PLACEHOLDER_3,
+    B_ADDRESS_PLACEHOLDER_4,
+
+    /* Comparators */
+    B_ASCIICASEMAP,
+    B_OCTET,
+    B_ASCIINUMERIC,	/* require comparator-i;ascii-numeric */
+    
+    B_COMPARATOR_PLACEHOLDER_1,
+    B_COMPARATOR_PLACEHOLDER_2,
+    B_COMPARATOR_PLACEHOLDER_3,
+    B_COMPARATOR_PLACEHOLDER_4,
+ 
+    /* Match Types */
+    B_IS,
+    B_CONTAINS,
+    B_MATCHES,
+    B_REGEX,		/* require regex */
+    B_COUNT,		/* require relational */
+    B_VALUE,		/* require relational */
+
+    B_MATCH_PLACEHOLDER_1,
+    B_MATCH_PLACEHOLDER_2,
+    B_MATCH_PLACEHOLDER_3,
+    B_MATCH_PLACEHOLDER_4,
+
+    /* Body Transforms */
+    B_RAW,		/* require body */
+    B_TEXT,		/* require body */
+    B_CONTENT,		/* require body */
+
+    B_TRANSFORM_PLACEHOLDER_1,
+    B_TRANSFORM_PLACEHOLDER_2,
+    B_TRANSFORM_PLACEHOLDER_3,
+    B_TRANSFORM_PLACEHOLDER_4,
+    B_TRANSFORM_PLACEHOLDER_5,
+
+    /* Script locations */
+    B_PERSONAL,		/* require include */
+    B_GLOBAL,		/* require include */
+
+    B_LOCATION_PLACEHOLDER_1,
+    B_LOCATION_PLACEHOLDER_2,
+    B_LOCATION_PLACEHOLDER_3,
+    B_LOCATION_PLACEHOLDER_4
+  
+};
+
+int unwrap_string(bytecode_input_t *bc, int pos, const char **str, int *len);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/comparator.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/comparator.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/comparator.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/comparator.c	2007-09-16 04:58:31.000000000 -0600
@@ -0,0 +1,478 @@
+/* comparator.c -- comparator functions
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "xmalloc.h"
+#include "comparator.h"
+#include "tree.h"
+#include "sieve.h"
+#include "bytecode.h"
+#include "xmalloc.h"
+
+/*!!! uses B_CONTAINS not CONTAINS, etc, only works with bytecode*/
+
+typedef int (*compare_t)(const void *, size_t, const void *);
+
+/* --- relational comparators --- */
+
+/* these are generic wrappers in which 'rock' is the compare function */
+
+static int rel_eq(const char *text, size_t tlen, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, tlen, pat) == 0);
+}
+
+static int rel_ne(const char *text, size_t tlen, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, tlen, pat) != 0);
+}
+
+static int rel_gt(const char *text, size_t tlen, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, tlen, pat) > 0);
+}
+
+static int rel_ge(const char *text, size_t tlen, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, tlen, pat) >= 0);
+}
+
+static int rel_lt(const char *text, size_t tlen, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, tlen, pat) < 0);
+}
+
+static int rel_le(const char *text, size_t tlen, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, tlen, pat) <= 0);
+}
+
+/* --- i;octet comparators --- */
+
+/* just compare the two; pat should be NULL terminated */
+static int octet_cmp_(const char *text, size_t tlen,
+		      const char *pat, int casemap)
+{
+    size_t plen, sl, i;
+    int r = 0;
+
+    plen = strlen(pat);
+    sl = tlen < plen ? tlen : plen;
+
+    for (i = 0; !r && i < sl; i++) {
+	r = casemap ? toupper(text[i]) - toupper(pat[i]) : text[i] - pat[i];
+    }
+
+    if (r == 0)
+	return (tlen - plen);
+    else 
+	return r;
+}
+
+static int octet_cmp(const char *text, size_t tlen, const char *pat)
+{
+    return octet_cmp_(text, tlen, pat, 0);
+}
+
+/* we implement boyer-moore for hell of it, since this is probably
+ not very useful for sieve */
+#if 0
+int boyer_moore(char *text, char *pat)
+{
+    int i, j; /* indexes */
+    int M = strlen(pat); /* length of pattern */
+    int N = strlen(text); /* length of text */
+    int skip[256]; /* table of how much to skip, based on each character */
+
+    /* initialize skip table */
+    for (i = 0; i < 256; i++)
+	skip[i] = M;
+    for (i = 0; i < M; i++)
+	skip[(int) pat[i]] = M-i-1;
+    
+    /* look for pat in text */
+    i = j = M-1;
+    do {
+	if (pat[j] == text[i]) {
+	    i--;
+	    j--;
+	} else {
+	    if (M-j > skip[(int) text[i]]) {
+		i = i + M - j;
+	    } else {
+		i = i + skip[(int) text[i]];
+	    }
+	    j = M-1;
+	}
+    } while (!((j < 0) || (i >= N)));
+    /* i+1 is the position of the match if i < N */
+    return (i < N) ? 1 : 0;
+}
+#endif
+
+/* we do a brute force attack */
+static int octet_contains_(const char *text, size_t tlen,
+			   const char *pat, int casemap)
+{
+    int N = tlen;
+    int M = strlen(pat);
+    int i, j;
+
+    i = 0, j = 0;
+    while ((j < M) && (i < N)) {
+	if ((text[i] == pat[j]) ||
+	    (casemap && (toupper(text[i]) == toupper(pat[j])))) {
+	    i++; j++;
+	} else {
+	    i = i - j + 1;
+	    j = 0;
+	}
+    }    
+
+    return (j == M); /* we found a match! */
+}
+
+static int octet_contains(const char *text, size_t tlen, const char *pat,
+                          void *rock ATTR_UNUSED)
+{
+    return octet_contains_(text, tlen, pat, 0);
+}
+
+static int octet_matches_(const char *text, size_t tlen,
+			  const char *pat, int casemap)
+{
+    const char *p;
+    const char *t;
+    char c;
+
+    t = text;
+    p = pat;
+    for (;;) {
+	if (*p == '\0') {
+	    /* ran out of pattern */
+	    return (!tlen);
+	}
+	c = *p++;
+	switch (c) {
+	case '?':
+	    if (!tlen) {
+		return 0;
+	    }
+	    t++; tlen--;
+	    break;
+	case '*':
+	    while (*p == '*' || *p == '?') {
+		if (*p == '?') {
+		    /* eat the character now */
+		    if (!tlen) {
+			return 0;
+		    }
+		    t++; tlen--;
+		}
+		/* coalesce into a single wildcard */
+		p++;
+	    }
+	    if (*p == '\0') {
+		/* wildcard at end of string, any remaining text is ok */
+		return 1;
+	    }
+
+	    while (tlen) {
+		/* recurse */
+		if (octet_matches_(t, tlen, p, casemap)) return 1;
+		t++; tlen--;
+	    }
+	case '\\':
+	    p++;
+	    /* falls through */
+	default:
+	    if ((c == *t) || (casemap && (toupper(c) == toupper(*t)))) {
+		t++; tlen--;
+	    } else {
+		/* literal char doesn't match */
+		return 0;
+	    }
+	}
+    }
+
+    /* never reaches */
+}
+
+static int octet_matches(const char *text, size_t tlen, const char *pat,
+                         void *rock ATTR_UNUSED)
+{
+    return octet_matches_(text, tlen, pat, 0);
+}
+
+
+#ifdef ENABLE_REGEX
+static int octet_regex(const char *text, size_t tlen, const char *pat,
+                       void *rock ATTR_UNUSED)
+{
+    if (!text[tlen]) {
+	/* NUL-terminated string */
+	return (!regexec((regex_t *) pat, text, 0, NULL, 0));
+    }
+    else {
+	/* regexec() requires a NUL-terminated string */
+	int r;
+
+	t_push();
+	r = !regexec((regex_t *) pat, t_strndup(text, tlen), 0, NULL, 0);
+	t_pop();
+	return r;
+    }
+}
+#endif
+
+
+/* --- i;ascii-casemap comparators --- */
+
+
+static int ascii_casemap_cmp(const char *text, size_t tlen, const char *pat)
+{
+    return octet_cmp_(text, tlen, pat, 1);
+}
+
+static int ascii_casemap_contains(const char *text, size_t tlen,
+				  const char *pat,
+				  void *rock ATTR_UNUSED)
+{
+    return octet_contains_(text, tlen, pat, 1);
+}
+
+static int ascii_casemap_matches(const char *text, size_t tlen,
+				 const char *pat, 
+                                 void *rock ATTR_UNUSED)
+{
+    return octet_matches_(text, tlen, pat, 1);
+}
+
+/* i;ascii-numeric; only supports relational tests
+ *
+ *  A \ B    number   not-num 
+ *  number   A ? B    A < B 
+ *  not-num  A > B    A == B
+ */
+
+/* From RFC 2244:
+ *
+ * The i;ascii-numeric comparator interprets strings as decimal
+ * positive integers represented as US-ASCII digits.  All values
+ * which do not begin with a US-ASCII digit are considered equal
+ * with an ordinal value higher than all non-NIL single-valued
+ * attributes.  Otherwise, all US-ASCII digits (octet values
+ * 0x30 to 0x39) are interpreted starting from the beginning of
+ * the string to the first non-digit or the end of the string.
+ */
+
+static int ascii_numeric_cmp(const char *text, size_t tlen, const char *pat)
+{
+    unsigned text_digit_len;
+    unsigned pat_digit_len;
+
+    if (isdigit((int) *pat)) {
+	if (isdigit((int) *text)) {
+	    /* Count how many digits each string has */
+	    for (text_digit_len = 0;
+		 tlen-- && isdigit((int) text[text_digit_len]);
+		 text_digit_len++);
+	    for (pat_digit_len = 0;
+		 isdigit((int) pat[pat_digit_len]);
+		 pat_digit_len++);
+
+	    if (text_digit_len < pat_digit_len) {
+		/* Pad "text" with leading 0s */
+		while (pat_digit_len > text_digit_len) {
+		    /* "text" can only be less or equal to "pat" */
+		    if ('0' < *pat) {
+			return (-1); 
+		    }
+		    pat++;
+		    pat_digit_len--;
+		}
+	    } else if (text_digit_len > pat_digit_len) {
+		/* Pad "pad" with leading 0s */
+		while (text_digit_len > pat_digit_len) {
+		    /* "pad" can only be greater or equal to "text" */
+		    if (*text > '0') {
+			return 1;
+		    }
+		    text++;
+		    text_digit_len--;
+		}
+	    }
+
+	    /* CLAIM: If we here, we have two non-empty digital suffixes
+	       of equal length */
+	    while (text_digit_len > 0) {
+		if (*text < *pat) {
+		    return -1;
+		} else if (*text > *pat) {
+		    return 1;
+		}
+		/* Characters are equal, carry on */
+		text++;
+		pat++;
+		text_digit_len--;
+	    }
+
+	    return (0);
+	} else {
+	    return 1;
+	}
+    } else if (isdigit((int) *text)) {
+	return -1;
+    } else {
+	return 0; /* both not digits */
+    }
+}
+
+static comparator_t *lookup_rel(int relation)
+{
+    comparator_t *ret;
+
+    ret = NULL;
+    switch (relation)
+      {
+      case B_EQ:
+	ret = &rel_eq;
+	break;
+      case B_NE:
+	ret = &rel_ne; 
+	break;
+      case B_GT: 
+	ret = &rel_gt; 
+	break;
+      case B_GE:
+         ret = &rel_ge; 
+	 break;
+      case B_LT:
+	ret = &rel_lt; 
+	break;
+      case B_LE:
+	ret = &rel_le; 
+      }
+
+    return ret;
+}
+
+comparator_t *lookup_comp(int comp, int mode, int relation,
+			  void **comprock)
+{
+    comparator_t *ret;
+
+    ret = NULL;
+    *comprock = NULL;
+#if VERBOSE
+    printf("comp%d mode%d relat%d     \n", comp, mode, relation); 
+#endif
+    switch (comp)
+      {
+      case B_OCTET:    
+ 	switch (mode) {
+	  case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &octet_cmp;
+	    break;
+	  case B_CONTAINS:
+	    ret = &octet_contains;
+	    break;
+	  case B_MATCHES:
+	    ret = &octet_matches;
+	    break;
+#ifdef ENABLE_REGEX
+	  case B_REGEX:
+	    ret = &octet_regex;
+	    break;
+#endif
+	  case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &octet_cmp;
+	    break;
+	}
+	break; /*end of octet */
+      case B_ASCIICASEMAP:
+     	switch (mode) {
+	case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &ascii_casemap_cmp;
+	    break;
+	case B_CONTAINS:
+	    ret = &ascii_casemap_contains;
+	    break;
+	case B_MATCHES:
+	    ret = &ascii_casemap_matches;
+	    break;
+#ifdef ENABLE_REGEX
+	case B_REGEX:
+	    /* the ascii-casemap destinction is made during
+	       the compilation of the regex in verify_regex() */
+	    ret = &octet_regex;
+	    break;
+#endif
+	case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &ascii_casemap_cmp;
+	    break;
+	}
+	break;/*end of ascii casemap */
+      case B_ASCIINUMERIC:
+	switch (mode) {
+	case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &ascii_numeric_cmp;
+	    break;
+	case B_COUNT:
+	case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &ascii_numeric_cmp;
+	    break;
+	}
+	break;
+      }
+    return ret;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/comparator.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/comparator.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/comparator.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/comparator.h	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,48 @@
+/* comparator.h
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef COMPARATOR_H
+#define COMPARATOR_H
+
+#ifdef ENABLE_REGEX
+#ifdef HAVE_RX
+#include <rxposix.h>
+#else
+#include <sys/types.h>
+#include <regex.h>
+#endif
+#endif
+
+/* compares pat to text; returns 1 if it's true, 0 otherwise 
+   first arg is text, second arg is pat, third arg is rock */
+typedef int comparator_t(const char *, size_t, const char *, void *);
+
+/* returns a pointer to a comparator function given it's name */
+comparator_t *lookup_comp(int comp, int mode,
+			  int relation, void **rock);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/COPYING dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/COPYING
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/COPYING	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/COPYING	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,26 @@
+/* cmu-sieve
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1998 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/interp.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/interp.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/interp.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/interp.c	2007-07-19 19:34:26.000000000 -0600
@@ -0,0 +1,264 @@
+/* interp.c -- sieve script interpretor builder
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "lib.h"
+#include "str.h"
+#include "xmalloc.h"
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "libconfig.h"
+
+/* build a sieve interpretor */
+int sieve_interp_alloc(sieve_interp_t **interp, void *interp_context)
+{
+    sieve_interp_t *i;
+    static int initonce;
+
+    if (!initonce) {
+	initialize_siev_error_table();
+	initonce = 1;
+    }
+
+    *interp = NULL;
+    i = (sieve_interp_t *) xmalloc(sizeof(sieve_interp_t));
+    if (i == NULL) {
+	return SIEVE_NOMEM;
+    }
+
+    i->redirect = i->discard = i->reject = i->fileinto = i->keep = NULL;
+    i->getsize = NULL;
+    i->getheader = NULL;
+    i->getenvelope = NULL;
+    i->getbody = NULL;
+    i->getinclude = NULL;
+    i->vacation = NULL;
+    i->notify = NULL;
+
+    i->markflags = NULL;
+
+    i->interp_context = interp_context;
+    i->err = NULL;
+
+    *interp = i;
+    return SIEVE_OK;
+}
+
+const char *sieve_listextensions(sieve_interp_t *i)
+{
+    static int done = 0;
+    static string_t *extensions;
+
+    if (!done++) {
+	unsigned long config_sieve_extensions = EXTENSIONS_ALL;
+
+	/* add comparators */
+	extensions = str_new(default_pool, 128);
+	str_append(extensions, "comparator-i;ascii-numeric");
+
+	/* add actions */
+	if (i->fileinto &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_FILEINTO))
+	    str_append(extensions, " fileinto");
+	if (i->reject &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_REJECT))
+	    str_append(extensions, " reject");
+	if (i->vacation &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_VACATION))
+	    str_append(extensions, " vacation");
+	if (i->markflags &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_IMAPFLAGS))
+	    str_append(extensions, " imapflags");
+	if (i->notify &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_NOTIFY))
+	    str_append(extensions, " notify");
+	if (i->getinclude &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_INCLUDE))
+	    str_append(extensions, " include");
+
+	/* add tests */
+	if (i->getenvelope &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_ENVELOPE))
+	    str_append(extensions, " envelope");
+	if (i->getbody &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_BODY))
+	    str_append(extensions, " body");
+
+	/* add match-types */
+	if (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_RELATIONAL)
+	    str_append(extensions, " relational");
+#ifdef ENABLE_REGEX
+	if (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_REGEX)
+	    str_append(extensions, " regex");
+#endif
+
+	/* add misc extensions */
+	if (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_SUBADDRESS)
+	    str_append(extensions, " subaddress");
+	if (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_COPY)
+	    str_append(extensions, " copy");
+    }
+
+    return str_c(extensions);
+}
+
+int sieve_interp_free(sieve_interp_t **interp)
+{
+    free(*interp);
+    
+    return SIEVE_OK;
+}
+
+/* add the callbacks */
+int sieve_register_redirect(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->redirect = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_discard(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->discard = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_reject(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->reject = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_fileinto(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->fileinto = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_keep(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->keep = f;
+ 
+    return SIEVE_OK;
+}
+
+static char *default_markflags[] = { "\\flagged" };
+static sieve_imapflags_t default_mark = { default_markflags, 1 };
+
+int sieve_register_imapflags(sieve_interp_t *interp, sieve_imapflags_t *mark)
+{
+    interp->markflags =
+	(mark && mark->flag && mark->nflags) ? mark : &default_mark;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_notify(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->notify = f;
+ 
+    return SIEVE_OK;
+}
+
+/* add the callbacks for messages. again, undefined if used after
+   sieve_script_parse */
+int sieve_register_size(sieve_interp_t *interp, sieve_get_size *f)
+{
+    interp->getsize = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_header(sieve_interp_t *interp, sieve_get_header *f)
+{
+    interp->getheader = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_envelope(sieve_interp_t *interp, sieve_get_envelope *f)
+{
+    interp->getenvelope = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_include(sieve_interp_t *interp, sieve_get_include *f)
+{
+    interp->getinclude = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_body(sieve_interp_t *interp, sieve_get_body *f)
+{
+    interp->getbody = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_vacation(sieve_interp_t *interp, sieve_vacation_t *v)
+{
+    if (!interp->getenvelope) {
+	return SIEVE_NOT_FINALIZED; /* we need envelope for vacation! */
+    }
+
+    if (v->min_response == 0) v->min_response = 3;
+    if (v->max_response == 0) v->max_response = 90;
+    if (v->min_response < 0 || v->max_response < 7 || !v->autorespond
+	|| !v->send_response) {
+	return SIEVE_FAIL;
+    }
+
+    interp->vacation = v;
+    return SIEVE_OK;
+}
+
+int sieve_register_parse_error(sieve_interp_t *interp, sieve_parse_error *f)
+{
+    interp->err = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_execute_error(sieve_interp_t *interp, sieve_execute_error *f)
+{
+    interp->execute_err = f;
+    return SIEVE_OK;
+}
+
+int interp_verify(sieve_interp_t *i)
+{
+    if (i->redirect && i->keep && i->getsize && i->getheader) {
+	return SIEVE_OK;
+    } else {
+	return SIEVE_NOT_FINALIZED;
+    }
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/interp.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/interp.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/interp.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/interp.h	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,77 @@
+/* interp.h -- interpretor definition
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+#ifndef SIEVE_INTERP_H
+#define SIEVE_INTERP_H
+
+#include "sieve_interface.h"
+
+enum enum_value {
+
+  IMAP_ENUM_ZERO = 0,
+
+  IMAP_ENUM_SIEVE_EXTENSIONS_COPY = (1<<11),
+  IMAP_ENUM_SIEVE_EXTENSIONS_SUBADDRESS = (1<<10),
+  IMAP_ENUM_SIEVE_EXTENSIONS_REGEX = (1<<9),
+  IMAP_ENUM_SIEVE_EXTENSIONS_RELATIONAL = (1<<8),
+  IMAP_ENUM_SIEVE_EXTENSIONS_BODY = (1<<7),
+  IMAP_ENUM_SIEVE_EXTENSIONS_ENVELOPE = (1<<6),
+  IMAP_ENUM_SIEVE_EXTENSIONS_INCLUDE = (1<<5),
+  IMAP_ENUM_SIEVE_EXTENSIONS_NOTIFY = (1<<4),
+  IMAP_ENUM_SIEVE_EXTENSIONS_IMAPFLAGS = (1<<3),
+  IMAP_ENUM_SIEVE_EXTENSIONS_VACATION = (1<<2),
+  IMAP_ENUM_SIEVE_EXTENSIONS_REJECT = (1<<1),
+  IMAP_ENUM_SIEVE_EXTENSIONS_FILEINTO = (1<<0)
+};
+#define EXTENSIONS_ALL ((1 << 12)-1)
+
+struct sieve_interp {
+    /* standard callbacks for actions */
+    sieve_callback *redirect, *discard, *reject, *fileinto, *keep;
+    sieve_callback *notify;
+    sieve_vacation_t *vacation;
+
+    sieve_get_size *getsize;
+    sieve_get_header *getheader;
+    sieve_get_envelope *getenvelope;
+    sieve_get_body *getbody;
+    sieve_get_include *getinclude;
+
+    sieve_parse_error *err;
+
+    /* site-specific imapflags for mark/unmark */
+    sieve_imapflags_t *markflags;
+
+    sieve_execute_error *execute_err;
+
+    /* context to pass along */
+    void *interp_context;
+};
+
+int interp_verify(sieve_interp_t *interp);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/Makefile.am dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/Makefile.am
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/Makefile.am	2007-07-19 22:30:53.000000000 -0600
@@ -0,0 +1,81 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+noinst_LTLIBRARIES = libsieve.la
+
+AM_YFLAGS = -d -p $*
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(top_srcdir)/src
+
+addr-lex.c: addr-lex.l
+	$(LEX) -t -Paddr addr-lex.l > addr-lex.c
+
+sieve-lex.c: sieve-lex.l
+	$(LEX) -t sieve-lex.l > sieve-lex.c
+
+libsieve_la_SOURCES = \
+	addr.y \
+	sieve.y \
+	addr-lex.l \
+	sieve-lex.l \
+	bc_dump.c \
+	bc_emit.c \
+	bc_eval.c \
+	bc_generate.c \
+	comparator.c \
+	interp.c \
+	message.c \
+	parseaddr.c \
+	script.c \
+	sieve_err.c \
+	tree.c
+
+noinst_HEADERS = \
+	addr.h \
+	bytecode.h \
+	comparator.h \
+	interp.h \
+	message.h \
+	parseaddr.h \
+	script.h \
+	sieve.h \
+	sieve_err.h \
+	sieve_interface.h \
+	tree.h
+
+if HAVE_DOVECOT_LIBS
+pkglibexec_PROGRAMS = sievec sieved
+
+sievec_SOURCES = \
+	sievec.c \
+	../map.c \
+	../imparse.c
+
+sieved_SOURCES = \
+	sieved.c \
+	../map.c \
+	../imparse.c
+
+sievec_LDADD = \
+	libsieve.la \
+	$(dovecotdir)/src/lib/liblib.a
+
+sieved_LDADD = \
+	libsieve.la \
+	$(dovecotdir)/src/lib/liblib.a
+
+notbuilt_sources =
+else
+notbuilt_sources = sievec.c sieved.c
+endif
+
+EXTRA_DIST = \
+	addr-lex.l \
+	sieve-lex.l \
+	AUTHORS \
+	COPYING \
+	NEWS \
+	README \
+	$(notbuilt_sources)
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/message.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/message.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/message.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/message.c	2007-09-30 08:20:52.000000000 -0600
@@ -0,0 +1,612 @@
+/* message.c -- message parsing functions
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include "lib.h"
+#include "md5.h"
+#include "sieve_interface.h"
+#include "interp.h"
+#include "message.h"
+#include "parseaddr.h"
+#include "xmalloc.h"
+
+/* reject message m with message msg
+ *
+ * incompatible with: fileinto, redirect
+ */
+int do_reject(action_list_t *a, const char *msg)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_FILEINTO ||
+	    a->a == ACTION_KEEP ||
+	    a->a == ACTION_REDIRECT ||
+	    a->a == ACTION_REJECT ||
+	    a->a == ACTION_VACATION ||
+	    a->a == ACTION_SETFLAG ||
+	    a->a == ACTION_ADDFLAG ||
+	    a->a == ACTION_REMOVEFLAG ||
+	    a->a == ACTION_MARK ||
+	    a->a == ACTION_UNMARK
+	    )
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REJECT;
+    a->cancel_keep = 1;
+    a->u.rej.msg = msg;
+    b->next = a;
+    a->next =  NULL;
+    return 0;
+}
+
+/* fileinto message m into mailbox 
+ *
+ * incompatible with: reject
+ */
+int do_fileinto(action_list_t *a, const char *mbox, int cancel_keep,
+		sieve_imapflags_t *imapflags)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_FILEINTO;
+    a->cancel_keep = cancel_keep;
+    a->u.fil.mailbox = mbox;
+    a->u.fil.imapflags = imapflags;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* redirect message m to to addr
+ *
+ * incompatible with: reject
+ */
+int do_redirect(action_list_t *a, const char *addr, int cancel_keep)
+{
+    action_list_t *b = NULL;
+
+    /* xxx we should validate addr */
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REDIRECT;
+    a->cancel_keep = cancel_keep;
+    a->u.red.addr = addr;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* keep message
+ *
+ * incompatible with: reject
+ */
+int do_keep(action_list_t *a, sieve_imapflags_t *imapflags)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	if (a->a == ACTION_KEEP) /* don't bother doing it twice */
+	    return 0;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_KEEP;
+    a->cancel_keep = 1;
+    a->u.keep.imapflags = imapflags;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* discard message m
+ *
+ * incompatible with: nothing---it doesn't cancel any actions
+ */
+int do_discard(action_list_t *a)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_DISCARD) /* don't bother doing twice */
+	    return 0;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_DISCARD;
+    a->cancel_keep = 1;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+static int makehash(unsigned char hash[],
+		    const char *s1, const char *s2, const char *s3)
+{
+    struct md5_context ctx;
+
+    md5_init(&ctx);
+    md5_update(&ctx, s1, strlen(s1));
+    md5_update(&ctx, s2, strlen(s2));
+    if (s3) md5_update(&ctx, s3, strlen(s3));
+    md5_final(&ctx, hash);
+
+    return SIEVE_OK;
+}
+
+int do_vacation(action_list_t *a, char *addr, char *fromaddr,
+		char *subj, const char *msg, int days,
+		int mime, const char *handle)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT ||
+	    a->a == ACTION_VACATION) /* vacation can't be used twice */
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_VACATION;
+    a->cancel_keep = 0;
+    a->u.vac.send.addr = addr;
+    a->u.vac.send.fromaddr = fromaddr;
+    a->u.vac.send.subj = subj;	/* user specified subject */
+    a->u.vac.send.msg = msg;
+    a->u.vac.send.mime = mime;
+    if (handle)
+	makehash(a->u.vac.autoresp.hash, addr, handle, NULL);
+    else
+	makehash(a->u.vac.autoresp.hash, addr, fromaddr, msg);
+    a->u.vac.autoresp.days = days;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* setflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_setflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_SETFLAG;
+    a->cancel_keep = 0;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* addflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_addflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_ADDFLAG;
+    a->cancel_keep = 0;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* removeflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_removeflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REMOVEFLAG;
+    a->cancel_keep = 0;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+
+/* mark message m
+ *
+ * incompatible with: reject
+ */
+int do_mark(action_list_t *a)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_MARK;
+    a->cancel_keep = 0;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+
+/* unmark message m
+ *
+ * incompatible with: reject
+ */
+int do_unmark(action_list_t *a)
+{
+
+    action_list_t *b = NULL;
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_UNMARK;
+    a->cancel_keep = 0;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* notify
+ *
+ * incompatible with: none
+ */
+int do_notify(notify_list_t *a, const char *id,
+	      const char *method, const char **options,
+	      const char *priority, const char *message)
+{
+    notify_list_t *b = NULL;
+
+    /* find the end of the notify list */
+    while (a != NULL) {
+	b = a;
+	a = a->next;
+    }
+
+    /* add to the notify list */
+    a = (notify_list_t *) xmalloc(sizeof(notify_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+
+    b->next = a;
+    a->isactive = 1;
+    a->id = id;
+    a->method = method;
+    a->options = options;
+    a->priority = priority;
+    a->message = message;
+    a->next = NULL;
+    return 0;
+}
+
+/* denotify
+ *
+ * incomaptible with: none
+ */
+int do_denotify(notify_list_t *n, comparator_t *comp, const void *pat,
+		void *comprock, const char *priority)
+{
+    while (n != NULL) {
+	if (n->isactive && 
+	    (!priority || !strcasecmp(n->priority, priority)) &&
+	    (!comp || (n->id && comp(n->id, strlen(n->id), pat, comprock)))) {
+	    n->isactive = 0;
+	}
+	n = n->next;
+    }
+
+    return 0;
+}
+
+
+
+/* given a header, extract an address out of it.  if marker points to NULL,
+   extract the first address.  otherwise, it's an index into the header to
+   say where to start extracting */
+struct addr_marker {
+    struct address *where;
+    char *freeme;
+};
+
+int parse_address(const char *header, void **data, void **marker)
+{
+    struct addr_marker *am = (struct addr_marker *) *marker;
+
+    parseaddr_list(header, (struct address **) data);
+    am = (void *) xmalloc(sizeof(struct addr_marker));
+    am->where = *data;
+    am->freeme = NULL;
+    *marker = am;
+    return SIEVE_OK;
+}
+
+char *get_address(address_part_t addrpart,
+		  void **data ATTR_UNUSED,
+		  void **marker,
+		  int canon_domain)
+{
+    char *ret = NULL;
+    struct address *a;
+    struct addr_marker *am = *marker;
+
+    a = am->where;
+    if (am->freeme) {
+	free(am->freeme);
+	am->freeme = NULL;
+    }
+
+    if (a == NULL) {
+	ret = NULL;
+    } else {
+	if (canon_domain && a->domain)
+	    lcase(a->domain);
+
+	switch (addrpart) { 
+	case ADDRESS_ALL:
+#define U_DOMAIN "unspecified-domain"
+#define U_USER "unknown-user"
+	    if (a->mailbox || a->domain) {
+		char *m = a->mailbox ? a->mailbox : U_USER;
+		char *d = a->domain ? a->domain : U_DOMAIN;
+		am->freeme = (char *) xmalloc(strlen(m) + strlen(d) + 2);
+
+		sprintf(am->freeme, "%s@%s", m, d);
+		ret = am->freeme;
+	    } else {
+		ret = NULL;
+	    }
+	    break;
+
+	case ADDRESS_LOCALPART:
+	    ret = a->mailbox;
+	    break;
+	    
+	case ADDRESS_DOMAIN:
+	    ret = a->domain;
+	    break;
+
+	case ADDRESS_USER:
+	    if (a->mailbox) {
+		char *p = strchr(a->mailbox, '+');
+		int len = p ? p - a->mailbox : (int)strlen(a->mailbox);
+
+		am->freeme = (char *) xmalloc(len + 1);
+		strncpy(am->freeme, a->mailbox, len);
+		am->freeme[len] = '\0';
+		ret = am->freeme;
+	    } else {
+		ret = NULL;
+	    }
+	    break;
+
+	case ADDRESS_DETAIL:
+	    if (a->mailbox)
+	    {	    
+		char *p = strchr(a->mailbox, '+');
+		ret = (p ? p + 1 : NULL);
+	    }
+	    else
+	    {
+		ret = NULL;
+	    }
+	    break;
+	}
+	a = a->next;
+	am->where = a;
+    }
+    *marker = am;
+    return ret;
+}
+
+int free_address(void **data, void **marker)
+{
+    struct addr_marker *am = (struct addr_marker *) *marker;
+
+    if (*data)
+	parseaddr_free((struct address *) *data);
+    *data = NULL;
+    if (am->freeme) free(am->freeme);
+    free(am);
+    *marker = NULL;
+    return SIEVE_OK;
+}
+
+notify_list_t *new_notify_list(void)    
+{
+    notify_list_t *ret = xmalloc(sizeof(notify_list_t));
+
+    if (ret != NULL) {
+	ret->isactive = 0;
+	ret->id       = NULL;
+	ret->method   = NULL;
+	ret->options  = NULL;
+	ret->priority = NULL;
+	ret->message  = NULL;
+	ret->next     = NULL;
+    }
+    return ret;
+}
+
+void free_notify_list(notify_list_t *n)
+{
+    while (n) {
+	notify_list_t *b = n->next;
+	free(n->options); /* strings live in bytecode, only free the array */
+	free(n);
+	n = b;
+    }
+}
+
+action_list_t *new_action_list(void)
+{
+    action_list_t *ret = xmalloc(sizeof(action_list_t));
+
+    if (ret != NULL) {
+	ret->a = ACTION_NONE;
+	ret->param = NULL;
+	ret->next = NULL;
+	ret->cancel_keep = 0;
+    }
+    return ret;
+}
+
+void free_action_list(action_list_t *a)
+{
+    while (a) {
+	action_list_t *b = a->next;
+
+	if(a->a == ACTION_VACATION) {
+	    if(a->u.vac.send.subj) free(a->u.vac.send.subj);
+	    if(a->u.vac.send.addr) free(a->u.vac.send.addr);
+	    if(a->u.vac.send.fromaddr) free(a->u.vac.send.fromaddr);
+	}
+
+	free(a);
+	a = b;
+    }
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/message.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/message.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/message.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/message.h	2007-07-19 21:49:24.000000000 -0600
@@ -0,0 +1,143 @@
+/* message.h
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef MESSAGE_H
+#define MESSAGE_H
+
+#include "sieve_interface.h"	/* for action contexts */
+#include "tree.h"		/* for stringlist_t */
+#include "lib.h"
+#include "hash.h"
+
+typedef struct Action action_list_t;
+
+typedef enum {
+    ACTION_NULL = -1,
+    ACTION_NONE = 0,
+    ACTION_REJECT,
+    ACTION_FILEINTO,
+    ACTION_KEEP,
+    ACTION_REDIRECT,
+    ACTION_DISCARD,
+    ACTION_VACATION,
+    ACTION_SETFLAG,
+    ACTION_ADDFLAG,
+    ACTION_REMOVEFLAG,
+    ACTION_MARK,
+    ACTION_UNMARK,
+    ACTION_NOTIFY,
+    ACTION_DENOTIFY
+} action_t;
+
+/* information */
+action_list_t *new_action_list(void);
+void free_action_list(action_list_t *actions);
+
+/* invariant: always have a dummy element when free_action_list, param
+   and vac_subj are freed.  none of the others are automatically freed.
+
+   the do_action() functions should copy param */
+struct Action {
+    action_t a;
+    int cancel_keep;
+    union {
+	sieve_reject_context_t rej;
+	sieve_fileinto_context_t fil;
+	sieve_keep_context_t keep;
+	sieve_redirect_context_t red;
+	struct {
+	    /* addr, fromaddr, subj - freed! */
+	    sieve_send_response_context_t send;
+	    sieve_autorespond_context_t autoresp;
+	} vac;
+	struct {
+	    const char *flag;
+	} fla;
+    } u;
+    char *param;		/* freed! */
+    struct Action *next;
+    char *vac_subj;		/* freed! */
+    char *vac_msg;
+    int vac_days;
+};
+
+typedef struct notify_list_s {
+    int isactive;
+    const char *id;
+    const char *method;
+    const char **options;
+    const char *priority;
+    const char *message;
+    struct notify_list_s *next;
+} notify_list_t;
+
+/* header parsing */
+typedef enum {
+    ADDRESS_ALL,
+    ADDRESS_LOCALPART,
+    ADDRESS_DOMAIN,
+    ADDRESS_USER,
+    ADDRESS_DETAIL
+} address_part_t;
+
+int parse_address(const char *header, void **data, void **marker);
+char *get_address(address_part_t addrpart, void **data, void **marker,
+		  int canon_domain);
+int free_address(void **data, void **marker);
+notify_list_t *new_notify_list(void);
+void free_notify_list(notify_list_t *n);
+
+/* actions; return negative on failure.
+ * these don't actually perform the actions, they just add it to the
+ * action list */
+int do_reject(action_list_t *m, const char *msg);
+int do_fileinto(action_list_t *m, const char *mbox, int cancel_keep,
+		sieve_imapflags_t *imapflags);
+int do_redirect(action_list_t *m, const char *addr, int cancel_keep);
+int do_keep(action_list_t *m, sieve_imapflags_t *imapflags);
+int do_discard(action_list_t *m);
+int do_vacation(action_list_t *m, char *addr, char *fromaddr,
+		char *subj, const char *msg, int days, int mime,
+		const char *handle);
+int do_setflag(action_list_t *m, const char *flag);
+int do_addflag(action_list_t *m, const char *flag);
+int do_removeflag(action_list_t *m, const char *flag);
+int do_mark(action_list_t *m);
+int do_unmark(action_list_t *m);
+int do_notify(notify_list_t *n, const char *id,
+	      const char *method, const char **options,
+	      const char *priority, const char *message);
+int do_denotify(notify_list_t *n, comparator_t *comp, const void *pat,
+		void *comprock, const char *priority);
+
+/* execute some bytecode */
+int sieve_eval_bc(sieve_execute_t *exe, int is_incl, sieve_interp_t *i,
+		  struct hash_table *body_cache, void *sc, void *m,
+		  sieve_imapflags_t * imapflags, action_list_t *actions,
+		  notify_list_t *notify_list, const char **errmsg);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/NEWS dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/NEWS
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/NEWS	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/NEWS	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,84 @@
+$Id$
+
+CMU Sieve 2.1
+-------------
+
+- Compliant with RFC 3028.  As a result, fileinto and redirect only
+  accept a single string and NOT a string-list.
+
+- Compliant with draft-martin-sieve-notify-01.  As a result, notify
+  actions will need to be updated to the new syntax.
+
+CMU Sieve 2.0
+-------------
+
+- Compliant with draft-showalter-sieve-11.txt and 
+  draft-showalter-sieve-vacation-03.txt.
+
+- Added support for the regex, imapflags, notify and subaddress extensions.
+  See README for references.
+
+- Verifies email addresses in redirect and vacation actions are syntactically
+  correct (compliant with RFC822).
+
+- Run-time error reporting.
+
+- Changed callback interface to use callback contexts instead of individual
+  parameters.  Also added an error string buffer for run-time error reporting.
+
+- Vacation will not reply to any message containing an "auto-submitted"
+  header containing anything other than "no".
+
+CMU Sieve 1.4
+-------------
+
+Now included with imapd distribution (hell, why not?).
+
+Error returning and recovering:
+	added error recovering to the parser (but not much!)
+	added error messages to the parser
+
+Working on error returning and error recovering.
+	run-time errors
+	detect some errors in lexer?
+
+Working on even better parsing:
+	verify addresses could be addresses
+	verify mailboxes could be mailboxes
+	verify outgoing headers can be headers
+
+CMU Sieve 1.3
+-------------
+
+Changed for integration with cyrus deliver.
+
+CMU Sieve 1.2
+-------------
+
+Added additional callbacks (ok, so I want to make my integration with deliver
+easier) and envelope and vacation support.
+
+Made it compile without libcyrus.
+It should compile without libcyrus, but then it does not implement the
+"address" test.	 That's just too much work to do when I have a neato
+library to do it for me.
+
+Todo:
+- regex matching
+
+CMU Sieve 1.1
+-------------
+
+- Updated to draft-showalter-sieve-07bis.txt
+
+- Simple API (see sieve_interface.h; currently mostly undocumented)
+
+- Implements all of the optional features except "envelope"
+
+- Maintains "if it parses, it probably runs" behavior. (Goal: minimize
+  run-time errors.)
+
+CMU Sieve 1.0
+-------------
+
+- prototype implementation
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/parseaddr.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/parseaddr.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/parseaddr.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/parseaddr.c	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,370 @@
+/* parseaddr.c -- RFC 822 address parser
+ * $Id$
+ *
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "parseaddr.h"
+
+#define xmalloc malloc
+#define xstrdup strdup
+
+static char parseaddr_unspecified_domain[] = "unspecified-domain";
+
+static void parseaddr_append (struct address ***addrpp, char *name,
+				char *route, char *mailbox, char *domain,
+				char **freemep);
+static int parseaddr_phrase (char **inp, char **phrasep, char *specials);
+static int parseaddr_domain (char **inp, char **domainp, char **commmentp);
+static int parseaddr_route (char **inp, char **routep);
+
+/*
+ * Parse an address list in 's', appending address structures to
+ * the list pointed to by 'addrp'.
+ */
+void
+parseaddr_list(str, addrp)
+const char *str;
+struct address **addrp;
+{
+    char *s;
+    int ingroup = 0;
+    char *freeme;
+    int tok = ' ';
+    char *phrase, *route, *mailbox, *domain, *comment;
+
+    /* Skip down to the tail */
+    while (*addrp) {
+	addrp = &(*addrp)->next;
+    }
+
+    s = freeme = xstrdup(str);
+
+    while (tok) {
+	tok = parseaddr_phrase(&s, &phrase, ingroup ? ",@<;" : ",@<:");
+	switch (tok) {
+	case ',':
+	case '\0':
+	case ';':
+	    if (*phrase) {
+		parseaddr_append(&addrp, 0, 0, phrase, "", &freeme);
+	    }
+	    if (tok == ';') {
+		parseaddr_append(&addrp, 0, 0, 0, 0, &freeme);
+		ingroup = 0;
+	    }
+	    continue;
+
+	case ':':
+	    parseaddr_append(&addrp, 0, 0, phrase, 0, &freeme);
+	    ingroup++;
+	    continue;
+
+	case '@':
+	    tok = parseaddr_domain(&s, &domain, &comment);
+	    parseaddr_append(&addrp, comment, 0, phrase, domain, &freeme);
+	    continue;
+
+	case '<':
+	    tok = parseaddr_phrase(&s, &mailbox, "@>");
+	    if (tok == '@') {
+		route = 0;
+		if (!*mailbox) {
+		    *--s = '@';
+		    tok = parseaddr_route(&s, &route);
+		    if (tok != ':') {
+			parseaddr_append(&addrp, phrase, route, "", "", &freeme);
+			while (tok && tok != '>') tok = *s++;
+			continue;
+		    }
+		    tok = parseaddr_phrase(&s, &mailbox, "@>");
+		    if (tok != '@') {
+			parseaddr_append(&addrp, phrase, route, mailbox, "",
+					 &freeme);
+			continue;
+		    }
+		}
+		tok = parseaddr_domain(&s, &domain, 0);
+		parseaddr_append(&addrp, phrase, route, mailbox, domain,
+				 &freeme);
+		while (tok && tok != '>') tok = *s++;
+		continue; /* effectively auto-inserts a comma */
+	    }
+	    else {
+		parseaddr_append(&addrp, phrase, 0, mailbox, "", &freeme);
+	    }
+	}
+    }
+    if (ingroup) parseaddr_append(&addrp, 0, 0, 0, 0, &freeme);
+
+    if (freeme) free(freeme);
+}
+
+/*
+ * Free the address list 'addr'
+ */
+void
+parseaddr_free(addr)
+struct address *addr;
+{
+    struct address *next;
+
+    while (addr) {
+	if (addr->freeme) free(addr->freeme);
+	next = addr->next;
+	free((char *)addr);
+	addr = next;
+    }
+}
+
+/*
+ * Helper function to append a new address structure to and address list.
+ */
+static void
+parseaddr_append(addrpp, name, route, mailbox, domain, freemep)
+struct address ***addrpp;
+char *name;
+char *route;
+char *mailbox;
+char *domain;
+char **freemep;
+{
+    struct address *newaddr;
+
+    newaddr = (struct address *)xmalloc(sizeof(struct address));
+    if (name && *name) {
+	newaddr->name = name;
+    }
+    else {
+	newaddr->name = 0;
+    }
+
+    if (route && *route) {
+	newaddr->route = route;
+    }
+    else {
+	newaddr->route = 0;
+    }
+
+    newaddr->mailbox = mailbox;
+
+    if (domain && !*domain) {
+	domain = parseaddr_unspecified_domain;
+    }
+    newaddr->domain = domain;
+
+    newaddr->next = 0;
+    newaddr->freeme = *freemep;
+    *freemep = 0;
+
+    **addrpp = newaddr;
+    *addrpp = &newaddr->next;
+}
+
+/* Macro to skip white space and rfc822 comments */
+
+#define SKIPWHITESPACE(s) \
+{ \
+    int _c, _comment = 0; \
+ \
+    while ((_c = *(s))) { \
+	if (_c == '(') { \
+	    _comment = 1; \
+	    (s)++; \
+	    while ((_comment && (_c = *(s)))) { \
+		(s)++; \
+		if (_c == '\\' && *(s)) (s)++; \
+		else if (_c == '(') _comment++; \
+		else if (_c == ')') _comment--; \
+	    } \
+	    (s)--; \
+	} \
+	else if (!isspace(_c)) break; \
+	(s)++; \
+    } \
+}
+
+/*
+ * Parse an RFC 822 "phrase", stopping at 'specials'
+ */
+static int parseaddr_phrase(inp, phrasep, specials)
+char **inp;
+char **phrasep;
+char *specials;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+
+    SKIPWHITESPACE(src);
+
+    *phrasep = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (c == '\"') {
+	    while ((c = *src)) {
+		src++;
+		if (c == '\"') break;
+		if (c == '\\') {
+		    if (!(c = *src)) break;
+		    src++;
+		}
+		*dst++ = c;
+	    }
+	}
+	else if (isspace(c) || c == '(') {
+	    src--;
+	    SKIPWHITESPACE(src);
+	    *dst++ = ' ';
+	}
+	else if (!c || strchr(specials, c)) {
+	    if (dst > *phrasep && dst[-1] == ' ') dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+	else {
+	    *dst++ = c;
+	}
+    }
+}
+
+/*
+ * Parse a domain.  If 'commentp' is non-nil, parses any trailing comment
+ */
+static int parseaddr_domain(inp, domainp, commentp)
+char **inp;
+char **domainp;
+char **commentp;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+    char *cdst;
+    int comment;
+
+    if (commentp) *commentp = 0;
+    SKIPWHITESPACE(src);
+
+    *domainp = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (isalnum(c) || c == '-' || c == '[' || c == ']' || c == ':') {
+	    *dst++ = c;
+	    if (commentp) *commentp = 0;
+	}
+	else if (c == '.') {
+	    if (dst > *domainp && dst[-1] != '.') *dst++ = c;
+	    if (commentp) *commentp = 0;
+	}
+	else if (c == '(') {
+	    if (commentp) {
+		*commentp = cdst = src;
+		comment = 1;
+		while (comment && (c = *src)) {
+		    src++;
+		    if (c == '(') comment++;
+		    else if (c == ')') comment--;
+		    else if (c == '\\' && (c = *src)) src++;
+
+		    if (comment) *cdst++ = c;
+		}
+		*cdst = '\0';
+	    }
+	    else {
+		src--;
+		SKIPWHITESPACE(src);
+	    }
+	}
+	else if (!isspace(c)) {
+	    if (dst > *domainp && dst[-1] == '.') dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+    }
+}
+	
+/*
+ * Parse a source route (at-domain-list)
+ */
+static int parseaddr_route(inp, routep)
+char **inp;
+char **routep;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+
+    SKIPWHITESPACE(src);
+
+    *routep = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (isalnum(c) || c == '-' || c == '[' || c == ']' ||
+	    c == ',' || c == '@') {
+	    *dst++ = c;
+	}
+	else if (c == '.') {
+	    if (dst > *routep && dst[-1] != '.') *dst++ = c;
+	}
+	else if (isspace(c) || c == '(') {
+	    src--;
+	    SKIPWHITESPACE(src);
+	}
+	else {
+	    while (dst > *routep &&
+		   (dst[-1] == '.' || dst[-1] == ',' || dst[-1] == '@')) dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+    }
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/parseaddr.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/parseaddr.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/parseaddr.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/parseaddr.h	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,69 @@
+/* parseaddr.h -- RFC 822 address parser
+ $Id$
+ 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+
+#ifndef INCLUDED_PARSEADDR_H
+#define INCLUDED_PARSEADDR_H
+
+#ifndef P
+#ifdef __STDC__
+#define P(x) x
+#else
+#define P(x) ()
+#endif
+#endif
+
+struct address {
+    char *name;
+    char *route;
+    char *mailbox;
+    char *domain;
+    struct address *next;
+    char *freeme;		/* If non-nil, free */
+};
+
+extern void parseaddr_list P((const char *s, struct address **addrp));
+extern void parseaddr_free P((struct address *addr));
+
+
+#endif /* INCLUDED_PARSEADDR_H */
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/README dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/README
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/README	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/README	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,59 @@
+$Id$
+
+CMU Sieve 2.1
+-------------
+
+This code is typically distributed as part of Cyrus imapd 1.6 and higher.
+This code will be configured and compiled from the cyrus-imapd directory.
+
+Notes on implementation
+-----------------------
+
+This is an implementation of a simple Sieve API.  This API is
+well-suited for incorporating in other programs, but is not
+extensible.  (If there is interest, we may implement an extensible API
+in the future.)
+
+If you wish to compile Sieve without compiling all of imapd, you'll
+have to create a Makefile for it.  I recommend you use Makefile.in as
+a guide.
+
+It should compile without libcyrus, but then it does not implement the
+"address" test.	 That's just too much work to do when I have a neato
+library to do it for me.
+
+There's a simple "test" application included, which is not built by
+default (type "make test" to build it).  It expects:
+
+test <message> <script>
+
+And prints out the actions taken or errors encountered.  (This
+implementation will attempt all the actions or no actions.)
+
+Questions and comments to:
+Derrick Brashear (shadow+sieve@andrew.cmu.edu)
+
+References:
+
+[SIEVE] Showalter, T., "Sieve: A Mail Filtering Language",
+RFC 3028, January, 2001.
+
+[VACATION] Showalter, T., "Sieve: Vacation Extension",
+draft-showalter-sieve-vacation-04.txt, August, 2000.
+
+[IMAPFLAGS] Melnikov, A., "Sieve -- IMAP flag extension",
+draft-melnikov-sieve-imapflags-03.txt, July, 2000.
+
+[NOTIFY] Martin, T., Segmuller, W.,
+"Sieve -- An extension for providing instant notifications",
+draft-martin-sieve-notify-01.txt, June, 2001.
+
+[REGEX] Murchison, K., "Sieve: Regular Expression Extension",
+draft-murchison-sieve-regex-04.txt, August, 2001.
+
+[RELATIONAL] Segmuller, W., "Sieve Extension: Relational Tests",
+RFC 3431, December 2002.
+
+[SUBADDR] Murchison, K., "Sieve Email Filtering -- Subaddress Extension",
+RFC 3598, September 2003.
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/script.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/script.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/script.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/script.c	2007-07-20 01:31:43.000000000 -0600
@@ -0,0 +1,886 @@
+/* script.c -- sieve script functions
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <assert.h>
+
+#include "lib.h"
+#include "xmalloc.h"
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+#include "map.h"
+#include "sieve.h"
+#include "message.h"
+#include "bytecode.h"
+#include "libconfig.h"
+
+/* does this interpretor support this requirement? */
+int script_require(sieve_script_t *s, char *req)
+{
+    unsigned long config_sieve_extensions = EXTENSIONS_ALL;
+
+    if (!strcmp("fileinto", req)) {
+	if (s->interp.fileinto &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_FILEINTO)) {
+	    s->support.fileinto = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("reject", req)) {
+	if (s->interp.reject &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_REJECT)) {
+	    s->support.reject = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("envelope", req)) {
+	if (s->interp.getenvelope &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_ENVELOPE)) {
+	    s->support.envelope = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("body", req)) {
+	if (s->interp.getbody &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_BODY)) {
+	    s->support.body = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("vacation", req)) {
+	if (s->interp.vacation &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_VACATION)) {
+	    s->support.vacation = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("imapflags", req)) {
+	if (s->interp.markflags->flag &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_IMAPFLAGS)) {
+	    s->support.imapflags = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("notify",req)) {
+	if (s->interp.notify &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_NOTIFY)) {
+	    s->support.notify = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("include", req)) {
+	if (s->interp.getinclude &&
+	    (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_INCLUDE)) {
+	    s->support.include = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+#ifdef ENABLE_REGEX
+    } else if (!strcmp("regex", req) &&
+	       (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_REGEX)) {
+	s->support.regex = 1;
+	return 1;
+#endif
+    } else if (!strcmp("subaddress", req) &&
+	       (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_SUBADDRESS)) {
+	s->support.subaddress = 1;
+	return 1;
+    } else if (!strcmp("relational", req) &&
+	       (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_RELATIONAL)) {
+	s->support.relational = 1;
+	return 1;
+    } else if (!strcmp("comparator-i;octet", req)) {
+	return 1;
+    } else if (!strcmp("comparator-i;ascii-casemap", req)) {
+	return 1;
+    } else if (!strcmp("comparator-i;ascii-numeric", req)) {
+	s->support.i_ascii_numeric = 1;
+	return 1;
+    } else if (!strcmp("copy", req) &&
+	       (config_sieve_extensions & IMAP_ENUM_SIEVE_EXTENSIONS_COPY)) {
+	s->support.copy = 1;
+	return 1;
+    }
+    return 0;
+}
+
+/* given an interpretor and a script, produce an executable script */
+int sieve_script_parse(sieve_interp_t *interp, FILE *script,
+		       void *script_context, sieve_script_t **ret)
+{
+    sieve_script_t *s;
+    int res = SIEVE_OK;
+    extern int yylineno;
+
+    res = interp_verify(interp);
+    if (res != SIEVE_OK) {
+	return res;
+    }
+
+    s = (sieve_script_t *) xmalloc(sizeof(sieve_script_t));
+    s->interp = *interp;
+    s->script_context = script_context;
+    /* clear all support bits */
+    memset(&s->support, 0, sizeof(struct sieve_support));
+
+    s->err = 0;
+
+    yylineno = 1;		/* reset line number */
+    s->cmds = sieve_parse(s, script);
+    if (s->err > 0) {
+	if (s->cmds) {
+	    free_tree(s->cmds);
+	}
+	s->cmds = NULL;
+	res = SIEVE_PARSE_ERROR;
+    }
+
+    *ret = s;
+    return res;
+}
+
+static void free_imapflags(sieve_imapflags_t *imapflags)
+{
+    while (imapflags->nflags)
+	free(imapflags->flag[--imapflags->nflags]);
+    free(imapflags->flag);
+    
+    imapflags->flag = NULL;
+}
+  
+int sieve_script_free(sieve_script_t **s)
+{
+    if (*s) {
+	if ((*s)->cmds) {
+	    free_tree((*s)->cmds);
+	}
+	free(*s);
+    }
+
+    return SIEVE_OK;
+}
+ 
+#define GROW_AMOUNT 100
+
+static void add_header(sieve_interp_t *i, int isenv, char *header, 
+		       void *message_context, char **out, 
+		       int *outlen, int *outalloc)
+{
+    const char **h;
+    int addlen;
+    /* get header value */
+    if (isenv)
+	i->getenvelope(message_context, header, &h);	
+    else
+	i->getheader(message_context, header, &h);	
+
+    if (!h || !h[0])
+	return;
+
+    addlen = strlen(h[0]) + 1;
+
+    /* realloc if necessary */
+    if ( (*outlen) + addlen >= *outalloc)
+    {
+	*outalloc = (*outlen) + addlen + GROW_AMOUNT;
+	*out = xrealloc(*out, *outalloc);
+    }
+
+    /* add header value */
+    strcat(*out,h[0]);
+
+    *outlen += addlen;
+}
+
+static int build_notify_message(sieve_interp_t *i,
+				const char *msg, 
+				void *message_context, char **out, int *outlen)
+{
+    int allocsize = GROW_AMOUNT;
+    const char *c;
+    size_t n;
+
+    *out = xmalloc(GROW_AMOUNT);
+    *outlen = 0;
+    (*out)[0]='\0';
+
+    if (msg == NULL) return SIEVE_OK;
+
+    /* construct the message */
+    c = msg;
+    while (*c) {
+	/* expand variables */
+	if (!strncasecmp(c, "$from$", 6)) {
+	    add_header(i, 0 ,"From", message_context, out, outlen, &allocsize);
+	    c += 6;
+	}
+	else if (!strncasecmp(c, "$env-from$", 10)) {
+	    add_header(i, 1, "From", message_context, out, outlen, &allocsize);
+	    c += 10;
+	}
+	else if (!strncasecmp(c, "$subject$", 9)) {
+	    add_header(i, 0, "Subject", message_context, out, outlen, &allocsize);
+	    c += 9;
+	}
+	else if (i->getbody &&
+		 !strncasecmp(c, "$text", 5) && (c[5] == '[' || c[5] == '$')) {
+	    const char *content_types[] = { "text", NULL };
+	    sieve_bodypart_t *parts = NULL;
+
+	    c += 5;
+	    n = 0;
+	    if (*c++ == '[') {
+		while (*c != ']') n = n * 10 + (*c++ - '0');
+		c += 2; /* skip ]$ */
+	    }
+
+	    i->getbody(message_context, content_types, TRUE, &parts);
+
+	    /* we only use the first text part */
+	    if (parts[0].content) {
+		const char *content = parts[0].content;
+		size_t size = parts[0].size;
+
+		if (n == 0 || n > size) n = size;
+
+		/* realloc if necessary */
+		if ( (*outlen) + n+1 >= (size_t)allocsize) {
+		    allocsize = (*outlen) + n+1 + GROW_AMOUNT;
+		    *out = xrealloc(*out, allocsize);
+		}
+		/* copy the plaintext */
+		strncat(*out, content, n);
+		(*out)[*outlen+n]='\0';
+		(*outlen) += n;
+	    }
+	}
+	else {
+	    /* find length of plaintext up to next potential variable */
+	    n = strcspn(c+1, "$") + 1; /* skip opening '$' */
+	    /* realloc if necessary */
+	    if ( (*outlen) + n+1 >= (size_t)allocsize) {
+		allocsize = (*outlen) + n+1 + GROW_AMOUNT;
+		*out = xrealloc(*out, allocsize);
+	    }
+	    /* copy the plaintext */
+	    strncat(*out, c, n);
+	    (*out)[*outlen+n]='\0';
+	    (*outlen) += n;
+	    c += n;
+	}
+    }
+
+    return SIEVE_OK;
+}
+
+static int sieve_addflag(sieve_imapflags_t *imapflags, const char *flag)
+{
+    int n;
+    /* search for flag already in list */
+    for (n = 0; n < imapflags->nflags; n++) {
+	if (!strcmp(imapflags->flag[n], flag))
+	    break;
+    }
+ 
+    /* add flag to list, iff not in list */
+    if (n == imapflags->nflags) {
+	imapflags->nflags++;
+	imapflags->flag =
+	    (char **) xrealloc((char *)imapflags->flag,
+			       imapflags->nflags*sizeof(char *));
+	imapflags->flag[imapflags->nflags-1] = xstrdup(flag);
+    }
+ 
+    return SIEVE_OK;
+}
+
+static int sieve_removeflag(sieve_imapflags_t *imapflags, const char *flag)
+{
+    int n;
+    /* search for flag already in list */
+    for (n = 0; n < imapflags->nflags; n++) {
+      if (!strcmp(imapflags->flag[n], flag))
+	break;
+    }
+    
+     /* remove flag from list, iff in list */
+    if (n < imapflags->nflags) 
+      {
+	free(imapflags->flag[n]);
+	imapflags->nflags--;
+	
+	for (; n < imapflags->nflags; n++)
+	  imapflags->flag[n] = imapflags->flag[n+1];
+	
+	if (imapflags->nflags)
+	  {imapflags->flag =
+	     (char **) xrealloc((char *)imapflags->flag,
+				imapflags->nflags*sizeof(char *));}
+	else
+	  {free(imapflags->flag);
+	  imapflags->flag=NULL;}
+      }
+    
+    return SIEVE_OK;
+}
+
+static int send_notify_callback(sieve_interp_t *interp,
+				void *message_context, 
+				void * script_context, notify_list_t *notify, 
+				char *actions_string, const char **errmsg)
+{
+    sieve_notify_context_t nc;
+    char *out_msg, *build_msg;
+    int out_msglen;    
+    int ret;
+
+    assert(notify->isactive);
+
+    if (!notify->method || !notify->options ||
+	!notify->priority || !notify->message) {
+	return SIEVE_RUN_ERROR;
+    }
+
+    nc.method = notify->method;
+    nc.options = notify->options ? notify->options : NULL;
+    nc.priority = notify->priority;
+
+    build_notify_message(interp, notify->message, message_context, 
+			 &out_msg, &out_msglen);
+
+    build_msg = xmalloc(out_msglen + strlen(actions_string) + 30);
+
+    strcpy(build_msg, out_msg);
+    strcat(build_msg, "\n\n");
+    strcat(build_msg, actions_string);
+
+    nc.message = build_msg;
+
+    free(out_msg);
+
+    ret = interp->notify(&nc,
+			 interp->interp_context,
+			 script_context,
+			 message_context,
+			 errmsg);    
+
+    free(build_msg);
+
+    return ret;
+}
+
+static char *action_to_string(action_t action)
+{
+    switch(action)
+	{
+	case ACTION_REJECT: return "Reject";
+	case ACTION_FILEINTO: return "Fileinto";
+	case ACTION_KEEP: return "Keep";
+	case ACTION_REDIRECT: return "Redirect";
+	case ACTION_DISCARD: return "Discard";
+	case ACTION_VACATION: return "Vacation";
+	case ACTION_SETFLAG: return "Setflag";
+	case ACTION_ADDFLAG: return "Addflag";
+	case ACTION_REMOVEFLAG: return "Removeflag";
+	case ACTION_MARK: return "Mark";
+	case ACTION_UNMARK: return "Unmark";
+	case ACTION_NOTIFY: return "Notify";
+	case ACTION_DENOTIFY: return "Denotify";
+	default: return "Unknown";
+	}
+
+    /* never reached */
+}
+
+static char *sieve_errstr(int code)
+{
+    switch (code)
+	{
+	case SIEVE_FAIL: return "Generic Error";
+	case SIEVE_NOT_FINALIZED: return "Sieve not finalized";
+	case SIEVE_PARSE_ERROR: return "Parse error";
+	case SIEVE_RUN_ERROR: return "Run error";
+	case SIEVE_INTERNAL_ERROR: return "Internal Error";
+	case SIEVE_NOMEM: return "No memory";
+	default: return "Unknown error";
+	}
+
+    /* never reached */
+}
+
+
+/******************************bytecode functions*****************************
+ *****************************************************************************/
+
+/* Load a compiled script */
+int sieve_script_load(const char *fname, sieve_execute_t **ret) 
+{
+    struct stat sbuf;
+    sieve_execute_t *r;
+    sieve_bytecode_t *bc;
+   
+    if (!fname || !ret) return SIEVE_FAIL;
+    
+    if (stat(fname, &sbuf) == -1) {
+        if (errno != ENOENT)
+	    i_error("IOERROR: stating sieve script %s: %m", fname);
+	return SIEVE_FAIL;
+    }
+
+    if (!*ret) {
+	/* new sieve_bytecode_t */
+	r = (sieve_execute_t *) xzmalloc(sizeof(sieve_execute_t));
+    } else {
+	/* existing sieve_execute_t (INCLUDE) */
+	r = *ret;
+    }
+
+    /* see if we already have this script loaded */
+    bc = r->bc_list;
+    while (bc) {
+	if (sbuf.st_ino == bc->inode) break;
+	bc = bc->next;
+    }
+
+    if (!bc) {
+	int fd;
+
+	/* new script -- load it */
+	fd = open(fname, O_RDONLY);
+	if (fd == -1) {
+            if (errno != ENOENT)
+                i_error("IOERROR: can not open sieve script %s: %m", fname);
+	    return SIEVE_FAIL;
+	}
+        if (fstat(fd, &sbuf) == -1) {
+            i_error("IOERROR: fstating sieve script %s: %m", fname);
+            close(fd);
+            return SIEVE_FAIL;
+	}
+
+	bc = (sieve_bytecode_t *) xzmalloc(sizeof(sieve_bytecode_t));
+
+	bc->fd = fd;
+	bc->inode = sbuf.st_ino;
+
+	map_refresh(fd, 1, &bc->data, &bc->len, sbuf.st_size,
+		    fname, "sievescript");
+
+	/* add buffer to list */
+	bc->next = r->bc_list;
+	r->bc_list = bc;
+    }
+
+    r->bc_cur = bc;
+    *ret = r;
+    return SIEVE_OK;
+}
+
+
+
+int sieve_script_unload(sieve_execute_t **s) 
+{
+    if(s && *s) {
+	sieve_bytecode_t *bc = (*s)->bc_list;
+
+	/* free each bytecode buffer in the linked list */
+	while (bc) {
+	    map_free(&(bc->data), &(bc->len));
+	    close(bc->fd);
+	    bc = bc->next;
+	}
+	free(*s);
+	*s = NULL;
+    } 
+    /*i added this else, i'm not sure why, but this function always returned SIEVE_FAIL*/
+    else
+      return SIEVE_FAIL;
+    return SIEVE_OK;
+}
+
+
+#define ACTIONS_STRING_LEN 4096
+
+static int do_sieve_error(int ret,
+			  sieve_interp_t *interp,
+			  void *script_context,
+			  void *message_context,
+			  sieve_imapflags_t * imapflags,
+			  action_list_t *actions,
+			  notify_list_t *notify_list,
+			  /* notify_action_t *notify_action,*/
+			  int lastaction,
+			  int implicit_keep,
+			  char *actions_string,
+			  const char *errmsg
+			  ) 
+{
+   if (ret != SIEVE_OK) {
+	if (lastaction == -1) /* we never executed an action */
+	    snprintf(actions_string+strlen(actions_string),
+		     ACTIONS_STRING_LEN-strlen(actions_string),
+		     "script execution failed: %s\n",
+		     errmsg ? errmsg : sieve_errstr(ret));
+	else
+	    snprintf(actions_string+strlen(actions_string),
+		     ACTIONS_STRING_LEN-strlen(actions_string),
+		     "%s action failed: %s\n",
+		     action_to_string(lastaction),
+		     errmsg ? errmsg : sieve_errstr(ret));
+    }
+ 
+   
+    /* Process notify actions */
+    if (interp->notify && notify_list) 
+      {
+	notify_list_t *n = notify_list;
+	int notify_ret = SIEVE_OK;
+	
+	while (n != NULL) 
+	  {
+	    if (n->isactive) 
+	      {
+	      lastaction = ACTION_NOTIFY;
+	       notify_ret = send_notify_callback(interp,
+						 message_context, 
+						 script_context,n,
+						 actions_string, &errmsg);
+	      ret |= notify_ret;
+	      }
+	    n = n->next;
+	  }
+	
+	if (notify_list) free_notify_list(notify_list);
+	notify_list = NULL;	/* don't try any notifications again */
+	
+	
+	if (notify_ret != SIEVE_OK) 
+	  return do_sieve_error(ret, interp, 
+				script_context, message_context,
+				imapflags, actions, notify_list, lastaction,
+				implicit_keep, actions_string, errmsg);
+      
+      }
+    
+    if ((ret != SIEVE_OK) && interp->err) {
+	char buf[1024];
+	if (lastaction == -1) /* we never executed an action */
+	    sprintf(buf, "%s", errmsg ? errmsg : sieve_errstr(ret));
+	else
+	    sprintf(buf, "%s: %s", action_to_string(lastaction),
+		    errmsg ? errmsg : sieve_errstr(ret));
+ 
+	ret |= interp->execute_err(buf, interp->interp_context,
+				   script_context, message_context);
+    }
+
+    if (implicit_keep) {
+	sieve_keep_context_t keep_context;
+	int keep_ret;
+	keep_context.imapflags = imapflags;
+ 
+	lastaction = ACTION_KEEP;
+	keep_ret = interp->keep(&keep_context, interp->interp_context,
+				script_context, message_context, &errmsg);
+	ret |= keep_ret;
+        if (keep_ret == SIEVE_OK)
+            snprintf(actions_string+strlen(actions_string),
+		     sizeof(actions_string)-strlen(actions_string),
+		     "Kept\n");
+	else {
+	    implicit_keep = 0;	/* don't try an implicit keep again */
+	    return do_sieve_error(ret, interp, 
+				  script_context, message_context,
+				  imapflags, actions, notify_list, lastaction,
+				  implicit_keep, actions_string, errmsg);
+	}
+    }
+
+    if (actions)
+	free_action_list(actions);
+
+    return ret;
+}
+
+
+static int do_action_list(sieve_interp_t *interp,
+			  void *script_context,
+			  void *message_context,
+			  sieve_imapflags_t *imapflags,
+			  action_list_t *actions,
+			  notify_list_t *notify_list,
+			  /* notify_action_t *notify_action,*/
+			  char *actions_string,
+			  const char *errmsg) 
+{
+    action_list_t *a;
+    action_t lastaction = -1;
+    int ret = 0;
+    int implicit_keep = 1;
+    
+    strcpy(actions_string,"Action(s) taken:\n");
+  
+    /* now perform actions attached to m */
+    a = actions;
+    while (a != NULL) {
+	lastaction = a->a;
+	errmsg = NULL;
+	implicit_keep = implicit_keep && !a->cancel_keep;
+	switch (a->a) {
+	case ACTION_REJECT:
+	    if (!interp->reject)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->reject(&a->u.rej,
+				 interp->interp_context,
+				 script_context,
+				 message_context,
+				 &errmsg);
+	    
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string), 
+			 "Rejected with: %s\n", a->u.rej.msg);
+
+	    break;
+	case ACTION_FILEINTO:
+	    if (!interp->fileinto)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->fileinto(&a->u.fil,
+				   interp->interp_context,
+				   script_context,
+				   message_context,
+				   &errmsg);
+
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Filed into: %s\n",a->u.fil.mailbox);
+	    break;
+	case ACTION_KEEP:
+	    if (!interp->keep)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->keep(&a->u.keep,
+			       interp->interp_context,
+			       script_context,
+			       message_context,
+			       &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Kept\n");
+	    break;
+	case ACTION_REDIRECT:
+	    if (!interp->redirect)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->redirect(&a->u.red,
+				   interp->interp_context,
+				   script_context,
+				   message_context,
+				   &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Redirected to %s\n", a->u.red.addr);
+	    break;
+	case ACTION_DISCARD:
+	    if (interp->discard) /* discard is optional */
+		ret = interp->discard(NULL, interp->interp_context,
+				      script_context,
+				      message_context,
+				      &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Discarded\n");
+	    break;
+
+	case ACTION_VACATION:
+	    {
+		if (!interp->vacation)
+		    return SIEVE_INTERNAL_ERROR;
+
+		/* first, let's figure out if we should respond to this */
+		ret = interp->vacation->autorespond(&a->u.vac.autoresp,
+						    interp->interp_context,
+						    script_context,
+						    message_context,
+						    &errmsg);
+
+		if (ret == SIEVE_OK) {
+		    /* send the response */
+		    ret = interp->vacation->send_response(&a->u.vac.send,
+							  interp->interp_context,
+							  script_context, 
+							  message_context,
+							  &errmsg);
+
+		    if (ret == SIEVE_OK)
+			snprintf(actions_string+strlen(actions_string),
+				 sizeof(actions_string)-strlen(actions_string),
+				 "Sent vacation reply\n");
+
+		} else if (ret == SIEVE_DONE) {
+		    snprintf(actions_string+strlen(actions_string),
+			     sizeof(actions_string)-strlen(actions_string),
+			     "Vacation reply suppressed\n");
+
+		    ret = SIEVE_OK;
+		}
+	    
+		break;
+	    }
+
+ 
+	case ACTION_SETFLAG:
+	    free_imapflags(imapflags);
+	    ret = sieve_addflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_ADDFLAG:
+	    ret = sieve_addflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_REMOVEFLAG:
+	    ret = sieve_removeflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_MARK:
+	    {
+		int n = interp->markflags->nflags;
+
+		ret = SIEVE_OK;
+		while (n && ret == SIEVE_OK) {
+		    ret = sieve_addflag(imapflags,
+					interp->markflags->flag[--n]);
+		}
+		break;
+	    }
+	case ACTION_UNMARK:
+	  {
+	   
+		int n = interp->markflags->nflags;
+		ret = SIEVE_OK;
+		while (n && ret == SIEVE_OK) {
+		    ret = sieve_removeflag(imapflags,
+					   interp->markflags->flag[--n]);
+		}
+		break;
+	    }
+
+	case ACTION_NONE:
+	    break;
+
+	default:
+	    ret = SIEVE_INTERNAL_ERROR;
+	    break;
+	}
+	a = a->next;
+
+	if (ret != SIEVE_OK) {
+	    /* uh oh! better bail! */
+	    break;
+	}
+    }
+
+    return do_sieve_error(ret, interp, 
+			  script_context, message_context, 
+			  imapflags, actions, notify_list, lastaction, 
+			  implicit_keep, actions_string, errmsg);
+}
+
+
+int sieve_execute_bytecode(sieve_execute_t *exe, sieve_interp_t *interp,
+			   void *script_context, void *message_context) 
+{
+    action_list_t *actions = NULL;
+    notify_list_t *notify_list = NULL;
+    /*   notify_action_t *notify_action;*/
+    action_t lastaction = -1;
+    int ret;
+    char actions_string[ACTIONS_STRING_LEN] = "";
+    const char *errmsg = NULL;
+    sieve_imapflags_t imapflags;
+
+    if (!interp) return SIEVE_FAIL;
+
+    imapflags.flag = NULL; 
+    imapflags.nflags = 0;
+    
+    if (interp->notify) {
+	notify_list = new_notify_list();
+	if (notify_list == NULL) {
+	    return do_sieve_error(SIEVE_NOMEM, interp,
+				  script_context, message_context, &imapflags,
+				  actions, notify_list, lastaction, 0,
+				  actions_string, errmsg);
+	}
+    }
+
+    actions = new_action_list();
+    if (actions == NULL) {
+	ret = do_sieve_error(SIEVE_NOMEM, interp,
+			     script_context, message_context, &imapflags,
+			     actions, notify_list, lastaction, 0,
+			     actions_string, errmsg);
+    }
+    else {
+	ret = sieve_eval_bc(exe, 0, interp, NULL,
+			    script_context, message_context,
+			    &imapflags, actions, notify_list, &errmsg);
+
+	if (ret < 0) {
+	    ret = do_sieve_error(SIEVE_RUN_ERROR, interp,
+				 script_context, message_context, &imapflags,
+				 actions, notify_list, lastaction, 0,
+				 actions_string, errmsg);
+	}
+	else {
+	    ret = do_action_list(interp,
+				 script_context, message_context, 
+				 &imapflags, actions, notify_list,
+				 actions_string, errmsg);
+	}
+    }
+    return ret;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/script.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/script.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/script.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/script.h	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,87 @@
+/* script.h -- script definition
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef SIEVE_SCRIPT_H
+#define SIEVE_SCRIPT_H
+
+#include <sys/types.h>
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "tree.h"
+
+#define ADDRERR_SIZE 500
+
+struct sieve_script {
+    sieve_interp_t interp;
+
+    /* was a "require" done for these? */
+    struct sieve_support {
+	int fileinto       : 1;
+	int reject         : 1;
+	int envelope       : 1;
+	int body           : 1;
+	int vacation       : 1;
+	int imapflags      : 1;
+	int notify         : 1;
+	int regex          : 1;
+	int subaddress     : 1;
+	int relational     : 1;
+	int i_ascii_numeric: 1;
+	int include        : 1;
+	int copy           : 1;
+    } support;
+
+    void *script_context;
+    commandlist_t *cmds;
+
+    int err;
+};
+
+typedef struct sieve_bytecode sieve_bytecode_t;
+
+struct sieve_bytecode {
+    ino_t inode;		/* used to prevent mmapping the same script */
+    const char *data;
+    unsigned long len;
+    int fd;
+
+    int is_executing;		/* used to prevent recursive INCLUDEs */
+
+    sieve_bytecode_t *next;
+};
+
+struct sieve_execute {
+    sieve_bytecode_t *bc_list;	/* list of loaded bytecode buffers */
+    sieve_bytecode_t *bc_cur;	/* currently active bytecode buffer */
+};
+
+/* generated by the yacc script */
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f);
+int script_require(sieve_script_t *s, char *req);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve.c	2007-08-09 06:44:02.000000000 -0600
@@ -0,0 +1,3473 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse sieveparse
+#define yylex   sievelex
+#define yyerror sieveerror
+#define yylval  sievelval
+#define yychar  sievechar
+#define yydebug sievedebug
+#define yynerrs sievenerrs
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NUMBER = 258,
+     STRING = 259,
+     IF = 260,
+     ELSIF = 261,
+     ELSE = 262,
+     REJCT = 263,
+     FILEINTO = 264,
+     REDIRECT = 265,
+     KEEP = 266,
+     STOP = 267,
+     DISCARD = 268,
+     VACATION = 269,
+     REQUIRE = 270,
+     SETFLAG = 271,
+     ADDFLAG = 272,
+     REMOVEFLAG = 273,
+     MARK = 274,
+     UNMARK = 275,
+     NOTIFY = 276,
+     DENOTIFY = 277,
+     ANYOF = 278,
+     ALLOF = 279,
+     EXISTS = 280,
+     SFALSE = 281,
+     STRUE = 282,
+     HEADER = 283,
+     NOT = 284,
+     SIZE = 285,
+     ADDRESS = 286,
+     ENVELOPE = 287,
+     BODY = 288,
+     COMPARATOR = 289,
+     IS = 290,
+     CONTAINS = 291,
+     MATCHES = 292,
+     REGEX = 293,
+     COUNT = 294,
+     VALUE = 295,
+     OVER = 296,
+     UNDER = 297,
+     GT = 298,
+     GE = 299,
+     LT = 300,
+     LE = 301,
+     EQ = 302,
+     NE = 303,
+     ALL = 304,
+     LOCALPART = 305,
+     DOMAIN = 306,
+     USER = 307,
+     DETAIL = 308,
+     RAW = 309,
+     TEXT = 310,
+     CONTENT = 311,
+     DAYS = 312,
+     ADDRESSES = 313,
+     SUBJECT = 314,
+     FROM = 315,
+     HANDLE = 316,
+     MIME = 317,
+     METHOD = 318,
+     ID = 319,
+     OPTIONS = 320,
+     LOW = 321,
+     NORMAL = 322,
+     HIGH = 323,
+     ANY = 324,
+     MESSAGE = 325,
+     INCLUDE = 326,
+     PERSONAL = 327,
+     GLOBAL = 328,
+     RETURN = 329,
+     COPY = 330
+   };
+#endif
+/* Tokens.  */
+#define NUMBER 258
+#define STRING 259
+#define IF 260
+#define ELSIF 261
+#define ELSE 262
+#define REJCT 263
+#define FILEINTO 264
+#define REDIRECT 265
+#define KEEP 266
+#define STOP 267
+#define DISCARD 268
+#define VACATION 269
+#define REQUIRE 270
+#define SETFLAG 271
+#define ADDFLAG 272
+#define REMOVEFLAG 273
+#define MARK 274
+#define UNMARK 275
+#define NOTIFY 276
+#define DENOTIFY 277
+#define ANYOF 278
+#define ALLOF 279
+#define EXISTS 280
+#define SFALSE 281
+#define STRUE 282
+#define HEADER 283
+#define NOT 284
+#define SIZE 285
+#define ADDRESS 286
+#define ENVELOPE 287
+#define BODY 288
+#define COMPARATOR 289
+#define IS 290
+#define CONTAINS 291
+#define MATCHES 292
+#define REGEX 293
+#define COUNT 294
+#define VALUE 295
+#define OVER 296
+#define UNDER 297
+#define GT 298
+#define GE 299
+#define LT 300
+#define LE 301
+#define EQ 302
+#define NE 303
+#define ALL 304
+#define LOCALPART 305
+#define DOMAIN 306
+#define USER 307
+#define DETAIL 308
+#define RAW 309
+#define TEXT 310
+#define CONTENT 311
+#define DAYS 312
+#define ADDRESSES 313
+#define SUBJECT 314
+#define FROM 315
+#define HANDLE 316
+#define MIME 317
+#define METHOD 318
+#define ID 319
+#define OPTIONS 320
+#define LOW 321
+#define NORMAL 322
+#define HIGH 323
+#define ANY 324
+#define MESSAGE 325
+#define INCLUDE 326
+#define PERSONAL 327
+#define GLOBAL 328
+#define RETURN 329
+#define COPY 330
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "sieve.y"
+
+/* sieve.y -- sieve parser
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include "xmalloc.h"
+#include "comparator.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+
+#include "imparse.h"
+#include "libconfig.h"
+
+    /* definitions */
+    extern int addrparse(void);
+
+struct vtags {
+    int days;
+    stringlist_t *addresses;
+    char *subject;
+    char *from;
+    char *handle;
+    int mime;
+};
+
+struct htags {
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct aetags {
+    int addrtag;
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct btags {
+    int transform;
+    int offset;
+    stringlist_t *content_types;
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct ntags {
+    char *method;
+    char *id;
+    stringlist_t *options;
+    int priority;
+    char *message;
+};
+
+struct dtags {
+    int comptag;
+    int relation;
+    void *pattern;
+    int priority;
+};
+
+static commandlist_t *ret;
+static sieve_script_t *parse_script;
+static int check_reqs(stringlist_t *sl);
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl);
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl);
+static test_t *build_body(int t, struct btags *b, stringlist_t *pl);
+static commandlist_t *build_vacation(int t, struct vtags *h, char *s);
+static commandlist_t *build_notify(int t, struct ntags *n);
+static commandlist_t *build_denotify(int t, struct dtags *n);
+static commandlist_t *build_fileinto(int t, int c, char *f);
+static commandlist_t *build_redirect(int t, int c, char *a);
+static struct aetags *new_aetags(void);
+static struct aetags *canon_aetags(struct aetags *ae);
+static void free_aetags(struct aetags *ae);
+static struct htags *new_htags(void);
+static struct htags *canon_htags(struct htags *h);
+static void free_htags(struct htags *h);
+static struct btags *new_btags(void);
+static struct btags *canon_btags(struct btags *b);
+static void free_btags(struct btags *b);
+static struct vtags *new_vtags(void);
+static struct vtags *canon_vtags(struct vtags *v);
+static void free_vtags(struct vtags *v);
+static struct ntags *new_ntags(void);
+static struct ntags *canon_ntags(struct ntags *n);
+static void free_ntags(struct ntags *n);
+static struct dtags *new_dtags(void);
+static struct dtags *canon_dtags(struct dtags *d);
+static void free_dtags(struct dtags *d);
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *));
+static int verify_mailbox(char *s);
+static int verify_address(char *s);
+static int verify_header(char *s);
+static int verify_addrheader(char *s);
+static int verify_envelope(char *s);
+static int verify_flag(char *s);
+static int verify_relat(char *s);
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags);
+static int verify_regexs(stringlist_t *sl, char *comp);
+#endif
+static int verify_utf8(char *s);
+
+int yyerror(char *msg);
+extern int yylex(void);
+extern void yyrestart(FILE *f);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 148 "sieve.y"
+{
+    int nval;
+    char *sval;
+    stringlist_t *sl;
+    test_t *test;
+    testlist_t *testl;
+    commandlist_t *cl;
+    struct vtags *vtag;
+    struct aetags *aetag;
+    struct htags *htag;
+    struct btags *btag;
+    struct ntags *ntag;
+    struct dtags *dtag;
+}
+/* Line 187 of yacc.c.  */
+#line 416 "sieve.c"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 429 "sieve.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  8
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   248
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  84
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  28
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  106
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  164
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   330
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      82,    83,     2,     2,    79,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    76,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    77,     2,    78,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    80,     2,    81,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     8,     9,    12,    16,    18,    21,
+      24,    29,    32,    33,    38,    41,    44,    48,    52,    54,
+      56,    58,    62,    65,    68,    71,    73,    75,    78,    81,
+      85,    87,    88,    90,    92,    93,    97,   101,   105,   108,
+     112,   113,   116,   120,   124,   126,   128,   130,   131,   135,
+     139,   143,   147,   151,   154,   158,   160,   162,   166,   170,
+     173,   176,   179,   182,   184,   186,   191,   196,   200,   203,
+     207,   209,   211,   213,   214,   217,   220,   224,   228,   229,
+     232,   236,   240,   241,   244,   247,   251,   254,   258,   262,
+     264,   266,   268,   270,   272,   274,   276,   278,   280,   282,
+     284,   286,   288,   289,   291,   295,   297
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      85,     0,    -1,    86,    -1,    86,    88,    -1,    -1,    87,
+      86,    -1,    15,    97,    76,    -1,    89,    -1,    89,    88,
+      -1,    91,    76,    -1,     5,   100,    99,    90,    -1,     1,
+      76,    -1,    -1,     6,   100,    99,    90,    -1,     7,    99,
+      -1,     8,     4,    -1,     9,   109,     4,    -1,    10,   109,
+       4,    -1,    11,    -1,    12,    -1,    13,    -1,    14,    96,
+       4,    -1,    16,    97,    -1,    17,    97,    -1,    18,    97,
+      -1,    19,    -1,    20,    -1,    21,    93,    -1,    22,    94,
+      -1,    71,    92,     4,    -1,    74,    -1,    -1,    72,    -1,
+      73,    -1,    -1,    93,    64,     4,    -1,    93,    63,     4,
+      -1,    93,    65,    97,    -1,    93,    95,    -1,    93,    70,
+       4,    -1,    -1,    94,    95,    -1,    94,   106,     4,    -1,
+      94,   107,     4,    -1,    66,    -1,    67,    -1,    68,    -1,
+      -1,    96,    57,     3,    -1,    96,    58,    97,    -1,    96,
+      59,     4,    -1,    96,    60,     4,    -1,    96,    61,     4,
+      -1,    96,    62,    -1,    77,    98,    78,    -1,     4,    -1,
+       4,    -1,     4,    79,    98,    -1,    80,    88,    81,    -1,
+      80,    81,    -1,    23,   110,    -1,    24,   110,    -1,    25,
+      97,    -1,    26,    -1,    27,    -1,    28,   103,    97,    97,
+      -1,   101,   102,    97,    97,    -1,    33,   104,    97,    -1,
+      29,   100,    -1,    30,   108,     3,    -1,     1,    -1,    31,
+      -1,    32,    -1,    -1,   102,   105,    -1,   102,   106,    -1,
+     102,   107,     4,    -1,   102,    34,     4,    -1,    -1,   103,
+     106,    -1,   103,   107,     4,    -1,   103,    34,     4,    -1,
+      -1,   104,    54,    -1,   104,    55,    -1,   104,    56,    97,
+      -1,   104,   106,    -1,   104,   107,     4,    -1,   104,    34,
+       4,    -1,    49,    -1,    50,    -1,    51,    -1,    52,    -1,
+      53,    -1,    35,    -1,    36,    -1,    37,    -1,    38,    -1,
+      39,    -1,    40,    -1,    41,    -1,    42,    -1,    -1,    75,
+      -1,    82,   111,    83,    -1,   100,    -1,   100,    79,   111,
+      -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   194,   194,   195,   198,   199,   202,   208,   209,   212,
+     213,   214,   217,   218,   219,   222,   231,   239,   243,   244,
+     245,   246,   255,   264,   273,   282,   287,   293,   301,   311,
+     318,   325,   326,   327,   330,   331,   334,   337,   340,   343,
+     348,   349,   352,   367,   377,   378,   379,   382,   383,   386,
+     394,   400,   406,   412,   418,   419,   422,   423,   426,   427,
+     430,   431,   432,   433,   434,   435,   459,   481,   507,   508,
+     510,   513,   514,   521,   522,   527,   531,   539,   549,   550,
+     554,   562,   572,   573,   578,   583,   591,   595,   603,   614,
+     615,   616,   617,   622,   628,   629,   630,   631,   638,   643,
+     651,   652,   655,   656,   663,   666,   667
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "NUMBER", "STRING", "IF", "ELSIF",
+  "ELSE", "REJCT", "FILEINTO", "REDIRECT", "KEEP", "STOP", "DISCARD",
+  "VACATION", "REQUIRE", "SETFLAG", "ADDFLAG", "REMOVEFLAG", "MARK",
+  "UNMARK", "NOTIFY", "DENOTIFY", "ANYOF", "ALLOF", "EXISTS", "SFALSE",
+  "STRUE", "HEADER", "NOT", "SIZE", "ADDRESS", "ENVELOPE", "BODY",
+  "COMPARATOR", "IS", "CONTAINS", "MATCHES", "REGEX", "COUNT", "VALUE",
+  "OVER", "UNDER", "GT", "GE", "LT", "LE", "EQ", "NE", "ALL", "LOCALPART",
+  "DOMAIN", "USER", "DETAIL", "RAW", "TEXT", "CONTENT", "DAYS",
+  "ADDRESSES", "SUBJECT", "FROM", "HANDLE", "MIME", "METHOD", "ID",
+  "OPTIONS", "LOW", "NORMAL", "HIGH", "ANY", "MESSAGE", "INCLUDE",
+  "PERSONAL", "GLOBAL", "RETURN", "COPY", "';'", "'['", "']'", "','",
+  "'{'", "'}'", "'('", "')'", "$accept", "start", "reqs", "require",
+  "commands", "command", "elsif", "action", "location", "ntags", "dtags",
+  "priority", "vtags", "stringlist", "strings", "block", "test",
+  "addrorenv", "aetags", "htags", "btags", "addrparttag", "comptag",
+  "relcomp", "sizetag", "copy", "testlist", "tests", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,    59,    91,    93,    44,
+     123,   125,    40,    41
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    84,    85,    85,    86,    86,    87,    88,    88,    89,
+      89,    89,    90,    90,    90,    91,    91,    91,    91,    91,
+      91,    91,    91,    91,    91,    91,    91,    91,    91,    91,
+      91,    92,    92,    92,    93,    93,    93,    93,    93,    93,
+      94,    94,    94,    94,    95,    95,    95,    96,    96,    96,
+      96,    96,    96,    96,    97,    97,    98,    98,    99,    99,
+     100,   100,   100,   100,   100,   100,   100,   100,   100,   100,
+     100,   101,   101,   102,   102,   102,   102,   102,   103,   103,
+     103,   103,   104,   104,   104,   104,   104,   104,   104,   105,
+     105,   105,   105,   105,   106,   106,   106,   106,   107,   107,
+     108,   108,   109,   109,   110,   111,   111
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     0,     2,     3,     1,     2,     2,
+       4,     2,     0,     4,     2,     2,     3,     3,     1,     1,
+       1,     3,     2,     2,     2,     1,     1,     2,     2,     3,
+       1,     0,     1,     1,     0,     3,     3,     3,     2,     3,
+       0,     2,     3,     3,     1,     1,     1,     0,     3,     3,
+       3,     3,     3,     2,     3,     1,     1,     3,     3,     2,
+       2,     2,     2,     1,     1,     4,     4,     3,     2,     3,
+       1,     1,     1,     0,     2,     2,     3,     3,     0,     2,
+       3,     3,     0,     2,     2,     3,     2,     3,     3,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     0,     1,     3,     1,     3
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       4,     0,     0,     0,     4,    55,     0,     0,     1,     0,
+       0,     0,   102,   102,    18,    19,    20,    47,     0,     0,
+       0,    25,    26,    34,    40,    31,    30,     3,     0,     0,
+       5,    56,     0,     6,    11,    70,     0,     0,     0,    63,
+      64,    78,     0,     0,    71,    72,    82,     0,    73,    15,
+     103,     0,     0,     0,    22,    23,    24,    27,    28,    32,
+      33,     0,     8,     9,     0,    54,     0,    60,    61,    62,
+       0,    68,   100,   101,     0,     0,     0,    12,     0,    16,
+      17,    21,     0,     0,     0,     0,     0,    53,     0,     0,
+       0,    44,    45,    46,     0,    38,    94,    95,    96,    97,
+      98,    99,    41,     0,     0,    29,    57,   105,     0,     0,
+       0,    79,     0,    69,     0,    83,    84,     0,    67,    86,
+       0,    59,     0,     0,     0,    10,     0,    89,    90,    91,
+      92,    93,     0,    74,    75,     0,    48,    49,    50,    51,
+      52,    36,    35,    37,    39,    42,    43,     0,   104,    81,
+      65,    80,    88,    85,    87,    58,     0,    14,    77,    66,
+      76,   106,    12,    13
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     2,     3,     4,    27,    28,   125,    29,    61,    57,
+      58,    95,    53,     7,    32,    77,   107,    48,    78,    70,
+      75,   133,   103,   104,    74,    51,    67,   108
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -113
+static const yytype_int16 yypact[] =
+{
+      -4,     0,    54,   112,    -4,  -113,    25,   -20,  -113,   -12,
+     215,    55,    -1,    -1,  -113,  -113,  -113,  -113,     0,     0,
+       0,  -113,  -113,  -113,  -113,   -64,  -113,  -113,     5,     2,
+    -113,     1,    -3,  -113,  -113,  -113,     6,     6,     0,  -113,
+    -113,  -113,   215,   -10,  -113,  -113,  -113,     4,  -113,  -113,
+    -113,    77,    78,    85,  -113,  -113,  -113,     3,   135,  -113,
+    -113,    79,  -113,  -113,    25,  -113,   215,  -113,  -113,  -113,
+     160,  -113,  -113,  -113,    82,   153,    29,    56,   101,  -113,
+    -113,  -113,    84,     0,    86,    87,    89,  -113,    90,    91,
+       0,  -113,  -113,  -113,    92,  -113,  -113,  -113,  -113,  -113,
+    -113,  -113,  -113,    93,    94,  -113,  -113,    22,    19,   100,
+       0,  -113,   102,  -113,   103,  -113,  -113,     0,  -113,  -113,
+     104,  -113,    28,   215,     4,  -113,   107,  -113,  -113,  -113,
+    -113,  -113,     0,  -113,  -113,   111,  -113,  -113,  -113,  -113,
+    -113,  -113,  -113,  -113,  -113,  -113,  -113,   215,  -113,  -113,
+    -113,  -113,  -113,  -113,  -113,  -113,     4,  -113,  -113,  -113,
+    -113,  -113,    56,  -113
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -113,  -113,   114,  -113,   -21,  -113,   -43,  -113,  -113,  -113,
+    -113,    69,  -113,   -18,    95,  -112,    -7,  -113,  -113,  -113,
+    -113,  -113,   -42,   -17,  -113,   136,   118,     9
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -8
+static const yytype_int16 yytable[] =
+{
+      54,    55,    56,    47,     5,    -7,     9,    62,    59,    60,
+      10,     1,   157,    11,    12,    13,    14,    15,    16,    17,
+      69,    18,    19,    20,    21,    22,    23,    24,   111,    31,
+       9,    72,    73,   119,    10,    71,   134,    11,    12,    13,
+      14,    15,    16,    17,   162,    18,    19,    20,    21,    22,
+      23,    24,   110,   112,     8,   122,    33,   118,   120,    49,
+     132,   135,   123,   124,    34,   137,    88,    89,    90,    91,
+      92,    93,   143,    94,    50,    65,    25,     6,    63,    26,
+      64,    79,    80,   105,    76,   113,    -7,   136,    66,    81,
+     138,   139,   150,   140,   141,   142,   144,   145,   146,   153,
+      25,   147,   148,    26,   149,     5,   151,   152,   154,   155,
+     121,   158,    -2,     9,   159,   160,   156,    10,    30,   163,
+      11,    12,    13,    14,    15,    16,    17,   102,    18,    19,
+      20,    21,    22,    23,    24,   126,    96,    97,    98,    99,
+     100,   101,    82,    83,    84,    85,    86,    87,     0,    52,
+     127,   128,   129,   130,   131,    68,   161,     5,     0,   106,
+       0,     0,     0,     0,     5,     0,     0,     0,     0,     0,
+      96,    97,    98,    99,   100,   101,     0,     0,     6,     0,
+       0,     0,     0,    25,     0,     0,    26,   114,    96,    97,
+      98,    99,   100,   101,   109,    96,    97,    98,    99,   100,
+     101,    91,    92,    93,     0,     0,     0,   115,   116,   117,
+       0,     0,     0,     0,     0,     0,    35,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       6,     0,     0,     0,     0,     0,     0,     6,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    46
+};
+
+static const yytype_int16 yycheck[] =
+{
+      18,    19,    20,    10,     4,     0,     1,    28,    72,    73,
+       5,    15,   124,     8,     9,    10,    11,    12,    13,    14,
+      38,    16,    17,    18,    19,    20,    21,    22,    70,     4,
+       1,    41,    42,    75,     5,    42,    78,     8,     9,    10,
+      11,    12,    13,    14,   156,    16,    17,    18,    19,    20,
+      21,    22,    70,    70,     0,    76,    76,    75,    75,     4,
+      78,    78,     6,     7,    76,    83,    63,    64,    65,    66,
+      67,    68,    90,    70,    75,    78,    71,    77,    76,    74,
+      79,     4,     4,     4,    80,     3,    81,     3,    82,     4,
+       4,     4,   110,     4,     4,     4,     4,     4,     4,   117,
+      71,    79,    83,    74,     4,     4,     4,     4,     4,    81,
+      81,     4,     0,     1,   132,     4,   123,     5,     4,   162,
+       8,     9,    10,    11,    12,    13,    14,    58,    16,    17,
+      18,    19,    20,    21,    22,    34,    35,    36,    37,    38,
+      39,    40,    57,    58,    59,    60,    61,    62,    -1,    13,
+      49,    50,    51,    52,    53,    37,   147,     4,    -1,    64,
+      -1,    -1,    -1,    -1,     4,    -1,    -1,    -1,    -1,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,    77,    -1,
+      -1,    -1,    -1,    71,    -1,    -1,    74,    34,    35,    36,
+      37,    38,    39,    40,    34,    35,    36,    37,    38,    39,
+      40,    66,    67,    68,    -1,    -1,    -1,    54,    55,    56,
+      -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      77,    -1,    -1,    -1,    -1,    -1,    -1,    77,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    15,    85,    86,    87,     4,    77,    97,     0,     1,
+       5,     8,     9,    10,    11,    12,    13,    14,    16,    17,
+      18,    19,    20,    21,    22,    71,    74,    88,    89,    91,
+      86,     4,    98,    76,    76,     1,    23,    24,    25,    26,
+      27,    28,    29,    30,    31,    32,    33,   100,   101,     4,
+      75,   109,   109,    96,    97,    97,    97,    93,    94,    72,
+      73,    92,    88,    76,    79,    78,    82,   110,   110,    97,
+     103,   100,    41,    42,   108,   104,    80,    99,   102,     4,
+       4,     4,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    70,    95,    35,    36,    37,    38,
+      39,    40,    95,   106,   107,     4,    98,   100,   111,    34,
+      97,   106,   107,     3,    34,    54,    55,    56,    97,   106,
+     107,    81,    88,     6,     7,    90,    34,    49,    50,    51,
+      52,    53,    97,   105,   106,   107,     3,    97,     4,     4,
+       4,     4,     4,    97,     4,     4,     4,    79,    83,     4,
+      97,     4,     4,    97,     4,    81,   100,    99,     4,    97,
+       4,   111,    99,    90
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 194 "sieve.y"
+    { ret = NULL; }
+    break;
+
+  case 3:
+#line 195 "sieve.y"
+    { ret = (yyvsp[(2) - (2)].cl); }
+    break;
+
+  case 6:
+#line 202 "sieve.y"
+    { if (!check_reqs((yyvsp[(2) - (3)].sl))) {
+                                    yyerror("Unsupported features in require line");
+				    YYERROR; 
+                                  } }
+    break;
+
+  case 7:
+#line 208 "sieve.y"
+    { (yyval.cl) = (yyvsp[(1) - (1)].cl); }
+    break;
+
+  case 8:
+#line 209 "sieve.y"
+    { (yyvsp[(1) - (2)].cl)->next = (yyvsp[(2) - (2)].cl); (yyval.cl) = (yyvsp[(1) - (2)].cl); }
+    break;
+
+  case 9:
+#line 212 "sieve.y"
+    { (yyval.cl) = (yyvsp[(1) - (2)].cl); }
+    break;
+
+  case 10:
+#line 213 "sieve.y"
+    { (yyval.cl) = new_if((yyvsp[(2) - (4)].test), (yyvsp[(3) - (4)].cl), (yyvsp[(4) - (4)].cl)); }
+    break;
+
+  case 11:
+#line 214 "sieve.y"
+    { (yyval.cl) = new_command(STOP); }
+    break;
+
+  case 12:
+#line 217 "sieve.y"
+    { (yyval.cl) = NULL; }
+    break;
+
+  case 13:
+#line 218 "sieve.y"
+    { (yyval.cl) = new_if((yyvsp[(2) - (4)].test), (yyvsp[(3) - (4)].cl), (yyvsp[(4) - (4)].cl)); }
+    break;
+
+  case 14:
+#line 219 "sieve.y"
+    { (yyval.cl) = (yyvsp[(2) - (2)].cl); }
+    break;
+
+  case 15:
+#line 222 "sieve.y"
+    { if (!parse_script->support.reject) {
+				     yyerror("reject require missing");
+				     YYERROR;
+				   }
+				   if (!verify_utf8((yyvsp[(2) - (2)].sval))) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+				   (yyval.cl) = new_command(REJCT);
+				   (yyval.cl)->u.str = (yyvsp[(2) - (2)].sval); }
+    break;
+
+  case 16:
+#line 231 "sieve.y"
+    { if (!parse_script->support.fileinto) {
+				     yyerror("fileinto require missing");
+	                             YYERROR;
+                                   }
+				   if (!verify_mailbox((yyvsp[(3) - (3)].sval))) {
+				     YYERROR; /* vm should call yyerror() */
+				   }
+	                           (yyval.cl) = build_fileinto(FILEINTO, (yyvsp[(2) - (3)].nval), (yyvsp[(3) - (3)].sval)); }
+    break;
+
+  case 17:
+#line 239 "sieve.y"
+    { if (!verify_address((yyvsp[(3) - (3)].sval))) {
+				     YYERROR; /* va should call yyerror() */
+				   }
+	                           (yyval.cl) = build_redirect(REDIRECT, (yyvsp[(2) - (3)].nval), (yyvsp[(3) - (3)].sval)); }
+    break;
+
+  case 18:
+#line 243 "sieve.y"
+    { (yyval.cl) = new_command(KEEP); }
+    break;
+
+  case 19:
+#line 244 "sieve.y"
+    { (yyval.cl) = new_command(STOP); }
+    break;
+
+  case 20:
+#line 245 "sieve.y"
+    { (yyval.cl) = new_command(DISCARD); }
+    break;
+
+  case 21:
+#line 246 "sieve.y"
+    { if (!parse_script->support.vacation) {
+				     yyerror("vacation require missing");
+				     YYERROR;
+				   }
+				   if (((yyvsp[(2) - (3)].vtag)->mime == -1) && !verify_utf8((yyvsp[(3) - (3)].sval))) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+  				   (yyval.cl) = build_vacation(VACATION,
+					    canon_vtags((yyvsp[(2) - (3)].vtag)), (yyvsp[(3) - (3)].sval)); }
+    break;
+
+  case 22:
+#line 255 "sieve.y"
+    { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                   }
+                                  if (!verify_stringlist((yyvsp[(2) - (2)].sl), verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  (yyval.cl) = new_command(SETFLAG);
+                                  (yyval.cl)->u.sl = (yyvsp[(2) - (2)].sl); }
+    break;
+
+  case 23:
+#line 264 "sieve.y"
+    { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist((yyvsp[(2) - (2)].sl), verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  (yyval.cl) = new_command(ADDFLAG);
+                                  (yyval.cl)->u.sl = (yyvsp[(2) - (2)].sl); }
+    break;
+
+  case 24:
+#line 273 "sieve.y"
+    { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist((yyvsp[(2) - (2)].sl), verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  (yyval.cl) = new_command(REMOVEFLAG);
+                                  (yyval.cl)->u.sl = (yyvsp[(2) - (2)].sl); }
+    break;
+
+  case 25:
+#line 282 "sieve.y"
+    { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  (yyval.cl) = new_command(MARK); }
+    break;
+
+  case 26:
+#line 287 "sieve.y"
+    { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  (yyval.cl) = new_command(UNMARK); }
+    break;
+
+  case 27:
+#line 293 "sieve.y"
+    { if (!parse_script->support.notify) {
+				       yyerror("notify require missing");
+				       (yyval.cl) = new_command(NOTIFY); 
+				       YYERROR;
+	 			    } else {
+				      (yyval.cl) = build_notify(NOTIFY,
+				             canon_ntags((yyvsp[(2) - (2)].ntag)));
+				    } }
+    break;
+
+  case 28:
+#line 301 "sieve.y"
+    { if (!parse_script->support.notify) {
+                                       yyerror("notify require missing");
+				       (yyval.cl) = new_command(DENOTIFY);
+				       YYERROR;
+				    } else {
+					(yyval.cl) = build_denotify(DENOTIFY, canon_dtags((yyvsp[(2) - (2)].dtag)));
+					if ((yyval.cl) == NULL) { 
+			yyerror("unable to find a compatible comparator");
+			YYERROR; } } }
+    break;
+
+  case 29:
+#line 311 "sieve.y"
+    { if (!parse_script->support.include) {
+				     yyerror("include require missing");
+	                             YYERROR;
+                                   }
+	                           (yyval.cl) = new_command(INCLUDE);
+				   (yyval.cl)->u.inc.location = (yyvsp[(2) - (3)].nval);
+				   (yyval.cl)->u.inc.script = (yyvsp[(3) - (3)].sval); }
+    break;
+
+  case 30:
+#line 318 "sieve.y"
+    { if (!parse_script->support.include) {
+                                    yyerror("include require missing");
+                                    YYERROR;
+                                  }
+                                   (yyval.cl) = new_command(RETURN); }
+    break;
+
+  case 31:
+#line 325 "sieve.y"
+    { (yyval.nval) = PERSONAL; }
+    break;
+
+  case 32:
+#line 326 "sieve.y"
+    { (yyval.nval) = PERSONAL; }
+    break;
+
+  case 33:
+#line 327 "sieve.y"
+    { (yyval.nval) = GLOBAL; }
+    break;
+
+  case 34:
+#line 330 "sieve.y"
+    { (yyval.ntag) = new_ntags(); }
+    break;
+
+  case 35:
+#line 331 "sieve.y"
+    { if ((yyval.ntag)->id != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { (yyval.ntag)->id = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 36:
+#line 334 "sieve.y"
+    { if ((yyval.ntag)->method != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { (yyval.ntag)->method = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 37:
+#line 337 "sieve.y"
+    { if ((yyval.ntag)->options != NULL) { 
+					yyerror("duplicate :options"); YYERROR; }
+				     else { (yyval.ntag)->options = (yyvsp[(3) - (3)].sl); } }
+    break;
+
+  case 38:
+#line 340 "sieve.y"
+    { if ((yyval.ntag)->priority != -1) { 
+                                 yyerror("duplicate :priority"); YYERROR; }
+                                   else { (yyval.ntag)->priority = (yyvsp[(2) - (2)].nval); } }
+    break;
+
+  case 39:
+#line 343 "sieve.y"
+    { if ((yyval.ntag)->message != NULL) { 
+					yyerror("duplicate :message"); YYERROR; }
+				   else { (yyval.ntag)->message = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 40:
+#line 348 "sieve.y"
+    { (yyval.dtag) = new_dtags(); }
+    break;
+
+  case 41:
+#line 349 "sieve.y"
+    { if ((yyval.dtag)->priority != -1) { 
+				yyerror("duplicate priority level"); YYERROR; }
+				   else { (yyval.dtag)->priority = (yyvsp[(2) - (2)].nval); } }
+    break;
+
+  case 42:
+#line 352 "sieve.y"
+    { if ((yyval.dtag)->comptag != -1)
+	                             { 
+					 yyerror("duplicate comparator type tag"); YYERROR;
+				     }
+	                           (yyval.dtag)->comptag = (yyvsp[(2) - (3)].nval);
+#ifdef ENABLE_REGEX
+				   if ((yyval.dtag)->comptag == REGEX)
+				   {
+				       int cflags = REG_EXTENDED |
+					   REG_NOSUB | REG_ICASE;
+				       if (!verify_regex((yyvsp[(3) - (3)].sval), cflags)) { YYERROR; }
+				   }
+#endif
+				   (yyval.dtag)->pattern = (yyvsp[(3) - (3)].sval);
+	                          }
+    break;
+
+  case 43:
+#line 367 "sieve.y"
+    { (yyval.dtag) = (yyvsp[(1) - (3)].dtag);
+				   if ((yyval.dtag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.dtag)->comptag = (yyvsp[(2) - (3)].nval);
+				   (yyval.dtag)->relation = verify_relat((yyvsp[(3) - (3)].sval));
+				   if ((yyval.dtag)->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+    break;
+
+  case 44:
+#line 377 "sieve.y"
+    { (yyval.nval) = LOW; }
+    break;
+
+  case 45:
+#line 378 "sieve.y"
+    { (yyval.nval) = NORMAL; }
+    break;
+
+  case 46:
+#line 379 "sieve.y"
+    { (yyval.nval) = HIGH; }
+    break;
+
+  case 47:
+#line 382 "sieve.y"
+    { (yyval.vtag) = new_vtags(); }
+    break;
+
+  case 48:
+#line 383 "sieve.y"
+    { if ((yyval.vtag)->days != -1) { 
+					yyerror("duplicate :days"); YYERROR; }
+				   else { (yyval.vtag)->days = (yyvsp[(3) - (3)].nval); } }
+    break;
+
+  case 49:
+#line 386 "sieve.y"
+    { if ((yyval.vtag)->addresses != NULL) { 
+					yyerror("duplicate :addresses"); 
+					YYERROR;
+				       } else if (!verify_stringlist((yyvsp[(3) - (3)].sl),
+							verify_address)) {
+					  YYERROR;
+				       } else {
+					 (yyval.vtag)->addresses = (yyvsp[(3) - (3)].sl); } }
+    break;
+
+  case 50:
+#line 394 "sieve.y"
+    { if ((yyval.vtag)->subject != NULL) { 
+					yyerror("duplicate :subject"); 
+					YYERROR;
+				   } else if (!verify_utf8((yyvsp[(3) - (3)].sval))) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { (yyval.vtag)->subject = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 51:
+#line 400 "sieve.y"
+    { if ((yyval.vtag)->from != NULL) { 
+					yyerror("duplicate :from"); 
+					YYERROR;
+				   } else if (!verify_address((yyvsp[(3) - (3)].sval))) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { (yyval.vtag)->from = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 52:
+#line 406 "sieve.y"
+    { if ((yyval.vtag)->handle != NULL) { 
+					yyerror("duplicate :handle"); 
+					YYERROR;
+				   } else if (!verify_utf8((yyvsp[(3) - (3)].sval))) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { (yyval.vtag)->handle = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 53:
+#line 412 "sieve.y"
+    { if ((yyval.vtag)->mime != -1) { 
+					yyerror("duplicate :mime"); 
+					YYERROR; }
+				   else { (yyval.vtag)->mime = MIME; } }
+    break;
+
+  case 54:
+#line 418 "sieve.y"
+    { (yyval.sl) = (yyvsp[(2) - (3)].sl); }
+    break;
+
+  case 55:
+#line 419 "sieve.y"
+    { (yyval.sl) = new_sl((yyvsp[(1) - (1)].sval), NULL); }
+    break;
+
+  case 56:
+#line 422 "sieve.y"
+    { (yyval.sl) = new_sl((yyvsp[(1) - (1)].sval), NULL); }
+    break;
+
+  case 57:
+#line 423 "sieve.y"
+    { (yyval.sl) = new_sl((yyvsp[(1) - (3)].sval), (yyvsp[(3) - (3)].sl)); }
+    break;
+
+  case 58:
+#line 426 "sieve.y"
+    { (yyval.cl) = (yyvsp[(2) - (3)].cl); }
+    break;
+
+  case 59:
+#line 427 "sieve.y"
+    { (yyval.cl) = NULL; }
+    break;
+
+  case 60:
+#line 430 "sieve.y"
+    { (yyval.test) = new_test(ANYOF); (yyval.test)->u.tl = (yyvsp[(2) - (2)].testl); }
+    break;
+
+  case 61:
+#line 431 "sieve.y"
+    { (yyval.test) = new_test(ALLOF); (yyval.test)->u.tl = (yyvsp[(2) - (2)].testl); }
+    break;
+
+  case 62:
+#line 432 "sieve.y"
+    { (yyval.test) = new_test(EXISTS); (yyval.test)->u.sl = (yyvsp[(2) - (2)].sl); }
+    break;
+
+  case 63:
+#line 433 "sieve.y"
+    { (yyval.test) = new_test(SFALSE); }
+    break;
+
+  case 64:
+#line 434 "sieve.y"
+    { (yyval.test) = new_test(STRUE); }
+    break;
+
+  case 65:
+#line 436 "sieve.y"
+    {
+				     if (!verify_stringlist((yyvsp[(3) - (4)].sl), verify_header)) {
+					 YYERROR; /* vh should call yyerror() */
+				     }
+				     if (!verify_stringlist((yyvsp[(4) - (4)].sl), verify_utf8)) {
+					 YYERROR; /* vu should call yyerror() */
+				     }
+				     
+				     (yyvsp[(2) - (4)].htag) = canon_htags((yyvsp[(2) - (4)].htag));
+#ifdef ENABLE_REGEX
+				     if ((yyvsp[(2) - (4)].htag)->comptag == REGEX)
+				     {
+					 if (!(verify_regexs((yyvsp[(4) - (4)].sl), (yyvsp[(2) - (4)].htag)->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     (yyval.test) = build_header(HEADER, (yyvsp[(2) - (4)].htag), (yyvsp[(3) - (4)].sl), (yyvsp[(4) - (4)].sl));
+				     if ((yyval.test) == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+    break;
+
+  case 66:
+#line 460 "sieve.y"
+    { 
+				     if (((yyvsp[(1) - (4)].nval) == ADDRESS) &&
+					 !verify_stringlist((yyvsp[(3) - (4)].sl), verify_addrheader))
+					 { YYERROR; }
+				     else if (((yyvsp[(1) - (4)].nval) == ENVELOPE) &&
+					      !verify_stringlist((yyvsp[(3) - (4)].sl), verify_envelope))
+					 { YYERROR; }
+				     (yyvsp[(2) - (4)].aetag) = canon_aetags((yyvsp[(2) - (4)].aetag));
+#ifdef ENABLE_REGEX
+				     if ((yyvsp[(2) - (4)].aetag)->comptag == REGEX)
+				     {
+					 if (!( verify_regexs((yyvsp[(4) - (4)].sl), (yyvsp[(2) - (4)].aetag)->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     (yyval.test) = build_address((yyvsp[(1) - (4)].nval), (yyvsp[(2) - (4)].aetag), (yyvsp[(3) - (4)].sl), (yyvsp[(4) - (4)].sl));
+				     if ((yyval.test) == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+    break;
+
+  case 67:
+#line 482 "sieve.y"
+    {
+				     if (!parse_script->support.body) {
+                                       yyerror("body require missing");
+				       YYERROR;
+				     }
+					
+				     if (!verify_stringlist((yyvsp[(3) - (3)].sl), verify_utf8)) {
+					 YYERROR; /* vu should call yyerror() */
+				     }
+				     
+				     (yyvsp[(2) - (3)].btag) = canon_btags((yyvsp[(2) - (3)].btag));
+#ifdef ENABLE_REGEX
+				     if ((yyvsp[(2) - (3)].btag)->comptag == REGEX)
+				     {
+					 if (!(verify_regexs((yyvsp[(3) - (3)].sl), (yyvsp[(2) - (3)].btag)->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     (yyval.test) = build_body(BODY, (yyvsp[(2) - (3)].btag), (yyvsp[(3) - (3)].sl));
+				     if ((yyval.test) == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+    break;
+
+  case 68:
+#line 507 "sieve.y"
+    { (yyval.test) = new_test(NOT); (yyval.test)->u.t = (yyvsp[(2) - (2)].test); }
+    break;
+
+  case 69:
+#line 508 "sieve.y"
+    { (yyval.test) = new_test(SIZE); (yyval.test)->u.sz.t = (yyvsp[(2) - (3)].nval);
+		                   (yyval.test)->u.sz.n = (yyvsp[(3) - (3)].nval); }
+    break;
+
+  case 70:
+#line 510 "sieve.y"
+    { (yyval.test) = NULL; }
+    break;
+
+  case 71:
+#line 513 "sieve.y"
+    { (yyval.nval) = ADDRESS; }
+    break;
+
+  case 72:
+#line 514 "sieve.y"
+    {if (!parse_script->support.envelope)
+	                              {yyerror("envelope require missing"); YYERROR;}
+	                          else{(yyval.nval) = ENVELOPE; }
+	                         }
+    break;
+
+  case 73:
+#line 521 "sieve.y"
+    { (yyval.aetag) = new_aetags(); }
+    break;
+
+  case 74:
+#line 522 "sieve.y"
+    { (yyval.aetag) = (yyvsp[(1) - (2)].aetag);
+				   if ((yyval.aetag)->addrtag != -1) { 
+			yyerror("duplicate or conflicting address part tag");
+			YYERROR; }
+				   else { (yyval.aetag)->addrtag = (yyvsp[(2) - (2)].nval); } }
+    break;
+
+  case 75:
+#line 527 "sieve.y"
+    { (yyval.aetag) = (yyvsp[(1) - (2)].aetag);
+				   if ((yyval.aetag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.aetag)->comptag = (yyvsp[(2) - (2)].nval); } }
+    break;
+
+  case 76:
+#line 531 "sieve.y"
+    { (yyval.aetag) = (yyvsp[(1) - (3)].aetag);
+				   if ((yyval.aetag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.aetag)->comptag = (yyvsp[(2) - (3)].nval);
+				   (yyval.aetag)->relation = verify_relat((yyvsp[(3) - (3)].sval));
+				   if ((yyval.aetag)->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+    break;
+
+  case 77:
+#line 539 "sieve.y"
+    { (yyval.aetag) = (yyvsp[(1) - (3)].aetag);
+	if ((yyval.aetag)->comparator != NULL) { 
+			yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp((yyvsp[(3) - (3)].sval), "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) {
+			yyerror("comparator-i;ascii-numeric require missing");
+			YYERROR; }
+				   else { (yyval.aetag)->comparator = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 78:
+#line 549 "sieve.y"
+    { (yyval.htag) = new_htags(); }
+    break;
+
+  case 79:
+#line 550 "sieve.y"
+    { (yyval.htag) = (yyvsp[(1) - (2)].htag);
+				   if ((yyval.htag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.htag)->comptag = (yyvsp[(2) - (2)].nval); } }
+    break;
+
+  case 80:
+#line 554 "sieve.y"
+    { (yyval.htag) = (yyvsp[(1) - (3)].htag);
+				   if ((yyval.htag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.htag)->comptag = (yyvsp[(2) - (3)].nval);
+				   (yyval.htag)->relation = verify_relat((yyvsp[(3) - (3)].sval));
+				   if ((yyval.htag)->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+    break;
+
+  case 81:
+#line 562 "sieve.y"
+    { (yyval.htag) = (yyvsp[(1) - (3)].htag);
+				   if ((yyval.htag)->comparator != NULL) { 
+			 yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp((yyvsp[(3) - (3)].sval), "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) { 
+			 yyerror("comparator-i;ascii-numeric require missing");  YYERROR; }
+				   else { 
+				     (yyval.htag)->comparator = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 82:
+#line 572 "sieve.y"
+    { (yyval.btag) = new_btags(); }
+    break;
+
+  case 83:
+#line 573 "sieve.y"
+    { (yyval.btag) = (yyvsp[(1) - (2)].btag);
+				   if ((yyval.btag)->transform != -1) {
+			yyerror("duplicate or conflicting transform tag");
+			YYERROR; }
+				   else { (yyval.btag)->transform = RAW; } }
+    break;
+
+  case 84:
+#line 578 "sieve.y"
+    { (yyval.btag) = (yyvsp[(1) - (2)].btag);
+				   if ((yyval.btag)->transform != -1) {
+			yyerror("duplicate or conflicting transform tag");
+			YYERROR; }
+				   else { (yyval.btag)->transform = TEXT; } }
+    break;
+
+  case 85:
+#line 583 "sieve.y"
+    { (yyval.btag) = (yyvsp[(1) - (3)].btag);
+				   if ((yyval.btag)->transform != -1) {
+			yyerror("duplicate or conflicting transform tag");
+			YYERROR; }
+				   else {
+				       (yyval.btag)->transform = CONTENT;
+				       (yyval.btag)->content_types = (yyvsp[(3) - (3)].sl);
+				   } }
+    break;
+
+  case 86:
+#line 591 "sieve.y"
+    { (yyval.btag) = (yyvsp[(1) - (2)].btag);
+				   if ((yyval.btag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.btag)->comptag = (yyvsp[(2) - (2)].nval); } }
+    break;
+
+  case 87:
+#line 595 "sieve.y"
+    { (yyval.btag) = (yyvsp[(1) - (3)].btag);
+				   if ((yyval.btag)->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { (yyval.btag)->comptag = (yyvsp[(2) - (3)].nval);
+				   (yyval.btag)->relation = verify_relat((yyvsp[(3) - (3)].sval));
+				   if ((yyval.btag)->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+    break;
+
+  case 88:
+#line 603 "sieve.y"
+    { (yyval.btag) = (yyvsp[(1) - (3)].btag);
+				   if ((yyval.btag)->comparator != NULL) { 
+			 yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp((yyvsp[(3) - (3)].sval), "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) { 
+			 yyerror("comparator-i;ascii-numeric require missing");  YYERROR; }
+				   else { 
+				     (yyval.btag)->comparator = (yyvsp[(3) - (3)].sval); } }
+    break;
+
+  case 89:
+#line 614 "sieve.y"
+    { (yyval.nval) = ALL; }
+    break;
+
+  case 90:
+#line 615 "sieve.y"
+    { (yyval.nval) = LOCALPART; }
+    break;
+
+  case 91:
+#line 616 "sieve.y"
+    { (yyval.nval) = DOMAIN; }
+    break;
+
+  case 92:
+#line 617 "sieve.y"
+    { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   (yyval.nval) = USER; }
+    break;
+
+  case 93:
+#line 622 "sieve.y"
+    { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   (yyval.nval) = DETAIL; }
+    break;
+
+  case 94:
+#line 628 "sieve.y"
+    { (yyval.nval) = IS; }
+    break;
+
+  case 95:
+#line 629 "sieve.y"
+    { (yyval.nval) = CONTAINS; }
+    break;
+
+  case 96:
+#line 630 "sieve.y"
+    { (yyval.nval) = MATCHES; }
+    break;
+
+  case 97:
+#line 631 "sieve.y"
+    { if (!parse_script->support.regex) {
+				     yyerror("regex require missing");
+				     YYERROR;
+				   }
+				   (yyval.nval) = REGEX; }
+    break;
+
+  case 98:
+#line 638 "sieve.y"
+    { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   (yyval.nval) = COUNT; }
+    break;
+
+  case 99:
+#line 643 "sieve.y"
+    { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   (yyval.nval) = VALUE; }
+    break;
+
+  case 100:
+#line 651 "sieve.y"
+    { (yyval.nval) = OVER; }
+    break;
+
+  case 101:
+#line 652 "sieve.y"
+    { (yyval.nval) = UNDER; }
+    break;
+
+  case 102:
+#line 655 "sieve.y"
+    { (yyval.nval) = 0; }
+    break;
+
+  case 103:
+#line 656 "sieve.y"
+    { if (!parse_script->support.copy) {
+				     yyerror("copy require missing");
+	                             YYERROR;
+                                   }
+				   (yyval.nval) = COPY; }
+    break;
+
+  case 104:
+#line 663 "sieve.y"
+    { (yyval.testl) = (yyvsp[(2) - (3)].testl); }
+    break;
+
+  case 105:
+#line 666 "sieve.y"
+    { (yyval.testl) = new_testlist((yyvsp[(1) - (1)].test), NULL); }
+    break;
+
+  case 106:
+#line 667 "sieve.y"
+    { (yyval.testl) = new_testlist((yyvsp[(1) - (3)].test), (yyvsp[(3) - (3)].testl)); }
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 2628 "sieve.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 670 "sieve.y"
+
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f)
+{
+    commandlist_t *t;
+
+    parse_script = script;
+    yyrestart(f);
+    if (yyparse()) {
+	t = NULL;
+    } else {
+	t = ret;
+    }
+    ret = NULL;
+    return t;
+}
+
+int yyerror(char *msg)
+{
+    extern int yylineno;
+    int ret;
+
+    parse_script->err++;
+    if (parse_script->interp.err) {
+	ret = parse_script->interp.err(yylineno, msg, 
+				       parse_script->interp.interp_context,
+				       parse_script->script_context);
+    }
+
+    return 0;
+}
+
+static int check_reqs(stringlist_t *sl)
+{
+    int i = 1;
+    stringlist_t *s;
+    
+    while (sl != NULL) {
+	s = sl;
+	sl = sl->next;
+
+	i &= script_require(parse_script, s->s);
+
+	if (s->s) free(s->s);
+	free(s);
+    }
+    return i;
+}
+
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be either ADDRESS or ENVELOPE */
+
+    assert((t == ADDRESS) || (t == ENVELOPE));
+
+    if (ret) {
+	ret->u.ae.comptag = ae->comptag;
+	ret->u.ae.relation=ae->relation;
+	ret->u.ae.comparator=xstrdup(ae->comparator);
+	ret->u.ae.sl = sl;
+	ret->u.ae.pl = pl;
+	ret->u.ae.addrpart = ae->addrtag;
+	free_aetags(ae);
+
+    }
+    return ret;
+}
+
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be HEADER */
+
+    assert(t == HEADER);
+
+    if (ret) {
+	ret->u.h.comptag = h->comptag;
+	ret->u.h.relation=h->relation;
+	ret->u.h.comparator=xstrdup(h->comparator);
+	ret->u.h.sl = sl;
+	ret->u.h.pl = pl;
+	free_htags(h);
+    }
+    return ret;
+}
+
+static test_t *build_body(int t, struct btags *b, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be BODY */
+
+    assert(t == BODY);
+
+    if (ret) {
+	ret->u.b.comptag = b->comptag;
+	ret->u.b.relation = b->relation;
+	ret->u.b.comparator = xstrdup(b->comparator);
+	ret->u.b.transform = b->transform;
+	ret->u.b.offset = b->offset;
+	ret->u.b.content_types = b->content_types; b->content_types = NULL;
+	ret->u.b.pl = pl;
+	free_btags(b);
+    }
+    return ret;
+}
+
+static commandlist_t *build_vacation(int t, struct vtags *v, char *reason)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == VACATION);
+
+    if (ret) {
+	ret->u.v.subject = v->subject; v->subject = NULL;
+	ret->u.v.from = v->from; v->from = NULL;
+	ret->u.v.handle = v->handle; v->handle = NULL;
+	ret->u.v.days = v->days;
+	ret->u.v.mime = v->mime;
+	ret->u.v.addresses = v->addresses; v->addresses = NULL;
+	free_vtags(v);
+	ret->u.v.message = reason;
+    }
+    return ret;
+}
+
+static commandlist_t *build_notify(int t, struct ntags *n)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == NOTIFY);
+       if (ret) {
+	ret->u.n.method = n->method; n->method = NULL;
+	ret->u.n.id = n->id; n->id = NULL;
+	ret->u.n.options = n->options; n->options = NULL;
+	ret->u.n.priority = n->priority;
+	ret->u.n.message = n->message; n->message = NULL;
+	free_ntags(n);
+    }
+    return ret;
+}
+
+static commandlist_t *build_denotify(int t, struct dtags *d)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == DENOTIFY);
+
+    if (ret) {
+	ret->u.d.comptag = d->comptag;
+	ret->u.d.relation=d->relation;
+	ret->u.d.pattern = d->pattern; d->pattern = NULL;
+	ret->u.d.priority = d->priority;
+	free_dtags(d);
+    }
+    return ret;
+}
+
+static commandlist_t *build_fileinto(int t, int copy, char *folder)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == FILEINTO);
+
+    if (ret) {
+	ret->u.f.copy = copy;
+	ret->u.f.folder = folder;
+    }
+    return ret;
+}
+
+static commandlist_t *build_redirect(int t, int copy, char *address)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == REDIRECT);
+
+    if (ret) {
+	ret->u.r.copy = copy;
+	ret->u.r.address = address;
+    }
+    return ret;
+}
+
+static struct aetags *new_aetags(void)
+{
+    struct aetags *r = (struct aetags *) xmalloc(sizeof(struct aetags));
+
+    r->addrtag = r->comptag = r->relation=-1;
+    r->comparator=NULL;
+
+    return r;
+}
+
+static struct aetags *canon_aetags(struct aetags *ae)
+{
+    if (ae->addrtag == -1) { ae->addrtag = ALL; }
+    if (ae->comparator == NULL) {
+        ae->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (ae->comptag == -1) { ae->comptag = IS; }
+    return ae;
+}
+
+static void free_aetags(struct aetags *ae)
+{
+    free(ae->comparator);
+     free(ae);
+}
+
+static struct htags *new_htags(void)
+{
+    struct htags *r = (struct htags *) xmalloc(sizeof(struct htags));
+
+    r->comptag = r->relation= -1;
+    
+    r->comparator = NULL;
+
+    return r;
+}
+
+static struct htags *canon_htags(struct htags *h)
+{
+    if (h->comparator == NULL) {
+	h->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (h->comptag == -1) { h->comptag = IS; }
+    return h;
+}
+
+static void free_htags(struct htags *h)
+{
+    free(h->comparator);
+    free(h);
+}
+
+static struct btags *new_btags(void)
+{
+    struct btags *r = (struct btags *) xmalloc(sizeof(struct btags));
+
+    r->transform = r->offset = r->comptag = r->relation = -1;
+    r->content_types = NULL;
+    r->comparator = NULL;
+
+    return r;
+}
+
+static struct btags *canon_btags(struct btags *b)
+{
+    if (b->transform == -1) { b->transform = TEXT; }
+    if (b->content_types == NULL) {
+	if (b->transform == RAW) {
+	    b->content_types = new_sl(xstrdup(""), NULL);
+	} else {
+	    b->content_types = new_sl(xstrdup("text"), NULL);
+	}
+    }
+    if (b->offset == -1) { b->offset = 0; }
+    if (b->comparator == NULL) { b->comparator = xstrdup("i;ascii-casemap"); }
+    if (b->comptag == -1) { b->comptag = IS; }
+    return b;
+}
+
+static void free_btags(struct btags *b)
+{
+    if (b->content_types) { free_sl(b->content_types); }
+    free(b->comparator);
+    free(b);
+}
+
+static struct vtags *new_vtags(void)
+{
+    struct vtags *r = (struct vtags *) xmalloc(sizeof(struct vtags));
+
+    r->days = -1;
+    r->addresses = NULL;
+    r->subject = NULL;
+    r->from = NULL;
+    r->handle = NULL;
+    r->mime = -1;
+
+    return r;
+}
+
+static struct vtags *canon_vtags(struct vtags *v)
+{
+    assert(parse_script->interp.vacation != NULL);
+
+    if (v->days == -1) { v->days = 7; }
+    if (v->days < parse_script->interp.vacation->min_response) 
+       { v->days = parse_script->interp.vacation->min_response; }
+    if (v->days > parse_script->interp.vacation->max_response)
+       { v->days = parse_script->interp.vacation->max_response; }
+    if (v->mime == -1) { v->mime = 0; }
+
+    return v;
+}
+
+static void free_vtags(struct vtags *v)
+{
+    if (v->addresses) { free_sl(v->addresses); }
+    if (v->subject) { free(v->subject); }
+    if (v->from) { free(v->from); }
+    if (v->handle) { free(v->handle); }
+    free(v);
+}
+
+static struct ntags *new_ntags(void)
+{
+    struct ntags *r = (struct ntags *) xmalloc(sizeof(struct ntags));
+
+    r->method = NULL;
+    r->id = NULL;
+    r->options = NULL;
+    r->priority = -1;
+    r->message = NULL;
+
+    return r;
+}
+
+static struct ntags *canon_ntags(struct ntags *n)
+{
+    if (n->priority == -1) { n->priority = NORMAL; }
+    if (n->message == NULL) { n->message = xstrdup("$from$: $subject$"); }
+    if (n->method == NULL) { n->method = xstrdup("default"); }
+    return n;
+}
+static struct dtags *canon_dtags(struct dtags *d)
+{
+    if (d->priority == -1) { d->priority = ANY; }
+    if (d->comptag == -1) { d->comptag = ANY; }
+       return d;
+}
+
+static void free_ntags(struct ntags *n)
+{
+    if (n->method) { free(n->method); }
+    if (n->id) { free(n->id); }
+    if (n->options) { free_sl(n->options); }
+    if (n->message) { free(n->message); }
+    free(n);
+}
+
+static struct dtags *new_dtags(void)
+{
+    struct dtags *r = (struct dtags *) xmalloc(sizeof(struct dtags));
+
+    r->comptag = r->priority= r->relation = -1;
+    r->pattern  = NULL;
+
+    return r;
+}
+
+static void free_dtags(struct dtags *d)
+{
+    if (d->pattern) free(d->pattern);
+    free(d);
+}
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *))
+{
+    for (; sl != NULL && verify(sl->s); sl = sl->next) ;
+    return (sl == NULL);
+}
+
+char *addrptr;		/* pointer to address string for address lexer */
+char addrerr[500];	/* buffer for address parser error messages */
+
+static int verify_address(char *s)
+{
+    char errbuf[500];
+
+    addrptr = s;
+    addrerr[0] = '\0';	/* paranoia */
+    if (addrparse()) {
+	snprintf(errbuf, sizeof(errbuf), "address '%s': %s", s, addrerr);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+
+static int verify_mailbox(char *s)
+{
+    if (!verify_utf8(s)) return 0;
+
+    /* xxx if not a mailbox, call yyerror */
+    return 1;
+}
+
+static int verify_header(char *hdr)
+{
+    char *h = hdr;
+    char errbuf[100];
+
+    while (*h) {
+	/* field-name      =       1*ftext
+	   ftext           =       %d33-57 / %d59-126         
+	   ; Any character except
+	   ;  controls, SP, and
+	   ;  ":". */
+	if (!((*h >= 33 && *h <= 57) || (*h >= 59 && *h <= 126))) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "header '%s': not a valid header", hdr);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	h++;
+    }
+    return 1;
+}
+ 
+static int verify_addrheader(char *hdr)
+{
+    const char **h, *hdrs[] = {
+	"from", "sender", "reply-to",	/* RFC2822 originator fields */
+	"to", "cc", "bcc",		/* RFC2822 destination fields */
+	"resent-from", "resent-sender",	/* RFC2822 resent fields */
+	"resent-to", "resent-cc", "resent-bcc",
+	"return-path",			/* RFC2822 trace fields */
+	"disposition-notification-to",	/* RFC2298 MDN request fields */
+	"delivered-to",			/* non-standard (loop detection) */
+	"approved",			/* RFC1036 moderator/control fields */
+	NULL
+    };
+    char errbuf[100];
+
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT))
+	return verify_header(hdr);
+
+    for (lcase(hdr), h = hdrs; *h; h++) {
+	if (!strcmp(*h, hdr)) return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "header '%s': not a valid header for an address test", hdr);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_envelope(char *env)
+{
+    char errbuf[100];
+
+    lcase(env);
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT) ||
+	!strcmp(env, "from") || !strcmp(env, "to") || !strcmp(env, "auth")) {
+	return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "env-part '%s': not a valid part for an envelope test", env);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_relat(char *r)
+{/* this really should have been a token to begin with.*/
+    char errbuf[100];
+	lcase(r);
+	if (!strcmp(r, "gt")) {return GT;}
+	else if (!strcmp(r, "ge")) {return GE;}
+	else if (!strcmp(r, "lt")) {return LT;}
+	else if (!strcmp(r, "le")) {return LE;}
+	else if (!strcmp(r, "ne")) {return NE;}
+	else if (!strcmp(r, "eq")) {return EQ;}
+	else{
+	  sprintf(errbuf, "flag '%s': not a valid relational operation", r);
+	  yyerror(errbuf);
+	  return -1;
+	}
+	
+}
+
+
+
+
+static int verify_flag(char *f)
+{
+    char errbuf[100];
+ 
+    if (f[0] == '\\') {
+	lcase(f);
+	if (strcmp(f, "\\seen") && strcmp(f, "\\answered") &&
+	    strcmp(f, "\\flagged") && strcmp(f, "\\draft") &&
+	    strcmp(f, "\\deleted")) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "flag '%s': not a system flag", f);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	return 1;
+    }
+    if (!imparse_isatom(f)) {
+	snprintf(errbuf, sizeof(errbuf), "flag '%s': not a valid keyword", f);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+ 
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags)
+{
+    int ret;
+    char errbuf[100];
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+
+     if ((ret = regcomp(reg, s, cflags)) != 0) {
+	(void) regerror(ret, reg, errbuf, sizeof(errbuf));
+	yyerror(errbuf);
+	free(reg);
+	return 0;
+	}
+    free(reg);
+    return 1;
+}
+
+static int verify_regexs(stringlist_t *sl, char *comp)
+{
+    stringlist_t *sl2;
+    int cflags = REG_EXTENDED | REG_NOSUB;
+ 
+
+    if (!strcmp(comp, "i;ascii-casemap")) {
+	cflags |= REG_ICASE;
+    }
+
+    for (sl2 = sl; sl2 != NULL; sl2 = sl2->next) {
+	if ((verify_regex(sl2->s, cflags)) == 0) {
+	    break;
+	}
+    }
+    if (sl2 == NULL) {
+	return 1;
+    }
+    return 0;
+}
+#endif
+
+/*
+ * Valid UTF-8 check (from RFC 2640 Annex B.1)
+ *
+ * The following routine checks if a byte sequence is valid UTF-8. This
+ * is done by checking for the proper tagging of the first and following
+ * bytes to make sure they conform to the UTF-8 format. It then checks
+ * to assure that the data part of the UTF-8 sequence conforms to the
+ * proper range allowed by the encoding. Note: This routine will not
+ * detect characters that have not been assigned and therefore do not
+ * exist.
+ */
+static int verify_utf8(char *s)
+{
+    const char *buf = s;
+    const char *endbuf = s + strlen(s);
+    unsigned char byte2mask = 0x00, c;
+    int trailing = 0;  /* trailing (continuation) bytes to follow */
+
+    while (buf != endbuf) {
+	c = *buf++;
+	if (trailing) {
+	    if ((c & 0xC0) == 0x80) {		/* Does trailing byte
+						   follow UTF-8 format? */
+		if (byte2mask) {		/* Need to check 2nd byte
+						   for proper range? */
+		    if (c & byte2mask)		/* Are appropriate bits set? */
+			byte2mask = 0x00;
+		    else
+			break;
+		}
+		trailing--;
+	    }
+	    else
+		break;
+	}
+	else {
+	    if ((c & 0x80) == 0x00)		/* valid 1 byte UTF-8 */
+		continue;
+	    else if ((c & 0xE0) == 0xC0)	/* valid 2 byte UTF-8 */
+		if (c & 0x1E) {			/* Is UTF-8 byte
+						   in proper range? */
+		    trailing = 1;
+		}
+		else
+		    break;
+	    else if ((c & 0xF0) == 0xE0) {	/* valid 3 byte UTF-8 */
+		if (!(c & 0x0F)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x20;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 2;
+	    }
+	    else if ((c & 0xF8) == 0xF0) {	/* valid 4 byte UTF-8 */
+		if (!(c & 0x07)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x30;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 3;
+	    }
+	    else if ((c & 0xFC) == 0xF8) {	/* valid 5 byte UTF-8 */
+		if (!(c & 0x03)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x38;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 4;
+	    }
+	    else if ((c & 0xFE) == 0xFC) {	/* valid 6 byte UTF-8 */
+		if (!(c & 0x01)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x3C;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 5;
+	    }
+	    else
+		break;
+	}
+    }
+
+    if ((buf != endbuf) || trailing) {
+	char errbuf[100];
+
+	snprintf(errbuf, sizeof(errbuf),
+		 "string '%s': not valid utf8", s);
+	yyerror(errbuf);
+	return 0;
+    }
+
+    return 1;
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sievec.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sievec.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sievec.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sievec.c	2007-09-16 04:58:15.000000000 -0600
@@ -0,0 +1,288 @@
+/* sievec.c -- compile a sieve script to bytecode manually
+ * Rob Siemborski
+ * $Id$
+ */
+/*
+ * Copyright (c) 1999-2000 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sieve_interface.h"
+
+#include "libconfig.h"
+#include "xmalloc.h"
+
+#include "script.h"
+#include <string.h> 
+#include <stdlib.h>
+#include <sys/file.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+struct et_list *_et_list = NULL;
+
+int is_script_parsable(FILE *stream, char **errstr, sieve_script_t **ret);
+
+#define TIMSIEVE_FAIL -1
+#define TIMSIEVE_OK 0
+
+int main(int argc, char **argv) 
+{
+    FILE *instream;
+    char *err = NULL;
+    sieve_script_t *s;
+    bytecode_info_t *bc;
+    int c, fd, usage_error = 0;
+
+    while ((c = getopt(argc, argv, "C:")) != EOF)
+	switch (c) {
+	default:
+	    usage_error = 1;
+	    break;
+	}
+
+    if (usage_error || (argc - optind) < 2) {
+	printf("Syntax: %s <filename> <outputfile>\n",
+	       argv[0]);
+	exit(1);
+    }
+
+    instream = fopen(argv[optind++],"r");
+    if(instream == NULL) {
+	printf("Unable to open %s for reading\n", argv[1]);
+	exit(1);
+    }
+    
+    if(is_script_parsable(instream, &err, &s) == TIMSIEVE_FAIL) {
+	if(err) {
+	    printf("Unable to parse script: %s\n", err);
+	} else {
+	    printf("Unable to parse script.\n");
+	}
+	 
+	exit(1);
+    }
+    
+    /* Now, generate the bytecode */
+    if(sieve_generate_bytecode(&bc, s) == -1) {
+	printf("bytecode generate failed\n");
+	exit(1);
+    }
+
+    /* Now, open the new file */
+    fd = open(argv[optind], O_CREAT | O_TRUNC | O_WRONLY, 0644);
+    if(fd < 0) {
+	printf("couldn't open bytecode output file\n");
+	exit(1);
+    }  
+
+    /* Now, emit the bytecode */
+    if(sieve_emit_bytecode(fd, bc) == -1) {
+	printf("bytecode emit failed\n");
+	exit(1);
+    }
+
+    close(fd);
+    
+    sieve_free_bytecode(&bc);
+    sieve_script_free(&s);
+
+    return 0;
+}
+
+/* to make larry's stupid functions happy :) */ 
+static void foo(void)
+{
+    i_fatal("stub function called");
+}
+sieve_vacation_t vacation = {
+    0,				/* min response */
+    0,				/* max response */
+    (sieve_callback *) &foo,	/* autorespond() */
+    (sieve_callback *) &foo	/* send_response() */
+};
+
+static int sieve_notify(void *ac ATTR_UNUSED, 
+			void *interp_context ATTR_UNUSED, 
+			void *script_context ATTR_UNUSED,
+			void *message_context ATTR_UNUSED,
+			const char **errmsg ATTR_UNUSED)
+{
+    i_fatal("stub function called");
+    return SIEVE_FAIL;
+}
+
+static int mysieve_error(int lineno, const char *msg,
+			 void *i ATTR_UNUSED, void *s)
+{
+    char buf[1024];
+    char **errstr = (char **) s;
+
+    snprintf(buf, 80, "line %d: %s\r\n", lineno, msg);
+    *errstr = xrealloc(*errstr, strlen(*errstr) + strlen(buf) + 30);
+    i_info("%s", buf);
+    strcat(*errstr, buf);
+
+    return SIEVE_OK;
+}
+
+/* end the boilerplate */
+
+/* returns TRUE or FALSE */
+int is_script_parsable(FILE *stream, char **errstr, sieve_script_t **ret)
+{
+    sieve_interp_t *i;
+    sieve_script_t *s;
+    int res;
+  
+    res = sieve_interp_alloc(&i, NULL);
+    if (res != SIEVE_OK) {
+	i_error("sieve_interp_alloc() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_redirect(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_redirect() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_discard(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_discard() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_reject(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_reject() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_fileinto(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_fileinto() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_keep(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_keep() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_imapflags(i, NULL);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_imapflags() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_size(i, (sieve_get_size *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_size() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_header(i, (sieve_get_header *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_header() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_envelope(i, (sieve_get_envelope *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_envelope() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_body(i, (sieve_get_body *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_body() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_include(i, (sieve_get_include *) &foo);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_include() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_vacation(i, &vacation);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_vacation() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_notify(i, &sieve_notify);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_notify() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_parse_error(i, &mysieve_error);
+    if (res != SIEVE_OK) {
+	i_error("sieve_register_parse_error() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    rewind(stream);
+
+    *errstr = (char *) xmalloc(20 * sizeof(char));
+    strcpy(*errstr, "script errors:\r\n");
+
+    res = sieve_script_parse(i, stream, errstr, &s);
+
+    if (res == SIEVE_OK) {
+	if(ret) {
+	    *ret = s;
+	} else {
+	    sieve_script_free(&s);
+	}
+	free(*errstr);
+	*errstr = NULL;
+    }
+
+    /* free interpreter */
+    sieve_interp_free(&i);
+
+    return (res == SIEVE_OK) ? TIMSIEVE_OK : TIMSIEVE_FAIL;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieved.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieved.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieved.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieved.c	2007-07-19 19:52:08.000000000 -0600
@@ -0,0 +1,487 @@
+/* dump.c -- bytecode decompiler
+ * Jen Smith
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+
+
+#include "sieve_interface.h"
+
+#include "bytecode.h"
+#include "script.h"
+
+#include "xmalloc.h"
+#include <sys/types.h> 
+#include <sys/stat.h>
+#include <fcntl.h> 
+#include <unistd.h> 
+#include <netinet/in.h>
+
+#include <string.h>
+
+#include "map.h"
+
+struct et_list *_et_list = NULL;
+
+/* config.c stuff */
+const int config_need_data = 0;
+
+static void dump2(bytecode_input_t *d, int len);
+static int dump2_test(bytecode_input_t * d, int i);
+
+static int load(int fd, bytecode_input_t ** d)
+{  
+    const char * data=NULL;
+    struct stat sbuf;
+    unsigned long len=0;
+    
+    if (fstat(fd, &sbuf) == -1) {
+	printf("IOERROR: fstating sieve script: %m");
+	return SIEVE_FAIL;
+    }
+    
+    /*this reads in data and length from file*/
+    map_refresh(fd, 1, &(data), &len, sbuf.st_size,
+		"sievescript", "");
+    *d=(bytecode_input_t *)data;
+    
+    printf("\n");
+    
+    return (len/sizeof(int));
+}
+
+
+int main(int argc, char * argv[])
+{
+    bytecode_input_t * bc = NULL;
+    int script_fd;
+    
+    unsigned long len;
+    
+    if (argc!=2) {
+	 fprintf(stderr, "usage:\n %s script\n", argv[0]);
+	 exit(1);
+    }
+
+    /*get script*/
+    script_fd = open(argv[1], O_RDONLY);
+    if (script_fd == -1) 
+    {
+	printf("can not open script '%s'\n", argv[1]);
+	exit(1);
+    }
+    
+    lib_init();
+    len=load(script_fd,&bc);
+    close(script_fd);
+    
+    if (bc) {
+	dump2(bc, len );
+	exit(0);
+    } else {
+	exit(1);
+    }
+}
+
+static int write_list(int list_len, int i, bytecode_input_t * d)
+{
+    int x;
+    i++;
+    for (x=0; x<list_len; x++)
+    {
+	const char *data;
+	int len;
+	
+	i = unwrap_string(d, i, &data, &len);
+	
+	printf("{%d}%s\n", len, data);
+    }
+    return i;
+}
+
+static int printComparison(bytecode_input_t *d ,int i)
+{
+    printf("Comparison: ");
+    switch(ntohl(d[i].value))
+    {
+    case B_IS: printf("Is"); break;
+    case B_CONTAINS:printf("Contains"); break;
+    case B_MATCHES: printf("Matches"); break;
+    case B_REGEX: printf("Regex"); break;
+    case B_COUNT:
+	printf("Count");
+	
+	switch(ntohl(d[i+1].value))
+	{
+	case B_GT: printf(" greater than "); break;   
+	case B_GE: printf(" greater than or equal "); break;
+	case B_LT: printf(" less than "); break;
+	case B_LE: printf(" less than or equal "); break;
+	case B_NE: printf(" not equal "); break;
+	case B_EQ: printf(" equal "); break;
+	}
+
+	break;
+    case B_VALUE:
+	printf("Value");
+	
+	switch(ntohl(d[i+1].value))
+	{
+	case B_GT: printf(" greater than "); break;   
+	case B_GE: printf(" greater than or equal ");break;
+	case B_LT: printf(" less than ");    break;
+	case B_LE: printf(" less than or equal ");break;
+	case B_NE: printf(" not equal ");    break;
+	case B_EQ: printf(" equal ");break;
+	}
+	
+	break;
+    default:
+	exit(1);
+    }
+
+    switch (ntohl(d[i+2].value))
+    {
+    case B_ASCIICASEMAP: printf("   (ascii-casemap) "); break;
+    case B_OCTET: printf("    (octet) "); break;
+    case B_ASCIINUMERIC:  printf("   (ascii-numeric) "); break;
+    default: exit(1);
+    }
+    
+    printf("\n");
+    return i+3;
+}
+
+
+static int dump2_test(bytecode_input_t * d, int i)
+{
+    int l,x;
+    switch(ntohl(d[i].value)) {
+    case BC_FALSE:
+	printf("false");
+	i++;
+	break;
+    case BC_TRUE:
+	printf("true");
+	i++;
+	break;
+    case BC_NOT:/*2*/
+	/* XXX 
+	   there is a value being skipped in the second pass...
+	   no idea what it does, but it isn't carried to here...
+	   see bytecodee.c */
+	printf(" not(");
+	i=dump2_test(d, i+1);
+	printf(")\n");
+	break;
+    case BC_EXISTS:
+	printf("exists");
+	i=write_list(ntohl(d[i+1].len), i+2, d);
+	break;
+    case BC_SIZE:
+	printf("size");
+	if (ntohl(d[i+1].value)==B_OVER) {
+	    /* over */
+	    printf("over %d", ntohl(d[i+2].value));
+	} else {
+	    /* under */
+	    printf("under %d", ntohl(d[i+2].value));
+	}
+	i+=3;
+	break;
+    case BC_ANYOF:/*5*/
+	printf("any of \n(");
+	l=ntohl(d[i+1].len);
+	i+=3;
+	
+	for (x=0; x<l; x++)
+	{
+	    i=dump2_test(d,i);
+	    if((x+1)<l)
+		printf(" OR ");
+	}
+	
+	printf(")\n");	 
+	break;
+    case BC_ALLOF:/*6*/
+	printf("all of \n(");
+	l=ntohl(d[i+1].len);
+	i+=3;
+	
+	for (x=0; x<l; x++)
+	{
+	    i=dump2_test(d,i);
+	    if((x+1)<l)
+		printf(" AND ");
+	}
+	
+	printf(")\n");
+	break;
+    case BC_ADDRESS:/*7*/
+	printf("Address [");
+	i=printComparison(d, i+1);
+	printf("               type: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_ALL: printf("all"); break;
+	case B_LOCALPART:printf("localpart"); break;
+	case B_DOMAIN:printf("domain"); break;
+	case B_USER:printf("user"); break;
+	case B_DETAIL:printf("detail"); break;
+	}
+	printf("              Headers:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_ENVELOPE:/*8*/
+	printf("Envelope [");
+	i=printComparison(d, i+1);
+	printf("                type: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_ALL: printf("all"); break;
+	case B_LOCALPART:printf("localpart"); break;
+	case B_DOMAIN:printf("domain"); break;
+	case B_USER:printf("user"); break;
+	case B_DETAIL:printf("detail"); break;
+	}
+	printf("              Headers:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_HEADER:/*9*/
+	printf("Header [");
+	i= printComparison(d, i+1);
+	printf("              Headers: ");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data: ");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_BODY:/*10*/
+	printf("Body [");
+	i=printComparison(d, i+1);
+	printf("              Transform: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_RAW: printf("raw"); break;
+	case B_TEXT:printf("text"); break;
+	case B_CONTENT:printf("content"); break;
+	}
+	printf("\tOffset: %d\n", ntohl(d[i++].value));
+	printf("              Content-Types:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    default:
+	printf("WERT %d ", ntohl(d[i].value));
+    }   
+    return i;
+}
+
+static void dump2(bytecode_input_t *d, int bc_len)
+{
+    int i;
+    int version;
+    const char *data;
+    int len;
+    
+    if(memcmp(d, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	printf("not a bytecode file [magic number test failed]\n");
+	return;
+    }
+
+    i = BYTECODE_MAGIC_LEN / sizeof(bytecode_input_t);
+
+    version = ntohl(d[i].op);
+    printf("Sievecode version %d\n", version);
+    if(!d) return;
+    
+    for(i++; i<bc_len;) 
+    {
+	int copy = 0;
+
+	printf("%d: ",i);
+
+	switch(ntohl(d[i++].op)) {
+	    
+	case B_STOP:/*0*/
+	    printf("STOP\n");
+	    break;
+	    
+	case B_KEEP:/*1*/
+	    printf("KEEP\n");
+	    break;
+	    
+	case B_DISCARD:/*2*/
+	    printf("DISCARD\n");
+	    break;
+	    
+	case B_REJECT:/*3*/
+	    i = unwrap_string(d, i, &data, &len);
+	    printf("REJECT {%d}%s\n", len, data);
+	    break;
+
+	case B_FILEINTO: /*19*/
+	    copy = ntohl(d[i++].value);
+	case B_FILEINTO_ORIG: /*4*/
+	    i = unwrap_string(d, i, &data, &len);
+	    printf("FILEINTO COPY(%d) FOLDER({%d}%s)\n",copy,len,data);
+	    break;
+
+	case B_REDIRECT: /*20*/
+	    copy = ntohl(d[i++].value);
+	case B_REDIRECT_ORIG: /*5*/
+	    i = unwrap_string(d, i, &data, &len);
+	    printf("REDIRECT COPY(%d) ADDRESS({%d}%s)\n",copy,len,data);
+	    break;
+	     
+	case B_IF:/*6*/
+	    printf("IF (ends at %d)", ntohl(d[i].value));
+
+            /* there is no short circuiting involved here*/
+	    i = dump2_test(d,i+1);
+	    printf("\n");
+
+	    break;
+
+	case B_MARK:/*7*/
+	    printf("MARK\n");
+	    break;
+
+	case B_UNMARK:/*8*/
+	    printf("UNMARK\n");
+	    break;
+
+	case B_ADDFLAG: /*9*/
+	    printf("ADDFLAG  {%d}\n",ntohl(d[i].len));
+	    i=write_list(ntohl(d[i].len),i+1,d);
+	    break;
+
+	case B_SETFLAG: /*10*/
+	    printf("SETFLAG  {%d}\n",ntohl(d[i].len));
+	    i=write_list(ntohl(d[i].len),i+1,d);
+	    break;
+	    
+	case B_REMOVEFLAG: /*11*/
+	    printf("REMOVEFLAG  {%d}\n",ntohl(d[i].len));
+	    i=write_list(ntohl(d[i].len),i+1,d);
+	    break;
+	    
+	case B_DENOTIFY:/*12*/
+	    printf("DENOTIFY\n");
+	    printf("            PRIORITY(%d) Comparison type %d (relat %d)\n",
+		   ntohl(d[i].value), ntohl(d[i+1].value), ntohl(d[i+2].value));
+	    i+=3;
+
+	    i = unwrap_string(d, i+1, &data, &len);
+	    
+	    printf("           ({%d}%s)\n", len, (!data ? "[nil]" : data));
+	    break;
+	    
+	case B_NOTIFY: /*13*/
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("NOTIFY METHOD({%d}%s)\n",len,data);
+
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("            ID({%d}%s) OPTIONS ", len,
+		   (!data ? "[nil]" : data));
+
+	    i=write_list(ntohl(d[i].len),i+1,d);
+	    
+	    printf("            PRIORITY(%d)\n", ntohl(d[i].value));
+      	    i++;
+		  
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("            MESSAGE({%d}%s)\n", len, data);
+
+	    break;
+
+	case B_VACATION:/*14*/
+	    printf("VACATION\n");
+	    /*add address list here!*/
+	    i=write_list(ntohl(d[i].len),i+1,d);
+
+	    i = unwrap_string(d, i, &data, &len);
+	  
+	    printf("%d SUBJ({%d}%s) \n",i, len, (!data ? "[nil]" : data));
+	    
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("%d MESG({%d}%s) \n", i, len, (!data ? "[nil]" : data));
+
+	    printf("DAYS(%d) MIME(%d)\n", ntohl(d[i].value), ntohl(d[i+1].value));
+	    i+=2;
+
+	    if (version >= 0x05) {
+		i = unwrap_string(d, i, &data, &len);
+
+		printf("%d FROM({%d}%s) \n",i, len, (!data ? "[nil]" : data));
+
+		i = unwrap_string(d, i, &data, &len);
+
+		printf("%d HANDLE({%d}%s) \n",i, len, (!data ? "[nil]" : data));
+	    }
+
+	    break;
+	case B_NULL:/*15*/
+	    printf("NULL\n");
+	    break;
+	case B_JUMP:/*16*/
+	    printf("JUMP %d\n", ntohl(d[i].jump));
+	    i+=1;
+	    break;		  
+
+	case B_INCLUDE:/*17*/
+	    printf("INCLUDE ");
+	    switch (ntohl(d[i].value)) {
+	    case B_PERSONAL: printf("Personal"); break;
+	    case B_GLOBAL: printf("Global"); break;
+	    }
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf(" {%d}%s\n", len, data);
+	    break;
+
+	case B_RETURN:/*18*/
+	    printf("RETURN\n");
+	    break;
+	    
+	default:
+	    printf("%d (NOT AN OP)\n",ntohl(d[i-1].op));
+	    exit(1);
+	}
+    }
+    printf("full len is: %d\n", bc_len);
+}
+
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve_err.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve_err.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve_err.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve_err.c	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,59 @@
+/*
+ * sieve_err.c:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <stdlib.h>
+
+static const char * const text[] = {
+	   "Generic Sieve error",
+	   "Sieve interpretor not finalized",
+	   "Parse error in Sieve script",
+	   "Run-time error during Sieve execution",
+	   "Internal error in Sieve subsystem",
+	   "Memory exhausted in Sieve subsystem",
+	   "Sieve action already taken",
+    0
+};
+
+struct error_table {
+    char const * const * msgs;
+    long base;
+    int n_msgs;
+};
+struct et_list {
+    struct et_list *next;
+    const struct error_table * table;
+};
+extern struct et_list *_et_list;
+
+const struct error_table et_siev_error_table = { text, -1237848064L, 7 };
+
+static struct et_list link = { 0, 0 };
+
+void initialize_siev_error_table_r(struct et_list **list);
+void initialize_siev_error_table(void);
+
+void initialize_siev_error_table(void) {
+    initialize_siev_error_table_r(&_et_list);
+}
+
+/* For Heimdal compatibility */
+void initialize_siev_error_table_r(struct et_list **list)
+{
+    struct et_list *et, **end;
+
+    for (end = list, et = *list; et; end = &et->next, et = et->next)
+        if (et->table->msgs == text)
+            return;
+    et = malloc(sizeof(struct et_list));
+    if (et == 0) {
+        if (!link.table)
+            et = &link;
+        else
+            return;
+    }
+    et->table = &et_siev_error_table;
+    et->next = 0;
+    *end = et;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve_err.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve_err.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve_err.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve_err.h	2007-07-19 19:19:14.000000000 -0600
@@ -0,0 +1,25 @@
+/*
+ * sieve_err.h:
+ * This file is automatically generated; please do not edit it.
+ */
+
+struct et_list;
+
+#define SIEVE_FAIL                               (-1237848064L)
+#define SIEVE_NOT_FINALIZED                      (-1237848063L)
+#define SIEVE_PARSE_ERROR                        (-1237848062L)
+#define SIEVE_RUN_ERROR                          (-1237848061L)
+#define SIEVE_INTERNAL_ERROR                     (-1237848060L)
+#define SIEVE_NOMEM                              (-1237848059L)
+#define SIEVE_DONE                               (-1237848058L)
+extern const struct error_table et_siev_error_table;
+extern void initialize_siev_error_table(void);
+
+/* For compatibility with Heimdal */
+extern void initialize_siev_error_table_r(struct et_list **list);
+
+#define ERROR_TABLE_BASE_siev (-1237848064L)
+
+/* for compatibility with older versions... */
+#define init_siev_err_tbl initialize_siev_error_table
+#define siev_err_base ERROR_TABLE_BASE_siev
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve.h	2007-07-19 20:00:00.000000000 -0600
@@ -0,0 +1,221 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     NUMBER = 258,
+     STRING = 259,
+     IF = 260,
+     ELSIF = 261,
+     ELSE = 262,
+     REJCT = 263,
+     FILEINTO = 264,
+     REDIRECT = 265,
+     KEEP = 266,
+     STOP = 267,
+     DISCARD = 268,
+     VACATION = 269,
+     REQUIRE = 270,
+     SETFLAG = 271,
+     ADDFLAG = 272,
+     REMOVEFLAG = 273,
+     MARK = 274,
+     UNMARK = 275,
+     NOTIFY = 276,
+     DENOTIFY = 277,
+     ANYOF = 278,
+     ALLOF = 279,
+     EXISTS = 280,
+     SFALSE = 281,
+     STRUE = 282,
+     HEADER = 283,
+     NOT = 284,
+     SIZE = 285,
+     ADDRESS = 286,
+     ENVELOPE = 287,
+     BODY = 288,
+     COMPARATOR = 289,
+     IS = 290,
+     CONTAINS = 291,
+     MATCHES = 292,
+     REGEX = 293,
+     COUNT = 294,
+     VALUE = 295,
+     OVER = 296,
+     UNDER = 297,
+     GT = 298,
+     GE = 299,
+     LT = 300,
+     LE = 301,
+     EQ = 302,
+     NE = 303,
+     ALL = 304,
+     LOCALPART = 305,
+     DOMAIN = 306,
+     USER = 307,
+     DETAIL = 308,
+     RAW = 309,
+     TEXT = 310,
+     CONTENT = 311,
+     DAYS = 312,
+     ADDRESSES = 313,
+     SUBJECT = 314,
+     FROM = 315,
+     HANDLE = 316,
+     MIME = 317,
+     METHOD = 318,
+     ID = 319,
+     OPTIONS = 320,
+     LOW = 321,
+     NORMAL = 322,
+     HIGH = 323,
+     ANY = 324,
+     MESSAGE = 325,
+     INCLUDE = 326,
+     PERSONAL = 327,
+     GLOBAL = 328,
+     RETURN = 329,
+     COPY = 330
+   };
+#endif
+/* Tokens.  */
+#define NUMBER 258
+#define STRING 259
+#define IF 260
+#define ELSIF 261
+#define ELSE 262
+#define REJCT 263
+#define FILEINTO 264
+#define REDIRECT 265
+#define KEEP 266
+#define STOP 267
+#define DISCARD 268
+#define VACATION 269
+#define REQUIRE 270
+#define SETFLAG 271
+#define ADDFLAG 272
+#define REMOVEFLAG 273
+#define MARK 274
+#define UNMARK 275
+#define NOTIFY 276
+#define DENOTIFY 277
+#define ANYOF 278
+#define ALLOF 279
+#define EXISTS 280
+#define SFALSE 281
+#define STRUE 282
+#define HEADER 283
+#define NOT 284
+#define SIZE 285
+#define ADDRESS 286
+#define ENVELOPE 287
+#define BODY 288
+#define COMPARATOR 289
+#define IS 290
+#define CONTAINS 291
+#define MATCHES 292
+#define REGEX 293
+#define COUNT 294
+#define VALUE 295
+#define OVER 296
+#define UNDER 297
+#define GT 298
+#define GE 299
+#define LT 300
+#define LE 301
+#define EQ 302
+#define NE 303
+#define ALL 304
+#define LOCALPART 305
+#define DOMAIN 306
+#define USER 307
+#define DETAIL 308
+#define RAW 309
+#define TEXT 310
+#define CONTENT 311
+#define DAYS 312
+#define ADDRESSES 313
+#define SUBJECT 314
+#define FROM 315
+#define HANDLE 316
+#define MIME 317
+#define METHOD 318
+#define ID 319
+#define OPTIONS 320
+#define LOW 321
+#define NORMAL 322
+#define HIGH 323
+#define ANY 324
+#define MESSAGE 325
+#define INCLUDE 326
+#define PERSONAL 327
+#define GLOBAL 328
+#define RETURN 329
+#define COPY 330
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 148 "sieve.y"
+{
+    int nval;
+    char *sval;
+    stringlist_t *sl;
+    test_t *test;
+    testlist_t *testl;
+    commandlist_t *cl;
+    struct vtags *vtag;
+    struct aetags *aetag;
+    struct htags *htag;
+    struct btags *btag;
+    struct ntags *ntag;
+    struct dtags *dtag;
+}
+/* Line 1489 of yacc.c.  */
+#line 214 "sieve.h"
+	YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE sievelval;
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve_interface.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve_interface.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve_interface.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve_interface.h	2007-07-19 22:10:02.000000000 -0600
@@ -0,0 +1,188 @@
+/* sieve_interface.h -- interface for deliver
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef SIEVE_H
+#define SIEVE_H
+
+#include <stdio.h>
+
+#define SIEVE_VERSION "CMU Sieve 2.3"
+
+/* error codes */
+#define SIEVE_OK (0)
+
+#include "sieve_err.h"
+
+/* external sieve types */
+typedef struct sieve_interp sieve_interp_t;
+typedef struct sieve_script sieve_script_t;
+typedef struct sieve_execute sieve_execute_t;
+typedef struct bytecode_info bytecode_info_t;
+
+typedef int sieve_callback(void *action_context, void *interp_context, 
+			   void *script_context,
+			   void *message_context, const char **errmsg);
+typedef int sieve_get_size(void *message_context, int *size);
+typedef int sieve_get_header(void *message_context, 
+			     const char *header,
+			     const char ***contents);
+typedef int sieve_get_envelope(void *message_context, 
+			       const char *field,
+			       const char ***contents);
+typedef int sieve_get_include(void *script_context, const char *script,
+			      int isglobal, char *fpath, size_t size);
+
+/* MUST keep this struct sync'd with bodypart in imap/message.h */
+typedef struct sieve_bodypart {
+    /*char section[128];*/
+    const char *content;
+    /*const char *encoding;*/
+    unsigned long size;
+} sieve_bodypart_t;
+
+typedef int sieve_get_body(void *message_context, const char **content_types,
+			   int decode_to_plain, sieve_bodypart_t **parts_r);
+
+typedef struct sieve_vacation {
+    int min_response;		/* 0 -> defaults to 3 */
+    int max_response;		/* 0 -> defaults to 90 */
+
+    /* given a hash, say whether we've already responded to it in the last
+       days days.  return SIEVE_OK if we SHOULD autorespond (have not already)
+       or SIEVE_DONE if we SHOULD NOT. */
+    sieve_callback *autorespond;
+
+    /* mail the response */
+    sieve_callback *send_response;
+} sieve_vacation_t;
+
+typedef struct sieve_imapflags {
+    char **flag;		/* NULL -> defaults to \flagged */
+    int nflags;
+} sieve_imapflags_t;
+
+typedef struct sieve_redirect_context {
+    const char *addr;
+} sieve_redirect_context_t;
+
+typedef struct sieve_reject_context {
+    const char *msg;
+} sieve_reject_context_t;
+
+typedef struct sieve_fileinto_context {
+    const char *mailbox;
+    sieve_imapflags_t *imapflags;
+} sieve_fileinto_context_t;
+
+typedef struct sieve_keep_context {
+    sieve_imapflags_t *imapflags;
+} sieve_keep_context_t;
+
+typedef struct sieve_notify_context {
+    const char *method;
+    const char **options;
+    const char *priority;
+    const char *message;
+} sieve_notify_context_t;
+
+#define SIEVE_HASHLEN 16
+
+typedef struct sieve_autorespond_context {
+    unsigned char hash[SIEVE_HASHLEN];
+    int days;
+} sieve_autorespond_context_t;
+
+typedef struct sieve_send_response_context {
+    char *addr;
+    char *fromaddr;
+    const char *msg;
+    char *subj;
+    int mime;
+} sieve_send_response_context_t;
+
+/* build a sieve interpretor */
+int sieve_interp_alloc(sieve_interp_t **interp, void *interp_context);
+int sieve_interp_free(sieve_interp_t **interp);
+
+/* add the callbacks for actions. undefined behavior results if these
+   are called after sieve_script_parse is called! */
+int sieve_register_redirect(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_discard(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_reject(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_fileinto(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_keep(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_vacation(sieve_interp_t *interp, sieve_vacation_t *v);
+int sieve_register_imapflags(sieve_interp_t *interp, sieve_imapflags_t *mark);
+int sieve_register_notify(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_include(sieve_interp_t *interp, sieve_get_include *f);
+
+/* add the callbacks for messages. again, undefined if used after
+   sieve_script_parse */
+int sieve_register_size(sieve_interp_t *interp, sieve_get_size *f);
+int sieve_register_header(sieve_interp_t *interp, sieve_get_header *f);
+int sieve_register_envelope(sieve_interp_t *interp, sieve_get_envelope *f);
+int sieve_register_body(sieve_interp_t *interp, sieve_get_body *f);
+
+typedef int sieve_parse_error(int lineno, const char *msg, 
+			      void *interp_context,
+			      void *script_context);
+int sieve_register_parse_error(sieve_interp_t *interp, sieve_parse_error *f);
+
+typedef int sieve_execute_error(const char *msg, void *interp_context,
+				void *script_context, void *message_context);
+int sieve_register_execute_error(sieve_interp_t *interp, 
+				 sieve_execute_error *f);
+ 
+/* given an interpretor and a script, produce an executable script */
+int sieve_script_parse(sieve_interp_t *interp, FILE *script,
+		       void *script_context, sieve_script_t **ret);
+
+/* given a path to a bytecode file, load it into the sieve_execute_t */
+int sieve_script_load(const char *fpath, sieve_execute_t **ret);
+
+/* Unload a sieve_bytecode_t */
+int sieve_script_unload(sieve_execute_t **s);
+
+/* Free a sieve_script_t */
+int sieve_script_free(sieve_script_t **s);
+
+/* execute bytecode on a message */
+int sieve_execute_bytecode(sieve_execute_t *script, sieve_interp_t *interp,
+			   void *script_context, void *message_context);
+
+/* Get space separated list of extensions supported by the implementation */
+const char *sieve_listextensions(sieve_interp_t *i);
+
+/* Create a bytecode structure given a parsed commandlist */
+int sieve_generate_bytecode(bytecode_info_t **retval, sieve_script_t *s);
+
+/* Emit bytecode to a file descriptor */
+int sieve_emit_bytecode(int fd, bytecode_info_t *bc);
+
+/* Free a bytecode_info_t */
+void sieve_free_bytecode(bytecode_info_t **p);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve-lex.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve-lex.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve-lex.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve-lex.c	2007-07-19 20:45:27.000000000 -0600
@@ -0,0 +1,2385 @@
+
+#line 3 "<stdout>"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 78
+#define YY_END_OF_BUFFER 79
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[359] =
+    {   0,
+        0,    0,    0,    0,    0,    0,   79,   77,   74,   74,
+        8,   75,   77,    9,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+        3,    3,    3,    6,    6,    4,    6,   75,    0,    9,
+        9,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       10,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    1,    1,    2,    5,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   38,
+
+       53,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   22,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   76,    0,   61,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       41,    0,    0,    0,    0,    0,    0,    0,    0,   66,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       21,    0,    0,   12,    0,    0,    0,    0,    0,    0,
+        0,   27,   34,    0,    0,    0,    0,    0,    0,    0,
+
+       23,   29,    0,   17,    0,    0,   76,    0,    0,    0,
+       73,    0,   46,    0,    0,   49,    0,    0,   43,    0,
+        0,    0,    0,   51,    0,    0,   59,    0,    0,    0,
+       67,    0,   64,    0,    0,    0,   14,   13,    0,    0,
+       11,    0,    0,   16,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   57,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   56,    0,   60,   58,    0,    0,    0,
+        0,    0,   15,    0,   20,    0,   36,    0,   24,    0,
+        0,   72,    0,    0,    7,    7,    0,   35,    0,    0,
+
+        0,    0,    0,   65,   63,   71,   50,    0,    0,    0,
+       39,   42,    0,    0,    0,   32,   18,    0,   30,    0,
+        0,   69,    0,    0,   28,   31,    0,    7,    0,    0,
+        0,    0,   68,    0,   55,   44,   40,    0,   48,   37,
+       19,   25,   26,    0,    7,   45,    0,    0,   54,    0,
+       70,    0,   47,    0,   62,   33,   52,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    5,    6,    1,    1,    1,    1,    1,
+        1,    7,    1,    1,    1,    8,    9,   10,   10,   10,
+       10,   10,   10,   10,   10,   10,   10,   11,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+       12,    1,    1,    1,   12,    1,   12,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,   13,    1,    1,    1,    1,   14,   15,   16,   17,
+
+       18,   19,   20,   21,   22,   23,   24,   25,   26,   27,
+       28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
+       38,   39,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[40] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[365] =
+    {   0,
+        0,    0,  393,   37,   38,   39,  395,  397,  397,  397,
+      397,    0,  387,   36,   49,   30,  365,   31,   60,   36,
+      374,   40,  373,  376,  361,  370,   68,   61,  360,  372,
+      397,  397,   85,  397,  397,  397,    0,    0,  378,   84,
+      397,   47,  356,   77,  352,  357,   84,   82,  353,   89,
+      352,   80,  361,   98,  344,  359,   86,  362,  358,  349,
+      335,  355,  344,  338,  337,  333,  345,  341,  340,  350,
+      397,  347,  344,  330,  327,  100,  326,  319,  329,  319,
+      321,  328,  337,  397,  349,  397,  397,  344,   93,  333,
+      324,   93,  310,  314,  320,  317,  316,  316,  322,  397,
+
+      397,  105,  308,   92,  314,  308,  305,  319,  305,  299,
+      314,  318,  295,  314,  312,  304,   42,  300,  299,  288,
+      297,  308,  110,  305,  290,  289,  302,  302,  293,  288,
+      292,  293,  292,  295,  284,  277,  276,  290,  290,  278,
+      273,  287,  290,  289,  122,  397,  271,  397,  272,  267,
+      261,  271,  265,  282,  281,  268,  278,  275,  270,  276,
+      397,  273,  256,  266,  268,  259,  262,  252,  250,  397,
+      263,  257,  246,  260,  246,  242,  250,  256,  254,  253,
+      397,  238,  256,  397,  250,  243,  234,  248,  243,  246,
+      229,  397,  397,  243,  230,  244,  224,  236,  226,  231,
+
+      397,  397,  244,  397,  223,  220,  245,  233,  236,  120,
+      397,  216,  397,  226,  225,  397,  232,  220,  397,  219,
+      222,  228,  213,  397,  226,  211,  397,  210,  200,  218,
+      397,  204,  397,  216,  219,  200,  397,  397,  209,  199,
+      397,  201,  196,  397,  200,  195,  208,  186,  205,  189,
+      203,  189,  192,  204,  133,  193,  194,  183,  183,  191,
+      185,  397,  186,  183,  184,  190,  178,  188,  185,  187,
+      178,  175,  174,  397,  184,  397,  397,  179,  166,  178,
+      179,  166,  397,  161,  397,  175,  397,  176,  397,  172,
+      172,  397,  169,  140,  397,  185,  144,  397,  159,  154,
+
+      171,  157,  150,  397,  397,  397,  397,  168,  149,  162,
+      397,  397,  147,  164,  144,  397,  397,  138,  397,  157,
+      146,  397,  140,  147,  397,  397,  146,  148,  144,  152,
+      136,  136,  397,  136,  397,  397,  397,  141,  397,  397,
+      397,  397,  397,  151,  397,  397,  132,  135,  397,  129,
+      397,  141,  397,  114,  397,  397,  397,  397,  152,  154,
+      139,   53,  156,  158
+    } ;
+
+static yyconst flex_int16_t yy_def[365] =
+    {   0,
+      358,    1,  359,  359,  360,  360,  358,  358,  358,  358,
+      358,  361,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  362,  361,  363,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  363,  363,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  363,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+
+      358,  358,  358,  358,  358,  358,  363,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  364,  358,  358,  358,
+
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  364,  364,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,    0,  358,  358,
+      358,  358,  358,  358
+    } ;
+
+static yyconst flex_int16_t yy_nxt[437] =
+    {   0,
+        8,    9,   10,    9,   11,   12,    8,    8,   13,   14,
+       15,    8,    8,   16,   17,    8,   18,   19,   20,    8,
+       21,   22,    8,   23,    8,   24,   25,    8,    8,    8,
+       26,   27,   28,   29,   30,    8,    8,    8,    8,   32,
+       35,   35,   36,   36,   33,   40,   59,   41,   63,   68,
+       37,   37,   64,   87,   60,   41,   61,   69,   71,   41,
+      177,   41,   42,   90,   43,   44,   72,   45,   46,   47,
+       48,   91,  178,   49,   50,   51,   52,   53,   80,   54,
+       55,   56,   57,   58,   65,   77,   66,   84,   85,   78,
+       93,   81,   86,   40,   94,   41,   67,   98,  100,  145,
+
+       79,  146,  103,   41,   95,   99,  104,   41,  107,   41,
+      105,  110,  114,  101,  108,  111,  133,  115,  149,  150,
+      160,  151,  134,  163,  164,  135,  152,  184,   89,  136,
+      207,  185,  137,  260,  294,  295,  296,  261,  297,   38,
+      161,  294,  295,  296,  357,  297,  295,  328,  295,  328,
+      345,  328,   31,   31,   34,   34,   88,   88,  327,  327,
+      356,  355,  354,  353,  352,  351,  350,  349,  348,  347,
+      346,  344,  343,  342,  341,  340,  339,  338,  337,  336,
+      335,  334,  333,  332,  331,  330,  329,  295,  326,  325,
+      324,  323,  322,  321,  320,  319,  318,  317,  316,  315,
+
+      314,  313,  312,  311,  310,  309,  308,  307,  306,  305,
+      304,  303,  302,  301,  300,  299,  298,  293,  292,  291,
+      290,  289,  288,  287,  286,  285,  284,  283,  282,  281,
+      280,  279,  278,  277,  276,  275,  274,  273,  272,  271,
+      270,  269,  268,  267,  266,  265,  264,  263,  262,  259,
+      258,   89,  257,  256,  255,  254,  253,  252,  251,  250,
+      249,  248,  247,  246,  245,  244,  243,  242,  241,  240,
+      239,  238,  237,  236,  235,  234,  233,  232,  231,  230,
+      229,  228,  227,  226,  225,  224,  223,  222,  221,  220,
+      219,  218,  217,  216,  215,  214,  213,  212,  211,  210,
+
+      209,  208,  206,  205,  204,  203,  202,  201,  200,  199,
+      198,  197,  196,  195,  194,  193,  192,  191,  190,  189,
+      188,  187,  186,  183,  182,  181,  180,  179,  176,  175,
+      174,  173,  172,  171,  170,  169,  168,  167,  166,  165,
+      162,  159,  158,  157,  156,  155,  154,  153,  148,  147,
+       89,   84,  144,  143,  142,  141,  140,  139,  138,  132,
+      131,  130,  129,  128,  127,  126,  125,  124,  123,  122,
+      121,  120,  119,  118,  117,  116,  113,  112,  109,  106,
+      102,   97,   96,   92,   89,   83,   82,   76,   75,   74,
+       73,   70,   62,   39,  358,   32,    7,  358,  358,  358,
+
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358
+    } ;
+
+static yyconst flex_int16_t yy_chk[437] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    4,
+        5,    6,    5,    6,    4,   14,   16,   14,   18,   20,
+        5,    6,   18,  362,   16,   14,   16,   20,   22,   14,
+      117,   14,   15,   42,   15,   15,   22,   15,   15,   15,
+       15,   42,  117,   15,   15,   15,   15,   15,   28,   15,
+       15,   15,   15,   15,   19,   27,   19,   33,   33,   27,
+       44,   28,   33,   40,   44,   40,   19,   47,   48,   89,
+
+       27,   89,   50,   40,   44,   47,   50,   40,   52,   40,
+       50,   54,   57,   48,   52,   54,   76,   57,   92,   92,
+      102,   92,   76,  104,  104,   76,   92,  123,  145,   76,
+      145,  123,   76,  210,  255,  255,  255,  210,  255,  361,
+      102,  294,  294,  294,  354,  294,  297,  297,  327,  327,
+      328,  328,  359,  359,  360,  360,  363,  363,  364,  364,
+      352,  350,  348,  347,  344,  338,  334,  332,  331,  330,
+      329,  324,  323,  321,  320,  318,  315,  314,  313,  310,
+      309,  308,  303,  302,  301,  300,  299,  296,  293,  291,
+      290,  288,  286,  284,  282,  281,  280,  279,  278,  275,
+
+      273,  272,  271,  270,  269,  268,  267,  266,  265,  264,
+      263,  261,  260,  259,  258,  257,  256,  254,  253,  252,
+      251,  250,  249,  248,  247,  246,  245,  243,  242,  240,
+      239,  236,  235,  234,  232,  230,  229,  228,  226,  225,
+      223,  222,  221,  220,  218,  217,  215,  214,  212,  209,
+      208,  207,  206,  205,  203,  200,  199,  198,  197,  196,
+      195,  194,  191,  190,  189,  188,  187,  186,  185,  183,
+      182,  180,  179,  178,  177,  176,  175,  174,  173,  172,
+      171,  169,  168,  167,  166,  165,  164,  163,  162,  160,
+      159,  158,  157,  156,  155,  154,  153,  152,  151,  150,
+
+      149,  147,  144,  143,  142,  141,  140,  139,  138,  137,
+      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
+      126,  125,  124,  122,  121,  120,  119,  118,  116,  115,
+      114,  113,  112,  111,  110,  109,  108,  107,  106,  105,
+      103,   99,   98,   97,   96,   95,   94,   93,   91,   90,
+       88,   85,   83,   82,   81,   80,   79,   78,   77,   75,
+       74,   73,   72,   70,   69,   68,   67,   66,   65,   64,
+       63,   62,   61,   60,   59,   58,   56,   55,   53,   51,
+       49,   46,   45,   43,   39,   30,   29,   26,   25,   24,
+       23,   21,   17,   13,    7,    3,  358,  358,  358,  358,
+
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358,  358,  358,  358,  358,
+      358,  358,  358,  358,  358,  358
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[79] =
+    {   0,
+1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,     };
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "sieve-lex.l"
+#line 2 "sieve-lex.l"
+/* sieve.l -- sieve lexer
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h> /* for strdup */
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+#define yylval sievelval
+#define yylex sievelex
+#define yyerror sieveerror
+
+static int tonum(char *c);
+static char *chkstr(char *);
+static char *mlbuf;
+static int mlbufsz, mlcur;
+extern int yyerror(char *);
+
+
+#line 739 "<stdout>"
+
+#define INITIAL 0
+#define MULTILINE 1
+#define QSTRING 2
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 61 "sieve-lex.l"
+
+#line 897 "<stdout>"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 359 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 397 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					   
+    yylineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 62 "sieve-lex.l"
+{ BEGIN INITIAL; 
+                          if (mlbuf) mlbuf[mlcur] = '\0';
+                          yylval.sval = chkstr(mlbuf); return STRING; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 65 "sieve-lex.l"
+{ /* dot stuffing! we want one . */ yyless(1); }
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 66 "sieve-lex.l"
+{ if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+	YY_BREAK
+case YY_STATE_EOF(MULTILINE):
+#line 69 "sieve-lex.l"
+{ yyerror("unexpected end of file in string"); 
+		     yyterminate(); }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 71 "sieve-lex.l"
+{ BEGIN INITIAL;
+                     if (mlbuf) mlbuf[mlcur] = '\0';
+		     yylval.sval = chkstr(mlbuf); return STRING; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 74 "sieve-lex.l"
+{ if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[1]; }
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 77 "sieve-lex.l"
+{ if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+	YY_BREAK
+case 7:
+/* rule 7 can match eol */
+YY_RULE_SETUP
+#line 80 "sieve-lex.l"
+{ BEGIN MULTILINE;
+			  mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 82 "sieve-lex.l"
+{ BEGIN QSTRING;
+                    mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 84 "sieve-lex.l"
+{ yylval.nval = tonum(yytext); return NUMBER; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 85 "sieve-lex.l"
+return IF;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 86 "sieve-lex.l"
+return ELSIF;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 87 "sieve-lex.l"
+return ELSE;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 88 "sieve-lex.l"
+return ANYOF;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 89 "sieve-lex.l"
+return ALLOF;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 90 "sieve-lex.l"
+return EXISTS;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 91 "sieve-lex.l"
+return SFALSE;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 92 "sieve-lex.l"
+return STRUE;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 93 "sieve-lex.l"
+return ADDRESS;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 94 "sieve-lex.l"
+return ENVELOPE;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 95 "sieve-lex.l"
+return HEADER;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 96 "sieve-lex.l"
+return BODY;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 97 "sieve-lex.l"
+return NOT;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 98 "sieve-lex.l"
+return SIZE;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 99 "sieve-lex.l"
+return REJCT;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 100 "sieve-lex.l"
+return FILEINTO;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 101 "sieve-lex.l"
+return REDIRECT;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 102 "sieve-lex.l"
+return KEEP;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 103 "sieve-lex.l"
+return REQUIRE;
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 104 "sieve-lex.l"
+return STOP;
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 105 "sieve-lex.l"
+return DISCARD;
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 106 "sieve-lex.l"
+return SETFLAG;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 107 "sieve-lex.l"
+return ADDFLAG;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 108 "sieve-lex.l"
+return REMOVEFLAG;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 109 "sieve-lex.l"
+return MARK;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 110 "sieve-lex.l"
+return UNMARK;
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 111 "sieve-lex.l"
+return NOTIFY;
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 112 "sieve-lex.l"
+return DENOTIFY;
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 113 "sieve-lex.l"
+return ID;
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 114 "sieve-lex.l"
+return METHOD;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 115 "sieve-lex.l"
+return OPTIONS;
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 116 "sieve-lex.l"
+return LOW;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 117 "sieve-lex.l"
+return NORMAL;
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 118 "sieve-lex.l"
+return HIGH;
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 119 "sieve-lex.l"
+return MESSAGE;
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 120 "sieve-lex.l"
+return VACATION;
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 121 "sieve-lex.l"
+return DAYS;
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 122 "sieve-lex.l"
+return ADDRESSES;
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 123 "sieve-lex.l"
+return SUBJECT;
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 124 "sieve-lex.l"
+return FROM;
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 125 "sieve-lex.l"
+return HANDLE;
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 126 "sieve-lex.l"
+return MIME;
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 127 "sieve-lex.l"
+return COMPARATOR;
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 128 "sieve-lex.l"
+return IS;
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 129 "sieve-lex.l"
+return CONTAINS;
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 130 "sieve-lex.l"
+return MATCHES;
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 131 "sieve-lex.l"
+return REGEX;
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 132 "sieve-lex.l"
+return COUNT;
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 133 "sieve-lex.l"
+return VALUE;
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 134 "sieve-lex.l"
+return OVER;
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 135 "sieve-lex.l"
+return UNDER;
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 136 "sieve-lex.l"
+return ALL;
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 137 "sieve-lex.l"
+return LOCALPART;
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 138 "sieve-lex.l"
+return DOMAIN;
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 139 "sieve-lex.l"
+return USER;
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 140 "sieve-lex.l"
+return DETAIL;
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 141 "sieve-lex.l"
+return RAW;
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+#line 142 "sieve-lex.l"
+return TEXT;
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 143 "sieve-lex.l"
+return CONTENT;
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 144 "sieve-lex.l"
+return INCLUDE;
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 145 "sieve-lex.l"
+return PERSONAL;
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 146 "sieve-lex.l"
+return GLOBAL;
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 147 "sieve-lex.l"
+return RETURN;
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 148 "sieve-lex.l"
+return COPY;
+	YY_BREAK
+case 74:
+/* rule 74 can match eol */
+YY_RULE_SETUP
+#line 149 "sieve-lex.l"
+;	/* ignore whitespace */
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+#line 150 "sieve-lex.l"
+;		/* ignore hash comments */
+	YY_BREAK
+case 76:
+/* rule 76 can match eol */
+YY_RULE_SETUP
+#line 151 "sieve-lex.l"
+;	/* ignore bracket comments */
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 152 "sieve-lex.l"
+return yytext[0];
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+#line 154 "sieve-lex.l"
+ECHO;
+	YY_BREAK
+#line 1404 "<stdout>"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(QSTRING):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 359 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 359 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 358);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )
+		   
+    yylineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch yylineno unless the option is enabled. */
+    yylineno =  1;
+    
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 154 "sieve-lex.l"
+
+
+/*  */
+static int tonum(char *c)
+{
+  int val = atoi(c);
+  switch (c[strlen(c)-1]) {
+  case 'K': case 'k': val *= (1 << 10); break;
+  case 'M': case 'm': val *= (1 << 20); break;
+  case 'G': case 'g': val *= (1 << 30); break;
+  default: break;
+  }
+  return val;
+}
+
+/* convert NULL strings to "" */
+static char *chkstr(char *str)
+{
+    if (!str) return xstrdup("");
+    else return str;
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve-lex.l dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve-lex.l
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve-lex.l	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve-lex.l	2007-07-19 20:31:28.000000000 -0600
@@ -0,0 +1,173 @@
+%{
+/* sieve.l -- sieve lexer
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h> /* for strdup */
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+#define yylval sievelval
+#define yylex sievelex
+#define yyerror sieveerror
+
+static int tonum(char *c);
+static char *chkstr(char *);
+static char *mlbuf;
+static int mlbufsz, mlcur;
+extern int yyerror(char *);
+%}
+
+%option yylineno
+%option noyywrap
+%option nounput
+
+ws		[ \t]+
+ident		[a-zA-Z_][a-zA-Z_0-9]*
+CRLF		(\r\n|\r|\n)
+
+%state MULTILINE
+%state QSTRING
+
+%%
+<MULTILINE>^\.{CRLF}	{ BEGIN INITIAL; 
+                          if (mlbuf) mlbuf[mlcur] = '\0';
+                          yylval.sval = chkstr(mlbuf); return STRING; }
+<MULTILINE>^\.\.  { /* dot stuffing! we want one . */ yyless(1); }
+<MULTILINE>(.|\n) { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+<MULTILINE><<EOF>> { yyerror("unexpected end of file in string"); 
+		     yyterminate(); }
+<QSTRING>\"        { BEGIN INITIAL;
+                     if (mlbuf) mlbuf[mlcur] = '\0';
+		     yylval.sval = chkstr(mlbuf); return STRING; }
+<QSTRING>\\.      { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[1]; }
+<QSTRING>(.|\n)   { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+<INITIAL>text:{ws}?(#.*)?{CRLF}	{ BEGIN MULTILINE;
+			  mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+<INITIAL>\"        { BEGIN QSTRING;
+                    mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+<INITIAL>[0-9]+[KMGkmg]?	{ yylval.nval = tonum(yytext); return NUMBER; }
+<INITIAL>if		return IF;
+<INITIAL>elsif		return ELSIF;
+<INITIAL>else		return ELSE;
+<INITIAL>anyof		return ANYOF;
+<INITIAL>allof		return ALLOF;
+<INITIAL>exists		return EXISTS;
+<INITIAL>false		return SFALSE;
+<INITIAL>true		return STRUE;
+<INITIAL>address	return ADDRESS;
+<INITIAL>envelope	return ENVELOPE;
+<INITIAL>header		return HEADER;
+<INITIAL>body		return BODY;
+<INITIAL>not		return NOT;
+<INITIAL>size		return SIZE;
+<INITIAL>reject		return REJCT;
+<INITIAL>fileinto	return FILEINTO;
+<INITIAL>redirect	return REDIRECT;
+<INITIAL>keep		return KEEP;
+<INITIAL>require	return REQUIRE;
+<INITIAL>stop		return STOP;
+<INITIAL>discard	return DISCARD;
+<INITIAL>setflag	return SETFLAG;
+<INITIAL>addflag	return ADDFLAG;
+<INITIAL>removeflag	return REMOVEFLAG;
+<INITIAL>mark		return MARK;
+<INITIAL>unmark		return UNMARK;
+<INITIAL>notify		return NOTIFY;
+<INITIAL>denotify	return DENOTIFY;
+<INITIAL>:id		return ID;
+<INITIAL>:method	return METHOD;
+<INITIAL>:options	return OPTIONS;
+<INITIAL>:low		return LOW;
+<INITIAL>:normal	return NORMAL;
+<INITIAL>:high		return HIGH;
+<INITIAL>:message	return MESSAGE;
+<INITIAL>vacation	return VACATION;
+<INITIAL>:days		return DAYS;
+<INITIAL>:addresses	return ADDRESSES;
+<INITIAL>:subject	return SUBJECT;
+<INITIAL>:from		return FROM;
+<INITIAL>:handle	return HANDLE;
+<INITIAL>:mime		return MIME;
+<INITIAL>:comparator	return COMPARATOR;
+<INITIAL>:is		return IS;
+<INITIAL>:contains	return CONTAINS;
+<INITIAL>:matches	return MATCHES;
+<INITIAL>:regex		return REGEX;
+<INITIAL>:count		return COUNT;
+<INITIAL>:value		return VALUE;
+<INITIAL>:over		return OVER;
+<INITIAL>:under		return UNDER;
+<INITIAL>:all		return ALL;
+<INITIAL>:localpart	return LOCALPART;
+<INITIAL>:domain	return DOMAIN;
+<INITIAL>:user		return USER;
+<INITIAL>:detail	return DETAIL;
+<INITIAL>:raw		return RAW;
+<INITIAL>:text		return TEXT;
+<INITIAL>:content	return CONTENT;
+<INITIAL>include	return INCLUDE;
+<INITIAL>:personal	return PERSONAL;
+<INITIAL>:global	return GLOBAL;
+<INITIAL>return		return RETURN;
+<INITIAL>:copy		return COPY;
+<INITIAL>[ \t\n\r] ;	/* ignore whitespace */
+<INITIAL>#.* ;		/* ignore hash comments */
+<INITIAL>"/*"([^\*]|\*[^\/])*\*?"*/" ;	/* ignore bracket comments */
+.			return yytext[0];
+
+%%
+/*  */
+static int tonum(char *c)
+{
+  int val = atoi(c);
+  switch (c[strlen(c)-1]) {
+  case 'K': case 'k': val *= (1 << 10); break;
+  case 'M': case 'm': val *= (1 << 20); break;
+  case 'G': case 'g': val *= (1 << 30); break;
+  default: break;
+  }
+  return val;
+}
+
+/* convert NULL strings to "" */
+static char *chkstr(char *str)
+{
+    if (!str) return xstrdup("");
+    else return str;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve.y dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve.y
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/sieve.y	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/sieve.y	2007-08-09 06:44:00.000000000 -0600
@@ -0,0 +1,1300 @@
+%{
+/* sieve.y -- sieve parser
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include "xmalloc.h"
+#include "comparator.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+
+#include "imparse.h"
+#include "libconfig.h"
+
+    /* definitions */
+    extern int addrparse(void);
+
+struct vtags {
+    int days;
+    stringlist_t *addresses;
+    char *subject;
+    char *from;
+    char *handle;
+    int mime;
+};
+
+struct htags {
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct aetags {
+    int addrtag;
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct btags {
+    int transform;
+    int offset;
+    stringlist_t *content_types;
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct ntags {
+    char *method;
+    char *id;
+    stringlist_t *options;
+    int priority;
+    char *message;
+};
+
+struct dtags {
+    int comptag;
+    int relation;
+    void *pattern;
+    int priority;
+};
+
+static commandlist_t *ret;
+static sieve_script_t *parse_script;
+static int check_reqs(stringlist_t *sl);
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl);
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl);
+static test_t *build_body(int t, struct btags *b, stringlist_t *pl);
+static commandlist_t *build_vacation(int t, struct vtags *h, char *s);
+static commandlist_t *build_notify(int t, struct ntags *n);
+static commandlist_t *build_denotify(int t, struct dtags *n);
+static commandlist_t *build_fileinto(int t, int c, char *f);
+static commandlist_t *build_redirect(int t, int c, char *a);
+static struct aetags *new_aetags(void);
+static struct aetags *canon_aetags(struct aetags *ae);
+static void free_aetags(struct aetags *ae);
+static struct htags *new_htags(void);
+static struct htags *canon_htags(struct htags *h);
+static void free_htags(struct htags *h);
+static struct btags *new_btags(void);
+static struct btags *canon_btags(struct btags *b);
+static void free_btags(struct btags *b);
+static struct vtags *new_vtags(void);
+static struct vtags *canon_vtags(struct vtags *v);
+static void free_vtags(struct vtags *v);
+static struct ntags *new_ntags(void);
+static struct ntags *canon_ntags(struct ntags *n);
+static void free_ntags(struct ntags *n);
+static struct dtags *new_dtags(void);
+static struct dtags *canon_dtags(struct dtags *d);
+static void free_dtags(struct dtags *d);
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *));
+static int verify_mailbox(char *s);
+static int verify_address(char *s);
+static int verify_header(char *s);
+static int verify_addrheader(char *s);
+static int verify_envelope(char *s);
+static int verify_flag(char *s);
+static int verify_relat(char *s);
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags);
+static int verify_regexs(stringlist_t *sl, char *comp);
+#endif
+static int verify_utf8(char *s);
+
+int yyerror(char *msg);
+extern int yylex(void);
+extern void yyrestart(FILE *f);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+%}
+
+%union {
+    int nval;
+    char *sval;
+    stringlist_t *sl;
+    test_t *test;
+    testlist_t *testl;
+    commandlist_t *cl;
+    struct vtags *vtag;
+    struct aetags *aetag;
+    struct htags *htag;
+    struct btags *btag;
+    struct ntags *ntag;
+    struct dtags *dtag;
+}
+
+%token <nval> NUMBER
+%token <sval> STRING
+%token IF ELSIF ELSE
+%token REJCT FILEINTO REDIRECT KEEP STOP DISCARD VACATION REQUIRE
+%token SETFLAG ADDFLAG REMOVEFLAG MARK UNMARK
+%token NOTIFY DENOTIFY
+%token ANYOF ALLOF EXISTS SFALSE STRUE HEADER NOT SIZE ADDRESS ENVELOPE BODY
+%token COMPARATOR IS CONTAINS MATCHES REGEX COUNT VALUE OVER UNDER
+%token GT GE LT LE EQ NE
+%token ALL LOCALPART DOMAIN USER DETAIL
+%token RAW TEXT CONTENT
+%token DAYS ADDRESSES SUBJECT FROM HANDLE MIME
+%token METHOD ID OPTIONS LOW NORMAL HIGH ANY MESSAGE
+%token INCLUDE PERSONAL GLOBAL RETURN
+%token COPY
+
+%type <cl> commands command action elsif block
+%type <sl> stringlist strings
+%type <test> test
+%type <nval> comptag relcomp sizetag addrparttag addrorenv location copy
+%type <testl> testlist tests
+%type <htag> htags
+%type <aetag> aetags
+%type <btag> btags
+%type <vtag> vtags
+%type <ntag> ntags
+%type <dtag> dtags
+%type <nval> priority
+
+%%
+
+start: reqs			{ ret = NULL; }
+	| reqs commands		{ ret = $2; }
+	;
+
+reqs: /* empty */
+	| require reqs
+	;
+
+require: REQUIRE stringlist ';'	{ if (!check_reqs($2)) {
+                                    yyerror("Unsupported features in require line");
+				    YYERROR; 
+                                  } }
+	;
+
+commands: command		{ $$ = $1; }
+	| command commands	{ $1->next = $2; $$ = $1; }
+	;
+
+command: action ';'		{ $$ = $1; }
+	| IF test block elsif   { $$ = new_if($2, $3, $4); }
+	| error ';'		{ $$ = new_command(STOP); }
+	;
+
+elsif: /* empty */               { $$ = NULL; }
+	| ELSIF test block elsif { $$ = new_if($2, $3, $4); }
+	| ELSE block             { $$ = $2; }
+	;
+
+action: REJCT STRING             { if (!parse_script->support.reject) {
+				     yyerror("reject require missing");
+				     YYERROR;
+				   }
+				   if (!verify_utf8($2)) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+				   $$ = new_command(REJCT);
+				   $$->u.str = $2; }
+	| FILEINTO copy STRING	 { if (!parse_script->support.fileinto) {
+				     yyerror("fileinto require missing");
+	                             YYERROR;
+                                   }
+				   if (!verify_mailbox($3)) {
+				     YYERROR; /* vm should call yyerror() */
+				   }
+	                           $$ = build_fileinto(FILEINTO, $2, $3); }
+	| REDIRECT copy STRING   { if (!verify_address($3)) {
+				     YYERROR; /* va should call yyerror() */
+				   }
+	                           $$ = build_redirect(REDIRECT, $2, $3); }
+	| KEEP			 { $$ = new_command(KEEP); }
+	| STOP			 { $$ = new_command(STOP); }
+	| DISCARD		 { $$ = new_command(DISCARD); }
+	| VACATION vtags STRING  { if (!parse_script->support.vacation) {
+				     yyerror("vacation require missing");
+				     YYERROR;
+				   }
+				   if (($2->mime == -1) && !verify_utf8($3)) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+  				   $$ = build_vacation(VACATION,
+					    canon_vtags($2), $3); }
+        | SETFLAG stringlist     { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                   }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(SETFLAG);
+                                  $$->u.sl = $2; }
+         | ADDFLAG stringlist     { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(ADDFLAG);
+                                  $$->u.sl = $2; }
+         | REMOVEFLAG stringlist  { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(REMOVEFLAG);
+                                  $$->u.sl = $2; }
+         | MARK                   { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  $$ = new_command(MARK); }
+         | UNMARK                 { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  $$ = new_command(UNMARK); }
+
+         | NOTIFY ntags           { if (!parse_script->support.notify) {
+				       yyerror("notify require missing");
+				       $$ = new_command(NOTIFY); 
+				       YYERROR;
+	 			    } else {
+				      $$ = build_notify(NOTIFY,
+				             canon_ntags($2));
+				    } }
+         | DENOTIFY dtags         { if (!parse_script->support.notify) {
+                                       yyerror("notify require missing");
+				       $$ = new_command(DENOTIFY);
+				       YYERROR;
+				    } else {
+					$$ = build_denotify(DENOTIFY, canon_dtags($2));
+					if ($$ == NULL) { 
+			yyerror("unable to find a compatible comparator");
+			YYERROR; } } }
+
+	 | INCLUDE location STRING { if (!parse_script->support.include) {
+				     yyerror("include require missing");
+	                             YYERROR;
+                                   }
+	                           $$ = new_command(INCLUDE);
+				   $$->u.inc.location = $2;
+				   $$->u.inc.script = $3; }
+         | RETURN		 { if (!parse_script->support.include) {
+                                    yyerror("include require missing");
+                                    YYERROR;
+                                  }
+                                   $$ = new_command(RETURN); }
+	;
+
+location: /* empty */		 { $$ = PERSONAL; }
+	| PERSONAL		 { $$ = PERSONAL; }
+	| GLOBAL		 { $$ = GLOBAL; }
+	;
+
+ntags: /* empty */		 { $$ = new_ntags(); }
+	| ntags ID STRING	 { if ($$->id != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { $$->id = $3; } }
+	| ntags METHOD STRING	 { if ($$->method != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { $$->method = $3; } }
+	| ntags OPTIONS stringlist { if ($$->options != NULL) { 
+					yyerror("duplicate :options"); YYERROR; }
+				     else { $$->options = $3; } }
+        | ntags priority	 { if ($$->priority != -1) { 
+                                 yyerror("duplicate :priority"); YYERROR; }
+                                   else { $$->priority = $2; } }
+	| ntags MESSAGE STRING	 { if ($$->message != NULL) { 
+					yyerror("duplicate :message"); YYERROR; }
+				   else { $$->message = $3; } }
+	;
+
+dtags: /* empty */		 { $$ = new_dtags(); }
+	| dtags priority	 { if ($$->priority != -1) { 
+				yyerror("duplicate priority level"); YYERROR; }
+				   else { $$->priority = $2; } }
+	| dtags comptag STRING 	 { if ($$->comptag != -1)
+	                             { 
+					 yyerror("duplicate comparator type tag"); YYERROR;
+				     }
+	                           $$->comptag = $2;
+#ifdef ENABLE_REGEX
+				   if ($$->comptag == REGEX)
+				   {
+				       int cflags = REG_EXTENDED |
+					   REG_NOSUB | REG_ICASE;
+				       if (!verify_regex($3, cflags)) { YYERROR; }
+				   }
+#endif
+				   $$->pattern = $3;
+	                          }
+	| dtags relcomp STRING  { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	;
+
+priority: LOW                   { $$ = LOW; }
+        | NORMAL                { $$ = NORMAL; }
+        | HIGH                  { $$ = HIGH; }
+        ;
+
+vtags: /* empty */		 { $$ = new_vtags(); }
+	| vtags DAYS NUMBER	 { if ($$->days != -1) { 
+					yyerror("duplicate :days"); YYERROR; }
+				   else { $$->days = $3; } }
+	| vtags ADDRESSES stringlist { if ($$->addresses != NULL) { 
+					yyerror("duplicate :addresses"); 
+					YYERROR;
+				       } else if (!verify_stringlist($3,
+							verify_address)) {
+					  YYERROR;
+				       } else {
+					 $$->addresses = $3; } }
+	| vtags SUBJECT STRING	 { if ($$->subject != NULL) { 
+					yyerror("duplicate :subject"); 
+					YYERROR;
+				   } else if (!verify_utf8($3)) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { $$->subject = $3; } }
+	| vtags FROM STRING	 { if ($$->from != NULL) { 
+					yyerror("duplicate :from"); 
+					YYERROR;
+				   } else if (!verify_address($3)) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { $$->from = $3; } }
+	| vtags HANDLE STRING	 { if ($$->handle != NULL) { 
+					yyerror("duplicate :handle"); 
+					YYERROR;
+				   } else if (!verify_utf8($3)) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { $$->handle = $3; } }
+	| vtags MIME		 { if ($$->mime != -1) { 
+					yyerror("duplicate :mime"); 
+					YYERROR; }
+				   else { $$->mime = MIME; } }
+	;
+
+stringlist: '[' strings ']'      { $$ = $2; }
+	| STRING		 { $$ = new_sl($1, NULL); }
+	;
+
+strings: STRING			 { $$ = new_sl($1, NULL); }
+	| STRING ',' strings	 { $$ = new_sl($1, $3); }
+	;
+
+block: '{' commands '}'		 { $$ = $2; }
+	| '{' '}'		 { $$ = NULL; }
+	;
+
+test:     ANYOF testlist	 { $$ = new_test(ANYOF); $$->u.tl = $2; }
+        | ALLOF testlist	 { $$ = new_test(ALLOF); $$->u.tl = $2; }
+        | EXISTS stringlist      { $$ = new_test(EXISTS); $$->u.sl = $2; }
+        | SFALSE		 { $$ = new_test(SFALSE); }
+	| STRUE			 { $$ = new_test(STRUE); }
+	| HEADER htags stringlist stringlist
+				 {
+				     if (!verify_stringlist($3, verify_header)) {
+					 YYERROR; /* vh should call yyerror() */
+				     }
+				     if (!verify_stringlist($4, verify_utf8)) {
+					 YYERROR; /* vu should call yyerror() */
+				     }
+				     
+				     $2 = canon_htags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!(verify_regexs($4, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_header(HEADER, $2, $3, $4);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+
+        | addrorenv aetags stringlist stringlist
+				 { 
+				     if (($1 == ADDRESS) &&
+					 !verify_stringlist($3, verify_addrheader))
+					 { YYERROR; }
+				     else if (($1 == ENVELOPE) &&
+					      !verify_stringlist($3, verify_envelope))
+					 { YYERROR; }
+				     $2 = canon_aetags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!( verify_regexs($4, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_address($1, $2, $3, $4);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+	| BODY btags stringlist
+				 {
+				     if (!parse_script->support.body) {
+                                       yyerror("body require missing");
+				       YYERROR;
+				     }
+					
+				     if (!verify_stringlist($3, verify_utf8)) {
+					 YYERROR; /* vu should call yyerror() */
+				     }
+				     
+				     $2 = canon_btags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!(verify_regexs($3, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_body(BODY, $2, $3);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+
+	| NOT test		 { $$ = new_test(NOT); $$->u.t = $2; }
+	| SIZE sizetag NUMBER    { $$ = new_test(SIZE); $$->u.sz.t = $2;
+		                   $$->u.sz.n = $3; }
+	| error			 { $$ = NULL; }
+	;
+
+addrorenv: ADDRESS		 { $$ = ADDRESS; }
+	| ENVELOPE		 {if (!parse_script->support.envelope)
+	                              {yyerror("envelope require missing"); YYERROR;}
+	                          else{$$ = ENVELOPE; }
+	                         }
+
+	;
+
+aetags: /* empty */              { $$ = new_aetags(); }
+        | aetags addrparttag	 { $$ = $1;
+				   if ($$->addrtag != -1) { 
+			yyerror("duplicate or conflicting address part tag");
+			YYERROR; }
+				   else { $$->addrtag = $2; } }
+	| aetags comptag         { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| aetags relcomp STRING{ $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+        | aetags COMPARATOR STRING { $$ = $1;
+	if ($$->comparator != NULL) { 
+			yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) {
+			yyerror("comparator-i;ascii-numeric require missing");
+			YYERROR; }
+				   else { $$->comparator = $3; } }
+	;
+
+htags: /* empty */		 { $$ = new_htags(); }
+	| htags comptag		 { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| htags relcomp STRING { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	| htags COMPARATOR STRING { $$ = $1;
+				   if ($$->comparator != NULL) { 
+			 yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) { 
+			 yyerror("comparator-i;ascii-numeric require missing");  YYERROR; }
+				   else { 
+				     $$->comparator = $3; } }
+        ;
+
+btags: /* empty */		 { $$ = new_btags(); }
+        | btags RAW	 	 { $$ = $1;
+				   if ($$->transform != -1) {
+			yyerror("duplicate or conflicting transform tag");
+			YYERROR; }
+				   else { $$->transform = RAW; } }
+        | btags TEXT	 	 { $$ = $1;
+				   if ($$->transform != -1) {
+			yyerror("duplicate or conflicting transform tag");
+			YYERROR; }
+				   else { $$->transform = TEXT; } }
+        | btags CONTENT stringlist { $$ = $1;
+				   if ($$->transform != -1) {
+			yyerror("duplicate or conflicting transform tag");
+			YYERROR; }
+				   else {
+				       $$->transform = CONTENT;
+				       $$->content_types = $3;
+				   } }
+	| btags comptag		 { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| btags relcomp STRING { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	| btags COMPARATOR STRING { $$ = $1;
+				   if ($$->comparator != NULL) { 
+			 yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) { 
+			 yyerror("comparator-i;ascii-numeric require missing");  YYERROR; }
+				   else { 
+				     $$->comparator = $3; } }
+        ;
+
+
+addrparttag: ALL                 { $$ = ALL; }
+	| LOCALPART		 { $$ = LOCALPART; }
+	| DOMAIN                 { $$ = DOMAIN; }
+	| USER                   { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   $$ = USER; }  
+	| DETAIL                { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   $$ = DETAIL; }
+	;
+comptag: IS			 { $$ = IS; }
+	| CONTAINS		 { $$ = CONTAINS; }
+	| MATCHES		 { $$ = MATCHES; }
+	| REGEX			 { if (!parse_script->support.regex) {
+				     yyerror("regex require missing");
+				     YYERROR;
+				   }
+				   $$ = REGEX; }
+	;
+
+relcomp: COUNT			 { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   $$ = COUNT; }
+	| VALUE			 { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   $$ = VALUE; }
+	;
+
+
+sizetag: OVER			 { $$ = OVER; }
+	| UNDER			 { $$ = UNDER; }
+	;
+
+copy: /* empty */		 { $$ = 0; }
+	| COPY			 { if (!parse_script->support.copy) {
+				     yyerror("copy require missing");
+	                             YYERROR;
+                                   }
+				   $$ = COPY; }
+	;
+
+testlist: '(' tests ')'		 { $$ = $2; }
+	;
+
+tests: test                      { $$ = new_testlist($1, NULL); }
+	| test ',' tests         { $$ = new_testlist($1, $3); }
+	;
+
+%%
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f)
+{
+    commandlist_t *t;
+
+    parse_script = script;
+    yyrestart(f);
+    if (yyparse()) {
+	t = NULL;
+    } else {
+	t = ret;
+    }
+    ret = NULL;
+    return t;
+}
+
+int yyerror(char *msg)
+{
+    extern int yylineno;
+    int ret;
+
+    parse_script->err++;
+    if (parse_script->interp.err) {
+	ret = parse_script->interp.err(yylineno, msg, 
+				       parse_script->interp.interp_context,
+				       parse_script->script_context);
+    }
+
+    return 0;
+}
+
+static int check_reqs(stringlist_t *sl)
+{
+    int i = 1;
+    stringlist_t *s;
+    
+    while (sl != NULL) {
+	s = sl;
+	sl = sl->next;
+
+	i &= script_require(parse_script, s->s);
+
+	if (s->s) free(s->s);
+	free(s);
+    }
+    return i;
+}
+
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be either ADDRESS or ENVELOPE */
+
+    assert((t == ADDRESS) || (t == ENVELOPE));
+
+    if (ret) {
+	ret->u.ae.comptag = ae->comptag;
+	ret->u.ae.relation=ae->relation;
+	ret->u.ae.comparator=xstrdup(ae->comparator);
+	ret->u.ae.sl = sl;
+	ret->u.ae.pl = pl;
+	ret->u.ae.addrpart = ae->addrtag;
+	free_aetags(ae);
+
+    }
+    return ret;
+}
+
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be HEADER */
+
+    assert(t == HEADER);
+
+    if (ret) {
+	ret->u.h.comptag = h->comptag;
+	ret->u.h.relation=h->relation;
+	ret->u.h.comparator=xstrdup(h->comparator);
+	ret->u.h.sl = sl;
+	ret->u.h.pl = pl;
+	free_htags(h);
+    }
+    return ret;
+}
+
+static test_t *build_body(int t, struct btags *b, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be BODY */
+
+    assert(t == BODY);
+
+    if (ret) {
+	ret->u.b.comptag = b->comptag;
+	ret->u.b.relation = b->relation;
+	ret->u.b.comparator = xstrdup(b->comparator);
+	ret->u.b.transform = b->transform;
+	ret->u.b.offset = b->offset;
+	ret->u.b.content_types = b->content_types; b->content_types = NULL;
+	ret->u.b.pl = pl;
+	free_btags(b);
+    }
+    return ret;
+}
+
+static commandlist_t *build_vacation(int t, struct vtags *v, char *reason)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == VACATION);
+
+    if (ret) {
+	ret->u.v.subject = v->subject; v->subject = NULL;
+	ret->u.v.from = v->from; v->from = NULL;
+	ret->u.v.handle = v->handle; v->handle = NULL;
+	ret->u.v.days = v->days;
+	ret->u.v.mime = v->mime;
+	ret->u.v.addresses = v->addresses; v->addresses = NULL;
+	free_vtags(v);
+	ret->u.v.message = reason;
+    }
+    return ret;
+}
+
+static commandlist_t *build_notify(int t, struct ntags *n)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == NOTIFY);
+       if (ret) {
+	ret->u.n.method = n->method; n->method = NULL;
+	ret->u.n.id = n->id; n->id = NULL;
+	ret->u.n.options = n->options; n->options = NULL;
+	ret->u.n.priority = n->priority;
+	ret->u.n.message = n->message; n->message = NULL;
+	free_ntags(n);
+    }
+    return ret;
+}
+
+static commandlist_t *build_denotify(int t, struct dtags *d)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == DENOTIFY);
+
+    if (ret) {
+	ret->u.d.comptag = d->comptag;
+	ret->u.d.relation=d->relation;
+	ret->u.d.pattern = d->pattern; d->pattern = NULL;
+	ret->u.d.priority = d->priority;
+	free_dtags(d);
+    }
+    return ret;
+}
+
+static commandlist_t *build_fileinto(int t, int copy, char *folder)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == FILEINTO);
+
+    if (ret) {
+	ret->u.f.copy = copy;
+	ret->u.f.folder = folder;
+    }
+    return ret;
+}
+
+static commandlist_t *build_redirect(int t, int copy, char *address)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == REDIRECT);
+
+    if (ret) {
+	ret->u.r.copy = copy;
+	ret->u.r.address = address;
+    }
+    return ret;
+}
+
+static struct aetags *new_aetags(void)
+{
+    struct aetags *r = (struct aetags *) xmalloc(sizeof(struct aetags));
+
+    r->addrtag = r->comptag = r->relation=-1;
+    r->comparator=NULL;
+
+    return r;
+}
+
+static struct aetags *canon_aetags(struct aetags *ae)
+{
+    if (ae->addrtag == -1) { ae->addrtag = ALL; }
+    if (ae->comparator == NULL) {
+        ae->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (ae->comptag == -1) { ae->comptag = IS; }
+    return ae;
+}
+
+static void free_aetags(struct aetags *ae)
+{
+    free(ae->comparator);
+     free(ae);
+}
+
+static struct htags *new_htags(void)
+{
+    struct htags *r = (struct htags *) xmalloc(sizeof(struct htags));
+
+    r->comptag = r->relation= -1;
+    
+    r->comparator = NULL;
+
+    return r;
+}
+
+static struct htags *canon_htags(struct htags *h)
+{
+    if (h->comparator == NULL) {
+	h->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (h->comptag == -1) { h->comptag = IS; }
+    return h;
+}
+
+static void free_htags(struct htags *h)
+{
+    free(h->comparator);
+    free(h);
+}
+
+static struct btags *new_btags(void)
+{
+    struct btags *r = (struct btags *) xmalloc(sizeof(struct btags));
+
+    r->transform = r->offset = r->comptag = r->relation = -1;
+    r->content_types = NULL;
+    r->comparator = NULL;
+
+    return r;
+}
+
+static struct btags *canon_btags(struct btags *b)
+{
+    if (b->transform == -1) { b->transform = TEXT; }
+    if (b->content_types == NULL) {
+	if (b->transform == RAW) {
+	    b->content_types = new_sl(xstrdup(""), NULL);
+	} else {
+	    b->content_types = new_sl(xstrdup("text"), NULL);
+	}
+    }
+    if (b->offset == -1) { b->offset = 0; }
+    if (b->comparator == NULL) { b->comparator = xstrdup("i;ascii-casemap"); }
+    if (b->comptag == -1) { b->comptag = IS; }
+    return b;
+}
+
+static void free_btags(struct btags *b)
+{
+    if (b->content_types) { free_sl(b->content_types); }
+    free(b->comparator);
+    free(b);
+}
+
+static struct vtags *new_vtags(void)
+{
+    struct vtags *r = (struct vtags *) xmalloc(sizeof(struct vtags));
+
+    r->days = -1;
+    r->addresses = NULL;
+    r->subject = NULL;
+    r->from = NULL;
+    r->handle = NULL;
+    r->mime = -1;
+
+    return r;
+}
+
+static struct vtags *canon_vtags(struct vtags *v)
+{
+    assert(parse_script->interp.vacation != NULL);
+
+    if (v->days == -1) { v->days = 7; }
+    if (v->days < parse_script->interp.vacation->min_response) 
+       { v->days = parse_script->interp.vacation->min_response; }
+    if (v->days > parse_script->interp.vacation->max_response)
+       { v->days = parse_script->interp.vacation->max_response; }
+    if (v->mime == -1) { v->mime = 0; }
+
+    return v;
+}
+
+static void free_vtags(struct vtags *v)
+{
+    if (v->addresses) { free_sl(v->addresses); }
+    if (v->subject) { free(v->subject); }
+    if (v->from) { free(v->from); }
+    if (v->handle) { free(v->handle); }
+    free(v);
+}
+
+static struct ntags *new_ntags(void)
+{
+    struct ntags *r = (struct ntags *) xmalloc(sizeof(struct ntags));
+
+    r->method = NULL;
+    r->id = NULL;
+    r->options = NULL;
+    r->priority = -1;
+    r->message = NULL;
+
+    return r;
+}
+
+static struct ntags *canon_ntags(struct ntags *n)
+{
+    if (n->priority == -1) { n->priority = NORMAL; }
+    if (n->message == NULL) { n->message = xstrdup("$from$: $subject$"); }
+    if (n->method == NULL) { n->method = xstrdup("default"); }
+    return n;
+}
+static struct dtags *canon_dtags(struct dtags *d)
+{
+    if (d->priority == -1) { d->priority = ANY; }
+    if (d->comptag == -1) { d->comptag = ANY; }
+       return d;
+}
+
+static void free_ntags(struct ntags *n)
+{
+    if (n->method) { free(n->method); }
+    if (n->id) { free(n->id); }
+    if (n->options) { free_sl(n->options); }
+    if (n->message) { free(n->message); }
+    free(n);
+}
+
+static struct dtags *new_dtags(void)
+{
+    struct dtags *r = (struct dtags *) xmalloc(sizeof(struct dtags));
+
+    r->comptag = r->priority= r->relation = -1;
+    r->pattern  = NULL;
+
+    return r;
+}
+
+static void free_dtags(struct dtags *d)
+{
+    if (d->pattern) free(d->pattern);
+    free(d);
+}
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *))
+{
+    for (; sl != NULL && verify(sl->s); sl = sl->next) ;
+    return (sl == NULL);
+}
+
+char *addrptr;		/* pointer to address string for address lexer */
+char addrerr[500];	/* buffer for address parser error messages */
+
+static int verify_address(char *s)
+{
+    char errbuf[500];
+
+    addrptr = s;
+    addrerr[0] = '\0';	/* paranoia */
+    if (addrparse()) {
+	snprintf(errbuf, sizeof(errbuf), "address '%s': %s", s, addrerr);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+
+static int verify_mailbox(char *s)
+{
+    if (!verify_utf8(s)) return 0;
+
+    /* xxx if not a mailbox, call yyerror */
+    return 1;
+}
+
+static int verify_header(char *hdr)
+{
+    char *h = hdr;
+    char errbuf[100];
+
+    while (*h) {
+	/* field-name      =       1*ftext
+	   ftext           =       %d33-57 / %d59-126         
+	   ; Any character except
+	   ;  controls, SP, and
+	   ;  ":". */
+	if (!((*h >= 33 && *h <= 57) || (*h >= 59 && *h <= 126))) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "header '%s': not a valid header", hdr);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	h++;
+    }
+    return 1;
+}
+ 
+static int verify_addrheader(char *hdr)
+{
+    const char **h, *hdrs[] = {
+	"from", "sender", "reply-to",	/* RFC2822 originator fields */
+	"to", "cc", "bcc",		/* RFC2822 destination fields */
+	"resent-from", "resent-sender",	/* RFC2822 resent fields */
+	"resent-to", "resent-cc", "resent-bcc",
+	"return-path",			/* RFC2822 trace fields */
+	"disposition-notification-to",	/* RFC2298 MDN request fields */
+	"delivered-to",			/* non-standard (loop detection) */
+	"approved",			/* RFC1036 moderator/control fields */
+	NULL
+    };
+    char errbuf[100];
+
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT))
+	return verify_header(hdr);
+
+    for (lcase(hdr), h = hdrs; *h; h++) {
+	if (!strcmp(*h, hdr)) return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "header '%s': not a valid header for an address test", hdr);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_envelope(char *env)
+{
+    char errbuf[100];
+
+    lcase(env);
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT) ||
+	!strcmp(env, "from") || !strcmp(env, "to") || !strcmp(env, "auth")) {
+	return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "env-part '%s': not a valid part for an envelope test", env);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_relat(char *r)
+{/* this really should have been a token to begin with.*/
+    char errbuf[100];
+	lcase(r);
+	if (!strcmp(r, "gt")) {return GT;}
+	else if (!strcmp(r, "ge")) {return GE;}
+	else if (!strcmp(r, "lt")) {return LT;}
+	else if (!strcmp(r, "le")) {return LE;}
+	else if (!strcmp(r, "ne")) {return NE;}
+	else if (!strcmp(r, "eq")) {return EQ;}
+	else{
+	  sprintf(errbuf, "flag '%s': not a valid relational operation", r);
+	  yyerror(errbuf);
+	  return -1;
+	}
+	
+}
+
+
+
+
+static int verify_flag(char *f)
+{
+    char errbuf[100];
+ 
+    if (f[0] == '\\') {
+	lcase(f);
+	if (strcmp(f, "\\seen") && strcmp(f, "\\answered") &&
+	    strcmp(f, "\\flagged") && strcmp(f, "\\draft") &&
+	    strcmp(f, "\\deleted")) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "flag '%s': not a system flag", f);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	return 1;
+    }
+    if (!imparse_isatom(f)) {
+	snprintf(errbuf, sizeof(errbuf), "flag '%s': not a valid keyword", f);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+ 
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags)
+{
+    int ret;
+    char errbuf[100];
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+
+     if ((ret = regcomp(reg, s, cflags)) != 0) {
+	(void) regerror(ret, reg, errbuf, sizeof(errbuf));
+	yyerror(errbuf);
+	free(reg);
+	return 0;
+	}
+    free(reg);
+    return 1;
+}
+
+static int verify_regexs(stringlist_t *sl, char *comp)
+{
+    stringlist_t *sl2;
+    int cflags = REG_EXTENDED | REG_NOSUB;
+ 
+
+    if (!strcmp(comp, "i;ascii-casemap")) {
+	cflags |= REG_ICASE;
+    }
+
+    for (sl2 = sl; sl2 != NULL; sl2 = sl2->next) {
+	if ((verify_regex(sl2->s, cflags)) == 0) {
+	    break;
+	}
+    }
+    if (sl2 == NULL) {
+	return 1;
+    }
+    return 0;
+}
+#endif
+
+/*
+ * Valid UTF-8 check (from RFC 2640 Annex B.1)
+ *
+ * The following routine checks if a byte sequence is valid UTF-8. This
+ * is done by checking for the proper tagging of the first and following
+ * bytes to make sure they conform to the UTF-8 format. It then checks
+ * to assure that the data part of the UTF-8 sequence conforms to the
+ * proper range allowed by the encoding. Note: This routine will not
+ * detect characters that have not been assigned and therefore do not
+ * exist.
+ */
+static int verify_utf8(char *s)
+{
+    const char *buf = s;
+    const char *endbuf = s + strlen(s);
+    unsigned char byte2mask = 0x00, c;
+    int trailing = 0;  /* trailing (continuation) bytes to follow */
+
+    while (buf != endbuf) {
+	c = *buf++;
+	if (trailing) {
+	    if ((c & 0xC0) == 0x80) {		/* Does trailing byte
+						   follow UTF-8 format? */
+		if (byte2mask) {		/* Need to check 2nd byte
+						   for proper range? */
+		    if (c & byte2mask)		/* Are appropriate bits set? */
+			byte2mask = 0x00;
+		    else
+			break;
+		}
+		trailing--;
+	    }
+	    else
+		break;
+	}
+	else {
+	    if ((c & 0x80) == 0x00)		/* valid 1 byte UTF-8 */
+		continue;
+	    else if ((c & 0xE0) == 0xC0)	/* valid 2 byte UTF-8 */
+		if (c & 0x1E) {			/* Is UTF-8 byte
+						   in proper range? */
+		    trailing = 1;
+		}
+		else
+		    break;
+	    else if ((c & 0xF0) == 0xE0) {	/* valid 3 byte UTF-8 */
+		if (!(c & 0x0F)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x20;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 2;
+	    }
+	    else if ((c & 0xF8) == 0xF0) {	/* valid 4 byte UTF-8 */
+		if (!(c & 0x07)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x30;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 3;
+	    }
+	    else if ((c & 0xFC) == 0xF8) {	/* valid 5 byte UTF-8 */
+		if (!(c & 0x03)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x38;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 4;
+	    }
+	    else if ((c & 0xFE) == 0xFC) {	/* valid 6 byte UTF-8 */
+		if (!(c & 0x01)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x3C;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 5;
+	    }
+	    else
+		break;
+	}
+    }
+
+    if ((buf != endbuf) || trailing) {
+	char errbuf[100];
+
+	snprintf(errbuf, sizeof(errbuf),
+		 "string '%s': not valid utf8", s);
+	yyerror(errbuf);
+	return 0;
+    }
+
+    return 1;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/tree.c dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/tree.c
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/tree.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/tree.c	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,240 @@
+/* tree.c -- abstract syntax tree handling
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+stringlist_t *new_sl(char *s, stringlist_t *n)
+{
+    stringlist_t *p = (stringlist_t *) xmalloc(sizeof(stringlist_t));
+    p->s = s;
+    p->next = n;
+    return p;
+}
+
+
+tag_t *new_tag(int type, char *s)
+{
+    tag_t *p = (tag_t *) xmalloc(sizeof(tag_t));
+    p->type = type;
+    p->arg = s;
+    return p;
+}
+
+taglist_t *new_taglist(tag_t *t, taglist_t *n)
+{
+    taglist_t *p = (taglist_t *) xmalloc(sizeof(taglist_t));
+    p->t = t;
+    p->next = n;
+    return p;
+}
+
+test_t *new_test(int type) 
+{
+    test_t *p = (test_t *) xmalloc(sizeof(test_t));
+    p->type = type;
+    return p;
+}
+
+testlist_t *new_testlist(test_t *t, testlist_t *n)
+{
+    testlist_t *p = (testlist_t *) xmalloc(sizeof(testlist_t));
+    p->t = t;
+    p->next = n;
+    return p;
+}
+
+commandlist_t *new_command(int type)
+{
+    commandlist_t *p = (commandlist_t *) xmalloc(sizeof(commandlist_t));
+    p->type = type;
+    p->next = NULL;
+    return p;
+}
+
+commandlist_t *new_if(test_t *t, commandlist_t *y, commandlist_t *n)
+{
+    commandlist_t *p = (commandlist_t *) xmalloc(sizeof(commandlist_t));
+    p->type = IF;
+    p->u.i.t = t;
+    p->u.i.do_then = y;
+    p->u.i.do_else = n;
+    p->next = NULL;
+    return p;
+}
+
+void free_sl(stringlist_t *sl) 
+{
+    stringlist_t *sl2;
+    
+    while (sl != NULL) {
+	sl2 = sl->next;
+
+	if (sl->s) free(sl->s);
+
+	free(sl);
+	sl = sl2;
+    }
+}
+
+
+void free_test(test_t *t);
+
+static void free_tl(testlist_t *tl)
+{
+    testlist_t *tl2;
+
+    while (tl) {
+	tl2 = tl->next;
+
+	if (tl->t) free_test(tl->t);
+
+	free(tl);
+	tl = tl2;
+    }
+}
+
+void free_test(test_t *t)
+{
+    if (t == NULL) return;
+
+    switch (t->type) {
+    case ANYOF:
+    case ALLOF:
+	free_tl(t->u.tl);
+	break;
+
+    case EXISTS:
+	free_sl(t->u.sl);
+	break;
+
+    case SIZE:
+    case SFALSE:
+    case STRUE:
+	break;
+
+    case HEADER:
+	free_sl(t->u.h.sl);
+	free_sl(t->u.h.pl);
+	
+	break;
+
+    case ADDRESS:
+	free_sl(t->u.ae.sl);
+	free_sl(t->u.ae.pl);
+	break;
+
+    case BODY:
+	free_sl(t->u.b.content_types);
+	free_sl(t->u.b.pl);
+	break;
+
+    case NOT:
+	free_test(t->u.t);
+	break;
+    }
+
+    free(t);
+}
+
+void free_tree(commandlist_t *cl)
+{
+    commandlist_t *cl2;
+
+    while (cl != NULL) {
+	cl2 = cl->next;
+	switch (cl->type) {
+	case IF:
+	    free_test(cl->u.i.t);
+	    free_tree(cl->u.i.do_then);
+	    free_tree(cl->u.i.do_else);
+	    break;
+
+	case INCLUDE:
+	    if (cl->u.inc.script) free(cl->u.inc.script);
+	    break;
+
+	case FILEINTO:
+	    if (cl->u.f.folder) free(cl->u.f.folder);
+	    break;
+
+	case REDIRECT:
+	    if (cl->u.r.address) free(cl->u.r.address);
+	    break;
+
+	case REJCT:
+	    if (cl->u.str) free(cl->u.str);
+	    break;
+
+	case VACATION:
+	    if (cl->u.v.subject) free(cl->u.v.subject);
+	    if (cl->u.v.addresses) free_sl(cl->u.v.addresses);
+	    if (cl->u.v.message) free(cl->u.v.message);
+	    break;
+	    
+	case SETFLAG:
+	case ADDFLAG:
+	case REMOVEFLAG:
+	    free_sl(cl->u.sl);
+	    break;
+
+	case KEEP:
+	case STOP:
+	case DISCARD:
+	case RETURN:
+	    break;
+
+	case NOTIFY:
+	    if (cl->u.n.method) free(cl->u.n.method);
+	    if (cl->u.n.id) free(cl->u.n.id);
+	    if (cl->u.n.options) free_sl(cl->u.n.options);
+	    if (cl->u.n.message) free(cl->u.n.message);
+	    break;
+
+	case DENOTIFY:
+	    if (cl->u.d.pattern) {
+#ifdef ENABLE_REGEX
+		if (cl->u.d.comptag == REGEX) {
+		    regfree((regex_t *) cl->u.d.pattern);
+		}
+#endif
+		free(cl->u.d.pattern);
+	    }
+	    break;
+	}
+
+	free(cl);
+	cl = cl2;
+    }
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/libsieve/tree.h dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/tree.h
--- dovecot-1.1.1/dovecot-sieve/src/libsieve/tree.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/libsieve/tree.h	2007-07-19 19:13:26.000000000 -0600
@@ -0,0 +1,164 @@
+/* tree.h -- abstract syntax tree
+ * Larry Greenfield
+ * $Id$
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef TREE_H
+#define TREE_H
+
+#include "comparator.h"
+
+/* abstract syntax tree for sieve */
+typedef struct Stringlist stringlist_t;
+typedef struct Commandlist commandlist_t;
+typedef struct Test test_t;
+typedef struct Testlist testlist_t;
+typedef struct Tag tag_t;
+typedef struct Taglist taglist_t;
+
+struct Stringlist {
+    char *s;
+    stringlist_t *next;
+};
+
+ 
+struct Tag {
+    int type;
+    char *arg;
+};
+
+struct Taglist {
+    tag_t *t;
+    taglist_t *next;
+};
+
+struct Test {
+    int type;
+    union {
+	testlist_t *tl; /* anyof, allof */
+	stringlist_t *sl; /* exists */
+	struct { /* it's a header test */
+	    int comptag;
+	    char * comparator;
+	    int relation;
+	    void *comprock;
+	    stringlist_t *sl;
+	    stringlist_t *pl;
+	} h;
+	struct { /* it's an address or envelope test */
+	    int comptag;
+	    char * comparator;
+	    int relation; 
+	    void *comprock;
+	    stringlist_t *sl;
+	    stringlist_t *pl;
+            int addrpart;
+	} ae; 
+	struct { /* it's a body test */
+	    int comptag;
+	    int relation; 
+	    char * comparator;
+	    void *comprock;
+	    int transform;
+	    int offset;
+	    stringlist_t *content_types;
+	    stringlist_t *pl;
+	} b; 
+	test_t *t; /* not */
+	struct { /* size */
+	    int t; /* tag */
+	    int n; /* param */
+	} sz;
+    } u;
+};
+
+struct Testlist {
+    test_t *t;
+    testlist_t *next;
+};
+
+struct Commandlist {
+    int type;
+    union {
+        char *str;
+	stringlist_t *sl; /* the parameters */
+	struct { /* it's an if statement */
+	    test_t *t;
+	    commandlist_t *do_then;
+	    commandlist_t *do_else;
+	} i;
+	struct { /* it's an include action */
+	    int location;
+	    char *script;
+	} inc;
+	struct { /* it's a fileinto action */
+	    char *folder;
+	    int copy;
+	    /* add stringlist_t for imap4flags */
+	} f;
+	struct { /* it's a redirect action */
+	    char *address;
+	    int copy;
+	} r;
+	struct { /* it's a vacation action */
+	    char *subject;
+	    int days;
+	    stringlist_t *addresses;
+	    char *message;
+	    char *from;
+	    char *handle;
+	    int mime;
+	} v;
+	struct { /* it's a notify action */
+	    char *method;
+	    char *id;
+	    stringlist_t *options;
+	    int priority;
+	    char *message;
+	} n;
+	struct { /* it's a denotify action */
+	    int comptag;
+	    int relation;
+	    void *comprock;
+	    void *pattern;
+	    int priority;
+	} d;
+    } u;
+    struct Commandlist *next;
+};
+
+stringlist_t *new_sl(char *s, stringlist_t *n);
+tag_t *new_tag(int type, char *s);
+taglist_t *new_taglist(tag_t *t, taglist_t *n);
+test_t *new_test(int type);
+testlist_t *new_testlist(test_t *t, testlist_t *n);
+commandlist_t *new_command(int type);
+commandlist_t *new_if(test_t *t, commandlist_t *y, commandlist_t *n);
+
+void free_sl(stringlist_t *sl);
+void free_test(test_t *t);
+void free_tree(commandlist_t *cl);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/Makefile.am dovecot-1.1.1-sieve/dovecot-sieve/src/Makefile.am
--- dovecot-1.1.1/dovecot-sieve/src/Makefile.am	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/Makefile.am	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,32 @@
+SUBDIRS = libsieve
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/deliver
+
+lda_moduledir = $(moduledir)/lda
+
+lib90_cmusieve_plugin_la_LDFLAGS = -module -avoid-version
+
+lda_module_LTLIBRARIES = \
+	lib90_cmusieve_plugin.la
+
+lib90_cmusieve_plugin_la_LIBADD = \
+	libsieve/libsieve.la
+
+lib90_cmusieve_plugin_la_SOURCES = \
+	cmusieve-plugin.c \
+	imparse.c \
+	map.c \
+	sieve-cmu.c
+
+noinst_HEADERS = \
+	cmusieve-plugin.h \
+	imparse.h \
+	libconfig.h \
+	map.h \
+	xmalloc.h
diff -urN dovecot-1.1.1/dovecot-sieve/src/map.c dovecot-1.1.1-sieve/dovecot-sieve/src/map.c
--- dovecot-1.1.1/dovecot-sieve/src/map.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/map.c	2007-09-16 04:57:55.000000000 -0600
@@ -0,0 +1,55 @@
+#include "lib.h"
+#include "map.h"
+
+#include <unistd.h>
+
+static ssize_t read_full_n(int fd, void *data, size_t size)
+{
+	ssize_t ret, all_ret = 0;
+
+	while (size > 0) {
+		ret = read(fd, data, size);
+		if (ret <= 0)
+			return ret;
+
+		data = PTR_OFFSET(data, ret);
+		all_ret += ret;
+		size -= ret;
+	}
+
+	return all_ret;
+}
+
+void map_refresh(int fd, int onceonly ATTR_UNUSED, const char **base,
+		 unsigned long *len, unsigned long newlen,
+		 const char *name, const char *mboxname ATTR_UNUSED)
+{
+	ssize_t ret;
+	void *p;
+
+	if (newlen == 0) {
+		/* the file is a broken zero-byte file */
+		*len = 0;
+		return;
+	}
+
+	*base = p = i_malloc(newlen);
+	*len = newlen;
+
+	ret = read_full_n(fd, p, newlen);
+	if (ret < 0) {
+		i_error("read_full_n(%s) failed: %m", name);
+		ret = 0;
+	}
+
+	*len = ret;
+}
+
+void map_free(const char **base, unsigned long *len ATTR_UNUSED)
+{
+	char *x = (char *) *base;
+
+	i_free(x);
+	*base = NULL;
+}
+
diff -urN dovecot-1.1.1/dovecot-sieve/src/map.h dovecot-1.1.1-sieve/dovecot-sieve/src/map.h
--- dovecot-1.1.1/dovecot-sieve/src/map.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/map.h	2007-07-19 19:12:51.000000000 -0600
@@ -0,0 +1,10 @@
+#ifndef __MAP_H
+#define __MAP_H
+
+extern void map_refresh(int fd, int onceonly, const char **base,
+			unsigned long *len, unsigned long newlen,
+			const char *name, const char *mboxname);
+
+extern void map_free(const char **base, unsigned long *len);
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/src/sieve-cmu.c dovecot-1.1.1-sieve/dovecot-sieve/src/sieve-cmu.c
--- dovecot-1.1.1/dovecot-sieve/src/sieve-cmu.c	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/sieve-cmu.c	2008-05-16 07:09:09.000000000 -0600
@@ -0,0 +1,1042 @@
+/* Copyright (C) 2005-2006 Timo Sirainen */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "array.h"
+#include "hostpid.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "write-full.h"
+#include "rfc822-parser.h"
+#include "message-date.h"
+#include "message-parser.h"
+#include "message-decoder.h"
+#include "mail-storage.h"
+#include "deliver.h"
+#include "duplicate.h"
+#include "mail-send.h"
+#include "smtp-client.h"
+#include "libsieve/sieve_interface.h"
+#include "cmusieve-plugin.h"
+
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+/* data per script */
+typedef struct script_data {
+	const char *username;
+	struct mail_namespace *namespaces;
+	struct mail_storage **storage_r;
+
+	sieve_interp_t *interp;
+	string_t *errors;
+} script_data_t;
+
+struct sieve_body_part {
+	const char *content_type;
+
+	const char *raw_body;
+	const char *decoded_body;
+	size_t raw_body_size;
+	size_t decoded_body_size;
+	bool have_body; /* there's the empty end-of-headers line */
+};
+
+typedef struct {
+	struct mail *mail;
+	const char *mailbox;
+	const char *id;
+	const char *return_path;
+	const char *authuser;
+	const char *destaddr;
+
+	pool_t body_parts_pool;
+	ARRAY_DEFINE(body_parts, struct sieve_body_part);
+	ARRAY_DEFINE(return_body_parts, sieve_bodypart_t);
+
+	const char *temp[10];
+	buffer_t *tmp_buffer;
+} sieve_msgdata_t;
+
+static int
+dovecot_sieve_compile(script_data_t *sdata, const char *script_path,
+		      const char *compiled_path);
+
+static const char *unfold_header(const char *str)
+{
+	char *new_str;
+	unsigned int i, j;
+
+	for (i = 0; str[i] != '\0'; i++) {
+		if (str[i] == '\n')
+			break;
+	}
+	if (str[i] == '\0')
+		return str;
+
+	/* @UNSAFE */
+	new_str = t_malloc(i + strlen(str+i) + 1);
+	memcpy(new_str, str, i);
+	for (j = i; str[i] != '\0'; i++) {
+		if (str[i] == '\n') {
+			new_str[j++] = ' ';
+			i++;
+			i_assert(str[i] == ' ' || str[i] == '\t');
+		} else {
+			new_str[j++] = str[i];
+		}
+	}
+	new_str[j] = '\0';
+	return new_str;
+}
+
+static const char *const *
+unfold_multiline_headers(const char *const *headers)
+{
+	const char **new_headers;
+	unsigned int i;
+
+	/* see if there are any multiline headers */
+	for (i = 0; headers[i] != NULL; i++) {
+		if (strchr(headers[i], '\n') != NULL)
+			break;
+	}
+	if (headers[i] == NULL) {
+		/* no multilines */
+		return headers;
+	}
+
+	/* @UNSAFE */
+	for (; headers[i] != NULL; i++) ;
+	new_headers = t_new(const char *, i + 1);
+	for (i = 0; headers[i] != NULL; i++)
+		new_headers[i] = unfold_header(headers[i]);
+	return new_headers;
+}
+
+/* gets the header "head" from msg. */
+static int getheader(void *v, const char *phead, const char ***body)
+{
+    sieve_msgdata_t *m = v;
+    const char *const *headers;
+
+    if (phead==NULL) return SIEVE_FAIL;
+    if (mail_get_headers_utf8(m->mail, phead, &headers) < 0)
+	    return SIEVE_FAIL;
+    headers = unfold_multiline_headers(headers);
+    *body = (const char **)headers;
+
+    if (**body) {
+	return SIEVE_OK;
+    } else {
+	return SIEVE_FAIL;
+    }
+}
+
+static int getsize(void *mc, int *size)
+{
+    sieve_msgdata_t *md = mc;
+    uoff_t psize;
+
+    if (mail_get_physical_size(md->mail, &psize) < 0)
+	    return SIEVE_FAIL;
+
+    *size = psize;
+    return SIEVE_OK;
+}
+
+/* we use the temp field in message_data to avoid having to malloc memory
+   to return, and we also can't expose our the receipients to the message */
+static int getenvelope(void *mc, const char *field, const char ***contents)
+{
+    sieve_msgdata_t *m = (sieve_msgdata_t *) mc;
+
+    if (!strcasecmp(field, "from")) {
+	if (m->return_path == NULL) {
+	    /* invalid or missing return path */
+	    *contents = NULL;
+	    return SIEVE_FAIL;
+	}
+	*contents = m->temp;
+	m->temp[0] = m->return_path;
+	m->temp[1] = NULL;
+	return SIEVE_OK;
+    } else if (!strcasecmp(field, "to")) {
+	*contents = m->temp;
+	m->temp[0] = m->destaddr;
+	m->temp[1] = NULL;
+	return SIEVE_OK;
+    } else if (!strcasecmp(field, "auth") && m->authuser) {
+	*contents = m->temp;
+	m->temp[0] = m->authuser;
+	m->temp[1] = NULL;
+	return SIEVE_OK;
+    } else {
+	*contents = NULL;
+	return SIEVE_FAIL;
+    }
+}
+
+static bool
+is_wanted_content_type(const char **wanted_types, const char *content_type)
+{
+	const char *subtype = strchr(content_type, '/');
+	size_t type_len;
+
+	type_len = subtype == NULL ? strlen(content_type) :
+		(size_t)(subtype - content_type);
+
+	for (; *wanted_types != NULL; wanted_types++) {
+		const char *wanted_subtype = strchr(*wanted_types, '/');
+
+		if (**wanted_types == '\0') {
+			/* empty string matches everything */
+			return TRUE;
+		}
+		if (wanted_subtype == NULL) {
+			/* match only main type */
+			if (strlen(*wanted_types) == type_len &&
+			    strncasecmp(*wanted_types, content_type,
+					type_len) == 0)
+				return TRUE;
+		} else {
+			/* match whole type/subtype */
+			if (strcasecmp(*wanted_types, content_type) == 0)
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+static bool get_return_body_parts(sieve_msgdata_t *m, const char **wanted_types,
+				  bool decode_to_plain)
+{
+	const struct sieve_body_part *body_parts;
+	unsigned int i, count;
+	sieve_bodypart_t *sieve_part;
+
+	body_parts = array_get(&m->body_parts, &count);
+	if (count == 0)
+		return FALSE;
+
+	array_clear(&m->return_body_parts);
+	for (i = 0; i < count; i++) {
+		if (!body_parts[i].have_body) {
+			/* doesn't match anything */
+			continue;
+		}
+
+		if (!is_wanted_content_type(wanted_types,
+					    body_parts[i].content_type))
+			continue;
+
+		sieve_part = array_append_space(&m->return_body_parts);
+		if (decode_to_plain) {
+			if (body_parts[i].decoded_body == NULL)
+				return FALSE;
+			sieve_part->content = body_parts[i].decoded_body;
+			sieve_part->size = body_parts[i].decoded_body_size;
+		} else {
+			if (body_parts[i].raw_body == NULL)
+				return FALSE;
+			sieve_part->content = body_parts[i].raw_body;
+			sieve_part->size = body_parts[i].raw_body_size;
+		}
+	}
+	return TRUE;
+}
+
+static void part_save(sieve_msgdata_t *m, struct message_part *part,
+		      struct sieve_body_part *body_part, bool decoded)
+{
+	buffer_t *buf = m->tmp_buffer;
+
+	buffer_append_c(buf, '\0');
+	if (!decoded) {
+		body_part->raw_body = p_strdup(m->body_parts_pool, buf->data);
+		body_part->raw_body_size = buf->used - 1;
+		i_assert(buf->used - 1 == part->body_size.physical_size);
+	} else {
+		body_part->decoded_body =
+			p_strdup(m->body_parts_pool, buf->data);
+		body_part->decoded_body_size = buf->used - 1;
+	}
+	buffer_set_used_size(buf, 0);
+}
+
+static const char *parse_content_type(const struct message_header_line *hdr)
+{
+	struct rfc822_parser_context parser;
+	string_t *content_type;
+
+	rfc822_parser_init(&parser, hdr->full_value, hdr->full_value_len, NULL);
+	(void)rfc822_skip_lwsp(&parser);
+
+	content_type = t_str_new(64);
+	if (rfc822_parse_content_type(&parser, content_type) < 0)
+		return "";
+	return str_c(content_type);
+}
+
+static int
+parts_add_missing(sieve_msgdata_t *m, const char **content_types,
+		  bool decode_to_plain)
+{
+	struct sieve_body_part *body_part = NULL;
+	struct message_parser_ctx *parser;
+	struct message_decoder_context *decoder;
+	struct message_block block, decoded;
+	const struct message_part *const_parts;
+	struct message_part *parts, *prev_part = NULL;
+	struct istream *input;
+	unsigned int idx = 0;
+	bool save_body = FALSE, have_all;
+	int ret;
+
+	if (get_return_body_parts(m, content_types, decode_to_plain))
+		return 0;
+
+	if (mail_get_stream(m->mail, NULL, NULL, &input) < 0)
+		return -1;
+	if (mail_get_parts(m->mail, &const_parts) < 0)
+		return -1;
+	parts = (struct message_part *)const_parts;
+
+	buffer_set_used_size(m->tmp_buffer, 0);
+	decoder = decode_to_plain ? message_decoder_init(FALSE) : NULL;
+	parser = message_parser_init_from_parts(parts, input, 0, 0);
+	while ((ret = message_parser_parse_next_block(parser, &block)) > 0) {
+		if (block.part != prev_part) {
+			if (body_part != NULL && save_body) {
+				part_save(m, prev_part, body_part,
+					  decoder != NULL);
+			}
+			prev_part = block.part;
+			body_part = array_idx_modifiable(&m->body_parts, idx);
+			idx++;
+			body_part->content_type = "text/plain";
+		}
+		if (block.hdr != NULL || block.size == 0) {
+			/* reading headers */
+			if (decoder != NULL) {
+				(void)message_decoder_decode_next_block(decoder,
+							&block, &decoded);
+			}
+
+			if (block.hdr == NULL) {
+				/* save bodies only if we have a wanted
+				   content-type */
+				save_body = is_wanted_content_type(
+						content_types,
+						body_part->content_type);
+				continue;
+			}
+			if (block.hdr->eoh)
+				body_part->have_body = TRUE;
+			/* We're interested of only Content-Type: header */
+			if (strcasecmp(block.hdr->name, "Content-Type") != 0)
+				continue;
+
+			if (block.hdr->continues) {
+				block.hdr->use_full_value = TRUE;
+				continue;
+			}
+			t_push();
+			body_part->content_type =
+				p_strdup(m->body_parts_pool,
+					 parse_content_type(block.hdr));
+			t_pop();
+			continue;
+		}
+
+		/* reading body */
+		if (save_body) {
+			if (decoder != NULL) {
+				(void)message_decoder_decode_next_block(decoder,
+							&block, &decoded);
+				buffer_append(m->tmp_buffer,
+					      decoded.data, decoded.size);
+			} else {
+				buffer_append(m->tmp_buffer,
+					      block.data, block.size);
+			}
+		}
+	}
+
+	if (body_part != NULL && save_body)
+		part_save(m, prev_part, body_part, decoder != NULL);
+
+	have_all = get_return_body_parts(m, content_types, decode_to_plain);
+	i_assert(have_all);
+
+	if (message_parser_deinit(&parser, &parts) < 0)
+		i_unreached();
+	if (decoder != NULL)
+		message_decoder_deinit(&decoder);
+	return input->stream_errno == 0 ? 0 : -1;
+}
+
+static int getbody(void *mc, const char **content_types,
+		   int decode_to_plain, sieve_bodypart_t **parts_r)
+{
+    sieve_msgdata_t *m = (sieve_msgdata_t *) mc;
+    int r = SIEVE_OK;
+
+    if (!array_is_created(&m->body_parts)) {
+	    m->body_parts_pool =
+		    pool_alloconly_create("sieve body parts", 1024*256);
+
+	    i_array_init(&m->body_parts, 8);
+	    i_array_init(&m->return_body_parts, array_count(&m->body_parts));
+	    m->tmp_buffer = buffer_create_dynamic(default_pool, 1024*64);
+    }
+
+    t_push();
+    if (parts_add_missing(m, content_types, decode_to_plain != 0) < 0)
+	    r = SIEVE_FAIL;
+    t_pop();
+
+    (void)array_append_space(&m->return_body_parts); /* NULL-terminate */
+    *parts_r = array_idx_modifiable(&m->return_body_parts, 0);
+
+    return r;
+}
+
+static int getinclude(void *sc, const char *script, int isglobal,
+		      char *fname, size_t size)
+{
+	script_data_t *sdata = (script_data_t *) sc;
+	const char *script_path, *compiled_path, *home, *script_dir;
+	int ret;
+
+	if (strchr(script, '/') != NULL) {
+		i_info("include: '/' not allowed in script names (%s)",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+
+	if (isglobal) {
+		script_dir = getenv("SIEVE_GLOBAL_DIR");
+		if (script_dir == NULL) {
+			i_info("include: sieve_global_dir not set "
+			       "(wanted script %s)", str_sanitize(script, 80));
+			return SIEVE_FAIL;
+		}
+		script_path = t_strdup_printf("%s/%s", script_dir, script);
+	} else {
+		home = getenv("SIEVE_DIR");
+		if (home == NULL)
+			home = getenv("HOME");
+		if (home == NULL) {
+			i_info("include: sieve_dir and home not set "
+			       "(wanted script %s)", str_sanitize(script, 80));
+			return SIEVE_FAIL;
+		}
+		script_path = t_strdup_printf("%s/%s", home, script);
+	}
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = dovecot_sieve_compile(sdata, script_path, compiled_path);
+	if (ret < 0) {
+		i_info("include: Error compiling script '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+	if (ret == 0) {
+		i_info("include: Script not found: '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+
+	if (i_strocpy(fname, compiled_path, size) < 0) {
+		i_info("include: Script path too long: '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+	return SIEVE_OK;
+}
+
+static int sieve_redirect(void *ac, 
+			  void *ic ATTR_UNUSED, 
+			  void *sc, void *mc, const char **errmsg)
+{
+    sieve_redirect_context_t *rc = (sieve_redirect_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *m = mc;
+    const char *dupeid;
+    int res;
+
+    /* if we have a msgid, we can track our redirects */
+    dupeid = m->id == NULL ? NULL : t_strdup_printf("%s-%s", m->id, rc->addr);
+    if (dupeid != NULL) {
+	/* ok, let's see if we've redirected this message before */
+	if (duplicate_check(dupeid, strlen(dupeid), sd->username)) {
+	    /*duplicate_log(m->id, sd->username, "redirect");*/
+	    i_info("msgid=%s: discarded duplicate forward to <%s>",
+		   str_sanitize(m->id, 80), str_sanitize(rc->addr, 80));
+            return SIEVE_OK;
+	}
+    }
+
+    if ((res = mail_send_forward(m->mail, rc->addr)) == 0) {
+	/* mark this message as redirected */
+	i_info("msgid=%s: forwarded to <%s>",
+	       m->id == NULL ? "" : str_sanitize(m->id, 80),
+	       str_sanitize(rc->addr, 80));
+        if (dupeid != NULL) {
+            duplicate_mark(dupeid, strlen(dupeid), sd->username,
+                           ioloop_time + DUPLICATE_DEFAULT_KEEP);
+        }
+	return SIEVE_OK;
+    } else {
+	*errmsg = "Error sending mail";
+	return SIEVE_FAIL;
+    }
+}
+
+static int sieve_discard(void *ac ATTR_UNUSED, 
+			 void *ic ATTR_UNUSED, 
+			 void *sc ATTR_UNUSED, void *mc,
+			 const char **errmsg ATTR_UNUSED)
+{
+    sieve_msgdata_t *md = mc;
+
+    /* ok, we won't file it, but log it */
+    i_info("msgid=%s: discarded",
+	   md->id == NULL ? "" : str_sanitize(md->id, 80));
+    return SIEVE_OK;
+}
+
+static int sieve_reject(void *ac, 
+			void *ic ATTR_UNUSED, 
+			void *sc, void *mc, const char **errmsg)
+{
+    sieve_reject_context_t *rc = (sieve_reject_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+    int res;
+
+    if (md->return_path == NULL) {
+	/* return message to who?!? */
+	*errmsg = "No return-path for reply";
+	return SIEVE_FAIL;
+    }
+
+    if (strlen(md->return_path) == 0) {
+        i_info("msgid=%s: discarded reject to <>",
+	       md->id == NULL ? "" : str_sanitize(md->id, 80));
+        return SIEVE_OK;
+    }
+
+    if ((res = mail_send_rejection(md->mail, sd->username, rc->msg)) == 0) {
+        i_info("msgid=%s: rejected",
+	       md->id == NULL ? "" : str_sanitize(md->id, 80));
+	return SIEVE_OK;
+    } else {
+	*errmsg = "Error sending mail";
+	return SIEVE_FAIL;
+    }
+    return SIEVE_FAIL;
+}
+
+static void get_flags(const sieve_imapflags_t *sieve_flags,
+		      enum mail_flags *flags_r, const char *const **keywords_r)
+{
+	ARRAY_DEFINE(keywords, const char *);
+        const char *name;
+	int i;
+
+	*flags_r = 0;
+
+	t_array_init(&keywords, 16);
+	for (i = 0; i < sieve_flags->nflags; i++) {
+		name = sieve_flags->flag[i];
+
+		if (name != NULL && *name != '\\') {
+			/* keyword */
+			array_append(&keywords, &name, 1);
+		} else {
+			/* system flag */
+			if (name == NULL || strcasecmp(name, "\\flagged") == 0)
+				*flags_r |= MAIL_FLAGGED;
+			else if (strcasecmp(name, "\\answered") == 0)
+				*flags_r |= MAIL_ANSWERED;
+			else if (strcasecmp(name, "\\deleted") == 0)
+				*flags_r |= MAIL_DELETED;
+			else if (strcasecmp(name, "\\seen") == 0)
+				*flags_r |= MAIL_SEEN;
+			else if (strcasecmp(name, "\\draft") == 0)
+				*flags_r |= MAIL_DRAFT;
+		}
+	}
+
+	name = NULL;
+	array_append(&keywords, &name, 1);
+
+	*keywords_r = array_count(&keywords) == 1 ? NULL :
+		array_idx(&keywords, 0);
+}
+
+static int sieve_fileinto(void *ac, 
+			  void *ic ATTR_UNUSED,
+			  void *sc, 
+			  void *mc,
+			  const char **errmsg ATTR_UNUSED)
+{
+    sieve_fileinto_context_t *fc = (sieve_fileinto_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+    enum mail_flags flags;
+    const char *const *keywords;
+
+    get_flags(fc->imapflags, &flags, &keywords);
+
+    if (deliver_save(sd->namespaces, sd->storage_r, fc->mailbox,
+		     md->mail, flags, keywords) < 0)
+	    return SIEVE_FAIL;
+
+    return SIEVE_OK;
+}
+
+static int sieve_keep(void *ac, 
+		      void *ic ATTR_UNUSED,
+		      void *sc, void *mc, const char **errmsg ATTR_UNUSED)
+{
+    sieve_keep_context_t *kc = (sieve_keep_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+    enum mail_flags flags;
+    const char *const *keywords;
+
+    get_flags(kc->imapflags, &flags, &keywords);
+
+    if (deliver_save(sd->namespaces, sd->storage_r, md->mailbox, md->mail, flags, keywords) < 0)
+	    return SIEVE_FAIL;
+
+    return SIEVE_OK;
+}
+
+static bool contains_8bit(const char *msg)
+{
+	const unsigned char *s = (const unsigned char *)msg;
+
+	for (; *s != '\0'; s++) {
+		if ((*s & 0x80) != 0)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+static int sieve_notify(void *ac,
+			void *ic ATTR_UNUSED,
+			void *sc ATTR_UNUSED,
+			void *mc,
+			const char **errmsg)
+{
+    sieve_notify_context_t *nc = (sieve_notify_context_t *) ac;
+    sieve_msgdata_t *m = mc;
+
+    int nopt = 0;
+    FILE *f;
+    struct smtp_client *smtp_client;
+    const char *outmsgid;
+
+    /* "default" is "mailto" as only one... */
+    if (!strcasecmp(nc->method, "default")) nc->method = "mailto";
+    /* check method */
+    if (strcasecmp(nc->method, "mailto")) { 
+        *errmsg = "Unknown [unimplemented] notify method";
+	/* just log error, failed notify is not reason to abort all script. */
+        i_info("SIEVE ERROR: Unknown [unimplemented] notify method <%s>", 
+	nc->method);
+	return SIEVE_OK;
+    }    
+    /* count options */
+    while (nc->options[nopt]) {
+	smtp_client = smtp_client_open(nc->options[nopt], NULL, &f);
+	outmsgid = deliver_get_new_message_id();
+	fprintf(f, "Message-ID: %s\r\n", outmsgid);
+	fprintf(f, "Date: %s\r\n", message_date_create(ioloop_time));
+	fprintf(f, "X-Sieve: %s\r\n", SIEVE_VERSION);
+	if ( strcasecmp(nc->priority, "high") == 0 ) {
+            fprintf(f, "X-Priority: 1 (Highest)\r\n");
+	    fprintf(f, "Importance: High\r\n");
+        } else if ( strcasecmp(nc->priority, "normal") == 0 ) {
+            fprintf(f, "X-Priority: 3 (Normal)\r\n");
+	    fprintf(f, "Importance: Normal\r\n");
+	} else if ( strcasecmp(nc->priority, "low") == 0 ) {
+	    fprintf(f, "X-Priority: 5 (Lowest)\r\n");
+	    fprintf(f, "Importance: Low\r\n");
+	/* RFC: If no importance is given, the default value is "2 (Normal)" */
+	} else {
+	    fprintf(f, "X-Priority: 3 (Normal)\r\n");
+	    fprintf(f, "Importance: Normal\r\n");
+	} 
+	fprintf(f, "From: Postmaster <%s>\r\n",
+		deliver_set->postmaster_address);
+	fprintf(f, "To: <%s>\r\n", nc->options[nopt]);
+	fprintf(f, "Subject: [SIEVE] New mail notification\r\n");
+        fprintf(f, "Auto-Submitted: auto-generated (notify)\r\n");
+	fprintf(f, "Precedence: bulk\r\n");
+        if (contains_8bit(nc->message)) {
+            fprintf(f, "MIME-Version: 1.0\r\n");
+	    fprintf(f, "Content-Type: text/plain; charset=UTF-8\r\n");
+	    fprintf(f, "Content-Transfer-Encoding: 8bit\r\n");
+	}
+	fprintf(f, "\r\n");
+	fprintf(f, "%s\r\n", nc->message);
+	if (smtp_client_close(smtp_client) == 0) {
+		i_info("msgid=%s: sent notification to <%s> (method=%s)",
+		       m->id == NULL ? "" : str_sanitize(m->id, 80),
+		       str_sanitize(nc->options[nopt], 80), nc->method);
+	} else {
+		i_info("msgid=%s: ERROR sending notification to <%s> "
+		       "(method=%s)",
+		       m->id == NULL ? "" : str_sanitize(m->id, 80),
+		       str_sanitize(nc->options[nopt], 80), nc->method);
+		*errmsg = "Error sending notify mail";
+	}
+	nopt = nopt + 1;
+    }
+    return SIEVE_OK;
+}
+
+static int autorespond(void *ac, 
+		       void *ic ATTR_UNUSED,
+		       void *sc,
+		       void *mc,
+		       const char **errmsg ATTR_UNUSED)
+{
+    sieve_autorespond_context_t *arc = (sieve_autorespond_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = mc;
+
+    /* ok, let's see if we've responded before */
+    if (duplicate_check(arc->hash, SIEVE_HASHLEN, sd->username)) {
+	i_info("msgid=%s: discarded duplicate vacation response to <%s>",
+	       md->id == NULL ? "" : str_sanitize(md->id, 80),
+	       str_sanitize(md->return_path, 80));
+	return SIEVE_DONE;
+    }
+
+    duplicate_mark(arc->hash, SIEVE_HASHLEN, sd->username,
+                   ioloop_time + arc->days * (24 * 60 * 60));
+
+    return SIEVE_OK;
+}
+
+static int send_response(void *ac, 
+			 void *ic ATTR_UNUSED, 
+			 void *sc, void *mc,
+			 const char **errmsg)
+{
+    struct smtp_client *smtp_client;
+    FILE *f;
+    const char *outmsgid;
+    sieve_send_response_context_t *src = (sieve_send_response_context_t *) ac;
+    script_data_t *sdata = (script_data_t *) sc;
+    sieve_msgdata_t *md = mc;
+
+    smtp_client = smtp_client_open(src->addr, NULL, &f);
+
+    outmsgid = deliver_get_new_message_id();
+    fprintf(f, "Message-ID: %s\r\n", outmsgid);
+    fprintf(f, "Date: %s\r\n", message_date_create(ioloop_time));
+    
+    fprintf(f, "X-Sieve: %s\r\n", SIEVE_VERSION);
+    fprintf(f, "From: <%s>\r\n", src->fromaddr);
+    fprintf(f, "To: <%s>\r\n", src->addr);
+    fprintf(f, "Subject: %s\r\n", str_sanitize(src->subj, 80));
+    if (md->id) fprintf(f, "In-Reply-To: %s\r\n", md->id);
+    fprintf(f, "Auto-Submitted: auto-replied (vacation)\r\n");
+    fprintf(f, "Precedence: bulk\r\n");
+    fprintf(f, "MIME-Version: 1.0\r\n");
+    if (src->mime) {
+	fprintf(f, "Content-Type: multipart/mixed;"
+		"\r\n\tboundary=\"%s/%s\"\r\n", my_pid, deliver_set->hostname);
+	fprintf(f, "\r\nThis is a MIME-encapsulated message\r\n\r\n");
+	fprintf(f, "--%s/%s\r\n", my_pid, deliver_set->hostname);
+    } else {
+	fprintf(f, "Content-Type: text/plain; charset=utf-8\r\n");
+	fprintf(f, "Content-Transfer-Encoding: 8bit\r\n");
+	fprintf(f, "\r\n");
+    }
+
+    fprintf(f, "%s\r\n", src->msg);
+    if (src->mime)
+	fprintf(f, "\r\n--%s/%s--\r\n", my_pid, deliver_set->hostname);
+
+    if (smtp_client_close(smtp_client) == 0) {
+        duplicate_mark(outmsgid, strlen(outmsgid),
+                       sdata->username, ioloop_time + DUPLICATE_DEFAULT_KEEP);
+	i_info("msgid=%s: sent vacation response to <%s>",
+	       md->id == NULL ? "" : str_sanitize(md->id, 80),
+	       str_sanitize(md->return_path, 80));
+	return SIEVE_OK;
+    } else {
+	*errmsg = "Error sending mail";
+	return SIEVE_FAIL;
+    }
+}
+
+/* vacation support */
+sieve_vacation_t vacation = {
+    1,				/* min response */
+    31,				/* max response */
+    &autorespond,		/* autorespond() */
+    &send_response		/* send_response() */
+};
+
+/* imapflags support */
+static char *markflags[] = { "\\flagged" };
+static sieve_imapflags_t mark = { markflags, 1 };
+
+static int sieve_parse_error_handler(int lineno, const char *msg, 
+				     void *ic ATTR_UNUSED,
+				     void *sc)
+{
+    script_data_t *sd = (script_data_t *) sc;
+
+    if (sd->errors == NULL)
+	    sd->errors = str_new(default_pool, 1024);
+
+    str_printfa(sd->errors, "line %d: %s\n", lineno, msg);
+    return SIEVE_OK;
+}
+
+static int sieve_execute_error_handler(const char *msg, 
+				       void *ic ATTR_UNUSED,
+				       void *sc ATTR_UNUSED,
+				       void *mc ATTR_UNUSED)
+{
+    i_info("sieve runtime error: %s", msg);
+    return SIEVE_OK;
+}
+ 
+static sieve_interp_t *setup_sieve(void)
+{
+    sieve_interp_t *interp = NULL;
+    int res;
+
+    res = sieve_interp_alloc(&interp, NULL);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_interp_alloc() returns %d\n", res);
+
+    res = sieve_register_redirect(interp, &sieve_redirect);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_redirect() returns %d\n", res);
+    res = sieve_register_discard(interp, &sieve_discard);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_discard() returns %d\n", res);
+    res = sieve_register_reject(interp, &sieve_reject);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_reject() returns %d\n", res);
+    res = sieve_register_fileinto(interp, &sieve_fileinto);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_fileinto() returns %d\n", res);
+    res = sieve_register_keep(interp, &sieve_keep);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_keep() returns %d\n", res);
+    res = sieve_register_imapflags(interp, &mark);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_imapflags() returns %d\n", res);
+    res = sieve_register_notify(interp, &sieve_notify);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_notify() returns %d\n", res);
+    res = sieve_register_size(interp, &getsize);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_size() returns %d\n", res);
+    res = sieve_register_header(interp, &getheader);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_header() returns %d\n", res);
+
+    res = sieve_register_envelope(interp, &getenvelope);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_envelope() returns %d\n", res);
+    res = sieve_register_body(interp, &getbody);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_body() returns %d\n", res);
+    res = sieve_register_include(interp, &getinclude);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_registerinclude() returns %d\n", res);
+    res = sieve_register_vacation(interp, &vacation);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_vacation() returns %d\n", res);
+    res = sieve_register_parse_error(interp, &sieve_parse_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_parse_error() returns %d\n", res);
+    res = sieve_register_execute_error(interp,  &sieve_execute_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_execute_error() returns %d\n", res);
+
+    return interp;
+}
+
+static void
+dovecot_sieve_write_error_file(script_data_t *sdata, const char *path)
+{
+	int fd;
+
+	fd = open(path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+	if (fd == -1) {
+		i_error("open(%s) failed: %m", path);
+		return;
+	}
+
+	if (write_full(fd, str_data(sdata->errors), str_len(sdata->errors)) < 0)
+		i_error("write_full(%s) failed: %m", path);
+
+	if (close(fd) < 0)
+		i_error("close() failed: %m");
+}
+
+static int
+dovecot_sieve_compile(script_data_t *sdata, const char *script_path,
+		      const char *compiled_path)
+{
+	struct stat st, st2;
+	sieve_script_t *script;
+	bytecode_info_t *bc;
+	const char *temp_path;
+	FILE *f;
+	int fd, ret;
+
+	if (stat(script_path, &st) < 0) {
+		if (errno == ENOENT) {
+			if (getenv("DEBUG") != NULL) {
+				i_info("cmusieve: Script not found: %s",
+				       script_path);
+			}
+			return 0;
+		}
+		i_error("stat(%s) failed: %m", script_path);
+		return -1;
+	}
+	if (S_ISDIR(st.st_mode)) {
+		i_error("%s should be a file, not a directory", script_path);
+		return -1;
+	}
+	if (stat(compiled_path, &st2) < 0) {
+		if (errno != ENOENT) {
+			i_error("stat(%s) failed: %m", script_path);
+			return -1;
+		}
+	} else {
+		if (st.st_mtime <= st2.st_mtime)
+			return 1;
+	}
+
+	/* need to compile */
+	f = fopen(script_path, "r");
+	if (f == NULL) {
+		i_error("fopen(%s) failed: %m", script_path);
+		return -1;
+	}
+
+	temp_path = t_strconcat(script_path, ".err", NULL);
+	ret = sieve_script_parse(sdata->interp, f, sdata, &script);
+	if (ret != SIEVE_OK) {
+		if (sdata->errors == NULL) {
+			sdata->errors = str_new(default_pool, 128);
+			str_printfa(sdata->errors, "parse error %d", ret);
+		}
+
+		if (getenv("DEBUG") != NULL) {
+			i_info("cmusieve: Compilation failed for %s: %s",
+			       script_path,
+			       str_sanitize(str_c(sdata->errors), 80));
+		}
+		dovecot_sieve_write_error_file(sdata, temp_path);
+		str_free(&sdata->errors);
+		return -1;
+	} else {
+		if (unlink(temp_path) < 0 && errno != ENOENT)
+			i_error("unlink(%s) failed: %m", temp_path);
+	}
+
+	if (sieve_generate_bytecode(&bc, script) < 0) {
+		i_error("sieve_generate_bytecode() failed");
+		return -1;
+	}
+
+	/* write to temp file */
+	temp_path = t_strconcat(compiled_path, ".tmp", NULL);
+	fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+	if(fd == -1) {
+		i_error("open(%s) failed: %m", temp_path);
+		return -1;
+	}
+
+	if (sieve_emit_bytecode(fd, bc) < 0) {
+		i_error("sieve_emit_bytecode() failed");
+		return -1;
+	}
+
+	if (close(fd) < 0)
+		i_error("close() failed: %m");
+
+	/* and finally replace the script */
+	if (rename(temp_path, compiled_path) < 0) {
+		i_error("rename(%s, %s) failed: %m", temp_path, compiled_path);
+		return -1;
+	}
+	return 1;
+}
+
+int cmu_sieve_run(struct mail_namespace *namespaces,
+		  struct mail_storage **storage_r, struct mail *mail,
+		  const char *script_path, const char *destaddr,
+		  const char *username, const char *mailbox)
+{
+	sieve_execute_t *bytecode = NULL;
+	script_data_t sdata;
+	sieve_msgdata_t mdata;
+	const char *compiled_path;
+	int ret;
+
+	memset(&sdata, 0, sizeof(sdata));
+	sdata.username = username;
+	sdata.namespaces = namespaces;
+	sdata.storage_r = storage_r;
+	sdata.interp = setup_sieve();
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = dovecot_sieve_compile(&sdata, script_path, compiled_path);
+	if (ret <= 0)
+		return ret;
+
+	memset(&mdata, 0, sizeof(mdata));
+	mdata.mail = mail;
+	mdata.mailbox = mailbox;
+	mdata.authuser = username;
+	mdata.destaddr = destaddr;
+	(void)mail_get_first_header(mail, "Message-ID", &mdata.id);
+	mdata.return_path = deliver_get_return_address(mail);
+
+	if ((ret = sieve_script_load(compiled_path, &bytecode)) != SIEVE_OK) {
+		i_error("sieve_script_load(%s) failed: %d", compiled_path, ret);
+		return -1;
+	}
+
+	if (getenv("DEBUG") != NULL)
+		i_info("cmusieve: Executing script %s", compiled_path);
+
+	ret = 1;
+	if (sieve_execute_bytecode(bytecode, sdata.interp,
+				   &sdata, &mdata) != SIEVE_OK) {
+		i_error("sieve_execute_bytecode(%s) failed", compiled_path);
+		ret = -1;
+	}
+
+	if (array_is_created(&mdata.body_parts)) {
+		array_free(&mdata.body_parts);
+		array_free(&mdata.return_body_parts);
+		buffer_free(&mdata.tmp_buffer);
+		pool_unref(&mdata.body_parts_pool);
+	}
+	return ret;
+}
diff -urN dovecot-1.1.1/dovecot-sieve/src/xmalloc.h dovecot-1.1.1-sieve/dovecot-sieve/src/xmalloc.h
--- dovecot-1.1.1/dovecot-sieve/src/xmalloc.h	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/src/xmalloc.h	2007-09-16 04:58:58.000000000 -0600
@@ -0,0 +1,26 @@
+#ifndef __XMALLOC_H
+#define __XMALLOC_H
+
+#include <stdlib.h>
+#include <string.h>
+
+#define xmalloc(n) malloc(n)
+#define xrealloc(n, m) realloc(n, m)
+#define xzmalloc(n) calloc(n, 1)
+#define xstrdup(s) strdup(s)
+
+/* missing headers.. */
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <regex.h>
+#include <fcntl.h>
+
+/* dovecot kludges */
+#include "lib.h"
+
+/* we don't have strlcpy, but strocpy is the same except for return value */
+#define strlcpy i_strocpy
+
+#define lcase str_lcase
+
+#endif
diff -urN dovecot-1.1.1/dovecot-sieve/stamp.h.in dovecot-1.1.1-sieve/dovecot-sieve/stamp.h.in
--- dovecot-1.1.1/dovecot-sieve/stamp.h.in	1969-12-31 17:00:00.000000000 -0700
+++ dovecot-1.1.1-sieve/dovecot-sieve/stamp.h.in	2008-06-23 22:52:29.000000000 -0600
@@ -0,0 +1 @@
+ 
\ No newline at end of file
