#! /bin/sh -e
## DP: Adds support for MANAGESIEVE
## DP: Author: Stephan Bosch <stephan@rename-it.nl>
## DP: Version: 0.11.6

# Copyright (c) 2006-2009 by Stephan Bosch <stephan@rename-it.nl>
# This patch is licenced under LGPLv2.1

. $(dirname $0)/DPATCH

exit 0
@DPATCH@
diff -urN dovecot-1.2.0/dovecot-managesieve/AUTHORS dovecot-1.2.0-debian/dovecot-managesieve/AUTHORS
--- dovecot-1.2.0/dovecot-managesieve/AUTHORS	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/AUTHORS	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,15 @@
+Stephan Bosch <stephan@rename-it.nl>
+
+This package is partly based on and built for the Dovecot Secure 
+IMAP server written by:
+
+Timo Sirainen <tss@iki.fi>. 
+
+The ManageSieve service is a modified version of Dovecot's IMAP 
+service implementation.
+
+Although a new Sieve implementation written by the authors listed
+above exists, this ManageSieve implementation can still be compiled
+against the old CMU Sieve implementation located in the 
+dovecot-sieve-1.1 package. The AUTHORS file there references the CMU
+authors.
diff -urN dovecot-1.2.0/dovecot-managesieve/ChangeLog dovecot-1.2.0-debian/dovecot-managesieve/ChangeLog
--- dovecot-1.2.0/dovecot-managesieve/ChangeLog	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/ChangeLog	2009-07-05 12:32:09.000000000 +0000
@@ -0,0 +1,938 @@
+2009-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[013e511cc62b] [tip]
+
+2009-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h,
+	src/managesieve/cmd-putscript.c:
+	Fixed CRLF line breaks in compile errors.
+	[e83c4bc6958a]
+
+	* src/lib-sievestorage/sieve-storage-private.h, src/lib-sievestorage
+	/sieve-storage-save.c, src/lib-sievestorage/sieve-storage.c:
+	Corrected directory/file creation behavior with respect to mode bits
+	and gid.
+	[fa03cc874378]
+
+2009-06-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-getscript.c:
+	Improved handling of script truncation bugs: connection is now
+	closed.
+	[66e3ca082d4f]
+
+2009-06-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-getscript.c:
+	Fixed GETSCRIPT problem that broke script retrieval of scripts
+	larger than 8192 bytes and produced an uninformative error.
+	[1910911af0f8]
+
+2009-06-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client.c:
+	Adjusted to changes in Dovecot regarding client idle timeout vs
+	authentication timeout.
+	[c77027f668b9]
+
+2009-06-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-private.h, src/lib-sievestorage
+	/sieve-storage-save.c, src/lib-sievestorage/sieve-storage-script.c:
+	Prevented temp script name from showing up in error output.
+	[12093e0ebecc]
+
+	* .hgtags:
+	Added tag 0.11.5 for changeset 947a147ab150
+	[c426a9c8d4ec]
+
+	* .hgtags:
+	Added tag 0.11.4 for changeset 2f2dae9ba865
+	[947a147ab150] [0.11.5]
+
+	* Merged concurrent changes.
+	[87a4983567c8]
+
+2009-05-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Minor code cleanup.
+	[29614148b6b4]
+
+	* src/managesieve/main.c:
+	Depricated sieve_storage setting in favour of sieve_dir.
+	[aeca80a747fd]
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Fixed indent problems.
+	[585d6d6e60f5]
+
+2009-06-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.11.4.
+	[dd4717818aa5]
+
+	* NEWS:
+	Updated NEWS file for new release.
+	[4594a9b97c75]
+
+2009-05-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed bug in proxy authentication.
+	[068b2746ce0d]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-login
+	/managesieve-proxy.c:
+	Proxy had IMAP port as default port.
+	[43c500edd103]
+
+	* src/managesieve-login/client-authenticate.c:
+	Fixed small line skip bug in the authenticate command.
+	[c02d8ca19a0d]
+
+2009-05-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[d4396e5076cc]
+
+2009-04-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, configure.in:
+	Released v0.11.4.
+	[2f2dae9ba865] [0.11.4]
+
+2009-05-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-login
+	/client-authenticate.h, src/managesieve-login/client.c, src
+	/managesieve-login/client.h, src/managesieve-login/managesieve-
+	proxy.c, src/managesieve-login/managesieve-proxy.h:
+	Incorporated various changes from imap-login into managesieve-login
+	(untested).
+	[97a7eacb4aad]
+
+2009-04-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Adjusted to signal handler API change in Dovecot.
+	[4a0e02ae5db2]
+
+2009-04-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added TODO item.
+	[45ee24f6a55c]
+
+2009-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.3 for changeset 8ec1103bc9c1
+	[a9231dcce293]
+
+	* configure.in:
+	Released v0.11.3.
+	[8ec1103bc9c1] [0.11.3]
+
+2009-02-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[581154538934]
+
+2009-01-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed small indent problem in previous change.
+	[4fb25c488864]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Added verbose log message for proxy login failure.
+	[05980fd5de09]
+
+	* Merged concurrent changes.
+	[5667030cbfce]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed small bug in the ManageSieve proxy.
+	[30ad00aa8236]
+
+2009-01-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL:
+	Removed ugly TABs from the INSTALL file.
+	[dd499d2dae3a]
+
+	* NEWS:
+	Fixed indent problem in the NEWS file.
+	[1926c9e6b4dd]
+
+	* README:
+	Major revision of the README file.
+	[6f010aef5ceb]
+
+	* README:
+	Fixed ambiguity in the README file regarding the sieve_dir setting.
+	[d1c08d5e3958]
+
+2009-01-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Reprioritized TODO.
+	[2634d65f9b3c]
+
+	* .hgignore, configure.in, dmanagesieve-config.h.in, src/managesieve-
+	login/client.h, src/managesieve/common.h:
+	Started using config header generated by configure.
+	[ac2c64f40791]
+
+	* src/managesieve-login/managesieve-capability.c:
+	Fixed segfault bug occuring when capability string is empty.
+	[8636becd5207]
+
+2009-01-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Final adjustments to the NEWS file.
+	[7a87c0ec99ab]
+
+2009-01-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[e19e0cdaee37]
+
+	* NEWS, src/managesieve-login/client-authenticate.c:
+	Changed SASL service name from 'managesieve' into 'sieve' as
+	required by the specification.
+	[49104f6ac36b]
+
+	* DESIGN, Makefile.am, doc/design.txt:
+	Moved DESIGN file to doc directory.
+	[92671ca35338]
+
+	* NEWS:
+	Prepared NEWS file for new release.
+	[6cbda56aacdc]
+
+	* doc/rfc/draft-ietf-sieve-managesieve-09.txt, draft-ietf-sieve-
+	managesieve-08.txt:
+	Substituted protocol specification.
+	[02a2d2196016]
+
+2009-01-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Fixed handling of ~/ in use of mail-data for script location.
+	[282c5e0231f2]
+
+2009-01-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c:
+	Fixed segfault bug in the authentication timeout.
+	[45575b0b5d59]
+
+	* TODO:
+	Reprioritized TODO.
+	[9d65cc990469]
+
+	* TODO, src/lib-sievestorage/sieve-storage-save.c, src/managesieve-
+	login/client.c, src/managesieve/cmd-capability.c, src/managesieve
+	/cmd-putscript.c, src/managesieve/commands.c,
+	src/managesieve/commands.h:
+	Added CHECKSCRIPT command and marked implementation as protocol
+	VERSION 1.0.
+	[43d0d8e06028]
+
+	* draft-ietf-sieve-managesieve-01.txt, draft-ietf-sieve-
+	managesieve-08.txt:
+	Downloaded latest ManageSieve specification.
+	[f5d0e9366d9a]
+
+	* AUTHORS, src/lib-cmusieve/sieve-common.h, src/lib-cmusieve/sieve-
+	error-private.h, src/lib-cmusieve/sieve-error.c, src/lib-cmusieve
+	/sieve-error.h, src/lib-cmusieve/sieve-script-private.h, src/lib-
+	cmusieve/sieve-script.c, src/lib-cmusieve/sieve-script.h, src/lib-
+	cmusieve/sieve.c, src/lib-cmusieve/sieve.h, src/lib-managesieve
+	/managesieve-parser.c, src/lib-managesieve/managesieve-parser.h, src
+	/lib-managesieve/managesieve-quote.c, src/lib-managesieve
+	/managesieve-quote.h, src/lib-sievestorage/sieve-storage-error.h,
+	src/lib-sievestorage/sieve-storage-list.c, src/lib-sievestorage
+	/sieve-storage-list.h, src/lib-sievestorage/sieve-storage-private.h,
+	src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-save.h, src/lib-sievestorage/sieve-storage-script.c,
+	src/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h, src
+	/managesieve-login/client-authenticate.c, src/managesieve-login
+	/client-authenticate.h, src/managesieve-login/client.c, src
+	/managesieve-login/client.h, src/managesieve-login/cmd-noop.c, src
+	/managesieve-login/commands.h, src/managesieve-login/managesieve-
+	capability.c, src/managesieve-login/managesieve-capability.h, src
+	/managesieve-login/managesieve-proxy.c, src/managesieve-login
+	/managesieve-proxy.h, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-havespace.c, src/managesieve/cmd-listscripts.c,
+	src/managesieve/cmd-logout.c, src/managesieve/cmd-noop.c,
+	src/managesieve/cmd-putscript.c, src/managesieve/cmd-renamescript.c,
+	src/managesieve/cmd-setactive.c, src/managesieve/commands.c,
+	src/managesieve/commands.h, src/managesieve/common.h,
+	src/managesieve/main.c:
+	Added and updated copyright messages to include the new year.
+	[4e7a1b66a5fe]
+
+2008-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Added dump-capability functionality to the managesieve binary.
+	[e2d43b2571d2]
+
+	* src/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client.c, src/managesieve-
+	login/managesieve-capability.c, src/managesieve-login/managesieve-
+	capability.h:
+	Implemented retrieving capabilities from the managesieve daemon in
+	stead of loading the sieve library into the login daemon.
+	[6d05b2352618]
+
+2008-12-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve/sieve-
+	script.c, src/lib-cmusieve/sieve-script.h, src/lib-cmusieve/sieve.c,
+	src/lib-cmusieve/sieve.h, src/managesieve-login/client.c, src
+	/managesieve-login/managesieve-proxy.c, src/managesieve/main.c:
+	Adapted to changes in Sieve and Dovecot.
+	[2455ced8fb3e]
+
+2008-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/client.c:
+	Adapted to changes in the Dovecot API.
+	[65bbf889f6a7]
+
+2008-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.2 for changeset 75f6d40cb4d5
+	[2a6fd3294a09]
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Properly set maximum permissions for uploaded scripts, was 0777.
+	[a0f0f0caf0a9]
+
+2008-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.11.2.
+	[75f6d40cb4d5] [0.11.2]
+
+2008-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[768aa94cc154]
+
+2008-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-cmusieve/sieve.c, src/lib-cmusieve/sieve.h, src
+	/managesieve-login/client.c, src/managesieve/cmd-capability.c:
+	Cleaned up capability reporting and added NOTIFY capability.
+	[147b2f1b4230]
+
+2008-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/Makefile.am:
+	Fixed compile problem caused by changes in Dovecot.
+	[18a1c92ba81a]
+
+2008-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.1 for changeset ef627c91feee
+	[6f112d9171ac]
+
+	* NEWS, configure.in, src/lib-sievestorage/Makefile.am:
+	Released v0.11.1.
+	[ef627c91feee] [0.11.1]
+
+2008-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-script.c:
+	Disallowed '/' characters in script names.
+	[445c103f2b45]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Minor change to the TODO list.
+	[9775c8ca27f6]
+
+	* TODO, src/managesieve/cmd-putscript.c:
+	Implemented WARNINGS response code.
+	[e4cd0bbb51b2]
+
+	* TODO, src/lib-sievestorage/sieve-storage-error.h, src/lib-
+	sievestorage/sieve-storage-private.h, src/lib-sievestorage/sieve-
+	storage-save.c, src/lib-sievestorage/sieve-storage-script.c, src
+	/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h,
+	src/managesieve/client.c, src/managesieve/cmd-deletescript.c:
+	Improved error handling and implemented ALREADYEXISTS response code.
+	[3fc05b4fbf56]
+
+2008-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sievestorage/sieve-storage-script.c, src/managesieve
+	/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-renamescript.c, src/managesieve/cmd-setactive.c:
+	Implemented NONEXISTENT response code.
+	[617f6b259f23]
+
+	* src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage-script.h, src/managesieve/cmd-deletescript.c:
+	Implemented ACTIVE response code.
+	[8a8f93db8614]
+
+	* TODO:
+	Updated TODO.
+	[7b6e9b80da2d]
+
+	* src/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client.c, src/managesieve-
+	login/client.h, src/managesieve-login/cmd-noop.c, src/managesieve-
+	login/commands.h:
+	Added pre-auth NOOP command.
+	[bdc4c280be29]
+
+	* TODO:
+	Updated TODO.
+	[f2cf49e1d6f9]
+
+	* src/managesieve/cmd-noop.c:
+	Updated NOOP command to new draft spec (not pre-auth available yet).
+	[3b50e9d3fefc]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c:
+	Minor cleanups in the code (indentation).
+	[df5d3041fe29]
+
+	* TODO:
+	Updated TODO
+	[5e28128e60fe]
+
+	* draft-ietf-sieve-managesieve-01.txt:
+	Added draft standard document.
+	[b6d643971b22]
+
+2008-11-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in, src/lib-sievestorage/Makefile.am, src/managesieve-
+	login/Makefile.am, src/managesieve/Makefile.am:
+	Added root directory of sieve plugin to include patch to include
+	newly added config header (dovecot-libsieve changed).
+	[6d90d0fa402f]
+
+2008-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.0 for changeset eb997ed30a44
+	[36496bf8e0c6]
+
+	* configure.in:
+	Released v0.11.0.
+	[eb997ed30a44] [0.11.0]
+
+	* src/lib-cmusieve/Makefile.am:
+	Fixed bug in { test ! -d dovecot-1.2-managesieve-0.11.0 || { find
+	dovecot-1.2-managesieve-0.11.0 -type d ! -perm -200 -exec chmod u+w
+	{} ';' && rm -fr dovecot-1.2-managesieve-0.11.0; }; } mkdir
+	dovecot-1.2-managesieve-0.11.0 mkdir -p --
+	dovecot-1.2-managesieve-0.11.0/. list='src'; for subdir in $list; do
+	\ if test "$subdir" = .; then :; else \ test
+	-d "dovecot-1.2-managesieve-0.11.0/$subdir" \ || mkdir
+	-p -- "dovecot-1.2-managesieve-0.11.0/$subdir" \ || exit
+	1; \ distdir=`CDPATH="${ZSH_VERSION+.}:" && cd
+	dovecot-1.2-managesieve-0.11.0 && pwd`; \
+	top_distdir=`CDPATH="${ZSH_VERSION+.}:" && cd
+	dovecot-1.2-managesieve-0.11.0 && pwd`; \ (cd $subdir &&
+	\ make \ top_distdir="$top_distdir" \
+	distdir="$distdir/$subdir" \ distdir) \
+	|| exit 1; \ fi; \ done make[1]: Entering
+	directory `/home/stephan/src/devel/dovecot-1.2-managesieve/src' list
+	='lib-cmusieve lib-managesieve lib-sievestorage managesieve
+	managesieve-login'; for subdir in $list; do \ if test
+	"$subdir" = .; then :; else \ test -d "/home/stephan/src
+	/devel/dovecot-1.2-managesieve/dovecot-1.2-managesieve-0.11.0/src/$s
+	ubdir" \ || mkdir -p -- "/home/stephan/src/devel/dovecot
+	-1.2-managesieve/dovecot-1.2-managesieve-0.11.0/src/$subdir" \
+	|| exit 1; \ distdir=`CDPATH="${ZSH_VERSION+.}:" && cd /
+	home/stephan/src/devel/dovecot-1.2-managesieve/dovecot-1.2-managesie
+	ve-0.11.0/src && pwd`; \
+	top_distdir=`CDPATH="${ZSH_VERSION+.}:" && cd /home/stephan/src/deve
+	l/dovecot-1.2-managesieve/dovecot-1.2-managesieve-0.11.0 && pwd`; \
+	(cd $subdir && \ make \
+	top_distdir="$top_distdir" \
+	distdir="$distdir/$subdir" \ distdir) \
+	|| exit 1; \ fi; \ done make[2]: Entering
+	directory `/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	cmusieve' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-cmusieve'
+	make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	managesieve' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	managesieve' make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	sievestorage' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	sievestorage' make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve'
+	make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve'
+	make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve-
+	login' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve-
+	login' make[1]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src' find
+	dovecot-1.2-managesieve-0.11.0 -type d ! -perm -777 -exec chmod
+	a+rwx {} \; -o \ ! -type d ! -perm -444 -links 1 -exec
+	chmod a+r {} \; -o \ ! -type d ! -perm -400 -exec chmod
+	a+r {} \; -o \ ! -type d ! -perm -444 -exec /bin/bash
+	/home/stephan/src/devel/dovecot-1.2-managesieve/install-sh -c -m a+r
+	{} {} \; \ || chmod -R a+r dovecot-1.2-managesieve-0.11.0
+	tardir=dovecot-1.2-managesieve-0.11.0 && /bin/bash
+	/home/stephan/src/devel/dovecot-1.2-managesieve/missing --run tar
+	chof - "$tardir" | GZIP=--best gzip -c
+	>dovecot-1.2-managesieve-0.11.0.tar.gz { test ! -d
+	dovecot-1.2-managesieve-0.11.0 || { find
+	dovecot-1.2-managesieve-0.11.0 -type d ! -perm -200 -exec chmod u+w
+	{} ';' && rm -fr dovecot-1.2-managesieve-0.11.0; }; } support for
+	old sieve plugin.
+	[b3d53867ce74]
+
+	* AUTHORS, NEWS, README, TODO:
+	Minor revisions of the package documentation.
+	[556a3b88349d]
+
+2008-10-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Fixed compilation failure due to minor change in dict support.
+	[8b27d201d62e]
+
+2008-09-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Updated documentation to v1.2
+	[88b2a988d694]
+
+2008-09-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Moved sieve settings to plugin {} section of config file.
+	[0e39471148b1]
+
+2008-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-script.c:
+	Forgot changes to the script rename function.
+	[7a98d4df0ed1]
+
+	* src/lib-sievestorage/sieve-storage-list.c, src/lib-sievestorage
+	/sieve-storage-script.c, src/lib-sievestorage/sieve-storage-
+	script.h:
+	Previous change caused segfaults.
+	[55c53e7be0f3]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve/sieve-
+	script.c, src/lib-cmusieve/sieve.h, src/lib-sievestorage/sieve-
+	storage-private.h, src/lib-sievestorage/sieve-storage-save.c, src
+	/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage.c, src/managesieve/cmd-getscript.c:
+	Changed handling of script objects to avoid printing the name of the
+	main script in error messages.
+	[26a7a7c0f08c]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c, src/managesieve-login/client.h, src/managesieve-
+	login/managesieve-proxy.c:
+	More changes to make managesieve work with dovecot-1.2 UNSTABLE.
+	[6516de69a897]
+
+	* src/managesieve-login/client.c:
+	Upgraded to dovecot-1.2 UNSTABLE development tree
+	[98ef994b03e5]
+
+	* src/lib-cmusieve/sieve-error-private.h, src/lib-cmusieve/sieve-
+	error.c, src/lib-cmusieve/sieve-error.h, src/lib-cmusieve/sieve-
+	script.c, src/lib-sievestorage/sieve-storage.c, src/managesieve/cmd-
+	putscript.c, src/managesieve/common.h:
+	Updated to compile against changes in new Sieve implementation.
+	[9c931795fa98]
+
+2008-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[d73e3cfe1caf]
+
+	* src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage-script.h, src/managesieve-login/Makefile.am, src
+	/managesieve-login/client.c, src/managesieve/Makefile.am,
+	src/managesieve/client.c, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-noop.c, src/managesieve/cmd-renamescript.c,
+	src/managesieve/commands.c, src/managesieve/commands.h:
+	Added RENAME and NOOP capabilities.
+	[fbdcfb1fecfa]
+
+2008-07-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.3 for changeset f3822babdd53
+	[45360c8f76ec]
+
+	* NEWS, configure.in:
+	Released v0.10.3
+	[f3822babdd53] [0.10.3]
+
+	* NEWS, configure.in:
+	Fixed auto-dectection of sieve implementation in configure.
+	[749f5a50eb8b]
+
+	* src/lib-cmusieve/sieve-script.c, src/lib-cmusieve/sieve-script.h:
+	Fixed erroneous inline declarations.
+	[08d3b23308da]
+
+2008-05-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Fixed indentation error in the NEWS file.
+	[6771103e6db2]
+
+	* NEWS:
+	Fixed indentation error in the NEWS file.
+	[ae2b4b402ac6]
+
+	* .hgtags:
+	Added tag 0.10.2 for changeset ae364c136e31
+	[34a677577950]
+
+	* configure.in:
+	Released v0.10.2.
+	[ae364c136e31] [0.10.2]
+
+2008-04-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c:
+	Misplaced managesieve_parser_reset() call could break things in rare
+	occasions.
+	[9ad0783596ac]
+
+	* README:
+	Minor typo in the README.
+	[74e8cb23aaf3]
+
+	* NEWS:
+	Updated NEWS.
+	[a8198d09730e]
+
+	* INSTALL, README:
+	Updated documentation to match wiki.
+	[d721cc96dd31]
+
+	* src/managesieve-login/client-authenticate.c:
+	Fixed SASL conversation for SASL mechanisms that need more than two
+	client responses.
+	[fd7c75362f9a]
+
+2008-03-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.1 for changeset 1d8e0f019d22
+	[a951da18b8d8]
+
+	* configure.in:
+	Released v0.10.1.
+	[1d8e0f019d22] [0.10.1]
+
+	* NEWS:
+	Updated NEWS file.
+	[abd768086f01]
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Fixed assert bug in sieve-storage save occuring when save was
+	canceled.
+	[a35209b66170]
+
+	* NEWS:
+	Updated NEWS file.
+	[0729a6aa443e]
+
+	* README:
+	Updated README file.
+	[f559718ec326]
+
+2008-03-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve.c:
+	Fixed bug: compiled script was saved to sieve/tmp and left there.
+	[22ec735aeea9]
+
+	* src/lib-cmusieve/sieve.c, src/lib-sievestorage/sieve-storage-save.c,
+	src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage.c:
+	Made log lines sieve-storage specific.
+	[cc0b1f5a3fdf]
+
+2008-02-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Fixed bug in the saving a script to disc by incorporating related
+	changes from maildir-save.c (tmp files).
+	[1ccf54331bbb]
+
+2008-02-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Amended README file with proxy configuration.
+	[41b45cac234d]
+
+2008-02-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Minor changes to the documentation.
+	[dd6a0b1f411e]
+
+	* README:
+	Added Known Issues section to the README.
+	[8a726b60606e]
+
+2008-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Added DESIGN file to tarball distribution.
+	[3ee68d9bb40b]
+
+	* .hgignore, COPYING:
+	Removed duplicate licence.
+	[0a20481bf71b]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.0 for changeset 1fc40a7b807e
+	[b662dc260864]
+
+	* configure.in:
+	Released v0.10.0.
+	[1fc40a7b807e] [0.10.0]
+
+	* INSTALL:
+	Minor changes to the INSTALL file.
+	[c4ab1821769d]
+
+	* NEWS, configure.in:
+	Updated NEWS file.
+	[34b025d7db3a]
+
+	* src/lib-cmusieve/sieve.h, src/managesieve-login/client.c, src
+	/managesieve-login/managesieve-proxy.c:
+	Incorporated minor changes to the imap implementation into
+	managesieve and fixed a few compiler warnings.
+	[499c6577f171]
+
+	* INSTALL, README:
+	Moved compile info from README to separate INSTALL file.
+	[844cc1514cd8]
+
+	* README:
+	Added notice about the patch to the README.
+	[4910acccd984]
+
+	* DESIGN, NEWS, README, TODO:
+	Updated README to new situation and spliced off NEWS, TODO and
+	DESIGN files.
+	[f8280a8a986c]
+
+	* src/managesieve/cmd-putscript.c:
+	Adjusted to changes in dovecot-1.1.
+	[6938e4f41779]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-script.c, src/managesieve/cmd-putscript.c:
+	Adjusted to changes in dovecot-1.1.
+	[d170f3343646]
+
+2008-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-putscript.c:
+	Removed inappropriate references to 'message' from cmd_putscript.c
+	[e230e3139ce0]
+
+	* src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-save.h, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-putscript.c,
+	src/managesieve/common.h, src/managesieve/main.c:
+	Incorporated v1.1 imap (relevant) changes in client.c into
+	managesieve.
+	[29e1d96c679c]
+
+2008-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/commands.c:
+	Incorporated v1.1 imap changes in commands.c into managesieve.
+	[69899aa6fd71]
+
+	* src/managesieve/main.c:
+	Incorporated v1.1 imap changes in main.c into managesieve.
+	[e92b5cee9005]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Incorporated v1.1 imap-login changes in imap-proxy.c into
+	managesieve-login.
+	[3e8cbe6a965b]
+
+	* src/managesieve-login/client-authenticate.c:
+	Incorporated v1.1 imap-login changes in client-authenticate.c into
+	managesieve-login.
+	[1b2ae7648f1f]
+
+	* src/managesieve-login/client.c, src/managesieve-login/client.h,
+	src/managesieve/main.c:
+	Incorporated v1.1 imap-login changes in client.c/client.h into
+	managesieve-login.
+	[71920eb2b1ea]
+
+2008-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve.c, src/lib-cmusieve/sieve.h:
+	Updated cmu sieve implementation to mathch new libsieve API.
+	[79fde30ec4e7]
+
+	* src/managesieve/cmd-putscript.c:
+	Cleaned up putscript command implementation. The script is now
+	passed to the compiler as a script object and not as a script path.
+	[9d260008a304]
+
+	* src/managesieve-login/Makefile.am, src/managesieve/Makefile.am:
+	Included extra libraries to compile against new sieve plugin.
+	[0656fb1ab0a3]
+
+2008-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Minor change in script storage error handling.
+	[862e79b43158]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-script.c, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-script.c, src/lib-sievestorage/sieve-storage.c,
+	src/managesieve/cmd-putscript.c:
+	Fixed various bugs resulting from the script object merge.
+	[c2720aaa01e3]
+
+	* src/lib-cmusieve/sieve-error-private.h, src/lib-cmusieve/sieve-
+	error.c, src/lib-cmusieve/sieve-script.c, src/managesieve/main.c:
+	Incorporated changes in the libsieve interface and dovecot.
+	[496b349b8b6c]
+
+	* src/Makefile.am:
+	Fixed bug in makefile.
+	[03a629108c0a]
+
+	* configure.in, src/Makefile.am, src/lib-cmusieve/Makefile.am, src
+	/lib-cmusieve/sieve-common.h, src/lib-cmusieve/sieve-error-
+	private.h, src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-
+	error.h, src/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve
+	/sieve-script.c, src/lib-cmusieve/sieve-script.h, src/lib-
+	sievestorage/Makefile.am, src/lib-sievestorage/sieve-storage-
+	private.h, src/lib-sievestorage/sieve-storage-save.c, src/lib-
+	sievestorage/sieve-storage-save.h, src/lib-sievestorage/sieve-
+	storage-script.c, src/lib-sievestorage/sieve-storage-script.h, src
+	/lib-sievestorage/sieve-storage.c, src/lib-sievestorage/sieve-
+	storage.h, src/managesieve-login/Makefile.am,
+	src/managesieve/Makefile.am, src/managesieve/cmd-deletescript.c,
+	src/managesieve/cmd-getscript.c, src/managesieve/cmd-putscript.c,
+	src/managesieve/cmd-setactive.c:
+	Merged managesieve script object with libsieve script object to
+	remove conflict.
+	[04015ad664ff]
+
+	* src/lib-cmusieve/Makefile.am, src/lib-cmusieve/sieve-error.c, src
+	/lib-cmusieve/sieve-error.h, src/lib-cmusieve/sieve.c, src/lib-
+	cmusieve/sieve.h, src/managesieve/cmd-putscript.c:
+	Added renewed error handling to script compilation.
+	[85b13786220f]
+
+2008-01-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/Makefile.am, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-putscript.c, src/managesieve/main.c:
+	Re-enabled compiling scripts upon PUTSCRIPT.
+	[94941c84c15d]
+
+	* configure.in:
+	Fixed bug in configure script.
+	[e9ce47319f1e]
+
+	* src/lib-cmusieve/Makefile.am, src/lib-cmusieve/sieve.c, src/lib-
+	cmusieve/sieve.h:
+	Forgot to add new files.
+	[43de7f9e8ed1]
+
+	* .hgignore, configure.in, src/Makefile.am, src/lib-cmusieve/sieve-
+	cmu.c, src/managesieve-login/Makefile.am, src/managesieve-
+	login/client.c:
+	Added link to cmusieve implementation in dovecot-sieve-1.1.
+	[24afa34fdc90]
+
+2008-01-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Fixed signal handing related assert fail in managesieve/main.c.
+	[87bd5155de04]
+
+	* .hgignore, src/managesieve-login/managesieve-login:
+	Accidentally added managesieve-login binary.
+	[150201234662]
+
+	* .hgignore, AUTHORS, COPYING.LGPL, INSTALL, Makefile.am, NEWS,
+	README, autogen.sh, configure.in, src/Makefile.am, src/lib-cmusieve
+	/sieve-cmu.c, src/lib-managesieve/Makefile.am, src/lib-managesieve
+	/managesieve-parser.c, src/lib-managesieve/managesieve-parser.h, src
+	/lib-managesieve/managesieve-quote.c, src/lib-managesieve
+	/managesieve-quote.h, src/lib-sievestorage/Makefile.am, src/lib-
+	sievestorage/sieve-storage-list.c, src/lib-sievestorage/sieve-
+	storage-list.h, src/lib-sievestorage/sieve-storage-private.h, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-save.h, src/lib-sievestorage/sieve-storage-script.c, src
+	/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h, src
+	/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client-authenticate.h, src
+	/managesieve-login/client.c, src/managesieve-login/client.h, src
+	/managesieve-login/managesieve-login, src/managesieve-login
+	/managesieve-proxy.c, src/managesieve-login/managesieve-proxy.h,
+	src/managesieve/Makefile.am, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-havespace.c, src/managesieve/cmd-listscripts.c,
+	src/managesieve/cmd-logout.c, src/managesieve/cmd-putscript.c,
+	src/managesieve/cmd-setactive.c, src/managesieve/commands.c,
+	src/managesieve/commands.h, src/managesieve/common.h,
+	src/managesieve/main.c, stamp.h.in:
+	Started repository for MANAGESIEVE implementation as separate
+	package.
+	[e81ad896fdf8]
+
diff -urN dovecot-1.2.0/dovecot-managesieve/configure.in dovecot-1.2.0-debian/dovecot-managesieve/configure.in
--- dovecot-1.2.0/dovecot-managesieve/configure.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/configure.in	2009-07-06 04:20:10.000000000 +0000
@@ -0,0 +1,110 @@
+AC_INIT([Dovecot ManageSieve], [0.11.6], [dovecot@dovecot.org], [dovecot-1.2-managesieve])
+AC_CONFIG_SRCDIR([src])
+
+AC_CONFIG_HEADERS([dummy-config.h dmanagesieve-config.h])
+
+AC_DEFINE_UNQUOTED(MANAGESIEVE_NAME, "$PACKAGE_NAME",
+    [Define to the full name of this Sieve implementation.])
+AC_DEFINE_UNQUOTED(MANAGESIEVE_VERSION, "$PACKAGE_VERSION",
+    [Define to the version of this Sieve implementation.])
+
+AM_INIT_AUTOMAKE(no-define)
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AM_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[  --with-dovecot[=DIR]    Dovecot base directory (../)],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+
+AC_ARG_WITH(dovecot-sieve,
+[  --with-dovecot-sieve[=DIR]    Dovecot-sieve plugin base directory (../)],
+    dovecot_sievedir="$withval",
+    dovecot_sievedir=../dovecot-sieve-1.1
+)
+
+top=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $top
+cd $dovecot_sievedir
+dovecot_sievedir=`pwd`
+cd $top
+AC_SUBST(dovecotdir)
+AC_SUBST(dovecot_sievedir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+if test -f "$dovecot_sievedir/src/sieve-cmu.c"; then
+  # compiling against old cmu sieve plugin
+  echo "compiling against old dovecot-sieve plugin."
+  SIEVE_PLUGIN_TOP=$dovecot_sievedir
+  SIEVE_PLUGIN_INCLUDE=$top/src/lib-cmusieve
+  SIEVE_PLUGIN_LIB=$top/src/lib-cmusieve/libsieve_cmu.la
+  have_old_sieve_plugin=yes
+else
+  if test -f "$dovecot_sievedir/src/lib-sieve/sieve.c"; then
+    # compiling against native dovecot sieve plugin
+    echo "compiling against new dovecot-sieve plugin."
+	SIEVE_PLUGIN_TOP=$dovecot_sievedir
+    SIEVE_PLUGIN_INCLUDE=$dovecot_sievedir/src/lib-sieve
+    SIEVE_PLUGIN_LIB=$dovecot_sievedir/src/lib-sieve/libsieve.la
+    have_old_sieve_plugin=no
+  else
+    echo
+    echo "Dovecot Sieve implementation not found from $dovecot_sievedir, "
+    echo "use --with-dovecot-sieve=PATH to give path to compiled Dovecot Sieve sources."
+    AC_MSG_ERROR([dovecot-sieve not found])
+  fi
+fi
+AM_CONDITIONAL(HAVE_OLD_SIEVE_PLUGIN, test "$have_old_sieve_plugin" = "yes")
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(SSL_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_SUBST(SIEVE_PLUGIN_TOP)
+AC_SUBST(SIEVE_PLUGIN_INCLUDE)
+AC_SUBST(SIEVE_PLUGIN_LIB)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/lib-sievestorage/Makefile
+src/lib-managesieve/Makefile
+src/managesieve/Makefile
+src/managesieve-login/Makefile
+stamp.h])
+
+AC_OUTPUT
diff -urN dovecot-1.2.0/dovecot-managesieve/COPYING dovecot-1.2.0-debian/dovecot-managesieve/COPYING
--- dovecot-1.2.0/dovecot-managesieve/COPYING	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/COPYING	2009-07-06 03:49:17.000000000 +0000
@@ -0,0 +1,4 @@
+See AUTHORS file for list of copyright holders.
+
+Everything is licenced under LGPLv2.1 (see /usr/share/common-licenses/LGPL-2.1)
+unless otherwise mentioned at the beginning of the file.
diff -urN dovecot-1.2.0/dovecot-managesieve/dmanagesieve-config.h.in dovecot-1.2.0-debian/dovecot-managesieve/dmanagesieve-config.h.in
--- dovecot-1.2.0/dovecot-managesieve/dmanagesieve-config.h.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/dmanagesieve-config.h.in	2009-01-27 15:55:09.000000000 +0000
@@ -0,0 +1,6 @@
+
+/* Define to the full name of this ManageSieve implementation. */
+#undef MANAGESIEVE_NAME
+
+/* Define to the version of this ManageSieve implementation. */
+#undef MANAGESIEVE_VERSION
diff -urN dovecot-1.2.0/dovecot-managesieve/doc/design.txt dovecot-1.2.0-debian/dovecot-managesieve/doc/design.txt
--- dovecot-1.2.0/dovecot-managesieve/doc/design.txt	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/doc/design.txt	2008-07-18 10:09:52.000000000 +0000
@@ -0,0 +1,28 @@
+Design
+------
+
+The overall design of the daemon is entirely borrowed from the existing
+imap daemon. I have tried to apply the dovecot framework and programming
+paradigms as much as possible. This package contains the following
+directories:
+
+lib-managesieve: parser and quote functions (bound to disappear)
+lib-sievestorage: defines a storage for the sieve scripts (a bit crude)
+managesieve-login: the initial login daemon (derived from src/imap-login)
+managesieve: the actual managesieve daemon (derived form src/imap)
+lib-cmusieve: wrapper around dovecot-sieve-1.x to give the old sieve
+  implementation an identical interface as the new library. This makes 
+  the choice for a specific implementation arbitrary and the transition to
+  the new version a seemless process. 
+
+This package currently still requires the dovecot tree to be patched to add
+support for the new managesieve daemons. For dovecot-1.0 (<= v9), the 
+contents of this package was included in the patch, but now the managesieve 
+implementation is separated from the changes in the dovecot tree. Eventually 
+the need for the patch will disappear when Timo adds support for defining 
+arbitrary new services.
+
+The daemon currently implements all existing MANAGESIEVE commands except the 
+HAVESPACE command which always says 'ok'. It also implements the required
+support for UTF-8 strings. 
+
diff -urN dovecot-1.2.0/dovecot-managesieve/dummy-config.h.in dovecot-1.2.0-debian/dovecot-managesieve/dummy-config.h.in
--- dovecot-1.2.0/dovecot-managesieve/dummy-config.h.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/dummy-config.h.in	2009-07-05 12:31:27.000000000 +0000
@@ -0,0 +1,59 @@
+/* dummy-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to the full name of this Sieve implementation. */
+#undef MANAGESIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef MANAGESIEVE_VERSION
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
diff -urN dovecot-1.2.0/dovecot-managesieve/INSTALL dovecot-1.2.0-debian/dovecot-managesieve/INSTALL
--- dovecot-1.2.0/dovecot-managesieve/INSTALL	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/INSTALL	2009-01-31 21:25:21.000000000 +0000
@@ -0,0 +1,62 @@
+Compile
+-------
+
+Prerequisites:
+
+  * A patched and compiled dovecot-1.2 tree:
+
+    To enable support for the new managesieve service, Dovecot needs to be 
+    patched. The patch is available from the same source as this package. 
+		
+    Package and patch are named as follows:
+
+      Patch: dovecot-1.2.X-managesieve-<managesieve version>.diff.gz
+      Package: dovecot-1.2-managesieve-<managesieve version>.tar.gz
+		
+    Nothing special needs to be done to compile the patched tree. You can use:
+      
+      ./configure
+      make
+      sudo make install
+
+    as usual. 
+		
+    Note that this package will compile against an unpatched dovecot tree, but 
+    keep in mind that dovecot will not know about managesieve without the patch.
+
+  * A compiled dovecot-1.2-sieve tree 
+
+    Currently, no special version dependencies are known to compile against the
+    sieve plugin, but of course the most recent version is recommended. 
+
+    NOTE: dovecot-sieve-1.1 can still be used if you do not want to use the new
+    Sieve implementation.
+
+If you downloaded this package using Mercurial, you have a script called 
+autogen.sh in your source tree. You should execute that first:
+
+./autogen.sh
+
+After this executed successfully or when you downloaded the tarball,
+configure needs to be executed with the following parameters:
+
+  --with-dovecot=<path>
+    Path to the patched and compiled dovecot-1.w source tree
+  --with-dovecot-sieve=<path>	
+    Path to the compiled dovecot-1.2-sieve or dovecot-sieve-1.1 source tree
+
+For example:
+
+./configure --with-dovecot=../dovecot-1.2 \
+  --with-dovecot-sieve=../dovecot-1.2-sieve
+
+As usual, to compile and install, execute the following:
+
+make
+sudo make install 
+
+Configure
+---------
+
+Refer to README file.
+ 
diff -urN dovecot-1.2.0/dovecot-managesieve/Makefile.am dovecot-1.2.0-debian/dovecot-managesieve/Makefile.am
--- dovecot-1.2.0/dovecot-managesieve/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/Makefile.am	2009-07-06 03:52:55.000000000 +0000
@@ -0,0 +1,11 @@
+SUBDIRS = src
+
+EXTRA_DIST = \
+	COPYING.LGPL \
+	ChangeLog \
+	doc
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
diff -urN dovecot-1.2.0/dovecot-managesieve/NEWS dovecot-1.2.0-debian/dovecot-managesieve/NEWS
--- dovecot-1.2.0/dovecot-managesieve/NEWS	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/NEWS	2009-06-29 21:22:16.000000000 +0000
@@ -0,0 +1,239 @@
+Dovecot 1.2:
+
+v0.11.6:
+	* Adjusted to changes in Dovecot regarding client idle timeout vs 
+	  authentication timeout. This release now depends on Dovecot v1.2.rc6.
+	- Fixed CRLF line breaks in compile errors.
+	- Corrected directory/file creation behavior with respect to mode bits
+	  and gid.
+	- Improved handling of script truncation bugs: connection is now closed
+	  (bug itself not fixed yet). 
+	- Prevented temp script name from showing up in error output.
+
+v0.11.5:
+	* Incorporated various changes from imap-login into managesieve-login. This
+	  includes changes in the proxy support.
+  
+v0.11.4:
+	* Adjusted to changes in the Dovecot signal handler API.
+
+v0.11.3:
+	* Changed the SASL service name from "managesieve" into "sieve" as required
+	  in the protocol specification. Don't forget to adjust your configuration 
+	  if your authentication mechanism depends on this service name. 
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot
+	  >= v1.2.beta1.
+	* Adapted to changes in the new Sieve implementation, making this release
+	  dependent on Dovecot Sieve >= v0.1.3 if used. The old cmusieve plugin is 
+	  still supported. 
+	+ Implemented making the SIEVE and NOTIFY capability fully dynamic, meaning 
+	  that the sieve_extensions setting that was introduced for the new Sieve 
+	  plugin properly affects the ManageSieve daemon as well.
+	+ Added support for the CHECKSCRIPT command. In terms of the supported 
+	  commands, the ManageSieve daemon now complies with protocol VERSION 1.0 as
+	  listed in the CAPABILITY response. 
+	- Fixed maximum permissions for uploaded scripts; was 0777. This
+	  was shielded however by the default umask (not documented to be 
+	  configurable), so the actual permissions would never have been 0777.
+	- Fixed a segfault bug in the authentication time-out. Bug report and trace
+	  provided by Wolfgang Friebel.
+	- Fixed handling of ~/ in use of mail-data for script location.
+	- Fixed small problems in the login proxy support.
+  
+v0.11.2:
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot 
+	  >= v1.2.alpa4.	
+
+v0.11.1:
+	- Fixed security issue that gives virtual users the ability to read and
+	  modify each other's scripts if the directory structure of the sieve
+	  storage is known.
+	* Updated NOOP command to match new protocol specification
+	+ Improved error handling and implemented the new response codes: 
+	  ACTIVE, NONEXISTENT, ALREADYEXISTS and WARNINGS
+
+v0.11.0:
+	* Upgraded to Dovecot v1.2
+	* Added support for new ManageSieve extensions RENAME and NOOP
+	* Moved sieve settings to plugin {} section of config file. Now the settings
+	  `sieve` and `sieve_dir` in the plugin section are used for the Sieve plugin
+	  and the ManageSieve service, avoiding the posibility of accidental 
+	  differences in configuration.
+
+Dovecot 1.1:
+
+v0.10.3
+	* Removed erroneous inline declarations that caused compiler warnings. GCC 4.3
+	  turns out to fail entirely as reported by Joel Johnson. 
+	* Fixed auto-dectection of Sieve implementation during ./configure. It now 
+	  produces a proper error when the directory is invalid.
+
+v0.10.2
+	* Fixed bug that caused SASL mechanisms that require more than a single client
+	  response to fail. Reported by Steffen Kaiser and occured when he tried using 
+	  the (obsolete) LOGIN mechanism.
+	* Updated installation and configuration documentation to match the 
+	  information provided in the wiki
+
+v0.10.1
+	* Fixed bug introduced in v0.10.0: compiled scripts were also written to disk
+	  in the sieve/tmp directory and left there. This accumulates much .sievec 
+	  junk in that directory over time. 
+	* Fixed bug in tmp file generation for sieve-storage: errors other than EEXIST
+	  would cause the daemon to sleep() loop indefinitely. 
+	  
+	+ Improved log lines to be more recognizable as being generated from 
+	  managesieve.
+	+ Added short proxy configuration explanation to the README file
+	+ Added 'Known Issues' section to the README file
+	- Fixed assert bug in sieve-storage occuring when save is canceled.
+  
+v0.10.0
+	* Upgraded to Dovecot 1.1:
+		- The actual managesieve implementation is now a separate package. 
+		  The dovecot tree still needs to be patched though to make dovecot 
+		  recognize the new managesieve service.
+		- Incorporated changes to imap/imap-login into the equivalent 
+		  managesieve processes.
+		- Removed cmusieve implementation from managesieve sources. It is 
+		  now linked externally from the dovecot-sieve-1.1 package. 
+		- Restructured README.managesieve file into separate README, NEWS, 
+		  TODO, DESIGN and INSTALL files. 
+	* Added support for new libsieve implementation (to be released). This 
+	  package can be compiled with either the new or the old Sieve
+	  implementation (autodetected). If the new Sieve becomes stable, this 
+	  package will be merged with it to make a single package for Dovecot 
+	  Sieve support.
+   
+Dovecot 1.0:
+
+(development forked, v9 is still maintained for Dovecot v1.0)
+
+v9
+
++ Definitively fixed the segfault mentioned in V8. It proved to be 
+  very time-constrained and thus hard to reproduce. The error turned out
+  to be related to the input handling of the login daemon during 
+  authentication. 
++ Checked for changes in the imap daemon that weren't propagated to the 
+  managesieve implementation due to code duplication.
++ Fixed a bug in the autodetection of the sieve storage location.
++ Fixed bug in the sieve storage that failed to refresh the symlink if
+  the storage was moved. 
++ Improved error handing in the sieve-storage implementation in various 
+  places. 
++ Fixed the situation in which the active script link is located in the 
+  sieve storage. 
++ Added managesieve configuration to dovecot-example.conf and made the example
+  in this file more concise. 
+
+v8
+
++ Fixed a few incompatibilities with 1.0.7 version. For instance, the "Logged
+  in" message is now sent by the -login process and not by the managesieve 
+  daemon anymore. This caused a segfault every once in a while. 
++ Probably fixed the settings problem reported by Steffen Kaiser regarding 
+  login_dir. 'dovecot -n' now reports correct results, but testing will show
+  whether the whole problem is solved.
++ The managesieve daemon now accepts the sieve_storage and sieve configuration
+  settings, so it is now possible to explicitly configure the location of the
+  sieve storage and the active script respectively. The daemon still falls back
+  to using the mail_location (MAIL) settings if nothing else is specified. 
++ The cyrus timsieved does not use the + character in string literals and many
+  clients have adopted to this behaviour. The latest managesieve (08) advises to
+  accept a missing + from clients. The server should not send any + characters 
+  as well. This behavior is now implemented on the server. 
++ Cleaned up sieve-storage.c: split up the sieve_storage_create function in 
+  various sub-functions for obtaining the various paths and directories.
++ Forced manual intervention if rescueing a non-symlink file at the active script
+  path fails somehow. Previously, this presented the admin with a log message 
+  that it had just eaten the script, which is not very nice. 
++ Restructured the README.managesieve file and added some more explanation with
+  regard to the configuration of the daemon.
+
+v7 
+
+- Robin Breathe indicated that the regex capability was missing in the server's
+  SIEVE listing. It turns out I forgot to make arrangements for setting 
+  ENABLE_REGEX in the cmu libsieve sources, so the regex extension was not
+  compiled in. I copied the configure.in section regarding ENABLE_REGEX from 
+  dovecot-sieve-1.0.2 and that fixed the problem.
+
+v6
+
+- Corked the client output stream while producing the capability greeting and on 
+  other some other occasions as well. Some naive client implementations expect to 
+  receive this as a single tcp frame and it is a good practice to do so anyway.
+  Using this change the Thunderbird sieve extension (v0.1.1) seemed to work. However,
+  scripts larger than a tcp frame still caused failures. All these issues are fixed
+  in the latest version of the sieve add-on (currently v0.1.4). 
+- Cleaned up the new proxy source. My editor made the indentation a complete mess
+  in terms of TABs vs spaces. 
+- Added TRYLATER response codes to BYE and NO messages where appropriate.  
+- Recopied the libsieve library into this patch to incorporate any changes that were
+  made (only sieve-cmu.c still needs to be compared to the old cmu-sieve.c). This 
+  also solves the __attribute__((unused)) GCC dependencies. These were fixed long
+  ago by Timo....  the code duplication beast strikes again. 
+- Removed spurious return value from void function in 
+  src/lib-sieve/sieve-implementation.c as reported by Robin Breathe. GCC fails to
+  report these issues. The function involved is currently not used and serves only
+  as an example on how dovecot could support multiple sieve backends... 
+
+v5 
+
+- Applied patch by Uldis Pakuls to fix master_dump_settings bug
+- Added some compilation/installation info to this README
+- Moved README to source tree root as README.managesieve
+- Fixed minor error handling bug in sieve_storage.c with respect to a missing
+  root directory.
+- Now sieve capabilities are reported as they are specified by the implementing
+  library and not in forced upper case. The sieve RFC now explicitly states
+  that sieve capability identifiers are case-sensitive. This broke compatibility
+  with SquirrelMail/Avelsieve. 
+- Disabled ANONYMOUS login entirely until proper support is implemented. V4
+  claimed to do so as well, but in fact it only stopped announcing it.
+- Implemented managesieve-proxy. It is not so much a clean copy of imap-proxy,
+  since the managesieve greeting is much more complex and requires parsing. 
+  Configuration is identical to imap-proxy. This seems to be a little under-
+  documented however (http://wiki.dovecot.org/PasswordDatabase/ExtraFields).  
+
+v4
+
+- Added managesieve_implementation_string setting to the managesieve 
+  configuration. This can be used to customize the default "IMPLEMENTATION" 
+  capability response.
+- Denied ANONYMOUS login until proper support is implemented
+- Fixed problem with authenticate command regarding continued responses. In
+  V3 only initial response would work. Problem was caused by rc2 -> rc28 
+  upgrade. One of the clear reasons why code duplication is a very bad idea.
+- Fixed readlink bug as indicated by Timo: return value of readlink can also
+  be -1.
+- Fixed bug in the regular file rescue code, as introduced in the previous 
+  version. Used stat instead of lstat. This caused the symlink to be rescued 
+  subsequently in the next activation, thus still overwriting the initially 
+  rescued script.
+
+v3
+
+- Updated source to compile with dovecot 1.0.rc27 
+- Daemon now uses the same location for .dovecot.sieve as dovecot-lda
+  This is typically ~/.dovecot.sieve
+- If .dovecot.sieve is a regular file, it is now moved into the script storage as
+  dovecot.orig.sieve, preventing deletion of (important) active scripts 
+  upon upgrade.
+- Changed error handling to yield a BYE message when the managesieve 
+  daemon exits unexpectedly (upon login) before any commands are entered. 
+  Horde-ingo would wait indefinitely for a response. 
+
+v2
+
+- Fixed the bug (missing CRLF) in the authenticate command
+- Modified the sieve storage library making the interface much less crude.
+- The scripts put on the server using the putscript command are now 
+  checked before they are accepted.
+- The reported SIEVE capability is now directly read from the sieve 
+  implementation (in this case cmu), listing much more than "FILEINTO 
+  VACATION".
+- Imported instance of libsieve source into this patch for implementation
+  of script checking and capability listing. THIS NEEDS TO BE CHANGED! 
+- Fixed some minor bugs in the putscript command
diff -urN dovecot-1.2.0/dovecot-managesieve/README dovecot-1.2.0-debian/dovecot-managesieve/README
--- dovecot-1.2.0/dovecot-managesieve/README	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/README	2009-01-31 21:25:21.000000000 +0000
@@ -0,0 +1,163 @@
+MANAGESIEVE implementation for Dovecot (1.2)
+
+Compile
+-------
+
+Refer to INSTALL file.
+ 
+Configure
+---------
+
+IMPORTANT: 
+    If you have used the Sieve plugin before and you have .dovecot.sieve files 
+    in user directories, you are advised to make a backup first. Although the
+    ManageSieve daemon takes care to move these files to the Sieve directory 
+    before it is substituted with a symbolic link, this is not a very well 
+    tested operation, meaning that there is a possibility that existing Sieve 
+    scripts get lost.
+
+Along with all other binaries that Dovecot uses, the managesieve and 
+managesieve-login binaries are installed during make install. The only thing you 
+need to do to activate the ManageSieve support in Dovecot is to add managesieve 
+to the protocols= configuration line in your dovecot.conf. 
+
+The ManageSieve daemon will listen on all interfaces at port 2000 by default. 
+Because the implementation of the ManageSieve daemon is largely based on the 
+original IMAP implementation, it is very similar in terms of configuration. 
+The following settings can be configured in the 'protocol managesieve' section:
+
+listen = *:2000
+    Interface and port on which the daemon listens for incoming connections.
+
+login_executable = /usr/libexec/dovecot/managesieve-login
+    Login executable location. 
+
+mail_executable = /usr/libexec/dovecot/managesieve
+    The managesieve executable location. For examples how this could be applied,
+    refer to the explanation of the mail_executable setting for IMAP. 
+    
+managesieve_max_line_length = 65536
+    The maximum managesieve command line length in bytes. This setting is 
+    directly borrowed from IMAP. But, since long command lines are very unlikely 
+    with ManageSieve, changing this will not be very useful. 
+
+managesieve_implementation_string = dovecot
+    To fool ManageSieve clients that are focused on CMU's timesieved you can 
+    specify the IMPLEMENTATION capability that the Dovecot reports to clients 
+    (e.g. 'Cyrus timsieved v2.2.13'). 
+
+Additionally, the ManageSieve service uses the following settings from the 
+plugin section of the config file. These settings are the ones used by the Sieve 
+plugin.
+
+sieve_dir = 
+    This specifies the path to the directory where the uploaded scripts are 
+    stored. Scripts are stored as separate files with extension '.sieve'. All 
+    other files are ignored when scripts are listed by a ManageSieve client. If
+    this setting remains unspecified, the mail_location setting is used as 
+    explained above.
+
+sieve = ~/.dovecot.sieve
+    Specifies the location of the symbolic link pointing to the active script in
+    the Sieve storage directory. If a regular file exists at this location, it is 
+    moved to the sieve_dir location before the symbolic link is installed. It is 
+    renamed to dovecot.orig.sieve and therefore listed as dovecot.orig by a 
+    ManageSieve client. 
+
+Scripts are stored in a special directory at the location specified by the 
+sieve_dir setting. The active Sieve script is managed as a symbolic link 
+pointing to the active script in the script directory. The location of this 
+symlink is specified with the 'sieve' setting. The default location is 
+~/.dovecot.sieve. Note that if a file starting with '.' is placed inside a 
+Maildir, it will be recognized as a folder, so try to avoid that.
+
+If no 'sieve_dir' is specified, the ManageSieve daemon expects the script 
+directory to reside in the mail folder as specified by the 'mail_location' 
+setting. More precisely, it is placed in the CONTROL= directory of 
+'mail_location' if specified, otherwise the script directory is placed in the 
+root of the mail location. In such a mail or mail control directory, scripts are 
+always stored in a sub-directory called 'sieve'. Using this implicit manner to 
+specify the Sieve script directory is depricated. Also note that for some mail 
+storage types (e.g. mbox) the 'sieve' sub-directory is listed as a mail folder, 
+so be sure to put the Sieve scripts somewhere else if you can.
+
+A storage location specified by 'sieve_dir' is always generated automatically 
+if it does not exist (as far as the system permits the user to do so; no root 
+privileges are used). This is similar to the behaviour of the mail daemons. Note 
+that when 'mail_location' is used to specify the script storage location, only 
+the 'sieve' subdirectory is generated automatically.
+
+The following provides an example configuration for ManageSieve in dovecot.conf. 
+Only sections relevant to ManageSieve are shown. Refer to dovecot-example.conf 
+in your patched Dovecot tree for a full example with comments, but don't forget 
+to add managesieve to the 'protocols = ...' setting if you use it.
+
+# Start imap, pop3 and managesieve services
+protocols = imap pop3 managesieve
+
+protocol managesieve {
+  # Specify an alternative address:port the daemon must listen on
+  # (default: *:2000)
+  #listen = localhost:2000
+}
+
+plugin {
+  sieve=~/.dovecot.sieve
+  sieve_storage=~/sieve
+}
+
+Proxying
+--------
+
+Like Dovecot's imapd, the ManageSieve login daemon supports proxying to multiple
+backend servers. Although the underlying code is copied from the imapd sources
+for the most part, it has some ManageSieve-specifics that have not seen much
+testing. 
+
+The proxy configuration wiki page for POP3 and IMAP should apply to ManageSieve 
+as well:
+
+http://wiki.dovecot.org/PasswordDatabase/ExtraFields/Proxy
+
+Known Issues
+------------
+
+* Although this ManageSieve server should comply with the draft specification of 
+  the ManageSieve protocol, quite a few clients don't. This is particularly true 
+  for the TLS support. However, now that Cyrus' Timsieved has changed its 
+  behavior towards protocol compliance, all those clients will follow 
+  eventually. 
+
+  Clients known to have TLS issues:
+	- Thunderbird Sieve add-on: fixed as per version 0.1.5
+	- AvelSieve: patch on the wiki:	http://wiki.dovecot.org/ManageSieve
+	- KMail + kio_sieve: TLS broken for old versions. This issue is fixed at 
+	  least in kmail 1.9.9 / kde 3.5.9. 
+
+  Unfortunately, there is no reliable way to provide a workaround for this
+  problem. We will have to wait for the authors of these clients to make the
+  proper adjustments. 
+  
+* Other client issues:
+
+	- SmartSieve, WebSieve: 
+	  These clients are specifically written for Cyrus timsieved and fail on 
+	  multiple stages of the protocol when connected to Dovecot ManageSieve.
+	    
+* The current implementation of the daemon does not have quota enforcement as
+  recommended in the specification. So keep in mind that malicious users could
+  fill your filesystem with loads of spurious scriptfiles.
+  
+* The ANONYMOUS authentication mechanism is currently not supported and 
+  explicitly denied. 
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about 
+this package. You can post to the list without subscribing, the mail then waits 
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/Makefile.am dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/Makefile.am
--- dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/Makefile.am	2008-07-18 10:09:52.000000000 +0000
@@ -0,0 +1,15 @@
+noinst_LIBRARIES = libmanagesieve.a
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-charset \
+	-I$(dovecot_incdir)/src/lib-mail
+
+libmanagesieve_a_SOURCES = \
+	managesieve-quote.c \
+	managesieve-parser.c 
+
+noinst_HEADERS = \
+	managesieve-quote.h \
+	managesieve-parser.h 
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c
--- dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,675 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "istream.h"
+#include "ostream.h"
+#include "strescape.h"
+#include "managesieve-parser.h"
+
+#define is_linebreak(c) \
+	((c) == '\r' || (c) == '\n')
+
+#define LIST_ALLOC_SIZE 7
+
+enum arg_parse_type {
+	ARG_PARSE_NONE = 0,
+	ARG_PARSE_ATOM,
+	ARG_PARSE_STRING,
+	ARG_PARSE_LITERAL,
+	ARG_PARSE_LITERAL_DATA
+};
+
+struct managesieve_parser {
+	/* permanent */
+	pool_t pool;
+	struct istream *input;
+	struct ostream *output;
+	size_t max_line_size;
+	enum managesieve_parser_flags flags;
+
+	/* reset by managesieve_parser_reset(): */
+	size_t line_size;
+	struct managesieve_arg_list *root_list;
+	struct managesieve_arg_list *cur_list;
+
+	enum arg_parse_type cur_type;
+	size_t cur_pos; /* parser position in input buffer */
+
+	int str_first_escape; /* ARG_PARSE_STRING: index to first '\' */
+	uoff_t literal_size; /* ARG_PARSE_LITERAL: string size */
+
+	const char *error;
+
+	unsigned int literal_skip_crlf:1;
+	unsigned int literal_nonsync:1;
+	unsigned int eol:1;
+	unsigned int fatal_error:1;
+};
+
+/* @UNSAFE */
+#define LIST_REALLOC(parser, old_list, new_size) \
+	p_realloc((parser)->pool, old_list, \
+		  sizeof(struct managesieve_arg_list) + \
+		  (old_list == NULL ? 0 : \
+		   sizeof(struct managesieve_arg_list) * (old_list)->alloc), \
+		  sizeof(struct managesieve_arg_list) * (new_size))
+
+static void managesieve_args_realloc(struct managesieve_parser *parser, size_t size)
+{
+	parser->cur_list = LIST_REALLOC(parser, parser->cur_list, size);
+	parser->cur_list->alloc = size;
+
+  parser->root_list = parser->cur_list;
+}
+
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size)
+{
+	struct managesieve_parser *parser;
+
+	parser = i_new(struct managesieve_parser, 1);
+        parser->pool = pool_alloconly_create("MANAGESIEVE parser", 8192);
+	parser->input = input;
+	parser->output = output;
+	parser->max_line_size = max_line_size;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+	return parser;
+}
+
+void managesieve_parser_destroy(struct managesieve_parser **parser)
+{
+	pool_unref(&(*parser)->pool);
+	i_free(*parser);
+	*parser = NULL;
+}
+
+void managesieve_parser_reset(struct managesieve_parser *parser)
+{
+	p_clear(parser->pool);
+
+	parser->line_size = 0;
+
+	parser->root_list = NULL;
+	parser->cur_list = NULL;
+
+	parser->cur_type = ARG_PARSE_NONE;
+	parser->cur_pos = 0;
+
+	parser->str_first_escape = 0;
+	parser->literal_size = 0;
+
+	parser->error = NULL;
+
+	parser->literal_skip_crlf = FALSE;
+	parser->eol = FALSE;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+}
+
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal)
+{
+	*fatal = parser->fatal_error;
+	return parser->error;
+}
+
+/* skip over everything parsed so far, plus the following whitespace */
+static int managesieve_parser_skip_to_next(struct managesieve_parser *parser,
+				    const unsigned char **data,
+				    size_t *data_size)
+{
+	size_t i;
+
+	for (i = parser->cur_pos; i < *data_size; i++) {
+		if ((*data)[i] != ' ')
+			break;
+	}
+
+	parser->line_size += i;
+	i_stream_skip(parser->input, i);
+	parser->cur_pos = 0;
+
+	*data += i;
+	*data_size -= i;
+	return *data_size > 0;
+}
+
+static struct managesieve_arg *managesieve_arg_create(struct managesieve_parser *parser)
+{
+	struct managesieve_arg *arg;
+
+	i_assert(parser->cur_list != NULL);
+
+	/* @UNSAFE */
+	if (parser->cur_list->size == parser->cur_list->alloc)
+		managesieve_args_realloc(parser, parser->cur_list->alloc * 2);
+
+	arg = &parser->cur_list->args[parser->cur_list->size];
+	parser->cur_list->size++;
+
+	return arg;
+}
+
+static void managesieve_parser_save_arg(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t size)
+{
+	struct managesieve_arg *arg;
+
+	arg = managesieve_arg_create(parser);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		/* simply save the string */
+		arg->type = MANAGESIEVE_ARG_ATOM;
+		arg->_data.str = p_strndup(parser->pool, data, size);
+		break;
+	case ARG_PARSE_STRING:
+		/* data is quoted and may contain escapes. */
+		i_assert(size > 0);
+
+		arg->type = MANAGESIEVE_ARG_STRING;
+		arg->_data.str = p_strndup(parser->pool, data+1, size-1);
+
+		/* remove the escapes */
+		if (parser->str_first_escape >= 0 &&
+		    (parser->flags & MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE) == 0) {
+			/* -1 because we skipped the '"' prefix */
+			str_unescape(arg->_data.str +
+				     parser->str_first_escape-1);
+		}
+		break;
+	case ARG_PARSE_LITERAL_DATA:
+		if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) != 0) {
+			/* save literal size */
+			arg->type = MANAGESIEVE_ARG_LITERAL_SIZE;
+			arg->_data.literal_size = parser->literal_size;
+		} else if ((parser->flags &
+			    MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE) != 0) {
+			arg->type = MANAGESIEVE_ARG_LITERAL;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		} else {
+			arg->type = MANAGESIEVE_ARG_STRING;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		}
+		break;
+	default:
+		i_unreached();
+	}
+
+	parser->cur_type = ARG_PARSE_NONE;
+}
+
+static int is_valid_atom_char(struct managesieve_parser *parser, char chr)
+{
+	if (IS_ATOM_SPECIAL((unsigned char)chr)) {
+		parser->error = "Invalid characters in atom";
+		return FALSE;
+	} else if ((chr & 0x80) != 0) {
+		parser->error = "8bit data in atom";
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static int managesieve_parser_read_atom(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t data_size)
+{
+	size_t i;
+
+	/* read until we've found space, CR or LF. */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == ')' ||
+			 is_linebreak(data[i])) {
+			managesieve_parser_save_arg(parser, data, i);
+			break;
+		} else if (!is_valid_atom_char(parser, data[i]))
+			return FALSE;
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_read_string(struct managesieve_parser *parser,
+				   const unsigned char *data, size_t data_size)
+{
+	size_t i;
+	int utf8_len;
+
+	/* QUOTED-CHAR        = SAFE-UTF8-CHAR / "\" QUOTED-SPECIALS
+	 * quoted             = <"> *QUOTED-CHAR <">
+	 *                    ;; limited to 1024 octets between the <">s
+	 */
+
+	/* read until we've found non-escaped ", CR or LF */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '"') {
+			managesieve_parser_save_arg(parser, data, i);
+
+			i++; /* skip the trailing '"' too */
+			break;
+		}
+
+		if (data[i] == '\\') {
+			if (i+1 == data_size) {
+				/* known data ends with '\' - leave it to
+				   next time as well if it happens to be \" */
+				break;
+			}
+
+			/* save the first escaped char */
+			if (parser->str_first_escape < 0)
+				parser->str_first_escape = i;
+
+			/* skip the escaped char */
+			i++;
+
+			if ( !IS_QUOTED_SPECIAL(data[i]) ) {
+				parser->error = "Escaped quoted-string character is not a QUOTED-SPECIAL.";
+				return FALSE;
+			}
+
+			continue;
+		}
+
+		/* Enforce valid UTF-8
+		 */
+		if ( (utf8_len = UTF8_LEN(data[i])) == 0 ) {
+			parser->error = "String contains invalid character.";
+			return FALSE;
+		}
+		
+		if ( utf8_len > 1 ) {
+			bool overlong = FALSE;
+
+			if ( (i+utf8_len-1) >= data_size ) {
+				/* Known data ends in the middle of a UTF-8 character;
+				 * leave it to next time.
+				 */
+				break;
+			}
+
+			/* Check for overlong UTF-8 sequences */
+			switch (utf8_len) {
+			case 2:
+				if (!(data[i] & 0x1E)) overlong = TRUE;
+				break;
+			case 3:	
+				if (!(data[i] & 0x0F) && !(data[i+1] & 0x20)) overlong = TRUE;
+				break;
+			case 4:
+				if (!(data[i] & 0x07) && !(data[i+1] & 0x30)) overlong = TRUE;				
+				break;
+			case 5:
+				if (!(data[i] & 0x03) && !(data[i+1] & 0x38)) overlong = TRUE;
+				break;				
+			case 6:
+				if (!(data[i] & 0x01) && !(data[i+1] & 0x3C)) overlong = TRUE;
+				break;				
+			default:
+				i_unreached();
+			} 
+
+			if ( overlong ) {
+				parser->error = "String contains invalid/overlong UTF-8 character.";
+				return FALSE;
+			}
+
+			i++;
+			utf8_len--;
+	
+			/* Parse the series of UTF8_1 characters */
+			for (; utf8_len > 0; utf8_len--, i++ ) {  
+				if (!IS_UTF8_1(data[i])) {
+					parser->error = "String contains invalid UTF-8 character.";
+			    return FALSE;
+				}
+			}
+		}
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_literal_end(struct managesieve_parser *parser)
+{
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		if (parser->line_size >= parser->max_line_size ||
+		    parser->literal_size >
+		    	parser->max_line_size - parser->line_size) {
+			/* too long string, abort. */
+			parser->error = "Literal size too large";
+			parser->fatal_error = TRUE;
+			return FALSE;
+		}
+	}
+
+	parser->cur_type = ARG_PARSE_LITERAL_DATA;
+	parser->literal_skip_crlf = TRUE;
+
+	parser->cur_pos = 0;
+	return TRUE;
+}
+
+static int managesieve_parser_read_literal(struct managesieve_parser *parser,
+				    const unsigned char *data,
+				    size_t data_size)
+{
+	size_t i, prev_size;
+
+	/* expecting digits + "}" */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '}') {
+			parser->line_size += i+1;
+			i_stream_skip(parser->input, i+1);
+
+			return managesieve_parser_literal_end(parser);
+		}
+
+		if (parser->literal_nonsync) {
+			parser->error = "Expecting '}' after '+'";
+			return FALSE;
+		}
+
+		if (data[i] == '+') {
+			parser->literal_nonsync = TRUE;
+			continue;
+		}
+
+		if (data[i] < '0' || data[i] > '9') {
+			parser->error = "Invalid literal size";
+			return FALSE;
+		}
+
+		prev_size = parser->literal_size;
+		parser->literal_size = parser->literal_size*10 + (data[i]-'0');
+
+		if (parser->literal_size < prev_size) {
+			/* wrapped around, abort. */
+			parser->error = "Literal size too large";
+			return FALSE;
+		}
+	}
+
+	parser->cur_pos = i;
+	return FALSE;
+}
+
+static int managesieve_parser_read_literal_data(struct managesieve_parser *parser,
+					 const unsigned char *data,
+					 size_t data_size)
+{
+	if (parser->literal_skip_crlf) {
+
+		/* skip \r\n or \n, anything else gives an error */
+		if (data_size == 0)
+			return FALSE;
+
+		if (*data == '\r') {
+			parser->line_size++;
+			data++; data_size--;
+			i_stream_skip(parser->input, 1);
+
+			if (data_size == 0)
+				return FALSE;
+		}
+
+		if (*data != '\n') {
+			parser->error = "Missing LF after literal size";
+			return FALSE;
+		}
+
+		parser->line_size++;
+		data++; data_size--;
+		i_stream_skip(parser->input, 1);
+
+		parser->literal_skip_crlf = FALSE;
+
+		i_assert(parser->cur_pos == 0);
+	}
+
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		/* now we just wait until we've read enough data */
+		if (data_size < parser->literal_size) {
+			return FALSE;
+		} else {
+			managesieve_parser_save_arg(parser, data,
+					     (size_t)parser->literal_size);
+			parser->cur_pos = (size_t)parser->literal_size;
+			return TRUE;
+		}
+	} else {
+		/* we want to save only literal size, not the literal itself. */
+		parser->eol = TRUE;
+		managesieve_parser_save_arg(parser, NULL, 0);
+		return TRUE;
+	}
+}
+
+/* Returns TRUE if argument was fully processed. Also returns TRUE if
+   an argument inside a list was processed. */
+static int managesieve_parser_read_arg(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+	if (data_size == 0)
+		return FALSE;
+
+	while (parser->cur_type == ARG_PARSE_NONE) {
+		/* we haven't started parsing yet */
+		if (!managesieve_parser_skip_to_next(parser, &data, &data_size))
+			return FALSE;
+		i_assert(parser->cur_pos == 0);
+
+		switch (data[0]) {
+		case '\r':
+		case '\n':
+			/* unexpected end of line */
+			parser->eol = TRUE;
+			return FALSE;
+		case '"':
+			parser->cur_type = ARG_PARSE_STRING;
+			parser->str_first_escape = -1;
+			break;
+		case '{':
+			parser->cur_type = ARG_PARSE_LITERAL;
+			parser->literal_size = 0;
+			parser->literal_nonsync = FALSE;
+			break;
+		default:
+			if (!is_valid_atom_char(parser, data[0]))
+				return FALSE;
+			parser->cur_type = ARG_PARSE_ATOM;
+			break;
+		}
+
+		parser->cur_pos++;
+	}
+
+	i_assert(data_size > 0);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		if (!managesieve_parser_read_atom(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_STRING:
+		if (!managesieve_parser_read_string(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_LITERAL:
+		if (!managesieve_parser_read_literal(parser, data, data_size))
+			return FALSE;
+
+		/* pass through to parsing data. since input->skip was
+		   modified, we need to get the data start position again. */
+		data = i_stream_get_data(parser->input, &data_size);
+
+		/* fall through */
+	case ARG_PARSE_LITERAL_DATA:
+		if (!managesieve_parser_read_literal_data(parser, data, data_size))
+			return FALSE;
+		break;
+	default:
+		i_unreached();
+	}
+
+	i_assert(parser->cur_type == ARG_PARSE_NONE);
+	return TRUE;
+}
+
+/* ARG_PARSE_NONE checks that last argument isn't only partially parsed. */
+#define IS_UNFINISHED(parser) \
+        ((parser)->cur_type != ARG_PARSE_NONE || \
+	 (parser)->cur_list != parser->root_list)
+
+static int finish_line(struct managesieve_parser *parser, unsigned int count,
+		       struct managesieve_arg **args)
+{
+	parser->line_size += parser->cur_pos;
+	i_stream_skip(parser->input, parser->cur_pos);
+	parser->cur_pos = 0;
+
+	if (count >= parser->root_list->alloc) {
+		/* unused arguments must be NIL-filled. */
+		parser->root_list =
+			LIST_REALLOC(parser, parser->root_list, count+1);
+		parser->root_list->alloc = count+1;
+	}
+
+	parser->root_list->args[parser->root_list->size].type = MANAGESIEVE_ARG_EOL;
+
+	*args = parser->root_list->args;
+	return parser->root_list->size;
+}
+
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args)
+{
+	parser->flags = flags;
+
+	while (!parser->eol && (count == 0 || parser->root_list->size < count ||
+				IS_UNFINISHED(parser))) {
+		if (!managesieve_parser_read_arg(parser))
+			break;
+
+		if (parser->line_size > parser->max_line_size) {
+			parser->error = "MANAGESIEVE command line too large";
+			break;
+		}
+	}
+
+	if (parser->error != NULL) {
+		/* error, abort */
+		parser->line_size += parser->cur_pos;
+		i_stream_skip(parser->input, parser->cur_pos);
+		parser->cur_pos = 0;
+		*args = NULL;
+		return -1;
+	} else if ((!IS_UNFINISHED(parser) && count > 0 &&
+		    parser->root_list->size >= count) || parser->eol) {
+		/* all arguments read / end of line. */
+                return finish_line(parser, count, args);
+	} else {
+		/* need more data */
+		*args = NULL;
+		return -2;
+	}
+}
+
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args)
+{
+	const unsigned char *data;
+	size_t data_size;
+	int ret;
+
+	ret = managesieve_parser_read_args(parser, count, flags, args);
+	if (ret == -2) {
+		/* we should have noticed end of everything except atom */
+		if (parser->cur_type == ARG_PARSE_ATOM) {
+			data = i_stream_get_data(parser->input, &data_size);
+			managesieve_parser_save_arg(parser, data, data_size);
+		}
+	}
+	return finish_line(parser, count, args);
+}
+
+const char *managesieve_parser_read_word(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == '\r' || data[i] == '\n')
+			break;
+	}
+
+	if (i < data_size) {
+		data_size = i + (data[i] == ' ' ? 1 : 0);
+		parser->line_size += data_size;
+		i_stream_skip(parser->input, data_size);
+		return p_strndup(parser->pool, data, i);
+	} else {
+		return NULL;
+	}
+}
+
+const char *managesieve_arg_string(struct managesieve_arg *arg)
+{
+	if (arg->type == MANAGESIEVE_ARG_STRING) 
+		return arg->_data.str;
+
+	return NULL;
+}
+
+int managesieve_arg_number
+	(struct managesieve_arg *arg, uoff_t *number)
+{
+	int i = 0;
+	const char *data;
+
+	*number = 0;
+
+	if (arg->type == MANAGESIEVE_ARG_ATOM) {
+		data = arg->_data.str;
+		while (data[i] != '\0') {
+			if (data[i] < '0' || data[i] > '9')
+				return -1;
+	
+			*number = (*number)*10 + (data[i] -'0');
+			i++;
+		}
+    
+		return 1;
+	}
+
+	return -1;
+}
+
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as string", arg->type);
+	return NULL;
+}
+
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as literal size", arg->type);
+	return 0;
+}
+
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as list", arg->type);
+	return NULL;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,192 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MANAGESIEVE_PARSER_H
+#define __MANAGESIEVE_PARSER_H
+
+/*
+ * QUOTED-SPECIALS    = <"> / "\"
+ */
+#define IS_QUOTED_SPECIAL(c) \
+	((c) == '"' || (c) == '\\')
+
+/* 
+ * ATOM-SPECIALS      = "(" / ")" / "{" / SP / CTL / QUOTED-SPECIALS
+ */
+#define IS_ATOM_SPECIAL(c) \
+	((c) == '(' || (c) == ')' || (c) == '{' || \
+	 (c) <= 32 || (c) == 0x7f || \
+	 IS_QUOTED_SPECIAL(c)) 
+
+/* 
+ * CHAR               = %x01-7F
+ */
+#define IS_CHAR(c) \
+	(((c) & 0x80) == 0)
+
+/* 
+ * TEXT-CHAR          = %x01-09 / %x0B-0C / %x0E-7F
+ *                       ;; any CHAR except CR and LF
+ */
+#define IS_TEXT_CHAR(c) \
+	(IS_CHAR(c) && (c) != '\r' && (c) != '\n')
+
+/*
+ * SAFE-CHAR          = %x01-09 / %x0B-0C / %x0E-21 /
+ *                      %x23-5B / %x5D-7F
+ *                      ;; any TEXT-CHAR except QUOTED-SPECIALS
+ */
+#define IS_SAFE_CHAR(c) \
+	(IS_TEXT_CHAR(c) && !IS_QUOTED_SPECIAL(c))
+
+/* UTF8-1             = %x80-BF
+ */
+#define IS_UTF8_1(c) \
+	(((c) & 0xC0) == 0x80)
+
+/* UTF8-2             = %xC0-DF UTF8-1
+ */
+#define IS_UTF8_2S(c) \
+  (((c) & 0xE0) == 0xC0)
+
+/* UTF8-3             = %xE0-EF 2UTF8-1
+ */
+#define IS_UTF8_3S(c) \
+  (((c) & 0xF0) == 0xE0)
+
+/* UTF8-4             = %xF0-F7 3UTF8-1
+ */
+#define IS_UTF8_4S(c) \
+  (((c) & 0xF8) == 0xF0)
+
+/* UTF8-5             = %xF8-FB 4UTF8-1
+ */
+#define IS_UTF8_5S(c) \
+  (((c) & 0xFC) == 0xF8)
+
+/* UTF8-6             = %xFC-FD 5UTF8-1
+ */
+#define IS_UTF8_6S(c) \
+  (((c) & 0xFE) == 0xFC)
+
+/* SAFE-UTF8-CHAR     = SAFE-CHAR / UTF8-2 / UTF8-3 / UTF8-4 /
+ *                      UTF8-5 / UTF8-6
+ */
+#define UTF8_LEN(c) \
+  ( IS_SAFE_CHAR(c) ? 1 : \
+    IS_UTF8_2S(c) ? 2 : \
+    IS_UTF8_3S(c) ? 3 : \
+    IS_UTF8_4S(c) ? 4 : \
+    IS_UTF8_5S(c) ? 5 : \
+    IS_UTF8_6S(c) ? 6 : 0 )
+
+enum managesieve_parser_flags {
+	/* Set this flag if you wish to read only size of literal argument
+	   and not convert literal into string. Useful when you need to deal
+	   with large literal sizes. The literal must be the last read
+	   parameter. */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE	= 0x01,
+	/* Don't remove '\' chars from string arguments */
+	MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE	= 0x02,
+	/* Return literals as MANAGESIEVE_ARG_LITERAL instead of MANAGESIEVE_ARG_STRING */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE	= 0x04
+};
+
+enum managesieve_arg_type {
+	MANAGESIEVE_ARG_ATOM = 0,
+	MANAGESIEVE_ARG_STRING,
+
+	/* literals are returned as MANAGESIEVE_ARG_STRING by default */
+	MANAGESIEVE_ARG_LITERAL,
+	MANAGESIEVE_ARG_LITERAL_SIZE,
+
+	MANAGESIEVE_ARG_EOL /* end of argument list */
+};
+
+struct managesieve_parser;
+
+struct managesieve_arg {
+	enum managesieve_arg_type type;
+
+	union {
+		char *str;
+		uoff_t literal_size;
+	} _data;
+};
+
+#define MANAGESIEVE_ARG_STR(arg) \
+	((arg)->type == MANAGESIEVE_ARG_STRING || \
+   (arg)->type == MANAGESIEVE_ARG_ATOM || \
+	 (arg)->type == MANAGESIEVE_ARG_LITERAL ? \
+	 (arg)->_data.str : _managesieve_arg_str_error(arg))
+
+#define MANAGESIEVE_ARG_LITERAL_SIZE(arg) \
+	(((arg)->type == MANAGESIEVE_ARG_LITERAL_SIZE) ? \
+	 (arg)->_data.literal_size : _managesieve_arg_literal_size_error(arg))
+
+struct managesieve_arg_list {
+	size_t size, alloc;
+	struct managesieve_arg args[1]; /* variable size */
+};
+
+
+/* Create new MANAGESIEVE argument parser. output is used for sending command
+   continuation requests for literals.
+
+   max_line_size can be used to approximately limit the maximum amount of
+   memory that gets allocated when parsing a line. Input buffer size limits
+   the maximum size of each parsed token.
+
+   Usually the largest lines are large only because they have a one huge
+   message set token, so you'll probably want to keep input buffer size the
+   same as max_line_size. That means the maximum memory usage is around
+   2 * max_line_size. */
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size);
+void managesieve_parser_destroy(struct managesieve_parser **parser);
+
+/* Reset the parser to initial state. */
+void managesieve_parser_reset(struct managesieve_parser *parser);
+
+/* Return the last error in parser. fatal is set to TRUE if there's no way to
+   continue parsing, currently only if too large non-sync literal size was
+   given. */
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal);
+
+/* Read a number of arguments. This function doesn't call i_stream_read(), you
+   need to do that. Returns number of arguments read (may be less than count
+   in case of EOL), -2 if more data is needed or -1 if error occurred.
+
+   count-sized array of arguments are stored into args when return value is
+   0 or larger. If all arguments weren't read, they're set to NIL. count
+   can be set to 0 to read all arguments in the line. Last element in
+   args is always of type MANAGESIEVE_ARG_EOL. */
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args);
+
+/* just like managesieve_parser_read_args(), but assume \n at end of data in
+   input stream. */
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args);
+
+/* Read one word - used for reading tag and command name.
+   Returns NULL if more data is needed. */
+const char *managesieve_parser_read_word(struct managesieve_parser *parser);
+
+/* Returns the managesieve argument as string. If it is no string this returns NULL */
+const char *managesieve_arg_string(struct managesieve_arg *arg);
+
+/* Returns 1 if the argument is a number. If it is no number this returns -1.
+ * The number itself is stored in *number.
+ */
+int managesieve_arg_number
+  (struct managesieve_arg *arg, uoff_t *number);
+
+/* Error functions */
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg);
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg);
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c
--- dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,179 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+/* Turn the value string into a valid MANAGESIEVE string or literal, no matter 
+ * what. QUOTED-SPECIALS are escaped, but any invalid (UTF-8) character
+ * is simply removed. Linebreak characters are not considered invalid, but
+ * they do force the generation of a string literal.
+ */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp)
+{
+	size_t i, extra = 0;
+	bool 
+		last_lwsp = TRUE, 
+		literal = FALSE, 
+		modify = FALSE,
+		escape = FALSE;
+	int utf8_len;
+
+ 	if (value == NULL) {
+		str_append(str, "\"\"");
+		return;
+	}
+
+	if (value_len == (size_t)-1)
+		value_len = strlen((const char *) value);
+
+	for (i = 0; i < value_len; i++) {
+		switch (value[i]) {
+		case ' ':
+		case '\t':
+			if (last_lwsp && compress_lwsp) {
+				modify = TRUE;
+				extra++;
+			}
+			last_lwsp = TRUE;
+			break;
+		case '"':
+		case '\\':
+			escape = TRUE;
+			last_lwsp = FALSE;
+			break;
+		case 13:
+		case 10:
+			literal = TRUE;
+			last_lwsp = TRUE;
+			break;
+		default:
+			/* Enforce valid UTF-8
+			 */
+			if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) {
+				modify = TRUE;
+				extra++;
+				break;
+			}
+
+			if ( utf8_len > 1 ) {
+				int c = utf8_len - 1;
+
+		 		if ( (i+utf8_len-1) >= value_len ) {
+				  	/* Value ends in the middle of a UTF-8 character;
+					 * Kill the partial UTF-8 character
+					 */
+				  	extra += i + utf8_len - value_len;
+					modify = TRUE;
+					break;        	
+				}
+
+				/* Parse the series of UTF8_1 characters */
+				for (i++; c > 0; c--, i++ ) {
+					if (!IS_UTF8_1(value[i])) {
+						extra += utf8_len - c;
+						modify = TRUE;
+						break;
+					}
+				}
+			}
+   			
+			last_lwsp = FALSE;
+		}
+	}
+
+	if (!literal) {
+		/* no linebreak chars, return as (escaped) "string" */
+		str_append_c(str, '"');
+	} else {
+		/* return as literal */
+		str_printfa(str, "{%"PRIuSIZE_T"}\r\n", value_len - extra);
+	}
+
+	if (!modify && (literal || !escape))
+		str_append_n(str, value, value_len);
+	else {
+		last_lwsp = TRUE;
+		for (i = 0; i < value_len; i++) {
+			switch (value[i]) {
+			case '"':
+			case '\\':
+				last_lwsp = FALSE;
+				if (!literal) 
+					str_append_c(str, '\\');
+				str_append_c(str, value[i]);
+				break;
+			case ' ':
+			case '\t':
+				if (!last_lwsp || !compress_lwsp)
+					str_append_c(str, ' ');
+				last_lwsp = TRUE;
+				break;
+			case 13:
+			case 10:
+				last_lwsp = TRUE;
+				str_append_c(str, value[i]);
+				break;
+			default:
+	  			/* Enforce valid UTF-8
+				 */
+				if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) 
+					break;
+      
+				if ( utf8_len > 1 ) {
+					int c = utf8_len - 1;
+					int j;
+
+					if ( (i+utf8_len-1) >= value_len ) {
+						/* Value ends in the middle of a UTF-8 character;
+						 * Kill the partial character
+						 */
+					 	i = value_len;
+						break;
+					}
+
+					/* Parse the series of UTF8_1 characters */
+					for (j = i+1; c > 0; c--, j++ ) {
+						if (!IS_UTF8_1(value[j])) {
+							/* Skip until after this erroneous character */
+							i = j;
+							break;
+						}
+					}
+
+					/* Append the UTF-8 character. Last octet is done later */
+					c = utf8_len - 1;
+					for (; c > 0; c--, i++ ) 
+						str_append_c(str, value[i]);
+				}
+     
+				last_lwsp = FALSE;
+				str_append_c(str, value[i]);
+				break;
+			}
+		}
+	}
+
+	if (!literal)
+		str_append_c(str, '"');
+}
+
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len)
+{
+	string_t *str;
+	char *ret;
+
+	if (value == NULL)
+		return "\"\"";
+
+	t_push();
+	str = t_str_new(value_len + MAX_INT_STRLEN + 5);
+	managesieve_quote_append(str, value, value_len, TRUE);
+	ret = p_strndup(pool, str_data(str), str_len(str));
+	t_pop();
+
+	return ret;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,20 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __IMAP_QUOTE_H
+#define __IMAP_QUOTE_H
+
+/* Return value suitable for sending to client, either as quoted-string or
+   literal. Note that this also converts TABs into spaces, multiple spaces
+   into single space and NULs to #128. */
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len);
+
+/* Append to existing string. */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp);
+
+#define managesieve_quote_append_string(str, value, compress_lwsp) \
+	managesieve_quote_append(str, (const unsigned char *)(value), \
+			  (size_t)-1, compress_lwsp)
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/Makefile.am dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/Makefile.am
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/Makefile.am	2008-11-17 18:52:34.000000000 +0000
@@ -0,0 +1,22 @@
+noinst_LIBRARIES = libsievestorage.a
+
+INCLUDES = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(docecot_incdir)/src/lib-mail \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+libsievestorage_a_SOURCES = \
+	sieve-storage-save.c \
+	sieve-storage-script.c \
+	sieve-storage-list.c \
+	sieve-storage.c 
+
+noinst_HEADERS = \
+	sieve-storage-error.h \
+	sieve-storage-save.h \
+	sieve-storage-script.h \
+	sieve-storage-list.h \
+	sieve-storage-private.h \
+	sieve-storage.h
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c	2009-06-28 13:36:33.000000000 +0000
@@ -0,0 +1,519 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "home-expand.h"
+#include "ioloop.h"
+#include "mkdir-parents.h"
+
+#include "sieve.h"
+#include "sieve-error-private.h"
+
+#include "sieve-storage-private.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define MAX_DIR_CREATE_MODE 0770
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+static void sieve_storage_verror
+	(struct sieve_error_handler *ehandler ATTR_UNUSED, 
+		const char *location ATTR_UNUSED, const char *fmt, va_list args);
+
+static const char *sieve_get_active_script_path(void)
+{
+  const char *script_path, *home;
+
+  home = getenv("HOME");
+
+  /* userdb may specify Sieve path */
+  script_path = getenv("SIEVE");
+  if (script_path != NULL) {
+	if (*script_path == '\0') {
+		/* disabled */
+		return NULL;
+	}
+
+    if ( *script_path != '/' && *script_path != '~') {
+      /* relative path. change to absolute. */
+      script_path = t_strconcat(getenv("HOME"), "/",  
+        script_path, NULL);
+    }
+  } else {
+    if (home == NULL) {
+      /* we must have a home directory */
+      i_error("sieve-storage: userdb(%s) didn't return a home directory or "
+        "sieve script location, can't find it",
+        getenv("USER"));
+      return NULL;
+    }
+
+    script_path = SIEVE_SCRIPT_PATH;
+  }
+
+  /* No need to check for existance here */
+
+  return script_path;
+}
+
+/* Obtain the directory for script storage from the mail location
+ */
+static const char *sieve_storage_get_dir_from_mail(const char *data)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	struct stat st;
+	size_t len;
+	const char *root_dir, *dir, *p, *d;
+
+	root_dir = dir = d = NULL;
+
+	if (debug)
+		i_info("sieve-storage: using mail-data: %s", data);
+
+	/* check if we're in the form of mailformat:data
+	   (eg. maildir:Maildir) */
+	p = data;
+	while (i_isalnum(*p)) p++;
+	
+	if (*p == ':') {
+		d = p+1;
+	} else {
+		d = data;
+	}
+
+	if (d == NULL || *d == '\0') {
+		/* Ok, this is bad. Check whether we might be chrooted, bail out otherwise */
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0)
+			root_dir = "/";
+		else {
+			i_error("sieve-storage: sieve storage directory not given and mail root provides no alternative.");
+            return NULL;
+		}
+	} else {
+		/* <scriptdir> */
+		p = strchr(d, ':');
+		if (p == NULL)
+			/* No additional parameters */
+			root_dir = d;
+		else {
+			dir = t_strdup_until(d, p);
+ 
+			do {
+				p++;
+				/* Use control dir as script dir if specified */
+				if (strncmp(p, "CONTROL=", 8) == 0)
+					root_dir = t_strcut(p+8, ':');
+				p = strchr(p, ':');
+			} while (p != NULL);
+			
+			if ( root_dir == NULL || *root_dir == '\0' )
+				root_dir = dir;
+		}
+	}
+
+	/* Not found */
+	if ( root_dir == NULL || *root_dir == '\0' ) {
+		if (debug)
+			i_info("sieve-storage: couldn't find root dir from mail-data.");
+		return NULL;
+	}
+
+	/* Strip trailing '/' */
+	len = strlen(root_dir);
+	if (root_dir[len-1] == '/')
+		root_dir = t_strndup(root_dir, len-1);
+
+	root_dir = home_expand(root_dir);
+
+	/* Superior mail directory must exist; it is never auto-created by the 
+	 * sieve-storage.
+ 	 */
+	if (stat(root_dir, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			i_error("sieve-storage: root dir from mail data: stat(%s) failed: %m", root_dir);
+			return NULL;
+		} else {
+			i_error("sieve-storage: root directory specified by mail data does not exist: %s", root_dir);
+			return NULL;
+		}
+	} 
+
+	/* Never store scripts directly in the root of the mail or mail:CONTROl directory.
+	 */
+	root_dir = t_strconcat( root_dir, "/sieve", NULL );
+
+	return root_dir;
+}
+
+static const char *sieve_storage_get_relative_link_path
+	(const char *active_path, const char *storage_dir) 
+{
+	const char *link_path, *p;
+	size_t pathlen;
+	
+	/* Determine to what extent the sieve storage and active script 
+	 * paths match up. This enables the managed symlink to be short and the 
+	 * sieve storages can be moved around without trouble (if the active 
+	 * script path is common to the script storage).
+	 */		
+	p = strrchr(active_path, '/');
+	if ( p == NULL ) {
+		link_path = storage_dir;
+	} else { 
+		pathlen = p - active_path;
+
+		if ( strncmp( active_path, storage_dir, pathlen ) == 0 &&
+			(storage_dir[pathlen] == '/' || storage_dir[pathlen] == '\0') ) 
+		{
+			if ( storage_dir[pathlen] == '\0' ) 
+				link_path = ""; 
+			else 
+				link_path = storage_dir + pathlen + 1;
+		} else 
+			link_path = storage_dir;
+	}
+
+	/* Add trailing '/' when link path is not empty 
+	 */
+	pathlen = strlen(link_path);
+    if ( pathlen != 0 && link_path[pathlen-1] != '/')
+        return t_strconcat(link_path, "/", NULL);
+
+	return t_strdup(link_path);
+}
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user)
+{
+	struct sieve_storage *storage;
+	const char *storage_dir;
+
+	t_push();
+
+	storage_dir = sieve_storage_get_dir_from_mail(data);
+	if (storage_dir == NULL) {
+		if (getenv("DEBUG") != NULL)
+			i_info("sieve-storage: failed to obtain storage directory from mail-data.");
+		t_pop();
+		return NULL;
+	} 
+
+	storage = sieve_storage_create(storage_dir, user);
+
+	t_pop();
+
+	return storage;
+}
+
+static int sieve_storage_verify_dir
+(const char *path, mode_t *mode_r, gid_t *gid_r)
+{
+	struct stat st;
+
+	if ( stat(path, &st) < 0 ) {
+		const char *p;
+		int ret;
+
+		if ( errno != ENOENT )
+			return -1;
+
+		/* Ascend to parent path element */
+        p = strrchr(path, '/');
+
+		/* Path components exhausted? */
+        if  (p == NULL || p == path )
+            return -1;
+
+		/* Recurse */
+		T_BEGIN {
+            ret = sieve_storage_verify_dir(t_strdup_until(path, p), mode_r, gid_r);
+        } T_END;
+
+        if ( ret < 0 )
+            return -1;
+
+		if ( mkdir_chown(path, *mode_r, (uid_t) -1, *gid_r) < 0 )
+			return -1;
+
+		return 0;
+    }  
+
+	/* Report back permission bits and group id back to caller */
+
+	if ( !S_ISDIR(st.st_mode) ) {
+		i_error("sieve-storage: Path is not a directory: %s", path);
+		return -1;
+	}
+		
+	*mode_r = st.st_mode & MAX_DIR_CREATE_MODE & 0777;
+
+	/* Check whether changing GID will be necessary */
+	if ( (st.st_mode & S_ISGID) != 0 ) {
+		/* Setgid bit set */
+		*gid_r = (gid_t) -1;
+	} else if ( getegid() == st.st_gid ) {
+		*gid_r = (gid_t) -1;
+	} else {
+		*gid_r = st.st_gid;
+	}
+
+	return 0;
+}
+
+struct sieve_storage *sieve_storage_create(const char *data, const char *user)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	pool_t pool;
+	struct sieve_storage *storage;
+	const char *home, *tmp_dir, *link_path;
+	const char *active_path, *active_fname, *storage_dir;
+	mode_t dir_mode;
+	gid_t dir_gid;
+
+	t_push();
+
+	/* Find out where the active script is stored (e.g. ~/.dovecot.sieve) */
+
+	active_path = sieve_get_active_script_path();
+	if (active_path == NULL) {
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+
+	/* Get the filename for the active script link */
+
+	active_fname = strrchr(active_path, '/');
+	if ( active_fname == NULL ) 
+		active_fname = active_path;
+	else
+		active_fname++;
+
+	if ( *active_fname == '\0' ) {	
+		/* Link cannot be just a path */
+		i_error("sieve-storage: Path to active symlink must include the link's filename. Path is: %s", 
+			active_path);
+
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+
+	/* Find out where to put the script storage */
+
+	storage_dir = NULL;
+
+	if ( data == NULL || *data == '\0' ) {
+		/* We'll need to figure out the storage location ourself.
+		 *
+		 * It's $HOME/sieve or /sieve when (presumed to be) chrooted.  
+		 */
+		home = getenv("HOME");
+		if ( home != NULL && *home != '\0' ) {
+			if (access(home, R_OK|W_OK|X_OK) == 0) {
+				/* Use default ~/sieve */
+
+				if (debug) {
+					i_info("sieve-storage: root exists (%s)",
+						home);
+				}
+
+				storage_dir = home_expand_tilde("~/sieve", home);
+			} else {
+				/* Don't have required access on the home directory */
+
+				if (debug) {
+					i_info("sieve-storage: access(%s, rwx): "
+						"failed: %m", home);
+				}
+			}
+		} else {
+			if (debug)
+				i_info("sieve-storage: HOME not set");
+		}
+
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0) {
+			storage_dir = "/sieve";
+			if (debug)
+				i_info("sieve-storage: /sieve exists, assuming chroot");
+		}
+	} else {
+		storage_dir = data;
+	}
+
+	if (storage_dir == NULL || *storage_dir == '\0') {
+		if (debug)
+			i_info("sieve-storage: couldn't find storage dir");
+		t_pop();
+		return NULL;
+	}
+
+	if (debug)
+ 		i_info("sieve-storage: using sieve script storage directory: %s", storage_dir);    
+
+	/* Expand home directories in path */
+	storage_dir = home_expand(storage_dir);
+	active_path = home_expand(active_path);
+
+	/* Ensure sieve local directory structure exists (full autocreate):
+	 *  This currently currently only consists of a ./tmp direcory
+	 */
+	tmp_dir = t_strconcat( storage_dir, "/tmp", NULL );	
+	if ( sieve_storage_verify_dir(tmp_dir, &dir_mode, &dir_gid) < 0 ) {
+		i_error("sieve-storage: sieve_storage_verify_dir(%s) failed: %m", tmp_dir);
+		t_pop();
+		return NULL;
+	}
+
+	/* Create storage object */
+	pool = pool_alloconly_create("sieve-storage", 512+256);
+	storage = p_new(pool, struct sieve_storage, 1);	
+	storage->pool = pool;
+	storage->dir = p_strdup(pool, storage_dir);
+	storage->user = p_strdup(pool, user);
+	storage->active_path = p_strdup(pool, active_path);
+	storage->active_fname = p_strdup(pool, active_fname);
+
+	storage->dir_create_mode = dir_mode;
+	storage->file_create_mode = dir_mode & 0666;
+	storage->dir_create_gid = dir_gid;
+
+	/* Get the path to be prefixed to the script name in the symlink pointing 
+	 * to the active script.
+	 */
+	link_path = sieve_storage_get_relative_link_path
+		(storage->active_path, storage->dir);
+
+	if (debug)
+		i_info("sieve-storage: relative path to sieve storage in active link: %s", link_path);
+
+	storage->link_path = p_strdup(pool, link_path);
+
+	t_pop();
+
+	return storage;
+}
+
+void sieve_storage_free(struct sieve_storage *storage)
+{
+	sieve_error_handler_unref(&storage->ehandler);
+
+	pool_unref(&storage->pool);
+}
+
+/* Error handling */
+
+struct sieve_error_handler *sieve_storage_get_error_handler(struct sieve_storage *storage)
+{
+	struct sieve_storage_ehandler *ehandler;
+
+	if ( storage->ehandler == NULL ) {
+		pool_t pool = pool_alloconly_create("sieve_storage_ehandler", 512);
+		ehandler = p_new(pool, struct sieve_storage_ehandler,1);
+		sieve_error_handler_init(&ehandler->handler, pool, 1);
+
+		ehandler->handler.verror = sieve_storage_verror;
+		ehandler->storage = storage;
+		
+		storage->ehandler = (struct sieve_error_handler *) ehandler;
+	}
+
+	return storage->ehandler;
+}
+
+static void sieve_storage_verror
+(struct sieve_error_handler *ehandler, const char *location ATTR_UNUSED,
+    const char *fmt, va_list args)
+{
+	struct sieve_storage_ehandler *sehandler = (struct sieve_storage_ehandler *) ehandler; 
+	struct sieve_storage *storage = sehandler->storage;
+
+	sieve_storage_clear_error(storage);
+	
+	if (fmt != NULL) {
+        storage->error = i_strdup_vprintf(fmt, args);
+    }
+}
+
+void sieve_storage_clear_error(struct sieve_storage *storage)
+{
+	i_free(storage->error);
+	storage->error = NULL;
+}
+
+void sieve_storage_set_error
+(struct sieve_storage *storage, enum sieve_storage_error error, const char *fmt, ...)
+{
+	va_list va;
+
+	sieve_storage_clear_error(storage);
+
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		storage->error = i_strdup_vprintf(fmt, va);
+		va_end(va);
+	}
+
+	storage->error_code = error;
+}
+
+void sieve_storage_set_internal_error(struct sieve_storage *storage)
+{
+	struct tm *tm;
+	char str[256];
+
+	tm = localtime(&ioloop_time);
+
+	i_free(storage->error);
+	storage->error_code = SIEVE_STORAGE_ERROR_TEMP;
+	storage->error =
+	  strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+	  i_strdup(str) : i_strdup(CRITICAL_MSG);
+}
+
+void sieve_storage_set_critical(struct sieve_storage *storage,
+             const char *fmt, ...)
+{
+	va_list va;
+	
+	sieve_storage_clear_error(storage);
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		i_error("sieve-storage: %s", t_strdup_vprintf(fmt, va));
+		va_end(va);
+		
+		/* critical errors may contain sensitive data, so let user
+		   see only "Internal error" with a timestamp to make it
+		   easier to look from log files the actual error message. */
+		sieve_storage_set_internal_error(storage);
+	}
+}
+
+const char *sieve_storage_get_last_error
+	(struct sieve_storage *storage, enum sieve_storage_error *error_r)
+{
+	/* We get here only in error situations, so we have to return some
+	   error. If storage->error is NULL, it means we forgot to set it at
+	   some point.. 
+	 */
+  
+	if ( error_r != NULL ) 
+		*error_r = storage->error_code;
+
+	return storage->error != NULL ? storage->error : "Unknown error";
+}
+
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,32 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_ERROR_H
+#define __SIEVE_STORAGE_ERROR_H
+
+enum sieve_storage_error {
+	SIEVE_STORAGE_ERROR_NONE = 0,
+
+        /* Temporary internal error */
+        SIEVE_STORAGE_ERROR_TEMP,
+
+        /* It's not possible to do the wanted operation */
+        SIEVE_STORAGE_ERROR_IMPOSSIBLE,
+
+	/* Quota exceeded */
+        SIEVE_STORAGE_ERROR_QUOTA,
+
+        /* Out of disk space */	
+        SIEVE_STORAGE_ERROR_NOSPACE,
+
+	/* Script does not exist */
+        SIEVE_STORAGE_ERROR_NOTFOUND,
+
+	/* Operation not allowed on active script */
+	SIEVE_STORAGE_ERROR_ACTIVE,
+
+	/* Operation not allowed on existing script */
+	SIEVE_STORAGE_ERROR_EXISTS
+};
+
+#endif /* __SIEVE_STORAGE_ERROR_H */
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,31 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_H
+#define __SIEVE_STORAGE_H
+
+#include "sieve-storage-error.h"
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user);
+struct sieve_storage *sieve_storage_create(const char *data, const char *user);
+void sieve_storage_free(struct sieve_storage *storage);
+
+struct sieve_error_handler *sieve_storage_get_error_handler(struct sieve_storage *storage);
+
+/* Set error message in storage. Critical errors are logged with i_error(),
+   but user sees only "internal error" message. */
+void sieve_storage_clear_error(struct sieve_storage *storage);
+
+void sieve_storage_set_error
+	(struct sieve_storage *storage, enum sieve_storage_error error, const char *fmt, ...)
+		ATTR_FORMAT(3, 4);
+
+void sieve_storage_set_critical(struct sieve_storage *storage,
+	const char *fmt, ...) ATTR_FORMAT(2, 3);
+
+void sieve_storage_set_internal_error(struct sieve_storage *storage);
+
+const char *sieve_storage_get_last_error
+	(struct sieve_storage *storage, enum sieve_storage_error *error_r);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,115 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-list.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context {
+	pool_t pool;
+	struct sieve_storage *storage;
+
+	const char *active;
+	const char *dir;
+	DIR *dirp;
+
+	unsigned int seen_active:1; // Just present for assertions
+};
+
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage)
+{	
+	struct sieve_list_context *ctx;
+	const char *active;
+	pool_t pool;
+	DIR *dirp;
+
+	/* Open the directory */
+	if ( (dirp = opendir(storage->dir)) == NULL ) {
+		sieve_storage_set_critical(storage, "opendir(%s) failed: %m",
+					   storage->dir);
+		return NULL;
+	}
+
+	t_push();
+
+	/* Get the name of the active script */
+	if ( (active = sieve_storage_get_active_scriptfile(storage)) 
+		== NULL ) {
+		t_pop();
+		return NULL;
+	}
+
+	pool = pool_alloconly_create("sieve_list_context", 4096);
+	ctx = p_new(pool, struct sieve_list_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->dirp = dirp;
+	ctx->active = p_strdup(pool, active);
+	ctx->seen_active = FALSE;
+
+	t_pop();
+
+	return ctx;
+}
+
+const char *sieve_storage_list_next
+	(struct sieve_list_context *ctx, bool *active)
+{
+	const struct sieve_storage *storage = ctx->storage;
+	struct dirent *dp;
+	const char *scriptname;
+
+	*active = FALSE;
+
+	for (;;) {
+		if ( (dp = readdir(ctx->dirp)) == NULL )
+			return NULL;
+
+		scriptname = sieve_storage_file_get_scriptname
+			(storage, dp->d_name);	
+		
+		if (scriptname != NULL ) {
+			/* Don't list our active sieve script link if the link 
+			 * resides in the script dir (generally a bad idea).
+			 */
+			if ( *(storage->link_path) == '\0' && 
+				strcmp(storage->active_fname, dp->d_name) == 0 )
+				continue;
+		
+			break;
+		}
+	}
+
+	if ( ctx->active != NULL && 
+		strcmp(dp->d_name, ctx->active) == 0 ) {
+		*active = TRUE;
+		ctx->active = NULL;
+	}
+
+	return scriptname;
+}
+
+int sieve_storage_list_deinit(struct sieve_list_context **ctx)
+{
+	if (closedir((*ctx)->dirp) < 0) {
+		sieve_storage_set_critical((*ctx)->storage, "closedir(%s) failed: %m",
+					   (*ctx)->storage->dir);
+	}
+
+	pool_unref(&(*ctx)->pool);
+	*ctx = NULL;
+	return 1;
+}
+
+
+	
+    
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,32 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_LIST_H
+#define __SIEVE_STORAGE_LIST_H
+
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context;
+
+/* Create a context for listing the scripts in the storage */
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage);
+
+/* Get the next script in the storage. */
+const char *sieve_storage_list_next(struct sieve_list_context *ctx, bool *active);
+
+/* Destroy the listing context */
+int sieve_storage_list_deinit(struct sieve_list_context **ctx);
+
+#endif
+
+
+	
+    
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h	2009-06-28 13:35:39.000000000 +0000
@@ -0,0 +1,58 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_PRIVATE_H
+#define __SIEVE_STORAGE_PRIVATE_H
+
+#include "sieve.h"
+#include "sieve-error-private.h"
+
+#include "sieve-storage.h"
+
+
+enum sieve_storage_flags {
+	/* Print debugging information while initializing the storage */
+	SIEVE_STORAGE_FLAG_DEBUG     = 0x01,
+	/* Use CRLF linefeeds when saving mails. */
+	SIEVE_STORAGE_FLAG_SAVE_CRLF   = 0x02,
+};
+
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+struct sieve_storage;
+
+struct sieve_storage_ehandler {
+	struct sieve_error_handler handler;
+	struct sieve_storage *storage;
+};
+
+/* All methods returning int return either TRUE or FALSE. */
+struct sieve_storage {
+	pool_t pool;
+	char *name;
+	char *dir;
+
+	/* Private */	
+	char *active_path;
+	char *active_fname;
+	char *link_path;
+	char *error;
+	char *user; /* name of user accessing the storage */
+
+	mode_t dir_create_mode;
+	mode_t file_create_mode;
+	gid_t dir_create_gid;
+
+	enum sieve_storage_error error_code;
+
+	struct sieve_error_handler *ehandler;
+
+	enum sieve_storage_flags flags;
+};
+
+struct sieve_script *sieve_storage_script_init_from_path
+	(struct sieve_storage *storage, const char *path, 
+		const char *scriptname, bool *exists_r);
+
+#endif
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c	2009-06-28 13:35:17.000000000 +0000
@@ -0,0 +1,346 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "array.h"
+#include "buffer.h"
+#include "ostream.h"
+#include "str.h"
+
+#include "sieve-script.h"
+
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-save.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <utime.h>
+#include <sys/stat.h>
+
+struct sieve_save_context {
+	pool_t pool;
+
+	struct sieve_storage *storage;
+	const char *scriptname;
+	struct sieve_script *scriptobject;
+
+	struct istream *input;
+	struct ostream *output;
+	int fd;
+	const char *tmp_path;
+
+	unsigned int failed:1;
+	unsigned int moving:1;
+	unsigned int finished:1;
+};
+
+static const char *sieve_generate_tmp_filename(const char *scriptname)
+{
+	static struct timeval last_tv = { 0, 0 };
+	struct timeval tv;
+
+	/* use secs + usecs to guarantee uniqueness within this process. */
+	if (ioloop_timeval.tv_sec > last_tv.tv_sec ||
+		(ioloop_timeval.tv_sec == last_tv.tv_sec &&
+		ioloop_timeval.tv_usec > last_tv.tv_usec)) {
+		tv = ioloop_timeval;
+	} else {
+		tv = last_tv;
+		if (++tv.tv_usec == 1000000) {
+			tv.tv_sec++;
+			tv.tv_usec = 0;
+		}
+	}
+	last_tv = tv;
+
+	if ( scriptname == NULL )
+		return t_strdup_printf("NULL_%s.M%sP%s.%s.sieve", dec2str(tv.tv_sec), 
+			dec2str(tv.tv_usec), my_pid, my_hostname);
+
+	return t_strdup_printf("%s-%s.M%sP%s.%s.sieve", scriptname, dec2str(tv.tv_sec), 
+		dec2str(tv.tv_usec), my_pid, my_hostname);
+}
+
+static int sieve_storage_create_tmp
+(struct sieve_storage *storage, const char *scriptname, const char **fpath_r)
+{
+	struct stat st;
+	unsigned int prefix_len;
+	const char *tmp_fname = NULL;
+	string_t *path;
+	int fd;
+
+	path = t_str_new(256);	
+	str_append(path, storage->dir);
+	str_append(path, "/tmp/");
+	prefix_len = str_len(path);
+
+	for (;;) {
+		tmp_fname = sieve_generate_tmp_filename(scriptname);
+		str_truncate(path, prefix_len);
+		str_append(path, tmp_fname);
+
+		/* stat() first to see if it exists. pretty much the only
+		   possibility of that happening is if time had moved
+		   backwards, but even then it's highly unlikely. */
+		if (stat(str_c(path), &st) == 0) {
+			/* try another file name */	
+		} else if (errno != ENOENT) {
+			sieve_storage_set_critical(storage,
+				"stat(%s) failed: %m", str_c(path));
+			return -1;
+		} else {
+			/* doesn't exist */
+			mode_t old_mask = umask(0777 & ~(storage->file_create_mode));
+			fd = open(str_c(path),
+				O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0777);
+			umask(old_mask);
+
+			if (fd != -1 || errno != EEXIST)
+				break;
+			/* race condition between stat() and open().
+				highly unlikely. */
+		}
+	}
+
+    *fpath_r = str_c(path);
+    if (fd == -1) {
+        if (ENOSPACE(errno)) {
+            sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_NOSPACE,
+							"Not enough disk space");
+        } else {
+            sieve_storage_set_critical(storage,
+							"open(%s) failed: %m", str_c(path));
+        }
+    } 
+
+    return fd;
+}
+
+
+static int sieve_storage_script_move(struct sieve_save_context *ctx,
+  const char *dst)
+{
+	int failed;
+
+	t_push();
+
+	/* Using rename() to ensure existing files are replaced
+	 * without conflicts with other processes using the same
+	 * file. The kernel wont fully delete the original until
+	 * all processes have closed the file.
+	 */
+	if (rename(ctx->tmp_path, dst) == 0)
+		failed = FALSE;
+	else {
+		failed = TRUE;
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error
+			  (ctx->storage, SIEVE_STORAGE_ERROR_NOSPACE, "Not enough disk space");
+		} else {
+			sieve_storage_set_critical
+			  (ctx->storage, "link(%s, %s) failed: %m", ctx->tmp_path, dst);
+		}
+	}
+
+	/* Always destroy temp file */
+	(void)unlink(ctx->tmp_path);
+
+	t_pop();
+	return !failed;
+}
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input)
+{
+	struct sieve_save_context *ctx;
+	pool_t pool;
+	const char *path;
+
+	if ( scriptname != NULL ) {
+		/* Disallow '/' characters in script name */
+		if ( strchr(scriptname, '/') != NULL ) {
+			sieve_storage_set_error(storage, 
+				SIEVE_STORAGE_ERROR_IMPOSSIBLE,
+				"Invalid script name '%s'.", scriptname);
+			return NULL;
+		}
+
+		/* Prevent overwriting the active script link when it resides in the 
+		 * sieve storage directory.
+		 */
+		if ( *(storage->link_path) == '\0' ) {
+			const char *svext;
+			size_t namelen;
+
+			svext = strrchr(storage->active_fname, '.');
+			namelen = svext - storage->active_fname;
+			if ( svext != NULL && strncmp(svext+1, "sieve", 5) == 0 &&
+				strlen(scriptname) == namelen && 
+				strncmp(scriptname, storage->active_fname, namelen) == 0 ) 
+			{
+				sieve_storage_set_error(
+					storage, SIEVE_STORAGE_ERROR_IMPOSSIBLE, 
+					"Script name '%s' is reserved for internal use.", scriptname); 
+				return NULL;
+			}
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_save_context", 4096);
+	ctx = p_new(pool, struct sieve_save_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->scriptname = scriptname;
+	ctx->scriptobject = NULL;
+
+	T_BEGIN {
+		ctx->fd = sieve_storage_create_tmp(storage, scriptname, &path);
+		if (ctx->fd == -1) {
+			ctx->failed = TRUE;
+			pool_unref(&pool);
+			ctx = NULL;
+		} else {
+			ctx->input = input;
+			ctx->output = o_stream_create_fd(ctx->fd, 0, FALSE);
+			ctx->tmp_path = p_strdup(pool, path);
+			ctx->failed = FALSE;
+		}
+	} T_END;
+
+	return ctx;
+}
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx)
+{
+	if (o_stream_send_istream(ctx->output, ctx->input) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+		return -1;
+	}
+	return 0;
+}
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx)
+{
+	int output_errno;
+
+	ctx->finished = TRUE;
+	if (ctx->failed && ctx->fd == -1) {
+		/* tmp file creation failed */
+		return -1;
+	}
+
+	t_push();
+	output_errno = ctx->output->stream_errno;
+	o_stream_destroy(&ctx->output);
+
+	if (fsync(ctx->fd) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+					  "fsync(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+	}
+	if (close(ctx->fd) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+					  "close(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+	}
+	ctx->fd = -1;
+
+	if (ctx->failed) {
+		/* delete the tmp file */
+		if (unlink(ctx->tmp_path) < 0 && errno != ENOENT) 
+			i_warning("sieve-storage: Unlink(%s) failed: %m", ctx->tmp_path);
+
+		errno = output_errno;
+		if (ENOSPACE(errno)) {
+			sieve_storage_set_error(ctx->storage, SIEVE_STORAGE_ERROR_NOSPACE,
+					       "Not enough disk space");
+		} else if (errno != 0) {
+			sieve_storage_set_critical(ctx->storage,
+				"write(%s) failed: %m", ctx->tmp_path);
+		}
+
+		t_pop();
+		return -1;
+	}
+	t_pop();
+
+	return 0;
+}
+
+static void sieve_storage_save_destroy(struct sieve_save_context **ctx)
+{
+	if ((*ctx)->scriptobject != NULL)
+		sieve_script_unref(&((*ctx)->scriptobject));
+
+	pool_unref(&(*ctx)->pool);
+	*ctx = NULL;
+}
+
+struct sieve_script *sieve_storage_save_get_tempscript
+(struct sieve_save_context *ctx)
+{
+	const char *scriptname = 
+		( ctx->scriptname == NULL ? "" : ctx->scriptname ); 
+	bool exists = FALSE;
+
+	if (ctx->failed) 
+		return NULL;
+
+	ctx->scriptobject = sieve_storage_script_init_from_path
+		(ctx->storage, ctx->tmp_path, scriptname, &exists);	
+
+	if ( !exists ) {
+		sieve_storage_set_critical(ctx->storage, 
+			"save: Temporary script file with name '%s' got lost, "
+			"which should not happen (possibly deleted externally).", 
+			ctx->tmp_path);
+		sieve_script_unref(&ctx->scriptobject);
+		return NULL;
+	}
+
+	return ctx->scriptobject;
+}
+
+int sieve_storage_save_commit(struct sieve_save_context **ctx)
+{
+	const char *dest_path;
+	bool failed = FALSE;
+
+	i_assert((*ctx)->output == NULL);
+	i_assert((*ctx)->finished);
+	i_assert((*ctx)->scriptname != NULL);
+
+	T_BEGIN {
+		dest_path = t_strconcat((*ctx)->storage->dir, "/", 
+			(*ctx)->scriptname, ".sieve", NULL);
+
+		failed = !sieve_storage_script_move((*ctx), dest_path);
+	} T_END;
+
+	sieve_storage_save_destroy(ctx);
+
+	return !failed;
+}
+
+void sieve_storage_save_cancel(struct sieve_save_context **ctx)
+{
+	(*ctx)->failed = TRUE;
+
+	if (!(*ctx)->finished) 
+		(void)sieve_storage_save_finish(*ctx);
+	else
+		(void)unlink((*ctx)->tmp_path);
+
+	i_assert((*ctx)->output == NULL);
+
+	sieve_storage_save_destroy(ctx);
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SAVE_H
+#define __SIEVE_SAVE_H
+
+#include "sieve-storage.h"
+
+struct sieve_save_context;
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input);
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx);
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx);
+
+struct sieve_script *sieve_storage_save_get_tempscript
+  (struct sieve_save_context *ctx);
+
+void sieve_storage_save_cancel(struct sieve_save_context **ctx);
+
+int sieve_storage_save_commit(struct sieve_save_context **ctx);
+
+#endif
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c	2009-06-19 09:06:35.000000000 +0000
@@ -0,0 +1,613 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "file-copy.h"
+
+#include "sieve-script-private.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+#include <fcntl.h>
+
+struct sieve_storage_script {
+	struct sieve_script script;	
+
+    struct sieve_storage *storage;
+};
+
+struct sieve_script *sieve_storage_script_init_from_path
+(struct sieve_storage *storage, const char *path, 
+	const char *scriptname, bool *exists_r)
+{
+	pool_t pool;
+	struct sieve_storage_script *st_script = NULL;	
+
+	/* Prevent initializing the active script link as a script when it
+	 * resides in the sieve storage directory.
+	 */
+	if ( *(storage->link_path) == '\0' ) {
+		const char *fname;
+
+		fname = strrchr(path, '/');
+		if ( fname == NULL )
+			fname = path;
+		else
+			fname++;
+
+		if ( strcmp(fname, storage->active_fname) == 0 ) {
+			if ( exists_r != NULL )
+				*exists_r = FALSE;
+			return NULL;
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_storage_script", 4096);	
+	st_script = p_new(pool, struct sieve_storage_script, 1);
+	st_script->script.pool = pool;
+	st_script->storage = storage;
+
+	if ( sieve_script_init(&st_script->script, path, scriptname, 
+		sieve_storage_get_error_handler(storage), exists_r) != NULL ) {
+
+		return &st_script->script;
+	}
+
+	pool_unref(&pool);
+
+	return NULL;
+}
+
+struct sieve_script *sieve_storage_script_init
+(struct sieve_storage *storage, const char *scriptname, bool *exists_r)
+{	
+	struct sieve_script *script;
+	const char *path;
+
+	/* Disallow '/' characters in script name */	
+	if ( strchr(scriptname, '/') != NULL ) {
+		sieve_storage_set_error(storage, 
+			SIEVE_STORAGE_ERROR_IMPOSSIBLE,
+			"Invalid script name '%s'.", scriptname);
+		return NULL;
+	}
+
+	T_BEGIN {
+		path = t_strconcat( storage->dir, "/", scriptname, ".sieve", NULL );
+
+		script = sieve_storage_script_init_from_path
+			(storage, path, NULL, exists_r);
+	} T_END;
+
+	return script;
+}
+
+static struct sieve_script *sieve_storage_script_init_from_file
+(struct sieve_storage *storage, const char *scriptfile, bool *exists_r)
+{	
+	struct sieve_script *script;
+	const char *path;
+
+	T_BEGIN {
+		path = t_strconcat( storage->dir, "/", scriptfile, NULL );
+
+		script = sieve_storage_script_init_from_path
+			(storage, path, NULL, exists_r);
+	} T_END;
+
+	return script;
+}
+
+const char *sieve_storage_file_get_scriptname
+(const struct sieve_storage *storage ATTR_UNUSED, const char *filename)
+{
+	const char *ext;
+
+	ext = strrchr(filename, '.');
+
+	if ( ext == NULL || ext == filename || strcmp(ext,".sieve") != 0 ) 
+		return NULL;
+	
+	return t_strdup_until(filename, ext);
+}
+
+static const char *sieve_storage_read_active_link
+(struct sieve_storage *storage, bool *not_link)
+{
+  char linkbuf[PATH_MAX];
+  int ret;
+
+	if ( not_link != NULL )
+		*not_link = FALSE;
+
+	ret = readlink(storage->active_path, linkbuf, sizeof(linkbuf));
+
+	if ( ret < 0 ) {
+		if (errno == EINVAL) {
+			/* Our symlink is no symlink. Report 'no active script'.
+			 * Activating a script will automatically resolve this, so
+			 * there is no need to panic on this one.
+			 */
+			i_warning
+			  ("sieve-storage: Active sieve script symlink %s is no symlink.",
+			   storage->active_path);
+			if ( not_link != NULL )
+				*not_link = TRUE;
+			return "";
+		}
+
+		if (errno != ENOENT ) {
+			/* We do need to panic otherwise */
+			sieve_storage_set_critical
+			  (storage,
+			  	"Performing readlink() on active sieve symlink '%s' failed: %m", 
+					storage->active_path);
+			return NULL;
+		}
+
+		return "";
+	}
+
+	/* ret is now assured to be valid, i.e. > 0 */
+	return t_strndup(linkbuf, ret);
+}
+
+static const char *sieve_storage_parse_link
+(struct sieve_storage *storage, const char *link)
+{
+	const char *fname, *scriptname, *scriptpath;
+
+	/* Split link into path and filename */
+	fname = strrchr(link, '/');
+	if ( fname != NULL ) {
+		scriptpath = t_strdup_until(link, fname+1);
+		fname++;
+	} else {
+		scriptpath = "";
+		fname = link;
+	}
+
+	/* Check the script name */
+	scriptname = sieve_storage_file_get_scriptname(storage, fname);
+
+	/* Warn if link is deemed to be invalid */
+	if ( scriptname == NULL ) {
+		i_warning
+			("sieve-storage: Active sieve script symlink %s is broken: "
+				"invalid scriptname (points to %s).",
+				storage->active_path, link);
+		return NULL;
+	}
+
+	/* Check whether the path is any good */
+	if ( strcmp(scriptpath, storage->link_path) != 0 &&
+		strcmp(scriptpath, storage->dir) != 0 ) {
+		i_warning
+			("sieve-storage: Active sieve script symlink %s is broken: "
+				"invalid/unknown path to storage (points to %s).",
+				storage->active_path, link);
+		return NULL; 
+	}
+
+	return fname;
+}
+
+const char *sieve_storage_get_active_scriptfile
+(struct sieve_storage *storage)
+{
+	const char *link, *scriptfile;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, NULL);
+
+	if ( link == NULL || *link == '\0' ) 
+		return link;
+
+	/* Parse the link */
+	scriptfile = sieve_storage_parse_link(storage, link);
+
+	if (scriptfile == NULL) {
+		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 * Activation should fix this situation.
+		 */
+		return "";
+	}
+
+	return scriptfile;
+}
+
+struct sieve_script *sieve_storage_get_active_script
+(struct sieve_storage *storage, bool *no_active)
+{
+	bool exists, no_link;
+	struct sieve_script *script;
+	const char *scriptfile, *link;
+
+	*no_active = FALSE;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, &no_link);
+	
+	if ( link == NULL )
+		/* Error */
+		return NULL;
+
+	if ( *link == '\0' )
+	{
+		if (no_link) {
+			/* Try to open the active_path as a regular file */
+			return sieve_storage_script_init_from_path
+				(storage, storage->active_path, NULL, NULL);
+		}
+
+		*no_active = TRUE;
+		return NULL;
+	}
+
+	/* Parse the link */
+	scriptfile = sieve_storage_parse_link(storage, link);
+
+	if (scriptfile == NULL) {
+  		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 */
+		*no_active = TRUE;
+		return NULL;
+	}
+	
+	exists = TRUE;
+	script = sieve_storage_script_init_from_file(storage, scriptfile, &exists);	
+
+	if ( !exists ) {
+		i_warning
+		  ("sieve-storage: Active sieve script symlink %s "
+		   "points to non-existent script (points to %s).",
+		   storage->active_path, link);
+	}
+	
+	*no_active = !exists;
+	return script;
+}
+
+int sieve_storage_script_is_active(struct sieve_script *script)
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	const char *afile;
+	int ret = 0;
+
+	T_BEGIN {
+		afile = sieve_storage_get_active_scriptfile(st_script->storage);
+	
+		if (afile == NULL) {
+			/* Critical error */
+			ret = -1;
+		} else {
+		 	/* Is the requested script active? */
+			if ( strcmp(script->filename, afile) == 0 ) 
+				ret = 1;
+		}
+	} T_END;
+
+	return ret;
+}
+
+int sieve_storage_script_delete(struct sieve_script **script) 
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) *script;
+	struct sieve_storage *storage = st_script->storage;
+	int ret = 0;
+
+	/* Is the requested script active? */
+	if ( sieve_storage_script_is_active(*script) ) {
+		sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_ACTIVE,
+			"Cannot delete the active sieve script.");
+		ret = -1;
+	} else {
+		ret = unlink((*script)->path);
+
+		if ( ret < 0 ) {
+			if ( errno == ENOENT ) 
+				sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_NOTFOUND,
+					"Sieve script does not exist.");
+			else
+				sieve_storage_set_critical(
+					storage, "Performing unlink() failed on sieve file '%s': %m", 
+					(*script)->path);
+		}	
+	}
+
+	/* Always deinitialize the script object */
+	sieve_script_unref(script);
+
+	return ret;	
+}
+
+static bool sieve_storage_rescue_regular_file(struct sieve_storage *storage)
+{
+	struct stat st;
+	
+	/* Stat the file */
+	if ( lstat(storage->active_path, &st) != 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_critical(storage, 
+				"Failed to stat active sieve script symlink (%s): %m.", 
+				storage->active_path); 
+			return FALSE;	
+		} 
+		return TRUE;
+	}
+
+  	if ( S_ISLNK( st.st_mode ) ) {
+		if ( getenv("DEBUG") != NULL )
+	    	i_info( "sieve-storage: nothing to rescue %s.", storage->active_path);
+    	return TRUE; /* Nothing to rescue */
+  	}
+
+	/* Only regular files can be rescued */
+	if ( S_ISREG( st.st_mode ) ) {
+		const char *dstpath;
+
+ 		t_push();
+
+		dstpath = t_strconcat
+			( storage->dir, "/dovecot.orig.sieve", NULL );
+		if ( file_copy(storage->active_path, dstpath, 1) < 1 ) {
+			sieve_storage_set_critical(storage, 
+				"Active sieve script file '%s' is a regular file and copying it to the "
+				"script storage as '%s' failed. This needs to be fixed manually.",
+				storage->active_path, dstpath);
+			t_pop();
+			return FALSE;	
+		} else {
+			i_info("sieve-storage: Moved active sieve script file '%s' "
+				"to script storage as '%s'.",
+				storage->active_path, dstpath); 
+			t_pop();
+			return TRUE;
+    	}
+		t_pop();
+  	}
+
+	sieve_storage_set_critical( storage,
+		"Active sieve script file '%s' is no symlink nor a regular file. "
+		"This needs to be fixed manually.", storage->active_path );
+	return FALSE;	
+}
+
+int sieve_storage_deactivate(struct sieve_storage *storage)
+{
+	int ret;
+
+	if ( !sieve_storage_rescue_regular_file(storage) ) 
+		return -1;
+
+	/* Delete the symlink, so no script is active */
+	ret = unlink(storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_critical(storage, "sieve_storage_deactivate(): "
+				"error on unlink(%s): %m", storage->active_path);
+			return -1;
+		} else 
+			return 0;
+	} 
+
+	return 1;
+}
+
+static int sieve_storage_replace_active_link
+	(struct sieve_storage *storage, const char *link_path)
+{
+	const char *active_path_new;
+	struct timeval *tv, tv_now;
+	int ret = 0;	
+
+	tv = &ioloop_timeval;
+
+	for (;;) {	
+		/* First the new symlink is created with a different filename */
+		active_path_new = t_strdup_printf
+			("%s-new.%s.P%sM%s.%s.sieve",
+				storage->active_path,
+				dec2str(tv->tv_sec), my_pid,
+				dec2str(tv->tv_usec), my_hostname);
+
+		ret = symlink(link_path, active_path_new);
+		
+		if ( ret < 0 ) {
+			/* If link exists we try again later */
+			if ( errno == EEXIST ) {
+				/* Wait and try again - very unlikely */
+				sleep(2);
+				tv = &tv_now;
+				if (gettimeofday(&tv_now, NULL) < 0)
+					i_fatal("gettimeofday(): %m");
+				continue;
+			}
+
+			/* Other error, critical */
+			sieve_storage_set_critical
+				(storage, "Creating symlink() %s to %s failed: %m", 
+				active_path_new, link_path);
+			return -1;
+		}
+	
+		/* Link created */
+		break;
+	}
+
+	/* Replace the existing link. This activates the new script */
+	ret = rename(active_path_new, storage->active_path);
+
+	if ( ret < 0 ) {
+		/* Failed; created symlink must be deleted */
+		(void)unlink(active_path_new);
+		sieve_storage_set_critical
+			(storage, "Performing rename() %s to %s failed: %m", 
+			active_path_new, storage->active_path);
+		return -1;
+	}	
+
+	return 1;
+}
+
+int sieve_storage_script_activate(struct sieve_script *script)
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	struct sieve_storage *storage = st_script->storage;
+	struct stat st;
+	const char *link_path, *afile;
+	int activated = 0;
+	int ret;
+
+	t_push();	
+
+	/* Find out whether there is an active script, but recreate
+	 * the symlink either way. This way, any possible error in the symlink
+	 * resolves automatically. This step is only necessary to provide a
+	 * proper return value indicating whether the script was already active.
+	 */
+	afile = sieve_storage_get_active_scriptfile(storage);
+
+	/* Is the requested script already active? */
+	if ( afile == NULL || strcmp(script->filename, afile) != 0 ) 
+		activated = 1; 
+
+	/* Check the scriptfile we are trying to activate */
+	if ( lstat(script->path, &st) != 0 ) {
+		sieve_storage_set_critical(storage, 
+		  "Stat on sieve script %s failed, but it is to be activated: %m.", 
+			script->path);
+		t_pop();
+		return -1;
+	}
+
+	/* Rescue a possible .dovecot.sieve regular file remaining from old 
+	 * installations.
+	 */
+	if ( !sieve_storage_rescue_regular_file(storage) ) {
+		/* Rescue failed, manual intervention is necessary */
+		t_pop();
+		return -1;
+	}
+
+	/* Just try to create the symlink first */
+	link_path = t_strconcat
+	  ( storage->link_path, script->filename, NULL );
+		
+ 	ret = symlink(link_path, storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno == EEXIST ) {
+			ret = sieve_storage_replace_active_link(storage, link_path);
+			if ( ret < 0 ) {
+				t_pop();
+				return ret;
+			}
+		} else {
+			/* Other error, critical */
+			sieve_storage_set_critical
+				(storage,
+					"Creating symlink() %s to %s failed: %m",
+					storage->active_path, link_path);
+			t_pop();
+			return -1;
+		}
+	}
+
+	t_pop();
+	return activated;
+}
+
+int sieve_storage_script_rename(struct sieve_script *script, const char *newname) 
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	struct sieve_storage *storage = st_script->storage;
+	const char *newpath, *newfile, *link_path;
+	int ret = 0;
+
+	/* Disallow '/' characters in script name */
+	if ( strchr(newname, '/') != NULL ) {
+		sieve_storage_set_error(storage, 
+			SIEVE_STORAGE_ERROR_IMPOSSIBLE, 
+			"Invalid new script name '%s'.", newname);
+		return -1;
+	}
+
+	T_BEGIN {
+		newfile = t_strconcat( newname, ".sieve", NULL );
+		newpath = t_strconcat( storage->dir, "/", newfile, NULL );
+
+		/* The normal rename() system call overwrites the existing file without notice. 
+		 * Also, active scripts must not be disrupted by renaming a script. That is why
+		 * we use a link(newpath) [activate newpath] unlink(oldpath)
+		 */
+
+		/* Link to the new path */
+		ret = link(script->path, newpath);
+		if ( ret >= 0 ) {
+			/* Is the requested script active? */
+			if ( sieve_storage_script_is_active(script) ) {
+				/* Active; make active link point to the new copy */
+				link_path = t_strconcat
+					( storage->link_path, newfile, NULL );
+
+				ret = sieve_storage_replace_active_link(storage, link_path);
+			}
+
+			if ( ret >= 0 ) {
+				/* If all is good, remove the old link */
+				if ( unlink(script->path) < 0 ) {
+					i_error("Failed to clean up old file link '%s' after rename: %m", 
+						script->path);
+				}
+
+				if ( script->name != NULL && *script->name != '\0' )
+					script->name = p_strdup(script->pool, newname);
+				script->path = p_strdup(script->pool, newpath);
+				script->filename = p_strdup(script->pool, newfile);
+				script->basename = p_strdup(script->pool, newname);
+			} else {
+				/* If something went wrong, remove the new link to restore previous state */
+				if ( unlink(newpath) < 0 ) {
+					i_error("Failed to clean up new file link '%s'"
+						" after failed rename: %m", newpath);
+				}
+			}
+		} else {
+			/* Our efforts failed right away */
+			switch ( errno ) {
+			case ENOENT: 
+				sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_NOTFOUND, 
+					"Sieve script does not exist.");
+				break;
+			case EEXIST:
+				sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_EXISTS,
+					"A sieve script with that name already exists.");
+				break;
+			default:
+				sieve_storage_set_critical(
+					storage, "Performing link(%s, %s) failed: %m", 
+						script->path, newpath);
+			}				
+		}
+	} T_END;
+
+	return ret;	
+}
+
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h
--- dovecot-1.2.0/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_SCRIPT_H
+#define __SIEVE_STORAGE_SCRIPT_H
+
+#include "sieve-script.h"
+
+#include "sieve-storage.h"
+
+struct sieve_script *sieve_storage_script_init
+    (struct sieve_storage *storage, const char *scriptname, bool *exists_r);
+
+const char *sieve_storage_file_get_scriptname
+	(const struct sieve_storage *storage, const char *filename);
+
+const char *
+	sieve_storage_get_active_scriptfile(struct sieve_storage *storage);
+
+struct sieve_script *
+	sieve_storage_get_active_script(struct sieve_storage *storage, bool *no_active);
+
+int sieve_storage_script_is_active(struct sieve_script *script);
+
+int sieve_storage_script_delete(struct sieve_script **script);
+
+int sieve_storage_deactivate(struct sieve_storage *storage);
+
+int sieve_storage_script_activate(struct sieve_script *script);
+
+int sieve_storage_script_rename(struct sieve_script *script, const char *newname);
+
+#endif
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/Makefile.am dovecot-1.2.0-debian/dovecot-managesieve/src/Makefile.am
--- dovecot-1.2.0/dovecot-managesieve/src/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/Makefile.am	2008-07-18 10:09:52.000000000 +0000
@@ -0,0 +1,1 @@
+SUBDIRS = lib-managesieve lib-sievestorage managesieve managesieve-login
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/client.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/client.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/client.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/client.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,578 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "str.h"
+#include "ioloop.h"
+#include "network.h"
+#include "istream.h"
+#include "ostream.h"
+#include "var-expand.h"
+#include "commands.h"
+
+#include "managesieve-quote.h"
+#include "sieve-storage.h"
+
+#include "client.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+static struct client *my_client; /* we don't need more than one currently */
+
+static void client_idle_timeout(struct client *client)
+{
+	client_send_bye(client, "Disconnected for inactivity.");
+	client_destroy(client, "Disconnected for inactivity");
+}
+
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage)
+{
+	struct client *client;
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd_in, TRUE);
+	net_set_nonblock(fd_out, TRUE);
+
+	client = i_new(struct client, 1);
+	client->fd_in = fd_in;
+	client->fd_out = fd_out;
+	client->input = i_stream_create_fd(fd_in, managesieve_max_line_length, FALSE);
+	client->output = o_stream_create_fd(fd_out, (size_t)-1, FALSE);
+
+	o_stream_set_flush_callback(client->output, client_output, client);
+
+	client->io = io_add(fd_in, IO_READ, client_input, client);
+	client->parser = managesieve_parser_create(client->input, client->output,
+					    managesieve_max_line_length);
+	client->to_idle = timeout_add(CLIENT_IDLE_TIMEOUT_MSECS,
+				      client_idle_timeout, client);
+
+	client->cmd.pool = pool_alloconly_create("command pool", 8192);
+	client->cmd.client = client;
+
+	client->storage = storage;
+
+	i_assert(my_client == NULL);
+	my_client = client;
+
+	if (hook_client_created != NULL)
+		hook_client_created(&client);
+	return client;
+}
+
+static const char *client_stats(struct client *client)
+{	
+	static struct var_expand_table static_tab[] = {
+		{ 'i', NULL, "input" },
+		{ 'o', NULL, "output" },
+		{ '\0', NULL, NULL }
+	};
+	struct var_expand_table *tab;
+	string_t *str;
+
+	tab = t_malloc(sizeof(static_tab));
+	memcpy(tab, static_tab, sizeof(static_tab));
+
+	tab[0].value = dec2str(client->input->v_offset);
+	tab[1].value = dec2str(client->output->offset);
+
+	str = t_str_new(128);
+	var_expand(str, logout_format, tab);
+	return str_c(str);
+}
+
+static const char *client_get_disconnect_reason(struct client *client)
+{
+	errno = client->input->stream_errno != 0 ?
+		client->input->stream_errno :
+		client->output->stream_errno;
+	return errno == 0 || errno == EPIPE ? "Connection closed" :
+		t_strdup_printf("Connection closed: %m");
+}
+
+void client_destroy(struct client *client, const char *reason)
+{
+	int ret;
+
+ 	i_assert(!client->handling_input);
+	i_assert(!client->destroyed);
+	client->destroyed = TRUE;
+
+	if (!client->disconnected) {
+		client->disconnected = TRUE;
+		if (reason == NULL)
+			reason = client_get_disconnect_reason(client);
+		i_info("%s %s", reason, client_stats(client));	
+	}
+
+	if (client->command_pending) {
+		/* try to deinitialize the command */
+		i_assert(client->cmd.func != NULL);
+		i_stream_close(client->input);
+		o_stream_close(client->output);
+		client->input_pending = FALSE;
+
+		ret = client->cmd.func(&client->cmd);
+		i_assert(ret);
+	}
+
+	managesieve_parser_destroy(&client->parser);
+	if (client->io != NULL)
+		io_remove(&client->io);
+	if (client->to_idle_output != NULL)
+		timeout_remove(&client->to_idle_output);
+	timeout_remove(&client->to_idle);
+
+	i_stream_destroy(&client->input);
+	o_stream_destroy(&client->output);
+
+	if (close(client->fd_in) < 0)
+		i_error("close(client in) failed: %m");
+	if (client->fd_in != client->fd_out) {
+		if (close(client->fd_out) < 0)
+			i_error("close(client out) failed: %m");
+	}
+
+	pool_unref(&client->cmd.pool);
+	i_free(client);
+
+	/* quit the program */
+	my_client = NULL;
+	io_loop_stop(ioloop);
+}
+
+void client_disconnect(struct client *client, const char *reason)
+{
+	i_assert(reason != NULL);
+
+	if (client->disconnected)
+		return;
+
+	i_info("Disconnected: %s %s", reason, client_stats(client));
+	client->disconnected = TRUE;
+	(void)o_stream_flush(client->output);
+
+	i_stream_close(client->input);
+	o_stream_close(client->output);
+}
+
+void client_disconnect_with_error(struct client *client, const char *msg)
+{
+	client_send_bye(client, msg);
+	client_disconnect(client, msg);
+}
+
+int client_send_line(struct client *client, const char *data) 
+{
+	struct const_iovec iov[2];
+
+	if (client->output->closed)
+		return -1;
+
+	iov[0].iov_base = data;
+	iov[0].iov_len = strlen(data);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	if (o_stream_sendv(client->output, iov, 2) < 0)
+		return -1;
+	client->last_output = ioloop_time;
+
+	if (o_stream_get_buffer_used_size(client->output) >=
+	    CLIENT_OUTPUT_OPTIMAL_SIZE) {
+		/* buffer full, try flushing */
+		return o_stream_flush(client->output);
+	}
+	return 1;
+}
+
+void client_send_response
+(struct client *client, const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+	
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL ) {
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL ) {
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void client_send_command_error
+(struct client_command_context *cmd, const char *msg)
+{
+	struct client *client = cmd->client;
+	const char *error, *cmd_name;
+	bool fatal;
+
+	if (msg == NULL) {
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_disconnect_with_error(client, msg);
+			return;
+		}
+	}
+
+	if (cmd->name == NULL)
+		error = t_strconcat
+			("Error in MANAGESIEVE command: ", msg, NULL);
+	else {
+		cmd_name = t_str_ucase(cmd->name);
+		error = t_strconcat
+			("Error in MANAGESIEVE command ", cmd_name, ": ", msg, NULL);
+	}
+
+	client_send_no(client, error);
+
+	if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+		client_disconnect_with_error(client,
+			"Too many invalid MANAGESIEVE commands.");
+	}
+
+	/* client_read_args() failures rely on this being set, so that the
+	   command processing is stopped even while command function returns
+	   FALSE. */
+	cmd->param_error = TRUE;
+}
+
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage)
+{
+	enum sieve_storage_error error_code;
+	const char *error;
+
+	error = sieve_storage_get_last_error(storage, &error_code);
+
+	switch ( error_code ) {
+	case SIEVE_STORAGE_ERROR_TEMP:
+		client_send_noresp(client, "TRYLATER", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_QUOTA:
+	case SIEVE_STORAGE_ERROR_NOSPACE: /* Not sure if this is appropriate */
+		client_send_noresp(client, "QUOTA", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_NOTFOUND:
+		client_send_noresp(client, "NONEXISTENT", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_ACTIVE:
+		client_send_noresp(client, "ACTIVE", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_EXISTS:
+		client_send_noresp(client, "ALREADYEXISTS", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_IMPOSSIBLE:
+	default:
+		client_send_no(client, error);
+		break;
+	}
+}
+
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args)
+{
+	int ret;
+
+	i_assert(count <= INT_MAX);
+
+	ret = managesieve_parser_read_args(cmd->client->parser, count, flags, args);
+	if (ret >= (int)count) {
+		/* all parameters read successfully */
+		return TRUE;
+	} else if (ret == -2) {
+		/* need more data */
+		if (cmd->client->input->closed) {
+            /* disconnected */
+            cmd->param_error = TRUE;
+        }
+		return FALSE;
+	} else {
+		/* error, or missing arguments */
+		client_send_command_error(cmd, ret < 0 ? NULL :
+					  "Missing arguments");
+		return FALSE;
+	}
+}
+
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...)
+{
+	struct managesieve_arg *managesieve_args;
+	va_list va;
+	const char *str;
+	unsigned int i;
+	bool result = TRUE;
+
+	if (!client_read_args(cmd, count, 0, &managesieve_args))
+		return FALSE;
+
+	va_start(va, count);
+	for (i = 0; i < count; i++) {
+		const char **ret = va_arg(va, const char **);
+
+		if (managesieve_args[i].type == MANAGESIEVE_ARG_EOL) {
+			client_send_command_error(cmd, "Missing arguments.");
+			result = FALSE;
+			break;
+		}
+
+		str = managesieve_arg_string(&managesieve_args[i]);
+		if (str == NULL) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			result = FALSE;
+			break;
+		}
+
+		if (ret != NULL)
+			*ret = str;
+	}
+	va_end(va);
+
+	if (result && managesieve_args[i].type != MANAGESIEVE_ARG_EOL) {
+		client_send_command_error(cmd, "Too many arguments.");
+		result = FALSE;
+	}
+
+	return result;
+}
+
+void _client_reset_command(struct client *client)
+{
+	pool_t pool;
+	size_t size;
+
+	/* reset input idle time because command output might have taken a
+	   long time and we don't want to disconnect client immediately then */
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	client->command_pending = FALSE;
+    if (client->io == NULL && !client->disconnected) {
+        i_assert(i_stream_get_fd(client->input) >= 0);
+        client->io = io_add(i_stream_get_fd(client->input),
+                    IO_READ, client_input, client);
+    }
+    o_stream_set_flush_callback(client->output, client_output, client);
+
+	pool = client->cmd.pool;
+	memset(&client->cmd, 0, sizeof(client->cmd));
+
+	p_clear(pool);
+	client->cmd.pool = pool;
+	client->cmd.client = client;
+
+	managesieve_parser_reset(client->parser);
+
+	/* if there's unread data in buffer, remember that there's input
+	   pending and we should get around to calling client_input() soon.
+	   This is mostly for APPEND/IDLE. */
+	(void)i_stream_get_data(client->input, &size);
+	if (size > 0 && !client->destroyed)
+		client->input_pending = TRUE;
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+static bool client_skip_line(struct client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			client->input_skip_line = FALSE;
+			i++;
+			break;
+		}
+	}
+
+	i_stream_skip(client->input, i);
+	return !client->input_skip_line;
+}
+
+static bool client_handle_input(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	if (cmd->func != NULL) {
+		/* command is being executed - continue it */
+		if (cmd->func(cmd) || cmd->param_error) {
+			/* command execution was finished */
+			if (!cmd->param_error)
+				client->bad_counter = 0;
+			_client_reset_command(client);
+			return TRUE;
+		}
+
+		/* unfinished */
+        if (client->command_pending)
+            o_stream_set_flush_pending(client->output, TRUE);
+		return FALSE;
+	}
+
+	if (client->input_skip_line) {
+		/* we're just waiting for new line.. */
+		if (!client_skip_line(client))
+			return FALSE;
+
+		/* got the newline */
+		_client_reset_command(client);
+
+		/* pass through to parse next command */
+	}
+
+	if (cmd->name == NULL) {
+		cmd->name = managesieve_parser_read_word(client->parser);
+		if (cmd->name == NULL)
+			return FALSE; /* need more data */
+		cmd->name = p_strdup(cmd->pool, cmd->name);
+	}
+
+	if (cmd->name == '\0') {
+        /* command not given - cmd_func is already NULL. */
+    } else {
+        /* find the command function */
+        struct command *command = command_find(cmd->name);
+
+        if (command != NULL) {
+            cmd->func = command->func;
+        }
+    }
+
+	client->input_skip_line = TRUE;
+	if (cmd->func == NULL) {
+		/* unknown command */
+		client_send_command_error(cmd, "Unknown command.");
+		_client_reset_command(client);
+	} else {
+		i_assert(!client->disconnected);
+
+		client_handle_input(cmd);
+	}
+
+	return TRUE;
+}
+
+void client_input(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+
+	if (client->command_pending) {
+		/* already processing one command. wait. */
+		io_remove(&client->io);
+		return;
+	}
+
+	client->input_pending = FALSE;
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		client_destroy(client, NULL);
+		return;
+	case -2:
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		_client_reset_command(client);
+		break;
+	}
+
+	client->handling_input = TRUE;
+	o_stream_cork(client->output);
+	do {
+		t_push();
+		ret = client_handle_input(cmd);
+		t_pop();
+	} while (ret && !client->disconnected);
+    o_stream_uncork(client->output);
+    client->handling_input = FALSE;
+
+	if (client->command_pending)
+		client->input_pending = TRUE;
+
+	if (client->output->closed)
+		client_destroy(client, NULL);
+}
+
+int client_output(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+	bool finished;
+
+	client->last_output = ioloop_time;
+    timeout_reset(client->to_idle);
+    if (client->to_idle_output != NULL)
+        timeout_reset(client->to_idle_output);
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, NULL);
+		return 1;
+	}
+
+	if (!client->command_pending)
+		return 1;
+
+	/* continue processing command */
+	o_stream_cork(client->output);
+	client->output_pending = TRUE;
+	finished = cmd->func(cmd) || cmd->param_error;
+
+	/* a bit kludgy check. normally we would want to get back to this
+	   output handler, but IDLE is a special case which has command
+	   pending but without necessarily anything to write. */
+	if (!finished && client->output_pending)
+		o_stream_set_flush_pending(client->output, TRUE);
+
+	o_stream_uncork(client->output);
+
+	if (finished) {
+		/* command execution was finished */
+		client->bad_counter = 0;
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			client_input(client);
+	}
+	return ret;
+}
+
+void clients_init(void)
+{
+	my_client = NULL;
+}
+
+void clients_deinit(void)
+{
+	if (my_client != NULL) {
+		client_send_bye(my_client, "Server shutting down.");
+		client_destroy(my_client, "Server shutting down");
+	}
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/client.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/client.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/client.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/client.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,105 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "commands.h"
+
+struct client;
+struct sieve_storage;
+struct managesieve_parser;
+struct managesieve_arg;
+
+struct client_command_context {
+	struct client *client;
+
+	pool_t pool;
+	const char *name;
+
+	command_func_t *func;
+	void *context;
+
+	unsigned int param_error:1;
+};
+
+struct client {
+	int fd_in, fd_out;
+	struct sieve_storage *storage;
+
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+	struct timeout *to_idle, *to_idle_output;
+
+	time_t last_input, last_output;
+	unsigned int bad_counter;
+
+	struct managesieve_parser *parser;
+	struct client_command_context cmd;
+
+	unsigned int disconnected:1;
+	unsigned int destroyed:1;
+	unsigned int command_pending:1;
+	unsigned int input_pending:1;
+	unsigned int output_pending:1;
+	unsigned int handling_input:1;
+	unsigned int input_skip_line:1; /* skip all the data until we've
+					   found a new line */
+};
+
+/* Create new client with specified input/output handles. socket specifies
+   if the handle is a socket. */
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage);
+void client_destroy(struct client *client, const char *reason);
+
+/* Disconnect client connection */
+void client_disconnect(struct client *client, const char *reason);
+void client_disconnect_with_error(struct client *client, const char *msg);
+
+/* Send a line of data to client. Returns 1 if ok, 0 if buffer is getting full,
+   -1 if error */
+int client_send_line(struct client *client, const char *data);
+
+void client_send_response(struct client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+  client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(cmd, resp_code, msg) \
+  client_send_response(client, "BYE", resp_code, msg)
+
+/* Send BAD command error to client. msg can be NULL. */
+void client_send_command_error(struct client_command_context *cmd,
+			       const char *msg);
+
+/* Send storage or sieve related errors to the client */
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage);
+
+/* Read a number of arguments. Returns TRUE if everything was read or
+   FALSE if either needs more data or error occurred. */
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args);
+/* Reads a number of string arguments. ... is a list of pointers where to
+   store the arguments. */
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...);
+
+void clients_init(void);
+void clients_deinit(void);
+
+void _client_reset_command(struct client *client);
+void client_input(void *context);
+int client_output(void *context);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-capability.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-capability.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-capability.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-capability.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,49 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "ostream.h"
+
+#include "sieve.h"
+
+bool cmd_capability(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	const char *sievecap, *notifycap;
+
+	o_stream_cork(client->output);
+
+	T_BEGIN {
+		/* Get capabilities */
+		sievecap = sieve_get_capabilities(NULL);
+		notifycap = sieve_get_capabilities("notify");
+
+
+		/* Default capabilities */
+  		client_send_line(client, t_strconcat("\"IMPLEMENTATION\" \"", 
+			managesieve_implementation_string, "\"", NULL));
+		client_send_line(client, t_strconcat("\"SIEVE\" \"", 
+			( sievecap == NULL ? "" : sievecap ), "\"", NULL));
+
+		/* Notify methods */
+		if ( notifycap != NULL ) {
+			client_send_line(client, t_strconcat("\"NOTIFY\" \"", 
+				notifycap, "\"", NULL));
+		}
+
+		/* Protocol version */
+		client_send_line(client, "\"VERSION\" \"1.0\"");
+
+		/* Finish */
+		client_send_line(client, "OK \"Capability completed.\"");
+	} T_END;
+
+	o_stream_uncork(client->output);
+
+	return TRUE;
+
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-deletescript.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-deletescript.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-deletescript.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-deletescript.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+bool cmd_deletescript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+
+	/* <scrip name>*/
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	exists = TRUE;
+	script = sieve_storage_script_init(storage, scriptname, &exists);
+
+	if (script == NULL) {
+		if (!exists) 
+			client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+		else 
+			client_send_storage_error(client, storage);
+
+		return TRUE;
+	}
+
+	if (sieve_storage_script_delete(&script) < 0) {
+		client_send_storage_error(client, storage);
+	} else {
+		client_send_ok(client, "Deletescript completed.");
+	}
+
+	/* Script object is deleted no matter what in 
+	 * sieve_script_delete()
+	 */
+
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-getscript.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-getscript.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-getscript.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-getscript.c	2009-06-24 15:49:57.000000000 +0000
@@ -0,0 +1,127 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+#include "istream.h"
+
+#include "sieve-storage-script.h"
+
+struct cmd_getscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;	
+	uoff_t script_size, script_offset;
+
+	struct sieve_script *script;
+	struct istream *script_stream;
+	bool failed;
+	bool exists;
+};
+
+static bool cmd_getscript_finish(struct cmd_getscript_context *ctx)
+{
+  struct client *client = ctx->client;
+
+	if (ctx->script != NULL)
+		sieve_script_unref(&ctx->script);
+
+	if (ctx->failed) {
+		if (client->output->closed) {
+			client_disconnect(client, "Disconnected");
+			return TRUE;
+		}
+
+		if (!ctx->exists) {
+			client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+			return TRUE;
+		}
+		
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	client_send_line(client, "");
+	client_send_ok(client, "Getscript completed.");
+	return TRUE;
+}
+
+static bool cmd_getscript_continue(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx = cmd->context;
+	off_t ret;
+
+	ret = o_stream_send_istream(client->output, ctx->script_stream);
+
+	if ( ret < 0 ) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", sieve_script_filename(ctx->script));
+		ctx->failed = TRUE;
+		return cmd_getscript_finish(ctx);
+	}
+
+	ctx->script_offset += ret;
+
+	if ( ctx->script_offset != ctx->script_size && !ctx->failed ) {
+		/* unfinished */
+		if (!i_stream_have_bytes_left(ctx->script_stream)) {
+            /* Input stream gave less data than expected */
+            i_error("GETSCRIPT for SCRIPT %s got too little data: "
+                "%"PRIuUOFF_T" vs %"PRIuUOFF_T,
+                sieve_script_name(ctx->script),
+                ctx->script_offset, ctx->script_size);
+            client_disconnect(ctx->client, "GETSCRIPT failed");
+            return TRUE;
+        }
+
+        return FALSE;
+	}
+
+	return cmd_getscript_finish(ctx);
+}
+
+bool cmd_getscript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx;
+	const char *scriptname;
+	bool deleted_r;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	ctx = p_new(cmd->pool, struct cmd_getscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->failed = FALSE;
+	ctx->exists = TRUE;
+	ctx->script = sieve_storage_script_init(client->storage, scriptname, &ctx->exists);
+
+	if (ctx->script == NULL) {
+		ctx->failed = TRUE;
+		return cmd_getscript_finish(ctx);
+	}
+			
+	ctx->script_stream = sieve_script_open(ctx->script, &deleted_r);
+
+	if ( ctx->script_stream == NULL ) {
+		ctx->failed = TRUE;
+		ctx->exists = !deleted_r;
+		return cmd_getscript_finish(ctx);
+	}
+
+	ctx->script_size = sieve_script_get_size(ctx->script);
+	ctx->script_offset = 0;	
+
+	client_send_line(client, t_strdup_printf("{%"PRIuUOFF_T"}", ctx->script_size));
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_getscript_continue;
+	cmd->context = ctx;
+
+	return cmd_getscript_continue(cmd);
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-havespace.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-havespace.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-havespace.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-havespace.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,41 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+
+bool cmd_havespace(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct managesieve_arg *args;
+	const char *scriptname;
+	uoff_t size;
+	int ret;
+
+	/* <scriptname> <size> */
+	if (!(ret=client_read_args(cmd, 2, 0, &args)))
+	  return FALSE;
+
+	if ( ret > 2 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( (scriptname = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid string for scriptname.");
+		return TRUE;
+	}
+
+	if ( managesieve_arg_number(&args[1], &size) < 0 ) {
+		client_send_no(client, "Invalid scriptsize argument.");
+		return TRUE;
+	}
+
+	if ( size == 0 ) {
+		client_send_no(client, "Cannot upload empty script.");
+		return TRUE;
+	}
+
+	client_send_ok(client, "Putscript would succeed.");
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-listscripts.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-listscripts.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-listscripts.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-listscripts.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,49 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "sieve-storage.h"
+#include "sieve-storage-list.h"
+#include "managesieve-quote.h"
+
+bool cmd_listscripts(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct sieve_list_context *ctx;
+	const char *scriptname;
+	bool active;
+	string_t *str;
+
+	if ( (ctx = sieve_storage_list_init(client->storage))
+		== NULL ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	/* FIXME: This will be quite slow for large script lists. Implement
+	 * some buffering to fix this. Wont truely be an issue with managesieve
+	 * though.
+	 */
+	while ((scriptname = sieve_storage_list_next(ctx, &active)) != NULL) {
+		t_push();
+		str = t_str_new(128);
+	  
+		managesieve_quote_append_string(str, scriptname, FALSE);
+		
+		if ( active ) 
+		  str_append(str, " ACTIVE");
+		
+		client_send_line(client, str_c(str));
+		t_pop();
+	}
+  
+	if ( sieve_storage_list_deinit(&ctx) < 0 ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+	
+	client_send_ok(client, "Listscripts completed.");
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-logout.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-logout.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-logout.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-logout.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,15 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+
+bool cmd_logout(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	client_send_line(client, "OK \"Logout completed.\"");
+	client_disconnect(client, "Logged out");
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-noop.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-noop.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-noop.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-noop.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "str.h"
+#include "managesieve-quote.h"
+#include "commands.h"
+
+#include <stdlib.h>
+
+bool cmd_noop(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct managesieve_arg *args;
+	const char *text;
+	string_t *resp_code;
+	int ret;
+
+	/* [<echo string>] */
+	if (!(ret=client_read_args(cmd, 0, 0, &args)))
+		return FALSE;
+
+	if ( ret > 1 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( args[0].type == MANAGESIEVE_ARG_EOL ) {
+		client_send_ok(client, "NOOP Completed");
+		return TRUE;
+	}
+
+	if ( (text = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid echo tag.");
+		return TRUE;
+	}
+
+	resp_code = t_str_new(256);
+	str_append(resp_code, "TAG ");
+	managesieve_quote_append_string(resp_code, text, FALSE);
+
+	client_send_okresp(client, str_c(resp_code), "Done");
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-putscript.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-putscript.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-putscript.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-putscript.c	2009-06-28 13:50:46.000000000 +0000
@@ -0,0 +1,424 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* NOTE: this file also contains the checkscript command due to its obvious
+ * similarities.
+ */
+
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "commands.h"
+#include "managesieve-parser.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-save.h"
+#include "sieve.h"
+
+#include <sys/time.h>
+
+struct cmd_putscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;
+
+	struct istream *input;
+
+	const char *scriptname;
+	uoff_t script_size;	
+
+	struct managesieve_parser *save_parser;
+	struct sieve_save_context *save_ctx;
+};
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx);
+static bool cmd_putscript_continue_script(struct client_command_context *cmd);
+
+static void client_input_putscript(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+
+	i_assert(!client->destroyed);
+
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		cmd_putscript_finish(cmd->context);
+		/* Reset command so that client_destroy() doesn't try to call
+		   cmd_putscript_continue_script() anymore. */
+		_client_reset_command(client);
+		client_destroy(client, "Disconnected in PUTSCRIPT/SCRIPT");
+		return;
+	case -2:
+		cmd_putscript_finish(cmd->context);
+		if (client->command_pending) {
+			/* uploaded script data, this is handled internally by
+			   mailbox_save_continue() */
+			break;
+		}
+
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		cmd->param_error = TRUE;
+		_client_reset_command(client);
+		return;
+	}
+
+	if (cmd->func(cmd)) {
+		/* command execution was finished. Note that if cmd_sync()
+		   didn't finish, we didn't get here but the input handler
+		   has already been moved. So don't do anything important
+		   here..
+
+		   reset command once again to reset cmd_sync()'s changes. */
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			client_input(client);
+	}
+}
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx)
+{
+	managesieve_parser_destroy(&ctx->save_parser);
+	
+	io_remove(&ctx->client->io);
+	o_stream_set_flush_callback(ctx->client->output,
+				    client_output, ctx->client);
+
+	if (ctx->input != NULL)
+		i_stream_unref(&ctx->input);
+
+	if (ctx->save_ctx != NULL)
+	{
+		ctx->client->input_skip_line = TRUE;
+		sieve_storage_save_cancel(&ctx->save_ctx);
+	}
+}
+
+static bool cmd_putscript_continue_cancel(struct client_command_context *cmd)
+{
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+
+	(void)i_stream_read(ctx->input);
+	(void)i_stream_get_data(ctx->input, &size);
+	i_stream_skip(ctx->input, size);
+
+	if ( cmd->client->input->closed ||
+		ctx->input->v_offset == ctx->script_size ) {
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool cmd_putscript_cancel(struct cmd_putscript_context *ctx, bool nonsync)
+{
+	ctx->client->input_skip_line = TRUE;
+
+	if (!nonsync) { /* Rediculous for managesieve */
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* we have to read the nonsynced literal so we don't treat the uploaded script
+	   as commands. */
+	ctx->input = i_stream_create_limit(ctx->client->input, ctx->script_size);
+
+	ctx->client->command_pending = TRUE;
+	ctx->cmd->func = cmd_putscript_continue_cancel;
+	ctx->cmd->context = ctx;
+	return cmd_putscript_continue_cancel(ctx->cmd);
+}
+
+static bool cmd_putscript_finish_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	struct sieve_script *script;
+	int ret;
+	
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+	
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+          MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1 || client->output->closed) {
+		if (ctx->storage != NULL)
+			client_send_command_error(cmd, NULL);
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args[0].type == MANAGESIEVE_ARG_EOL) {
+		/* Last (and only) script */
+		bool success = TRUE;
+
+		/* Eat away the trailing CRLF */
+		client->input_skip_line = TRUE;
+
+		/* Obtain script object for uploaded script */
+		script = sieve_storage_save_get_tempscript(ctx->save_ctx);
+
+		/* Check result */
+		if ( script == NULL ) {
+			client_send_storage_error(client, ctx->storage);
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		}
+
+		/* Try to compile script */
+		T_BEGIN {
+			struct sieve_error_handler *ehandler;
+			string_t *errors;
+
+			/* Prepare error handler */
+			errors = t_str_new(1024);
+			ehandler = sieve_strbuf_ehandler_create
+				(errors, TRUE, DEFAULT_MANAGESIEVE_SIEVE_MAX_ERRORS);
+
+			/* Compile */
+			if ( script == NULL || (sieve_compile_script(script, ehandler) == NULL)) {
+				client_send_no(client, str_c(errors));
+				success = FALSE;
+			} else {
+				/* Commit to save only when this is a putscript command */
+				if ( ctx->scriptname != NULL ) { 
+					ret = sieve_storage_save_commit(&ctx->save_ctx);
+
+					/* Check commit */			
+					if (ret < 0) {
+						client_send_storage_error(client, ctx->storage);
+						success = FALSE;
+					}
+				} 
+			}
+
+			/* Finish up */
+			cmd_putscript_finish(ctx);
+
+			/* Report result to user */
+			if ( success ) {
+				if ( sieve_get_warnings(ehandler) > 0 ) 
+					client_send_okresp(client, "WARNINGS", str_c(errors));
+				else {
+					if ( ctx->scriptname != NULL )
+						client_send_ok(client, "PUTSCRIPT completed.");
+					else
+						client_send_ok(client, "Script checked successfully.");						
+				}
+			}
+
+			sieve_error_handler_unref(&ehandler);
+		} T_END;
+
+		
+		return TRUE;
+	}
+
+	client_send_command_error(cmd, "Too many command arguments.");
+	cmd_putscript_finish(ctx);
+	return TRUE;
+}
+
+static bool cmd_putscript_continue_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	bool nonsync = FALSE;
+	int ret;
+
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+				    MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1 || client->output->closed) {
+		cmd_putscript_finish(ctx);
+		client_send_command_error(cmd, "Invalid arguments.");
+		client->input_skip_line = TRUE;
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args->type != MANAGESIEVE_ARG_STRING) {
+		/* Validate the script argument */
+	  	if (args->type != MANAGESIEVE_ARG_LITERAL_SIZE ) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			return cmd_putscript_cancel(ctx, FALSE);
+		}
+
+		ctx->script_size = MANAGESIEVE_ARG_LITERAL_SIZE(args);
+		nonsync = TRUE;
+	} else {
+		/* FIXME */
+		client_send_no(client, 
+			"This MANAGESIEVE implementation currently does not allow "
+			"quoted strings to be used for script contents.");
+		return cmd_putscript_cancel(ctx, FALSE);		
+	}
+
+	if (ctx->script_size == 0) {
+		/* no script content, abort */
+		if ( ctx->scriptname != NULL ) 
+			client_send_no(client, "PUTSCRIPT aborted (empty script).");
+		else
+			client_send_no(client, "CHECKSCRIPT aborted (empty script).");
+
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* save the script */
+	ctx->input = i_stream_create_limit(client->input, ctx->script_size);
+	ctx->save_ctx = sieve_storage_save_init
+		(ctx->storage, ctx->scriptname, ctx->input);
+
+	if ( ctx->save_ctx == NULL ) {
+		/* save initialization failed */
+		client_send_storage_error(client, ctx->storage);
+		return cmd_putscript_cancel(ctx, nonsync);
+	}
+
+	/* after literal comes CRLF, if we fail make sure we eat it away */
+	client->input_skip_line = TRUE;
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_putscript_continue_script;
+	return cmd_putscript_continue_script(cmd);
+}
+
+static bool cmd_putscript_continue_script(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+	bool failed;
+	int ret;
+
+	if (ctx->save_ctx != NULL) {
+		while (ctx->input->v_offset != ctx->script_size) {
+			ret = i_stream_read(ctx->input);
+			if (sieve_storage_save_continue(ctx->save_ctx) < 0) {
+				/* we still have to finish reading the script
+			   	  from client */
+				sieve_storage_save_cancel(&ctx->save_ctx);
+				break;
+			}
+			if (ret == -1 || ret == 0)
+                break;
+		}
+	}
+
+	if (ctx->save_ctx == NULL) {
+		(void)i_stream_read(ctx->input);
+		(void)i_stream_get_data(ctx->input, &size);
+		i_stream_skip(ctx->input, size);
+	}
+
+	if (ctx->input->eof || client->input->closed) {
+		bool all_written = ctx->input->v_offset == ctx->script_size;
+
+		/* finished */
+		i_stream_unref(&ctx->input);
+		ctx->input = NULL;
+
+		if (ctx->save_ctx == NULL) {
+			/* failed above */
+			client_send_storage_error(client, ctx->storage);
+			failed = TRUE;
+		} else if (!all_written) {
+			/* client disconnected before it finished sending the
+			   whole script. */
+			failed = TRUE;
+			sieve_storage_save_cancel(&ctx->save_ctx);
+			client_disconnect(client, "EOF while appending in PUTSCRIPT/CHECKSCRIPT");
+		} else if (sieve_storage_save_finish(ctx->save_ctx) < 0) {
+			failed = TRUE;
+			client_send_storage_error(client, ctx->storage);
+		} else {
+			failed = client->input->closed;
+		}
+
+		if (failed) {
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		}
+
+		/* finish */
+		client->command_pending = FALSE;
+		managesieve_parser_reset(ctx->save_parser);
+		cmd->func = cmd_putscript_finish_parsing;
+		return cmd_putscript_finish_parsing(cmd);
+	}
+
+	return FALSE;
+}
+
+static bool cmd_putscript_start
+(struct client_command_context *cmd, const char *scriptname)
+{
+	struct cmd_putscript_context *ctx;
+	struct client *client = cmd->client;
+
+	ctx = p_new(cmd->pool, struct cmd_putscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->scriptname = scriptname;
+
+	io_remove(&client->io);
+	client->io = io_add(i_stream_get_fd(client->input), IO_READ,
+			    client_input_putscript, client);
+	/* putscript is special because we're only waiting on client input, not
+	   client output, so disable the standard output handler until we're
+	   finished */
+	o_stream_unset_flush_callback(client->output);
+
+	ctx->save_parser = managesieve_parser_create(client->input, client->output,
+					      managesieve_max_line_length);
+
+	cmd->func = cmd_putscript_continue_parsing;
+	cmd->context = ctx;
+	return cmd_putscript_continue_parsing(cmd);
+
+}
+
+bool cmd_putscript(struct client_command_context *cmd)
+{
+	const char *scriptname;
+
+	/* <scriptname> */
+	if ( !client_read_string_args(cmd, 1, &scriptname) || *scriptname == '\0' )
+		return FALSE;
+
+	return cmd_putscript_start(cmd, scriptname);
+}
+
+bool cmd_checkscript(struct client_command_context *cmd)
+{
+	return cmd_putscript_start(cmd, NULL);
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-renamescript.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-renamescript.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-renamescript.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-renamescript.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "str.h"
+
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+#include <stdlib.h>
+
+bool cmd_renamescript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname, *newname;
+	struct sieve_script *script;
+	bool exists;
+
+	/* <oldname> <newname> */
+	if (!client_read_string_args(cmd, 2, &scriptname, &newname))
+		return FALSE;
+
+	exists = TRUE;
+	script = sieve_storage_script_init(storage, scriptname, &exists);
+
+	if (script == NULL) {
+		if (!exists)
+			client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+		else
+			client_send_storage_error(client, storage);
+
+		return TRUE;
+	}
+
+	if (sieve_storage_script_rename(script, newname) < 0)
+		client_send_storage_error(client, storage);
+	else    
+		client_send_ok(client, "Renamescript completed.");
+
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-setactive.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-setactive.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/cmd-setactive.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/cmd-setactive.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+bool cmd_setactive(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+	int ret;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	if ( *scriptname != '\0' ) {
+		exists = TRUE;
+		script = sieve_storage_script_init(storage, scriptname, &exists);
+
+		if ( script == NULL ) {
+			if (!exists)
+				client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+			else
+				client_send_storage_error(client, storage);
+
+			return TRUE;
+		}
+	
+		ret = sieve_storage_script_activate(script);
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ? 
+				"Setactive completed." :
+				"Script is already active.");
+
+		sieve_script_unref(&script);
+	} else {
+		ret = sieve_storage_deactivate(storage);
+		
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ?
+ 				"Active script is now deactivated." :
+				"No scripts currently active.");	
+	}
+
+	return TRUE;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/commands.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/commands.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/commands.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/commands.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,115 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "array.h"
+#include "commands.h"
+
+#include <stdlib.h>
+
+/* Might want to combine this somewhere in a commands-common.c 
+ * to avoid duplicate code 
+ */
+
+const struct command managesieve_commands[] = {
+	{ "CAPABILITY", cmd_capability },
+	{ "LOGOUT", cmd_logout },
+	{ "PUTSCRIPT", cmd_putscript },
+	{ "CHECKSCRIPT", cmd_checkscript },
+	{ "GETSCRIPT", cmd_getscript },
+	{ "SETACTIVE", cmd_setactive },
+	{ "DELETESCRIPT", cmd_deletescript },
+	{ "LISTSCRIPTS", cmd_listscripts },
+	{ "HAVESPACE", cmd_havespace },
+	{ "RENAMESCRIPT", cmd_renamescript },
+	{ "NOOP", cmd_noop }
+};
+
+#define MANAGESIEVE_COMMANDS_COUNT N_ELEMENTS(managesieve_commands) 
+
+static ARRAY_DEFINE(commands, struct command);
+static bool commands_unsorted;
+
+void command_register(const char *name, command_func_t *func)
+{
+	struct command cmd;
+
+	cmd.name = name;
+	cmd.func = func;
+	array_append(&commands, &cmd, 1);
+
+	commands_unsorted = TRUE;
+}
+
+void command_unregister(const char *name)
+{
+	const struct command *cmd;
+	unsigned int i, count;
+
+	cmd = array_get(&commands, &count);
+	for (i = 0; i < count; i++) {
+		if (strcasecmp(cmd[i].name, name) == 0) {
+			array_delete(&commands, i, 1);
+			return;
+		}
+	}
+
+	i_error("Trying to unregister unknown command '%s'", name);
+}
+
+void command_register_array(const struct command *cmdarr, unsigned int count)
+{
+	commands_unsorted = TRUE;
+	array_append(&commands, cmdarr, count);
+}
+
+void command_unregister_array(const struct command *cmdarr, unsigned int count)
+{
+	while (count > 0) {
+		command_unregister(cmdarr->name);
+		count--; cmdarr++;
+	}
+}
+
+static int command_cmp(const void *p1, const void *p2)
+{
+	const struct command *c1 = p1, *c2 = p2;
+
+	return strcasecmp(c1->name, c2->name);
+}
+
+static int command_bsearch(const void *name, const void *cmd_p)
+{
+	const struct command *cmd = cmd_p;
+
+	return strcasecmp(name, cmd->name);
+}
+
+struct command *command_find(const char *name)
+{
+    void *base;
+    unsigned int count;
+
+    base = array_get_modifiable(&commands, &count);
+    if (commands_unsorted) {
+        qsort(base, count, sizeof(struct command), command_cmp);
+                commands_unsorted = FALSE;
+    }
+
+    return bsearch(name, base, count, sizeof(struct command),
+               command_bsearch);
+}
+
+void commands_init(void)
+{
+	i_array_init(&commands, 16);
+	commands_unsorted = FALSE;
+	
+	command_register_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+}
+
+void commands_deinit(void)
+{
+	command_unregister_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+	array_free(&commands);
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/commands.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/commands.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/commands.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/commands.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,49 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __COMMANDS_H
+#define __COMMANDS_H
+
+struct client_command_context;
+
+#include "managesieve-parser.h"
+
+typedef bool command_func_t(struct client_command_context *cmd);
+
+struct command {
+	const char *name;
+	command_func_t *func;
+};
+
+/* Register command. Given name parameter must be permanently stored until
+   command is unregistered. */
+void command_register(const char *name, command_func_t *func);
+void command_unregister(const char *name);
+
+/* Register array of commands. */
+void command_register_array(const struct command *cmdarr, unsigned int count);
+void command_unregister_array(const struct command *cmdarr, unsigned int count);
+
+struct command *command_find(const char *name);
+
+void commands_init(void);
+void commands_deinit(void);
+
+/* MANAGESIEVE commands: */
+
+/* Non-Authenticated State */
+extern bool cmd_logout(struct client_command_context *cmd);
+extern bool cmd_capability(struct client_command_context *cmd);
+extern bool cmd_noop(struct client_command_context *cmd);
+
+/* Authenticated State */
+extern bool cmd_putscript(struct client_command_context *cmd);
+extern bool cmd_checkscript(struct client_command_context *cmd);
+extern bool cmd_getscript(struct client_command_context *cmd);
+extern bool cmd_setactive(struct client_command_context *cmd);
+extern bool cmd_deletescript(struct client_command_context *cmd);
+extern bool cmd_listscripts(struct client_command_context *cmd);
+extern bool cmd_havespace(struct client_command_context *cmd);
+extern bool cmd_renamescript(struct client_command_context *cmd);
+
+#endif /* __COMMANDS_H */
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/common.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/common.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/common.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/common.h	2009-01-27 16:03:40.000000000 +0000
@@ -0,0 +1,46 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#include "lib.h"
+#include "client.h"
+
+#include "dmanagesieve-config.h"
+
+/* Disconnect client after idling this many milliseconds */
+#define CLIENT_IDLE_TIMEOUT_MSECS (60*30*1000)
+
+/* If we can't send anything to client for this long, disconnect the client */
+#define CLIENT_OUTPUT_TIMEOUT_MSECS (5*60*1000)
+
+/* Stop buffering more data into output stream after this many bytes */
+#define CLIENT_OUTPUT_OPTIMAL_SIZE 2048
+
+/* Disconnect client when it sends too many bad commands in a row */
+#define CLIENT_MAX_BAD_COMMANDS 20
+
+/* RFC-2683 recommends at least 8000 bytes. Some clients however don't
+   break large message sets to multiple commands, so we're pretty liberal
+   by default. */
+#define DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH 65536
+
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING MANAGESIEVE_NAME
+
+#define DEFAULT_MANAGESIEVE_SIEVE_MAX_ERRORS 10
+
+enum client_workarounds {
+  WORKAROUND_NONE    = 0x00,
+};
+
+extern struct ioloop *ioloop;
+extern unsigned int managesieve_max_line_length;
+extern const char *managesieve_implementation_string;
+extern enum client_workarounds client_workarounds;
+extern const char *logout_format;
+
+//extern void (*hook_mail_storage_created)(struct sieve_storage *storage);
+extern void (*hook_client_created)(struct client **client);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/main.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/main.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/main.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/main.c	2009-06-18 22:01:53.000000000 +0000
@@ -0,0 +1,349 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "ioloop.h"
+#include "network.h"
+#include "ostream.h"
+#include "str.h"
+#include "lib-signals.h"
+#include "restrict-access.h"
+#include "fd-close-on-exec.h"
+#include "process-title.h"
+#include "randgen.h"
+#include "module-dir.h"
+#include "dict-client.h"
+
+#include "sieve-storage.h"
+#include "sieve.h"
+
+#include "commands.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+
+#define IS_STANDALONE() \
+        (getenv("LOGGED_IN") == NULL)
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+struct client_workaround_list {
+	const char *name;
+	enum client_workarounds num;
+};
+
+struct client_workaround_list client_workaround_list[] = {
+	{ NULL, 0 }
+};
+
+struct ioloop *ioloop;
+unsigned int managesieve_max_line_length;
+const char *managesieve_implementation_string;
+enum client_workarounds client_workarounds = 0;
+const char *logout_format;
+
+static struct io *log_io = NULL;
+static struct module *modules = NULL;
+static char log_prefix[128]; /* syslog() needs this to be permanent */
+
+void (*hook_client_created)(struct client **client) = NULL;
+
+static void sig_die(const siginfo_t *si, void *context ATTR_UNUSED)
+{
+	/* Warn about being killed because of some signal, except SIGINT (^C) */
+	if (si->si_signo != SIGINT) {
+		i_warning("Killed with signal %d (by pid=%s uid=%s code=%s)",
+			si->si_signo, dec2str(si->si_pid),
+			dec2str(si->si_uid),
+			lib_signal_code_to_str(si->si_signo, si->si_code));
+	}
+	io_loop_stop(ioloop);
+}
+
+static void log_error_callback(void *context ATTR_UNUSED)
+{
+	io_loop_stop(ioloop);
+}
+
+static void parse_workarounds(void)
+{
+	struct client_workaround_list *list;
+	const char *env, *const *str;
+
+	env = getenv("MANAGESIEVE_CLIENT_WORKAROUNDS");
+	if (env == NULL)
+		return;
+
+	for (str = t_strsplit_spaces(env, " ,"); *str != NULL; str++) {
+		list = client_workaround_list;
+		for (; list->name != NULL; list++) {
+			if (strcasecmp(*str, list->name) == 0) {
+				client_workarounds |= list->num;
+				break;
+			}
+		}
+		if (list->name == NULL)
+			i_fatal("Unknown client workaround: %s", *str);
+	}
+}
+
+static void open_logfile(void)
+{
+	const char *user;
+
+	if (getenv("LOG_TO_MASTER") != NULL) {
+		i_set_failure_internal();
+		return;
+	}
+
+ 	if (getenv("LOG_PREFIX") != NULL)
+		strncpy(log_prefix, getenv("LOG_PREFIX"), sizeof(log_prefix));
+	else {
+		user = getenv("USER");
+		if (user == NULL) {
+			if (IS_STANDALONE())
+				user = getlogin();
+			if (user == NULL)
+				user = "??";
+		}
+		if (strlen(user) >= sizeof(log_prefix)-6) {	
+			/* quite a long user name, cut it */
+ 			user = t_strndup(user, sizeof(log_prefix)-6-2);
+			user = t_strconcat(user, "..", NULL);
+		}
+		i_snprintf(log_prefix, sizeof(log_prefix), "imap(%s): ", user);
+	}
+
+	if (getenv("USE_SYSLOG") != NULL) {
+		const char *env = getenv("SYSLOG_FACILITY");
+		i_set_failure_syslog(log_prefix, LOG_NDELAY,
+				     env == NULL ? LOG_MAIL : atoi(env));
+	} else {
+		/* log to file or stderr */
+		i_set_failure_file(getenv("LOGFILE"), log_prefix);
+	}
+
+	if (getenv("INFOLOGFILE") != NULL)
+		i_set_info_file(getenv("INFOLOGFILE"));
+
+	i_set_failure_timestamp_format(getenv("LOGSTAMP"));
+}
+
+static void drop_privileges(void)
+{
+	const char *version;
+
+	version = getenv("DOVECOT_VERSION");
+	if (version != NULL && strcmp(version, PACKAGE_VERSION) != 0) {
+		i_fatal("Dovecot version mismatch: "
+			"Master is v%s, managesieve is v"PACKAGE_VERSION" "
+			"(if you don't care, set version_ignore=yes)", version);
+	}
+
+	/* Log file or syslog opening probably requires roots */
+	open_logfile();
+
+	/* Most likely needed. Have to open /dev/urandom before possible
+	   chrooting. */
+	random_init();
+	
+	/* Load the plugins before chrooting. Their init() is called later. */
+	/* FIXME: MAIL_PLUGINS is a rather odd config value for a MANAGESIEVE
+	 * server 
+	 */
+	if (getenv("MAIL_PLUGINS") != NULL) {
+		const char *plugin_dir = getenv("MAIL_PLUGIN_DIR");
+
+		if (plugin_dir == NULL)
+			plugin_dir = MODULEDIR"/managesieve";
+		modules = module_dir_load(plugin_dir, getenv("MAIL_PLUGINS"),
+			TRUE, version);
+	}	
+
+	restrict_access_by_env(!IS_STANDALONE());
+}
+
+static void internal_error()
+{
+  struct tm *tm;
+  char str[256];
+
+  tm = localtime(&ioloop_time);
+
+  printf("BYE \"%s\"\n",
+    strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+    i_strdup(str) : i_strdup(CRITICAL_MSG));
+}
+
+static void main_init(void)
+{
+	struct sieve_storage *storage;
+	struct client *client;
+	const char *user, *str, *sieve_storage, *mail;
+	const char *extensions;
+
+	lib_signals_init();
+	lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+	lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+	lib_signals_ignore(SIGPIPE, TRUE);
+	lib_signals_ignore(SIGALRM, FALSE);
+
+	user = getenv("USER");
+	if (user == NULL) {
+		if (IS_STANDALONE())
+			user = getlogin();
+		if (user == NULL) {
+			internal_error();
+			i_fatal("USER environment missing");
+		}
+	}
+
+	if (getenv("DEBUG") != NULL) {
+		const char *home;
+
+        home = getenv("HOME");
+        i_info("Effective uid=%s, gid=%s, home=%s",
+               dec2str(geteuid()), dec2str(getegid()),
+               home != NULL ? home : "(none)");
+	}
+	
+	if (getenv("STDERR_CLOSE_SHUTDOWN") != NULL) {
+		/* If master dies, the log fd gets closed and we'll quit */
+		log_io = io_add(STDERR_FILENO, IO_ERROR,
+				log_error_callback, NULL);
+	}
+
+	sieve_init();
+	dict_drivers_register_builtin();
+	clients_init();
+	commands_init();
+
+	module_dir_init(modules);
+
+	/* Sieve settings */
+	
+	extensions = getenv("SIEVE_EXTENSIONS");
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Dump capabilities if requested */
+
+	if ( getenv("DUMP_CAPABILITY") != NULL ) {
+		const char *notify_cap = sieve_get_capabilities("notify");
+
+		if ( notify_cap == NULL ) 
+			printf("SIEVE: %s\n", sieve_get_capabilities(NULL));
+		else
+			printf("SIEVE: %s, NOTIFY: %s\n", sieve_get_capabilities(NULL),
+				sieve_get_capabilities("notify"));
+		exit(0);
+	}
+
+	/* Service settings */
+
+	str = getenv("MANAGESIEVE_MAX_LINE_LENGTH");
+	managesieve_max_line_length = str != NULL ?
+		(unsigned int)strtoul(str, NULL, 10) :
+		DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH;
+
+	logout_format = getenv("MANAGESIEVE_LOGOUT_FORMAT");
+	if (logout_format == NULL)
+		logout_format = "bytes=%i/%o";
+
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+		str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	parse_workarounds();
+
+	/* Obtain Sieve storage */		
+
+	mail = getenv("MAIL");
+	sieve_storage = getenv("SIEVE_DIR");
+	
+	if ( sieve_storage == NULL || *sieve_storage == '\0' ) {
+		/* Storage perhaps specified as depricated sieve_storage? */
+		sieve_storage = getenv("SIEVE_STORAGE");
+	}		
+
+	if ( (sieve_storage == NULL || *sieve_storage == '\0') &&
+		!(mail == NULL || *mail == '\0') ) {
+		storage = sieve_storage_create_from_mail(mail, user);
+	} else 
+		storage = sieve_storage_create(sieve_storage, user);
+
+	if (storage == NULL) {
+		internal_error();
+
+		/* failed */
+		if (sieve_storage != NULL && *sieve_storage != '\0')
+			i_fatal("Failed to create sieve storage with data: %s", sieve_storage);
+		else if (mail != NULL && *mail != '\0')
+			i_fatal("Failed to create sieve storage with mail-data: %s", mail);
+		else {
+			const char *home;
+	    
+			home = getenv("HOME");
+			if (home == NULL) home = "not set";
+	    
+			i_fatal("SIEVE_STORAGE and MAIL environment missing and "
+				"autodetection failed (home %s)", home);
+		}
+	}
+	
+	client = client_create(0, 1, storage);
+	
+	client_send_ok(client, "Logged in.");
+}
+
+static void main_deinit(void)
+{
+	if (log_io != NULL)
+		io_remove(&log_io);
+	clients_deinit();
+
+	module_dir_unload(&modules);
+	commands_deinit();
+	dict_drivers_unregister_builtin();
+	sieve_deinit();
+	random_deinit();
+
+	lib_signals_deinit();
+	closelog();
+}
+
+int main(int argc ATTR_UNUSED, char *argv[], char *envp[])
+{
+#ifdef DEBUG
+	if (getenv("LOGGED_IN") != NULL && getenv("GDB") == NULL)
+		fd_debug_verify_leaks(3, 1024);
+#endif
+	if (IS_STANDALONE() && getuid() == 0 &&
+		net_getpeername(1, NULL, NULL) == 0) {
+		printf("NO \"managesieve binary must not be started from "
+		       "inetd, use managesieve-login instead.\"\n");
+		return 1;
+	}
+
+	/* NOTE: we start rooted, so keep the code minimal until
+	   restrict_access_by_env() is called */
+	lib_init();
+	drop_privileges();
+
+	process_title_init(argv, envp);
+	ioloop = io_loop_create();
+
+	main_init();
+	io_loop_run(ioloop);
+	main_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+
+	return 0;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve/Makefile.am dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/Makefile.am
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve/Makefile.am	2008-11-21 21:25:03.000000000 +0000
@@ -0,0 +1,64 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-DMODULEDIR=\""$(moduledir)"\" \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_LDFLAGS = -export-dynamic
+
+libs = \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+
+managesieve_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS) 
+
+managesieve_DEPENDENCIES = $(libs)
+
+cmds = \
+	cmd-capability.c \
+	cmd-logout.c \
+	cmd-putscript.c \
+	cmd-getscript.c \
+	cmd-setactive.c \
+	cmd-deletescript.c \
+	cmd-listscripts.c \
+	cmd-havespace.c \
+	cmd-renamescript.c \
+	cmd-noop.c
+
+managesieve_SOURCES = \
+	$(cmds) \
+	client.c \
+	commands.c \
+	main.c 
+
+noinst_HEADERS = \
+	client.h \
+	commands.h \
+	common.h 
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client-authenticate.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client-authenticate.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client-authenticate.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client-authenticate.c	2009-05-03 14:09:16.000000000 +0000
@@ -0,0 +1,411 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "base64.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+#include "auth-client.h"
+#include "client.h"
+#include "client-authenticate.h"
+#include "managesieve-proxy.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+
+#define AUTH_FAILURE_DELAY_INCREASE_MSECS 5000
+
+#define MANAGESIEVE_SERVICE_NAME "sieve"
+
+/* FIXME: The use of the ANONYMOUS mechanism is currently denied 
+ */
+static bool _sasl_mechanism_acceptable
+	(const struct auth_mech_desc *mech, bool secured) {
+
+	/* a) transport is secured
+	   b) auth mechanism isn't plaintext
+       c) we allow insecure authentication
+	 */
+
+	if ((mech->flags & MECH_SEC_PRIVATE) == 0 &&
+		(mech->flags & MECH_SEC_ANONYMOUS) == 0 &&
+ 		(secured || !disable_plaintext_auth ||
+		(mech->flags & MECH_SEC_PLAINTEXT) == 0)) {
+    		return 1;     
+	}  
+
+	return 0;
+}
+
+const char *client_authenticate_get_capabilities(bool secured)
+{
+	const struct auth_mech_desc *mech;
+	unsigned int i, count;
+	string_t *str;
+
+	str = t_str_new(128);
+	mech = auth_client_get_available_mechs(auth_client, &count);
+
+	if ( count > 0 ) {
+		if ( _sasl_mechanism_acceptable(&(mech[0]), secured) ) {
+			str_append(str, mech[0].name);
+		}
+     
+		for (i = 1; i < count; i++) {
+			if ( _sasl_mechanism_acceptable(&(mech[i]), secured) ) {
+				str_append_c(str, ' ');
+				str_append(str, mech[i].name);
+			}
+		}
+	}
+
+	return str_c(str);
+}
+
+static void client_auth_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	char *line;
+	bool fatal;
+
+	if (!client_read(client))
+		return;
+
+	if (client->skip_line) {
+		if (i_stream_next_line(client->common.input) == NULL)
+			return;
+
+		client->skip_line = FALSE;
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			/* FIXME: What to do? */
+		}
+	  
+		sasl_server_auth_client_error(&client->common, msg);
+		return;
+	case -2:
+		/* not enough data */
+		return;
+	}
+
+	client->skip_line = TRUE;
+
+	if (args[0].type != MANAGESIEVE_ARG_STRING || 
+		args[1].type != MANAGESIEVE_ARG_EOL) {
+		sasl_server_auth_client_error(&client->common, 
+			"Invalid AUTHENTICATE client response.");
+		return;
+	}
+
+	line = MANAGESIEVE_ARG_STR(&args[0]);
+
+	auth_client_request_continue(client->common.auth_request, line);
+	io_remove(&client->io);
+
+	/* clear sensitive data */
+	safe_memset(line, 0, strlen(line));
+}
+
+static void client_authfail_delay_timeout(struct managesieve_client *client)
+{
+	timeout_remove(&client->to_authfail_delay);
+
+	/* get back to normal client input. */
+	i_assert(client->io == NULL);
+	client->io = io_add(client->common.fd, IO_READ, client_input, client);
+	client_input(client);
+}
+
+void client_auth_failed(struct managesieve_client *client, bool nodelay)
+{
+	unsigned int delay_msecs;
+
+	client->common.auth_command_tag = NULL;
+
+	if ( client->auth_initializing )
+		return;
+
+	if ( client->io != NULL )
+		io_remove(&client->io);
+	if ( nodelay ) {
+		client->io = io_add(client->common.fd, IO_READ, client_input, client);
+ 		client_input(client);
+		return;
+	}
+
+	/* increase the timeout after each unsuccessful attempt, but don't
+		increase it so high that the idle timeout would be triggered */
+	delay_msecs = client->common.auth_attempts *
+		AUTH_FAILURE_DELAY_INCREASE_MSECS;
+	if (delay_msecs > CLIENT_LOGIN_IDLE_TIMEOUT_MSECS)
+		delay_msecs = CLIENT_LOGIN_IDLE_TIMEOUT_MSECS - 1000;
+
+	i_assert(client->to_authfail_delay == NULL);
+	client->to_authfail_delay =
+		timeout_add(delay_msecs, client_authfail_delay_timeout, client);
+}
+
+static bool client_handle_args(struct managesieve_client *client,
+	const char *const *args, bool success, bool *nodelay_r)
+{
+	const char *reason = NULL, *host = NULL, *destuser = NULL, *pass = NULL;
+	const char *master_user = NULL;
+	const char *key, *value, *p;
+	enum login_proxy_ssl_flags ssl_flags = 0;
+	unsigned int port = 2000;
+	bool proxy = FALSE, temp = FALSE, nologin = !success;
+	bool authz_failure = FALSE;
+
+	*nodelay_r = FALSE;
+	for (; *args != NULL; args++) {
+		p = strchr(*args, '=');
+		if (p == NULL) {
+			key = *args;
+			value = "";
+		} else {
+			key = t_strdup_until(*args, p);
+			value = p + 1;
+		}
+		if (strcmp(key, "nologin") == 0)
+			nologin = TRUE;
+		else if (strcmp(key, "nodelay") == 0)
+			*nodelay_r = TRUE;
+		else if (strcmp(key, "proxy") == 0)
+			proxy = TRUE;
+		else if (strcmp(key, "temp") == 0)
+			temp = TRUE;
+		else if (strcmp(key, "authz") == 0)
+			authz_failure = TRUE;
+		else if (strcmp(key, "reason") == 0)
+			reason = value + 7;
+		else if (strcmp(key, "host") == 0)
+			host = value;
+		else if (strcmp(key, "port") == 0)
+			port = atoi(value);
+		else if (strcmp(key, "destuser") == 0)
+			destuser = value;
+		else if (strcmp(key, "pass") == 0)
+			pass = value;
+		else if (strcmp(key, "master") == 0)
+			master_user = value;
+		else if (strcmp(key, "ssl") == 0) {
+			if (strcmp(value, "yes") == 0)
+				ssl_flags |= PROXY_SSL_FLAG_YES;
+			else if (strcmp(value, "any-cert") == 0) {
+				ssl_flags |= PROXY_SSL_FLAG_YES |
+					PROXY_SSL_FLAG_ANY_CERT;
+			}
+		} else if (strcmp(key, "starttls") == 0) {
+			ssl_flags |= PROXY_SSL_FLAG_STARTTLS;
+		} else if (strcmp(key, "user") == 0) {
+			/* already handled in login-common */
+		} else if (auth_debug) {
+			i_info("Ignoring unknown passdb extra field: %s", key);
+		}
+	}
+
+	if (destuser == NULL)
+		destuser = client->common.virtual_user;
+
+	if (proxy) {
+		/* we want to proxy the connection to another server.
+		don't do this unless authentication succeeded. with
+		master user proxying we can get FAIL with proxy still set.
+
+		proxy host=.. [port=..] [destuser=..] pass=.. */
+		if (!success)
+			return FALSE;
+		if (managesieve_proxy_new(client, host, port, destuser, master_user,
+			pass, ssl_flags) < 0)
+			client_auth_failed(client, TRUE);
+		return TRUE;
+	}
+
+	if (host != NULL) {
+		string_t *resp_code;
+
+		/* MANAGESIEVE referral
+
+		   [nologin] referral host=.. [port=..] [destuser=..]
+		   [reason=..]
+
+		   NO (REFERRAL sieve://user;AUTH=mech@host:port/) Can't login.
+		   OK (...) Logged in, but you should use this server instead.
+		   .. [REFERRAL ..] (Reason from auth server)
+		*/
+		resp_code = t_str_new(128);
+		str_printfa(resp_code, "REFERRAL sieve://%s;AUTH=%s@%s",
+			    destuser, client->common.auth_mech_name, host);
+		if (port != 2000)
+			str_printfa(resp_code, ":%u", port);
+
+		if (reason == NULL) {
+			if (nologin)
+				reason = "Try this server instead.";
+			else 
+				reason = "Logged in, but you should use "
+					"this server instead.";
+		}
+
+		if (!nologin) {
+			client_send_okresp(client, str_c(resp_code), reason);
+			client_destroy_success(client, "Login with referral");
+			return TRUE;
+ 		}
+		client_send_noresp(client, str_c(resp_code), reason);
+	} else if (nologin) {
+		/* Authentication went ok, but for some reason user isn't
+		   allowed to log in. Shouldn't probably happen. */
+		if (reason != NULL)
+			client_send_no(client, reason);
+		else if (temp)
+			client_send_no(client, AUTH_TEMP_FAILED_MSG);
+		else if (authz_failure) 
+			client_send_no(client, "Authorization failed.");
+		else
+			client_send_no(client, AUTH_FAILED_MSG);
+	} else {
+		/* normal login/failure */
+		return FALSE;
+	}
+
+	i_assert(nologin);
+
+	managesieve_parser_reset(client->parser);
+
+	if (!client->destroyed) 
+		client_auth_failed(client, *nodelay_r);
+	return TRUE;
+}
+
+static void sasl_callback(struct client *_client, enum sasl_server_reply reply,
+			  const char *data, const char *const *args)
+{
+	struct managesieve_client *client = (struct managesieve_client *)_client;
+	string_t *str;
+	bool nodelay;
+
+	i_assert(!client->destroyed ||
+		reply == SASL_SERVER_REPLY_CLIENT_ERROR ||
+		reply == SASL_SERVER_REPLY_MASTER_FAILED);
+
+	switch (reply) {
+	case SASL_SERVER_REPLY_SUCCESS:
+		if ( client->to_auth_waiting != NULL )
+			timeout_remove(&client->to_auth_waiting);
+		if (args != NULL) {
+			if (client_handle_args(client, args, TRUE, &nodelay))
+				break;
+		}
+
+		client_destroy_success(client, "Login");
+		break;
+
+	case SASL_SERVER_REPLY_AUTH_FAILED:
+	case SASL_SERVER_REPLY_CLIENT_ERROR:
+		if ( client->to_auth_waiting != NULL )
+			timeout_remove(&client->to_auth_waiting);
+		if (args != NULL) {
+			if (client_handle_args(client, args, FALSE, &nodelay))
+				break;
+		}
+
+		client_send_no(client, data != NULL ? data : AUTH_FAILED_MSG);
+
+		managesieve_parser_reset(client->parser);
+
+		if (!client->destroyed) 
+			client_auth_failed(client, nodelay);
+		break;
+
+	case SASL_SERVER_REPLY_MASTER_FAILED:
+		if (data == NULL)
+			client_destroy_internal_failure(client);
+		else {
+			client_send_no(client, data);
+			client_destroy_success(client, data);
+		}
+		break;
+
+	case SASL_SERVER_REPLY_CONTINUE:
+		T_BEGIN {
+			str = t_str_new(256);
+			managesieve_quote_append_string(str, data, TRUE);
+			str_append(str, "\r\n");
+				
+			/* don't check return value here. it gets tricky if we try
+			   to call client_destroy() in here. */
+			(void)o_stream_send(client->output, str_c(str), str_len(str));
+		} T_END;
+
+		managesieve_parser_reset(client->parser);
+
+		i_assert(client->io == NULL);
+		client->io = io_add(client->common.fd, IO_READ, client_auth_input, client);
+		client_auth_input(client);
+		return;
+	}
+
+	client_unref(client);
+}
+
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args)
+{
+	const char *mech_name, *init_resp = NULL;
+
+	/* one mandatory argument: authentication mechanism name */
+	if (args[0].type != MANAGESIEVE_ARG_STRING)
+		return -1;
+	if (args[1].type != MANAGESIEVE_ARG_EOL) {
+		/* optional SASL initial response */
+		if (args[1].type != MANAGESIEVE_ARG_STRING ||
+		    args[2].type != MANAGESIEVE_ARG_EOL)
+			return -1;
+		init_resp = MANAGESIEVE_ARG_STR(&args[1]);
+	}
+
+	mech_name = MANAGESIEVE_ARG_STR(&args[0]);
+	if (*mech_name == '\0') 
+		return -1;
+
+	/* FIXME: This refuses the ANONYMOUS mechanism. 
+	 *   This can be removed once anonymous login is implemented according to the 
+	 *   draft RFC. - Stephan
+	 */
+	if ( strncasecmp(mech_name, "ANONYMOUS", 9) == 0 ) {
+		client_send_no(client, "ANONYMOUS mechanism is not implemented.");		
+		return 0;
+	}
+
+	client_ref(client);
+	client->auth_initializing = TRUE;
+	sasl_server_auth_begin(&client->common, MANAGESIEVE_SERVICE_NAME, mech_name,
+		init_resp, sasl_callback);
+	client->auth_initializing = FALSE;
+	if (!client->common.authenticating)
+		return 1;
+
+	/* don't handle input until we get the initial auth reply */
+	if (client->io != NULL)
+		io_remove(&client->io);
+	client_set_auth_waiting(client);
+
+	managesieve_parser_reset(client->parser);
+
+	return 0;
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client-authenticate.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client-authenticate.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client-authenticate.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client-authenticate.h	2009-05-03 13:58:06.000000000 +0000
@@ -0,0 +1,14 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __CLIENT_AUTHENTICATE_H
+#define __CLIENT_AUTHENTICATE_H
+
+const char *client_authenticate_get_capabilities(bool secured);
+
+int cmd_login(struct managesieve_client *client, struct managesieve_arg *args);
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args);
+
+void client_auth_failed(struct managesieve_client *client, bool nodelay);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client.c	2009-06-22 07:23:37.000000000 +0000
@@ -0,0 +1,731 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "process-title.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "strescape.h"
+
+#include "sieve.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+#include "client.h"
+#include "client-authenticate.h"
+#include "commands.h"
+#include "auth-client.h"
+#include "ssl-proxy.h"
+
+#include "managesieve-capability.h"
+#include "managesieve-proxy.h"
+
+#include <stdlib.h>
+
+/* max. size of output buffer. if it gets full, the client is disconnected.
+   SASL authentication gives the largest output. */
+#define MAX_OUTBUF_SIZE 4096
+
+/* Disconnect client when it sends too many bad commands */
+#define CLIENT_MAX_BAD_COMMANDS 10
+
+/* When max. number of simultaneous connections is reached, few of the
+   oldest connections are disconnected. Since we have to go through all of the
+   clients, it's faster if we disconnect multiple clients. */
+#define CLIENT_DESTROY_OLDEST_COUNT 16
+
+/* If we've been waiting auth server to respond for over this many milliseconds,
+   send a "waiting" message. */
+#define AUTH_WAITING_TIMEOUT_MSECS (30*1000)
+
+#if CLIENT_LOGIN_IDLE_TIMEOUT_MSECS < AUTH_REQUEST_TIMEOUT*1000
+#  error client idle timeout must be larger than authentication timeout
+#endif
+
+const char *login_protocol = "MANAGESIEVE";
+const char *capability_string = NULL;
+
+const char *managesieve_implementation_string;
+
+static void client_set_title(struct managesieve_client *client)
+{
+	const char *addr;
+
+	if (!verbose_proctitle || !process_per_connection)
+		return;
+
+	addr = net_ip2addr(&client->common.ip);
+	if (addr == NULL)
+		addr = "??";
+
+	process_title_set(t_strdup_printf(client->common.tls ?
+					  "[%s TLS]" : "[%s]", addr));
+}
+
+static void client_open_streams(struct managesieve_client *client, int fd)
+{
+	client->common.input =
+		i_stream_create_fd(fd, LOGIN_MAX_INBUF_SIZE, FALSE);
+	client->output = o_stream_create_fd(fd, MAX_OUTBUF_SIZE, FALSE);
+	client->parser = managesieve_parser_create(client->common.input, client->output,
+					    MAX_MANAGESIEVE_LINE);
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+bool client_skip_line(struct managesieve_client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->common.input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			i_stream_skip(client->common.input, i+1);
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static void client_send_capabilities(struct managesieve_client *client)
+{
+	const char *saslcap, *sievecap, *notifycap;
+
+	T_BEGIN {
+		/* Get capabilities */
+		sievecap = managesieve_capability_sieve;
+		saslcap = client_authenticate_get_capabilities(client->common.secured);
+		notifycap = managesieve_capability_notify;
+
+		/* Default capabilities */
+		client_send_line(client, t_strconcat("\"IMPLEMENTATION\" \"", 
+			managesieve_implementation_string, "\"", NULL));
+		client_send_line(client, t_strconcat("\"SIEVE\" \"",
+			( sievecap == NULL ? "" : sievecap ), "\"", NULL));
+		client_send_line(client, t_strconcat("\"SASL\" \"", 
+			saslcap, "\"", NULL));
+
+		/* STARTTLS */
+		if (ssl_initialized && !client->common.tls)
+			client_send_line(client, "\"STARTTLS\"" );
+
+		/* Notify methods */
+		if ( notifycap != NULL ) {
+			client_send_line(client, t_strconcat("\"NOTIFY\" \"", 
+				notifycap, "\"", NULL));
+		}
+
+		/* Protocol version */
+		client_send_line(client, "\"VERSION\" \"1.0\"");
+	} T_END;
+}
+
+static int cmd_capability(struct managesieve_client *client)
+{
+	o_stream_cork(client->output);
+
+	client_send_capabilities(client);
+	client_send_ok(client, "Capability completed.");
+
+	o_stream_uncork(client->output);
+
+	return 1;
+}
+
+static void client_start_tls(struct managesieve_client *client)
+{
+	int fd_ssl;
+
+	client_ref(client);
+	connection_queue_add(1);
+	if (!client_unref(client) || client->destroyed)
+		return;
+
+	fd_ssl = ssl_proxy_new(client->common.fd, &client->common.ip,
+			       &client->common.proxy);
+	if (fd_ssl == -1) {
+		client_send_bye(client, "TLS initialization failed.");
+		client_destroy(client, "Disconnected: TLS initialization failed.");
+		return;
+	}
+
+	client->common.tls = TRUE;
+	client->common.secured = TRUE;
+	client_set_title(client);
+
+	client->common.fd = fd_ssl;
+	i_stream_unref(&client->common.input);
+	o_stream_unref(&client->output);
+	managesieve_parser_destroy(&client->parser);
+
+	/* CRLF is lost from buffer when streams are reopened. */
+	client->skip_line = FALSE;
+
+	client_open_streams(client, fd_ssl);
+	client->io = io_add(client->common.fd, IO_READ, client_input, client);
+}
+
+static int client_output_starttls(void *context)
+{
+	struct managesieve_client *client = context;
+	int ret;
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, "Disconnected");
+		return 1;
+	}
+
+	if (ret > 0) {
+		o_stream_unset_flush_callback(client->output);
+		client_start_tls(client);
+	}
+	return 1;
+}
+
+static int cmd_starttls(struct managesieve_client *client)
+{
+	if (client->common.tls) {
+		client_send_no(client, "TLS is already active.");
+		return 1;
+	}
+
+	if (!ssl_initialized) {
+		client_send_no(client, "TLS support isn't enabled.");
+		return 1;
+	}
+
+	/* remove input handler, SSL proxy gives us a new fd. we also have to
+	   remove it in case we have to wait for buffer to be flushed */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	client_send_ok(client, "Begin TLS negotiation now.");
+
+	/* uncork the old fd */
+	o_stream_uncork(client->output);
+
+	if (o_stream_flush(client->output) <= 0) {
+		/* the buffer has to be flushed */
+		o_stream_set_flush_pending(client->output, TRUE);
+		o_stream_set_flush_callback(client->output,
+					    client_output_starttls, client);
+	} else {
+		client_start_tls(client);
+	}
+
+	/* Cork the stream to send the capability data as a single tcp frame
+	 *   Some naive clients break if we don't.
+	 */
+	o_stream_cork(client->output);
+
+	client_send_capabilities(client);
+	client_send_ok(client, "TLS negotiation successful.");
+
+	o_stream_uncork(client->output);
+
+	return 1;
+}
+
+static int cmd_logout(struct managesieve_client *client)
+{
+	client_send_ok(client, "Logout completed.");
+	client_destroy(client, "Aborted login");
+	return 1;
+}
+
+static int client_command_execute(struct managesieve_client *client, const char *cmd,
+				  struct managesieve_arg *args)
+{
+	cmd = t_str_ucase(cmd);
+	if (strcmp(cmd, "AUTHENTICATE") == 0)
+		return cmd_authenticate(client, args);
+	if (strcmp(cmd, "CAPABILITY") == 0)
+		return cmd_capability(client);
+	if (strcmp(cmd, "STARTTLS") == 0)
+		return cmd_starttls(client);
+	if (strcmp(cmd, "LOGOUT") == 0)
+		return cmd_logout(client);
+	if (strcmp(cmd, "NOOP") == 0)
+		return cmd_noop(client);
+
+	return -1;
+}
+
+static bool client_handle_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	int ret;
+	bool fatal;
+
+	i_assert(!client->common.authenticating);
+
+	if (client->cmd_finished) {
+		/* clear the previous command from memory. don't do this
+		   immediately after handling command since we need the
+		   cmd_tag to stay some time after authentication commands. */
+		client->cmd_name = NULL;
+		managesieve_parser_reset(client->parser);
+
+		/* remove \r\n */
+		if (client->skip_line) {
+			if (!client_skip_line(client))
+				return FALSE;
+			client->skip_line = FALSE;
+		}
+
+		client->cmd_finished = FALSE;
+	}
+
+	if (client->cmd_name == NULL) {
+		client->cmd_name = managesieve_parser_read_word(client->parser);
+		if (client->cmd_name == NULL)
+			return FALSE; /* need more data */
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_send_bye(client, msg);
+			client_destroy(client, t_strconcat("Disconnected: ",
+				msg, NULL));
+			return FALSE;
+		}
+
+		client_send_no(client, msg);
+		client->cmd_finished = TRUE;
+		client->skip_line = TRUE;
+		return TRUE;
+	case -2:
+		/* not enough data */
+		return FALSE;
+	}
+	/* we read the entire line - skip over the CRLF */
+	if (!client_skip_line(client))
+		i_unreached();
+
+	ret = client_command_execute(client, client->cmd_name, args);
+
+	client->cmd_finished = TRUE;
+	if (ret < 0) {
+		if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+			client_send_bye(client,	
+				"Too many invalid MANAGESIEVE commands.");
+			client_destroy(client, "Disconnected: "
+				"Too many invalid commands.");
+			return FALSE;
+		}  
+		client_send_no(client,
+			"Error in MANAGESIEVE command received by server.");
+	}
+
+	return ret != 0;
+}
+
+bool client_read(struct managesieve_client *client)
+{
+	switch (i_stream_read(client->common.input)) {
+	case -2:
+		/* buffer full */
+		client_send_bye(client, "Input buffer full, aborting");
+		client_destroy(client, "Disconnected: Input buffer full");
+		return FALSE;
+	case -1:
+		/* disconnected */
+		client_destroy(client, "Disconnected");
+		return FALSE;
+	case 0:
+		/* nothing new read */
+		return TRUE;
+	default:
+		/* something was read */
+		timeout_reset(client->to_idle_disconnect);
+		return TRUE;
+	}
+}
+
+void client_input(struct managesieve_client *client)
+{
+	if (!client_read(client))
+		return;
+
+	client_ref(client);
+
+	if (!auth_client_is_connected(auth_client)) {
+		/* we're not yet connected to auth process -
+		   don't allow any commands */
+		/* FIXME: Can't do this with managesieve. Any other ways?
+		client_send_ok(client, AUTH_WAITING_MSG);
+		*/
+		if (client->to_auth_waiting != NULL)
+			timeout_remove(&client->to_auth_waiting);
+		
+		client->input_blocked = TRUE;
+	} else {
+		o_stream_cork(client->output);
+		while (client_handle_input(client)) ;
+		o_stream_uncork(client->output);
+	}
+
+	client_unref(client);
+}
+
+void client_destroy_oldest(void)
+{
+	struct client *client;
+	struct managesieve_client *destroy_buf[CLIENT_DESTROY_OLDEST_COUNT];
+	unsigned int i, destroy_count;
+
+	/* find the oldest clients and put them to destroy-buffer */
+	memset(destroy_buf, 0, sizeof(destroy_buf));
+
+ 	destroy_count = max_connections > CLIENT_DESTROY_OLDEST_COUNT*2 ?
+		CLIENT_DESTROY_OLDEST_COUNT : I_MIN(max_connections/2, 1);
+	for (client = clients; client != NULL; client = client->next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *) client;
+
+		for (i = 0; i < destroy_count; i++) {
+			if (destroy_buf[i] == NULL ||
+				destroy_buf[i]->created > msieve_client->created) {
+				/* @UNSAFE */
+				memmove(destroy_buf+i+1, destroy_buf+i,
+					sizeof(destroy_buf) -
+					(i+1) * sizeof(struct managesieve_client *));
+				destroy_buf[i] = msieve_client;
+				break;
+			}
+		}
+	}
+
+	/* then kill them */
+	for (i = 0; i < destroy_count; i++) {
+		if (destroy_buf[i] == NULL)
+			break;
+
+		client_destroy(destroy_buf[i], "Disconnected: Connection queue full");
+	}
+}
+
+static void client_send_greeting(struct managesieve_client *client)
+{
+	/* Cork the stream to send the capability data as a single tcp frame
+	 *   Some naive clients break if we don't.
+	 */
+	o_stream_cork(client->output);
+
+	/* Send initial capabilities */   
+	client_send_capabilities(client);
+	client_send_ok(client, greeting);
+	client->greeting_sent = TRUE;
+
+	o_stream_uncork(client->output);
+}
+
+static void client_idle_disconnect_timeout(struct managesieve_client *client)
+{
+	client_send_bye(client, "Disconnected for inactivity.");
+	client_destroy(client, "Disconnected: Inactivity");
+}
+
+static void client_auth_waiting_timeout(struct managesieve_client *client)
+{
+	timeout_remove(&client->to_auth_waiting);
+}
+
+void client_set_auth_waiting(struct managesieve_client *client)
+{
+	i_assert(client->to_auth_waiting == NULL);
+	client->to_auth_waiting =
+		timeout_add(AUTH_WAITING_TIMEOUT_MSECS,
+			client_auth_waiting_timeout, client);
+}
+
+struct client *client_create(int fd, bool ssl, const struct ip_addr *local_ip,
+			     const struct ip_addr *ip)
+{
+	struct managesieve_client *client;
+
+	i_assert(fd != -1);
+
+	connection_queue_add(1);
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd, TRUE);
+
+	client = i_new(struct managesieve_client, 1);
+	client->created = ioloop_time;
+	client->refcount = 1;
+
+	client->common.local_ip = *local_ip;
+	client->common.ip = *ip;
+	client->common.fd = fd;
+	client->common.tls = ssl;
+	client->common.trusted = client_is_trusted(&client->common);
+	client->common.secured = ssl || client->common.trusted ||
+		net_ip_compare(ip, local_ip);
+
+	client_open_streams(client, fd);
+	client->io = io_add(fd, IO_READ, client_input, client);
+
+	client_link(&client->common);
+
+	main_ref();
+
+	if (auth_client_is_connected(auth_client))
+		client_send_greeting(client);
+	else
+		client_set_auth_waiting(client);
+	client_set_title(client);
+
+	client->to_idle_disconnect =
+		timeout_add(CLIENT_LOGIN_IDLE_TIMEOUT_MSECS,
+			client_idle_disconnect_timeout, client);
+	return &client->common;
+}
+
+void client_destroy(struct managesieve_client *client, const char *reason)
+{
+	if (client->destroyed)
+		return;
+	client->destroyed = TRUE;
+
+	if (!client->login_success && reason != NULL) {
+		reason = t_strconcat(reason, " ",
+			client_get_extra_disconnect_reason(&client->common),
+			NULL);
+	}
+	if (reason != NULL)
+		client_syslog(&client->common, reason);
+
+	client_unlink(&client->common);
+
+	if (client->common.input != NULL)
+		i_stream_close(client->common.input);
+	if (client->output != NULL)
+		o_stream_close(client->output);
+
+	if (client->common.master_tag != 0) {
+		i_assert(client->common.auth_request == NULL);
+		i_assert(client->common.authenticating);
+		master_request_abort(&client->common);
+	} else if (client->common.auth_request != NULL) {
+		i_assert(client->common.authenticating);
+		sasl_server_auth_client_error(&client->common, NULL);
+	} else {
+		i_assert(!client->common.authenticating);
+	}
+
+	if (client->io != NULL)
+		io_remove(&client->io);
+	if (client->to_idle_disconnect != NULL)
+		timeout_remove(&client->to_idle_disconnect);
+	if (client->to_auth_waiting != NULL)
+		timeout_remove(&client->to_auth_waiting);
+	if (client->to_authfail_delay != NULL)
+		timeout_remove(&client->to_authfail_delay);
+
+	if (client->common.fd != -1) {
+		net_disconnect(client->common.fd);
+		client->common.fd = -1;
+	}
+
+	if (client->proxy_password != NULL) {
+		safe_memset(client->proxy_password, 0, strlen(client->proxy_password));
+		i_free(client->proxy_password);
+		client->proxy_password = NULL;
+	}
+
+	i_free_and_null(client->proxy_user);
+	i_free_and_null(client->proxy_master_user);
+
+	if (client->proxy != NULL)
+		login_proxy_free(&client->proxy);
+
+	if (client->common.proxy != NULL) {
+		ssl_proxy_free(client->common.proxy);
+		client->common.proxy = NULL;
+	}
+
+	client_unref(client);
+
+	main_listen_start();
+	main_unref();
+}
+
+void client_destroy_success(struct managesieve_client *client, const char *reason)
+{   
+    client->login_success = TRUE;
+    client_destroy(client, reason);
+}
+
+bool client_read_args(struct managesieve_client *client, unsigned int count,
+	unsigned int flags, struct managesieve_arg **args)
+{
+	int ret;
+	bool fatal;
+	const char *msg;
+
+	i_assert(count <= INT_MAX);
+
+	ret = managesieve_parser_read_args(client->parser, count, flags, args);
+	if (ret >= (int)count) {
+		/* all parameters read successfully */
+		return TRUE;
+	} else if (ret == -2) {
+		/* need more data */
+		return FALSE;
+	} else {
+		/* error, or missing arguments */
+		if ( ret < 0 ) {
+			msg = managesieve_parser_get_error(client->parser, &fatal);
+			client_send_no(client, msg);
+		} else {
+			client_send_no(client, "Missing arguments");
+		}
+		return FALSE;
+	}
+}
+
+void client_destroy_internal_failure(struct managesieve_client *client)
+{
+	client_send_byeresp(client, "TRYLATER", "Internal login failure. "
+		"Refer to server log for more information.");
+	client_destroy(client, "Internal login failure");
+}
+
+void client_ref(struct managesieve_client *client)
+{
+	client->refcount++;
+}
+
+bool client_unref(struct managesieve_client *client)
+{
+	i_assert(client->refcount > 0);
+	if (--client->refcount > 0)
+		return TRUE;
+
+	i_assert(client->destroyed);
+
+	managesieve_parser_destroy(&client->parser);
+
+	if (client->common.input != NULL)
+		i_stream_unref(&client->common.input);
+	if (client->output != NULL)
+		o_stream_unref(&client->output);
+
+	i_free(client->common.virtual_user);
+	i_free(client->common.auth_mech_name);
+	i_free(client);
+
+	return FALSE;
+}
+
+void client_send_line(struct managesieve_client *client, const char *line)
+{
+	struct const_iovec iov[2];
+	ssize_t ret;
+
+	iov[0].iov_base = line;
+	iov[0].iov_len = strlen(line);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	ret = o_stream_sendv(client->output, iov, 2);
+	if (ret < 0 || (size_t)ret != iov[0].iov_len + iov[1].iov_len) {
+		/* either disconnection or buffer full. in either case we
+		   want this connection destroyed. however destroying it here
+		   might break things if client is still tried to be accessed
+		   without being referenced.. */
+		i_stream_close(client->common.input);
+	}
+}
+
+void _client_send_response(struct managesieve_client *client, 
+	const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL )
+	{
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL )	
+	{
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void clients_notify_auth_connected(void)
+{
+	struct client *client;
+
+	for (client = clients; client != NULL; client = client->next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *)client;
+
+		if (msieve_client->to_auth_waiting != NULL)
+			timeout_remove(&msieve_client->to_auth_waiting);
+		if (!msieve_client->greeting_sent)
+			client_send_greeting(msieve_client);
+		if (msieve_client->input_blocked) {
+			msieve_client->input_blocked = FALSE;
+			client_input(msieve_client);
+		}
+	}
+}
+
+void clients_destroy_all(void)
+{
+	struct client *client, *next;
+
+	for (client = clients; client != NULL; client = next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *) client;
+
+		next = client->next;
+		client_destroy(msieve_client, "Disconnected: Shutting down");
+	}
+}
+
+void clients_init(void)
+{
+	const char *str;
+
+	/* Specific MANAGESIEVE settings */
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+    	str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	/* Parse CAPABILITY_STRING */	
+	managesieve_capabilities_init(capability_string);
+}
+
+void clients_deinit(void)
+{
+	clients_destroy_all();
+
+	/* Free allocated capability strings */
+	managesieve_capabilities_deinit();
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/client.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/client.h	2009-05-03 13:58:06.000000000 +0000
@@ -0,0 +1,92 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "network.h"
+#include "master.h"
+
+#include "client-common.h"
+
+#include "managesieve-parser.h"
+
+#include "dmanagesieve-config.h"
+
+/* maximum length for IMAP command line. */
+#define MAX_MANAGESIEVE_LINE 8192
+
+/* Disconnect client after idling this many milliseconds */
+#define CLIENT_LOGIN_IDLE_TIMEOUT_MSECS (3*60*1000)
+
+/* FIXME: Duplicate, also defined in src/managesieve */
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING MANAGESIEVE_NAME
+
+struct managesieve_client {
+	struct client common;
+
+	time_t created;
+	int refcount;
+
+	struct io *io;
+	struct ostream *output;
+	struct managesieve_parser *parser;
+	struct timeout *to_idle_disconnect, *to_auth_waiting;
+	struct timeout *to_authfail_delay;
+
+	struct login_proxy *proxy;
+	char *proxy_user, *proxy_master_user, *proxy_password;
+
+	unsigned int proxy_state;
+
+	unsigned int bad_counter;
+
+	const char *cmd_name;
+
+	unsigned int login_success:1;
+	unsigned int cmd_finished:1;
+	unsigned int proxy_starttls:1;
+	unsigned int skip_line:1;
+	unsigned int input_blocked:1;
+	unsigned int destroyed:1;
+	unsigned int greeting_sent:1;
+	unsigned int id_logged:1;
+	unsigned int auth_initializing:1;
+	unsigned int capability_command_used:1;
+};
+
+void client_destroy(struct managesieve_client *client, const char *reason);
+void client_destroy_success(struct managesieve_client *client, const char *reason);
+void client_destroy_internal_failure(struct managesieve_client *client);
+
+void client_send_line(struct managesieve_client *client, const char *line);
+
+bool client_read(struct managesieve_client *client);
+bool client_skip_line(struct managesieve_client *client);
+void client_input(struct managesieve_client *client);
+
+bool client_read_args(struct managesieve_client *client, unsigned int count,
+	unsigned int flags, struct managesieve_arg **args);
+
+void client_ref(struct managesieve_client *client);
+bool client_unref(struct managesieve_client *client);
+
+void client_set_auth_waiting(struct managesieve_client *client);
+
+void _client_send_response(struct managesieve_client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+	_client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  _client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  _client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  _client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  _client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(client, resp_code, msg) \
+  _client_send_response(client, "BYE", resp_code, msg)
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/cmd-noop.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/cmd-noop.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/cmd-noop.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/cmd-noop.c	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,48 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: Duplicate! */
+
+#include "common.h"
+#include "str.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+#include "client.h"
+#include "commands.h"
+
+int cmd_noop(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *text;
+	string_t *resp_code;
+	int ret;
+
+	/* [<echo string>] */
+	if (!(ret=client_read_args(client, 0, 0, &args)))
+		return FALSE;
+
+	if ( ret > 1 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( args[0].type == MANAGESIEVE_ARG_EOL ) {
+		client_send_ok(client, "NOOP Completed");
+		return TRUE;
+	}
+
+	if ( (text = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid echo tag.");
+		return TRUE;
+	}
+
+	resp_code = t_str_new(256);
+	str_append(resp_code, "TAG ");
+	managesieve_quote_append_string(resp_code, text, FALSE);
+
+	client_send_okresp(client, str_c(resp_code), "Done");
+	return TRUE;
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/commands.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/commands.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/commands.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/commands.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,11 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __COMMANDS_H
+#define __COMMANDS_H
+
+struct managesieve_client;
+
+extern int cmd_noop(struct managesieve_client *client);
+
+#endif /* __COMMANDS_H */
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/Makefile.am dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/Makefile.am
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/Makefile.am	2008-12-27 11:32:39.000000000 +0000
@@ -0,0 +1,46 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve-login
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/login-common \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_login_LDADD = \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a \
+	$(SSL_LIBS)
+
+commands = \
+	cmd-noop.c
+
+managesieve_login_SOURCES = \
+	client.c \
+	client-authenticate.c \
+	managesieve-capability.c \
+	managesieve-proxy.c \
+	$(commands)
+
+noinst_HEADERS = \
+	commands.h \
+	client.h \
+	client-authenticate.h \
+	managesieve-capability.h \
+	managesieve-proxy.h
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-capability.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-capability.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-capability.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-capability.c	2009-01-27 13:21:24.000000000 +0000
@@ -0,0 +1,89 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "managesieve-capability.h"
+
+char *managesieve_capability_sieve = NULL;
+char *managesieve_capability_notify = NULL;
+
+typedef	enum { CAP_SIEVE, CAP_NOTIFY } capability_type_t;
+
+static void _capability_assign(capability_type_t cap_type, const char *value)
+{
+	const char *duplicate = NULL;
+	
+	switch ( cap_type ) {
+	case CAP_SIEVE:
+		if ( managesieve_capability_sieve == NULL )
+			managesieve_capability_sieve = i_strdup(value);
+		else
+			duplicate = "SIEVE";
+		break;
+	case CAP_NOTIFY:
+		if ( managesieve_capability_notify == NULL )
+			managesieve_capability_notify = i_strdup(value);
+		else
+			duplicate = "NOTIFY";
+		break;
+	}
+	
+	if ( duplicate != NULL ) 
+		i_warning("managesieve-login: duplicate capability '%s' listed in "
+			"capability string (ignored).", duplicate);
+}
+
+void managesieve_capabilities_init(const char *cap_string)
+{
+	capability_type_t cap_type = CAP_SIEVE;
+	const char *p = cap_string;
+	string_t *part = t_str_new(256);
+
+	if ( cap_string == NULL || *cap_string == '\0' ) {
+		i_warning("managesieve-login: capability string is empty.");
+		return;
+	}
+	
+	while ( *p != '\0' ) {
+		if ( *p == '\\' ) {
+			p++;
+			if ( *p != '\0' ) {
+				str_append_c(part, *p);
+				p++;
+			} else break;
+		} else if ( *p == ':' ) {
+			if ( strcasecmp(str_c(part), "SIEVE") == 0 )
+				cap_type = CAP_SIEVE;
+			else if ( strcasecmp(str_c(part), "NOTIFY") == 0 )
+				cap_type = CAP_NOTIFY;
+			else
+				i_warning("managesieve-login: unknown capability '%s' listed in "
+					"capability string (ignored).", str_c(part));
+			str_truncate(part, 0); 
+		} else if ( *p == ',' ) {
+			_capability_assign(cap_type, str_c(part));
+			str_truncate(part, 0);
+		} else {
+			/* Append character, but omit leading spaces */
+			if ( str_len(part) > 0 || *p != ' ' )
+				str_append_c(part, *p);
+		}
+		p++;
+	}
+	
+	if ( str_len(part) > 0 ) {
+		_capability_assign(cap_type, str_c(part));
+	}
+}
+
+void managesieve_capabilities_deinit(void)
+{
+	if ( managesieve_capability_sieve != NULL ) 
+		i_free(managesieve_capability_sieve);
+	
+	if ( managesieve_capability_notify != NULL )
+		i_free(managesieve_capability_notify);	
+}
+
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-capability.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-capability.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-capability.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-capability.h	2009-01-15 23:34:41.000000000 +0000
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MANAGESIEVE_CAPABILITY_H
+#define __MANAGESIEVE_CAPABILITY_H
+
+extern char *managesieve_capability_sieve;
+extern char *managesieve_capability_notify;
+
+void managesieve_capabilities_init(const char *capabilities);
+void managesieve_capabilities_deinit(void);
+
+#endif /* __MANAGESIEVE_CAPABILITY_H */
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c	2009-05-03 17:29:50.000000000 +0000
@@ -0,0 +1,475 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <string.h>
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "safe-memset.h"
+#include "buffer.h"
+#include "base64.h"
+
+#include "client.h"
+#include "client-authenticate.h"
+
+#include "managesieve-quote.h"
+#include "managesieve-proxy.h"
+#include "managesieve-parser.h"
+
+enum {
+	PROXY_STATE_INITIAL,
+	PROXY_STATE_STARTTLS,
+	PROXY_STATE_AUTHENTICATE,
+};
+
+typedef enum {
+	MANAGESIEVE_RESPONSE_NONE,
+	MANAGESIEVE_RESPONSE_OK,
+	MANAGESIEVE_RESPONSE_NO,
+	MANAGESIEVE_RESPONSE_BYE
+} managesieve_response_t;
+
+static void proxy_free_password(struct managesieve_client *client)
+{   
+	if (client->proxy_password == NULL)
+		return;
+
+	safe_memset(client->proxy_password, 0, strlen(client->proxy_password));
+	i_free_and_null(client->proxy_password);
+}
+
+static void proxy_failed(struct managesieve_client *client, bool send_tagline)
+{   
+	if (send_tagline)
+		client_send_noresp(client, "TRYLATER", AUTH_TEMP_FAILED_MSG);
+
+	login_proxy_free(&client->proxy);
+	proxy_free_password(client);
+	i_free_and_null(client->proxy_user);
+	i_free_and_null(client->proxy_master_user);
+
+	/* call this last - it may destroy the client */
+	client_auth_failed(client, TRUE);
+}
+
+static void get_plain_auth(struct managesieve_client *client, string_t *dest)
+{   
+	string_t *str, *base64;
+
+	str = t_str_new(128);
+	if ( client->proxy_master_user == NULL ) {
+		str_append_c(str, '\0');
+		str_append(str, client->proxy_user);
+	} else {
+		str_append(str, client->proxy_user);
+		str_append_c(str, '\0');
+		str_append(str, client->proxy_master_user);
+	}
+	str_append_c(str, '\0');
+	str_append(str, client->proxy_password);
+
+	base64 = t_str_new(128);
+	base64_encode(str_data(str), str_len(str), base64);
+
+	managesieve_quote_append_string(dest, str_c(base64), FALSE);
+}
+
+static void proxy_write_login(struct managesieve_client *client, string_t *str)
+{   
+	/*   Send command */
+	str_append(str, "AUTHENTICATE \"PLAIN\" ");
+	get_plain_auth(client, str);
+	proxy_free_password(client);
+	str_append(str, "\r\n");
+}
+
+static managesieve_response_t proxy_read_response
+(struct managesieve_arg *args)
+{
+	if ( args[0].type == MANAGESIEVE_ARG_ATOM ) {
+		const char *response = MANAGESIEVE_ARG_STR(&(args[0]));
+
+		if ( strcasecmp(response, "OK") == 0 ) {
+			/* Received OK response; greeting is finished */
+			return MANAGESIEVE_RESPONSE_OK; 
+
+        } else if ( strcasecmp(response, "NO") == 0 ) {
+			/* Received OK response; greeting is finished */
+			return MANAGESIEVE_RESPONSE_NO; 
+
+        } else if ( strcasecmp(response, "BYE") == 0 ) {
+			/* Received OK response; greeting is finished */
+			return MANAGESIEVE_RESPONSE_BYE;
+ 
+		}
+	}
+
+	return MANAGESIEVE_RESPONSE_NONE;
+}
+
+static int proxy_input_capability
+(struct managesieve_client *client, const char *line, managesieve_response_t *resp_r)
+{   
+	struct istream *input;
+	struct managesieve_parser *parser;
+ 	struct managesieve_arg *args;
+	int ret;
+	bool fatal = FALSE;
+
+	*resp_r = MANAGESIEVE_RESPONSE_NONE;
+
+	/* Build an input stream for the managesieve parser 
+	 *  FIXME: It would be nice if the line-wise parsing could be
+	 *    substituded by something similar to the command line interpreter.
+	 *    However, the current login_proxy structure does not make streams
+	 *    known until inside proxy_input handler.
+	 */
+	line = t_strconcat(line, "\r\n", NULL);
+	input = i_stream_create_from_data(line, strlen(line));
+	parser = managesieve_parser_create(input, NULL, MAX_MANAGESIEVE_LINE);
+	managesieve_parser_reset(parser);
+
+	/* Parse input 
+	 *  FIXME: Theoretically the OK response could include a 
+	 *   response code which could be rejected by the parser. 
+	 */ 
+	(void)i_stream_read(input);
+	ret = managesieve_parser_read_args(parser, 2, 0, &args);
+		
+	if ( ret >= 1 ) {
+		if ( args[0].type == MANAGESIEVE_ARG_ATOM ) {
+			*resp_r = proxy_read_response(args);
+
+			if ( *resp_r == MANAGESIEVE_RESPONSE_NONE ) {
+				client_syslog_err(&client->common, t_strdup_printf("proxy: "
+					"Remote sent invalid response: %s",
+					str_sanitize(line,160)));
+		
+				fatal = TRUE;
+			}
+      	} else if ( args[0].type == MANAGESIEVE_ARG_STRING ) {
+			const char *capability = MANAGESIEVE_ARG_STR(&(args[0]));
+
+        	if ( strcasecmp(capability, "SASL") == 0 ) {
+				/* Check whether the server supports the SASL mechanism 
+		    	 * we are going to use (currently only PLAIN supported). 
+				 */
+				if ( ret == 2 && args[1].type == MANAGESIEVE_ARG_STRING ) {
+					const char *const *mechs = 
+						t_strsplit(MANAGESIEVE_ARG_STR(&(args[1])), " "); 
+
+					if ( !str_array_icase_find(mechs, "PLAIN") ) {
+						client_syslog_err(&client->common, "proxy: "
+		         			"Server does not support required PLAIN SASL mechanism");
+						fatal = TRUE;
+					} 	
+
+				} else {
+					client_syslog_err(&client->common, "proxy: "
+		         		"Server returned erroneous SASL capability");
+					fatal = TRUE;
+				}
+
+			} else if ( strcasecmp(capability, "STARTTLS") == 0 ) {
+				client->proxy_starttls = TRUE;
+			}
+
+		} else {
+			/* Do not accept faulty server */
+			client_syslog_err(&client->common, t_strdup_printf("proxy: "
+				"Remote returned with invalid capability/greeting line: %s",
+				str_sanitize(line,160)));
+			fatal = TRUE;
+		}
+
+	} else if ( ret == -2 ) {
+		/* Parser needs more data (not possible on mem stream) */
+		i_unreached();
+
+    } else if ( ret < 0 ) {
+		const char *error_str = managesieve_parser_get_error(parser, &fatal);
+		error_str = (error_str != NULL ? error_str : "unknown (bug)" );
+	
+		/* Do not accept faulty server */
+		client_syslog_err(&client->common, t_strdup_printf("proxy: "
+			"Protocol parse error(%d) in capability/greeting line: %s (line='%s')",
+			ret, error_str, line));
+		fatal = TRUE;
+	}
+
+	/* Cleanup parser */
+    managesieve_parser_destroy(&parser);
+	i_stream_destroy(&input);
+
+	/* Time to exit if greeting was not accepted */
+	if ( fatal ) return -1;
+
+	/* Wait until greeting is received completely */
+	if ( *resp_r == MANAGESIEVE_RESPONSE_NONE ) return 1;
+
+	return 0;
+}
+
+static int proxy_input_line
+(struct managesieve_client *client, const char *line)
+{
+	struct ostream *output; 
+    enum login_proxy_ssl_flags ssl_flags;
+	managesieve_response_t response = MANAGESIEVE_RESPONSE_NONE;
+	string_t *command;
+	int ret = 0;
+
+	i_assert(!client->destroyed);
+
+    output = login_proxy_get_ostream(client->proxy);
+	switch ( client->proxy_state ) {
+	case PROXY_STATE_INITIAL:
+		if ( (ret=proxy_input_capability(client, line, &response)) < 0 ) {
+			proxy_failed(client, TRUE);
+			return -1;
+		}
+
+		if ( ret == 0 ) {
+			if ( response != MANAGESIEVE_RESPONSE_OK ) {
+				client_syslog_err(&client->common,
+					"proxy: Remote sent unexpected NO/BYE in stead of capability response");
+				proxy_failed(client, TRUE);
+				return -1;		
+			}
+
+			command = t_str_new(128);
+
+    		ssl_flags = login_proxy_get_ssl_flags(client->proxy);
+    		if ((ssl_flags & PROXY_SSL_FLAG_STARTTLS) != 0) {
+        		if ( !client->proxy_starttls ) {
+            		client_syslog_err(&client->common,
+                		"proxy: Remote doesn't support STARTTLS");
+					return -1;
+        		}
+        	
+				str_append(command, "STARTTLS\r\n");
+				client->proxy_state = PROXY_STATE_STARTTLS;
+    		} else {
+				proxy_write_login(client, command);
+				client->proxy_state = PROXY_STATE_AUTHENTICATE;
+			}
+
+			(void)o_stream_send(output, str_data(command), str_len(command));
+		}
+
+		return 0;
+
+	case PROXY_STATE_STARTTLS:
+		if ( (ret=proxy_input_capability(client, line, &response)) < 0 ) {
+            proxy_failed(client, TRUE);
+            return -1;
+        }
+
+        if ( ret == 0 ) {
+			if ( response != MANAGESIEVE_RESPONSE_OK ) {
+				/* STARTTLS failed */
+				client_syslog_err(&client->common, t_strdup_printf(
+					"proxy: Remote STARTTLS failed: %s",
+					str_sanitize(line, 160)));
+					proxy_failed(client, TRUE);
+				return -1;
+			}
+
+			/* STARTTLS successful, begin TLS negotiation. */
+			if (login_proxy_starttls(client->proxy) < 0) {
+				proxy_failed(client, TRUE);
+				return -1;
+			}
+	
+			/* Streams changed. */
+			output = login_proxy_get_ostream(client->proxy);
+			command = t_str_new(128);
+			proxy_write_login(client, command);
+			(void)o_stream_send(output, str_data(command), str_len(command));
+		
+			client->proxy_state = PROXY_STATE_AUTHENTICATE;
+		}
+
+		return 1;
+	
+	case PROXY_STATE_AUTHENTICATE:
+
+		/* Check login status */
+		if ( strncasecmp(line, "OK", 2) == 0 && ( strlen(line) == 2 || line[2] == ' ' ) ) {
+			string_t *str = t_str_new(128);
+
+			/* Login successful */
+
+			/* FIXME: some SASL mechanisms cause a capability response to be sent */
+
+			/* Send this line to client. */
+			o_stream_cork(client->output);
+			(void)o_stream_send_str(client->output, line);
+			(void)o_stream_send(client->output, "\r\n", 2);
+			o_stream_uncork(client->output);
+
+			str_printfa(str, "proxy(%s): started proxying to %s:%u",
+				client->common.virtual_user,
+				login_proxy_get_host(client->proxy),
+				login_proxy_get_port(client->proxy));
+			if ( strcmp(client->common.virtual_user, client->proxy_user) != 0 ) {
+				/* remote username is different, log it */
+				str_append_c(str, '/');
+				str_append(str, client->proxy_user);
+        	}
+			if (client->proxy_master_user != NULL) {
+				str_printfa(str, " (master %s)", client->proxy_master_user);
+			}
+
+			(void)client_skip_line(client);
+			login_proxy_detach(client->proxy, client->common.input,
+				client->output);
+
+			client->proxy = NULL;
+			client->common.input = NULL;
+			client->output = NULL;
+			client->common.fd = -1;
+			client_destroy_success(client, str_c(str));
+			
+			return 1;
+		} 
+		
+		/* Login failed */
+
+		if (verbose_auth) {
+			string_t *str = t_str_new(128);
+				
+			str_printfa(str, "proxy(%s): Login failed to %s:%u",
+				client->common.virtual_user,
+ 				login_proxy_get_host(client->proxy),
+				login_proxy_get_port(client->proxy));
+			if (strcmp(client->common.virtual_user, client->proxy_user) != 0) {
+				/* remote username is different, log it */
+				str_append_c(str, '/');
+				str_append(str, client->proxy_user);
+			}
+			if (client->proxy_master_user != NULL) {
+				str_printfa(str, " (master %s)", client->proxy_master_user);
+			}
+			str_append(str, ": ");
+
+			if (strncasecmp(line, "NO ", 3) == 0)
+				str_append(str, line + 3);
+			else
+				str_append(str, line);
+	    
+			i_info("%s", str_c(str));
+		}
+
+		/* Login failed. Send our own failure reply so client can't
+		 * figure out if user exists or not just by looking at the
+		 * reply string.
+		 */
+		client_send_no(client, AUTH_FAILED_MSG);
+
+		proxy_failed(client, FALSE);
+		return -1;
+
+	default:
+		/* Not supposed to happen */
+		break;
+	}
+
+	i_unreached();
+	return -1;
+}
+
+
+static void proxy_input(struct managesieve_client *client)
+{   
+	struct istream *input;
+	const char *line;
+
+	if (client->proxy == NULL) {
+		/* we're just freeing the proxy */
+		return;
+	}
+
+	input = login_proxy_get_istream(client->proxy);
+	if (input == NULL) {
+		if (client->destroyed) {
+			/* we came here from client_destroy() */
+			return;
+ 		}
+
+		/* failed for some reason, probably server disconnected */
+		proxy_failed(client, TRUE);
+		return;
+	}
+
+	i_assert(!client->destroyed);
+
+	switch (i_stream_read(input)) {
+	case -2:
+		client_syslog_err(&client->common, 
+			"proxy: Remote input buffer full");
+ 		proxy_failed(client, TRUE);
+		return;
+	case -1:
+		client_syslog_err(&client->common,
+			"proxy: Remote disconnected");
+		proxy_failed(client, TRUE);
+		return;
+	}
+
+	while ((line = i_stream_next_line(input)) != NULL) {
+		if (proxy_input_line(client, line) != 0)
+			break;
+	}
+}
+
+int managesieve_proxy_new(struct managesieve_client *client, const char *host,
+           unsigned int port, const char *user, const char *master_user,
+           const char *password, enum login_proxy_ssl_flags ssl_flags)
+{
+	i_assert(user != NULL);
+	i_assert(!client->destroyed);
+
+	if (password == NULL) {
+		client_syslog(&client->common, "proxy: password not given");
+		client_send_noresp(client, "TRYLATER", AUTH_TEMP_FAILED_MSG);
+		return -1;
+	}
+
+	i_assert(client->refcount > 1);
+	connection_queue_add(1);
+
+	if (client->destroyed) {
+		/* connection_queue_add() decided that we were the oldest
+		   connection and killed us. */
+		return -1;
+	}
+
+	if ( login_proxy_is_ourself(&client->common, host, port, user )) {
+        client_syslog_err(&client->common, "Proxying loops to itself");
+		client_send_noresp(client, "TRYLATER", AUTH_TEMP_FAILED_MSG);
+        return -1;
+    }
+
+	client->proxy = login_proxy_new(&client->common, host, port, ssl_flags,
+                    proxy_input, client);
+    if (client->proxy == NULL) {
+		client_send_noresp(client, "TRYLATER", AUTH_TEMP_FAILED_MSG);
+        return -1;
+    }
+
+	client->proxy_starttls = FALSE;
+	client->proxy_state = PROXY_STATE_INITIAL;
+	client->proxy_user = i_strdup(user);
+	client->proxy_master_user = i_strdup(master_user);
+	client->proxy_password = i_strdup(password);
+
+	/* disable input until authentication is finished */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	return 0;
+}
diff -urN dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h
--- dovecot-1.2.0/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h	2009-05-03 13:58:06.000000000 +0000
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MANAGESIEVE_PROXY_H
+#define __MANAGESIEVE_PROXY_H
+
+#include "login-proxy.h"
+
+int managesieve_proxy_new(struct managesieve_client *client, const char *hosts,
+           unsigned int port, const char *user, const char *master_user,
+           const char *password, enum login_proxy_ssl_flags ssl_flags);
+
+#endif
diff -urN dovecot-1.2.0/dovecot-managesieve/stamp.h.in dovecot-1.2.0-debian/dovecot-managesieve/stamp.h.in
--- dovecot-1.2.0/dovecot-managesieve/stamp.h.in	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/stamp.h.in	2009-07-06 03:47:41.000000000 +0000
@@ -0,0 +1,2 @@
+
+
diff -urN dovecot-1.2.0/dovecot-managesieve/TODO dovecot-1.2.0-debian/dovecot-managesieve/TODO
--- dovecot-1.2.0/dovecot-managesieve/TODO	1970-01-01 00:00:00.000000000 +0000
+++ dovecot-1.2.0-debian/dovecot-managesieve/TODO	2009-04-07 20:54:51.000000000 +0000
@@ -0,0 +1,25 @@
+Next (in order of descending priority/precedence):
+
+* Fix proxy to recognize response codes from the backend and forward
+  them to the user if appropriate/safe.
+* Implement new capabilities
+	- MAXREDIRECTS capability
+* Implement new script name rules
+* Implement the HAVESPACE command properly. Currently it always says ok.
+  Maybe this should be linked to the mail quota system. 
+* Enforce protocol syntax better with some of the commands. Some 
+  commands still allow spurious extra arguments
+  --> Full protocol syntax conformance review. 
+* Implement proper support for anonymous login.
+* Make the sieve storage a base class with (possibly) various
+  implementations, just like mail-storage. Currently not very useful. 
+
+* Thorough testing...
+  - Test pipelined behavior
+  - Test proxy authentication
+
+* Resolve exessive code duplication
+	- Between imap and managesieve (Timo?)
+	- Between managesieve and managesieve-login
+* Create proper process interface to dovecot for generic non-mail protocols 
+  (Timo).
