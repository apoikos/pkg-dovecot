#! /bin/sh -e
## DP: Adds support for MANAGESIEVE
## DP: Author: Stephan Bosch <stephan@rename-it.nl>
## DP: Version: 0.11.6

# Copyright (c) 2006-2009 by Stephan Bosch <stephan@rename-it.nl>
# This patch is licenced under LGPLv2.1

. $(dirname $0)/DPATCH

exit 0
@DPATCH@
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/AUTHORS dovecot-1.2.4/dovecot-managesieve/AUTHORS
--- dovecot-1.2.4.orig/dovecot-managesieve/AUTHORS	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/AUTHORS	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,15 @@
+Stephan Bosch <stephan@rename-it.nl>
+
+This package is partly based on and built for the Dovecot Secure 
+IMAP server written by:
+
+Timo Sirainen <tss@iki.fi>. 
+
+The ManageSieve service is a modified version of Dovecot's IMAP 
+service implementation.
+
+Although a new Sieve implementation written by the authors listed
+above exists, this ManageSieve implementation can still be compiled
+against the old CMU Sieve implementation located in the 
+dovecot-sieve-1.1 package. The AUTHORS file there references the CMU
+authors.
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/ChangeLog dovecot-1.2.4/dovecot-managesieve/ChangeLog
--- dovecot-1.2.4.orig/dovecot-managesieve/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/ChangeLog	2009-08-21 01:06:19.000000000 +0200
@@ -0,0 +1,1078 @@
+2009-08-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[cb3be526da8c] [tip]
+
+2009-08-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c:
+	Reintroduced ability to abort SASL with "*" response.
+	[2207e38b7005]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-login
+	/managesieve-proxy.c, src/managesieve-login/managesieve-proxy.h:
+	Incorporated changes in imap-proxy into managesieve-proxy.
+	[85ef7feebcc4]
+
+2009-08-08  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.8 for changeset 15751cd8609b
+	[21b9e53ff2a8]
+
+	* NEWS, configure.in:
+	Released v0.11.8 for Dovecot v1.2.3.
+	[15751cd8609b] [0.11.8]
+
+2009-08-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Sieve-storage: moved debug messages after /home/stephan substitution
+	to make sure the presented paths are useful.
+	[82a8ddf787dd]
+
+2009-08-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client.h, src/managesieve-login/managesieve-
+	proxy.c:
+	Fixed TLS support for ManageSieve proxy for the case that the remote
+	has disable_plaintext_auth enabled.
+	[9ebfcb75c192]
+
+2009-08-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[c39bb29dbe69]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed TLS support for ManageSieve proxy.
+	[d4f3a7be8df6]
+
+2009-07-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* autogen.sh, configure.in:
+	Use foreign automake option so it doesn't complain about missing
+	ChangeLog.
+	[1ff0c5496af4]
+
+2009-07-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Fixed small problems in the README file.
+	[12b9733ee8b0]
+
+	* README:
+	Updated README.
+	[754280926847]
+
+	* .hgtags:
+	Added tag 0.11.7 for changeset eb5ae4346ab8
+	[089ba4356b73]
+
+	* NEWS, configure.in:
+	Released v0.11.7 for Dovecot v1.2.1.
+	[eb5ae4346ab8] [0.11.7]
+
+2009-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[3f5e1aa77014]
+
+	* src/managesieve/main.c:
+	Incorporated various changes in IMAP's main.c into ManageSieve.
+	[289543707aa7]
+
+	* src/managesieve/cmd-putscript.c:
+	Fixed panic occuring when many errors are produced by the Sieve
+	compiler (never use t_str_new for strings that are written at deeper
+	datastack levels).
+	[2c9b4b4ab6a8]
+
+	* src/lib-managesieve/managesieve-quote.c, src/lib-sievestorage/sieve-
+	storage-list.c, src/lib-sievestorage/sieve-storage-save.c, src/lib-
+	sievestorage/sieve-storage-script.c, src/lib-sievestorage/sieve-
+	storage.c, src/managesieve/client.c, src/managesieve/cmd-
+	listscripts.c:
+	Replaced all occurences of t_push() .. t_pop() with T_BEGIN { .. }
+	T_END equivalents.
+	[12124c0e0459]
+
+	* src/lib-sievestorage/sieve-storage-save.c, src/managesieve/cmd-
+	putscript.c:
+	Previous change was wrong regarding unreferencing the script;
+	already done in the save context.
+	[4b50de87ab8f]
+
+	* src/managesieve/cmd-putscript.c:
+	Forgot to clean up script and binary objects upon compile.
+	[96ebd23f9d16]
+
+2009-07-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c:
+	Adapted to login changes in Dovecot v1.2.
+	[9082ea23b76a]
+
+2009-07-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-getscript.c:
+	The GETSCRIPT command did not properly cleanup when truncation bug
+	was detected.
+	[12e9982097b4]
+
+2009-07-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Minor post-release adjustments to NEWS file.
+	[7ac2596c71eb]
+
+	* .hgtags:
+	Added tag 0.11.6 for changeset 260a04d2d121
+	[65a0ca2246c9]
+
+	* configure.in:
+	Released v0.11.6 for Dovecot v1.2.0.
+	[260a04d2d121] [0.11.6]
+
+2009-06-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file for next release.
+	[013e511cc62b]
+
+2009-06-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h,
+	src/managesieve/cmd-putscript.c:
+	Fixed CRLF line breaks in compile errors.
+	[e83c4bc6958a]
+
+	* src/lib-sievestorage/sieve-storage-private.h, src/lib-sievestorage
+	/sieve-storage-save.c, src/lib-sievestorage/sieve-storage.c:
+	Corrected directory/file creation behavior with respect to mode bits
+	and gid.
+	[fa03cc874378]
+
+2009-06-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-getscript.c:
+	Improved handling of script truncation bugs: connection is now
+	closed.
+	[66e3ca082d4f]
+
+2009-06-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-getscript.c:
+	Fixed GETSCRIPT problem that broke script retrieval of scripts
+	larger than 8192 bytes and produced an uninformative error.
+	[1910911af0f8]
+
+2009-06-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client.c:
+	Adjusted to changes in Dovecot regarding client idle timeout vs
+	authentication timeout.
+	[c77027f668b9]
+
+2009-06-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-private.h, src/lib-sievestorage
+	/sieve-storage-save.c, src/lib-sievestorage/sieve-storage-script.c:
+	Prevented temp script name from showing up in error output.
+	[12093e0ebecc]
+
+	* .hgtags:
+	Added tag 0.11.5 for changeset 947a147ab150
+	[c426a9c8d4ec]
+
+	* .hgtags:
+	Added tag 0.11.4 for changeset 2f2dae9ba865
+	[947a147ab150] [0.11.5]
+
+	* Merged concurrent changes.
+	[87a4983567c8]
+
+2009-05-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Minor code cleanup.
+	[29614148b6b4]
+
+	* src/managesieve/main.c:
+	Depricated sieve_storage setting in favour of sieve_dir.
+	[aeca80a747fd]
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Fixed indent problems.
+	[585d6d6e60f5]
+
+2009-06-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.11.4.
+	[dd4717818aa5]
+
+	* NEWS:
+	Updated NEWS file for new release.
+	[4594a9b97c75]
+
+2009-05-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed bug in proxy authentication.
+	[068b2746ce0d]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-login
+	/managesieve-proxy.c:
+	Proxy had IMAP port as default port.
+	[43c500edd103]
+
+	* src/managesieve-login/client-authenticate.c:
+	Fixed small line skip bug in the authenticate command.
+	[c02d8ca19a0d]
+
+2009-05-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Merged concurrent changes.
+	[d4396e5076cc]
+
+2009-04-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS, configure.in:
+	Released v0.11.4.
+	[2f2dae9ba865] [0.11.4]
+
+2009-05-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-login
+	/client-authenticate.h, src/managesieve-login/client.c, src
+	/managesieve-login/client.h, src/managesieve-login/managesieve-
+	proxy.c, src/managesieve-login/managesieve-proxy.h:
+	Incorporated various changes from imap-login into managesieve-login
+	(untested).
+	[97a7eacb4aad]
+
+2009-04-10  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Adjusted to signal handler API change in Dovecot.
+	[4a0e02ae5db2]
+
+2009-04-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Added TODO item.
+	[45ee24f6a55c]
+
+2009-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.3 for changeset 8ec1103bc9c1
+	[a9231dcce293]
+
+	* configure.in:
+	Released v0.11.3.
+	[8ec1103bc9c1] [0.11.3]
+
+2009-02-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[581154538934]
+
+2009-01-31  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed small indent problem in previous change.
+	[4fb25c488864]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Added verbose log message for proxy login failure.
+	[05980fd5de09]
+
+	* Merged concurrent changes.
+	[5667030cbfce]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Fixed small bug in the ManageSieve proxy.
+	[30ad00aa8236]
+
+2009-01-30  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL:
+	Removed ugly TABs from the INSTALL file.
+	[dd499d2dae3a]
+
+	* NEWS:
+	Fixed indent problem in the NEWS file.
+	[1926c9e6b4dd]
+
+	* README:
+	Major revision of the README file.
+	[6f010aef5ceb]
+
+	* README:
+	Fixed ambiguity in the README file regarding the sieve_dir setting.
+	[d1c08d5e3958]
+
+2009-01-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Reprioritized TODO.
+	[2634d65f9b3c]
+
+	* .hgignore, configure.in, dmanagesieve-config.h.in, src/managesieve-
+	login/client.h, src/managesieve/common.h:
+	Started using config header generated by configure.
+	[ac2c64f40791]
+
+	* src/managesieve-login/managesieve-capability.c:
+	Fixed segfault bug occuring when capability string is empty.
+	[8636becd5207]
+
+2009-01-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Final adjustments to the NEWS file.
+	[7a87c0ec99ab]
+
+2009-01-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[e19e0cdaee37]
+
+	* NEWS, src/managesieve-login/client-authenticate.c:
+	Changed SASL service name from 'managesieve' into 'sieve' as
+	required by the specification.
+	[49104f6ac36b]
+
+	* DESIGN, Makefile.am, doc/design.txt:
+	Moved DESIGN file to doc directory.
+	[92671ca35338]
+
+	* NEWS:
+	Prepared NEWS file for new release.
+	[6cbda56aacdc]
+
+	* doc/rfc/draft-ietf-sieve-managesieve-09.txt, draft-ietf-sieve-
+	managesieve-08.txt:
+	Substituted protocol specification.
+	[02a2d2196016]
+
+2009-01-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Fixed handling of ~/ in use of mail-data for script location.
+	[282c5e0231f2]
+
+2009-01-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c:
+	Fixed segfault bug in the authentication timeout.
+	[45575b0b5d59]
+
+	* TODO:
+	Reprioritized TODO.
+	[9d65cc990469]
+
+	* TODO, src/lib-sievestorage/sieve-storage-save.c, src/managesieve-
+	login/client.c, src/managesieve/cmd-capability.c, src/managesieve
+	/cmd-putscript.c, src/managesieve/commands.c,
+	src/managesieve/commands.h:
+	Added CHECKSCRIPT command and marked implementation as protocol
+	VERSION 1.0.
+	[43d0d8e06028]
+
+	* draft-ietf-sieve-managesieve-01.txt, draft-ietf-sieve-
+	managesieve-08.txt:
+	Downloaded latest ManageSieve specification.
+	[f5d0e9366d9a]
+
+	* AUTHORS, src/lib-cmusieve/sieve-common.h, src/lib-cmusieve/sieve-
+	error-private.h, src/lib-cmusieve/sieve-error.c, src/lib-cmusieve
+	/sieve-error.h, src/lib-cmusieve/sieve-script-private.h, src/lib-
+	cmusieve/sieve-script.c, src/lib-cmusieve/sieve-script.h, src/lib-
+	cmusieve/sieve.c, src/lib-cmusieve/sieve.h, src/lib-managesieve
+	/managesieve-parser.c, src/lib-managesieve/managesieve-parser.h, src
+	/lib-managesieve/managesieve-quote.c, src/lib-managesieve
+	/managesieve-quote.h, src/lib-sievestorage/sieve-storage-error.h,
+	src/lib-sievestorage/sieve-storage-list.c, src/lib-sievestorage
+	/sieve-storage-list.h, src/lib-sievestorage/sieve-storage-private.h,
+	src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-save.h, src/lib-sievestorage/sieve-storage-script.c,
+	src/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h, src
+	/managesieve-login/client-authenticate.c, src/managesieve-login
+	/client-authenticate.h, src/managesieve-login/client.c, src
+	/managesieve-login/client.h, src/managesieve-login/cmd-noop.c, src
+	/managesieve-login/commands.h, src/managesieve-login/managesieve-
+	capability.c, src/managesieve-login/managesieve-capability.h, src
+	/managesieve-login/managesieve-proxy.c, src/managesieve-login
+	/managesieve-proxy.h, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-havespace.c, src/managesieve/cmd-listscripts.c,
+	src/managesieve/cmd-logout.c, src/managesieve/cmd-noop.c,
+	src/managesieve/cmd-putscript.c, src/managesieve/cmd-renamescript.c,
+	src/managesieve/cmd-setactive.c, src/managesieve/commands.c,
+	src/managesieve/commands.h, src/managesieve/common.h,
+	src/managesieve/main.c:
+	Added and updated copyright messages to include the new year.
+	[4e7a1b66a5fe]
+
+2008-12-27  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Added dump-capability functionality to the managesieve binary.
+	[e2d43b2571d2]
+
+	* src/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client.c, src/managesieve-
+	login/managesieve-capability.c, src/managesieve-login/managesieve-
+	capability.h:
+	Implemented retrieving capabilities from the managesieve daemon in
+	stead of loading the sieve library into the login daemon.
+	[6d05b2352618]
+
+2008-12-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve/sieve-
+	script.c, src/lib-cmusieve/sieve-script.h, src/lib-cmusieve/sieve.c,
+	src/lib-cmusieve/sieve.h, src/managesieve-login/client.c, src
+	/managesieve-login/managesieve-proxy.c, src/managesieve/main.c:
+	Adapted to changes in Sieve and Dovecot.
+	[2455ced8fb3e]
+
+2008-12-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/client.c:
+	Adapted to changes in the Dovecot API.
+	[65bbf889f6a7]
+
+2008-11-28  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.2 for changeset 75f6d40cb4d5
+	[2a6fd3294a09]
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Properly set maximum permissions for uploaded scripts, was 0777.
+	[a0f0f0caf0a9]
+
+2008-11-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in:
+	Released v0.11.2.
+	[75f6d40cb4d5] [0.11.2]
+
+2008-11-24  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Updated NEWS file.
+	[768aa94cc154]
+
+2008-11-22  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-cmusieve/sieve.c, src/lib-cmusieve/sieve.h, src
+	/managesieve-login/client.c, src/managesieve/cmd-capability.c:
+	Cleaned up capability reporting and added NOTIFY capability.
+	[147b2f1b4230]
+
+2008-11-21  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/Makefile.am:
+	Fixed compile problem caused by changes in Dovecot.
+	[18a1c92ba81a]
+
+2008-11-17  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.1 for changeset ef627c91feee
+	[6f112d9171ac]
+
+	* NEWS, configure.in, src/lib-sievestorage/Makefile.am:
+	Released v0.11.1.
+	[ef627c91feee] [0.11.1]
+
+2008-11-16  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-script.c:
+	Disallowed '/' characters in script names.
+	[445c103f2b45]
+
+2008-11-15  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Minor change to the TODO list.
+	[9775c8ca27f6]
+
+	* TODO, src/managesieve/cmd-putscript.c:
+	Implemented WARNINGS response code.
+	[e4cd0bbb51b2]
+
+	* TODO, src/lib-sievestorage/sieve-storage-error.h, src/lib-
+	sievestorage/sieve-storage-private.h, src/lib-sievestorage/sieve-
+	storage-save.c, src/lib-sievestorage/sieve-storage-script.c, src
+	/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h,
+	src/managesieve/client.c, src/managesieve/cmd-deletescript.c:
+	Improved error handling and implemented ALREADYEXISTS response code.
+	[3fc05b4fbf56]
+
+2008-11-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO, src/lib-sievestorage/sieve-storage-script.c, src/managesieve
+	/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-renamescript.c, src/managesieve/cmd-setactive.c:
+	Implemented NONEXISTENT response code.
+	[617f6b259f23]
+
+	* src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage-script.h, src/managesieve/cmd-deletescript.c:
+	Implemented ACTIVE response code.
+	[8a8f93db8614]
+
+	* TODO:
+	Updated TODO.
+	[7b6e9b80da2d]
+
+	* src/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client.c, src/managesieve-
+	login/client.h, src/managesieve-login/cmd-noop.c, src/managesieve-
+	login/commands.h:
+	Added pre-auth NOOP command.
+	[bdc4c280be29]
+
+	* TODO:
+	Updated TODO.
+	[f2cf49e1d6f9]
+
+	* src/managesieve/cmd-noop.c:
+	Updated NOOP command to new draft spec (not pre-auth available yet).
+	[3b50e9d3fefc]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c:
+	Minor cleanups in the code (indentation).
+	[df5d3041fe29]
+
+	* TODO:
+	Updated TODO
+	[5e28128e60fe]
+
+	* draft-ietf-sieve-managesieve-01.txt:
+	Added draft standard document.
+	[b6d643971b22]
+
+2008-11-05  Stephan Bosch  <stephan@rename-it.nl>
+
+	* configure.in, src/lib-sievestorage/Makefile.am, src/managesieve-
+	login/Makefile.am, src/managesieve/Makefile.am:
+	Added root directory of sieve plugin to include patch to include
+	newly added config header (dovecot-libsieve changed).
+	[6d90d0fa402f]
+
+2008-10-23  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.11.0 for changeset eb997ed30a44
+	[36496bf8e0c6]
+
+	* configure.in:
+	Released v0.11.0.
+	[eb997ed30a44] [0.11.0]
+
+	* src/lib-cmusieve/Makefile.am:
+	Fixed bug in { test ! -d dovecot-1.2-managesieve-0.11.0 || { find
+	dovecot-1.2-managesieve-0.11.0 -type d ! -perm -200 -exec chmod u+w
+	{} ';' && rm -fr dovecot-1.2-managesieve-0.11.0; }; } mkdir
+	dovecot-1.2-managesieve-0.11.0 mkdir -p --
+	dovecot-1.2-managesieve-0.11.0/. list='src'; for subdir in $list; do
+	\ if test "$subdir" = .; then :; else \ test
+	-d "dovecot-1.2-managesieve-0.11.0/$subdir" \ || mkdir
+	-p -- "dovecot-1.2-managesieve-0.11.0/$subdir" \ || exit
+	1; \ distdir=`CDPATH="${ZSH_VERSION+.}:" && cd
+	dovecot-1.2-managesieve-0.11.0 && pwd`; \
+	top_distdir=`CDPATH="${ZSH_VERSION+.}:" && cd
+	dovecot-1.2-managesieve-0.11.0 && pwd`; \ (cd $subdir &&
+	\ make \ top_distdir="$top_distdir" \
+	distdir="$distdir/$subdir" \ distdir) \
+	|| exit 1; \ fi; \ done make[1]: Entering
+	directory `/home/stephan/src/devel/dovecot-1.2-managesieve/src' list
+	='lib-cmusieve lib-managesieve lib-sievestorage managesieve
+	managesieve-login'; for subdir in $list; do \ if test
+	"$subdir" = .; then :; else \ test -d "/home/stephan/src
+	/devel/dovecot-1.2-managesieve/dovecot-1.2-managesieve-0.11.0/src/$s
+	ubdir" \ || mkdir -p -- "/home/stephan/src/devel/dovecot
+	-1.2-managesieve/dovecot-1.2-managesieve-0.11.0/src/$subdir" \
+	|| exit 1; \ distdir=`CDPATH="${ZSH_VERSION+.}:" && cd /
+	home/stephan/src/devel/dovecot-1.2-managesieve/dovecot-1.2-managesie
+	ve-0.11.0/src && pwd`; \
+	top_distdir=`CDPATH="${ZSH_VERSION+.}:" && cd /home/stephan/src/deve
+	l/dovecot-1.2-managesieve/dovecot-1.2-managesieve-0.11.0 && pwd`; \
+	(cd $subdir && \ make \
+	top_distdir="$top_distdir" \
+	distdir="$distdir/$subdir" \ distdir) \
+	|| exit 1; \ fi; \ done make[2]: Entering
+	directory `/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	cmusieve' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-cmusieve'
+	make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	managesieve' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	managesieve' make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	sievestorage' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/lib-
+	sievestorage' make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve'
+	make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve'
+	make[2]: Entering directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve-
+	login' make[2]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src/managesieve-
+	login' make[1]: Leaving directory
+	`/home/stephan/src/devel/dovecot-1.2-managesieve/src' find
+	dovecot-1.2-managesieve-0.11.0 -type d ! -perm -777 -exec chmod
+	a+rwx {} \; -o \ ! -type d ! -perm -444 -links 1 -exec
+	chmod a+r {} \; -o \ ! -type d ! -perm -400 -exec chmod
+	a+r {} \; -o \ ! -type d ! -perm -444 -exec /bin/bash
+	/home/stephan/src/devel/dovecot-1.2-managesieve/install-sh -c -m a+r
+	{} {} \; \ || chmod -R a+r dovecot-1.2-managesieve-0.11.0
+	tardir=dovecot-1.2-managesieve-0.11.0 && /bin/bash
+	/home/stephan/src/devel/dovecot-1.2-managesieve/missing --run tar
+	chof - "$tardir" | GZIP=--best gzip -c
+	>dovecot-1.2-managesieve-0.11.0.tar.gz { test ! -d
+	dovecot-1.2-managesieve-0.11.0 || { find
+	dovecot-1.2-managesieve-0.11.0 -type d ! -perm -200 -exec chmod u+w
+	{} ';' && rm -fr dovecot-1.2-managesieve-0.11.0; }; } support for
+	old sieve plugin.
+	[b3d53867ce74]
+
+	* AUTHORS, NEWS, README, TODO:
+	Minor revisions of the package documentation.
+	[556a3b88349d]
+
+2008-10-19  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Fixed compilation failure due to minor change in dict support.
+	[8b27d201d62e]
+
+2008-09-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Updated documentation to v1.2
+	[88b2a988d694]
+
+2008-09-09  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Moved sieve settings to plugin {} section of config file.
+	[0e39471148b1]
+
+2008-07-18  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-script.c:
+	Forgot changes to the script rename function.
+	[7a98d4df0ed1]
+
+	* src/lib-sievestorage/sieve-storage-list.c, src/lib-sievestorage
+	/sieve-storage-script.c, src/lib-sievestorage/sieve-storage-
+	script.h:
+	Previous change caused segfaults.
+	[55c53e7be0f3]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve/sieve-
+	script.c, src/lib-cmusieve/sieve.h, src/lib-sievestorage/sieve-
+	storage-private.h, src/lib-sievestorage/sieve-storage-save.c, src
+	/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage.c, src/managesieve/cmd-getscript.c:
+	Changed handling of script objects to avoid printing the name of the
+	main script in error messages.
+	[26a7a7c0f08c]
+
+	* src/managesieve-login/client-authenticate.c, src/managesieve-
+	login/client.c, src/managesieve-login/client.h, src/managesieve-
+	login/managesieve-proxy.c:
+	More changes to make managesieve work with dovecot-1.2 UNSTABLE.
+	[6516de69a897]
+
+	* src/managesieve-login/client.c:
+	Upgraded to dovecot-1.2 UNSTABLE development tree
+	[98ef994b03e5]
+
+	* src/lib-cmusieve/sieve-error-private.h, src/lib-cmusieve/sieve-
+	error.c, src/lib-cmusieve/sieve-error.h, src/lib-cmusieve/sieve-
+	script.c, src/lib-sievestorage/sieve-storage.c, src/managesieve/cmd-
+	putscript.c, src/managesieve/common.h:
+	Updated to compile against changes in new Sieve implementation.
+	[9c931795fa98]
+
+2008-07-12  Stephan Bosch  <stephan@rename-it.nl>
+
+	* TODO:
+	Updated TODO list.
+	[d73e3cfe1caf]
+
+	* src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage-script.h, src/managesieve-login/Makefile.am, src
+	/managesieve-login/client.c, src/managesieve/Makefile.am,
+	src/managesieve/client.c, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-noop.c, src/managesieve/cmd-renamescript.c,
+	src/managesieve/commands.c, src/managesieve/commands.h:
+	Added RENAME and NOOP capabilities.
+	[fbdcfb1fecfa]
+
+2008-07-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.3 for changeset f3822babdd53
+	[45360c8f76ec]
+
+	* NEWS, configure.in:
+	Released v0.10.3
+	[f3822babdd53] [0.10.3]
+
+	* NEWS, configure.in:
+	Fixed auto-dectection of sieve implementation in configure.
+	[749f5a50eb8b]
+
+	* src/lib-cmusieve/sieve-script.c, src/lib-cmusieve/sieve-script.h:
+	Fixed erroneous inline declarations.
+	[08d3b23308da]
+
+2008-05-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* NEWS:
+	Fixed indentation error in the NEWS file.
+	[6771103e6db2]
+
+	* NEWS:
+	Fixed indentation error in the NEWS file.
+	[ae2b4b402ac6]
+
+	* .hgtags:
+	Added tag 0.10.2 for changeset ae364c136e31
+	[34a677577950]
+
+	* configure.in:
+	Released v0.10.2.
+	[ae364c136e31] [0.10.2]
+
+2008-04-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve-login/client-authenticate.c:
+	Misplaced managesieve_parser_reset() call could break things in rare
+	occasions.
+	[9ad0783596ac]
+
+	* README:
+	Minor typo in the README.
+	[74e8cb23aaf3]
+
+	* NEWS:
+	Updated NEWS.
+	[a8198d09730e]
+
+	* INSTALL, README:
+	Updated documentation to match wiki.
+	[d721cc96dd31]
+
+	* src/managesieve-login/client-authenticate.c:
+	Fixed SASL conversation for SASL mechanisms that need more than two
+	client responses.
+	[fd7c75362f9a]
+
+2008-03-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.1 for changeset 1d8e0f019d22
+	[a951da18b8d8]
+
+	* configure.in:
+	Released v0.10.1.
+	[1d8e0f019d22] [0.10.1]
+
+	* NEWS:
+	Updated NEWS file.
+	[abd768086f01]
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Fixed assert bug in sieve-storage save occuring when save was
+	canceled.
+	[a35209b66170]
+
+	* NEWS:
+	Updated NEWS file.
+	[0729a6aa443e]
+
+	* README:
+	Updated README file.
+	[f559718ec326]
+
+2008-03-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve.c:
+	Fixed bug: compiled script was saved to sieve/tmp and left there.
+	[22ec735aeea9]
+
+	* src/lib-cmusieve/sieve.c, src/lib-sievestorage/sieve-storage-save.c,
+	src/lib-sievestorage/sieve-storage-script.c, src/lib-sievestorage
+	/sieve-storage.c:
+	Made log lines sieve-storage specific.
+	[cc0b1f5a3fdf]
+
+2008-02-29  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage-save.c:
+	Fixed bug in the saving a script to disc by incorporating related
+	changes from maildir-save.c (tmp files).
+	[1ccf54331bbb]
+
+2008-02-26  Stephan Bosch  <stephan@rename-it.nl>
+
+	* README:
+	Amended README file with proxy configuration.
+	[41b45cac234d]
+
+2008-02-25  Stephan Bosch  <stephan@rename-it.nl>
+
+	* INSTALL, README:
+	Minor changes to the documentation.
+	[dd6a0b1f411e]
+
+	* README:
+	Added Known Issues section to the README.
+	[8a726b60606e]
+
+2008-02-14  Stephan Bosch  <stephan@rename-it.nl>
+
+	* Makefile.am:
+	Added DESIGN file to tarball distribution.
+	[3ee68d9bb40b]
+
+	* .hgignore, COPYING:
+	Removed duplicate licence.
+	[0a20481bf71b]
+
+2008-02-13  Stephan Bosch  <stephan@rename-it.nl>
+
+	* .hgtags:
+	Added tag 0.10.0 for changeset 1fc40a7b807e
+	[b662dc260864]
+
+	* configure.in:
+	Released v0.10.0.
+	[1fc40a7b807e] [0.10.0]
+
+	* INSTALL:
+	Minor changes to the INSTALL file.
+	[c4ab1821769d]
+
+	* NEWS, configure.in:
+	Updated NEWS file.
+	[34b025d7db3a]
+
+	* src/lib-cmusieve/sieve.h, src/managesieve-login/client.c, src
+	/managesieve-login/managesieve-proxy.c:
+	Incorporated minor changes to the imap implementation into
+	managesieve and fixed a few compiler warnings.
+	[499c6577f171]
+
+	* INSTALL, README:
+	Moved compile info from README to separate INSTALL file.
+	[844cc1514cd8]
+
+	* README:
+	Added notice about the patch to the README.
+	[4910acccd984]
+
+	* DESIGN, NEWS, README, TODO:
+	Updated README to new situation and spliced off NEWS, TODO and
+	DESIGN files.
+	[f8280a8a986c]
+
+	* src/managesieve/cmd-putscript.c:
+	Adjusted to changes in dovecot-1.1.
+	[6938e4f41779]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-error.h, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-script.c, src/managesieve/cmd-putscript.c:
+	Adjusted to changes in dovecot-1.1.
+	[d170f3343646]
+
+2008-01-07  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/cmd-putscript.c:
+	Removed inappropriate references to 'message' from cmd_putscript.c
+	[e230e3139ce0]
+
+	* src/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage
+	/sieve-storage-save.h, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-putscript.c,
+	src/managesieve/common.h, src/managesieve/main.c:
+	Incorporated v1.1 imap (relevant) changes in client.c into
+	managesieve.
+	[29e1d96c679c]
+
+2008-01-06  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/commands.c:
+	Incorporated v1.1 imap changes in commands.c into managesieve.
+	[69899aa6fd71]
+
+	* src/managesieve/main.c:
+	Incorporated v1.1 imap changes in main.c into managesieve.
+	[e92b5cee9005]
+
+	* src/managesieve-login/managesieve-proxy.c:
+	Incorporated v1.1 imap-login changes in imap-proxy.c into
+	managesieve-login.
+	[3e8cbe6a965b]
+
+	* src/managesieve-login/client-authenticate.c:
+	Incorporated v1.1 imap-login changes in client-authenticate.c into
+	managesieve-login.
+	[1b2ae7648f1f]
+
+	* src/managesieve-login/client.c, src/managesieve-login/client.h,
+	src/managesieve/main.c:
+	Incorporated v1.1 imap-login changes in client.c/client.h into
+	managesieve-login.
+	[71920eb2b1ea]
+
+2008-01-04  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-cmusieve/sieve.c, src/lib-cmusieve/sieve.h:
+	Updated cmu sieve implementation to mathch new libsieve API.
+	[79fde30ec4e7]
+
+	* src/managesieve/cmd-putscript.c:
+	Cleaned up putscript command implementation. The script is now
+	passed to the compiler as a script object and not as a script path.
+	[9d260008a304]
+
+	* src/managesieve-login/Makefile.am, src/managesieve/Makefile.am:
+	Included extra libraries to compile against new sieve plugin.
+	[0656fb1ab0a3]
+
+2008-01-03  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/lib-sievestorage/sieve-storage.c:
+	Minor change in script storage error handling.
+	[862e79b43158]
+
+	* src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-script.c, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-script.c, src/lib-sievestorage/sieve-storage.c,
+	src/managesieve/cmd-putscript.c:
+	Fixed various bugs resulting from the script object merge.
+	[c2720aaa01e3]
+
+	* src/lib-cmusieve/sieve-error-private.h, src/lib-cmusieve/sieve-
+	error.c, src/lib-cmusieve/sieve-script.c, src/managesieve/main.c:
+	Incorporated changes in the libsieve interface and dovecot.
+	[496b349b8b6c]
+
+	* src/Makefile.am:
+	Fixed bug in makefile.
+	[03a629108c0a]
+
+	* configure.in, src/Makefile.am, src/lib-cmusieve/Makefile.am, src
+	/lib-cmusieve/sieve-common.h, src/lib-cmusieve/sieve-error-
+	private.h, src/lib-cmusieve/sieve-error.c, src/lib-cmusieve/sieve-
+	error.h, src/lib-cmusieve/sieve-script-private.h, src/lib-cmusieve
+	/sieve-script.c, src/lib-cmusieve/sieve-script.h, src/lib-
+	sievestorage/Makefile.am, src/lib-sievestorage/sieve-storage-
+	private.h, src/lib-sievestorage/sieve-storage-save.c, src/lib-
+	sievestorage/sieve-storage-save.h, src/lib-sievestorage/sieve-
+	storage-script.c, src/lib-sievestorage/sieve-storage-script.h, src
+	/lib-sievestorage/sieve-storage.c, src/lib-sievestorage/sieve-
+	storage.h, src/managesieve-login/Makefile.am,
+	src/managesieve/Makefile.am, src/managesieve/cmd-deletescript.c,
+	src/managesieve/cmd-getscript.c, src/managesieve/cmd-putscript.c,
+	src/managesieve/cmd-setactive.c:
+	Merged managesieve script object with libsieve script object to
+	remove conflict.
+	[04015ad664ff]
+
+	* src/lib-cmusieve/Makefile.am, src/lib-cmusieve/sieve-error.c, src
+	/lib-cmusieve/sieve-error.h, src/lib-cmusieve/sieve.c, src/lib-
+	cmusieve/sieve.h, src/managesieve/cmd-putscript.c:
+	Added renewed error handling to script compilation.
+	[85b13786220f]
+
+2008-01-02  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/Makefile.am, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-putscript.c, src/managesieve/main.c:
+	Re-enabled compiling scripts upon PUTSCRIPT.
+	[94941c84c15d]
+
+	* configure.in:
+	Fixed bug in configure script.
+	[e9ce47319f1e]
+
+	* src/lib-cmusieve/Makefile.am, src/lib-cmusieve/sieve.c, src/lib-
+	cmusieve/sieve.h:
+	Forgot to add new files.
+	[43de7f9e8ed1]
+
+	* .hgignore, configure.in, src/Makefile.am, src/lib-cmusieve/sieve-
+	cmu.c, src/managesieve-login/Makefile.am, src/managesieve-
+	login/client.c:
+	Added link to cmusieve implementation in dovecot-sieve-1.1.
+	[24afa34fdc90]
+
+2008-01-01  Stephan Bosch  <stephan@rename-it.nl>
+
+	* src/managesieve/main.c:
+	Fixed signal handing related assert fail in managesieve/main.c.
+	[87bd5155de04]
+
+	* .hgignore, src/managesieve-login/managesieve-login:
+	Accidentally added managesieve-login binary.
+	[150201234662]
+
+	* .hgignore, AUTHORS, COPYING.LGPL, INSTALL, Makefile.am, NEWS,
+	README, autogen.sh, configure.in, src/Makefile.am, src/lib-cmusieve
+	/sieve-cmu.c, src/lib-managesieve/Makefile.am, src/lib-managesieve
+	/managesieve-parser.c, src/lib-managesieve/managesieve-parser.h, src
+	/lib-managesieve/managesieve-quote.c, src/lib-managesieve
+	/managesieve-quote.h, src/lib-sievestorage/Makefile.am, src/lib-
+	sievestorage/sieve-storage-list.c, src/lib-sievestorage/sieve-
+	storage-list.h, src/lib-sievestorage/sieve-storage-private.h, src
+	/lib-sievestorage/sieve-storage-save.c, src/lib-sievestorage/sieve-
+	storage-save.h, src/lib-sievestorage/sieve-storage-script.c, src
+	/lib-sievestorage/sieve-storage-script.h, src/lib-sievestorage
+	/sieve-storage.c, src/lib-sievestorage/sieve-storage.h, src
+	/managesieve-login/Makefile.am, src/managesieve-login/client-
+	authenticate.c, src/managesieve-login/client-authenticate.h, src
+	/managesieve-login/client.c, src/managesieve-login/client.h, src
+	/managesieve-login/managesieve-login, src/managesieve-login
+	/managesieve-proxy.c, src/managesieve-login/managesieve-proxy.h,
+	src/managesieve/Makefile.am, src/managesieve/client.c,
+	src/managesieve/client.h, src/managesieve/cmd-capability.c,
+	src/managesieve/cmd-deletescript.c, src/managesieve/cmd-getscript.c,
+	src/managesieve/cmd-havespace.c, src/managesieve/cmd-listscripts.c,
+	src/managesieve/cmd-logout.c, src/managesieve/cmd-putscript.c,
+	src/managesieve/cmd-setactive.c, src/managesieve/commands.c,
+	src/managesieve/commands.h, src/managesieve/common.h,
+	src/managesieve/main.c, stamp.h.in:
+	Started repository for MANAGESIEVE implementation as separate
+	package.
+	[e81ad896fdf8]
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/configure.in dovecot-1.2.4/dovecot-managesieve/configure.in
--- dovecot-1.2.4.orig/dovecot-managesieve/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/configure.in	2009-08-21 00:56:52.000000000 +0200
@@ -0,0 +1,111 @@
+AC_INIT([Dovecot ManageSieve], [0.11.9], [dovecot@dovecot.org], [dovecot-1.2-managesieve])
+AC_CONFIG_SRCDIR([src])
+
+AC_CONFIG_HEADERS([dummy-config.h dmanagesieve-config.h])
+
+AC_DEFINE_UNQUOTED(MANAGESIEVE_NAME, "$PACKAGE_NAME",
+    [Define to the full name of this Sieve implementation.])
+AC_DEFINE_UNQUOTED(MANAGESIEVE_VERSION, "$PACKAGE_VERSION",
+    [Define to the version of this Sieve implementation.])
+
+AM_INIT_AUTOMAKE([no-define foreign])
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AM_PROG_LIBTOOL
+
+AC_ARG_WITH(dovecot,
+[  --with-dovecot[=DIR]    Dovecot base directory (../)],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+
+AC_ARG_WITH(dovecot-sieve,
+[  --with-dovecot-sieve[=DIR]    Dovecot-sieve plugin base directory (../)],
+    dovecot_sievedir="$withval",
+    dovecot_sievedir=../dovecot-sieve-1.1
+)
+
+top=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $top
+cd $dovecot_sievedir
+dovecot_sievedir=`pwd`
+cd $top
+AC_SUBST(dovecotdir)
+AC_SUBST(dovecot_sievedir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources or to a directory with the"
+  echo "installed dovecot-config file."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+if test -d "$dovecotdir/src"; then
+  # compiling against sources
+  have_dovecot_libs=yes
+else
+  # compiling against installed headers
+  have_dovecot_libs=no
+fi
+AM_CONDITIONAL(HAVE_DOVECOT_LIBS, test "$have_dovecot_libs" = "yes")
+
+if test -f "$dovecot_sievedir/src/sieve-cmu.c"; then
+  # compiling against old cmu sieve plugin
+  echo "compiling against old dovecot-sieve plugin."
+  SIEVE_PLUGIN_TOP=$dovecot_sievedir
+  SIEVE_PLUGIN_INCLUDE=$top/src/lib-cmusieve
+  SIEVE_PLUGIN_LIB=$top/src/lib-cmusieve/libsieve_cmu.la
+  have_old_sieve_plugin=yes
+else
+  if test -f "$dovecot_sievedir/src/lib-sieve/sieve.c"; then
+    # compiling against native dovecot sieve plugin
+    echo "compiling against new dovecot-sieve plugin."
+	SIEVE_PLUGIN_TOP=$dovecot_sievedir
+    SIEVE_PLUGIN_INCLUDE=$dovecot_sievedir/src/lib-sieve
+    SIEVE_PLUGIN_LIB=$dovecot_sievedir/src/lib-sieve/libsieve.la
+    have_old_sieve_plugin=no
+  else
+    echo
+    echo "Dovecot Sieve implementation not found from $dovecot_sievedir, "
+    echo "use --with-dovecot-sieve=PATH to give path to compiled Dovecot Sieve sources."
+    AC_MSG_ERROR([dovecot-sieve not found])
+  fi
+fi
+AM_CONDITIONAL(HAVE_OLD_SIEVE_PLUGIN, test "$have_old_sieve_plugin" = "yes")
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+if test $have_dovecot_libs = yes; then
+  dovecot_incdir="$dovecotdir"
+fi
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(SSL_LIBS)
+AC_SUBST(dovecot_incdir)
+AC_SUBST(moduledir)
+
+AC_SUBST(SIEVE_PLUGIN_TOP)
+AC_SUBST(SIEVE_PLUGIN_INCLUDE)
+AC_SUBST(SIEVE_PLUGIN_LIB)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/lib-sievestorage/Makefile
+src/lib-managesieve/Makefile
+src/managesieve/Makefile
+src/managesieve-login/Makefile
+src/lib-cmusieve/Makefile
+stamp.h])
+
+AC_OUTPUT
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/COPYING dovecot-1.2.4/dovecot-managesieve/COPYING
--- dovecot-1.2.4.orig/dovecot-managesieve/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/COPYING	2008-07-18 12:09:52.000000000 +0200
@@ -0,0 +1,4 @@
+See AUTHORS file for list of copyright holders.
+
+Everything is licenced under LGPLv2.1 (see COPYING.LGPL) unless otherwise 
+mentioned at the beginning of the file.
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/COPYING.LGPL dovecot-1.2.4/dovecot-managesieve/COPYING.LGPL
--- dovecot-1.2.4.orig/dovecot-managesieve/COPYING.LGPL	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/COPYING.LGPL	2008-07-18 12:09:52.000000000 +0200
@@ -0,0 +1,510 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/depcomp dovecot-1.2.4/dovecot-managesieve/depcomp
--- dovecot-1.2.4.orig/dovecot-managesieve/depcomp	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/depcomp	2008-07-18 12:18:45.000000000 +0200
@@ -0,0 +1,589 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2007-03-29.01
+
+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007 Free Software
+# Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.
+
+case $1 in
+  '')
+     echo "$0: No command.  Try \`$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by `PROGRAMS ARGS'.
+  object      Object file output by `PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputing dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "depcomp $scriptversion"
+    exit $?
+    ;;
+esac
+
+if test -z "$depmode" || test -z "$source" || test -z "$object"; then
+  echo "depcomp: Variables source, object and depmode must be set" 1>&2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo "$object" |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f "$tmpdepfile"
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test "$depmode" = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test "$depmode" = dashXmstdout; then
+   # This is just like dashmstdout with a different argument.
+   dashmflag=-xM
+   depmode=dashmstdout
+fi
+
+case "$depmode" in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+## Unfortunately, FreeBSD c89 acceptance of flags depends upon
+## the command line argument order; so add the flags where they
+## appear in depend2.am.  Note that the slowdown incurred here
+## affects only configure: in makefiles, %FASTDEP% shortcuts this.
+  for arg
+  do
+    case $arg in
+    -c) set fnord "$@" -MT "$object" -MD -MP -MF "$tmpdepfile" "$arg" ;;
+    *)  set fnord "$@" "$arg" ;;
+    esac
+    shift # fnord
+    shift # $arg
+  done
+  "$@"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  mv "$tmpdepfile" "$depfile"
+  ;;
+
+gcc)
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z "$gccflag"; then
+    gccflag=-MD,
+  fi
+  "$@" -Wp,"$gccflag$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
+## The second -e expression handles DOS-style file names with drive letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
+## This next piece of magic avoids the `deleted header file' problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+  tr ' ' '
+' < "$tmpdepfile" |
+## Some versions of gcc put a space before the `:'.  On the theory
+## that the space means something, we add a space to the output as
+## well.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test "$libtool" = yes; then
+    "$@" "-Wp,-MDupdate,$tmpdepfile"
+  else
+    "$@" -MDupdate "$tmpdepfile"
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+
+  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
+    echo "$object : \\" > "$depfile"
+
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like `#:fec' to the end of the
+    # dependency line.
+    tr ' ' '
+' < "$tmpdepfile" \
+    | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' | \
+    tr '
+' ' ' >> $depfile
+    echo >> $depfile
+
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' '
+' < "$tmpdepfile" \
+   | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+   >> $depfile
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts `$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$base.u
+    tmpdepfile3=$dir.libs/$base.u
+    "$@" -Wc,-M
+  else
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$dir$base.u
+    tmpdepfile3=$dir$base.u
+    "$@" -M
+  fi
+  stat=$?
+
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    # Each line is of the form `foo.o: dependent.h'.
+    # Do two passes, one to just change these to
+    # `$object: dependent.h' and one to simply `dependent.h:'.
+    sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+    # That's a tab and a space in the [].
+    sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+  else
+    # The sourcefile does not contain any dependencies, so just
+    # store a dummy comment line, to avoid errors with the Makefile
+    # "include basename.Plo" scheme.
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+icc)
+  # Intel's C compiler understands `-MD -MF file'.  However on
+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
+  # ICC 7.0 will fill foo.d with something like
+  #    foo.o: sub/foo.c
+  #    foo.o: sub/foo.h
+  # which is wrong.  We want:
+  #    sub/foo.o: sub/foo.c
+  #    sub/foo.o: sub/foo.h
+  #    sub/foo.c:
+  #    sub/foo.h:
+  # ICC 7.1 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using \ :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
+    sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp2)
+  # The "hp" stanza above does not work with aCC (C++) and HP's ia64
+  # compilers, which have integrated preprocessors.  The correct option
+  # to use with these is +Maked; it writes dependencies to a file named
+  # 'foo.d', which lands next to the object file, wherever that
+  # happens to be.
+  # Much of this is similar to the tru64 case; see comments there.
+  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+  test "x$dir" = "x$object" && dir=
+  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir.libs/$base.d
+    "$@" -Wc,+Maked
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    "$@" +Maked
+  fi
+  stat=$?
+  if test $stat -eq 0; then :
+  else
+     rm -f "$tmpdepfile1" "$tmpdepfile2"
+     exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    sed -e "s,^.*\.[a-z]*:,$object:," "$tmpdepfile" > "$depfile"
+    # Add `dependent.h:' lines.
+    sed -ne '2,${; s/^ *//; s/ \\*$//; s/$/:/; p;}' "$tmpdepfile" >> "$depfile"
+  else
+    echo "#dummy" > "$depfile"
+  fi
+  rm -f "$tmpdepfile" "$tmpdepfile2"
+  ;;
+
+tru64)
+   # The Tru64 compiler uses -MD to generate dependencies as a side
+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.
+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+   # dependencies in `foo.d' instead, so we check for that too.
+   # Subdirectories are respected.
+   dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
+   test "x$dir" = "x$object" && dir=
+   base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+
+   if test "$libtool" = yes; then
+      # With Tru64 cc, shared objects can also be used to make a
+      # static library.  This mechanism is used in libtool 1.4 series to
+      # handle both shared and static libraries in a single compilation.
+      # With libtool 1.4, dependencies were output in $dir.libs/$base.lo.d.
+      #
+      # With libtool 1.5 this exception was removed, and libtool now
+      # generates 2 separate objects for the 2 libraries.  These two
+      # compilations output dependencies in $dir.libs/$base.o.d and
+      # in $dir$base.o.d.  We have to check for both files, because
+      # one of the two compilations can be disabled.  We should prefer
+      # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+      # automatically cleaned when .libs/ is deleted, while ignoring
+      # the former would cause a distcleancheck panic.
+      tmpdepfile1=$dir.libs/$base.lo.d   # libtool 1.4
+      tmpdepfile2=$dir$base.o.d          # libtool 1.5
+      tmpdepfile3=$dir.libs/$base.o.d    # libtool 1.5
+      tmpdepfile4=$dir.libs/$base.d      # Compaq CCC V6.2-504
+      "$@" -Wc,-MD
+   else
+      tmpdepfile1=$dir$base.o.d
+      tmpdepfile2=$dir$base.d
+      tmpdepfile3=$dir$base.d
+      tmpdepfile4=$dir$base.d
+      "$@" -MD
+   fi
+
+   stat=$?
+   if test $stat -eq 0; then :
+   else
+      rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+      exit $stat
+   fi
+
+   for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3" "$tmpdepfile4"
+   do
+     test -f "$tmpdepfile" && break
+   done
+   if test -f "$tmpdepfile"; then
+      sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
+      # That's a tab and a space in the [].
+      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+   else
+      echo "#dummy" > "$depfile"
+   fi
+   rm -f "$tmpdepfile"
+   ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z "$dashmflag" && dashmflag=-M
+  # Require at least two characters before searching for `:'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.
+  "$@" $dashmflag |
+    sed 's:^[  ]*[^: ][^:][^:]*\:[    ]*:'"$object"'\: :' > "$tmpdepfile"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  tr ' ' '
+' < "$tmpdepfile" | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  "$@" || exit $?
+  # Remove any Libtool call
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no
+  for arg in "$@"; do
+    case $cleared in
+    no)
+      set ""; shift
+      cleared=yes ;;
+    esac
+    case "$arg" in
+    -D*|-I*)
+      set fnord "$@" "$arg"; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -*|$object)
+      ;;
+    *)
+      set fnord "$@" "$arg"; shift ;;
+    esac
+  done
+  obj_suffix="`echo $object | sed 's/^.*\././'`"
+  touch "$tmpdepfile"
+  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  sed '1,2d' "$tmpdepfile" | tr ' ' '
+' | \
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+    sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile" "$tmpdepfile".bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test $1 != '--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove `-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  "$@" -E |
+    sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+       -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' |
+    sed '$ s: \\$::' > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  cat < "$tmpdepfile" >> "$depfile"
+  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o,
+  # because we must use -o when running libtool.
+  "$@" || exit $?
+  IFS=" "
+  for arg
+  do
+    case "$arg" in
+    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
+	set fnord "$@"
+	shift
+	shift
+	;;
+    *)
+	set fnord "$@" "$arg"
+	shift
+	shift
+	;;
+    esac
+  done
+  "$@" -E |
+  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::echo "`cygpath -u \\"\1\\"`":p' | sort | uniq > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::	\1 \\:p' >> "$depfile"
+  echo "	" >> "$depfile"
+  . "$tmpdepfile" | sed 's% %\\ %g' | sed -n '/^\(.*\)$/ s::\1\::p' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+none)
+  exec "$@"
+  ;;
+
+*)
+  echo "Unknown depmode $depmode" 1>&2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/dmanagesieve-config.h.in dovecot-1.2.4/dovecot-managesieve/dmanagesieve-config.h.in
--- dovecot-1.2.4.orig/dovecot-managesieve/dmanagesieve-config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/dmanagesieve-config.h.in	2009-01-27 16:55:09.000000000 +0100
@@ -0,0 +1,6 @@
+
+/* Define to the full name of this ManageSieve implementation. */
+#undef MANAGESIEVE_NAME
+
+/* Define to the version of this ManageSieve implementation. */
+#undef MANAGESIEVE_VERSION
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/doc/design.txt dovecot-1.2.4/dovecot-managesieve/doc/design.txt
--- dovecot-1.2.4.orig/dovecot-managesieve/doc/design.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/doc/design.txt	2008-07-18 12:09:52.000000000 +0200
@@ -0,0 +1,28 @@
+Design
+------
+
+The overall design of the daemon is entirely borrowed from the existing
+imap daemon. I have tried to apply the dovecot framework and programming
+paradigms as much as possible. This package contains the following
+directories:
+
+lib-managesieve: parser and quote functions (bound to disappear)
+lib-sievestorage: defines a storage for the sieve scripts (a bit crude)
+managesieve-login: the initial login daemon (derived from src/imap-login)
+managesieve: the actual managesieve daemon (derived form src/imap)
+lib-cmusieve: wrapper around dovecot-sieve-1.x to give the old sieve
+  implementation an identical interface as the new library. This makes 
+  the choice for a specific implementation arbitrary and the transition to
+  the new version a seemless process. 
+
+This package currently still requires the dovecot tree to be patched to add
+support for the new managesieve daemons. For dovecot-1.0 (<= v9), the 
+contents of this package was included in the patch, but now the managesieve 
+implementation is separated from the changes in the dovecot tree. Eventually 
+the need for the patch will disappear when Timo adds support for defining 
+arbitrary new services.
+
+The daemon currently implements all existing MANAGESIEVE commands except the 
+HAVESPACE command which always says 'ok'. It also implements the required
+support for UTF-8 strings. 
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/doc/rfc/draft-ietf-sieve-managesieve-09.txt dovecot-1.2.4/dovecot-managesieve/doc/rfc/draft-ietf-sieve-managesieve-09.txt
--- dovecot-1.2.4.orig/dovecot-managesieve/doc/rfc/draft-ietf-sieve-managesieve-09.txt	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/doc/rfc/draft-ietf-sieve-managesieve-09.txt	2009-01-27 16:51:21.000000000 +0100
@@ -0,0 +1,2913 @@
+
+
+
+Sieve Working Group                                     A. Melnikov, Ed.
+Internet-Draft                                             Isode Limited
+Intended status: Standards Track                               T. Martin
+Expires: July 21, 2009                              BeThereBeSquare Inc.
+                                                        January 17, 2009
+
+
+             A Protocol for Remotely Managing Sieve Scripts
+                    draft-ietf-sieve-managesieve-09
+
+Status of this Memo
+
+   This Internet-Draft is submitted to IETF in full conformance with the
+   provisions of BCP 78 and BCP 79.
+
+   Internet-Drafts are working documents of the Internet Engineering
+   Task Force (IETF), its areas, and its working groups.  Note that
+   other groups may also distribute working documents as Internet-
+   Drafts.
+
+   Internet-Drafts are draft documents valid for a maximum of six months
+   and may be updated, replaced, or obsoleted by other documents at any
+   time.  It is inappropriate to use Internet-Drafts as reference
+   material or to cite them other than as "work in progress."
+
+   The list of current Internet-Drafts can be accessed at
+   http://www.ietf.org/ietf/1id-abstracts.txt.
+
+   The list of Internet-Draft Shadow Directories can be accessed at
+   http://www.ietf.org/shadow.html.
+
+   This Internet-Draft will expire on July 21, 2009.
+
+Copyright Notice
+
+   Copyright (c) 2009 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents
+   (http://trustee.ietf.org/license-info) in effect on the date of
+   publication of this document.  Please review these documents
+   carefully, as they describe your rights and restrictions with respect
+   to this document.
+
+Abstract
+
+   Sieve scripts allow users to filter incoming email.  Message stores
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 1]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   are commonly sealed servers so users cannot log into them, yet users
+   must be able to update their scripts on them.  This document
+   describes a protocol "ManageSieve" for securely managing Sieve
+   scripts on a remote server.  This protocol allows a user to have
+   multiple scripts, and also alerts a user to syntactically flawed
+   scripts.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 2]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+Table of Contents
+
+   1.      Introduction . . . . . . . . . . . . . . . . . . . . . . .  5
+   1.1.    Conventions used in this document  . . . . . . . . . . . .  5
+   1.2.    Commands and Responses . . . . . . . . . . . . . . . . . .  5
+   1.3.    Syntax . . . . . . . . . . . . . . . . . . . . . . . . . .  5
+   1.4.    Response Codes . . . . . . . . . . . . . . . . . . . . . .  6
+   1.5.    Active Script  . . . . . . . . . . . . . . . . . . . . . .  8
+   1.6.    Quotas . . . . . . . . . . . . . . . . . . . . . . . . . .  8
+   1.7.    Script Names . . . . . . . . . . . . . . . . . . . . . . .  9
+   1.8.    Capabilities . . . . . . . . . . . . . . . . . . . . . . .  9
+   1.9.    Transport  . . . . . . . . . . . . . . . . . . . . . . . . 11
+
+   2.      Commands . . . . . . . . . . . . . . . . . . . . . . . . . 12
+   2.1.    AUTHENTICATE Command . . . . . . . . . . . . . . . . . . . 12
+   2.1.1.  Use of SASL PLAIN mechanism over TLS . . . . . . . . . . . 17
+   2.2.    STARTTLS Command . . . . . . . . . . . . . . . . . . . . . 17
+   2.2.1.  Server Identity Check  . . . . . . . . . . . . . . . . . . 18
+   2.3.    LOGOUT Command . . . . . . . . . . . . . . . . . . . . . . 21
+   2.4.    CAPABILITY Command . . . . . . . . . . . . . . . . . . . . 21
+   2.5.    HAVESPACE Command  . . . . . . . . . . . . . . . . . . . . 21
+   2.6.    PUTSCRIPT Command  . . . . . . . . . . . . . . . . . . . . 22
+   2.7.    LISTSCRIPTS Command  . . . . . . . . . . . . . . . . . . . 24
+   2.8.    SETACTIVE Command  . . . . . . . . . . . . . . . . . . . . 25
+   2.9.    GETSCRIPT Command  . . . . . . . . . . . . . . . . . . . . 25
+   2.10.   DELETESCRIPT Command . . . . . . . . . . . . . . . . . . . 26
+   2.11.   RENAMESCRIPT Command . . . . . . . . . . . . . . . . . . . 26
+   2.12.   CHECKSCRIPT Command  . . . . . . . . . . . . . . . . . . . 27
+   2.13.   NOOP Command . . . . . . . . . . . . . . . . . . . . . . . 28
+   2.14.   Recommended extensions . . . . . . . . . . . . . . . . . . 29
+   2.14.1. UNAUTHENTICATE Command . . . . . . . . . . . . . . . . . . 29
+
+   3.      Sieve URL Scheme . . . . . . . . . . . . . . . . . . . . . 29
+
+   4.      Formal Syntax  . . . . . . . . . . . . . . . . . . . . . . 32
+
+   5.      Security Considerations  . . . . . . . . . . . . . . . . . 38
+
+   6.      IANA Considerations  . . . . . . . . . . . . . . . . . . . 39
+   6.1.    ManageSieve Capability Registration Template . . . . . . . 39
+   6.2.    Registration of Initial ManageSieve capabilities . . . . . 40
+   6.3.    ManageSieve Response Code Registration Template  . . . . . 42
+   6.4.    Registration of Initial ManageSieve Response Codes . . . . 43
+
+   7.      Internationalization Considerations  . . . . . . . . . . . 48
+
+   8.      Acknowledgements . . . . . . . . . . . . . . . . . . . . . 49
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 3]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   9.      References . . . . . . . . . . . . . . . . . . . . . . . . 49
+   9.1.    Normative References . . . . . . . . . . . . . . . . . . . 49
+   9.2.    Informative References . . . . . . . . . . . . . . . . . . 51
+
+           Authors' Addresses . . . . . . . . . . . . . . . . . . . . 51
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 4]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+1.  Introduction
+
+1.1.  Conventions used in this document
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [KEYWORDS].
+
+   In examples, "C:" and "S:" indicate lines sent by the client and
+   server respectively.  Line breaks that do not start a new "C:" or
+   "S:" exist for editorial reasons.
+
+1.2.  Commands and Responses
+
+   A ManageSieve connection consists of the establishment of a client/
+   server network connection, an initial greeting from the server, and
+   client/server interactions.  These client/server interactions consist
+   of a client command, server data, and a server completion result
+   response.
+
+   All interactions transmitted by client and server are in the form of
+   lines, that is, strings that end with a CRLF.  The protocol receiver
+   of a ManageSieve client or server is either reading a line, or is
+   reading a sequence of octets with a known count followed by a line.
+
+1.3.  Syntax
+
+   ManageSieve is a line oriented protocol much like [IMAP] or [ACAP],
+   which runs over TCP.  There are three data types: atoms, numbers and
+   strings.  Strings may be quoted or literal.  See [ACAP] for detailed
+   descriptions of these types.
+
+   Each command consists of an atom (the command name) followed by zero
+   or more strings and numbers terminated by CRLF.
+
+   All client queries are replied to with either an OK, NO, or BYE
+   response.  Each response may be followed by a response code (see
+   Section 1.4) and by a string consisting of human readable text in the
+   local language (as returned by the LANGUAGE capability, see
+   Section 1.8), encoded in [UTF-8].  The contents of the string SHOULD
+   be shown to the user and implementations MUST NOT attempt to parse
+   the message for meaning.
+
+   The BYE response SHOULD be used if the server wishes to close the
+   connection.  A server may wish to do this because the client was idle
+   for too long or there were too many failed authentication attempts.
+   This response can be issued at any time and should be immediately
+   followed by a server hang-up of the connection.  If a server has an
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 5]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   inactivity timeout resulting in client autologout it MUST be no less
+   than 30 minutes after successful authentication.  The inactivity
+   timeout MAY be less before authentication.
+
+1.4.  Response Codes
+
+   An OK, NO, or BYE response from the server MAY contain a response
+   code to describe the event in a more detailed machine parsable
+   fashion.  A response code consists of data inside parentheses in the
+   form of an atom, possibly followed by a space and arguments.
+   Response codes are defined when there is a specific action that a
+   client can take based upon the additional information.  In order to
+   support future extension, the response code is represented as a
+   slash-separated (Solidus, %x2F) hierarchy with each level of
+   hierarchy representing increasing detail about the error.  Response
+   codes MUST NOT start with the Solidus character.  Clients MUST
+   tolerate additional hierarchical response code detail which they
+   don't understand.  For example, if the client supports the "QUOTA"
+   response code, but doesn't understand the "QUOTA/MAXSCRIPTS" response
+   code, it should treat "QUOTA/MAXSCRIPTS" as "QUOTA".
+
+   Client implementations MUST tolerate (ignore) response codes that
+   they do not recognize.
+
+   The currently defined response codes are:
+
+   AUTH-TOO-WEAK
+
+   This response code is returned in the NO or BYE response from an
+   AUTHENTICATE command.  It indicates that site security policy forbids
+   the use of the requested mechanism for the specified authentication
+   identity.
+
+   ENCRYPT-NEEDED
+
+   This response code is returned in the NO or BYE response from an
+   AUTHENTICATE command.  It indicates that site security policy
+   requires the use of a strong encryption mechanism for the specified
+   authentication identity and mechanism.
+
+   QUOTA
+
+   If this response code is returned in the NO/BYE response, it means
+   that the command would have placed the user above the site-defined
+   quota constraints.  If this response code is returned in the OK
+   response, it can mean that the user's storage is near its quota, or
+   it can mean that the account exceeded its quota but that that
+   condition is being allowed by the server (the server supports so
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 6]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   called "soft quotas").  The QUOTA response code has 2 more detailed
+   variants: "QUOTA/MAXSCRIPTS" (the maximum number of per-user scripts)
+   and "QUOTA/MAXSIZE" (the maximum script size).
+
+   REFERRAL
+
+   This response code may be returned with a BYE result from any
+   command, and includes a mandatory parameter that indicates what
+   server to access to manage this user's sieve scripts.  The server
+   will be specified by a Sieve URL (see Section 3).  The scriptname
+   portion of the URL MUST NOT be specified.  The client should
+   authenticate to the specified server and use it for all further
+   commands in the current session.
+
+   SASL
+
+   This response code can occur in the OK response to a successful
+   AUTHENTICATE command and includes the optional final server response
+   data from the server as specified by [SASL].
+
+   TRANSITION-NEEDED
+
+   This response code occurs in a NO response of an AUTHENTICATE
+   command.  It indicates that the user name is valid, but the entry in
+   the authentication database needs to be updated in order to permit
+   authentication with the specified mechanism.  This is typically done
+   by establishing a secure channel using TLS, verifying server identity
+   as specified in Section 2.2.1, and finally authenticating once using
+   the [PLAIN] authentication mechanism.  The selected mechanism SHOULD
+   then work for authentications in subsequent sessions.
+
+   This condition can happen if a user has an entry in a system
+   authentication database such as Unix /etc/passwd, but does not have
+   credentials suitable for use by the specified mechanism.
+
+   TRYLATER
+
+   A command failed due to a temporary server failure.  The client MAY
+   continue using local information and try the command later.  This
+   response code only makes sense when returned in a NO/BYE response.
+
+   ACTIVE
+
+   A command failed because it is not allowed on the active script.  For
+   example DELETESCRIPT on the active script.  This response code only
+   makes sense when returned in a NO/BYE response.
+
+   NONEXISTENT
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 7]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   A command failed because the referenced script name doesn't exist.
+   This response code only makes sense when returned in a NO/BYE
+   response.
+
+   ALREADYEXISTS
+
+   A command failed because the referenced script name already exists.
+   This response code only makes sense when returned in a NO/BYE
+   response.
+
+   TAG
+
+   This response code name is followed by a string specified in the
+   command.  See Section 2.13 for a possible use case.
+
+   WARNINGS
+
+   This response code MAY be returned by the server in the OK response
+   (but it might be returned with the NO/BYE response as well) and
+   signals the client that even though the script is syntactically
+   valid, it might contain errors not intended by the script writer.
+   This response code is typically returned in response to PUTSCRIPT
+   and/or CHECKSCRIPT commands.  A client seeing such response code
+   SHOULD present the returned warning text to the user.
+
+1.5.  Active Script
+
+   A user may have multiple Sieve scripts on the server, yet only one
+   script may be used for filtering of incoming messages.  This is the
+   active script.  Users may have zero or one active scripts and MUST
+   use the SETACTIVE command described below for changing the active
+   script or disabling Sieve processing.  For example, a user may have
+   an everyday script they normally use and a special script they use
+   when they go on vacation.  Users can change which script is being
+   used without having to download and upload a script stored somewhere
+   else.
+
+1.6.  Quotas
+
+   Servers SHOULD impose quotas to prevent malicious users from
+   overflowing available storage.  If a command would place a user over
+   a quota setting, servers that impose such quotas MUST reply with a NO
+   response containing the QUOTA response code.  Client implementations
+   MUST be able to handle commands failing because of quota
+   restrictions.
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 8]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+1.7.  Script Names
+
+   A Sieve script name is a sequence of Unicode characters encoded in
+   UTF-8 [UTF-8].  A script name MUST comply with Net-Unicode Definition
+   (Section 2 of [NET-UNICODE]), with the additional restriction of
+   prohibiting the following Unicode characters:
+
+   o  0000-001F; [CONTROL CHARACTERS]
+
+   o  007F; DELETE
+
+   o  0080-009F; [CONTROL CHARACTERS]
+
+   o  2028; LINE SEPARATOR
+
+   o  2029; PARAGRAPH SEPARATOR
+
+   Sieve script names MUST be at least one octet (and hense Unicode
+   character) long.  Zero octets script name has a special meaning (see
+   Section 2.8).  Servers MUST allow names of up to 128 Unicode
+   characters in length (which can take up to 512 bytes when encoded in
+   UTF-8, not counting the terminating NUL), and MAY allow longer names.
+   A server that receives a script name longer than its internal limit
+   MUST reject the corresponding operation, in particular it MUST NOT
+   truncate the script name.
+
+1.8.  Capabilities
+
+   Server capabilities are sent automatically by the server upon a
+   client connection, or after successful STARTTLS and AUTHENTICATE
+   (which establishes a SASL security layer) commands.  Capabilities may
+   change immediately after a successfully completed STARTTLS command,
+   and/or immediately after a successfully completed AUTHENTICATE
+   command, and/or after a successfully completed UNAUTHENTICATE command
+   (see Section 2.14.1).  Capabilities MUST remain static at all other
+   times.
+
+   Clients MAY request the capabilities at a later time by issuing the
+   CAPABILITY command described later.  The capabilities consist of a
+   series of lines each with one or two strings.  The first string is
+   the name of the capability, which is case-insensitive.  The second
+   optional string is the value associated with that capability.  Order
+   of capabilities is arbitrary, but each capability name can appear at
+   most once.
+
+   The following capabilities are defined in this document:
+
+   IMPLEMENTATION - Name of implementation and version.  This capability
+
+
+
+Melnikov & Martin         Expires July 21, 2009                 [Page 9]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   MUST always be returned by the server.
+
+   SASL - List of SASL mechanisms supported by the server, each
+   separated by a space.  This list can be empty if and only if STARTTLS
+   is also advertised.  This means that the client must negotiate TLS
+   encryption with STARTTLS first, at which point the SASL capability
+   will list a non empty list of SASL mechanisms.
+
+   SIEVE - List of space separated Sieve extensions (as listed in Sieve
+   "require" action [SIEVE]) supported by the Sieve engine.  This
+   capability MUST always be returned by the server.
+
+   STARTTLS - If TLS [TLS] is supported by this implementation.  Before
+   advertising this capability a server MUST verify to the best of its
+   ability that TLS can be successfully negotiated by a client with
+   common cipher suites.  Specifically, a server should verify that a
+   server certificate has been installed and that the TLS subsystem has
+   successfully initialized.  This capability SHOULD NOT be advertised
+   once STARTTLS or AUTHENTICATE command completes successfully.  Client
+   and server implementations MUST implement the STARTTLS extension.
+
+   MAXREDIRECTS - Specifies the limit on the number of Sieve "redirect"
+   actions a script can perform during a single evaluation.  Note, that
+   this is different from the total number of "redirect" actions a
+   script can contain.  The value is a non-negative number represented
+   as a ManageSieve string.
+
+   NOTIFY - A space separated list of URI schema parts for supported
+   notification methods.  This capability MUST be specified if the Sieve
+   implementation supports the "enotify" extension [NOTIFY].
+
+   LANGUAGE - The language (<Language-Tag> from [RFC4646]) currently
+   used for human readable error messages.  If this capability is not
+   returned, the "i-default" [RFC2277] language is assumed.  Note that
+   the current language MAY be per-user configurable (i.e. it MAY change
+   after authentication).
+
+   OWNER - The canonical name of the logged in user (SASL "authorization
+   identity") encoded in UTF-8.  This capability MUST NOT be returned in
+   unauthenticated state and SHOULD be returned once the AUTHENTICATE
+   command succeeds.
+
+   VERSION - This capability MUST be returned by servers compliant with
+   this document or its successor.  For servers compliant with this
+   document the capability value is the string "1.0".  Lack of this
+   capability means that the server predates this specification and thus
+   doesn't support the following commands: RENAMESCRIPT, CHECKSCRIPT and
+   NOOP.
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 10]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   Section 2.14 defines some additional ManageSieve extensions and their
+   respective capabilities.
+
+   A server implementation MUST return SIEVE, IMPLEMENTATION and VERSION
+   capabilities.
+
+   A client implementation MUST ignore any listed capabilities that it
+   does not understand.
+
+       Example:
+
+       S: "IMPlemENTATION" "Example1 ManageSieved v001"
+       S: "SASl" "DIGEST-MD5 GSSAPI"
+       S: "SIeVE" "fileinto vacation"
+       S: "StaRTTLS"
+       S: "NOTIFY" "xmpp mailto"
+       S: "MAXREdIRECTS" "5"
+       S: "VERSION" "1.0"
+       S: OK
+
+   After successful authentication this might look like this:
+
+       Example:
+
+       S: "IMPlemENTATION" "Example1 ManageSieved v001"
+       S: "SASl" "DIGEST-MD5 GSSAPI"
+       S: "SIeVE" "fileinto vacation"
+       S: "NOTIFY" "xmpp mailto"
+       S: "OWNER" "alexey@example.com"
+       S: "MAXREdIRECTS" "5"
+       S: "VERSION" "1.0"
+       S: OK
+
+1.9.  Transport
+
+   The ManageSieve protocol assumes a reliable data stream such as that
+   provided by TCP.  When TCP is used, a ManageSieve server typically
+   listens on port [[anchor7: To-be-assigned by IANA]].
+
+   Before opening the TCP connection, the ManageSieve client first MUST
+   resolve the Domain Name System (DNS) hostname associated with the
+   receiving entity and determine the appropriate TCP port for
+   communication with the receiving entity.  The process is as follows:
+
+   1.  Attempt to resolve the hostname using a [DNS-SRV] Service of
+       "sieve" and a Proto of "tcp" for the target domain (e.g.
+       "example.net"), resulting in resource records such as
+       "_sieve._tcp.example.net.".  The result of the SRV lookup, if
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 11]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+       successful, will be one or more combinations of a port and
+       hostname; the ManageSieve client MUST resolve the returned
+       hostnames to IPv4/IPv6 addresses according to returned SRV record
+       weight.  IP addresses from the first successfully resolved
+       hostname (with the corresponding port number returned by SRV
+       lookup) are used to connect to the server.  If connection using
+       one of the IP addresses fails, the next resolved IP address is
+       used to connect.  If connection to all resolved IP addresses
+       fails, then the resolution/connect is repeated for the next
+       hostname returned by SRV lookup.
+
+   2.  If the SRV lookup fails, the fallback SHOULD be a normal IPv4 or
+       IPv6 address record resolution to determine the IP address, where
+       the port used is the default ManageSieve port of [[anchor8: To-
+       be-assigned by IANA]].
+
+
+2.  Commands
+
+   This section and its subsections describes valid ManageSieve
+   commands.  Upon initial connection to the server the client's session
+   is in non-authenticated state.  Prior to successful authentication
+   only the AUTHENTICATE, CAPABILITY, STARTTLS, LOGOUT and NOOP (see
+   Section 2.13) commands are valid.  ManageSieve extensions MAY define
+   other commands which are valid in non-authenticated state.  Servers
+   MUST reject all other commands with a NO response.  Clients may
+   pipeline commands (send more than one command at a time without
+   waiting for completion of the first command ).  However, a group of
+   commands sent together MUST NOT have an AUTHENTICATE (*), a STARTTLS
+   or a HAVESPACE command anywhere but the last command in the list.
+
+   (*) - The only exception to this rule is when the AUTHENTICATE
+   command contains an initial response for a SASL mechanism that allows
+   clients to send data first, the mechanism is known to complete in one
+   round-trip and the mechanism doesn't negotiate a SASL security layer.
+   Two examples of such SASL mechanisms are PLAIN [PLAIN] and EXTERNAL
+   [SASL].
+
+2.1.  AUTHENTICATE Command
+
+   Arguments:  String - mechanism
+               String - initial data (optional)
+
+   The AUTHENTICATE command indicates a SASL [SASL] authentication
+   mechanism to the server.  If the server supports the requested
+   authentication mechanism, it performs an authentication protocol
+   exchange to identify and authenticate the user.  Optionally, it also
+   negotiates a security layer for subsequent protocol interactions.  If
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 12]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   the requested authentication mechanism is not supported, the server
+   rejects the AUTHENTICATE command by sending the NO response.
+
+   The authentication protocol exchange consists of a series of server
+   challenges and client responses that are specific to the selected
+   authentication mechanism.  A server challenge consists of a string
+   (quoted or literal) followed by a CRLF.  The contents of the string
+   is a base-64 encoding [BASE64] of the SASL data.  A client response
+   consists of a string (quoted or literal) with the base-64 encoding of
+   the SASL data followed by a CRLF.  If the client wishes to cancel the
+   authentication exchange, it issues a string containing a single "*".
+   If the server receives such a response, it MUST reject the
+   AUTHENTICATE command by sending an NO reply.
+
+   Note that an empty challenge/response is sent as an empty string.  If
+   the mechanism dictates that the final response is sent by the server
+   this data MAY be placed within the data portion of the SASL response
+   code to save a round trip.
+
+   The optional initial-response argument to the AUTHENTICATE command is
+   used to save a round trip when using authentication mechanisms that
+   are defined to send no data in the initial challenge.  When the
+   initial-response argument is used with such a mechanism, the initial
+   empty challenge is not sent to the client and the server uses the
+   data in the initial-response argument as if it were sent in response
+   to the empty challenge.  If the initial-response argument to the
+   AUTHENTICATE command is used with a mechanism that sends data in the
+   initial challenge, the server MUST reject the AUTHENTICATE command by
+   sending the NO response.
+
+   The service name specified by this protocol's profile of SASL is
+   "sieve".
+
+   Reauthentication is not supported by ManageSieve protocol's profile
+   of SASL.  I.e. after a successfully completed AUTHENTICATE command,
+   no more AUTHENTICATE commands may be issued in the same session.
+   After a successful AUTHENTICATE command completes, a server MUST
+   reject any further AUTHENTICATE commands with a NO reply.  However
+   note that a server may implement UNAUTHENTICATE extension described
+   in Section 2.14.1.
+
+   If a security layer is negotiated through the SASL authentication
+   exchange, it takes effect immediately following the CRLF that
+   concludes the successful authentication exchange for the client, and
+   the CRLF of the OK response for the server.
+
+   When a security layer takes effect, the ManageSieve protocol is reset
+   to the initial state (the state in ManageSieve after a client has
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 13]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   connected to the server).  The server MUST discard any knowledge
+   obtained from the client which was not obtained from the SASL (or
+   TLS) negotiation itself.  Likewise, the client MUST discard any
+   knowledge obtained from the server, such as the list of ManageSieve
+   extensions, which was not obtained from the SASL (and/or TLS)
+   negotiation itself.  (Note that a client MAY compare the advertised
+   SASL mechanisms before and after authentication in order to detect an
+   active down-negotiation attack.  See below.)
+
+   Once a SASL security layer is established, the server MUST re-issue
+   the capability results, followed by an OK response.  This is
+   necessary to protect against man-in-the-middle attacks which alter
+   the capabilities list prior to SASL negotiation.  The capability
+   results MUST include all SASL mechanisms the server was capable of
+   negotiating with that client.  This is done in order to allow the
+   client to detect active down-negotiation attack.  If a user-oriented
+   client detects such down-negotiation attack, it SHOULD either notify
+   the user (it MAY give the user the opportunity to continue with the
+   ManageSieve session in this case) or close the transport connection
+   and indicate that a down-negotiation attack might be in progress.  If
+   an automated client detects down-negotiation attack, it SHOULD return
+   or log an error indicating that a possible attack might be in
+   progress and/or SHOULD close the transport connection.
+
+   When both [TLS] and SASL security layers are in effect, the TLS
+   encoding MUST be applied (when sending data) after the SASL encoding.
+
+   Server implementations SHOULD support SASL proxy authentication so
+   that an administrator can administer a user's scripts.  Proxy
+   authentication is when a user authenticates as herself/himself but
+   requests the server to act (authorize) as another user.
+
+   The authorization identity generated by this [SASL] exchange is a
+   "simple username" (in the sense defined in [SASLprep]), and both
+   client and server MUST use the [SASLprep] profile of the [StringPrep]
+   algorithm to prepare these names for transmission or comparison.  If
+   preparation of the authorization identity fails or results in an
+   empty string (unless it was transmitted as the empty string), the
+   server MUST fail the authentication.
+
+   If an AUTHENTICATE command fails with a NO response, the client MAY
+   try another authentication mechanism by issuing another AUTHENTICATE
+   command.  In other words, the client may request authentication types
+   in decreasing order of preference.
+
+   Note that a failed (NO) response to the AUTHENTICATE command may
+   contain one of the following response codes: AUTH-TOO-WEAK, ENCRYPT-
+   NEEDED or TRANSITION-NEEDED.  See Section 1.4 for detailed
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 14]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   description of the relevant conditions.
+
+   To ensure interoperability, both client and server implementations of
+   the ManageSieve protocol MUST implement the SCRAM-HMAC-SHA-1 [SCRAM]
+   SASL mechanism, as well as [PLAIN] over [TLS].
+
+   Note: use of PLAIN over TLS reflects current use of PLAIN over TLS in
+   other email related protocols, however a longer term goal is to
+   migrate email related protocols from using PLAIN over TLS to SCRAM-
+   HMAC-SHA-1 mechanism.
+
+   Examples (Note that long lines are folded for readability and are not
+   part of protocol exchange):
+
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "SASL" "DIGEST-MD5 GSSAPI"
+       S: "SIEVE" "fileinto vacation"
+       S: "STARTTLS"
+       S: "VERSION" "1.0"
+       S: OK
+       C: Authenticate "DIGEST-MD5"
+       S: "cmVhbG09ImVsd29vZC5pbm5vc29mdC5leGFtcGxlLmNvbSIsbm9uY2U9Ik
+          9BNk1HOXRFUUdtMmhoIixxb3A9ImF1dGgiLGFsZ29yaXRobT1tZDUtc2Vz
+          cyxjaGFyc2V0PXV0Zi04"
+       C: "Y2hhcnNldD11dGYtOCx1c2VybmFtZT0iY2hyaXMiLHJlYWxtPSJlbHdvb2
+          QuaW5ub3NvZnQuZXhhbXBsZS5jb20iLG5vbmNlPSJPQTZNRzl0RVFHbTJo
+          aCIsbmM9MDAwMDAwMDEsY25vbmNlPSJPQTZNSFhoNlZxVHJSayIsZGlnZX
+          N0LXVyaT0ic2lldmUvZWx3b29kLmlubm9zb2Z0LmV4YW1wbGUuY29tIixy
+          ZXNwb25zZT1kMzg4ZGFkOTBkNGJiZDc2MGExNTIzMjFmMjE0M2FmNyxxb3
+          A9YXV0aA=="
+       S: OK (SASL "cnNwYXV0aD1lYTQwZjYwMzM1YzQyN2I1NTI3Yjg0ZGJhYmNkZ
+          mZmZA==")
+
+   A slightly different variant of the same authentication exchange:
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 15]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "SASL" "DIGEST-MD5 GSSAPI"
+       S: "SIEVE" "fileinto vacation"
+       S: "VERSION" "1.0"
+       S: "STARTTLS"
+       S: OK
+       C: Authenticate "DIGEST-MD5"
+       S: {136}
+       S: cmVhbG09ImVsd29vZC5pbm5vc29mdC5leGFtcGxlLmNvbSIsbm9uY2U9Ik
+          9BNk1HOXRFUUdtMmhoIixxb3A9ImF1dGgiLGFsZ29yaXRobT1tZDUtc2Vz
+          cyxjaGFyc2V0PXV0Zi04
+       C: {300+}
+       C: Y2hhcnNldD11dGYtOCx1c2VybmFtZT0iY2hyaXMiLHJlYWxtPSJlbHdvb2
+          QuaW5ub3NvZnQuZXhhbXBsZS5jb20iLG5vbmNlPSJPQTZNRzl0RVFHbTJo
+          aCIsbmM9MDAwMDAwMDEsY25vbmNlPSJPQTZNSFhoNlZxVHJSayIsZGlnZX
+          N0LXVyaT0ic2lldmUvZWx3b29kLmlubm9zb2Z0LmV4YW1wbGUuY29tIixy
+          ZXNwb25zZT1kMzg4ZGFkOTBkNGJiZDc2MGExNTIzMjFmMjE0M2FmNyxxb3
+          A9YXV0aA==
+       S: {56}
+       S: cnNwYXV0aD1lYTQwZjYwMzM1YzQyN2I1NTI3Yjg0ZGJhYmNkZmZmZA==
+       C: ""
+       S: OK
+
+   Another example demonstrating use of SASL PLAIN mechanism under TLS.
+   This example also demonstrate use of SASL "initial response" (the
+   second parameter to the Authenticate command):
+
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "VERSION" "1.0"
+       S: "SASL" ""
+       S: "SIEVE" "fileinto vacation"
+       S: "STARTTLS"
+       S: OK
+       C: STARTTLS
+       S: OK
+       <TLS negotiation, further commands are under TLS layer>
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "VERSION" "1.0"
+       S: "SASL" "PLAIN"
+       S: "SIEVE" "fileinto vacation"
+       S: OK
+       C: Authenticate "PLAIN" "QJIrweAPyo6Q1T9xu"
+       S: NO
+       C: Authenticate "PLAIN" "QJIrweAPyo6Q1T9xz"
+       S: NO
+       C: Authenticate "PLAIN" "QJIrweAPyo6Q1T9xy"
+       S: BYE "Too many failed authentication attempts"
+       <Server closes connection>
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 16]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   The following example demonstrates use of SASL "initial response".
+   It also demonstrates that an empty response can be sent as a literal,
+   and that negotiation a SASL security layer results in the server
+   reissuing server capabilities:
+
+       C: AUTHENTICATE "GSSAPI" {1488+}
+       C: YIIE[...1480 octets here ...]dA==
+       S: {208}
+       S: YIGZBgkqhkiG9xIBAgICAG+BiTCBhqADAgEFoQMCAQ+iejB4oAMCARKic
+          [...114 octets here ...]
+          /yzpAy9p+Y0LanLskOTvMc0MnjgAa4YEr3eJ6
+       C: {0+}
+       C:
+       S: {44}
+       S: BQQF/wAMAAwAAAAAYRGFAo6W0vIHti8i1UXODgEAEAA=
+       C: {44+}
+       C: BQQE/wAMAAwAAAAAIsT1iv9UkZApw471iXt6cwEAAAE=
+       S: OK
+       <Further commands/responses are under SASL security layer>
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "VERSION" "1.0"
+       S: "SASL" "PLAIN DIGEST-MD5 GSSAPI"
+       S: "SIEVE" "fileinto vacation"
+       S: "LANGUAGE" "ru"
+       S: "MAXREDIRECTS" "3"
+       S: ok
+
+2.1.1.  Use of SASL PLAIN mechanism over TLS
+
+   This section is normative for ManageSieve client implementations that
+   support SASL [PLAIN] over [TLS].
+
+   If a ManageSieve client is willing to use SASL PLAIN over TLS to
+   authenticate to the ManageSieve server, the client MUST verify the
+   server identity (see Section 2.2.1).  If the server identity can't be
+   verified (e.g. the server has not provided any certificate, or if the
+   certificate verification fails) the client MUST NOT attempt to
+   authenticate using the SASL PLAIN mechanism.
+
+2.2.  STARTTLS Command
+
+   Support for STARTTLS command in servers is optional.  Its
+   availability is advertised with "STARTTLS" capability as described in
+   Section 1.8.
+
+   The STARTTLS command requests commencement of a TLS [TLS]
+   negotiation.  The negotiation begins immediately after the CRLF in
+   the OK response.  After a client issues a STARTTLS command, it MUST
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 17]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   NOT issue further commands until a server response is seen and the
+   TLS negotiation is complete.
+
+   The STARTTLS command is only valid in non-authenticated state.  The
+   server remains in non-authenticated state, even if client credentials
+   are supplied during the TLS negotiation.  The SASL [SASL] EXTERNAL
+   mechanism MAY be used to authenticate once TLS client credentials are
+   successfully exchanged, but servers supporting the STARTTLS command
+   are not required to support the EXTERNAL mechanism.
+
+   After the TLS layer is established, the server MUST re-issue the
+   capability results, followed by an OK response.  This is necessary to
+   protect against man-in-the-middle attacks which alter the
+   capabilities list prior to STARTTLS.  This capability result MUST NOT
+   include the STARTTLS capability.
+
+   The client MUST discard cached capability information and replace it
+   with the new information.  The server MAY advertise different
+   capabilities after STARTTLS.
+
+       Example:
+
+       C: StartTls
+       S: oK
+       <TLS negotiation, further commands are under TLS layer>
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "SASL" "PLAIN DIGEST-MD5 GSSAPI"
+       S: "SIEVE" "fileinto vacation"
+       S: "VERSION" "1.0"
+       S: "LANGUAGE" "fr"
+       S: ok
+
+2.2.1.  Server Identity Check
+
+   During the TLS negotiation, the ManageSieve client MUST check its
+   understanding of the server hostname/IP address against the server's
+   identity as presented in the server Certificate message, in order to
+   prevent man-in-the-middle attacks.  In this section, the client's
+   understanding of the server's identity is called the "reference
+   identity".
+
+   Checking is performed according to the following rules:
+
+   o  If the reference identity is a hostname:
+
+      1.  If a subjectAltName extension of the SRVName [X509-SRV],
+          dNSName [X509] (in that order of preference) type is present
+          in the server's certificate, then it SHOULD be used as the
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 18]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+          source of the server's identity.  Matching is performed as
+          described in Section 2.2.1.1, with the exception that no
+          wildcard matching is allowed for SRVName type.  If the
+          certificate contains multiple names (e.g., more than one
+          dNSName field), then a match with any one of the fields is
+          considered acceptable.
+
+      2.  The client MAY use other types of subjectAltName for
+          performing comparison.
+
+      3.  The server's identity MAY also be verified by comparing the
+          reference identity to the Common Name (CN) [RFC4519] value in
+          the leaf Relative Distinguished Name (RDN) of the subjectName
+          field of the server's certificate.  This comparison is
+          performed using the rules for comparison of DNS names in
+          Section 2.2.1.1, below.  Although the use of the Common Name
+          value is existing practice, it is deprecated, and
+          Certification Authorities are encouraged to provide
+          subjectAltName values instead.  Note that the TLS
+          implementation may represent DNs in certificates according to
+          X.500 or other conventions.  For example, some X.500
+          implementations order the RDNs in a DN using a left-to-right
+          (most significant to least significant) convention instead of
+          LDAP's right- to-left convention.
+
+   o  When the reference identity is an IP address, the iPAddress
+      subjectAltName SHOULD be used by the client for comparison.  The
+      comparison is performed as described in Section 2.2.1.2.
+
+   If the server identity check fails, user-oriented clients SHOULD
+   either notify the user (clients MAY give the user the opportunity to
+   continue with the ManageSieve session in this case) or close the
+   transport connection and indicate that the server's identity is
+   suspect.  Automated clients SHOULD return or log an error indicating
+   that the server's identity is suspect and/or SHOULD close the
+   transport connection.  Automated clients MAY provide a configuration
+   setting that disables this check, but MUST provide a setting which
+   enables it.
+
+   Beyond the server identity check described in this section, clients
+   should be prepared to do further checking to ensure that the server
+   is authorized to provide the service it is requested to provide.  The
+   client may need to make use of local policy information in making
+   this determination.
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 19]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+2.2.1.1.  Comparison of DNS Names
+
+   If the reference identity is an internationalized domain name,
+   conforming implementations MUST convert it to the ASCII Compatible
+   Encoding (ACE) format as specified in Section 4 of RFC 3490 [RFC3490]
+   before comparison with subjectAltName values of type dNSName.
+   Specifically, conforming implementations MUST perform the conversion
+   operation specified in Section 4 of [RFC3490] as follows:
+
+   o  in step 1, the domain name SHALL be considered a "stored string";
+
+   o  in step 3, set the flag called "UseSTD3ASCIIRules";
+
+   o  in step 4, process each label with the "ToASCII" operation; and
+
+   o  in step 5, change all label separators to U+002E (full stop).
+
+   After performing the "to-ASCII" conversion, the DNS labels and names
+   MUST be compared for equality according to the rules specified in
+   Section 3 of [RFC3490], i.e. once all label separators are replaced
+   with U+002E (dot) they are compared in the case-insensitive manner.
+
+   The '*' (ASCII 42) wildcard character is allowed in subjectAltName
+   values of type dNSName, and then only as the left-most (least
+   significant) DNS label in that value.  This wildcard matches any
+   left-most DNS label in the server name.  That is, the subject
+   *.example.com matches the server names a.example.com and
+   b.example.com, but does not match example.com or a.b.example.com.
+
+2.2.1.2.  Comparison of IP Addresses
+
+   When the reference identity is an IP address, the identity MUST be
+   converted to the "network byte order" octet string representation
+   [RFC791][RFC2460].  For IP Version 4, as specified in RFC 791, the
+   octet string will contain exactly four octets.  For IP Version 6, as
+   specified in RFC 2460, the octet string will contain exactly sixteen
+   octets.  This octet string is then compared against subjectAltName
+   values of type iPAddress.  A match occurs if the reference identity
+   octet string and value octet strings are identical.
+
+2.2.1.3.  Comparison of Other subjectName Types
+
+   Client implementations MAY support matching against subjectAltName
+   values of other types as described in other documents.
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 20]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+2.3.  LOGOUT Command
+
+   The client sends the LOGOUT command when it is finished with a
+   connection and wishes to terminate it.  The server MUST reply with an
+   OK response.  The server MUST ignore commands issued by the client
+   after the LOGOUT command.
+
+   The client SHOULD wait for the OK response before closing the
+   connection.  This avoids the TCP connection going into the TIME_WAIT
+   state on the server.  In order to avoid going into the the TIME_WAIT
+   TCP state the server MAY wait for a short while for the client to
+   close the TCP connection first.  Whether or not the server waits for
+   the client to close the connection, it MUST then close the connection
+   itself.
+
+       Example:
+
+       C: Logout
+       S: Ok
+       <connection is terminated>
+
+2.4.  CAPABILITY Command
+
+   The CAPABILITY command requests the server capabilities as described
+   earlier in this document.  It has no parameters.
+
+       Example:
+
+       C: CAPABILITY
+       S: "IMPLEMENTATION" "Example1 ManageSieved v001"
+       S: "VERSION" "1.0"
+       S: "SASL" "PLAIN OTP GSSAPI"
+       S: "SIEVE" "fileinto vacation"
+       S: "STARTTLS"
+       S: OK
+
+2.5.  HAVESPACE Command
+
+   Arguments:  String - name
+               Number - script size
+
+   The HAVESPACE command is used to query the server for available
+   space.  Clients specify the name they wish to save the script as and
+   its size in octets.  Both parameters can be used by the server to see
+   if the script with the specified name and size is within user's
+   quota(s), for example the server MAY use the script name to check if
+   a script would be replaced or a new one would be created.  Servers
+   respond with an NO if storing a script with that name and size would
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 21]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   fail or OK otherwise.  Clients SHOULD issue this command before
+   attempting to place a script on the server.
+
+   Note that the OK response from the HAVESPACE command does not
+   constitute a guarantee of success as server disk space conditions
+   could change between the client issuing the HAVESPACE and the client
+   issuing the PUTSCRIPT commands.  A QUOTA response code (see
+   Section 1.4) remains a possible (albeit unlikely) response to a
+   subsequent PUTSCRIPT with the same name and size.
+
+       Example:
+
+       C: HAVESPACE "myscript" 999999
+       S: NO (QUOTA/MAXSIZE) "Quota exceeded"
+
+       C: HAVESPACE "foobar" 435
+       S: OK
+
+2.6.  PUTSCRIPT Command
+
+   Arguments:  String - Script name
+               String - Script content
+
+   The PUTSCRIPT command is used by the client to submit a Sieve script
+   to the server.
+
+   If the script already exists, upon success the old script will be
+   overwritten.  The old script MUST NOT be overwritten if PUTSCRIPT
+   fails in any way.  A script of zero length SHOULD be disallowed.
+
+   This command places the script on the server.  It does not affect
+   whether the script is processed on incoming mail, unless it replaces
+   the script which is already active.  The SETACTIVE command is used to
+   mark a script as active.
+
+   When submitting large scripts clients SHOULD use the HAVESPACE
+   command beforehand to query if the server is willing to accept a
+   script of that size.
+
+   The server MUST check the submitted script for validity, which
+   includes checking that the script complies with the Sieve grammar
+   [SIEVE], and that all Sieve extensions mentioned in script's
+   "require" statement(s) are supported by the Sieve interpreter.  (Note
+   that if the Sieve interpreter supports the Sieve "ihave" extension
+   [I-HAVE], any unrecognized/unsupported extension mentioned in the
+   "ihave" test MUST NOT cause the validation failure.)  Other checks
+   such as validating the supplied command arguments for each command
+   MAY be performed.  Essentially, the performed validation SHOULD be
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 22]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   the same as performed when compiling the script for execution.
+   Implementations that use a binary representation to store compiled
+   scripts can extend the validation to a full compilation, in order to
+   avoid validating uploaded scripts multiple times.
+
+   If the script fails the validation the server MUST reply with a NO
+   response.  Any script that fails the validity test MUST NOT be stored
+   on the server.  The message given with a NO response MUST be human
+   readable and SHOULD contain a specific error message giving the line
+   number of the first error.  Implementors should strive to produce
+   helpful error messages similar to those given by programming language
+   compilers.  Client implementations should note that this may be a
+   multiline literal string with more than one error message separated
+   by CRLFs.  The human readable message is in the language returned in
+   the latest LANGUAGE capability (or in "i-default", see Section 1.8),
+   encoded in UTF-8 [UTF-8].
+
+   An OK response MAY contain the WARNINGS response code.  In such case
+   the human readable message that follows the OK response SHOULD
+   contain a specific warning message (or messages) giving the line
+   number(s) in the script that might contain errors not intended by the
+   script writer.  The human readable message is in the language
+   returned in the latest LANGUAGE capability (or in "i-default", see
+   Section 1.8), encoded in UTF-8 [UTF-8] A client seeing such response
+   code SHOULD present the message to the user.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 23]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+       Examples:
+
+       C: Putscript "foo" {31+}
+       C: #comment
+       C: InvalidSieveCommand
+       C:
+       S: NO "line 2: Syntax error"
+
+       C: Putscript "mysievescript" {110+}
+       C: require ["fileinto"];
+       C:
+       C: if envelope :contains "to" "tmartin+sent" {
+       C:   fileinto "INBOX.sent";
+       C: }
+       S: OK
+
+       C: Putscript "myforwards" {190+}
+       C: redirect "111@example.net";
+       C:
+       C: if size :under 10k {
+       C:     redirect "mobile@cell.example.com";
+       C: }
+       C:
+       C: if envelope :contains "to" "tmartin+lists" {
+       C:     redirect "lists@groups.example.com";
+       C: }
+       S: OK (WARNINGS) "line 8: server redirect action
+               limit is 2, this redirect might be ignored"
+
+2.7.  LISTSCRIPTS Command
+
+   This command lists the scripts the user has on the server.  Upon
+   success a list of CRLF separated script names (each represented as a
+   quoted or literal string) is returned followed by an OK response.  If
+   there exists an active script the atom ACTIVE is appended to the
+   corresponding script name.  The atom ACTIVE MUST NOT appear on more
+   than one response line.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 24]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+       Example:
+
+       C: Listscripts
+       S: "summer_script"
+       S: "vacation_script"
+       S: {13}
+       S: clever"script
+       S: "main_script" ACTIVE
+       S: OK
+
+       C: listscripts
+       S: "summer_script"
+       S: "main_script" active
+       S: OK
+
+2.8.  SETACTIVE Command
+
+   Arguments:  String - script name
+
+   This command sets a script active.  If the script name is the empty
+   string (i.e. "") then any active script is disabled.  Disabling an
+   active script when there is no script active is not an error and MUST
+   result in OK reply.
+
+   If the script does not exist on the server then the server MUST reply
+   with a NO response.  Such reply SHOULD contain the NONEXISTENT
+   response code.
+
+       Examples:
+
+       C: Setactive "vacationscript"
+       S: Ok
+
+       C: Setactive ""
+       S: Ok
+
+       C: Setactive "baz"
+       S: No (NONEXISTENT) "There is no script by that name"
+
+       C: Setactive "baz"
+       S: No (NONEXISTENT) {31}
+       S: There is no script by that name
+
+2.9.  GETSCRIPT Command
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 25]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   Arguments:  String - script name
+
+   This command gets the contents of the specified script.  If the
+   script does not exist the server MUST reply with a NO response.  Such
+   reply SHOULD contain the NONEXISTENT response code.
+
+   Upon success a string with the contents of the script is returned
+   followed by a OK response.
+
+       Example:
+
+       C: Getscript "myscript"
+       S: {54}
+       S: #this is my wonderful script
+       S: reject "I reject all";
+       S:
+       S: OK
+
+2.10.  DELETESCRIPT Command
+
+   Arguments:  String - script name
+
+   This command is used to delete a user's Sieve script.  Servers MUST
+   reply with a NO response if the script does not exist.  Such
+   responses SHOULD include the NONEXISTENT response code.
+
+   The server MUST NOT allow the client to delete an active script, so
+   the server MUST reply with a NO response if attempted.  Such response
+   SHOULD contain the ACTIVE response code.  If a client wishes to
+   delete an active script it should use the SETACTIVE command to
+   disable the script first.
+
+       Example:
+
+       C: Deletescript "foo"
+       S: Ok
+
+       C: Deletescript "baz"
+       S: No (ACTIVE) "You may not delete an active script"
+
+2.11.  RENAMESCRIPT Command
+
+   Arguments:  String - Old Script name
+               String - New Script name
+
+   This command is used to rename a user's Sieve script.  Servers MUST
+   reply with a NO response if the old script does not exist (in which
+   case the NONEXISTENT response code SHOULD be included), or a script
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 26]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   with the new name already exists (in which case the ALREADYEXISTS
+   response code SHOULD be included).  Renaming the active script is
+   allowed, the renamed script remains active.
+
+       Example:
+
+       C: Renamescript "foo" "bar"
+       S: Ok
+
+       C: Renamescript "baz" "bar"
+       S: No "bar already exists"
+
+   If the server doesn't support the RENAMESCRIPT command, the client
+   can emulate it by performing the following steps:
+
+   1.  List available scripts with LISTSCRIPTS.  If the script with the
+       new script name exists, then the client should ask the user
+       whether to abort the operation, to replace the script (by issuing
+       the DELETESCRIPT <newname> after that) or to chose a different
+       name.
+
+   2.  Download the old script with GETSCRIPT <oldname>.
+
+   3.  Upload the old script with the new name: PUTSCRIPT <newname>.
+
+   4.  If the old script was active (as reported by LISTSCRIPTS in step
+       1), then make the new script active: SETACTIVE <newname>
+
+   5.  Delete the old script: DELETESCRIPT <oldname>
+
+   Note that these steps don't describe how to handle various other
+   error conditions (for example NO response containing QUOTA response
+   code in step 3).  Error handling is left as an excercise for the
+   reader.
+
+2.12.  CHECKSCRIPT Command
+
+   Arguments:  String - Script content
+
+   The CHECKSCRIPT command is used by the client to verify Sieve script
+   validity without storing the script on the server.
+
+   The server MUST check the submitted script for syntactic validity,
+   which includes checking that all Sieve extensions mentioned in Sieve
+   script "require" statement(s) are supported by the Sieve interpreter.
+   (Note that if the Sieve interpreter supports the Sieve "ihave"
+   extension [I-HAVE], any unrecognized/unsupported extension mentioned
+   in the "ihave" test MUST NOT cause the syntactic validation failure.)
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 27]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   If the script fails this test the server MUST reply with a NO
+   response.  The message given with a NO response MUST be human
+   readable and SHOULD contain a specific error message giving the line
+   number of the first error.  Implementors should strive to produce
+   helpful error messages similar to those given by programming language
+   compilers.  Client implementations should note that this may be a
+   multiline literal string with more than one error message separated
+   by CRLFs.  The human readable message is in the language returned in
+   the latest LANGUAGE capability (or in "i-default", see Section 1.8),
+   encoded in UTF-8 [UTF-8].
+
+       Examples:
+
+       C: CheckScript {31+}
+       C: #comment
+       C: InvalidSieveCommand
+       C:
+       S: NO "line 2: Syntax error"
+
+   A ManageSieve server supporting this command MUST NOT check if the
+   script will put the current user over its quota limit.
+
+   An OK response MAY contain the WARNINGS response code.  In such case
+   the human readable message that follows the OK response SHOULD
+   contain a specific warning message (or messages) giving the line
+   number(s) in the script that might contain errors not intended by the
+   script writer.  The human readable message is in the language
+   returned in the latest LANGUAGE capability (or in "i-default", see
+   Section 1.8), encoded in UTF-8 [UTF-8] A client seeing such response
+   code SHOULD present the message to the user.
+
+2.13.  NOOP Command
+
+   Arguments:  String - tag to echo back (optional)
+
+   The NOOP command does nothing, beyond returning a response to the
+   client.  It may be used by clients for protocol re-synchronisation or
+   to reset any inactivity auto-logout timer on the server.
+
+   The response to the NOOP command is always OK, followed by the TAG
+   response code together with the supplied string; if no string was
+   supplied in the NOOP command, the TAG response code MUST NOT be
+   included.
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 28]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+       Examples:
+
+       C: NOOP
+       S: OK "NOOP completed"
+
+       C: NOOP "STARTTLS-SYNC-42"
+       S: OK (TAG {16}
+       S: STARTTLS-SYNC-42) "Done"
+
+2.14.  Recommended extensions
+
+   The UNAUTHENTICATE extension (advertised as the "UNAUTHENTICATE"
+   capability with no parameters) defines a new UNAUTHENTICATE command,
+   which allows a client to return the server to non-authenticated
+   state.  Support for this extension is RECOMMENDED.
+
+2.14.1.  UNAUTHENTICATE Command
+
+   The UNAUTHENTICATE command returns the server to the non-
+   authenticated state.  It doesn't affect any previously established
+   TLS [TLS] or SASL (Section 2.1) security layer.
+
+   The UNAUTHENTICATE command is only valid in authenticated state.  If
+   issued in a wrong state, the server MUST reject it with a NO
+   response.
+
+   The UNAUTHENTICATE command has no parameters.
+
+   When issued in the authenticated state, the UNAUTHENTICATE command
+   MUST NOT fail (i.e. it must never return anything other than OK or
+   BYE)
+
+
+3.  Sieve URL Scheme
+
+   URI scheme name: sieve
+
+   Status: permanent
+
+   URI scheme syntax:
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 29]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+         Described using ABNF [ABNF]. Some ABNF productions not defined
+             below are from [URI-GEN].
+
+
+         sieveurl = sieveurl-server / sieveurl-list-scripts /
+                    sieveurl-script
+
+         sieveurl-server = "sieve://" authority
+
+         sieveurl-list-scripts = "sieve://" authority ["/"]
+
+         sieveurl-script = "sieve://" authority "/"
+                           [owner "/"] scriptname
+
+         authority = <defined in [URI-GEN]>
+
+         owner         = *ochar
+                         ;; %-encoded version of [SASL] authorization
+                         ;; identity (script owner) or "userid".
+                         ;;
+                         ;; Empty owner is used to reference
+                         ;; global scripts.
+                         ;;
+                         ;; Note that ASCII characters such as " ", ";",
+                         ;; "&", "=", "/" and "?" must be %-encoded
+                         ;; as per rule specified in [URI-GEN].
+
+         scriptname    = 1*ochar
+                         ;; %-encoded version of UTF-8 representation
+                         ;; of the script name.
+                         ;; Note that ASCII characters such as " ", ";",
+                         ;; "&", "=", "/" and "?" must be %-encoded
+                         ;; as per rule specified in [URI-GEN].
+
+         ochar         = unreserved / pct-encoded / sub-delims-sh /
+                         ":" / "@"
+                         ;; Same as [URI-GEN] 'pchar'
+                         ;; but without ";", "&" and "=".
+
+         unreserved = <defined in [URI-GEN]>
+
+         pct-encoded = <defined in [URI-GEN]>
+
+         sub-delims-sh = "!" / "$" / "'" / "(" / ")" /
+                         "*" / "+" / ","
+                         ;; Same as [URI-GEN] sub-delims,
+                         ;; but without ";", "&" and "=".
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 30]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   URI scheme semantics:
+
+      A Sieve URL identifies a Sieve server or a Sieve script on a Sieve
+      server.  The latter form is associated with the application/sieve
+      MIME type defined in [SIEVE].  There is no MIME type associated
+      with the former form of Sieve URI.
+
+      The server form is used in the REFERRAL response code (see
+      Section 1.4 in order to designate another server where the client
+      should perform its operations.
+
+      The script form allows to retrieve (GETSCRIPT), update
+      (PUTSCRIPT), delete (DELETESCRIPT) or activate (SETACTIVE) the
+      named script, however the most typical action would be to retrieve
+      the script.  If the script name is empty (omitted), the URI
+      requests that the client lists available scripts using the
+      LISTSCRIPTS command.
+
+   Encoding considerations:
+
+      The script name and/or the owner, if present, is in UTF-8.  Non-
+      US-ASCII UTF-8 octets MUST be percent-encoded as described in
+      [URI-GEN].  US-ASCII characters such as " " (space), ";", "&",
+      "=", "/" and "?"  MUST be %-encoded as described in [URI-GEN].
+      Note that "&" and "?" are in this list in order to allow for
+      future extensions.
+
+      Note that the empty owner (e.g. sieve://example.com//script) is
+      different from the missing owner (e.g. sieve://example.com/script)
+      and is reserved for referencing global scripts.
+
+      The user name (in the "authority" part), if present, is in UTF-8.
+      Non-US-ASCII UTF-8 octets MUST be percent-encoded as described in
+      [URI-GEN].
+
+   Applications/protocols that use this URI scheme name:
+   ManageSieve [RFC XXXX] clients and servers.  Clients that can store
+   user preferences in protocols such as [LDAP] or [ACAP].
+
+   Interoperability considerations: None.
+
+   Security considerations:
+   The <scriptname> part of a ManageSieve URL might potentially disclose
+   some confidential information about the author of the script or,
+   depending on a ManageSieve implementation, about configuration of the
+   mail system.  The latter might be used to prepare for a more complex
+   attack on the mail system.
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 31]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   Clients resolving ManageSieve URLs that wish to achieve data
+   confidentiality and/or integrity SHOULD use the STARTTLS command (if
+   supported by the server) before starting authentication, or use a
+   SASL mechanism, such as GSSAPI, that provides a confidentiality
+   security layer.
+
+   Contact: Alexey Melnikov <alexey.melnikov@isode.com>
+
+   Author/Change controller: IESG.
+
+   References: This document and RFC 5228 [SIEVE].
+
+
+4.  Formal Syntax
+
+   The following syntax specification uses the augmented Backus-Naur
+   Form (BNF) notation as specified in [ABNF].  This uses the ABNF core
+   rules as specified in Appendix A of the ABNF specification [ABNF].
+   "UTF8-2", "UTF8-3" and "UTF8-4" non-terminal are defined in [UTF-8].
+
+   Except as noted otherwise, all alphabetic characters are case-
+   insensitive.  The use of upper or lower case characters to define
+   token strings is for editorial clarity only.  Implementations MUST
+   accept these strings in a case-insensitive fashion.
+
+    SAFE-CHAR             = %x01-09 / %x0B-0C / %x0E-21 / %x23-5B /
+                            %x5D-7F
+                            ;; any TEXT-CHAR except QUOTED-SPECIALS
+
+    QUOTED-CHAR           = SAFE-UTF8-CHAR / DQUOTE QUOTED-SPECIALS
+
+    QUOTED-SPECIALS       = DQUOTE / "\"
+
+    SAFE-UTF8-CHAR        = SAFE-CHAR / UTF8-2 / UTF8-3 / UTF8-4
+                            ;; <UTF8-2>, <UTF8-3> and <UTF8-4>
+                            ;; are defined in [UTF-8]
+
+    ATOM-CHAR             = "!" / %x23-27 / %x2A-5B / %x5D-7A / %x7C-7E
+                            ;; Any CHAR except ATOM-SPECIALS
+
+    ATOM-SPECIALS         = "(" / ")" / "{" / SP / CTL /
+                             QUOTED-SPECIALS
+
+    NZDIGIT               = %x31-39
+                            ;; 1-9
+
+    atom                  = 1*1024ATOM-CHAR
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 32]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+    iana-token            = atom
+                            ;; MUST be registered with IANA
+
+    auth-type             = DQUOTE auth-type-name DQUOTE
+
+    auth-type-name        = iana-token
+                            ;; as defined in SASL [SASL]
+
+    command               = (command-any / command-auth /
+                             command-nonauth) CRLF
+                            ;; Modal based on state
+
+    command-any           = command-capability / command-logout /
+                            command-noop
+                            ;; Valid in all states
+
+    command-auth          = command-getscript / command-setactive /
+                            command-listscripts / command-deletescript /
+                            command-putscript / command-checkscript /
+                            command-havespace /
+                            command-renamescript /
+                            command-unauthenticate
+                            ;; Valid only in Authenticated state
+
+    command-nonauth       = command-authenticate / command-starttls
+                            ;; Valid only when in Non-Authenticated
+                            ;; state
+
+    command-authenticate  = "AUTHENTICATE" SP auth-type [SP string]
+                            *(CRLF string)
+
+    command-capability    = "CAPABILITY"
+
+    command-deletescript  = "DELETESCRIPT" SP sieve-name
+
+    command-getscript     = "GETSCRIPT" SP sieve-name
+
+    command-havespace     = "HAVESPACE" SP sieve-name SP number
+
+    command-listscripts   = "LISTSCRIPTS"
+
+    command-noop          = "NOOP" [SP string]
+
+    command-logout        = "LOGOUT"
+
+    command-putscript     = "PUTSCRIPT" SP sieve-name SP sieve-script
+
+    command-checkscript   = "CHECKSCRIPT" SP sieve-script
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 33]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+    sieve-script          = string
+
+    command-renamescript  = "RENAMESCRIPT" SP old-sieve-name SP
+                            new-sieve-name
+
+    old-sieve-name        = sieve-name
+
+    new-sieve-name        = sieve-name
+
+    command-setactive     = "SETACTIVE" SP active-sieve-name
+
+    command-starttls      = "STARTTLS"
+
+    command-unauthenticate= "UNAUTHENTICATE"
+
+    extend-token          = atom
+                            ;; MUST be defined by a standards track or
+                            ;; IESG approved experimental protocol
+                            ;; extension
+
+    extension-data        = extension-item *(SP extension-item)
+
+    extension-item        = extend-token / string / number /
+                            "(" [extension-data] ")"
+
+    literal-c2s           = "{" number "+}" CRLF *OCTET
+                            ;; The number represents the number of
+                            ;; octets.
+                            ;; This type of literal can only be sent
+                            ;; from the client to the server.
+
+    literal-s2c           = "{" number "}" CRLF *OCTET
+                            ;; Almost identical to literal-c2s,
+                            ;; but with no '+' character.
+                            ;; The number represents the number of
+                            ;; octets.
+                            ;; This type of literal can only be sent
+                            ;; from the server to the client.
+
+    number                = (NZDIGIT *DIGIT) / "0"
+                            ;; A 32-bit unsigned number
+                            ;; with no extra leading zeros.
+                            ;; (0 <= n < 4,294,967,296)
+
+    number-str            = string
+                            ;; <number> encoded as a <string>.
+
+    quoted                = DQUOTE *1024QUOTED-CHAR DQUOTE
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 34]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+                            ;; limited to 1024 octets between the <">s
+
+    resp-code             = "AUTH-TOO-WEAK" / "ENCRYPT-NEEDED" /
+                            "QUOTA" ["/" ("MAXSCRIPTS" / "MAXSIZE")] /
+                            resp-code-sasl /
+                            resp-code-referral /
+                            "TRANSITION-NEEDED" / "TRYLATER" /
+                            "ACTIVE" / "NONEXISTENT" /
+                            "ALREADYEXISTS" / "WARNINGS" /
+                            "TAG" SP string /
+                            resp-code-ext
+
+    resp-code-referral    = "REFERRAL" SP sieveurl
+
+    resp-code-sasl        = "SASL" SP string
+
+    resp-code-name        = iana-token
+                            ;; The response code name is hierarchical,
+                            ;; separated by '/'.
+                            ;; The response code name MUST NOT start
+                            ;; with '/'.
+
+    resp-code-ext         = resp-code-name [SP extension-data]
+                            ;; unknown response codes MUST be tolerated
+                            ;; by the client.
+
+    response              = response-authenticate /
+                            response-logout /
+                            response-getscript /
+                            response-setactive /
+                            response-listscripts /
+                            response-deletescript /
+                            response-putscript /
+                            response-checkscript /
+                            response-capability /
+                            response-havespace /
+                            response-starttls /
+                            response-renamescript /
+                            response-noop /
+                            response-unauthenticate
+
+    response-authenticate = *(string CRLF)
+                            ((response-ok [response-capability]) /
+                             response-nobye)
+                            ;; <response-capability> is REQUIRED if a
+                            ;; SASL security layer was negotiated and
+                            ;; MUST be omitted otherwise.
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 35]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+    response-capability   = *(single-capability) response-oknobye
+
+    single-capability     = capability-name [SP string] CRLF
+
+    capability-name       = string
+                            ;; Note that literal-s2c is allowed.
+
+    initial-capabilities  = DQUOTE "IMPLEMENTATION" DQUOTE SP string /
+                            DQUOTE "SASL" DQUOTE SP sasl-mechs /
+                            DQUOTE "SIEVE" DQUOTE SP sieve-extensions /
+                            DQUOTE "MAXREDIRECTS" DQUOTE SP number-str /
+                            DQUOTE "NOTIFY" DQUOTE SP notify-mechs /
+                            DQUOTE "STARTTLS" DQUOTE /
+                            DQUOTE "LANGUAGE" DQUOTE SP language /
+                            DQUOTE "VERSION" DQUOTE SP version /
+                            DQUOTE "OWNER" DQUOTE SP string
+                            ;; Each capability conforms to
+                            ;; the syntax for single-capability.
+                            ;; Also note that the capability name
+                            ;; can be returned as either literal-s2c
+                            ;; or quoted, even though only "quoted"
+                            ;; string is shown above.
+
+    version = ( DQUOTE "1.0" DQUOTE ) / version-ext
+
+    version-ext = DQUOTE ver-major "." ver-minor DQUOTE
+                 ; Future versions specified in updates
+                 ; to this document. An increment to
+                 ; the ver-major means a backward-incompatible
+                 ; change to the protocol, e.g. "3.5" (ver-major "3")
+                 ; is not backward-compatible with any "2.X" version.
+                 ; Any version "Z.W" MUST be backward compatible
+                 ; with any version "Z.Q", where Q < W.
+                 ; E.g. version "2.4" is backward-compatible
+                 ; with version "2.0", "2.1", "2.2" and "2.3".
+
+    ver-major = number
+
+    ver-minor = number
+
+    sasl-mechs = string
+                 ; space separated list of SASL mechanisms,
+                 ; each SASL mechanism name complies with rules
+                 ; specified in [SASL].
+                 ; Can be empty.
+
+    sieve-extensions = string
+                 ; space separated list of supported SIEVE extensions,
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 36]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+                 ; can be empty.
+
+    language     = string
+                 ; Contains <Language-Tag> from [RFC4646].
+
+    notify-mechs = string
+                 ; space separated list of URI schema parts
+                 ; for supported notification [NOTIFY] methods.
+                 ; MUST NOT be empty.
+
+    response-deletescript = response-oknobye
+
+    response-getscript    = (sieve-script CRLF response-ok) /
+                            response-nobye
+
+    response-havespace    = response-oknobye
+
+    response-listscripts  = *(sieve-name [SP "ACTIVE"] CRLF)
+                            response-oknobye
+                            ;; ACTIVE may only occur with one sieve-name
+
+    response-logout       = response-oknobye
+
+    response-unauthenticate= response-oknobye
+                             ;; "NO" response can only be returned when
+                             ;; the command is issued in a wrong state
+                             ;; or has a wrong number of parameters
+
+    response-ok           = "OK" [SP "(" resp-code ")"]
+                            [SP string] CRLF
+                            ;; The string contains human readable text
+                            ;; encoded as UTF-8.
+
+    response-nobye        = ("NO" / "BYE") [SP "(" resp-code ")"]
+                            [SP string] CRLF
+                            ;; The string contains human readable text
+                            ;; encoded as UTF-8.
+
+    response-oknobye      = response-ok / response-nobye
+
+    response-noop         = response-ok
+
+    response-putscript    = response-oknobye
+
+    response-checkscript  = response-oknobye
+
+    response-renamescript = response-oknobye
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 37]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+    response-setactive    = response-oknobye
+
+    response-starttls     = (response-ok response-capability) /
+                            response-nobye
+
+    sieve-name            = string
+                            ;; See Section 1.6 for the full list of
+                            ;; prohibited characters.
+                            ;; Empty string is not allowed.
+
+    active-sieve-name     = string
+                            ;; See Section 1.6 for the full list of
+                            ;; prohibited characters.
+                            ;; This is similar to <sieve-name>, but
+                            ;; empty string is allowed and has a special
+                            ;; meaning.
+
+    string                = quoted / literal-c2s / literal-s2c
+                            ;; literal-c2s is only allowed when sent
+                            ;; from the client to the server.
+                            ;; literal-s2c is only allowed when sent
+                            ;; from the server to the client.
+                            ;; quoted is allowed in either direction.
+
+
+5.  Security Considerations
+
+   The AUTHENTICATE command uses SASL [SASL] to provide authentication
+   and authorization services.  Integrity and privacy services can be
+   provided by [SASL] and/or [TLS].  When a SASL mechanism is used the
+   security considerations for that mechanism apply.
+
+   This protocol's transactions are susceptible to passive observers or
+   man in the middle attacks which alter the data, unless the optional
+   encryption and integrity services of the SASL (via the AUTHENTICATE
+   command) and/or [TLS] (via the STARTTLS command) are enabled, or an
+   external security mechanism is used for protection.  It may be useful
+   to allow configuration of both clients and servers to refuse to
+   transfer sensitive information in the absence of strong encryption.
+
+   If an implementation supports SASL mechanisms that are vulnerable to
+   passive eavesdropping attacks (such as [PLAIN]), then the
+   implementation MUST support at least one configuration where these
+   SASL mechanisms are not advertised or used without the presence of an
+   external security layer such as [TLS].
+
+   Some response codes returned on failed AUTHENTICATE command may
+   disclose whether or not the username is valid (e.g.  TRANSITION-
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 38]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   NEEDED), so server implementations SHOULD provide the ability to
+   disable these features (or make them not conditional on a per-user
+   basis) for sites concerned about such disclosure.  In the case of
+   ENCRYPT-NEEDED, if it is applied to all identities then no extra
+   information is disclosed, but if it is applied on a per-user basis it
+   can disclose information.
+
+   A compromised or malicious server can use the TRANSITION-NEEDED
+   response code to force the client which is configured to use a
+   mechanism that does not disclose the user's password to the server
+   (e.g., Kerberos), to send the bare password to the server.  Clients
+   SHOULD have the ability to disable the password transition feature,
+   or disclose that risk to the user and offer the user an option how to
+   proceed.
+
+
+6.  IANA Considerations
+
+   IANA is requested to reserve a TCP port number for use with the
+   ManageSieve protocol described in this document.
+
+   IANA is requested to register the "sieve" URI scheme defined in
+   Section 3 of this document.
+
+   IANA is requested to register "sieve" in the "GSSAPI/Kerberos/SASL
+   Service Names" registry.
+
+   IANA is requested to create a new registry for ManageSieve
+   capabilities.  The registration template for ManageSieve capabilities
+   is specified in Section 6.1.  ManageSieve protocol capabilities MUST
+   be specified in a standards track or IESG approved experimental RFC.
+
+   IANA is requested to create a new registry for ManageSieve response
+   codes.  The registration template for ManageSieve response codes is
+   specified in Section 6.3.  ManageSieve protocol response codes MUST
+   be specified in a standards track or IESG approved experimental RFC.
+
+6.1.  ManageSieve Capability Registration Template
+
+   To: iana@iana.org
+   Subject: ManageSieve Capability Registration
+
+   Please register the following ManageSieve Capability:
+   Capability name:
+   Description:
+   Relevant publications:
+   Person & email address to contact for further information:
+   Author/Change controller:
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 39]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+6.2.  Registration of Initial ManageSieve capabilities
+
+   To: iana@iana.org
+   Subject: ManageSieve Capability Registration
+
+   Please register the following ManageSieve Capabilities:
+
+      Capability name: IMPLEMENTATION
+
+      Description: Its value contains name of server implementation and
+      its version.
+
+      Relevant publications: this RFC, Section 1.8.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: SASL
+
+      Description: Its value contains a space separated list of SASL
+      mechanisms supported by server.
+
+      Relevant publications: this RFC, Section 1.8 and Section 2.1.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: SIEVE
+
+      Description: Its value contains a space separated list of
+      supported SIEVE extensions
+
+      Relevant publications: this RFC, Section 1.8.  Also [SIEVE].
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: STARTTLS
+
+      Description: This capability is returned if server supports TLS
+      (STARTTLS command).
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 40]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      Relevant publications: this RFC, Section 1.8 and Section 2.2.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: NOTIFY
+
+      Description: This capability is returned if server supports
+      'enotify' [NOTIFY] Sieve extension.
+
+      Relevant publications: this RFC, Section 1.8.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: MAXREDIRECTS
+
+      Description: This capability returns the limit on the number of
+      Sieve "redirect" actions a script can perform during a single
+      evaluation.  The value is a non-negative number represented as a
+      ManageSieve string.
+
+      Relevant publications: this RFC, Section 1.8.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: LANGUAGE
+
+      Description: The language (<Language-Tag> from [RFC4646])
+      currently used for human readable error messages.
+
+      Relevant publications: this RFC, Section 1.8.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: OWNER
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 41]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      Description: Its value contains UTF-8 encoded name of the
+      currently logged in user ("authorization identity" according to
+      RFC 4422).
+
+      Relevant publications: this RFC, Section 1.8.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Capability name: VERSION
+
+      Description: This capability is returned if the server is
+      compliant with RFCXXXX, i.e. that it supports RENAMESCRIPT,
+      CHECKSCRIPT and NOOP commands.
+
+      Relevant publications: this RFC, Section 2.11.
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+6.3.  ManageSieve Response Code Registration Template
+
+   To: iana@iana.org
+   Subject: ManageSieve Response Code Registration
+
+   Please register the following ManageSieve Response Code:
+
+      Response Code:
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified):
+
+      Purpose:
+
+      Published Specification(s):
+
+      Person & email address to contact for further information:
+
+      Author/Change controller:
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 42]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+6.4.  Registration of Initial ManageSieve Response Codes
+
+   To: iana@iana.org
+   Subject: ManageSieve Response Code Registration
+
+   Please register the following ManageSieve Response Codes:
+
+      Response Code: AUTH-TOO-WEAK
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: This response code is returned in the NO response from an
+      AUTHENTICATE command.  It indicates that site security policy
+      forbids the use of the requested mechanism for the specified
+      authentication identity.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: ENCRYPT-NEEDED
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: This response code is returned in the NO response from an
+      AUTHENTICATE command.  It indicates that site security policy
+      requires the use of a strong encryption mechanism for the
+      specified authentication identity and mechanism.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: QUOTA
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: If this response code is returned in the NO/BYE response,
+      it means that the command would have placed the user above the
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 43]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      site-defined quota constraints.  If this response code is returned
+      in the OK response, it can mean that the user is near its quota or
+      that the user exceeded its quota, but the server supports soft
+      quotas.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: QUOTA/MAXSCRIPTS
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: If this response code is returned in the NO/BYE response,
+      it means that the command would have placed the user above the
+      site-defined limit on the number of Sieve scripts.  If this
+      response code is returned in the OK response, it can mean that the
+      user is near its quota or that the user exceeded its quota, but
+      the server supports soft quotas.  This response code is a more
+      specific version of the QUOTA response code.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: QUOTA/MAXSIZE
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: If this response code is returned in the NO/BYE response,
+      it means that the command would have placed the user above the
+      site-defined maximum script size.  If this response code is
+      returned in the OK response, it can mean that the user is near its
+      quota or that the user exceeded its quota, but the server supports
+      soft quotas.  This response code is a more specific version of the
+      QUOTA response code.
+
+      Published Specification(s): [RFCXXXX]
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 44]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: REFERRAL
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): <sieveurl>
+
+      Purpose: This response code may be returned with a BYE result from
+      any command, and includes a mandatory parameter that indicates
+      what server to access to manage this user's sieve scripts.  The
+      server will be specified by a Sieve URL (see Section 3).  The
+      scriptname portion of the URL MUST NOT be specified.  The client
+      should authenticate to the specified server and use it for all
+      further commands in the current session.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: SASL
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): <string>
+
+      Purpose: This response code can occur in the OK response to a
+      successful AUTHENTICATE command and includes the optional final
+      server response data from the server as specified by [SASL].
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: TRANSITION-NEEDED
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: This response code occurs in a NO response of an
+      AUTHENTICATE command.  It indicates that the user name is valid,
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 45]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      but the entry in the authentication database needs to be updated
+      in order to permit authentication with the specified mechanism.
+      This is typically done by establishing a secure channel using TLS,
+      followed by authenticating once using the [PLAIN] authentication
+      mechanism.  The selected mechanism SHOULD then work for
+      authentications in subsequent sessions.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: TRYLATER
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: A command failed due to a temporary server failure.  The
+      client MAY continue using local information and try the command
+      later.  This response code only make sense when returned in a NO/
+      BYE response.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: ACTIVE
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: A command failed because it is not allowed on the active
+      script.  For example DELETESCRIPT on the active script.  This
+      response code only makes sense when returned in a NO/BYE response.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 46]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      Response Code: NONEXISTENT
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: A command failed because the referenced script name
+      doesn't exist.  This response code only makes sense when returned
+      in a NO/BYE response.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: ALREADYEXISTS
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: A command failed because the referenced script name
+      already exists.  This response code only makes sense when returned
+      in a NO/BYE response.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+      Response Code: WARNINGS
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): NONE
+
+      Purpose: This response code MAY be returned by the server in the
+      OK response (but it might be returned with the NO/BYE response as
+      well) and signals the client that even though the script is
+      syntactically valid, it might contain errors not intended by the
+      script writer.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 47]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+      Author/Change controller: IESG.
+
+      Response Code: TAG
+
+      Arguments (use ABNF to specify syntax, or the word NONE if none
+      can be specified): string
+
+      Purpose: This response code name is followed by a string specified
+      in the command that caused this response.  It is typically used
+      for client state synchronization.
+
+      Published Specification(s): [RFCXXXX]
+
+      Person & email address to contact for further information: Alexey
+      Melnikov <alexey.melnikov@isode.com>
+
+      Author/Change controller: IESG.
+
+
+7.  Internationalization Considerations
+
+   The LANGUAGE capability (see Section 1.8) allows a client to discover
+   the current language used in all human readable responses that might
+   be returned at the end of any OK/NO/BYE response.  Human readable
+   text in OK responses typically doesn't need to be shown to the user,
+   unless it is returned in response to PUTSCRIPT or CHECKSCRIPT command
+   that also contain the WARNINGS response code Section 1.4.  Human
+   readable text from NO/BYE responses is intended be shown to the user,
+   unless the client can automatically handle failure of the command
+   that caused such response.  Clients SHOULD use response codes
+   (Section 1.4) for automatic error handling.  Response codes MAY also
+   be used by the client to present error messages in a language
+   understood by the user, for example if the LANGUAGE capability
+   doesn't return a language understood by the user.
+
+   Note that the human readable text from OK (WARNINGS) or NO/BYE
+   responses for PUTSCRIPT/CHECKSCRIPT commands is intended for advanced
+   users that understand Sieve language.  Such advanced users are often
+   sophisticated enough to be able to handle whatever language the
+   server is using, even if it is not their preferred language, and will
+   want to see error/warning text no matter what language the server
+   puts it in.
+
+   A client that generates Sieve script automatically, for example if
+   the script is generated without user intervention or from a UI that
+   presents an abstract list of conditions and corresponding actions,
+   SHOULD NOT present warning/error messages to the user, because the
+   user might not even be aware that the client is using Sieve
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 48]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   underneath.  However if the client has a debugging mode, such
+   warnings/errors SHOULD be available in the debugging mode.
+
+   Note that this document doesn't provide a way to modify the currently
+   used language.  It is expected that a future extension will address
+   that.
+
+
+8.  Acknowledgements
+
+   Thanks to Simon Josefsson, Larry Greenfield, Allen Johnson, Chris
+   Newman, Lyndon Nerenberg, Tim Showalter, Sarah Robeson, Walter Wong,
+   Barry Leiba, Arnt Gulbrandsen, Stephan Bosch, Ken Murchison, Phil
+   Pennock, Ned Freed, Jeffrey Hutzelman, Mark E. Mallett, Dilyan
+   Palauzov, Dave Cridland, Aaron Stone, Robert Burrell Donkin, Patrick
+   Ben Koetter, Bjoern Hoehrmann, Martin Duerst, Pasi Eronen, Magnus
+   Westerlund and Tim Polk for help with this document.  Special thank
+   you to Phil Pennock for providing text for the NOOP command, as well
+   as finding various bugs in the document.
+
+
+9.  References
+
+9.1.  Normative References
+
+   [ABNF]     Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
+              Specifications: ABNF", RFC 5234, January 2008.
+
+   [ACAP]     Newman, C. and J. Myers, "ACAP -- Application
+              Configuration Access Protocol", RFC 2244, November 1997.
+
+   [BASE64]   Josefsson, S., "The Base16, Base32, and Base64 Data
+              Encodings", RFC 4648, October 2006.
+
+   [DNS-SRV]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
+              specifying the location of services (DNS SRV)", RFC 2782,
+              February 2000.
+
+   [KEYWORDS]
+              Bradner, S., "Key words for use in RFCs to Indicate
+              Requirement Levels", RFC 2119, March 1997.
+
+   [NET-UNICODE]
+              Klensin, J. and M. Padlipsky, "Unicode Format for Network
+              Interchange", RFC 5198, March 2008.
+
+   [NOTIFY]   Melnikov, A., Ed., Leiba, B., Ed., Segmuller, W., and T.
+              Martin, "Sieve Extension: Notifications",
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 49]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+              draft-ietf-sieve-notify-12 (work in progress),
+              December 2007.
+
+   [RFC2277]  Alvestrand, H., "IETF Policy on Character Sets and
+              Languages", RFC 2277, January 1998.
+
+   [RFC2460]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
+              (IPv6) Specification", RFC 2460, December 1998.
+
+   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
+              "Internationalizing Domain Names in Applications (IDNA)",
+              RFC 3490, March 2003.
+
+   [RFC4519]  Sciberras, A., "Lightweight Directory Access Protocol
+              (LDAP): Schema for User Applications", RFC 4519,
+              June 2006.
+
+   [RFC4646]  Phillips, A. and M. Davis, "Tags for Identifying
+              Languages", RFC 4646, September 2006.
+
+   [RFC791]   Postel, J., "Internet Protocol", RFC 791, September 1981.
+
+   [SASL]     Melnikov, A. and K. Zeilenga, "Simple Authentication and
+              Security Layer (SASL)", RFC 4422, June 2006.
+
+   [SASLprep]
+              Zeilenga, K., "SASLprep: Stringprep Profile for User Names
+              and Passwords", RFC 4013, February 2005.
+
+   [SCRAM]    Menon-Sen, A., Ed. and C. Newman, "Salted Challenge
+              Response Authentication Mechanism (SCRAM)",
+              draft-newman-auth-scram-07.txt (work in progress),
+              November 2008.
+
+   [SIEVE]    Guenther, P., Ed. and T. Showalter, Ed., "Sieve: An Email
+              Filtering Language", RFC 5228, January 2008.
+
+   [StringPrep]
+              Hoffman, P. and M. Blanchet, "Preparation of
+              Internationalized Strings ("stringprep")", RFC 3454,
+              December 2002.
+
+   [TLS]      Dierks, T. and E. Rescorla, "The Transport Layer Security
+              (TLS) Protocol Version 1.2", RFC 5246, August 2008.
+
+   [URI-GEN]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
+              Resource Identifier (URI): Generic Syntax", STD 66,
+              RFC 3986, January 2005.
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 50]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   [UTF-8]    Yergeau, F., "UTF-8, a transformation format of ISO
+              10646", STD 63, RFC 3629, November 2003.
+
+   [X509]     Housley, R., Polk, W., Ford, W., and D. Solo, "Internet
+              X.509 Public Key Infrastructure Certificate and
+              Certificate Revocation List (CRL) Profile", RFC 5280,
+              May 2008.
+
+   [X509-SRV]
+              Santesson, S., "Internet X.509 Public Key Infrastructure
+              Subject Alternative Name for Expression of Service Name",
+              RFC 4985, August 2007.
+
+9.2.  Informative References
+
+   [DIGEST-MD5]
+              Leach, P. and C. Newman, "Using Digest Authentication as a
+              SASL Mechanism", RFC 2831, May 2000.
+
+   [I-HAVE]   Freed, N., "Sieve Email Filtering: Ihave Extension",
+              draft-freed-sieve-ihave-03.txt (work in progress),
+              October 2008.
+
+   [IMAP]     Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - VERSION
+              4rev1", RFC 3501, March 2003.
+
+   [LDAP]     Zeilenga, K., "Lightweight Directory Access Protocol
+              (LDAP): Technical Specification Road Map", RFC 4510,
+              June 2006.
+
+   [PLAIN]    Zeilenga, K., "The PLAIN Simple Authentication and
+              Security Layer (SASL) Mechanism", RFC 4616, August 2006.
+
+
+Authors' Addresses
+
+   Alexey Melnikov (editor)
+   Isode Limited
+   5 Castle Business Village
+   36 Station Road
+   Hampton, Middlesex  TW12 2BX
+   UK
+
+   Email: Alexey.Melnikov@isode.com
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 51]
+
+Internet-Draft                 ManageSieve                  January 2009
+
+
+   Tim Martin
+   BeThereBeSquare Inc.
+   672 Haight st.
+   San Francisco, CA  94117
+   US
+
+   Phone: +1 510 260-4175
+   Email: timmartin@alumni.cmu.edu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Melnikov & Martin         Expires July 21, 2009                [Page 52]
+
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/dummy-config.h.in dovecot-1.2.4/dovecot-managesieve/dummy-config.h.in
--- dovecot-1.2.4.orig/dovecot-managesieve/dummy-config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/dummy-config.h.in	2009-08-21 01:05:42.000000000 +0200
@@ -0,0 +1,62 @@
+/* dummy-config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to the full name of this Sieve implementation. */
+#undef MANAGESIEVE_NAME
+
+/* Define to the version of this Sieve implementation. */
+#undef MANAGESIEVE_VERSION
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/INSTALL dovecot-1.2.4/dovecot-managesieve/INSTALL
--- dovecot-1.2.4.orig/dovecot-managesieve/INSTALL	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/INSTALL	2009-01-31 22:25:21.000000000 +0100
@@ -0,0 +1,62 @@
+Compile
+-------
+
+Prerequisites:
+
+  * A patched and compiled dovecot-1.2 tree:
+
+    To enable support for the new managesieve service, Dovecot needs to be 
+    patched. The patch is available from the same source as this package. 
+		
+    Package and patch are named as follows:
+
+      Patch: dovecot-1.2.X-managesieve-<managesieve version>.diff.gz
+      Package: dovecot-1.2-managesieve-<managesieve version>.tar.gz
+		
+    Nothing special needs to be done to compile the patched tree. You can use:
+      
+      ./configure
+      make
+      sudo make install
+
+    as usual. 
+		
+    Note that this package will compile against an unpatched dovecot tree, but 
+    keep in mind that dovecot will not know about managesieve without the patch.
+
+  * A compiled dovecot-1.2-sieve tree 
+
+    Currently, no special version dependencies are known to compile against the
+    sieve plugin, but of course the most recent version is recommended. 
+
+    NOTE: dovecot-sieve-1.1 can still be used if you do not want to use the new
+    Sieve implementation.
+
+If you downloaded this package using Mercurial, you have a script called 
+autogen.sh in your source tree. You should execute that first:
+
+./autogen.sh
+
+After this executed successfully or when you downloaded the tarball,
+configure needs to be executed with the following parameters:
+
+  --with-dovecot=<path>
+    Path to the patched and compiled dovecot-1.w source tree
+  --with-dovecot-sieve=<path>	
+    Path to the compiled dovecot-1.2-sieve or dovecot-sieve-1.1 source tree
+
+For example:
+
+./configure --with-dovecot=../dovecot-1.2 \
+  --with-dovecot-sieve=../dovecot-1.2-sieve
+
+As usual, to compile and install, execute the following:
+
+make
+sudo make install 
+
+Configure
+---------
+
+Refer to README file.
+ 
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/install-sh dovecot-1.2.4/dovecot-managesieve/install-sh
--- dovecot-1.2.4.orig/dovecot-managesieve/install-sh	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/install-sh	2008-07-18 12:18:45.000000000 +0200
@@ -0,0 +1,519 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2006-12-25.00
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+
+nl='
+'
+IFS=" ""	$nl"
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=${DOITPROG-}
+if test -z "$doit"; then
+  doit_exec=exec
+else
+  doit_exec=$doit
+fi
+
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
+
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
+
+posix_glob='?'
+initialize_posix_glob='
+  test "$posix_glob" != "?" || {
+    if (set -f) 2>/dev/null; then
+      posix_glob=
+    else
+      posix_glob=:
+    fi
+  }
+'
+
+posix_mkdir=
+
+# Desired mode of installed file.
+mode=0755
+
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
+rmcmd="$rmprog -f"
+stripcmd=
+
+src=
+dst=
+dir_arg=
+dst_arg=
+
+copy_on_change=false
+no_target_directory=
+
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
+
+  -c            (ignored)
+  -C            install only if different (preserve the last data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -s            $stripprog installed files.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
+"
+
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
+
+    -C) copy_on_change=true;;
+
+    -d) dir_arg=true;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+	shift;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) mode=$2
+	case $mode in
+	  *' '* | *'	'* | *'
+'*	  | *'*'* | *'?'* | *'['*)
+	    echo "$0: invalid mode: $mode" >&2
+	    exit 1;;
+	esac
+	shift;;
+
+    -o) chowncmd="$chownprog $2"
+	shift;;
+
+    -s) stripcmd=$stripprog;;
+
+    -t) dst_arg=$2
+	shift;;
+
+    -T) no_target_directory=true;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    --)	shift
+	break;;
+
+    -*)	echo "$0: invalid option: $1" >&2
+	exit 1;;
+
+    *)  break;;
+  esac
+  shift
+done
+
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+  done
+fi
+
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+if test -z "$dir_arg"; then
+  trap '(exit $?); exit' 1 2 13 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+
+    dst=$dst_arg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dst_arg: Is a directory" >&2
+	exit 1
+      fi
+      dstdir=$dst
+      dst=$dstdir/`basename "$src"`
+      dstdir_status=0
+    else
+      # Prefer dirname, but fall back on a substitute if dirname fails.
+      dstdir=`
+	(dirname "$dst") 2>/dev/null ||
+	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	     X"$dst" : 'X\(//\)[^/]' \| \
+	     X"$dst" : 'X\(//\)$' \| \
+	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
+	echo X"$dst" |
+	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)[^/].*/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\).*/{
+		   s//\1/
+		   q
+		 }
+		 s/.*/./; q'
+      `
+
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+	# Create intermediate dirs using mode 755 as modified by the umask.
+	# This is like FreeBSD 'install' as of 1997-10-28.
+	umask=`umask`
+	case $stripcmd.$umask in
+	  # Optimize common cases.
+	  *[2367][2367]) mkdir_umask=$umask;;
+	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;
+
+	  *[0-7])
+	    mkdir_umask=`expr $umask + 22 \
+	      - $umask % 100 % 40 + $umask % 20 \
+	      - $umask % 10 % 4 + $umask % 2
+	    `;;
+	  *) mkdir_umask=$umask,go-w;;
+	esac
+
+	# With -d, create the new directory with the user-specified mode.
+	# Otherwise, rely on $mkdir_umask.
+	if test -n "$dir_arg"; then
+	  mkdir_mode=-m$mode
+	else
+	  mkdir_mode=
+	fi
+
+	posix_mkdir=false
+	case $umask in
+	  *[123567][0-7][0-7])
+	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
+	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
+	    ;;
+	  *)
+	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+
+	    if (umask $mkdir_umask &&
+		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+	    then
+	      if test -z "$dir_arg" || {
+		   # Check for POSIX incompatibilities with -m.
+		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+		   # other-writeable bit of parent directory when it shouldn't.
+		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+		   case $ls_ld_tmpdir in
+		     d????-?r-*) different_mode=700;;
+		     d????-?--*) different_mode=755;;
+		     *) false;;
+		   esac &&
+		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
+		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+		   }
+		 }
+	      then posix_mkdir=:
+	      fi
+	      rmdir "$tmpdir/d" "$tmpdir"
+	    else
+	      # Remove any dirs left behind by ancient mkdir implementations.
+	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+	    fi
+	    trap '' 0;;
+	esac;;
+    esac
+
+    if
+      $posix_mkdir && (
+	umask $mkdir_umask &&
+	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # The umask is ridiculous, or mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+	/*) prefix='/';;
+	-*) prefix='./';;
+	*)  prefix='';;
+      esac
+
+      eval "$initialize_posix_glob"
+
+      oIFS=$IFS
+      IFS=/
+      $posix_glob set -f
+      set fnord $dstdir
+      shift
+      $posix_glob set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+	test -z "$d" && continue
+
+	prefix=$prefix$d
+	if test -d "$prefix"; then
+	  prefixes=
+	else
+	  if $posix_mkdir; then
+	    (umask=$mkdir_umask &&
+	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+	    # Don't fail if two instances are running concurrently.
+	    test -d "$prefix" || exit 1
+	  else
+	    case $prefix in
+	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+	      *) qprefix=$prefix;;
+	    esac
+	    prefixes="$prefixes '$qprefix'"
+	  fi
+	fi
+	prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+	# Don't fail if two instances are running concurrently.
+	(umask $mkdir_umask &&
+	 eval "\$doit_exec \$mkdirprog $prefixes") ||
+	  test -d "$dstdir" || exit 1
+	obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
+
+       eval "$initialize_posix_glob" &&
+       $posix_glob set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       $posix_glob set +f &&
+
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+	# Now remove or move aside any old file at destination location.
+	# We try this two ways since rm can't unlink itself on some
+	# systems and the destination file might be busy for other
+	# reasons.  In this case, the final cleanup might fail but the new
+	# file should still install successfully.
+	{
+	  test ! -f "$dst" ||
+	  $doit $rmcmd -f "$dst" 2>/dev/null ||
+	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
+	  } ||
+	  { echo "$0: cannot unlink or rename $dst" >&2
+	    (exit 1); exit 1
+	  }
+	} &&
+
+	# Now rename the file to the real destination.
+	$doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/ltmain.sh dovecot-1.2.4/dovecot-managesieve/ltmain.sh
--- dovecot-1.2.4.orig/dovecot-managesieve/ltmain.sh	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/ltmain.sh	2009-06-18 23:12:06.000000000 +0200
@@ -0,0 +1,8413 @@
+# Generated from ltmain.m4sh.
+
+# ltmain.sh (GNU libtool) 2.2.6
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#     --config             show all configuration variables
+#     --debug              enable verbose shell tracing
+# -n, --dry-run            display commands without modifying any files
+#     --features           display basic configuration information and exit
+#     --mode=MODE          use operation mode MODE
+#     --preserve-dup-deps  don't remove duplicate dependency libraries
+#     --quiet, --silent    don't print informational messages
+#     --tag=TAG            use configuration variables from tag TAG
+# -v, --verbose            print informational messages (default)
+#     --version            print version information
+# -h, --help               print short or long help message
+#
+# MODE must be one of the following:
+#
+#       clean              remove files from the build directory
+#       compile            compile a source file into a libtool object
+#       execute            automatically set library path, then run a program
+#       finish             complete the installation of libtool libraries
+#       install            install libraries or executables
+#       link               create a library or an executable
+#       uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#       host-triplet:	$host
+#       shell:		$SHELL
+#       compiler:		$LTCC
+#       compiler flags:		$LTCFLAGS
+#       linker:		$LD (gnu? $with_gnu_ld)
+#       $progname:		(GNU libtool) 2.2.6 Debian-2.2.6a-4
+#       automake:		$automake_version
+#       autoconf:		$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+
+PROGRAM=ltmain.sh
+PACKAGE=libtool
+VERSION="2.2.6 Debian-2.2.6a-4"
+TIMESTAMP=""
+package_revision=1.3012
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# NLS nuisances: We save the old values to restore during execute mode.
+# Only set LANG and LC_ALL to C if already set.
+# These must not be set unconditionally because not all systems understand
+# e.g. LANG=C (notably SCO).
+lt_user_locale=
+lt_safe_locale=
+for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
+	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+	fi"
+done
+
+$lt_unset CDPATH
+
+
+
+
+
+: ${CP="cp -f"}
+: ${ECHO="echo"}
+: ${EGREP="/bin/grep -E"}
+: ${FGREP="/bin/grep -F"}
+: ${GREP="/bin/grep"}
+: ${LN_S="ln -s"}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SED="/bin/sed"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
+}
+
+# Generated shell functions inserted here.
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+# The name of this program:
+# In the unlikely event $progname began with a '-', it would play havoc with
+# func_echo (imagine progname=-n), so we prepend ./ in that case:
+func_dirname_and_basename "$progpath"
+progname=$func_basename_result
+case $progname in
+  -*) progname=./$progname ;;
+esac
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=$func_dirname_result
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=:
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+opt_warning=:
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname${mode+: }$mode: $*"
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname${mode+: }$mode: "${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $opt_warning && $ECHO "$progname${mode+: }$mode: warning: "${1+"$@"} 1>&2
+
+    # bash bug again:
+    :
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "X$my_directory_path" | $Xsed -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "X$my_dir_list" | $Xsed -e 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "X$my_tmpdir" | $Xsed
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "X$1" | $Xsed -e "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "X$1" | $Xsed \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+# func_show_eval_locale cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$lt_user_locale
+	    $my_cmd"
+      my_status=$?
+      eval "$lt_safe_locale"
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $SED -n '/^# Usage:/,/# -h/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    $ECHO
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help
+# Echo long help message to standard output and exit.
+func_help ()
+{
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(automake --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(autoconf --version) 2>/dev/null |$SED 1q`"'/
+	p
+     }' < "$progpath"
+    exit $?
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    func_error "missing argument for $1"
+    exit_cmd=exit
+}
+
+exit_cmd=:
+
+
+
+
+
+# Check that we have a working $ECHO.
+if test "X$1" = X--no-reexec; then
+  # Discard the --no-reexec flag, and continue.
+  shift
+elif test "X$1" = X--fallback-echo; then
+  # Avoid inline document here, it may be left over
+  :
+elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t'; then
+  # Yippee, $ECHO works!
+  :
+else
+  # Restart under the correct shell, and then maybe $ECHO will work.
+  exec $SHELL "$progpath" --no-reexec ${1+"$@"}
+fi
+
+if test "X$1" = X--fallback-echo; then
+  # used as fallback echo
+  shift
+  cat <<EOF
+$*
+EOF
+  exit $EXIT_SUCCESS
+fi
+
+magic="%%%MAGIC variable%%%"
+magic_exe="%%%MAGIC EXE variable%%%"
+
+# Global variables.
+# $mode is unset
+nonopt=
+execute_dlfiles=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+opt_dry_run=false
+opt_duplicate_deps=false
+opt_silent=false
+opt_debug=:
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    $ECHO "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      $ECHO "enable shared libraries"
+    else
+      $ECHO "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      $ECHO "enable static libraries"
+    else
+      $ECHO "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+# Parse options once, thoroughly.  This comes as soon as possible in
+# the script to make things like `libtool --version' happen quickly.
+{
+
+  # Shorthand for --mode=foo, only valid as the first argument
+  case $1 in
+  clean|clea|cle|cl)
+    shift; set dummy --mode clean ${1+"$@"}; shift
+    ;;
+  compile|compil|compi|comp|com|co|c)
+    shift; set dummy --mode compile ${1+"$@"}; shift
+    ;;
+  execute|execut|execu|exec|exe|ex|e)
+    shift; set dummy --mode execute ${1+"$@"}; shift
+    ;;
+  finish|finis|fini|fin|fi|f)
+    shift; set dummy --mode finish ${1+"$@"}; shift
+    ;;
+  install|instal|insta|inst|ins|in|i)
+    shift; set dummy --mode install ${1+"$@"}; shift
+    ;;
+  link|lin|li|l)
+    shift; set dummy --mode link ${1+"$@"}; shift
+    ;;
+  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+    shift; set dummy --mode uninstall ${1+"$@"}; shift
+    ;;
+  esac
+
+  # Parse non-mode specific arguments:
+  while test "$#" -gt 0; do
+    opt="$1"
+    shift
+
+    case $opt in
+      --config)		func_config					;;
+
+      --debug)		preserve_args="$preserve_args $opt"
+			func_echo "enabling shell trace mode"
+			opt_debug='set -x'
+			$opt_debug
+			;;
+
+      -dlopen)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			execute_dlfiles="$execute_dlfiles $1"
+			shift
+			;;
+
+      --dry-run | -n)	opt_dry_run=:					;;
+      --features)       func_features					;;
+      --finish)		mode="finish"					;;
+
+      --mode)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			case $1 in
+			  # Valid mode arguments:
+			  clean)	;;
+			  compile)	;;
+			  execute)	;;
+			  finish)	;;
+			  install)	;;
+			  link)		;;
+			  relink)	;;
+			  uninstall)	;;
+
+			  # Catch anything else as an error
+			  *) func_error "invalid argument for $opt"
+			     exit_cmd=exit
+			     break
+			     ;;
+		        esac
+
+			mode="$1"
+			shift
+			;;
+
+      --preserve-dup-deps)
+			opt_duplicate_deps=:				;;
+
+      --quiet|--silent)	preserve_args="$preserve_args $opt"
+			opt_silent=:
+			;;
+
+      --verbose| -v)	preserve_args="$preserve_args $opt"
+			opt_silent=false
+			;;
+
+      --tag)		test "$#" -eq 0 && func_missing_arg "$opt" && break
+			preserve_args="$preserve_args $opt $1"
+			func_enable_tag "$1"	# tagname is set here
+			shift
+			;;
+
+      # Separate optargs to long options:
+      -dlopen=*|--mode=*|--tag=*)
+			func_opt_split "$opt"
+			set dummy "$func_opt_split_opt" "$func_opt_split_arg" ${1+"$@"}
+			shift
+			;;
+
+      -\?|-h)		func_usage					;;
+      --help)		opt_help=:					;;
+      --version)	func_version					;;
+
+      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
+
+      *)		nonopt="$opt"
+			break
+			;;
+    esac
+  done
+
+
+  case $host in
+    *cygwin* | *mingw* | *pw32* | *cegcc*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps
+      ;;
+  esac
+
+  # Having warned about all mis-specified options, bail out if
+  # anything was wrong.
+  $exit_cmd $EXIT_FAILURE
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+$opt_help || {
+  # Sanity checks first:
+  func_check_version_match
+
+  if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+    func_fatal_configuration "not configured to build any kind of library"
+  fi
+
+  test -z "$mode" && func_fatal_error "error: you must specify a MODE."
+
+
+  # Darwin sucks
+  eval std_shrext=\"$shrext_cmds\"
+
+
+  # Only execute mode is allowed to have -dlopen flags.
+  if test -n "$execute_dlfiles" && test "$mode" != execute; then
+    func_error "unrecognized option \`-dlopen'"
+    $ECHO "$help" 1>&2
+    exit $EXIT_FAILURE
+  fi
+
+  # Change the help message to a mode-specific one.
+  generic_help="$help"
+  help="Try \`$progname --help --mode=$mode' for more information."
+}
+
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    test -f "$1" &&
+      $SED -e 4q "$1" 2>/dev/null \
+        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 0<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_script_p file
+# True iff FILE is a libtool wrapper script
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_script_p ()
+{
+    func_lalib_p "$1"
+}
+
+# func_ltwrapper_executable_p file
+# True iff FILE is a libtool wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_executable_p ()
+{
+    func_ltwrapper_exec_suffix=
+    case $1 in
+    *.exe) ;;
+    *) func_ltwrapper_exec_suffix=.exe ;;
+    esac
+    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
+}
+
+# func_ltwrapper_scriptname file
+# Assumes file is an ltwrapper_executable
+# uses $file to determine the appropriate filename for a
+# temporary ltwrapper_script.
+func_ltwrapper_scriptname ()
+{
+    func_ltwrapper_scriptname_result=""
+    if func_ltwrapper_executable_p "$1"; then
+	func_dirname_and_basename "$1" "" "."
+	func_stripname '' '.exe' "$func_basename_result"
+	func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+    fi
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script or wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+        func_quote_for_eval "$arg"
+	CC_quoted="$CC_quoted $func_quote_for_eval_result"
+      done
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_quote_for_eval "$arg"
+	      CC_quoted="$CC_quoted $func_quote_for_eval_result"
+	    done
+	    case "$@ " in
+	      " $CC "* | "$CC "* | " `$ECHO $CC` "* | "`$ECHO $CC` "* | " $CC_quoted"* | "$CC_quoted "* | " `$ECHO $CC_quoted` "* | "`$ECHO $CC_quoted` "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      $MV "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          pie_flag="$pie_flag $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  later="$later $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_quote_for_eval "$arg"
+	    lastarg="$lastarg $func_quote_for_eval_result"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  base_compile="$base_compile $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_quote_for_eval "$lastarg"
+      base_compile="$base_compile $func_quote_for_eval_result"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    case $libobj in
+    *.[cCFSifmso] | \
+    *.ada | *.adb | *.ads | *.asm | \
+    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
+    *.[fF][09]? | *.for | *.java | *.obj | *.sx)
+      func_xform "$libobj"
+      libobj=$func_xform_result
+      ;;
+    esac
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_dirname_and_basename "$obj" "/" ""
+    objname="$func_basename_result"
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2* | cegcc*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "X$srcfile" | $Xsed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      removelist="$removelist $output_obj"
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    removelist="$removelist $lockfile"
+    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
+
+    if test -n "$fix_srcfile_path"; then
+      eval srcfile=\"$fix_srcfile_path\"
+    fi
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	command="$command -o $lobj"
+      fi
+
+      func_show_eval_locale "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	command="$command -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      command="$command$suppress_output"
+      func_show_eval_locale "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+	removelist=$lockfile
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+$opt_help || {
+test "$mode" = compile && func_mode_compile ${1+"$@"}
+}
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to building PIC objects only
+  -prefer-non-pic   try to building non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$mode'"
+        ;;
+    esac
+
+    $ECHO
+    $ECHO "Try \`$progname --help' for more information about other modes."
+
+    exit $?
+}
+
+  # Now that we've collected a possible --mode arg, show help if necessary
+  $opt_help && func_mode_help
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $execute_dlfiles; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  dir="$dir/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -*) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_script_p "$file"; then
+	  func_source "$file"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	elif func_ltwrapper_executable_p "$file"; then
+	  func_ltwrapper_scriptname "$file"
+	  func_source "$func_ltwrapper_scriptname_result"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_quote_for_eval "$file"
+      args="$args $func_quote_for_eval_result"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	$ECHO "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libdirs="$nonopt"
+    admincmds=
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for dir
+      do
+	libdirs="$libdirs $dir"
+      done
+
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || admincmds="$admincmds
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    $ECHO "Libraries have been installed in:"
+    for libdir in $libdirs; do
+      $ECHO "   $libdir"
+    done
+    $ECHO
+    $ECHO "If you ever happen to want to link against installed libraries"
+    $ECHO "in a given directory, LIBDIR, you must either use libtool, and"
+    $ECHO "specify the full pathname of the library, or use the \`-LLIBDIR'"
+    $ECHO "flag during linking and do at least one of the following:"
+    if test -n "$shlibpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+      $ECHO "     during execution"
+    fi
+    if test -n "$runpath_var"; then
+      $ECHO "   - add LIBDIR to the \`$runpath_var' environment variable"
+      $ECHO "     during linking"
+    fi
+    if test -n "$hardcode_libdir_flag_spec"; then
+      libdir=LIBDIR
+      eval flag=\"$hardcode_libdir_flag_spec\"
+
+      $ECHO "   - use the \`$flag' linker flag"
+    fi
+    if test -n "$admincmds"; then
+      $ECHO "   - have your system administrator run these commands:$admincmds"
+    fi
+    if test -f /etc/ld.so.conf; then
+      $ECHO "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+    fi
+    $ECHO
+
+    $ECHO "See any operating system documentation about shared libraries for"
+    case $host in
+      solaris2.[6789]|solaris2.1[0-9])
+        $ECHO "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	$ECHO "pages."
+	;;
+      *)
+        $ECHO "more information, such as the ld(1) and ld.so(8) manual pages."
+        ;;
+    esac
+    $ECHO "X----------------------------------------------------------------------" | $Xsed
+    exit $EXIT_SUCCESS
+}
+
+test "$mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       $ECHO "X$nonopt" | $GREP shtool >/dev/null; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    install_prog="$install_prog$func_quote_for_eval_result"
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    for arg
+    do
+      if test -n "$dest"; then
+	files="$files $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+	case " $install_prog " in
+	*[\\\ /]cp\ *) ;;
+	*) prev=$arg ;;
+	esac
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      install_prog="$install_prog $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname_and_basename "$dest" "" "."
+      destdir="$func_dirname_result"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	staticlibs="$staticlibs $file"
+	;;
+
+      *.la)
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) current_libdirs="$current_libdirs $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) future_libdirs="$future_libdirs $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	dir="$dir$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "X$destdir" | $Xsed -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "X$relink_command" | $Xsed -e "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32* | cegcc*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && staticlibs="$staticlibs $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin* | *mingw*)
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      wrapper=$func_ltwrapper_scriptname_result
+	    else
+	      func_stripname '' '.exe' "$file"
+	      wrapper=$func_stripname_result
+	    fi
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_script_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "X$lib" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "X$relink_command" | $Xsed -e 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "X$file$stripped_ext" | $Xsed -e "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_verbose "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_verbose "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "X$objs$old_deplibs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_verbose "extracting global C symbols from \`$progfile'"
+	    $opt_dry_run || eval "$NM $progfile | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* | *cegcc* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin | *mingw* | *cegcc* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+	  $opt_dry_run || {
+	    eval '$ECHO ": $name " >> "$nlist"'
+	    eval "$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	  }
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    $ECHO '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+"
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc* )
+	    $ECHO >> "$output_objdir/$my_dlsyms" "\
+/* DATA imports from DLLs on WIN32 con't be const, because
+   runtime relocations are performed -- see ld's documentation
+   on pseudo-relocs.  */"
+	    lt_dlsym_const= ;;
+	  *osf5*)
+	    echo >> "$output_objdir/$my_dlsyms" "\
+/* This system does not cope well with relocations in const data */"
+	    lt_dlsym_const= ;;
+	  *)
+	    lt_dlsym_const=const ;;
+	  esac
+
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+extern $lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+$lt_dlsym_const lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  case $need_lib_prefix in
+	  no)
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  *)
+	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  esac
+	  $ECHO >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) symtab_cflags="$symtab_cflags $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* | *cegcc* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "X$compile_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "X$compile_command" | $Xsed -e "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "X$finalize_command" | $Xsed -e "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then
+      win32_nmres=`eval $NM -f posix -A $1 |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" 'exit $?'
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  func_arith $extracted_serial + 1
+	  extracted_serial=$func_arith_result
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_verbose "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename "$darwin_archive"`
+	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`
+	      $LIPO -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+
+# func_emit_wrapper_part1 [arg=no]
+#
+# Emit the first part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part1 ()
+{
+	func_emit_wrapper_part1_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part1_arg1=$1
+	fi
+
+	$ECHO "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='${SED} -e 1s/^X//'
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    ECHO=\"$qecho\"
+    file=\"\$0\"
+    # Make sure echo works.
+    if test \"X\$1\" = X--no-reexec; then
+      # Discard the --no-reexec flag, and continue.
+      shift
+    elif test \"X\`{ \$ECHO '\t'; } 2>/dev/null\`\" = 'X\t'; then
+      # Yippee, \$ECHO works!
+      :
+    else
+      # Restart under the correct shell, and then maybe \$ECHO will work.
+      exec $SHELL \"\$0\" --no-reexec \${1+\"\$@\"}
+    fi
+  fi\
+"
+	$ECHO "\
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | ${SED} -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"X\$file\" | \$Xsed -e 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"X\$file\" | \$Xsed -e 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | ${SED} -n 's/.*-> //p'\`
+  done
+"
+}
+# end: func_emit_wrapper_part1
+
+# func_emit_wrapper_part2 [arg=no]
+#
+# Emit the second part of a libtool wrapper script on stdout.
+# For more information, see the description associated with
+# func_emit_wrapper(), below.
+func_emit_wrapper_part2 ()
+{
+	func_emit_wrapper_part2_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_part2_arg1=$1
+	fi
+
+	$ECHO "\
+
+  # Usually 'no', except on cygwin/mingw when embedded into
+  # the cwrapper.
+  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1
+  if test \"\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\" = \"yes\"; then
+    # special case for '.'
+    if test \"\$thisdir\" = \".\"; then
+      thisdir=\`pwd\`
+    fi
+    # remove .libs from thisdir
+    case \"\$thisdir\" in
+    *[\\\\/]$objdir ) thisdir=\`\$ECHO \"X\$thisdir\" | \$Xsed -e 's%[\\\\/][^\\\\/]*$%%'\` ;;
+    $objdir )   thisdir=. ;;
+    esac
+  fi
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"X\$$shlibpath_var\" | \$Xsed -e 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	# fixup the dll searchpath if we need to.
+	if test -n "$dllsearchpath"; then
+	  $ECHO "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	$ECHO "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+"
+	case $host in
+	# Backslashes separate directories on plain windows
+	*-*-mingw | *-*-os2* | *-cegcc*)
+	  $ECHO "\
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+	  ;;
+
+	*)
+	  $ECHO "\
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+	  ;;
+	esac
+	$ECHO "\
+      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
+      exit 1
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    $ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+}
+# end: func_emit_wrapper_part2
+
+
+# func_emit_wrapper [arg=no]
+#
+# Emit a libtool wrapper script on stdout.
+# Don't directly open a file because we may want to
+# incorporate the script contents within a cygwin/mingw
+# wrapper executable.  Must ONLY be called from within
+# func_mode_link because it depends on a number of variables
+# set therein.
+#
+# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
+# variable will take.  If 'yes', then the emitted script
+# will assume that the directory in which it is stored is
+# the $objdir directory.  This is a cygwin/mingw-specific
+# behavior.
+func_emit_wrapper ()
+{
+	func_emit_wrapper_arg1=no
+	if test -n "$1" ; then
+	  func_emit_wrapper_arg1=$1
+	fi
+
+	# split this up so that func_emit_cwrapperexe_src
+	# can call each part independently.
+	func_emit_wrapper_part1 "${func_emit_wrapper_arg1}"
+	func_emit_wrapper_part2 "${func_emit_wrapper_arg1}"
+}
+
+
+# func_to_host_path arg
+#
+# Convert paths to host format when used with build tools.
+# Intended for use with "native" mingw (where libtool itself
+# is running under the msys shell), or in the following cross-
+# build environments:
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+# where wine is equipped with the `winepath' executable.
+# In the native mingw case, the (msys) shell automatically
+# converts paths for any non-msys applications it launches,
+# but that facility isn't available from inside the cwrapper.
+# Similar accommodations are necessary for $host mingw and
+# $build cygwin.  Calling this function does no harm for other
+# $host/$build combinations not listed above.
+#
+# ARG is the path (on $build) that should be converted to
+# the proper representation for $host. The result is stored
+# in $func_to_host_path_result.
+func_to_host_path ()
+{
+  func_to_host_path_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        case $build in
+          *mingw* ) # actually, msys
+            # awkward: cmd appends spaces to result
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_path_tmp1=`( cmd //c echo "$1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_path_tmp1=`cygpath -w "$1"`
+            func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # Unfortunately, winepath does not exit with a non-zero
+            # error code, so we are forced to check the contents of
+            # stdout. On the other hand, if the command is not
+            # found, the shell will set an exit code of 127 and print
+            # *an error message* to stdout. So we must check for both
+            # error code of zero AND non-empty stdout, which explains
+            # the odd construction:
+            func_to_host_path_tmp1=`winepath -w "$1" 2>/dev/null`
+            if test "$?" -eq 0 && test -n "${func_to_host_path_tmp1}"; then
+              func_to_host_path_result=`echo "$func_to_host_path_tmp1" |\
+                $SED -e "$lt_sed_naive_backslashify"`
+            else
+              # Allow warning below.
+              func_to_host_path_result=""
+            fi
+            ;;
+        esac
+        if test -z "$func_to_host_path_result" ; then
+          func_error "Could not determine host path corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback:
+          func_to_host_path_result="$1"
+        fi
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_path
+
+# func_to_host_pathlist arg
+#
+# Convert pathlists to host format when used with build tools.
+# See func_to_host_path(), above. This function supports the
+# following $build/$host combinations (but does no harm for
+# combinations not listed here):
+#    $build          $host
+#    mingw (msys)    mingw  [e.g. native]
+#    cygwin          mingw
+#    *nix + wine     mingw
+#
+# Path separators are also converted from $build format to
+# $host format. If ARG begins or ends with a path separator
+# character, it is preserved (but converted to $host format)
+# on output.
+#
+# ARG is a pathlist (on $build) that should be converted to
+# the proper representation on $host. The result is stored
+# in $func_to_host_pathlist_result.
+func_to_host_pathlist ()
+{
+  func_to_host_pathlist_result="$1"
+  if test -n "$1" ; then
+    case $host in
+      *mingw* )
+        lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+        # Remove leading and trailing path separator characters from
+        # ARG. msys behavior is inconsistent here, cygpath turns them
+        # into '.;' and ';.', and winepath ignores them completely.
+        func_to_host_pathlist_tmp2="$1"
+        # Once set for this call, this variable should not be
+        # reassigned. It is used in tha fallback case.
+        func_to_host_pathlist_tmp1=`echo "$func_to_host_pathlist_tmp2" |\
+          $SED -e 's|^:*||' -e 's|:*$||'`
+        case $build in
+          *mingw* ) # Actually, msys.
+            # Awkward: cmd appends spaces to result.
+            lt_sed_strip_trailing_spaces="s/[ ]*\$//"
+            func_to_host_pathlist_tmp2=`( cmd //c echo "$func_to_host_pathlist_tmp1" |\
+              $SED -e "$lt_sed_strip_trailing_spaces" ) 2>/dev/null || echo ""`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          *cygwin* )
+            func_to_host_pathlist_tmp2=`cygpath -w -p "$func_to_host_pathlist_tmp1"`
+            func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp2" |\
+              $SED -e "$lt_sed_naive_backslashify"`
+            ;;
+          * )
+            # unfortunately, winepath doesn't convert pathlists
+            func_to_host_pathlist_result=""
+            func_to_host_pathlist_oldIFS=$IFS
+            IFS=:
+            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do
+              IFS=$func_to_host_pathlist_oldIFS
+              if test -n "$func_to_host_pathlist_f" ; then
+                func_to_host_path "$func_to_host_pathlist_f"
+                if test -n "$func_to_host_path_result" ; then
+                  if test -z "$func_to_host_pathlist_result" ; then
+                    func_to_host_pathlist_result="$func_to_host_path_result"
+                  else
+                    func_to_host_pathlist_result="$func_to_host_pathlist_result;$func_to_host_path_result"
+                  fi
+                fi
+              fi
+              IFS=:
+            done
+            IFS=$func_to_host_pathlist_oldIFS
+            ;;
+        esac
+        if test -z "$func_to_host_pathlist_result" ; then
+          func_error "Could not determine the host path(s) corresponding to"
+          func_error "  '$1'"
+          func_error "Continuing, but uninstalled executables may not work."
+          # Fallback. This may break if $1 contains DOS-style drive
+          # specifications. The fix is not to complicate the expression
+          # below, but for the user to provide a working wine installation
+          # with winepath so that path translation in the cross-to-mingw
+          # case works properly.
+          lt_replace_pathsep_nix_to_dos="s|:|;|g"
+          func_to_host_pathlist_result=`echo "$func_to_host_pathlist_tmp1" |\
+            $SED -e "$lt_replace_pathsep_nix_to_dos"`
+        fi
+        # Now, add the leading and trailing path separators back
+        case "$1" in
+          :* ) func_to_host_pathlist_result=";$func_to_host_pathlist_result"
+            ;;
+        esac
+        case "$1" in
+          *: ) func_to_host_pathlist_result="$func_to_host_pathlist_result;"
+            ;;
+        esac
+        ;;
+    esac
+  fi
+}
+# end: func_to_host_pathlist
+
+# func_emit_cwrapperexe_src
+# emit the source code for a wrapper executable on stdout
+# Must ONLY be called from within func_mode_link because
+# it depends on a number of variable set therein.
+func_emit_cwrapperexe_src ()
+{
+	cat <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+
+   Currently, it simply execs the wrapper *script* "$SHELL $output",
+   but could eventually absorb all of the scripts functionality and
+   exec $objdir/$outputname directly.
+*/
+EOF
+	    cat <<"EOF"
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef _MSC_VER
+# include <direct.h>
+# include <process.h>
+# include <io.h>
+# define setmode _setmode
+#else
+# include <unistd.h>
+# include <stdint.h>
+# ifdef __CYGWIN__
+#  include <io.h>
+#  define HAVE_SETENV
+#  ifdef __STRICT_ANSI__
+char *realpath (const char *, char *);
+int putenv (char *);
+int setenv (const char *, const char *, int);
+#  endif
+# endif
+#endif
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef S_IXOTH
+# define S_IXOTH 0
+#endif
+#ifndef S_IXGRP
+# define S_IXGRP 0
+#endif
+
+#ifdef _MSC_VER
+# define S_IXUSR _S_IEXEC
+# define stat _stat
+# ifndef _INTPTR_T_DEFINED
+#  define intptr_t int
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# define FOPEN_WB "wb"
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#ifdef __CYGWIN__
+# define FOPEN_WB "wb"
+#endif
+
+#ifndef FOPEN_WB
+# define FOPEN_WB "w"
+#endif
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+#undef LTWRAPPER_DEBUGPRINTF
+#if defined DEBUGWRAPPER
+# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args
+static void
+ltwrapper_debugprintf (const char *fmt, ...)
+{
+    va_list args;
+    va_start (args, fmt);
+    (void) vfprintf (stderr, fmt, args);
+    va_end (args);
+}
+#else
+# define LTWRAPPER_DEBUGPRINTF(args)
+#endif
+
+const char *program_name = NULL;
+
+void *xmalloc (size_t num);
+char *xstrdup (const char *string);
+const char *base_name (const char *name);
+char *find_executable (const char *wrapper);
+char *chase_symlinks (const char *pathspec);
+int make_executable (const char *path);
+int check_executable (const char *path);
+char *strendzap (char *str, const char *pat);
+void lt_fatal (const char *message, ...);
+void lt_setenv (const char *name, const char *value);
+char *lt_extend_str (const char *orig_value, const char *add, int to_end);
+void lt_opt_process_env_set (const char *arg);
+void lt_opt_process_env_prepend (const char *arg);
+void lt_opt_process_env_append (const char *arg);
+int lt_split_name_value (const char *arg, char** name, char** value);
+void lt_update_exe_path (const char *name, const char *value);
+void lt_update_lib_path (const char *name, const char *value);
+
+static const char *script_text_part1 =
+EOF
+
+	    func_emit_wrapper_part1 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+	    cat <<EOF
+
+static const char *script_text_part2 =
+EOF
+	    func_emit_wrapper_part2 yes |
+	        $SED -e 's/\([\\"]\)/\\\1/g' \
+	             -e 's/^/  "/' -e 's/$/\\n"/'
+	    echo ";"
+
+	    cat <<EOF
+const char * MAGIC_EXE = "$magic_exe";
+const char * LIB_PATH_VARNAME = "$shlibpath_var";
+EOF
+
+	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+              func_to_host_pathlist "$temp_rpath"
+	      cat <<EOF
+const char * LIB_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * LIB_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test -n "$dllsearchpath"; then
+              func_to_host_pathlist "$dllsearchpath:"
+	      cat <<EOF
+const char * EXE_PATH_VARNAME = "PATH";
+const char * EXE_PATH_VALUE   = "$func_to_host_pathlist_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * EXE_PATH_VARNAME = "";
+const char * EXE_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test "$fast_install" = yes; then
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
+EOF
+	    else
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
+EOF
+	    fi
+
+
+	    cat <<"EOF"
+
+#define LTWRAPPER_OPTION_PREFIX         "--lt-"
+#define LTWRAPPER_OPTION_PREFIX_LENGTH  5
+
+static const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;
+static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
+
+static const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX "dump-script";
+
+static const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;
+static const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX "env-set";
+  /* argument is putenv-style "foo=bar", value of foo is set to bar */
+
+static const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;
+static const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX "env-prepend";
+  /* argument is putenv-style "foo=bar", new value of foo is bar${foo} */
+
+static const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;
+static const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX "env-append";
+  /* argument is putenv-style "foo=bar", new value of foo is ${foo}bar */
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int  newargc;
+  char *tmp_pathspec;
+  char *actual_cwrapper_path;
+  char *actual_cwrapper_name;
+  char *target_name;
+  char *lt_argv_zero;
+  intptr_t rval = 127;
+
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) argv[0]      : %s\n", argv[0]));
+  LTWRAPPER_DEBUGPRINTF (("(main) program_name : %s\n", program_name));
+
+  /* very simple arg parsing; don't want to rely on getopt */
+  for (i = 1; i < argc; i++)
+    {
+      if (strcmp (argv[i], dumpscript_opt) == 0)
+	{
+EOF
+	    case "$host" in
+	      *mingw* | *cygwin* )
+		# make stdout use "unix" line endings
+		echo "          setmode(1,_O_BINARY);"
+		;;
+	      esac
+
+	    cat <<"EOF"
+	  printf ("%s", script_text_part1);
+	  printf ("%s", script_text_part2);
+	  return 0;
+	}
+    }
+
+  newargz = XMALLOC (char *, argc + 1);
+  tmp_pathspec = find_executable (argv[0]);
+  if (tmp_pathspec == NULL)
+    lt_fatal ("Couldn't find %s", argv[0]);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (before symlink chase) at : %s\n",
+			  tmp_pathspec));
+
+  actual_cwrapper_path = chase_symlinks (tmp_pathspec);
+  LTWRAPPER_DEBUGPRINTF (("(main) found exe (after symlink chase) at : %s\n",
+			  actual_cwrapper_path));
+  XFREE (tmp_pathspec);
+
+  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));
+  strendzap (actual_cwrapper_path, actual_cwrapper_name);
+
+  /* wrapper name transforms */
+  strendzap (actual_cwrapper_name, ".exe");
+  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
+  XFREE (actual_cwrapper_name);
+  actual_cwrapper_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  /* target_name transforms -- use actual target program name; might have lt- prefix */
+  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
+  strendzap (target_name, ".exe");
+  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
+  XFREE (target_name);
+  target_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  LTWRAPPER_DEBUGPRINTF (("(main) libtool target name: %s\n",
+			  target_name));
+EOF
+
+	    cat <<EOF
+  newargz[0] =
+    XMALLOC (char, (strlen (actual_cwrapper_path) +
+		    strlen ("$objdir") + 1 + strlen (actual_cwrapper_name) + 1));
+  strcpy (newargz[0], actual_cwrapper_path);
+  strcat (newargz[0], "$objdir");
+  strcat (newargz[0], "/");
+EOF
+
+	    cat <<"EOF"
+  /* stop here, and copy so we don't have to do this twice */
+  tmp_pathspec = xstrdup (newargz[0]);
+
+  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
+  strcat (newargz[0], actual_cwrapper_name);
+
+  /* DO want the lt- prefix here if it exists, so use target_name */
+  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
+  XFREE (tmp_pathspec);
+  tmp_pathspec = NULL;
+EOF
+
+	    case $host_os in
+	      mingw*)
+	    cat <<"EOF"
+  {
+    char* p;
+    while ((p = strchr (newargz[0], '\\')) != NULL)
+      {
+	*p = '/';
+      }
+    while ((p = strchr (lt_argv_zero, '\\')) != NULL)
+      {
+	*p = '/';
+      }
+  }
+EOF
+	    ;;
+	    esac
+
+	    cat <<"EOF"
+  XFREE (target_name);
+  XFREE (actual_cwrapper_path);
+  XFREE (actual_cwrapper_name);
+
+  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
+  lt_setenv ("DUALCASE", "1");  /* for MSK sh */
+  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);
+  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
+
+  newargc=0;
+  for (i = 1; i < argc; i++)
+    {
+      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)
+        {
+          if (argv[i][env_set_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_set_opt_len + 1;
+              lt_opt_process_env_set (p);
+            }
+          else if (argv[i][env_set_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_set (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_set_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)
+        {
+          if (argv[i][env_prepend_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_prepend_opt_len + 1;
+              lt_opt_process_env_prepend (p);
+            }
+          else if (argv[i][env_prepend_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_prepend (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_prepend_opt);
+          continue;
+        }
+      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)
+        {
+          if (argv[i][env_append_opt_len] == '=')
+            {
+              const char *p = argv[i] + env_append_opt_len + 1;
+              lt_opt_process_env_append (p);
+            }
+          else if (argv[i][env_append_opt_len] == '\0' && i + 1 < argc)
+            {
+              lt_opt_process_env_append (argv[++i]); /* don't copy */
+            }
+          else
+            lt_fatal ("%s missing required argument", env_append_opt);
+          continue;
+        }
+      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)
+        {
+          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
+             namespace, but it is not one of the ones we know about and
+             have already dealt with, above (inluding dump-script), then
+             report an error. Otherwise, targets might begin to believe
+             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX
+             namespace. The first time any user complains about this, we'll
+             need to make LTWRAPPER_OPTION_PREFIX a configure-time option
+             or a configure.ac-settable value.
+           */
+          lt_fatal ("Unrecognized option in %s namespace: '%s'",
+                    ltwrapper_option_prefix, argv[i]);
+        }
+      /* otherwise ... */
+      newargz[++newargc] = xstrdup (argv[i]);
+    }
+  newargz[++newargc] = NULL;
+
+  LTWRAPPER_DEBUGPRINTF     (("(main) lt_argv_zero : %s\n", (lt_argv_zero ? lt_argv_zero : "<NULL>")));
+  for (i = 0; i < newargc; i++)
+    {
+      LTWRAPPER_DEBUGPRINTF (("(main) newargz[%d]   : %s\n", i, (newargz[i] ? newargz[i] : "<NULL>")));
+    }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+  /* execv doesn't actually work on mingw as expected on unix */
+  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  if (rval == -1)
+    {
+      /* failed to start process */
+      LTWRAPPER_DEBUGPRINTF (("(main) failed to launch target \"%s\": errno = %d\n", lt_argv_zero, errno));
+      return 127;
+    }
+  return rval;
+EOF
+		;;
+	      *)
+		cat <<"EOF"
+  execv (lt_argv_zero, newargz);
+  return rval; /* =127, but avoids unused variable warning */
+EOF
+		;;
+	    esac
+
+	    cat <<"EOF"
+}
+
+void *
+xmalloc (size_t num)
+{
+  void *p = (void *) malloc (num);
+  if (!p)
+    lt_fatal ("Memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
+			  string) : NULL;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char) name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable (const char *path)
+{
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(check_executable)  : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0)
+      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
+    return 1;
+  else
+    return 0;
+}
+
+int
+make_executable (const char *path)
+{
+  int rval = 0;
+  struct stat st;
+
+  LTWRAPPER_DEBUGPRINTF (("(make_executable)   : %s\n",
+			  path ? (*path ? path : "EMPTY!") : "NULL!"));
+  if ((!path) || (!*path))
+    return 0;
+
+  if (stat (path, &st) >= 0)
+    {
+      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);
+    }
+  return rval;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise
+   Does not chase symlinks, even on platforms that support them.
+*/
+char *
+find_executable (const char *wrapper)
+{
+  int has_slash = 0;
+  const char *p;
+  const char *p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char *concat_name;
+
+  LTWRAPPER_DEBUGPRINTF (("(find_executable)   : %s\n",
+			  wrapper ? (*wrapper ? wrapper : "EMPTY!") : "NULL!"));
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable (concat_name))
+	return concat_name;
+      XFREE (concat_name);
+    }
+  else
+    {
+#endif
+      if (IS_DIR_SEPARATOR (wrapper[0]))
+	{
+	  concat_name = xstrdup (wrapper);
+	  if (check_executable (concat_name))
+	    return concat_name;
+	  XFREE (concat_name);
+	}
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+    }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+      {
+	has_slash = 1;
+	break;
+      }
+  if (!has_slash)
+    {
+      /* no slashes; search PATH */
+      const char *path = getenv ("PATH");
+      if (path != NULL)
+	{
+	  for (p = path; *p; p = p_next)
+	    {
+	      const char *q;
+	      size_t p_len;
+	      for (q = p; *q; q++)
+		if (IS_PATH_SEPARATOR (*q))
+		  break;
+	      p_len = q - p;
+	      p_next = (*q == '\0' ? q : q + 1);
+	      if (p_len == 0)
+		{
+		  /* empty path: current directory */
+		  if (getcwd (tmp, LT_PATHMAX) == NULL)
+		    lt_fatal ("getcwd failed");
+		  tmp_len = strlen (tmp);
+		  concat_name =
+		    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, tmp, tmp_len);
+		  concat_name[tmp_len] = '/';
+		  strcpy (concat_name + tmp_len + 1, wrapper);
+		}
+	      else
+		{
+		  concat_name =
+		    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, p, p_len);
+		  concat_name[p_len] = '/';
+		  strcpy (concat_name + p_len + 1, wrapper);
+		}
+	      if (check_executable (concat_name))
+		return concat_name;
+	      XFREE (concat_name);
+	    }
+	}
+      /* not found in PATH; assume curdir */
+    }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal ("getcwd failed");
+  tmp_len = strlen (tmp);
+  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable (concat_name))
+    return concat_name;
+  XFREE (concat_name);
+  return NULL;
+}
+
+char *
+chase_symlinks (const char *pathspec)
+{
+#ifndef S_ISLNK
+  return xstrdup (pathspec);
+#else
+  char buf[LT_PATHMAX];
+  struct stat s;
+  char *tmp_pathspec = xstrdup (pathspec);
+  char *p;
+  int has_symlinks = 0;
+  while (strlen (tmp_pathspec) && !has_symlinks)
+    {
+      LTWRAPPER_DEBUGPRINTF (("checking path component for symlinks: %s\n",
+			      tmp_pathspec));
+      if (lstat (tmp_pathspec, &s) == 0)
+	{
+	  if (S_ISLNK (s.st_mode) != 0)
+	    {
+	      has_symlinks = 1;
+	      break;
+	    }
+
+	  /* search backwards for last DIR_SEPARATOR */
+	  p = tmp_pathspec + strlen (tmp_pathspec) - 1;
+	  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    p--;
+	  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    {
+	      /* no more DIR_SEPARATORS left */
+	      break;
+	    }
+	  *p = '\0';
+	}
+      else
+	{
+	  char *errstr = strerror (errno);
+	  lt_fatal ("Error accessing file %s (%s)", tmp_pathspec, errstr);
+	}
+    }
+  XFREE (tmp_pathspec);
+
+  if (!has_symlinks)
+    {
+      return xstrdup (pathspec);
+    }
+
+  tmp_pathspec = realpath (pathspec, buf);
+  if (tmp_pathspec == 0)
+    {
+      lt_fatal ("Could not follow symlinks for %s", pathspec);
+    }
+  return xstrdup (tmp_pathspec);
+#endif
+}
+
+char *
+strendzap (char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert (str != NULL);
+  assert (pat != NULL);
+
+  len = strlen (str);
+  patlen = strlen (pat);
+
+  if (patlen <= len)
+    {
+      str += len - patlen;
+      if (strcmp (str, pat) == 0)
+	*str = '\0';
+    }
+  return str;
+}
+
+static void
+lt_error_core (int exit_status, const char *mode,
+	       const char *message, va_list ap)
+{
+  fprintf (stderr, "%s: %s: ", program_name, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, "FATAL", message, ap);
+  va_end (ap);
+}
+
+void
+lt_setenv (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_setenv) setting '%s' to '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+  {
+#ifdef HAVE_SETENV
+    /* always make a copy, for consistency with !HAVE_SETENV */
+    char *str = xstrdup (value);
+    setenv (name, str, 1);
+#else
+    int len = strlen (name) + 1 + strlen (value) + 1;
+    char *str = XMALLOC (char, len);
+    sprintf (str, "%s=%s", name, value);
+    if (putenv (str) != EXIT_SUCCESS)
+      {
+        XFREE (str);
+      }
+#endif
+  }
+}
+
+char *
+lt_extend_str (const char *orig_value, const char *add, int to_end)
+{
+  char *new_value;
+  if (orig_value && *orig_value)
+    {
+      int orig_value_len = strlen (orig_value);
+      int add_len = strlen (add);
+      new_value = XMALLOC (char, add_len + orig_value_len + 1);
+      if (to_end)
+        {
+          strcpy (new_value, orig_value);
+          strcpy (new_value + orig_value_len, add);
+        }
+      else
+        {
+          strcpy (new_value, add);
+          strcpy (new_value + add_len, orig_value);
+        }
+    }
+  else
+    {
+      new_value = xstrdup (add);
+    }
+  return new_value;
+}
+
+int
+lt_split_name_value (const char *arg, char** name, char** value)
+{
+  const char *p;
+  int len;
+  if (!arg || !*arg)
+    return 1;
+
+  p = strchr (arg, (int)'=');
+
+  if (!p)
+    return 1;
+
+  *value = xstrdup (++p);
+
+  len = strlen (arg) - strlen (*value);
+  *name = XMALLOC (char, len);
+  strncpy (*name, arg, len-1);
+  (*name)[len - 1] = '\0';
+
+  return 0;
+}
+
+void
+lt_opt_process_env_set (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_set_opt, arg);
+    }
+
+  lt_setenv (name, value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_prepend (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_prepend_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 0);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_opt_process_env_append (const char *arg)
+{
+  char *name = NULL;
+  char *value = NULL;
+  char *new_value = NULL;
+
+  if (lt_split_name_value (arg, &name, &value) != 0)
+    {
+      XFREE (name);
+      XFREE (value);
+      lt_fatal ("bad argument for %s: '%s'", env_append_opt, arg);
+    }
+
+  new_value = lt_extend_str (getenv (name), value, 1);
+  lt_setenv (name, new_value);
+  XFREE (new_value);
+  XFREE (name);
+  XFREE (value);
+}
+
+void
+lt_update_exe_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      /* some systems can't cope with a ':'-terminated path #' */
+      int len = strlen (new_value);
+      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+        {
+          new_value[len-1] = '\0';
+        }
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+void
+lt_update_lib_path (const char *name, const char *value)
+{
+  LTWRAPPER_DEBUGPRINTF (("(lt_update_lib_path) modifying '%s' by prepending '%s'\n",
+                          (name ? name : "<NULL>"),
+                          (value ? value : "<NULL>")));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+
+EOF
+}
+# end: func_emit_cwrapperexe_src
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      dlfiles="$dlfiles $arg"
+	    else
+	      dlprefiles="$dlprefiles $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) deplibs="$deplibs $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      moreargs="$moreargs $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      dlfiles="$dlfiles $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    dlprefiles="$dlprefiles $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) rpath="$rpath $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) xrpath="$xrpath $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  weak_libs="$weak_libs $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  compiler_flags="$compiler_flags $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  linker_flags="$linker_flags $qarg"
+	  compiler_flags="$compiler_flags $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  # See comment for -static flag below, for more details.
+	  func_append compile_command " $link_static_flag"
+	  func_append finalize_command " $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname '-L' '' "$arg"
+	dir=$func_stripname_result
+	if test -z "$dir"; then
+	  if test "$#" -gt 0; then
+	    func_fatal_error "require no space between \`-L' and \`$1'"
+	  else
+	    func_fatal_error "need path for \`-L' option"
+	  fi
+	fi
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "*) ;;
+	*)
+	  deplibs="$deplibs -L$dir"
+	  lib_search_path="$lib_search_path $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`$ECHO "X$dir" | $Xsed -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  ::) dllsearchpath=$dir;;
+	  *) dllsearchpath="$dllsearchpath:$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	deplibs="$deplibs $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	compiler_flags="$compiler_flags $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) new_inherited_linker_flags="$new_inherited_linker_flags $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # and Darwin in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) xrpath="$xrpath $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  arg="$arg $wl$func_quote_for_eval_result"
+	  compiler_flags="$compiler_flags $wl$func_quote_for_eval_result"
+	  linker_flags="$linker_flags $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -msg_* for osf cc
+      -msg_*)
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler
+      # -r[0-9][0-9]* specifies the processor on the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler
+      # +DA*, +DD* enable 64-bit mode on the HP compiler
+      # -q* pass through compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* pass through architecture-specific
+      # compiler args for GCC
+      # -F/path gives path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC
+      # @file GCC response files
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        compiler_flags="$compiler_flags $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	objs="$objs $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		dlfiles="$dlfiles $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      dlprefiles="$dlprefiles $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	deplibs="$deplibs $arg"
+	old_deplibs="$old_deplibs $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  dlfiles="$dlfiles $arg"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  dlprefiles="$dlprefiles $arg"
+	  prev=
+	else
+	  deplibs="$deplibs $arg"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"X\${$shlibpath_var}\" \| \$Xsed -e \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_duplicate_deps ; then
+	case "$libs " in
+	*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	esac
+      fi
+      libs="$libs $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) specialdeplibs="$specialdeplibs $pre_post_deps" ;;
+	  esac
+	  pre_post_deps="$pre_post_deps $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  case $lib in
+	  *.la)	func_source "$lib" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+            deplib_base=`$ECHO "X$deplib" | $Xsed -e "$basename"`
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) deplibs="$deplibs $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    compiler_flags="$compiler_flags $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  if test "$linkmode" = lib; then
+	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
+	  else
+	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
+	  fi
+	  for searchdir in $searchdirs; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) new_inherited_linker_flags="$new_inherited_linker_flags $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    newlib_search_path="$newlib_search_path $func_stripname_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    dir=$func_stripname_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) xrpath="$xrpath $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la) lib="$deplib" ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"X$deplib\"" 2>/dev/null | $Xsed -e 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		$ECHO
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because the file extensions .$libext of this argument makes me believe"
+		$ECHO "*** that it is just a static archive that I should not use here."
+	      else
+		$ECHO
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      newdlprefiles="$newdlprefiles $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      newdlfiles="$newdlfiles $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "X$inherited_linker_flags" | $Xsed -e 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) new_inherited_linker_flags="$new_inherited_linker_flags $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO "X $dependency_libs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && dlfiles="$dlfiles $dlopen"
+	  test -n "$dlpreopen" && dlprefiles="$dlprefiles $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    convenience="$convenience $ladir/$objdir/$old_library"
+	    old_convenience="$old_convenience $ladir/$objdir/$old_library"
+	    tmp_libs=
+	    for deplib in $dependency_libs; do
+	      deplibs="$deplib $deplibs"
+	      if $opt_duplicate_deps ; then
+		case "$tmp_libs " in
+		*" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+		esac
+	      fi
+	      tmp_libs="$tmp_libs $deplib"
+	    done
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	for l in $old_library $library_names; do
+	  linklib="$l"
+	done
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    dlprefiles="$dlprefiles $lib $dependency_libs"
+	  else
+	    newdlfiles="$newdlfiles $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$libdir"
+	    absdir="$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    notinst_path="$notinst_path $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  # Prefer using a static library (so that no silly _DYNAMIC symbols
+	  # are required to link).
+	  if test -n "$old_library"; then
+	    newdlprefiles="$newdlprefiles $dir/$old_library"
+	    # Keep a list of preopened convenience libraries to check
+	    # that they are being used correctly in the link pass.
+	    test -z "$libdir" && \
+		dlpreconveniencelibs="$dlpreconveniencelibs $dir/$old_library"
+	  # Otherwise, use the dlname, so that lt_dlopen finds it.
+	  elif test -n "$dlname"; then
+	    newdlprefiles="$newdlprefiles $dir/$dlname"
+	  else
+	    newdlprefiles="$newdlprefiles $dir/$linklib"
+	  fi
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  newlib_search_path="$newlib_search_path $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         newlib_search_path="$newlib_search_path $func_stripname_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) temp_rpath="$temp_rpath$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc*)
+	      # No point in relinking DLLs because paths are not encoded
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      notinst_deplibs="$notinst_deplibs $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    $ECHO
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) compile_rpath="$compile_rpath $absdir"
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) finalize_rpath="$finalize_rpath $libdir"
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw* | *cegcc*)
+	        func_arith $current - $age
+		major=$func_arith_result
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_verbose "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  $ECHO
+			  $ECHO "*** And there doesn't seem to be a static archive available"
+			  $ECHO "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$dir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) compile_shlibpath="$compile_shlibpath$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) finalize_shlibpath="$finalize_shlibpath$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    add_dir="$add_dir -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    $ECHO
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    $ECHO "*** I have the capability to make that library automatically link in when"
+	    $ECHO "*** you link to this library.  But I can only do this if you have a"
+	    $ECHO "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      $ECHO "*** But as you try to build a module library, libtool will still create "
+	      $ECHO "*** a static module, that should work as long as the dlopening application"
+	      $ECHO "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		$ECHO
+		$ECHO "*** However, this would only work if libtool was able to extract symbol"
+		$ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		$ECHO "*** not find such a program.  So, this module is probably useless."
+		$ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) xrpath="$xrpath $temp_xrpath";;
+		   esac;;
+	      *) temp_deplibs="$temp_deplibs $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  newlib_search_path="$newlib_search_path $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    if $opt_duplicate_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) specialdeplibs="$specialdeplibs $deplib" ;;
+	      esac
+	    fi
+	    tmp_libs="$tmp_libs $deplib"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      path=
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_dirname "$deplib" "" "."
+		dir="$func_dirname_result"
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                      fi
+		      compiler_flags="$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      linker_flags="$linker_flags -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      if test "$pass" = link; then
+	if test "$linkmode" = "prog"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags "`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	fi
+      fi
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) lib_search_path="$lib_search_path $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) tmp_libs="$tmp_libs $deplib" ;;
+	      esac
+	      ;;
+	    *) tmp_libs="$tmp_libs $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  tmp_libs="$tmp_libs $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      objs="$objs$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  $ECHO
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  libobjs="$libobjs $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  darwin|linux|osf|windows|none)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_minor"
+	    lt_irix_increment=no
+	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  func_arith $current + 1
+	  minor_current=$func_arith_result
+	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  if test "X$lt_irix_increment" = "Xno"; then
+	    func_arith $current - $age
+	  else
+	    func_arith $current - $age + 1
+	  fi
+	  major=$func_arith_result
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    func_arith $revision - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    func_arith $current - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  verstring="$verstring:${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  func_arith $current - $age
+	  major=$func_arith_result
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      libobjs="$libobjs $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext | *.gcno)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       removelist="$removelist $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	oldlibs="$oldlibs $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}'$/d' -e "$lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "X$lib_search_path " | $Xsed -e "s% $path % %g"`
+      #	deplibs=`$ECHO "X$deplibs " | $Xsed -e "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "X$dependency_libs " | $Xsed -e "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  temp_xrpath="$temp_xrpath -R$libdir"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) dlfiles="$dlfiles $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) dlprefiles="$dlprefiles $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    deplibs="$deplibs System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      deplibs="$deplibs -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    newdeplibs="$newdeplibs $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    newdeplibs="$newdeplibs $i"
+		  else
+		    droppeddeps=yes
+		    $ECHO
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    $ECHO "*** I have the capability to make that library automatically link in when"
+		    $ECHO "*** you link to this library.  But I can only do this if you have a"
+		    $ECHO "*** shared version of the library, which I believe you do not have"
+		    $ECHO "*** because a test_compile did reveal that the linker did not use it for"
+		    $ECHO "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      newdeplibs="$newdeplibs $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      newdeplibs="$newdeplibs $i"
+		    else
+		      droppeddeps=yes
+		      $ECHO
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      $ECHO "*** I have the capability to make that library automatically link in when"
+		      $ECHO "*** you link to this library.  But I can only do this if you have a"
+		      $ECHO "*** shared version of the library, which you do not appear to have"
+		      $ECHO "*** because a test_compile did reveal that the linker did not use this one"
+		      $ECHO "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  $ECHO
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  $ECHO "*** make it link in!  You will probably need to install it or some"
+		  $ECHO "*** library that it depends on before this library will be fully"
+		  $ECHO "*** functional.  Installing it before continuing would be even better."
+		fi
+		;;
+	      *)
+		newdeplibs="$newdeplibs $i"
+		;;
+	      esac
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "X$potlib" | $Xsed -e 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			newdeplibs="$newdeplibs $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  newdeplibs="$newdeplibs $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"X$potent_lib\"" 2>/dev/null | $Xsed -e 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      newdeplibs="$newdeplibs $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		$ECHO
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		$ECHO "*** I have the capability to make that library automatically link in when"
+		$ECHO "*** you link to this library.  But I can only do this if you have a"
+		$ECHO "*** shared version of the library, which you do not appear to have"
+		$ECHO "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      newdeplibs="$newdeplibs $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO "X $deplibs" | $Xsed \
+	      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO "X $tmp_deplibs" | $Xsed -e "s,$i,,"`
+	    done
+	  fi
+	  if $ECHO "X $tmp_deplibs" | $Xsed -e 's/[	 ]//g' |
+	     $GREP . >/dev/null; then
+	    $ECHO
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      $ECHO "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      $ECHO "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    $ECHO "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	  fi
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    $ECHO
+	    $ECHO "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    $ECHO "*** a static module, that should work as long as the dlopening"
+	    $ECHO "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      $ECHO
+	      $ECHO "*** However, this would only work if libtool was able to extract symbol"
+	      $ECHO "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      $ECHO "*** not find such a program.  So, this module is probably useless."
+	      $ECHO "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    $ECHO "*** The inter-library dependencies that have been dropped here will be"
+	    $ECHO "*** automatically added whenever a program is linked with this library"
+	    $ECHO "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      $ECHO
+	      $ECHO "*** Since this library must not contain undefined symbols,"
+	      $ECHO "*** because either the platform does not support them or"
+	      $ECHO "*** it was explicitly requested with -no-undefined,"
+	      $ECHO "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO "X $newdeplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO "X $new_inherited_linker_flags" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO "X $deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		dep_rpath="$dep_rpath $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) perm_rpath="$perm_rpath $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    if test -n "$hardcode_libdir_flag_spec_ld"; then
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec_ld\"
+	    else
+	      eval dep_rpath=\"$hardcode_libdir_flag_spec\"
+	    fi
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      rpath="$rpath$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  linknames="$linknames $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "X$libobjs" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  delfiles="$delfiles $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw* | cegcc*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $cmds; do
+	      IFS="$save_ifs"
+	      eval cmd=\"$cmd\"
+	      func_len " $cmd"
+	      len=$func_len_result
+	      if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_verbose "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    tmp_deplibs="$tmp_deplibs $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    generated="$generated $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    libobjs="$libobjs $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  linker_flags="$linker_flags $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   func_len " $test_cmds" &&
+	   len=$func_len_result &&
+	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  output_la=`$ECHO "X$output" | $Xsed -e "$basename"`
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_verbose "creating GNU ld script: $output"
+	    $ECHO 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    $ECHO ')' >> $output
+	    delfiles="$delfiles $output"
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_verbose "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      $ECHO "$obj" >> $output
+	    done
+	    delfiles="$delfiles $output"
+	    output=$firstobj\"$file_list_spec$output\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_verbose "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      eval test_cmds=\"$reload_cmds\"
+	      func_len " $test_cmds"
+	      len0=$func_len_result
+	      len=$len0
+
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		func_len " $obj"
+		func_arith $len + $func_len_result
+		len=$func_arith_result
+		if test "X$objlist" = X ||
+		   test "$len" -lt "$max_cmd_len"; then
+		  func_append objlist " $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    eval concat_cmds=\"$reload_cmds $objlist $last_robj\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds $objlist $last_robj~\$RM $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  func_arith $k + 1
+		  k=$func_arith_result
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=$obj
+		  func_len " $last_robj"
+		  func_arith $len0 + $func_len_result
+		  len=$func_arith_result
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds $objlist $last_robj\"
+	      if test -n "$last_robj"; then
+	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	      fi
+	      delfiles="$delfiles $output"
+
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_verbose "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	      if test -n "$last_robj"; then
+		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
+	      fi
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_verbose "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "X$include_expsyms" | $Xsed | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      delfiles="$delfiles $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  libobjs="$libobjs $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "X$tmp_whole_archive_flags" | $Xsed -e 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "X$libobjs" | $SP2NL | $Xsed -e '/\.'${libext}$'/d' -e '/\.lib$/d' -e "$lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      compile_command="$compile_command ${wl}-bind_at_load"
+	      finalize_command="$finalize_command ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO "X $compile_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO "X $finalize_deplibs" | $Xsed -e 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    new_libs="$new_libs -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) new_libs="$new_libs $deplib" ;;
+	  esac
+	  ;;
+	*) new_libs="$new_libs $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      compile_command="$compile_command $compile_deplibs"
+      finalize_command="$finalize_command $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_rpath="$finalize_rpath $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) perm_rpath="$perm_rpath $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  ::) dllsearchpath=$libdir;;
+	  *) dllsearchpath="$dllsearchpath:$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) dllsearchpath="$dllsearchpath:$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		hardcode_libdirs="$hardcode_libdirs$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    rpath="$rpath $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) finalize_perm_rpath="$finalize_perm_rpath $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "X$compile_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "X$finalize_command" | $SP2NL | $Xsed -e "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *cegcc)
+        # Disable wrappers for cegcc, we are cross compiling anyway.
+        wrappers_required=no
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "X$compile_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    rpath="$rpath$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "X$compile_var$compile_command$compile_rpath" | $Xsed -e 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "X$link_command" | $Xsed -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      # Now create the wrapper script.
+      func_verbose "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Quote $ECHO for shipping.
+      if test "X$ECHO" = "X$SHELL $progpath --fallback-echo"; then
+	case $progpath in
+	[\\/]* | [A-Za-z]:[\\/]*) qecho="$SHELL $progpath --fallback-echo";;
+	*) qecho="$SHELL `pwd`/$progpath --fallback-echo";;
+	esac
+	qecho=`$ECHO "X$qecho" | $Xsed -e "$sed_quote_subst"`
+      else
+	qecho=`$ECHO "X$ECHO" | $Xsed -e "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    func_dirname_and_basename "$output" "" "."
+	    output_name=$func_basename_result
+	    output_path=$func_dirname_result
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_cwrapperexe_src > $cwrappersource
+
+	    # The wrapper executable is built using the $host compiler,
+	    # because it contains $host paths and files. If cross-
+	    # compiling, it, like the target executable, must be
+	    # executed on the $host or under an emulation environment.
+	    $opt_dry_run || {
+	      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource
+	      $STRIP $cwrapper
+	    }
+
+	    # Now, create the wrapper script for func_source use:
+	    func_ltwrapper_scriptname $cwrapper
+	    $RM $func_ltwrapper_scriptname_result
+	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
+	    $opt_dry_run || {
+	      # note: this script will not be executed, so do not chmod.
+	      if test "x$build" = "x$host" ; then
+		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
+	      else
+		func_emit_wrapper no > $func_ltwrapper_scriptname_result
+	      fi
+	    }
+	  ;;
+	  * )
+	    $RM $output
+	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_wrapper no > $output
+	    chmod +x $output
+	  ;;
+	esac
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    oldobjs="$oldobjs $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	generated="$generated $gentop"
+
+	func_extract_archives $gentop $addlibs
+	oldobjs="$oldobjs $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  oldobjs="$oldobjs $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  $ECHO "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  generated="$generated $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		func_arith $counter + 1
+		counter=$func_arith_result
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      oldobjs="$oldobjs $gentop/$newobj"
+	      ;;
+	    *) oldobjs="$oldobjs $obj" ;;
+	    esac
+	  done
+	fi
+	eval cmds=\"$old_archive_cmds\"
+
+	func_len " $cmds"
+	len=$func_len_result
+	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_verbose "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  eval test_cmds=\"$old_archive_cmds\"
+	  func_len " $test_cmds"
+	  len0=$func_len_result
+	  len=$len0
+	  for obj in $save_oldobjs
+	  do
+	    func_len " $obj"
+	    func_arith $len + $func_len_result
+	    len=$func_arith_result
+	    func_append objlist " $obj"
+	    if test "$len" -lt "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	      len=$len0
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_verbose "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "X$relink_command" | $Xsed -e "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		newdependency_libs="$newdependency_libs $libdir/$name"
+		;;
+	      *) newdependency_libs="$newdependency_libs $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlfiles="$newdlfiles $libdir/$name"
+		;;
+	      *) newdlfiles="$newdlfiles $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		newdlprefiles="$newdlprefiles $libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlfiles="$newdlfiles $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      newdlprefiles="$newdlprefiles $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$mode" = link || test "$mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) RM="$RM $arg"; rmforce=yes ;;
+      -*) RM="$RM $arg" ;;
+      *) files="$files $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    origobjdir="$objdir"
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	objdir="$origobjdir"
+      else
+	objdir="$dir/$origobjdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$mode" = uninstall && objdir="$dir"
+
+      # Remember objdir for removal later, being careful to avoid duplicates
+      if test "$mode" = clean; then
+	case " $rmdirs " in
+	  *" $objdir "*) ;;
+	  *) rmdirs="$rmdirs $objdir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    rmfiles="$rmfiles $objdir/$n"
+	  done
+	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
+
+	  case "$mode" in
+	  clean)
+	    case "  $library_names " in
+	    # "  " in the beginning catches empty $dlname
+	    *" $dlname "*) ;;
+	    *) rmfiles="$rmfiles $objdir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    rmfiles="$rmfiles $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    rmfiles="$rmfiles $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      relink_command=
+	      func_source $func_ltwrapper_scriptname_result
+	      rmfiles="$rmfiles $func_ltwrapper_scriptname_result"
+	    else
+	      relink_command=
+	      func_source $dir/$noexename
+	    fi
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      rmfiles="$rmfiles $objdir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      rmfiles="$rmfiles $objdir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+    objdir="$origobjdir"
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$mode" = uninstall || test "$mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/Makefile.am dovecot-1.2.4/dovecot-managesieve/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/Makefile.am	2009-01-22 22:24:42.000000000 +0100
@@ -0,0 +1,11 @@
+SUBDIRS = src
+
+EXTRA_DIST = \
+	COPYING.LGPL \
+	ChangeLog \
+	doc
+
+if MAINTAINER_MODE
+ChangeLog: .hg/dirstate
+	hg log --style=changelog > ChangeLog
+endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/missing dovecot-1.2.4/dovecot-managesieve/missing
--- dovecot-1.2.4.orig/dovecot-managesieve/missing	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/missing	2008-07-18 12:18:45.000000000 +0200
@@ -0,0 +1,367 @@
+#! /bin/sh
+# Common stub for a few missing GNU programs while installing.
+
+scriptversion=2006-05-10.23
+
+# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004, 2005, 2006
+#   Free Software Foundation, Inc.
+# Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+# 02110-1301, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try \`$0 --help' for more information"
+  exit 1
+fi
+
+run=:
+sed_output='s/.* --output[ =]\([^ ]*\).*/\1/p'
+sed_minuso='s/.* -o \([^ ]*\).*/\1/p'
+
+# In the cases where this matters, `missing' is being run in the
+# srcdir already.
+if test -f configure.ac; then
+  configure_ac=configure.ac
+else
+  configure_ac=configure.in
+fi
+
+msg="missing on your system"
+
+case $1 in
+--run)
+  # Try to run requested program, and just exit if it succeeds.
+  run=
+  shift
+  "$@" && exit 0
+  # Exit code 63 means version mismatch.  This often happens
+  # when the user try to use an ancient version of a tool on
+  # a file that requires a minimum version.  In this case we
+  # we should proceed has if the program had been absent, or
+  # if --run hadn't been passed.
+  if test $? = 63; then
+    run=:
+    msg="probably too old"
+  fi
+  ;;
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Handle \`PROGRAM [ARGUMENT]...' for when PROGRAM is missing, or return an
+error status if there is no known handling for PROGRAM.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+  --run           try to run the given command, and emulate it if it fails
+
+Supported PROGRAM values:
+  aclocal      touch file \`aclocal.m4'
+  autoconf     touch file \`configure'
+  autoheader   touch file \`config.h.in'
+  autom4te     touch the output file, or create a stub one
+  automake     touch all \`Makefile.in' files
+  bison        create \`y.tab.[ch]', if possible, from existing .[ch]
+  flex         create \`lex.yy.c', if possible, from existing .c
+  help2man     touch the output file
+  lex          create \`lex.yy.c', if possible, from existing .c
+  makeinfo     touch the output file
+  tar          try tar, gnutar, gtar, then tar without non-portable flags
+  yacc         create \`y.tab.[ch]', if possible, from existing .[ch]
+
+Send bug reports to <bug-automake@gnu.org>."
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing $scriptversion (GNU Automake)"
+    exit $?
+    ;;
+
+  -*)
+    echo 1>&2 "$0: Unknown \`$1' option"
+    echo 1>&2 "Try \`$0 --help' for more information"
+    exit 1
+    ;;
+
+esac
+
+# Now exit if we have it, but it failed.  Also exit now if we
+# don't have it and --version was passed (most likely to detect
+# the program).
+case $1 in
+  lex|yacc)
+    # Not GNU programs, they don't have --version.
+    ;;
+
+  tar)
+    if test -n "$run"; then
+       echo 1>&2 "ERROR: \`tar' requires --run"
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       exit 1
+    fi
+    ;;
+
+  *)
+    if test -z "$run" && ($1 --version) > /dev/null 2>&1; then
+       # We have it, but it failed.
+       exit 1
+    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then
+       # Could not run --version or --help.  This is probably someone
+       # running `$TOOL --version' or `$TOOL --help' to check whether
+       # $TOOL exists and not knowing $TOOL uses missing.
+       exit 1
+    fi
+    ;;
+esac
+
+# If it does not exist, or fails to run (possibly an outdated version),
+# try to emulate it.
+case $1 in
+  aclocal*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acinclude.m4' or \`${configure_ac}'.  You might want
+         to install the \`Automake' and \`Perl' packages.  Grab them from
+         any GNU archive site."
+    touch aclocal.m4
+    ;;
+
+  autoconf)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`${configure_ac}'.  You might want to install the
+         \`Autoconf' and \`GNU m4' packages.  Grab them from any GNU
+         archive site."
+    touch configure
+    ;;
+
+  autoheader)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`acconfig.h' or \`${configure_ac}'.  You might want
+         to install the \`Autoconf' and \`GNU m4' packages.  Grab them
+         from any GNU archive site."
+    files=`sed -n 's/^[ ]*A[CM]_CONFIG_HEADER(\([^)]*\)).*/\1/p' ${configure_ac}`
+    test -z "$files" && files="config.h"
+    touch_files=
+    for f in $files; do
+      case $f in
+      *:*) touch_files="$touch_files "`echo "$f" |
+				       sed -e 's/^[^:]*://' -e 's/:.*//'`;;
+      *) touch_files="$touch_files $f.in";;
+      esac
+    done
+    touch $touch_files
+    ;;
+
+  automake*)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified \`Makefile.am', \`acinclude.m4' or \`${configure_ac}'.
+         You might want to install the \`Automake' and \`Perl' packages.
+         Grab them from any GNU archive site."
+    find . -type f -name Makefile.am -print |
+	   sed 's/\.am$/.in/' |
+	   while read f; do touch "$f"; done
+    ;;
+
+  autom4te)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, but is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.
+         You can get \`$1' as part of \`Autoconf' from any GNU
+         archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo "#! /bin/sh"
+	echo "# Created by GNU Automake missing as a replacement of"
+	echo "#  $ $@"
+	echo "exit 0"
+	chmod +x $file
+	exit 1
+    fi
+    ;;
+
+  bison|yacc)
+    echo 1>&2 "\
+WARNING: \`$1' $msg.  You should only need it if
+         you modified a \`.y' file.  You may need the \`Bison' package
+         in order for those modifications to take effect.  You can get
+         \`Bison' from any GNU archive site."
+    rm -f y.tab.c y.tab.h
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.y)
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.c
+	    fi
+	    SRCFILE=`echo "$LASTARG" | sed 's/y$/h/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" y.tab.h
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f y.tab.h; then
+	echo >y.tab.h
+    fi
+    if test ! -f y.tab.c; then
+	echo 'main() { return 0; }' >y.tab.c
+    fi
+    ;;
+
+  lex|flex)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.l' file.  You may need the \`Flex' package
+         in order for those modifications to take effect.  You can get
+         \`Flex' from any GNU archive site."
+    rm -f lex.yy.c
+    if test $# -ne 1; then
+        eval LASTARG="\${$#}"
+	case $LASTARG in
+	*.l)
+	    SRCFILE=`echo "$LASTARG" | sed 's/l$/c/'`
+	    if test -f "$SRCFILE"; then
+	         cp "$SRCFILE" lex.yy.c
+	    fi
+	  ;;
+	esac
+    fi
+    if test ! -f lex.yy.c; then
+	echo 'main() { return 0; }' >lex.yy.c
+    fi
+    ;;
+
+  help2man)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+	 you modified a dependency of a manual page.  You may need the
+	 \`Help2man' package in order for those modifications to take
+	 effect.  You can get \`Help2man' from any GNU archive site."
+
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -f "$file"; then
+	touch $file
+    else
+	test -z "$file" || exec >$file
+	echo ".ab help2man is required to generate this page"
+	exit 1
+    fi
+    ;;
+
+  makeinfo)
+    echo 1>&2 "\
+WARNING: \`$1' is $msg.  You should only need it if
+         you modified a \`.texi' or \`.texinfo' file, or any other file
+         indirectly affecting the aspect of the manual.  The spurious
+         call might also be the consequence of using a buggy \`make' (AIX,
+         DU, IRIX).  You might want to install the \`Texinfo' package or
+         the \`GNU make' package.  Grab either from any GNU archive site."
+    # The file to touch is that specified with -o ...
+    file=`echo "$*" | sed -n "$sed_output"`
+    test -z "$file" && file=`echo "$*" | sed -n "$sed_minuso"`
+    if test -z "$file"; then
+      # ... or it is the one specified with @setfilename ...
+      infile=`echo "$*" | sed 's/.* \([^ ]*\) *$/\1/'`
+      file=`sed -n '
+	/^@setfilename/{
+	  s/.* \([^ ]*\) *$/\1/
+	  p
+	  q
+	}' $infile`
+      # ... or it is derived from the source name (dir/f.texi becomes f.info)
+      test -z "$file" && file=`echo "$infile" | sed 's,.*/,,;s,.[^.]*$,,'`.info
+    fi
+    # If the file does not exist, the user really needs makeinfo;
+    # let's fail without touching anything.
+    test -f $file || exit 1
+    touch $file
+    ;;
+
+  tar)
+    shift
+
+    # We have already tried tar in the generic part.
+    # Look for gnutar/gtar before invocation to avoid ugly error
+    # messages.
+    if (gnutar --version > /dev/null 2>&1); then
+       gnutar "$@" && exit 0
+    fi
+    if (gtar --version > /dev/null 2>&1); then
+       gtar "$@" && exit 0
+    fi
+    firstarg="$1"
+    if shift; then
+	case $firstarg in
+	*o*)
+	    firstarg=`echo "$firstarg" | sed s/o//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+	case $firstarg in
+	*h*)
+	    firstarg=`echo "$firstarg" | sed s/h//`
+	    tar "$firstarg" "$@" && exit 0
+	    ;;
+	esac
+    fi
+
+    echo 1>&2 "\
+WARNING: I can't seem to be able to run \`tar' with the given arguments.
+         You may want to install GNU tar or Free paxutils, or check the
+         command line arguments."
+    exit 1
+    ;;
+
+  *)
+    echo 1>&2 "\
+WARNING: \`$1' is needed, and is $msg.
+         You might have modified some files without having the
+         proper tools for further handling them.  Check the \`README' file,
+         it often tells you about the needed prerequisites for installing
+         this package.  You may also peek at any GNU archive site, in case
+         some other package would contain this missing \`$1' program."
+    exit 1
+    ;;
+esac
+
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/NEWS dovecot-1.2.4/dovecot-managesieve/NEWS
--- dovecot-1.2.4.orig/dovecot-managesieve/NEWS	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/NEWS	2009-08-21 00:49:14.000000000 +0200
@@ -0,0 +1,265 @@
+Dovecot 1.2:
+
+v0.11.9:
+	* Adjusted to changes in the Dovecot login proxy API. This release 
+	  therefore depends on Dovecot v1.2.4.
+	+ Reintroduced ability to abort SASL with "*" response. Latest ManageSieve
+	  specification includes it.
+
+v0.11.8:
+	- Fixed TLS support for proxying ManageSieve. The protocol state machine
+	  was incorrect. Also added a check that disables ssl when 'starttls' is 
+	  not enabled for the user. This produces a proper warning in the log file. 
+	  There is no such thing as a managesieveS protocol which has SSL from the 
+	  start.
+
+v0.11.7:
+	* Adjusted to changes in the Dovecot login API. This release now depends on
+	  Dovecot v1.2.1 or newer.
+	* Incorporated various small changes in IMAP into ManageSieve. This includes
+	  properly enabling the generation of core dumps.
+	- The previous release implicitly resolved the FreeBSD script truncation
+	  error. This release adds a small correction to the code that detects the
+	  truncation.
+	- Fixed panic occurring when many errors are produced by the Sieve compiler
+	  (bug found by Pascal Volk).
+	- Fixed memory leak in the PUTSCRIPT command.
+
+v0.11.6:
+	* Adjusted to changes in Dovecot regarding client idle timeout vs 
+	  authentication timeout. This release now depends on Dovecot v1.2.rc6 or
+	  newer.
+	- Fixed CRLF line breaks in compile errors (bug reported by Pascal Volk).
+	- Corrected directory/file creation behavior with respect to mode bits
+	  and gid (bug reported by Pascal Volk).
+	- Improved handling of script truncation bugs: connection is now closed and
+	  an error is logged. bug itself not fixed yet). 
+	- Prevented temp script name from showing up in error output.
+
+v0.11.5:
+	* Incorporated various changes from imap-login into managesieve-login. This
+	  includes changes in the proxy support.
+  
+v0.11.4:
+	* Adjusted to changes in the Dovecot signal handler API.
+
+v0.11.3:
+	* Changed the SASL service name from "managesieve" into "sieve" as required
+	  in the protocol specification. Don't forget to adjust your configuration 
+	  if your authentication mechanism depends on this service name. 
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot
+	  >= v1.2.beta1.
+	* Adapted to changes in the new Sieve implementation, making this release
+	  dependent on Dovecot Sieve >= v0.1.3 if used. The old cmusieve plugin is 
+	  still supported. 
+	+ Implemented making the SIEVE and NOTIFY capability fully dynamic, meaning 
+	  that the sieve_extensions setting that was introduced for the new Sieve 
+	  plugin properly affects the ManageSieve daemon as well.
+	+ Added support for the CHECKSCRIPT command. In terms of the supported 
+	  commands, the ManageSieve daemon now complies with protocol VERSION 1.0 as
+	  listed in the CAPABILITY response. 
+	- Fixed maximum permissions for uploaded scripts; was 0777. This
+	  was shielded however by the default umask (not documented to be 
+	  configurable), so the actual permissions would never have been 0777.
+	- Fixed a segfault bug in the authentication time-out. Bug report and trace
+	  provided by Wolfgang Friebel.
+	- Fixed handling of ~/ in use of mail-data for script location.
+	- Fixed small problems in the login proxy support.
+  
+v0.11.2:
+	* Adapted to changes in Dovecot, making this release dependent on Dovecot 
+	  >= v1.2.alpa4.	
+
+v0.11.1:
+	- Fixed security issue that gives virtual users the ability to read and
+	  modify each other's scripts if the directory structure of the sieve
+	  storage is known.
+	* Updated NOOP command to match new protocol specification
+	+ Improved error handling and implemented the new response codes: 
+	  ACTIVE, NONEXISTENT, ALREADYEXISTS and WARNINGS
+
+v0.11.0:
+	* Upgraded to Dovecot v1.2
+	* Added support for new ManageSieve extensions RENAME and NOOP
+	* Moved sieve settings to plugin {} section of config file. Now the settings
+	  `sieve` and `sieve_dir` in the plugin section are used for the Sieve plugin
+	  and the ManageSieve service, avoiding the posibility of accidental 
+	  differences in configuration.
+
+Dovecot 1.1:
+
+v0.10.3
+	* Removed erroneous inline declarations that caused compiler warnings. GCC 4.3
+	  turns out to fail entirely as reported by Joel Johnson. 
+	* Fixed auto-dectection of Sieve implementation during ./configure. It now 
+	  produces a proper error when the directory is invalid.
+
+v0.10.2
+	* Fixed bug that caused SASL mechanisms that require more than a single client
+	  response to fail. Reported by Steffen Kaiser and occured when he tried using 
+	  the (obsolete) LOGIN mechanism.
+	* Updated installation and configuration documentation to match the 
+	  information provided in the wiki
+
+v0.10.1
+	* Fixed bug introduced in v0.10.0: compiled scripts were also written to disk
+	  in the sieve/tmp directory and left there. This accumulates much .sievec 
+	  junk in that directory over time. 
+	* Fixed bug in tmp file generation for sieve-storage: errors other than EEXIST
+	  would cause the daemon to sleep() loop indefinitely. 
+	  
+	+ Improved log lines to be more recognizable as being generated from 
+	  managesieve.
+	+ Added short proxy configuration explanation to the README file
+	+ Added 'Known Issues' section to the README file
+	- Fixed assert bug in sieve-storage occuring when save is canceled.
+  
+v0.10.0
+	* Upgraded to Dovecot 1.1:
+		- The actual managesieve implementation is now a separate package. 
+		  The dovecot tree still needs to be patched though to make dovecot 
+		  recognize the new managesieve service.
+		- Incorporated changes to imap/imap-login into the equivalent 
+		  managesieve processes.
+		- Removed cmusieve implementation from managesieve sources. It is 
+		  now linked externally from the dovecot-sieve-1.1 package. 
+		- Restructured README.managesieve file into separate README, NEWS, 
+		  TODO, DESIGN and INSTALL files. 
+	* Added support for new libsieve implementation (to be released). This 
+	  package can be compiled with either the new or the old Sieve
+	  implementation (autodetected). If the new Sieve becomes stable, this 
+	  package will be merged with it to make a single package for Dovecot 
+	  Sieve support.
+   
+Dovecot 1.0:
+
+(development forked, v9 is still maintained for Dovecot v1.0)
+
+v9
+
++ Definitively fixed the segfault mentioned in V8. It proved to be 
+  very time-constrained and thus hard to reproduce. The error turned out
+  to be related to the input handling of the login daemon during 
+  authentication. 
++ Checked for changes in the imap daemon that weren't propagated to the 
+  managesieve implementation due to code duplication.
++ Fixed a bug in the autodetection of the sieve storage location.
++ Fixed bug in the sieve storage that failed to refresh the symlink if
+  the storage was moved. 
++ Improved error handing in the sieve-storage implementation in various 
+  places. 
++ Fixed the situation in which the active script link is located in the 
+  sieve storage. 
++ Added managesieve configuration to dovecot-example.conf and made the example
+  in this file more concise. 
+
+v8
+
++ Fixed a few incompatibilities with 1.0.7 version. For instance, the "Logged
+  in" message is now sent by the -login process and not by the managesieve 
+  daemon anymore. This caused a segfault every once in a while. 
++ Probably fixed the settings problem reported by Steffen Kaiser regarding 
+  login_dir. 'dovecot -n' now reports correct results, but testing will show
+  whether the whole problem is solved.
++ The managesieve daemon now accepts the sieve_storage and sieve configuration
+  settings, so it is now possible to explicitly configure the location of the
+  sieve storage and the active script respectively. The daemon still falls back
+  to using the mail_location (MAIL) settings if nothing else is specified. 
++ The cyrus timsieved does not use the + character in string literals and many
+  clients have adopted to this behaviour. The latest managesieve (08) advises to
+  accept a missing + from clients. The server should not send any + characters 
+  as well. This behavior is now implemented on the server. 
++ Cleaned up sieve-storage.c: split up the sieve_storage_create function in 
+  various sub-functions for obtaining the various paths and directories.
++ Forced manual intervention if rescueing a non-symlink file at the active script
+  path fails somehow. Previously, this presented the admin with a log message 
+  that it had just eaten the script, which is not very nice. 
++ Restructured the README.managesieve file and added some more explanation with
+  regard to the configuration of the daemon.
+
+v7 
+
+- Robin Breathe indicated that the regex capability was missing in the server's
+  SIEVE listing. It turns out I forgot to make arrangements for setting 
+  ENABLE_REGEX in the cmu libsieve sources, so the regex extension was not
+  compiled in. I copied the configure.in section regarding ENABLE_REGEX from 
+  dovecot-sieve-1.0.2 and that fixed the problem.
+
+v6
+
+- Corked the client output stream while producing the capability greeting and on 
+  other some other occasions as well. Some naive client implementations expect to 
+  receive this as a single tcp frame and it is a good practice to do so anyway.
+  Using this change the Thunderbird sieve extension (v0.1.1) seemed to work. However,
+  scripts larger than a tcp frame still caused failures. All these issues are fixed
+  in the latest version of the sieve add-on (currently v0.1.4). 
+- Cleaned up the new proxy source. My editor made the indentation a complete mess
+  in terms of TABs vs spaces. 
+- Added TRYLATER response codes to BYE and NO messages where appropriate.  
+- Recopied the libsieve library into this patch to incorporate any changes that were
+  made (only sieve-cmu.c still needs to be compared to the old cmu-sieve.c). This 
+  also solves the __attribute__((unused)) GCC dependencies. These were fixed long
+  ago by Timo....  the code duplication beast strikes again. 
+- Removed spurious return value from void function in 
+  src/lib-sieve/sieve-implementation.c as reported by Robin Breathe. GCC fails to
+  report these issues. The function involved is currently not used and serves only
+  as an example on how dovecot could support multiple sieve backends... 
+
+v5 
+
+- Applied patch by Uldis Pakuls to fix master_dump_settings bug
+- Added some compilation/installation info to this README
+- Moved README to source tree root as README.managesieve
+- Fixed minor error handling bug in sieve_storage.c with respect to a missing
+  root directory.
+- Now sieve capabilities are reported as they are specified by the implementing
+  library and not in forced upper case. The sieve RFC now explicitly states
+  that sieve capability identifiers are case-sensitive. This broke compatibility
+  with SquirrelMail/Avelsieve. 
+- Disabled ANONYMOUS login entirely until proper support is implemented. V4
+  claimed to do so as well, but in fact it only stopped announcing it.
+- Implemented managesieve-proxy. It is not so much a clean copy of imap-proxy,
+  since the managesieve greeting is much more complex and requires parsing. 
+  Configuration is identical to imap-proxy. This seems to be a little under-
+  documented however (http://wiki.dovecot.org/PasswordDatabase/ExtraFields).  
+
+v4
+
+- Added managesieve_implementation_string setting to the managesieve 
+  configuration. This can be used to customize the default "IMPLEMENTATION" 
+  capability response.
+- Denied ANONYMOUS login until proper support is implemented
+- Fixed problem with authenticate command regarding continued responses. In
+  V3 only initial response would work. Problem was caused by rc2 -> rc28 
+  upgrade. One of the clear reasons why code duplication is a very bad idea.
+- Fixed readlink bug as indicated by Timo: return value of readlink can also
+  be -1.
+- Fixed bug in the regular file rescue code, as introduced in the previous 
+  version. Used stat instead of lstat. This caused the symlink to be rescued 
+  subsequently in the next activation, thus still overwriting the initially 
+  rescued script.
+
+v3
+
+- Updated source to compile with dovecot 1.0.rc27 
+- Daemon now uses the same location for .dovecot.sieve as dovecot-lda
+  This is typically ~/.dovecot.sieve
+- If .dovecot.sieve is a regular file, it is now moved into the script storage as
+  dovecot.orig.sieve, preventing deletion of (important) active scripts 
+  upon upgrade.
+- Changed error handling to yield a BYE message when the managesieve 
+  daemon exits unexpectedly (upon login) before any commands are entered. 
+  Horde-ingo would wait indefinitely for a response. 
+
+v2
+
+- Fixed the bug (missing CRLF) in the authenticate command
+- Modified the sieve storage library making the interface much less crude.
+- The scripts put on the server using the putscript command are now 
+  checked before they are accepted.
+- The reported SIEVE capability is now directly read from the sieve 
+  implementation (in this case cmu), listing much more than "FILEINTO 
+  VACATION".
+- Imported instance of libsieve source into this patch for implementation
+  of script checking and capability listing. THIS NEEDS TO BE CHANGED! 
+- Fixed some minor bugs in the putscript command
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/README dovecot-1.2.4/dovecot-managesieve/README
--- dovecot-1.2.4.orig/dovecot-managesieve/README	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/README	2009-07-13 21:10:41.000000000 +0200
@@ -0,0 +1,169 @@
+MANAGESIEVE implementation for Dovecot (1.2)
+
+Compile
+-------
+
+Refer to INSTALL file.
+ 
+Configure
+---------
+
+IMPORTANT: 
+    If you have used the Sieve plugin before and you have .dovecot.sieve files 
+    in user directories, you are advised to make a backup first. Although the
+    ManageSieve daemon takes care to move these files to the Sieve directory 
+    before it is substituted with a symbolic link, this is not a very well 
+    tested operation, meaning that there is a possibility that existing Sieve 
+    scripts get lost.
+
+Along with all other binaries that Dovecot uses, the managesieve and 
+managesieve-login binaries are installed during make install. The only thing you 
+need to do to activate the ManageSieve support in Dovecot is to add managesieve 
+to the protocols= configuration line in your dovecot.conf. 
+
+The ManageSieve daemon will listen on all interfaces at port 2000 by default. 
+Because the implementation of the ManageSieve daemon is largely based on the 
+original IMAP implementation, it is very similar in terms of configuration. 
+The following settings can be configured in the 'protocol managesieve' section:
+
+listen = *:2000
+    Interface and port on which the daemon listens for incoming connections.
+
+login_executable = /usr/lib/dovecot/managesieve-login
+    Login executable location. 
+
+mail_executable = /usr/lib/dovecot/managesieve
+    The managesieve executable location. For examples how this could be applied,
+    refer to the explanation of the mail_executable setting for IMAP. 
+    
+managesieve_max_line_length = 65536
+    The maximum managesieve command line length in bytes. This setting is 
+    directly borrowed from IMAP. But, since long command lines are very unlikely 
+    with ManageSieve, changing this will not be very useful. 
+
+managesieve_logout_format = bytes=%i/%o
+    Specifies the string pattern used to compose the logout message of an
+    authenticated session. The following substitutions are available:
+        %i - total number of bytes read from client
+        %o - total number of bytes sent to client
+
+managesieve_implementation_string = dovecot
+    To fool ManageSieve clients that are focused on CMU's timesieved you can 
+    specify the IMPLEMENTATION capability that the Dovecot reports to clients 
+    (e.g. 'Cyrus timsieved v2.2.13'). 
+
+Additionally, the ManageSieve service uses the following settings from the 
+plugin section of the config file. These settings are the ones used by the Sieve 
+plugin.
+
+sieve_dir = 
+    This specifies the path to the directory where the uploaded scripts are 
+    stored. Scripts are stored as separate files with extension '.sieve'. All 
+    other files are ignored when scripts are listed by a ManageSieve client. If
+    this setting remains unspecified, the mail_location setting is used as 
+    explained above. The now deprecated sieve_storage setting is still accepted.
+
+sieve = ~/.dovecot.sieve
+    Specifies the location of the symbolic link pointing to the active script in
+    the Sieve storage directory. If a regular file exists at this location, it is 
+    moved to the sieve_dir location before the symbolic link is installed. It is 
+    renamed to dovecot.orig.sieve and therefore listed as dovecot.orig by a 
+    ManageSieve client. 
+
+Scripts are stored in a special directory at the location specified by the 
+sieve_dir setting. The active Sieve script is managed as a symbolic link 
+pointing to the active script in the script directory. The location of this 
+symlink is specified with the 'sieve' setting. The default location is 
+~/.dovecot.sieve. Note that if a file starting with '.' is placed inside a 
+Maildir, it will be recognized as a folder, so try to avoid that.
+
+If no 'sieve_dir' is specified, the ManageSieve daemon expects the script 
+directory to reside in the mail folder as specified by the 'mail_location' 
+setting. More precisely, it is placed in the CONTROL= directory of 
+'mail_location' if specified, otherwise the script directory is placed in the 
+root of the mail location. In such a mail or mail control directory, scripts are 
+always stored in a sub-directory called 'sieve'. Using this implicit manner to 
+specify the Sieve script directory is depricated. Also note that for some mail 
+storage types (e.g. mbox) the 'sieve' sub-directory is listed as a mail folder, 
+so be sure to put the Sieve scripts somewhere else if you can.
+
+A storage location specified by 'sieve_dir' is always generated automatically 
+if it does not exist (as far as the system permits the user to do so; no root 
+privileges are used). This is similar to the behaviour of the mail daemons. Note 
+that when 'mail_location' is used to specify the script storage location, only 
+the 'sieve' subdirectory is generated automatically.
+
+The following provides an example configuration for ManageSieve in dovecot.conf. 
+Only sections relevant to ManageSieve are shown. Refer to dovecot-example.conf 
+in your patched Dovecot tree for a full example with comments, but don't forget 
+to add managesieve to the 'protocols = ...' setting if you use it.
+
+# Start imap, pop3 and managesieve services
+protocols = imap pop3 managesieve
+
+protocol managesieve {
+  # Specify an alternative address:port the daemon must listen on
+  # (default: *:2000)
+  #listen = localhost:2000
+}
+
+plugin {
+  sieve=~/.dovecot.sieve
+  sieve_dir=~/sieve
+}
+
+Proxying
+--------
+
+Like Dovecot's imapd, the ManageSieve login daemon supports proxying to multiple
+backend servers. Although the underlying code is copied from the imapd sources
+for the most part, it has some ManageSieve-specifics that have not seen much
+testing. 
+
+The proxy configuration wiki page for POP3 and IMAP should apply to ManageSieve 
+as well:
+
+http://wiki.dovecot.org/PasswordDatabase/ExtraFields/Proxy
+
+Known Issues
+------------
+
+* Although this ManageSieve server should comply with the draft specification of 
+  the ManageSieve protocol, quite a few clients don't. This is particularly true 
+  for the TLS support. However, now that Cyrus' Timsieved has changed its 
+  behavior towards protocol compliance, all those clients will follow 
+  eventually. 
+
+  Clients known to have TLS issues:
+	- Thunderbird Sieve add-on: fixed as per version 0.1.5
+	- AvelSieve: patch on the wiki:	http://wiki.dovecot.org/ManageSieve
+	- KMail + kio_sieve: TLS broken for old versions. This issue is fixed at 
+	  least in kmail 1.9.9 / kde 3.5.9. 
+
+  Unfortunately, there is no reliable way to provide a workaround for this
+  problem. We will have to wait for the authors of these clients to make the
+  proper adjustments. 
+  
+* Other client issues:
+
+	- SmartSieve, WebSieve: 
+	  These clients are specifically written for Cyrus timsieved and fail on 
+	  multiple stages of the protocol when connected to Dovecot ManageSieve.
+	    
+* The current implementation of the daemon does not have quota enforcement as
+  recommended in the specification. So keep in mind that malicious users could
+  fill your filesystem with loads of spurious scriptfiles.
+  
+* The ANONYMOUS authentication mechanism is currently not supported and 
+  explicitly denied. 
+
+Contact Info
+------------
+
+Stephan Bosch <stephan at rename-it dot nl>
+IRC: Freenode, #dovecot, S[r]us
+
+Please use the Dovecot mailing list <dovecot at dovecot.org> for questions about 
+this package. You can post to the list without subscribing, the mail then waits 
+in a moderator queue for a while. See http://dovecot.org/mailinglists.html
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/Makefile.am dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/Makefile.am	2008-11-05 15:48:20.000000000 +0100
@@ -0,0 +1,36 @@
+noinst_LTLIBRARIES = libsieve_cmu.la
+
+MOSTLYCLEANFILES = imparse.c map.c
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_sievedir)/src/ \
+	-I$(dovecot_sievedir)/src/libsieve 
+
+sieve_plugin=$(dovecot_sievedir)/src/libsieve/libsieve.la
+
+libsieve_cmu_la_DEPENDENCIES = $(sieve_plugin)
+libsieve_cmu_la_LIBADD = $(sieve_plugin)
+
+nodist_libsieve_cmu_la_SOURCES = \
+	imparse.c \
+	map.c
+
+libsieve_cmu_la_SOURCES = \
+	sieve-error.c \
+	sieve-script.c \
+	sieve.c 
+
+noinst_HEADERS = \
+	sieve-common.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve.h
+
+imparse.c map.c: $(dovecot_sievedir)/src/$@
+	cp $(dovecot_sievedir)/src/$@ $@
+
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/Makefile.in dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/Makefile.in
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/Makefile.in	2009-08-21 01:05:44.000000000 +0200
@@ -0,0 +1,487 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-cmusieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+am_libsieve_cmu_la_OBJECTS = sieve-error.lo sieve-script.lo sieve.lo
+nodist_libsieve_cmu_la_OBJECTS = imparse.lo map.lo
+libsieve_cmu_la_OBJECTS = $(am_libsieve_cmu_la_OBJECTS) \
+	$(nodist_libsieve_cmu_la_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsieve_cmu_la_SOURCES) $(nodist_libsieve_cmu_la_SOURCES)
+DIST_SOURCES = $(libsieve_cmu_la_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SIEVE_PLUGIN_TOP = @SIEVE_PLUGIN_TOP@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LTLIBRARIES = libsieve_cmu.la
+MOSTLYCLEANFILES = imparse.c map.c
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_sievedir)/src/ \
+	-I$(dovecot_sievedir)/src/libsieve 
+
+sieve_plugin = $(dovecot_sievedir)/src/libsieve/libsieve.la
+libsieve_cmu_la_DEPENDENCIES = $(sieve_plugin)
+libsieve_cmu_la_LIBADD = $(sieve_plugin)
+nodist_libsieve_cmu_la_SOURCES = \
+	imparse.c \
+	map.c
+
+libsieve_cmu_la_SOURCES = \
+	sieve-error.c \
+	sieve-script.c \
+	sieve.c 
+
+noinst_HEADERS = \
+	sieve-common.h \
+	sieve-error.h \
+	sieve-error-private.h \
+	sieve-script.h \
+	sieve-script-private.h \
+	sieve.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-cmusieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-cmusieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libsieve_cmu.la: $(libsieve_cmu_la_OBJECTS) $(libsieve_cmu_la_DEPENDENCIES) 
+	$(LINK)  $(libsieve_cmu_la_OBJECTS) $(libsieve_cmu_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/imparse.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/map.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-script.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+
+imparse.c map.c: $(dovecot_sievedir)/src/$@
+	cp $(dovecot_sievedir)/src/$@ $@
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve.c dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,379 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "ioloop.h"
+#include "array.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "istream.h"
+#include "libsieve/sieve_interface.h"
+
+#include "sieve.h"
+#include "sieve-script.h"
+
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+/* data per script */
+typedef struct script_data {
+	struct sieve_error_handler *ehandler;
+} script_data_t;
+
+static sieve_interp_t *_interp;
+
+struct et_list *_et_list = NULL;
+
+static int
+cmu_sieve_compile(script_data_t *sdata, const char *script_path,
+		      const char *compiled_path);
+
+/* gets the header "head" from msg. */
+static int getheader
+(void *v ATTR_UNUSED, const char *phead ATTR_UNUSED, const char ***body ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+static int getsize(void *mc ATTR_UNUSED, int *size ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int getenvelope
+(void *mc ATTR_UNUSED, const char *field ATTR_UNUSED, 
+	const char ***contents ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+static int getbody
+(void *mc ATTR_UNUSED, const char **content_types ATTR_UNUSED,
+	int decode_to_plain ATTR_UNUSED, sieve_bodypart_t **parts_r ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int getinclude(void *sc, const char *script, int isglobal,
+		      char *fname, size_t size)
+{
+	script_data_t *sdata = (script_data_t *) sc;
+	const char *script_path, *compiled_path, *home, *script_dir;
+	int ret;
+
+	if (strchr(script, '/') != NULL) {
+		i_info("include: '/' not allowed in script names (%s)",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+
+	if (isglobal) {
+		script_dir = getenv("SIEVE_GLOBAL_DIR");
+		if (script_dir == NULL) {
+			i_info("include: global_script_dir not set "
+			       "(wanted script %s)", str_sanitize(script, 80));
+			return SIEVE_FAIL;
+		}
+		script_path = t_strdup_printf("%s/%s", script_dir, script);
+	} else {
+		home = getenv("SIEVE_DIR");
+		if (home == NULL)
+			home = getenv("HOME");
+		if (home == NULL) {
+			i_info("include: sieve_dir and home not set "
+			       "(wanted script %s)", str_sanitize(script, 80));
+			return SIEVE_FAIL;
+		}
+		script_path = t_strdup_printf("%s/%s", home, script);
+	}
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = cmu_sieve_compile(sdata, script_path, compiled_path);
+	if (ret < 0) {
+		i_info("include: Error compiling script '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+	if (ret == 0) {
+		i_info("include: Script not found: '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+
+	if (i_strocpy(fname, compiled_path, size) < 0) {
+		i_info("include: Script path too long: '%s'",
+		       str_sanitize(script, 80));
+		return SIEVE_FAIL;
+	}
+	return SIEVE_OK;
+}
+
+static int sieve_redirect
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED,  void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+static int sieve_discard
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_reject
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_fileinto
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_keep
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int sieve_notify
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED,
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int autorespond
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED,
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+    return SIEVE_OK;
+}
+
+static int send_response
+(void *ac ATTR_UNUSED, void *ic ATTR_UNUSED, void *sc ATTR_UNUSED, 
+	void *mc ATTR_UNUSED, const char **errmsg ATTR_UNUSED)
+{
+	return SIEVE_OK;
+}
+
+/* vacation support */
+sieve_vacation_t vacation = {
+    1,				/* min response */
+    31,				/* max response */
+    &autorespond,		/* autorespond() */
+    &send_response		/* send_response() */
+};
+
+/* imapflags support */
+static char *markflags[] = { "\\flagged" };
+static sieve_imapflags_t mark = { markflags, 1 };
+
+static int sieve_parse_error_handler(int lineno, const char *msg, 
+				     void *ic ATTR_UNUSED,
+				     void *sc)
+{
+    script_data_t *sd = (script_data_t *) sc;
+
+	sieve_error(sd->ehandler, t_strdup_printf("line %d", lineno), "%s", msg);
+    return SIEVE_OK;
+}
+
+static int sieve_execute_error_handler(const char *msg, 
+				       void *ic ATTR_UNUSED,
+				       void *sc ATTR_UNUSED,
+				       void *mc ATTR_UNUSED)
+{
+    i_info("sieve runtime error: %s", msg);
+    return SIEVE_OK;
+}
+ 
+static int
+cmu_sieve_compile(script_data_t *sdata, const char *script_path,
+		      const char *compiled_path)
+{
+	struct stat st, st2;
+	sieve_script_t *script;
+	bytecode_info_t *bc;
+	const char *temp_path;
+	FILE *f;
+	int fd, ret;
+
+	if (stat(script_path, &st) < 0) {
+		if (errno == ENOENT) {
+			if (getenv("DEBUG") != NULL) {
+				i_info("cmusieve: Script not found: %s",
+				       script_path);
+			}
+			return 0;
+		}
+		i_error("cmusieve: stat(%s) failed: %m", script_path);
+		return -1;
+	}
+	if ( compiled_path != NULL ) {
+		if (stat(compiled_path, &st2) < 0) {
+			if (errno != ENOENT) {
+				i_error("cmusieve: stat(%s) failed: %m", script_path);
+				return -1;
+			}
+		} else {
+			if (st.st_mtime < st2.st_mtime)
+				return 1;
+		}
+	}
+
+	/* need to compile */
+	f = fopen(script_path, "r");
+	if (f == NULL) {
+		i_error("cmusieve: fopen(%s) failed: %m", script_path);
+		return -1;
+	}
+
+	ret = sieve_script_parse(_interp, f, sdata, &script);
+	if (ret != SIEVE_OK) {
+		if ( sieve_get_errors(sdata->ehandler) == 0 ) {
+			sieve_error(sdata->ehandler, "unknown location", 
+				"parse error %d", ret);
+		}
+		return -1;
+	} 
+
+	if (sieve_generate_bytecode(&bc, script) < 0) {
+		i_error("sieve_generate_bytecode() failed");
+		return -1;
+	}
+
+	if ( compiled_path != NULL ) {
+		/* write to temp file */
+		temp_path = t_strconcat(compiled_path, ".tmp", NULL);
+		fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+		if(fd == -1) {
+			i_error("cmusieve: open(%s) failed: %m", temp_path);
+			return -1;
+		}
+
+		if (sieve_emit_bytecode(fd, bc) < 0) {
+			i_error("cmusieve: sieve_emit_bytecode() failed");
+			return -1;
+		}
+
+		if (close(fd) < 0)
+			i_error("cmusieve: close() failed: %m");
+
+		/* and finally replace the script */
+		if (rename(temp_path, compiled_path) < 0) {
+			i_error("cmusieve: rename(%s, %s) failed: %m", temp_path, compiled_path);
+			return -1;
+		}
+	}
+	return 1;
+}
+
+struct sieve_binary *sieve_compile_script
+    (struct sieve_script *script, struct sieve_error_handler *ehandler)
+{
+	script_data_t sdata;
+	const char *script_path = sieve_script_path(script);
+	const char *compiled_path;
+	int ret;
+
+	memset(&sdata, 0, sizeof(sdata));
+	sdata.ehandler = ehandler;
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = cmu_sieve_compile(&sdata, script_path, NULL);
+	if (ret <= 0)
+		return NULL;
+
+	return (struct sieve_binary *) 1; 
+}
+
+const char *sieve_get_capabilities(const char *name)
+{
+	if ( name == NULL || *name == '\0' )
+		return sieve_listextensions(_interp);
+	
+	if ( strcmp(name, "notify") == 0 ) 
+		return "mailto";
+
+	return NULL;
+}
+
+void sieve_set_extensions(const char *extensions ATTR_UNUSED)
+{
+	sieve_sys_warning("cannot set available extensions for the CMUSieve plugin");
+}
+
+bool sieve_init(void)
+{
+    int res;
+
+    _interp = NULL;
+
+    res = sieve_interp_alloc(&_interp, NULL);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_interp_alloc() returns %d\n", res);
+
+    res = sieve_register_redirect(_interp, &sieve_redirect);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_redirect() returns %d\n", res);
+    res = sieve_register_discard(_interp, &sieve_discard);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_discard() returns %d\n", res);
+    res = sieve_register_reject(_interp, &sieve_reject);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_reject() returns %d\n", res);
+    res = sieve_register_fileinto(_interp, &sieve_fileinto);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_fileinto() returns %d\n", res);
+    res = sieve_register_keep(_interp, &sieve_keep);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_keep() returns %d\n", res);
+    res = sieve_register_imapflags(_interp, &mark);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_imapflags() returns %d\n", res);
+    res = sieve_register_notify(_interp, &sieve_notify);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_notify() returns %d\n", res);
+    res = sieve_register_size(_interp, &getsize);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_size() returns %d\n", res);
+    res = sieve_register_header(_interp, &getheader);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_header() returns %d\n", res);
+
+    res = sieve_register_envelope(_interp, &getenvelope);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_envelope() returns %d\n", res);
+    res = sieve_register_body(_interp, &getbody);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_body() returns %d\n", res);
+    res = sieve_register_include(_interp, &getinclude);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_registerinclude() returns %d\n", res);
+    res = sieve_register_vacation(_interp, &vacation);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_vacation() returns %d\n", res);
+    res = sieve_register_parse_error(_interp, &sieve_parse_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_parse_error() returns %d\n", res);
+    res = sieve_register_execute_error(_interp,  &sieve_execute_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_execute_error() returns %d\n", res);
+
+	return TRUE;
+}
+
+void sieve_deinit(void)
+{
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-common.h dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-common.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-common.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_COMMON_H
+#define __SIEVE_COMMON_H
+
+/* sieve-error.h */
+struct sieve_error_handler;
+
+/* sieve-script.h */
+struct sieve_script;
+
+#endif /* SIEVE_COMMON_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-error.c dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-error.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-error.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-error.c	2009-06-28 15:50:08.000000000 +0200
@@ -0,0 +1,587 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+ 
+#include "lib.h"
+#include "str.h"
+#include "ostream.h"
+
+#include "sieve-common.h"
+#include "sieve-script.h"
+#include "sieve-error-private.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdio.h>
+
+/*
+ * Definitions
+ */
+
+#define CRITICAL_MSG \
+	"internal error occurred: refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+/* Logfile error handler will rotate log when it exceeds 10k bytes */
+#define LOGFILE_MAX_SIZE (10 * 1024)
+
+/*
+ * Utility
+ */
+
+const char *sieve_error_script_location
+(const struct sieve_script *script, unsigned int source_line)
+{
+    const char *sname = sieve_script_name(script);
+
+    if ( sname == NULL || *sname == '\0' )
+        return t_strdup_printf("line %d", source_line);
+
+    return t_strdup_printf("%s: line %d", sname, source_line);
+}
+
+/*
+ * Main error functions
+ */
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+	
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_error("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+
+	if ( sieve_errors_more_allowed(ehandler) ) {
+		if ( ehandler->verror != NULL )
+			ehandler->verror(ehandler, location, fmt, args);
+		ehandler->errors++;
+	}
+}
+
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_warning("%s", t_strdup_vprintf(fmt, args_copy));
+		else
+			sieve_sys_warning("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	if ( ehandler->vwarning != NULL )	
+		ehandler->vwarning(ehandler, location, fmt, args);
+	ehandler->warnings++;
+}
+
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	if ( ehandler == NULL ) return;
+
+	if ( ehandler->log_master ) {
+		va_list args_copy;
+
+		VA_COPY(args_copy, args);
+
+
+		if ( location == NULL || *location == '\0' )
+			sieve_sys_info("%s", t_strdup_vprintf(fmt, args_copy));
+		else	
+			sieve_sys_info("%s: %s", location, t_strdup_vprintf(fmt, args_copy));
+	}
+	
+	if ( ehandler->log_info && ehandler->vinfo != NULL )	
+		ehandler->vinfo(ehandler, location, fmt, args);
+}
+
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args)
+{
+	char str[256];
+	struct tm *tm; 
+	
+	tm = localtime(&ioloop_time);
+	
+	if ( location == NULL || *location == '\0' )
+		sieve_sys_error("%s", t_strdup_vprintf(fmt, args));
+	else
+		sieve_sys_error("%s: %s", location, t_strdup_vprintf(fmt, args));
+		
+	if ( ehandler == NULL ) return;
+	
+	sieve_error(ehandler, location, "%s", 
+		strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ? 
+			str : CRITICAL_MSG );	
+}
+
+/*
+ * Error statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler) {
+	if ( ehandler == NULL ) return 0;
+	
+	return ehandler->errors;
+}
+
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler) {
+	if ( ehandler == NULL ) return 0;
+
+	return ehandler->errors;
+}
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler) {
+	return ehandler->max_errors == 0 || ehandler->errors < ehandler->max_errors;
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_info = enable;	
+}
+
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable)
+{
+	ehandler->log_master = enable;
+}
+
+/*
+ * Error handler init
+ */
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors)
+{
+	ehandler->pool = pool;
+	ehandler->refcount = 1;
+	ehandler->max_errors = max_errors;
+	
+	ehandler->errors = 0;
+	ehandler->warnings = 0;
+}
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler)
+{
+	if ( ehandler == NULL ) return;
+
+	ehandler->refcount++;
+}
+
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler)
+{
+	if ( *ehandler == NULL ) return;
+
+    i_assert((*ehandler)->refcount > 0);
+
+    if (--(*ehandler)->refcount != 0)
+        return;
+
+	if ( (*ehandler)->free != NULL )
+		(*ehandler)->free(*ehandler);
+
+	pool_unref(&((*ehandler)->pool));
+
+	*ehandler = NULL;
+}
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler)
+{
+    ehandler->errors = 0;
+    ehandler->warnings = 0;
+}
+
+/* 
+ * STDERR error handler
+ *
+ * - Output errors directly to stderror 
+ */
+
+static void sieve_stderr_verror
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "error: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: error: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vwarning
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "warning: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: warning: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+static void sieve_stderr_vinfo
+(struct sieve_error_handler *ehandler ATTR_UNUSED, const char *location, 
+	const char *fmt, va_list args) 
+{
+	if ( location == NULL || *location == '\0' )
+		fprintf(stderr, "info: %s.\n", t_strdup_vprintf(fmt, args));
+	else
+		fprintf(stderr, "%s: info: %s.\n", location, t_strdup_vprintf(fmt, args));
+}
+
+struct sieve_error_handler *sieve_stderr_ehandler_create
+(unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_error_handler *ehandler;
+	
+	/* Pool is not strictly necessary, but other handler types will need a pool,
+	 * so this one will have one too.
+	 */
+	pool = pool_alloconly_create
+		("stderr_error_handler", sizeof(struct sieve_error_handler));
+	ehandler = p_new(pool, struct sieve_error_handler, 1);
+	sieve_error_handler_init(ehandler, pool, max_errors);
+
+	ehandler->verror = sieve_stderr_verror;
+	ehandler->vwarning = sieve_stderr_vwarning;
+	ehandler->vinfo = sieve_stderr_vinfo;
+	
+	return ehandler;	
+}
+
+/* String buffer error handler
+ *
+ * - Output errors to a string buffer 
+ */
+
+struct sieve_strbuf_ehandler {
+	struct sieve_error_handler handler;
+
+	string_t *errors;
+	bool crlf;
+};
+
+static void sieve_strbuf_verror
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_append(handler->errors, "error: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vwarning
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);
+	str_printfa(handler->errors, "warning: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+static void sieve_strbuf_vinfo
+(struct sieve_error_handler *ehandler, const char *location,
+    const char *fmt, va_list args)
+{
+	struct sieve_strbuf_ehandler *handler =
+		(struct sieve_strbuf_ehandler *) ehandler;
+
+	if ( location != NULL && *location != '\0' )
+		str_printfa(handler->errors, "%s: ", location);	
+	str_printfa(handler->errors, "info: ");
+	str_vprintfa(handler->errors, fmt, args);
+
+	if ( !handler->crlf )
+		str_append(handler->errors, ".\n");
+	else
+		str_append(handler->errors, ".\r\n");
+}
+
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+(string_t *strbuf, bool crlf, unsigned int max_errors)
+{
+	pool_t pool;
+	struct sieve_strbuf_ehandler *ehandler;
+
+	pool = pool_alloconly_create("strbuf_error_handler", 256);
+	ehandler = p_new(pool, struct sieve_strbuf_ehandler, 1);
+	ehandler->errors = strbuf;
+    
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_strbuf_verror;
+	ehandler->handler.vwarning = sieve_strbuf_vwarning;
+	ehandler->handler.vinfo = sieve_strbuf_vinfo;
+
+	ehandler->crlf = crlf;
+
+	return &(ehandler->handler);
+}
+
+/* 
+ * Logfile error handler
+ * 
+ * - Output errors to a log file 
+ */
+
+struct sieve_logfile_ehandler {
+	struct sieve_error_handler handler;
+	
+	const char *logfile;
+	bool started;
+	int fd;
+	struct ostream *stream;
+};
+
+static void sieve_logfile_vprintf
+(struct sieve_logfile_ehandler *ehandler, const char *location, 
+	const char *prefix, const char *fmt, va_list args) 
+{
+	string_t *outbuf;
+	ssize_t ret = 0, remain;
+	const char *data;
+	
+	if ( ehandler->stream == NULL ) return;
+	
+	T_BEGIN {
+		outbuf = t_str_new(256);
+		if ( location != NULL && *location != '\0' )
+			str_printfa(outbuf, "%s: ", location);
+		str_printfa(outbuf, "%s: ", prefix);	
+		str_vprintfa(outbuf, fmt, args);
+		str_append(outbuf, ".\n");
+	
+		remain = str_len(outbuf);
+		data = (const char *) str_data(outbuf);
+
+		while ( remain > 0 ) { 
+			if ( (ret=o_stream_send(ehandler->stream, data, remain)) < 0 )
+				break;
+
+			remain -= ret;
+			data += ret;
+		}
+	} T_END;
+
+	if ( ret < 0 ) {
+		sieve_sys_error(
+			"o_stream_send() failed on logfile %s: %m", ehandler->logfile);		
+	}
+}
+
+inline static void sieve_logfile_printf
+(struct sieve_logfile_ehandler *ehandler, const char *location, const char *prefix,
+	const char *fmt, ...) 
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	sieve_logfile_vprintf(ehandler, location, prefix, fmt, args);
+	
+	va_end(args);
+}
+
+static void sieve_logfile_start(struct sieve_logfile_ehandler *ehandler)
+{
+	int fd;
+	struct ostream *ostream = NULL;
+	struct stat st;
+	struct tm *tm;
+	char buf[256];
+	time_t now;
+
+	/* Open the logfile */
+
+	fd = open(ehandler->logfile, O_CREAT | O_APPEND | O_WRONLY, 0600);
+	if (fd == -1) {
+		sieve_sys_error("failed to open logfile %s (logging to STDERR): %m", 
+			ehandler->logfile);
+		fd = STDERR_FILENO;
+	} else {
+		/* fd_close_on_exec(fd, TRUE); Necessary? */
+
+		/* Stat the log file to obtain size information */
+		if ( fstat(fd, &st) != 0 ) {
+			sieve_sys_error(
+				"failed to fstat opened logfile %s (logging to STDERR): %m", 
+				ehandler->logfile);
+			
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("close(fd) failed for logfile '%s': %m",
+					ehandler->logfile);
+			}
+
+			fd = STDERR_FILENO;
+		}
+		
+		/* Rotate log when it has grown too large */
+		if ( st.st_size >= LOGFILE_MAX_SIZE ) {
+			const char *rotated;
+			
+			/* Close open file */
+			if ( close(fd) < 0 ) {
+				sieve_sys_error("close(fd) failed for logfile '%s': %m",
+					ehandler->logfile);
+			}
+			
+			/* Rotate logfile */
+			rotated = t_strconcat(ehandler->logfile, ".0", NULL);
+			if ( rename(ehandler->logfile, rotated) < 0 ) {
+				sieve_sys_error(
+					"failed to rename logfile %s to %s: %m", 
+					ehandler->logfile, rotated);
+			}
+			
+			/* Open clean logfile (overwrites existing if rename() failed earlier) */
+			fd = open(ehandler->logfile, O_CREAT | O_WRONLY | O_TRUNC, 0600);
+			if (fd == -1) {
+				sieve_sys_error("failed to open logfile %s (logging to STDERR): %m", 
+					ehandler->logfile);
+				fd = STDERR_FILENO;
+			}
+		}
+	}
+
+	ostream = o_stream_create_fd(fd, 0, FALSE);
+	if ( ostream == NULL ) {
+		/* Can't we do anything else in this most awkward situation? */
+		sieve_sys_error("failed to open log stream on open file %s: "
+			"non-critical messages will not be logged!", ehandler->logfile);
+	} 
+
+	ehandler->fd = fd;
+	ehandler->stream = ostream;
+	ehandler->started = TRUE;
+	
+	if ( ostream != NULL ) {
+		now = time(NULL);	
+		tm = localtime(&now);
+
+		if (strftime(buf, sizeof(buf), "%b %d %H:%M:%S", tm) > 0) {
+			sieve_logfile_printf(ehandler, "sieve", "info",
+				"started log at %s", buf);
+		}
+	}
+}
+
+static void sieve_logfile_verror
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "error", fmt, args);
+}
+
+static void sieve_logfile_vwarning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "warning", fmt, args);
+}
+
+static void sieve_logfile_vinfo
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, va_list args) 
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+
+	if ( !handler->started ) sieve_logfile_start(handler);	
+
+	sieve_logfile_vprintf(handler, location, "info", fmt, args);
+}
+
+static void sieve_logfile_free
+(struct sieve_error_handler *ehandler)
+{
+	struct sieve_logfile_ehandler *handler = 
+		(struct sieve_logfile_ehandler *) ehandler;
+		
+	if ( handler->stream != NULL ) {
+		o_stream_destroy(&(handler->stream));
+		if ( handler->fd != STDERR_FILENO ){
+			if ( close(handler->fd) < 0 ) {
+				sieve_sys_error("close(fd) failed for logfile '%s': %m",
+					handler->logfile);
+			}
+		}
+	}
+}
+
+struct sieve_error_handler *sieve_logfile_ehandler_create
+(const char *logfile, unsigned int max_errors) 
+{
+	pool_t pool;
+	struct sieve_logfile_ehandler *ehandler;
+	
+	pool = pool_alloconly_create("logfile_error_handler", 256);	
+	ehandler = p_new(pool, struct sieve_logfile_ehandler, 1);
+	sieve_error_handler_init(&ehandler->handler, pool, max_errors);
+
+	ehandler->handler.verror = sieve_logfile_verror;
+	ehandler->handler.vwarning = sieve_logfile_vwarning;
+	ehandler->handler.vinfo = sieve_logfile_vinfo;
+	ehandler->handler.free = sieve_logfile_free;
+	
+	/* Don't open logfile until something is actually logged. 
+	 * Let's not pullute the sieve directory with useless logfiles.
+	 */
+	ehandler->logfile = p_strdup(pool, logfile);
+	ehandler->started = FALSE;
+	ehandler->stream = NULL;
+	ehandler->fd = -1;
+	
+	return &(ehandler->handler);	
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-error.h dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-error.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-error.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-error.h	2009-06-28 15:57:42.000000000 +0200
@@ -0,0 +1,165 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_H
+#define __SIEVE_ERROR_H
+
+#include "lib.h"
+#include "compat.h"
+
+#include <stdarg.h>
+
+/*
+ * Forward declarations
+ */
+
+struct sieve_script;
+struct sieve_error_handler;
+
+/*
+ * Types
+ */
+
+typedef void (*sieve_error_vfunc_t)
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+
+/*
+ * System errors
+ *
+ * FIXME: Low-level access to the Dovecot logging functions would be useful.
+ */
+
+#define sieve_sys_error(...) i_error("sieve: " __VA_ARGS__ )
+#define sieve_sys_warning(...) i_warning("sieve: " __VA_ARGS__ )
+#define sieve_sys_info(...) i_info("sieve: " __VA_ARGS__ )
+
+/*
+ * Main error functions
+ */
+
+/* For these functions it is the responsibility of the caller to
+ * manage the datastack.
+ */
+
+const char *sieve_error_script_location
+	(const struct sieve_script *script, unsigned int source_line);
+
+void sieve_verror
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args);
+void sieve_vwarning
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vinfo
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+void sieve_vcritical
+	(struct sieve_error_handler *ehandler, const char *location, 
+		const char *fmt, va_list args); 
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...) ATTR_FORMAT(3, 4);
+
+inline static void sieve_error
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_verror(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_warning
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vwarning(ehandler, location, fmt, args); } T_END;
+
+	va_end(args);
+}
+
+inline static void sieve_info
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vinfo(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+inline static void sieve_critical
+(struct sieve_error_handler *ehandler, const char *location, 
+	const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	
+	T_BEGIN { sieve_vcritical(ehandler, location, fmt, args); } T_END;
+	
+	va_end(args);
+}
+
+/*
+ * Error handler configuration
+ */
+
+void sieve_error_handler_accept_infolog
+	(struct sieve_error_handler *ehandler, bool enable);
+void sieve_error_handler_copy_masterlog
+	(struct sieve_error_handler *ehandler, bool enable);
+
+/*
+ * Error handler statistics
+ */
+
+unsigned int sieve_get_errors(struct sieve_error_handler *ehandler);
+unsigned int sieve_get_warnings(struct sieve_error_handler *ehandler);
+
+bool sieve_errors_more_allowed(struct sieve_error_handler *ehandler);
+
+/*
+ * Error handler object
+ */
+
+void sieve_error_handler_ref(struct sieve_error_handler *ehandler);
+void sieve_error_handler_unref(struct sieve_error_handler **ehandler);
+
+void sieve_error_handler_reset(struct sieve_error_handler *ehandler);
+
+/* 
+ * Error handlers 
+ */
+
+/* Write errors to stderr */
+struct sieve_error_handler *sieve_stderr_ehandler_create
+	(unsigned int max_errors);
+
+/* Write errors into a string buffer */
+struct sieve_error_handler *sieve_strbuf_ehandler_create
+	(string_t *strbuf, bool crlf, unsigned int max_errors);
+
+/* Write errors to a logfile */
+struct sieve_error_handler *sieve_logfile_ehandler_create
+	(const char *logfile, unsigned int max_errors);  
+
+#endif /* __SIEVE_ERROR_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-error-private.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,43 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_ERROR_PRIVATE_H
+#define __SIEVE_ERROR_PRIVATE_H
+
+#include "sieve-error.h"
+
+struct sieve_error_handler {
+	pool_t pool;
+	int refcount;
+	
+	unsigned int max_errors;
+
+	unsigned int errors;
+	unsigned int warnings;
+
+	/* Should we copy log to i_error, i_warning and i_info? */
+	bool log_master;
+
+	/* Should the errorhandler handle or discard info log?
+	 * (This does not influence the previous setting)
+	 */
+	bool log_info;
+
+	void (*verror)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vwarning)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+	void (*vinfo)
+		(struct sieve_error_handler *ehandler, const char *location,
+			const char *fmt, va_list args);
+
+	void (*free)
+		(struct sieve_error_handler *ehandler);
+};
+
+void sieve_error_handler_init
+	(struct sieve_error_handler *ehandler, pool_t pool, unsigned int max_errors);
+
+#endif /* __SIEVE_ERROR_PRIVATE_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve.h dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,25 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_H
+#define __SIEVE_H
+
+#include "lib.h"
+
+#include <stdio.h>
+
+struct sieve_binary;
+struct sieve_script;
+
+#include "sieve-error.h"
+
+bool sieve_init(void);
+void sieve_deinit(void);
+
+struct sieve_binary *sieve_compile_script
+    (struct sieve_script *script, struct sieve_error_handler *ehandler);
+
+void sieve_set_extensions(const char *extensions);
+const char *sieve_get_capabilities(const char *name);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-script.c dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-script.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-script.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-script.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,320 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "compat.h"
+#include "istream.h"
+
+#include "sieve-common.h"
+#include "sieve-error.h"
+
+#include "sieve-script-private.h"
+
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/*
+ * Configuration
+ */
+ 
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+/*
+ * Filename to name/name to filename
+ */
+
+static inline const char *_sieve_scriptfile_get_basename(const char *filename)
+{
+	const char *ext;
+
+	/* Extract the script name */
+	ext = strrchr(filename, '.');
+	if ( ext == NULL || ext == filename || strncmp(ext,".sieve",6) != 0 )
+		return filename;
+	
+	return t_strdup_until(filename, ext);	
+}
+
+static inline const char *_sieve_scriptfile_from_name(const char *name)
+{
+ 	const char *ext;
+
+ 	/* See if it ends in .sieve already */
+	ext = strrchr(name, '.');
+	if ( ext == NULL || ext == name || strncmp(ext,".sieve",6) != 0 )
+		return t_strconcat(name, ".sieve", NULL);
+
+	return name;
+}
+
+/* 
+ * Script object 
+ */
+ 
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	int ret;
+	pool_t pool;
+	struct stat st;
+	struct stat lnk_st;
+	const char *filename, *dirpath, *basename;
+
+	if ( exists_r != NULL )
+		*exists_r = TRUE;
+
+	T_BEGIN {
+
+		/* Extract filename from path */
+
+		filename = strrchr(path, '/');
+		if ( filename == NULL ) {
+			dirpath = "";
+			filename = path;
+		} else {
+			dirpath = t_strdup_until(path, filename);
+			filename++;
+		}
+		
+		if ( name == NULL || *name == '\0' ) {
+			basename = _sieve_scriptfile_get_basename(filename);
+		} else {
+			basename = name;
+		}
+			
+		/* First obtain stat data from the system */
+		
+		if ( (ret=lstat(path, &st)) < 0 ) {
+			if ( errno == ENOENT ) {
+				if ( exists_r == NULL ) 
+					sieve_error(ehandler, basename, "sieve script does not exist");
+				else
+					*exists_r = FALSE;
+			} else
+				sieve_critical(ehandler, basename, 
+					"failed to lstat sieve script file '%s': %m", path);
+
+			script = NULL;
+			ret = 1;
+
+		} else {
+			/* Record stat information from the symlink */
+			lnk_st = st;
+
+			/* Only create/init the object if it stat()s without problems */
+			if (S_ISLNK(st.st_mode)) {
+				if ( (ret=stat(path, &st)) < 0 ) { 
+					if ( errno == ENOENT ) {
+						if ( exists_r == NULL )
+							sieve_error(ehandler, basename, "sieve script does not exist");
+						else
+							*exists_r = FALSE;
+					} else
+						sieve_critical(ehandler, basename, 
+							"failed to stat sieve script file '%s': %m", path);
+
+					script = NULL;	
+					ret = 1;
+				}
+			}
+
+			if ( ret == 0 && !S_ISREG(st.st_mode) ) {
+				sieve_critical(ehandler, basename, 
+					"sieve script file '%s' is not a regular file.", path);
+				script = NULL;
+				ret = 1;
+			} 
+		}
+
+		if ( ret <= 0 ) {
+			if ( script == NULL ) {
+				pool = pool_alloconly_create("sieve_script", 1024);
+				script = p_new(pool, struct sieve_script, 1);
+				script->pool = pool;
+			} else 
+				pool = script->pool;
+		
+			script->refcount = 1;
+			script->ehandler = ehandler;
+			sieve_error_handler_ref(ehandler);
+		
+			script->st = st;
+			script->lnk_st = lnk_st;
+			script->path = p_strdup(pool, path);
+			script->filename = p_strdup(pool, filename);
+			script->dirpath = p_strdup(pool, dirpath);
+			script->basename = p_strdup(pool, basename);
+
+			if ( name != NULL )
+				script->name = p_strdup(pool, name);
+			else
+				script->name = NULL;
+		}
+	} T_END;	
+
+	return script;
+}
+
+struct sieve_script *sieve_script_create
+(const char *path, const char *name, 
+	struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+struct sieve_script *sieve_script_create_in_directory
+(const char *dirpath, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r)
+{
+	const char *path;
+
+	if ( dirpath[strlen(dirpath)-1] == '/' )
+		path = t_strconcat(dirpath, 
+			_sieve_scriptfile_from_name(name), NULL);
+	else
+		path = t_strconcat(dirpath, "/",
+			_sieve_scriptfile_from_name(name), NULL);
+
+    return sieve_script_init(NULL, path, name, ehandler, exists_r);
+}
+
+void sieve_script_ref(struct sieve_script *script)
+{
+	script->refcount++;
+}
+
+void sieve_script_unref(struct sieve_script **script)
+{
+	i_assert((*script)->refcount > 0);
+
+	if (--(*script)->refcount != 0)
+		return;
+
+	if ( (*script)->stream != NULL )
+		i_stream_destroy(&(*script)->stream);
+
+	sieve_error_handler_unref(&(*script)->ehandler);
+
+	pool_unref(&(*script)->pool);
+
+	*script = NULL;
+}
+
+/* 
+ * Accessors 
+ */
+
+const char *sieve_script_name(const struct sieve_script *script)
+{
+	return script->name;
+}
+
+const char *sieve_script_filename(const struct sieve_script *script)
+{
+	return script->filename;
+}
+
+const char *sieve_script_path(const struct sieve_script *script)
+{
+	return script->path;
+}
+
+const char *sieve_script_dirpath(const struct sieve_script *script)
+{
+	return script->dirpath;
+}
+
+const char *sieve_script_binpath(const struct sieve_script *script)
+{
+	return t_strconcat(script->dirpath, "/", script->basename, ".svbin", NULL);
+}
+
+/* 
+ * Stream manageement 
+ */
+
+struct istream *sieve_script_open
+(struct sieve_script *script, bool *deleted_r)
+{
+	int fd;
+	struct stat st;
+	struct istream *result;
+
+	if ( deleted_r != NULL )
+		*deleted_r = FALSE;
+
+	if ( (fd=open(script->path, O_RDONLY)) < 0 ) {
+		if ( errno == ENOENT ) 
+			if ( deleted_r == NULL ) 
+				/* Not supposed to occur, create() does stat already */
+				sieve_error(script->ehandler, script->basename, 
+					"sieve script does not exist");
+			else 
+				*deleted_r = TRUE;
+		else
+			sieve_critical(script->ehandler, script->path, 
+				"failed to open sieve script: %m");
+		return NULL;
+	}	
+	
+	if ( fstat(fd, &st) != 0 ) {
+		sieve_critical(script->ehandler, script->path, 
+			"failed to fstat opened sieve script: %m");
+		result = NULL;
+	} else {
+		/* Re-check the file type just to be sure */
+		if ( !S_ISREG(st.st_mode) ) {
+			sieve_critical(script->ehandler, script->path,
+				"opened sieve script file is not a regular file");
+			result = NULL;
+		} else {
+			result = script->stream = 
+				i_stream_create_fd(fd, SIEVE_READ_BLOCK_SIZE, TRUE);
+			script->st = script->lnk_st = st;
+		}
+	}
+
+	if ( result == NULL ) {
+		/* Something went wrong, close the fd */
+		if ( close(fd) != 0 ) {
+			sieve_sys_error(
+				"close(fd) failed for sieve script %s: %m", 
+				script->path);
+		}
+	}
+	
+	return result;
+}
+
+void sieve_script_close(struct sieve_script *script)
+{
+	i_stream_destroy(&script->stream);
+}
+
+uoff_t sieve_script_get_size(const struct sieve_script *script)
+{
+	return script->st.st_size;
+}
+
+/* 
+ * Comparison 
+ */
+
+int sieve_script_cmp
+(const struct sieve_script *script1, const struct sieve_script *script2)
+{	
+	return ( script1->st.st_ino == script2->st.st_ino ) ? 0 : -1;
+}
+
+unsigned int sieve_script_hash(const struct sieve_script *script)
+{	
+	return (unsigned int) script->st.st_ino;
+}
+
+bool sieve_script_older
+(const struct sieve_script *script, time_t time)
+{
+	return ( script->st.st_mtime < time && script->lnk_st.st_mtime < time );
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-script.h dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-script.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-script.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-script.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,60 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_H
+#define __SIEVE_SCRIPT_H
+
+#include "sieve-common.h"
+
+/*
+ * Sieve script object
+ */
+
+struct sieve_script;
+
+struct sieve_script *sieve_script_create
+	(const char *path, const char *name, 
+		struct sieve_error_handler *ehandler, bool *exists_r);
+
+struct sieve_script *sieve_script_create_in_directory
+	(const char *dirpath, const char *name,
+    	struct sieve_error_handler *ehandler, bool *exists_r);
+
+void sieve_script_ref(struct sieve_script *script);
+void sieve_script_unref(struct sieve_script **script);
+
+/*
+ * Accessors
+ */
+ 
+const char *sieve_script_name(const struct sieve_script *script);
+const char *sieve_script_filename(const struct sieve_script *script);
+const char *sieve_script_path(const struct sieve_script *script);
+const char *sieve_script_binpath(const struct sieve_script *script);
+const char *sieve_script_dirpath(const struct sieve_script *script);
+
+/* 
+ * Stream management 
+ */
+
+struct istream *sieve_script_open(struct sieve_script *script, bool *deleted_r);
+void sieve_script_close(struct sieve_script *script);
+
+uoff_t sieve_script_get_size(const struct sieve_script *script);
+
+/*
+ * Comparison
+ */
+ 
+int sieve_script_cmp
+	(const struct sieve_script *script1, const struct sieve_script *script2);
+unsigned int sieve_script_hash(const struct sieve_script *script);
+bool sieve_script_older(const struct sieve_script *script, time_t time);
+
+static inline bool sieve_script_equals
+	(const struct sieve_script *script1, const struct sieve_script *script2)
+{
+	return ( sieve_script_cmp(script1, script2) == 0 );
+}
+
+#endif /* __SIEVE_SCRIPT_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-cmusieve/sieve-script-private.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,39 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SCRIPT_PRIVATE_H
+#define __SIEVE_SCRIPT_PRIVATE_H
+
+#include "sieve-script.h"
+
+/*
+ * Script object
+ */
+
+struct sieve_script {
+	pool_t pool;
+	unsigned int refcount;
+
+	struct stat st;
+	struct stat lnk_st;
+	time_t mtime;
+
+	struct sieve_error_handler *ehandler;
+
+	/* Parameters */
+	const char *name;
+	const char *basename;
+	const char *filename;
+	const char *dirpath;
+	const char *path;
+
+	/* Stream */
+	int fd; /* FIXME: we could use the stream's autoclose facility */
+	struct istream *stream;
+};
+
+struct sieve_script *sieve_script_init
+(struct sieve_script *script, const char *path, const char *name,
+    struct sieve_error_handler *ehandler, bool *exists_r);
+
+#endif /* __SIEVE_SCRIPT_PRIVATE_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/Makefile.am dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/Makefile.am	2008-07-18 12:09:52.000000000 +0200
@@ -0,0 +1,15 @@
+noinst_LIBRARIES = libmanagesieve.a
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-charset \
+	-I$(dovecot_incdir)/src/lib-mail
+
+libmanagesieve_a_SOURCES = \
+	managesieve-quote.c \
+	managesieve-parser.c 
+
+noinst_HEADERS = \
+	managesieve-quote.h \
+	managesieve-parser.h 
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/Makefile.in dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/Makefile.in
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/Makefile.in	2009-08-21 01:05:44.000000000 +0200
@@ -0,0 +1,465 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-managesieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libmanagesieve_a_AR = $(AR) $(ARFLAGS)
+libmanagesieve_a_LIBADD =
+am_libmanagesieve_a_OBJECTS = managesieve-quote.$(OBJEXT) \
+	managesieve-parser.$(OBJEXT)
+libmanagesieve_a_OBJECTS = $(am_libmanagesieve_a_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libmanagesieve_a_SOURCES)
+DIST_SOURCES = $(libmanagesieve_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SIEVE_PLUGIN_TOP = @SIEVE_PLUGIN_TOP@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LIBRARIES = libmanagesieve.a
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-charset \
+	-I$(dovecot_incdir)/src/lib-mail
+
+libmanagesieve_a_SOURCES = \
+	managesieve-quote.c \
+	managesieve-parser.c 
+
+noinst_HEADERS = \
+	managesieve-quote.h \
+	managesieve-parser.h 
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-managesieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-managesieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libmanagesieve.a: $(libmanagesieve_a_OBJECTS) $(libmanagesieve_a_DEPENDENCIES) 
+	-rm -f libmanagesieve.a
+	$(libmanagesieve_a_AR) libmanagesieve.a $(libmanagesieve_a_OBJECTS) $(libmanagesieve_a_LIBADD)
+	$(RANLIB) libmanagesieve.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-parser.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-quote.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-parser.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,675 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "istream.h"
+#include "ostream.h"
+#include "strescape.h"
+#include "managesieve-parser.h"
+
+#define is_linebreak(c) \
+	((c) == '\r' || (c) == '\n')
+
+#define LIST_ALLOC_SIZE 7
+
+enum arg_parse_type {
+	ARG_PARSE_NONE = 0,
+	ARG_PARSE_ATOM,
+	ARG_PARSE_STRING,
+	ARG_PARSE_LITERAL,
+	ARG_PARSE_LITERAL_DATA
+};
+
+struct managesieve_parser {
+	/* permanent */
+	pool_t pool;
+	struct istream *input;
+	struct ostream *output;
+	size_t max_line_size;
+	enum managesieve_parser_flags flags;
+
+	/* reset by managesieve_parser_reset(): */
+	size_t line_size;
+	struct managesieve_arg_list *root_list;
+	struct managesieve_arg_list *cur_list;
+
+	enum arg_parse_type cur_type;
+	size_t cur_pos; /* parser position in input buffer */
+
+	int str_first_escape; /* ARG_PARSE_STRING: index to first '\' */
+	uoff_t literal_size; /* ARG_PARSE_LITERAL: string size */
+
+	const char *error;
+
+	unsigned int literal_skip_crlf:1;
+	unsigned int literal_nonsync:1;
+	unsigned int eol:1;
+	unsigned int fatal_error:1;
+};
+
+/* @UNSAFE */
+#define LIST_REALLOC(parser, old_list, new_size) \
+	p_realloc((parser)->pool, old_list, \
+		  sizeof(struct managesieve_arg_list) + \
+		  (old_list == NULL ? 0 : \
+		   sizeof(struct managesieve_arg_list) * (old_list)->alloc), \
+		  sizeof(struct managesieve_arg_list) * (new_size))
+
+static void managesieve_args_realloc(struct managesieve_parser *parser, size_t size)
+{
+	parser->cur_list = LIST_REALLOC(parser, parser->cur_list, size);
+	parser->cur_list->alloc = size;
+
+  parser->root_list = parser->cur_list;
+}
+
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size)
+{
+	struct managesieve_parser *parser;
+
+	parser = i_new(struct managesieve_parser, 1);
+        parser->pool = pool_alloconly_create("MANAGESIEVE parser", 8192);
+	parser->input = input;
+	parser->output = output;
+	parser->max_line_size = max_line_size;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+	return parser;
+}
+
+void managesieve_parser_destroy(struct managesieve_parser **parser)
+{
+	pool_unref(&(*parser)->pool);
+	i_free(*parser);
+	*parser = NULL;
+}
+
+void managesieve_parser_reset(struct managesieve_parser *parser)
+{
+	p_clear(parser->pool);
+
+	parser->line_size = 0;
+
+	parser->root_list = NULL;
+	parser->cur_list = NULL;
+
+	parser->cur_type = ARG_PARSE_NONE;
+	parser->cur_pos = 0;
+
+	parser->str_first_escape = 0;
+	parser->literal_size = 0;
+
+	parser->error = NULL;
+
+	parser->literal_skip_crlf = FALSE;
+	parser->eol = FALSE;
+
+	managesieve_args_realloc(parser, LIST_ALLOC_SIZE);
+}
+
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal)
+{
+	*fatal = parser->fatal_error;
+	return parser->error;
+}
+
+/* skip over everything parsed so far, plus the following whitespace */
+static int managesieve_parser_skip_to_next(struct managesieve_parser *parser,
+				    const unsigned char **data,
+				    size_t *data_size)
+{
+	size_t i;
+
+	for (i = parser->cur_pos; i < *data_size; i++) {
+		if ((*data)[i] != ' ')
+			break;
+	}
+
+	parser->line_size += i;
+	i_stream_skip(parser->input, i);
+	parser->cur_pos = 0;
+
+	*data += i;
+	*data_size -= i;
+	return *data_size > 0;
+}
+
+static struct managesieve_arg *managesieve_arg_create(struct managesieve_parser *parser)
+{
+	struct managesieve_arg *arg;
+
+	i_assert(parser->cur_list != NULL);
+
+	/* @UNSAFE */
+	if (parser->cur_list->size == parser->cur_list->alloc)
+		managesieve_args_realloc(parser, parser->cur_list->alloc * 2);
+
+	arg = &parser->cur_list->args[parser->cur_list->size];
+	parser->cur_list->size++;
+
+	return arg;
+}
+
+static void managesieve_parser_save_arg(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t size)
+{
+	struct managesieve_arg *arg;
+
+	arg = managesieve_arg_create(parser);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		/* simply save the string */
+		arg->type = MANAGESIEVE_ARG_ATOM;
+		arg->_data.str = p_strndup(parser->pool, data, size);
+		break;
+	case ARG_PARSE_STRING:
+		/* data is quoted and may contain escapes. */
+		i_assert(size > 0);
+
+		arg->type = MANAGESIEVE_ARG_STRING;
+		arg->_data.str = p_strndup(parser->pool, data+1, size-1);
+
+		/* remove the escapes */
+		if (parser->str_first_escape >= 0 &&
+		    (parser->flags & MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE) == 0) {
+			/* -1 because we skipped the '"' prefix */
+			str_unescape(arg->_data.str +
+				     parser->str_first_escape-1);
+		}
+		break;
+	case ARG_PARSE_LITERAL_DATA:
+		if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) != 0) {
+			/* save literal size */
+			arg->type = MANAGESIEVE_ARG_LITERAL_SIZE;
+			arg->_data.literal_size = parser->literal_size;
+		} else if ((parser->flags &
+			    MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE) != 0) {
+			arg->type = MANAGESIEVE_ARG_LITERAL;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		} else {
+			arg->type = MANAGESIEVE_ARG_STRING;
+			arg->_data.str = p_strndup(parser->pool, data, size);
+		}
+		break;
+	default:
+		i_unreached();
+	}
+
+	parser->cur_type = ARG_PARSE_NONE;
+}
+
+static int is_valid_atom_char(struct managesieve_parser *parser, char chr)
+{
+	if (IS_ATOM_SPECIAL((unsigned char)chr)) {
+		parser->error = "Invalid characters in atom";
+		return FALSE;
+	} else if ((chr & 0x80) != 0) {
+		parser->error = "8bit data in atom";
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static int managesieve_parser_read_atom(struct managesieve_parser *parser,
+				 const unsigned char *data, size_t data_size)
+{
+	size_t i;
+
+	/* read until we've found space, CR or LF. */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == ')' ||
+			 is_linebreak(data[i])) {
+			managesieve_parser_save_arg(parser, data, i);
+			break;
+		} else if (!is_valid_atom_char(parser, data[i]))
+			return FALSE;
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_read_string(struct managesieve_parser *parser,
+				   const unsigned char *data, size_t data_size)
+{
+	size_t i;
+	int utf8_len;
+
+	/* QUOTED-CHAR        = SAFE-UTF8-CHAR / "\" QUOTED-SPECIALS
+	 * quoted             = <"> *QUOTED-CHAR <">
+	 *                    ;; limited to 1024 octets between the <">s
+	 */
+
+	/* read until we've found non-escaped ", CR or LF */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '"') {
+			managesieve_parser_save_arg(parser, data, i);
+
+			i++; /* skip the trailing '"' too */
+			break;
+		}
+
+		if (data[i] == '\\') {
+			if (i+1 == data_size) {
+				/* known data ends with '\' - leave it to
+				   next time as well if it happens to be \" */
+				break;
+			}
+
+			/* save the first escaped char */
+			if (parser->str_first_escape < 0)
+				parser->str_first_escape = i;
+
+			/* skip the escaped char */
+			i++;
+
+			if ( !IS_QUOTED_SPECIAL(data[i]) ) {
+				parser->error = "Escaped quoted-string character is not a QUOTED-SPECIAL.";
+				return FALSE;
+			}
+
+			continue;
+		}
+
+		/* Enforce valid UTF-8
+		 */
+		if ( (utf8_len = UTF8_LEN(data[i])) == 0 ) {
+			parser->error = "String contains invalid character.";
+			return FALSE;
+		}
+		
+		if ( utf8_len > 1 ) {
+			bool overlong = FALSE;
+
+			if ( (i+utf8_len-1) >= data_size ) {
+				/* Known data ends in the middle of a UTF-8 character;
+				 * leave it to next time.
+				 */
+				break;
+			}
+
+			/* Check for overlong UTF-8 sequences */
+			switch (utf8_len) {
+			case 2:
+				if (!(data[i] & 0x1E)) overlong = TRUE;
+				break;
+			case 3:	
+				if (!(data[i] & 0x0F) && !(data[i+1] & 0x20)) overlong = TRUE;
+				break;
+			case 4:
+				if (!(data[i] & 0x07) && !(data[i+1] & 0x30)) overlong = TRUE;				
+				break;
+			case 5:
+				if (!(data[i] & 0x03) && !(data[i+1] & 0x38)) overlong = TRUE;
+				break;				
+			case 6:
+				if (!(data[i] & 0x01) && !(data[i+1] & 0x3C)) overlong = TRUE;
+				break;				
+			default:
+				i_unreached();
+			} 
+
+			if ( overlong ) {
+				parser->error = "String contains invalid/overlong UTF-8 character.";
+				return FALSE;
+			}
+
+			i++;
+			utf8_len--;
+	
+			/* Parse the series of UTF8_1 characters */
+			for (; utf8_len > 0; utf8_len--, i++ ) {  
+				if (!IS_UTF8_1(data[i])) {
+					parser->error = "String contains invalid UTF-8 character.";
+			    return FALSE;
+				}
+			}
+		}
+	}
+
+	parser->cur_pos = i;
+	return parser->cur_type == ARG_PARSE_NONE;
+}
+
+static int managesieve_parser_literal_end(struct managesieve_parser *parser)
+{
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		if (parser->line_size >= parser->max_line_size ||
+		    parser->literal_size >
+		    	parser->max_line_size - parser->line_size) {
+			/* too long string, abort. */
+			parser->error = "Literal size too large";
+			parser->fatal_error = TRUE;
+			return FALSE;
+		}
+	}
+
+	parser->cur_type = ARG_PARSE_LITERAL_DATA;
+	parser->literal_skip_crlf = TRUE;
+
+	parser->cur_pos = 0;
+	return TRUE;
+}
+
+static int managesieve_parser_read_literal(struct managesieve_parser *parser,
+				    const unsigned char *data,
+				    size_t data_size)
+{
+	size_t i, prev_size;
+
+	/* expecting digits + "}" */
+	for (i = parser->cur_pos; i < data_size; i++) {
+		if (data[i] == '}') {
+			parser->line_size += i+1;
+			i_stream_skip(parser->input, i+1);
+
+			return managesieve_parser_literal_end(parser);
+		}
+
+		if (parser->literal_nonsync) {
+			parser->error = "Expecting '}' after '+'";
+			return FALSE;
+		}
+
+		if (data[i] == '+') {
+			parser->literal_nonsync = TRUE;
+			continue;
+		}
+
+		if (data[i] < '0' || data[i] > '9') {
+			parser->error = "Invalid literal size";
+			return FALSE;
+		}
+
+		prev_size = parser->literal_size;
+		parser->literal_size = parser->literal_size*10 + (data[i]-'0');
+
+		if (parser->literal_size < prev_size) {
+			/* wrapped around, abort. */
+			parser->error = "Literal size too large";
+			return FALSE;
+		}
+	}
+
+	parser->cur_pos = i;
+	return FALSE;
+}
+
+static int managesieve_parser_read_literal_data(struct managesieve_parser *parser,
+					 const unsigned char *data,
+					 size_t data_size)
+{
+	if (parser->literal_skip_crlf) {
+
+		/* skip \r\n or \n, anything else gives an error */
+		if (data_size == 0)
+			return FALSE;
+
+		if (*data == '\r') {
+			parser->line_size++;
+			data++; data_size--;
+			i_stream_skip(parser->input, 1);
+
+			if (data_size == 0)
+				return FALSE;
+		}
+
+		if (*data != '\n') {
+			parser->error = "Missing LF after literal size";
+			return FALSE;
+		}
+
+		parser->line_size++;
+		data++; data_size--;
+		i_stream_skip(parser->input, 1);
+
+		parser->literal_skip_crlf = FALSE;
+
+		i_assert(parser->cur_pos == 0);
+	}
+
+	if ((parser->flags & MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE) == 0) {
+		/* now we just wait until we've read enough data */
+		if (data_size < parser->literal_size) {
+			return FALSE;
+		} else {
+			managesieve_parser_save_arg(parser, data,
+					     (size_t)parser->literal_size);
+			parser->cur_pos = (size_t)parser->literal_size;
+			return TRUE;
+		}
+	} else {
+		/* we want to save only literal size, not the literal itself. */
+		parser->eol = TRUE;
+		managesieve_parser_save_arg(parser, NULL, 0);
+		return TRUE;
+	}
+}
+
+/* Returns TRUE if argument was fully processed. Also returns TRUE if
+   an argument inside a list was processed. */
+static int managesieve_parser_read_arg(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+	if (data_size == 0)
+		return FALSE;
+
+	while (parser->cur_type == ARG_PARSE_NONE) {
+		/* we haven't started parsing yet */
+		if (!managesieve_parser_skip_to_next(parser, &data, &data_size))
+			return FALSE;
+		i_assert(parser->cur_pos == 0);
+
+		switch (data[0]) {
+		case '\r':
+		case '\n':
+			/* unexpected end of line */
+			parser->eol = TRUE;
+			return FALSE;
+		case '"':
+			parser->cur_type = ARG_PARSE_STRING;
+			parser->str_first_escape = -1;
+			break;
+		case '{':
+			parser->cur_type = ARG_PARSE_LITERAL;
+			parser->literal_size = 0;
+			parser->literal_nonsync = FALSE;
+			break;
+		default:
+			if (!is_valid_atom_char(parser, data[0]))
+				return FALSE;
+			parser->cur_type = ARG_PARSE_ATOM;
+			break;
+		}
+
+		parser->cur_pos++;
+	}
+
+	i_assert(data_size > 0);
+
+	switch (parser->cur_type) {
+	case ARG_PARSE_ATOM:
+		if (!managesieve_parser_read_atom(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_STRING:
+		if (!managesieve_parser_read_string(parser, data, data_size))
+			return FALSE;
+		break;
+	case ARG_PARSE_LITERAL:
+		if (!managesieve_parser_read_literal(parser, data, data_size))
+			return FALSE;
+
+		/* pass through to parsing data. since input->skip was
+		   modified, we need to get the data start position again. */
+		data = i_stream_get_data(parser->input, &data_size);
+
+		/* fall through */
+	case ARG_PARSE_LITERAL_DATA:
+		if (!managesieve_parser_read_literal_data(parser, data, data_size))
+			return FALSE;
+		break;
+	default:
+		i_unreached();
+	}
+
+	i_assert(parser->cur_type == ARG_PARSE_NONE);
+	return TRUE;
+}
+
+/* ARG_PARSE_NONE checks that last argument isn't only partially parsed. */
+#define IS_UNFINISHED(parser) \
+        ((parser)->cur_type != ARG_PARSE_NONE || \
+	 (parser)->cur_list != parser->root_list)
+
+static int finish_line(struct managesieve_parser *parser, unsigned int count,
+		       struct managesieve_arg **args)
+{
+	parser->line_size += parser->cur_pos;
+	i_stream_skip(parser->input, parser->cur_pos);
+	parser->cur_pos = 0;
+
+	if (count >= parser->root_list->alloc) {
+		/* unused arguments must be NIL-filled. */
+		parser->root_list =
+			LIST_REALLOC(parser, parser->root_list, count+1);
+		parser->root_list->alloc = count+1;
+	}
+
+	parser->root_list->args[parser->root_list->size].type = MANAGESIEVE_ARG_EOL;
+
+	*args = parser->root_list->args;
+	return parser->root_list->size;
+}
+
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args)
+{
+	parser->flags = flags;
+
+	while (!parser->eol && (count == 0 || parser->root_list->size < count ||
+				IS_UNFINISHED(parser))) {
+		if (!managesieve_parser_read_arg(parser))
+			break;
+
+		if (parser->line_size > parser->max_line_size) {
+			parser->error = "MANAGESIEVE command line too large";
+			break;
+		}
+	}
+
+	if (parser->error != NULL) {
+		/* error, abort */
+		parser->line_size += parser->cur_pos;
+		i_stream_skip(parser->input, parser->cur_pos);
+		parser->cur_pos = 0;
+		*args = NULL;
+		return -1;
+	} else if ((!IS_UNFINISHED(parser) && count > 0 &&
+		    parser->root_list->size >= count) || parser->eol) {
+		/* all arguments read / end of line. */
+                return finish_line(parser, count, args);
+	} else {
+		/* need more data */
+		*args = NULL;
+		return -2;
+	}
+}
+
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args)
+{
+	const unsigned char *data;
+	size_t data_size;
+	int ret;
+
+	ret = managesieve_parser_read_args(parser, count, flags, args);
+	if (ret == -2) {
+		/* we should have noticed end of everything except atom */
+		if (parser->cur_type == ARG_PARSE_ATOM) {
+			data = i_stream_get_data(parser->input, &data_size);
+			managesieve_parser_save_arg(parser, data, data_size);
+		}
+	}
+	return finish_line(parser, count, args);
+}
+
+const char *managesieve_parser_read_word(struct managesieve_parser *parser)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(parser->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == ' ' || data[i] == '\r' || data[i] == '\n')
+			break;
+	}
+
+	if (i < data_size) {
+		data_size = i + (data[i] == ' ' ? 1 : 0);
+		parser->line_size += data_size;
+		i_stream_skip(parser->input, data_size);
+		return p_strndup(parser->pool, data, i);
+	} else {
+		return NULL;
+	}
+}
+
+const char *managesieve_arg_string(struct managesieve_arg *arg)
+{
+	if (arg->type == MANAGESIEVE_ARG_STRING) 
+		return arg->_data.str;
+
+	return NULL;
+}
+
+int managesieve_arg_number
+	(struct managesieve_arg *arg, uoff_t *number)
+{
+	int i = 0;
+	const char *data;
+
+	*number = 0;
+
+	if (arg->type == MANAGESIEVE_ARG_ATOM) {
+		data = arg->_data.str;
+		while (data[i] != '\0') {
+			if (data[i] < '0' || data[i] > '9')
+				return -1;
+	
+			*number = (*number)*10 + (data[i] -'0');
+			i++;
+		}
+    
+		return 1;
+	}
+
+	return -1;
+}
+
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as string", arg->type);
+	return NULL;
+}
+
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as literal size", arg->type);
+	return 0;
+}
+
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg)
+{
+	i_panic("Tried to access managesieve_arg type %d as list", arg->type);
+	return NULL;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-parser.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,192 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MANAGESIEVE_PARSER_H
+#define __MANAGESIEVE_PARSER_H
+
+/*
+ * QUOTED-SPECIALS    = <"> / "\"
+ */
+#define IS_QUOTED_SPECIAL(c) \
+	((c) == '"' || (c) == '\\')
+
+/* 
+ * ATOM-SPECIALS      = "(" / ")" / "{" / SP / CTL / QUOTED-SPECIALS
+ */
+#define IS_ATOM_SPECIAL(c) \
+	((c) == '(' || (c) == ')' || (c) == '{' || \
+	 (c) <= 32 || (c) == 0x7f || \
+	 IS_QUOTED_SPECIAL(c)) 
+
+/* 
+ * CHAR               = %x01-7F
+ */
+#define IS_CHAR(c) \
+	(((c) & 0x80) == 0)
+
+/* 
+ * TEXT-CHAR          = %x01-09 / %x0B-0C / %x0E-7F
+ *                       ;; any CHAR except CR and LF
+ */
+#define IS_TEXT_CHAR(c) \
+	(IS_CHAR(c) && (c) != '\r' && (c) != '\n')
+
+/*
+ * SAFE-CHAR          = %x01-09 / %x0B-0C / %x0E-21 /
+ *                      %x23-5B / %x5D-7F
+ *                      ;; any TEXT-CHAR except QUOTED-SPECIALS
+ */
+#define IS_SAFE_CHAR(c) \
+	(IS_TEXT_CHAR(c) && !IS_QUOTED_SPECIAL(c))
+
+/* UTF8-1             = %x80-BF
+ */
+#define IS_UTF8_1(c) \
+	(((c) & 0xC0) == 0x80)
+
+/* UTF8-2             = %xC0-DF UTF8-1
+ */
+#define IS_UTF8_2S(c) \
+  (((c) & 0xE0) == 0xC0)
+
+/* UTF8-3             = %xE0-EF 2UTF8-1
+ */
+#define IS_UTF8_3S(c) \
+  (((c) & 0xF0) == 0xE0)
+
+/* UTF8-4             = %xF0-F7 3UTF8-1
+ */
+#define IS_UTF8_4S(c) \
+  (((c) & 0xF8) == 0xF0)
+
+/* UTF8-5             = %xF8-FB 4UTF8-1
+ */
+#define IS_UTF8_5S(c) \
+  (((c) & 0xFC) == 0xF8)
+
+/* UTF8-6             = %xFC-FD 5UTF8-1
+ */
+#define IS_UTF8_6S(c) \
+  (((c) & 0xFE) == 0xFC)
+
+/* SAFE-UTF8-CHAR     = SAFE-CHAR / UTF8-2 / UTF8-3 / UTF8-4 /
+ *                      UTF8-5 / UTF8-6
+ */
+#define UTF8_LEN(c) \
+  ( IS_SAFE_CHAR(c) ? 1 : \
+    IS_UTF8_2S(c) ? 2 : \
+    IS_UTF8_3S(c) ? 3 : \
+    IS_UTF8_4S(c) ? 4 : \
+    IS_UTF8_5S(c) ? 5 : \
+    IS_UTF8_6S(c) ? 6 : 0 )
+
+enum managesieve_parser_flags {
+	/* Set this flag if you wish to read only size of literal argument
+	   and not convert literal into string. Useful when you need to deal
+	   with large literal sizes. The literal must be the last read
+	   parameter. */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE	= 0x01,
+	/* Don't remove '\' chars from string arguments */
+	MANAGESIEVE_PARSE_FLAG_NO_UNESCAPE	= 0x02,
+	/* Return literals as MANAGESIEVE_ARG_LITERAL instead of MANAGESIEVE_ARG_STRING */
+	MANAGESIEVE_PARSE_FLAG_LITERAL_TYPE	= 0x04
+};
+
+enum managesieve_arg_type {
+	MANAGESIEVE_ARG_ATOM = 0,
+	MANAGESIEVE_ARG_STRING,
+
+	/* literals are returned as MANAGESIEVE_ARG_STRING by default */
+	MANAGESIEVE_ARG_LITERAL,
+	MANAGESIEVE_ARG_LITERAL_SIZE,
+
+	MANAGESIEVE_ARG_EOL /* end of argument list */
+};
+
+struct managesieve_parser;
+
+struct managesieve_arg {
+	enum managesieve_arg_type type;
+
+	union {
+		char *str;
+		uoff_t literal_size;
+	} _data;
+};
+
+#define MANAGESIEVE_ARG_STR(arg) \
+	((arg)->type == MANAGESIEVE_ARG_STRING || \
+   (arg)->type == MANAGESIEVE_ARG_ATOM || \
+	 (arg)->type == MANAGESIEVE_ARG_LITERAL ? \
+	 (arg)->_data.str : _managesieve_arg_str_error(arg))
+
+#define MANAGESIEVE_ARG_LITERAL_SIZE(arg) \
+	(((arg)->type == MANAGESIEVE_ARG_LITERAL_SIZE) ? \
+	 (arg)->_data.literal_size : _managesieve_arg_literal_size_error(arg))
+
+struct managesieve_arg_list {
+	size_t size, alloc;
+	struct managesieve_arg args[1]; /* variable size */
+};
+
+
+/* Create new MANAGESIEVE argument parser. output is used for sending command
+   continuation requests for literals.
+
+   max_line_size can be used to approximately limit the maximum amount of
+   memory that gets allocated when parsing a line. Input buffer size limits
+   the maximum size of each parsed token.
+
+   Usually the largest lines are large only because they have a one huge
+   message set token, so you'll probably want to keep input buffer size the
+   same as max_line_size. That means the maximum memory usage is around
+   2 * max_line_size. */
+struct managesieve_parser *
+managesieve_parser_create(struct istream *input, struct ostream *output,
+		   size_t max_line_size);
+void managesieve_parser_destroy(struct managesieve_parser **parser);
+
+/* Reset the parser to initial state. */
+void managesieve_parser_reset(struct managesieve_parser *parser);
+
+/* Return the last error in parser. fatal is set to TRUE if there's no way to
+   continue parsing, currently only if too large non-sync literal size was
+   given. */
+const char *managesieve_parser_get_error(struct managesieve_parser *parser, bool *fatal);
+
+/* Read a number of arguments. This function doesn't call i_stream_read(), you
+   need to do that. Returns number of arguments read (may be less than count
+   in case of EOL), -2 if more data is needed or -1 if error occurred.
+
+   count-sized array of arguments are stored into args when return value is
+   0 or larger. If all arguments weren't read, they're set to NIL. count
+   can be set to 0 to read all arguments in the line. Last element in
+   args is always of type MANAGESIEVE_ARG_EOL. */
+int managesieve_parser_read_args(struct managesieve_parser *parser, unsigned int count,
+			  enum managesieve_parser_flags flags, struct managesieve_arg **args);
+
+/* just like managesieve_parser_read_args(), but assume \n at end of data in
+   input stream. */
+int managesieve_parser_finish_line(struct managesieve_parser *parser, unsigned int count,
+			    enum managesieve_parser_flags flags,
+			    struct managesieve_arg **args);
+
+/* Read one word - used for reading tag and command name.
+   Returns NULL if more data is needed. */
+const char *managesieve_parser_read_word(struct managesieve_parser *parser);
+
+/* Returns the managesieve argument as string. If it is no string this returns NULL */
+const char *managesieve_arg_string(struct managesieve_arg *arg);
+
+/* Returns 1 if the argument is a number. If it is no number this returns -1.
+ * The number itself is stored in *number.
+ */
+int managesieve_arg_number
+  (struct managesieve_arg *arg, uoff_t *number);
+
+/* Error functions */
+char *_managesieve_arg_str_error(const struct managesieve_arg *arg);
+uoff_t _managesieve_arg_literal_size_error(const struct managesieve_arg *arg);
+struct managesieve_arg_list *_managesieve_arg_list_error(const struct managesieve_arg *arg);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-quote.c	2009-07-12 15:40:51.000000000 +0200
@@ -0,0 +1,179 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+/* Turn the value string into a valid MANAGESIEVE string or literal, no matter 
+ * what. QUOTED-SPECIALS are escaped, but any invalid (UTF-8) character
+ * is simply removed. Linebreak characters are not considered invalid, but
+ * they do force the generation of a string literal.
+ */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp)
+{
+	size_t i, extra = 0;
+	bool 
+		last_lwsp = TRUE, 
+		literal = FALSE, 
+		modify = FALSE,
+		escape = FALSE;
+	int utf8_len;
+
+ 	if (value == NULL) {
+		str_append(str, "\"\"");
+		return;
+	}
+
+	if (value_len == (size_t)-1)
+		value_len = strlen((const char *) value);
+
+	for (i = 0; i < value_len; i++) {
+		switch (value[i]) {
+		case ' ':
+		case '\t':
+			if (last_lwsp && compress_lwsp) {
+				modify = TRUE;
+				extra++;
+			}
+			last_lwsp = TRUE;
+			break;
+		case '"':
+		case '\\':
+			escape = TRUE;
+			last_lwsp = FALSE;
+			break;
+		case 13:
+		case 10:
+			literal = TRUE;
+			last_lwsp = TRUE;
+			break;
+		default:
+			/* Enforce valid UTF-8
+			 */
+			if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) {
+				modify = TRUE;
+				extra++;
+				break;
+			}
+
+			if ( utf8_len > 1 ) {
+				int c = utf8_len - 1;
+
+		 		if ( (i+utf8_len-1) >= value_len ) {
+				  	/* Value ends in the middle of a UTF-8 character;
+					 * Kill the partial UTF-8 character
+					 */
+				  	extra += i + utf8_len - value_len;
+					modify = TRUE;
+					break;        	
+				}
+
+				/* Parse the series of UTF8_1 characters */
+				for (i++; c > 0; c--, i++ ) {
+					if (!IS_UTF8_1(value[i])) {
+						extra += utf8_len - c;
+						modify = TRUE;
+						break;
+					}
+				}
+			}
+   			
+			last_lwsp = FALSE;
+		}
+	}
+
+	if (!literal) {
+		/* no linebreak chars, return as (escaped) "string" */
+		str_append_c(str, '"');
+	} else {
+		/* return as literal */
+		str_printfa(str, "{%"PRIuSIZE_T"}\r\n", value_len - extra);
+	}
+
+	if (!modify && (literal || !escape))
+		str_append_n(str, value, value_len);
+	else {
+		last_lwsp = TRUE;
+		for (i = 0; i < value_len; i++) {
+			switch (value[i]) {
+			case '"':
+			case '\\':
+				last_lwsp = FALSE;
+				if (!literal) 
+					str_append_c(str, '\\');
+				str_append_c(str, value[i]);
+				break;
+			case ' ':
+			case '\t':
+				if (!last_lwsp || !compress_lwsp)
+					str_append_c(str, ' ');
+				last_lwsp = TRUE;
+				break;
+			case 13:
+			case 10:
+				last_lwsp = TRUE;
+				str_append_c(str, value[i]);
+				break;
+			default:
+	  			/* Enforce valid UTF-8
+				 */
+				if ( (utf8_len=UTF8_LEN(value[i])) == 0 ) 
+					break;
+      
+				if ( utf8_len > 1 ) {
+					int c = utf8_len - 1;
+					int j;
+
+					if ( (i+utf8_len-1) >= value_len ) {
+						/* Value ends in the middle of a UTF-8 character;
+						 * Kill the partial character
+						 */
+					 	i = value_len;
+						break;
+					}
+
+					/* Parse the series of UTF8_1 characters */
+					for (j = i+1; c > 0; c--, j++ ) {
+						if (!IS_UTF8_1(value[j])) {
+							/* Skip until after this erroneous character */
+							i = j;
+							break;
+						}
+					}
+
+					/* Append the UTF-8 character. Last octet is done later */
+					c = utf8_len - 1;
+					for (; c > 0; c--, i++ ) 
+						str_append_c(str, value[i]);
+				}
+     
+				last_lwsp = FALSE;
+				str_append_c(str, value[i]);
+				break;
+			}
+		}
+	}
+
+	if (!literal)
+		str_append_c(str, '"');
+}
+
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len)
+{
+	string_t *str;
+	char *ret;
+
+	if (value == NULL)
+		return "\"\"";
+
+	T_BEGIN {
+		str = t_str_new(value_len + MAX_INT_STRLEN + 5);
+		managesieve_quote_append(str, value, value_len, TRUE);
+		ret = p_strndup(pool, str_data(str), str_len(str));
+	} T_END;
+
+	return ret;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-managesieve/managesieve-quote.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,20 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __IMAP_QUOTE_H
+#define __IMAP_QUOTE_H
+
+/* Return value suitable for sending to client, either as quoted-string or
+   literal. Note that this also converts TABs into spaces, multiple spaces
+   into single space and NULs to #128. */
+char *managesieve_quote(pool_t pool, const unsigned char *value, size_t value_len);
+
+/* Append to existing string. */
+void managesieve_quote_append(string_t *str, const unsigned char *value,
+		       size_t value_len, bool compress_lwsp);
+
+#define managesieve_quote_append_string(str, value, compress_lwsp) \
+	managesieve_quote_append(str, (const unsigned char *)(value), \
+			  (size_t)-1, compress_lwsp)
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/Makefile.am dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/Makefile.am	2008-11-17 19:52:34.000000000 +0100
@@ -0,0 +1,22 @@
+noinst_LIBRARIES = libsievestorage.a
+
+INCLUDES = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(docecot_incdir)/src/lib-mail \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+libsievestorage_a_SOURCES = \
+	sieve-storage-save.c \
+	sieve-storage-script.c \
+	sieve-storage-list.c \
+	sieve-storage.c 
+
+noinst_HEADERS = \
+	sieve-storage-error.h \
+	sieve-storage-save.h \
+	sieve-storage-script.h \
+	sieve-storage-list.h \
+	sieve-storage-private.h \
+	sieve-storage.h
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/Makefile.in dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/Makefile.in
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/Makefile.in	2009-08-21 01:05:44.000000000 +0200
@@ -0,0 +1,475 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/lib-sievestorage
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+ARFLAGS = cru
+libsievestorage_a_AR = $(AR) $(ARFLAGS)
+libsievestorage_a_LIBADD =
+am_libsievestorage_a_OBJECTS = sieve-storage-save.$(OBJEXT) \
+	sieve-storage-script.$(OBJEXT) sieve-storage-list.$(OBJEXT) \
+	sieve-storage.$(OBJEXT)
+libsievestorage_a_OBJECTS = $(am_libsievestorage_a_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libsievestorage_a_SOURCES)
+DIST_SOURCES = $(libsievestorage_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SIEVE_PLUGIN_TOP = @SIEVE_PLUGIN_TOP@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+noinst_LIBRARIES = libsievestorage.a
+INCLUDES = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(docecot_incdir)/src/lib-mail \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+libsievestorage_a_SOURCES = \
+	sieve-storage-save.c \
+	sieve-storage-script.c \
+	sieve-storage-list.c \
+	sieve-storage.c 
+
+noinst_HEADERS = \
+	sieve-storage-error.h \
+	sieve-storage-save.h \
+	sieve-storage-script.h \
+	sieve-storage-list.h \
+	sieve-storage-private.h \
+	sieve-storage.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/lib-sievestorage/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/lib-sievestorage/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libsievestorage.a: $(libsievestorage_a_OBJECTS) $(libsievestorage_a_DEPENDENCIES) 
+	-rm -f libsievestorage.a
+	$(libsievestorage_a_AR) libsievestorage.a $(libsievestorage_a_OBJECTS) $(libsievestorage_a_LIBADD)
+	$(RANLIB) libsievestorage.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage-list.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage-save.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage-script.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sieve-storage.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage.c	2009-08-04 18:22:48.000000000 +0200
@@ -0,0 +1,516 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "home-expand.h"
+#include "ioloop.h"
+#include "mkdir-parents.h"
+
+#include "sieve.h"
+#include "sieve-error-private.h"
+
+#include "sieve-storage-private.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define MAX_DIR_CREATE_MODE 0770
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+static void sieve_storage_verror
+	(struct sieve_error_handler *ehandler ATTR_UNUSED, 
+		const char *location ATTR_UNUSED, const char *fmt, va_list args);
+
+static const char *sieve_get_active_script_path(void)
+{
+  const char *script_path, *home;
+
+  home = getenv("HOME");
+
+  /* userdb may specify Sieve path */
+  script_path = getenv("SIEVE");
+  if (script_path != NULL) {
+	if (*script_path == '\0') {
+		/* disabled */
+		return NULL;
+	}
+
+    if ( *script_path != '/' && *script_path != '~') {
+      /* relative path. change to absolute. */
+      script_path = t_strconcat(getenv("HOME"), "/",  
+        script_path, NULL);
+    }
+  } else {
+    if (home == NULL) {
+      /* we must have a home directory */
+      i_error("sieve-storage: userdb(%s) didn't return a home directory or "
+        "sieve script location, can't find it",
+        getenv("USER"));
+      return NULL;
+    }
+
+    script_path = SIEVE_SCRIPT_PATH;
+  }
+
+  /* No need to check for existance here */
+
+  return script_path;
+}
+
+/* Obtain the directory for script storage from the mail location
+ */
+static const char *sieve_storage_get_dir_from_mail(const char *data)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	struct stat st;
+	size_t len;
+	const char *root_dir, *dir, *p, *d;
+
+	root_dir = dir = d = NULL;
+
+	if (debug)
+		i_info("sieve-storage: using mail-data: %s", data);
+
+	/* check if we're in the form of mailformat:data
+	   (eg. maildir:Maildir) */
+	p = data;
+	while (i_isalnum(*p)) p++;
+	
+	if (*p == ':') {
+		d = p+1;
+	} else {
+		d = data;
+	}
+
+	if (d == NULL || *d == '\0') {
+		/* Ok, this is bad. Check whether we might be chrooted, bail out otherwise */
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0)
+			root_dir = "/";
+		else {
+			i_error("sieve-storage: sieve storage directory not given and mail root provides no alternative.");
+            return NULL;
+		}
+	} else {
+		/* <scriptdir> */
+		p = strchr(d, ':');
+		if (p == NULL)
+			/* No additional parameters */
+			root_dir = d;
+		else {
+			dir = t_strdup_until(d, p);
+ 
+			do {
+				p++;
+				/* Use control dir as script dir if specified */
+				if (strncmp(p, "CONTROL=", 8) == 0)
+					root_dir = t_strcut(p+8, ':');
+				p = strchr(p, ':');
+			} while (p != NULL);
+			
+			if ( root_dir == NULL || *root_dir == '\0' )
+				root_dir = dir;
+		}
+	}
+
+	/* Not found */
+	if ( root_dir == NULL || *root_dir == '\0' ) {
+		if (debug)
+			i_info("sieve-storage: couldn't find root dir from mail-data.");
+		return NULL;
+	}
+
+	/* Strip trailing '/' */
+	len = strlen(root_dir);
+	if (root_dir[len-1] == '/')
+		root_dir = t_strndup(root_dir, len-1);
+
+	root_dir = home_expand(root_dir);
+
+	/* Superior mail directory must exist; it is never auto-created by the 
+	 * sieve-storage.
+ 	 */
+	if (stat(root_dir, &st) < 0 ) {
+		if ( errno != ENOENT ) {
+			i_error("sieve-storage: root dir from mail data: stat(%s) failed: %m", root_dir);
+			return NULL;
+		} else {
+			i_error("sieve-storage: root directory specified by mail data does not exist: %s", root_dir);
+			return NULL;
+		}
+	} 
+
+	/* Never store scripts directly in the root of the mail or mail:CONTROl directory.
+	 */
+	root_dir = t_strconcat( root_dir, "/sieve", NULL );
+
+	return root_dir;
+}
+
+static const char *sieve_storage_get_relative_link_path
+	(const char *active_path, const char *storage_dir) 
+{
+	const char *link_path, *p;
+	size_t pathlen;
+	
+	/* Determine to what extent the sieve storage and active script 
+	 * paths match up. This enables the managed symlink to be short and the 
+	 * sieve storages can be moved around without trouble (if the active 
+	 * script path is common to the script storage).
+	 */		
+	p = strrchr(active_path, '/');
+	if ( p == NULL ) {
+		link_path = storage_dir;
+	} else { 
+		pathlen = p - active_path;
+
+		if ( strncmp( active_path, storage_dir, pathlen ) == 0 &&
+			(storage_dir[pathlen] == '/' || storage_dir[pathlen] == '\0') ) 
+		{
+			if ( storage_dir[pathlen] == '\0' ) 
+				link_path = ""; 
+			else 
+				link_path = storage_dir + pathlen + 1;
+		} else 
+			link_path = storage_dir;
+	}
+
+	/* Add trailing '/' when link path is not empty 
+	 */
+	pathlen = strlen(link_path);
+    if ( pathlen != 0 && link_path[pathlen-1] != '/')
+        return t_strconcat(link_path, "/", NULL);
+
+	return t_strdup(link_path);
+}
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user)
+{
+	struct sieve_storage *storage;
+	const char *storage_dir;
+
+	T_BEGIN {
+		storage_dir = sieve_storage_get_dir_from_mail(data);
+
+		if (storage_dir == NULL) {
+			if (getenv("DEBUG") != NULL)
+				i_info("sieve-storage: failed to obtain storage directory from mail-data.");
+
+			storage = NULL;
+		} else {
+			storage = sieve_storage_create(storage_dir, user);
+		}
+	} T_END;
+
+	return storage;
+}
+
+static int sieve_storage_verify_dir
+(const char *path, mode_t *mode_r, gid_t *gid_r)
+{
+	struct stat st;
+
+	if ( stat(path, &st) < 0 ) {
+		const char *p;
+		int ret;
+
+		if ( errno != ENOENT )
+			return -1;
+
+		/* Ascend to parent path element */
+        p = strrchr(path, '/');
+
+		/* Path components exhausted? */
+        if  (p == NULL || p == path )
+            return -1;
+
+		/* Recurse */
+		T_BEGIN {
+            ret = sieve_storage_verify_dir(t_strdup_until(path, p), mode_r, gid_r);
+        } T_END;
+
+        if ( ret < 0 )
+            return -1;
+
+		if ( mkdir_chown(path, *mode_r, (uid_t) -1, *gid_r) < 0 )
+			return -1;
+
+		return 0;
+    }  
+
+	/* Report back permission bits and group id back to caller */
+
+	if ( !S_ISDIR(st.st_mode) ) {
+		i_error("sieve-storage: Path is not a directory: %s", path);
+		return -1;
+	}
+		
+	*mode_r = st.st_mode & MAX_DIR_CREATE_MODE & 0777;
+
+	/* Check whether changing GID will be necessary */
+	if ( (st.st_mode & S_ISGID) != 0 ) {
+		/* Setgid bit set */
+		*gid_r = (gid_t) -1;
+	} else if ( getegid() == st.st_gid ) {
+		*gid_r = (gid_t) -1;
+	} else {
+		*gid_r = st.st_gid;
+	}
+
+	return 0;
+}
+
+static struct sieve_storage *_sieve_storage_create(const char *data, const char *user)
+{
+	bool debug = (getenv("DEBUG") != NULL);
+	pool_t pool;
+	struct sieve_storage *storage;
+	const char *home, *tmp_dir, *link_path;
+	const char *active_path, *active_fname, *storage_dir;
+	mode_t dir_mode;
+	gid_t dir_gid;
+
+	/* Find out where the active script is stored (e.g. ~/.dovecot.sieve) */
+
+	active_path = sieve_get_active_script_path();
+	if (active_path == NULL) {
+		return NULL;
+	}
+
+	/* Get the filename for the active script link */
+
+	active_fname = strrchr(active_path, '/');
+	if ( active_fname == NULL ) 
+		active_fname = active_path;
+	else
+		active_fname++;
+
+	if ( *active_fname == '\0' ) {	
+		/* Link cannot be just a path */
+		i_error("sieve-storage: Path to active symlink must include the link's filename. Path is: %s", 
+			active_path);
+		return NULL;
+	}
+
+	/* Find out where to put the script storage */
+
+	storage_dir = NULL;
+
+	if ( data == NULL || *data == '\0' ) {
+		/* We'll need to figure out the storage location ourself.
+		 *
+		 * It's $HOME/sieve or /sieve when (presumed to be) chrooted.  
+		 */
+		home = getenv("HOME");
+		if ( home != NULL && *home != '\0' ) {
+			if (access(home, R_OK|W_OK|X_OK) == 0) {
+				/* Use default ~/sieve */
+
+				if (debug) {
+					i_info("sieve-storage: root exists (%s)",
+						home);
+				}
+
+				storage_dir = home_expand_tilde("~/sieve", home);
+			} else {
+				/* Don't have required access on the home directory */
+
+				if (debug) {
+					i_info("sieve-storage: access(%s, rwx): "
+						"failed: %m", home);
+				}
+			}
+		} else {
+			if (debug)
+				i_info("sieve-storage: HOME not set");
+		}
+
+		if (access("/sieve", R_OK|W_OK|X_OK) == 0) {
+			storage_dir = "/sieve";
+			if (debug)
+				i_info("sieve-storage: /sieve exists, assuming chroot");
+		}
+	} else {
+		storage_dir = data;
+	}
+
+	if (storage_dir == NULL || *storage_dir == '\0') {
+		if (debug)
+			i_info("sieve-storage: couldn't find storage dir");
+		return NULL;
+	}
+
+	/* Expand home directories in path */
+	active_path = home_expand(active_path);
+	storage_dir = home_expand(storage_dir);
+
+	if (debug) {
+		i_info("sieve-storage: using active sieve script path: %s", active_path);
+ 		i_info("sieve-storage: using sieve script storage directory: %s", storage_dir);
+	}
+
+	/* Ensure sieve local directory structure exists (full autocreate):
+	 *  This currently currently only consists of a ./tmp direcory
+	 */
+	tmp_dir = t_strconcat( storage_dir, "/tmp", NULL );	
+	if ( sieve_storage_verify_dir(tmp_dir, &dir_mode, &dir_gid) < 0 ) {
+		i_error("sieve-storage: sieve_storage_verify_dir(%s) failed: %m", tmp_dir);
+		return NULL;
+	}
+
+	/* Create storage object */
+	pool = pool_alloconly_create("sieve-storage", 512+256);
+	storage = p_new(pool, struct sieve_storage, 1);	
+	storage->pool = pool;
+	storage->dir = p_strdup(pool, storage_dir);
+	storage->user = p_strdup(pool, user);
+	storage->active_path = p_strdup(pool, active_path);
+	storage->active_fname = p_strdup(pool, active_fname);
+
+	storage->dir_create_mode = dir_mode;
+	storage->file_create_mode = dir_mode & 0666;
+	storage->dir_create_gid = dir_gid;
+
+	/* Get the path to be prefixed to the script name in the symlink pointing 
+	 * to the active script.
+	 */
+	link_path = sieve_storage_get_relative_link_path
+		(storage->active_path, storage->dir);
+
+	if (debug)
+		i_info("sieve-storage: relative path to sieve storage in active link: %s", link_path);
+
+	storage->link_path = p_strdup(pool, link_path);
+
+	return storage;
+}
+
+struct sieve_storage *sieve_storage_create(const char *data, const char *user)
+{
+	struct sieve_storage *storage;
+
+	T_BEGIN {
+		storage = _sieve_storage_create(data, user);
+	} T_END;
+
+	return storage;
+}
+
+void sieve_storage_free(struct sieve_storage *storage)
+{
+	sieve_error_handler_unref(&storage->ehandler);
+
+	pool_unref(&storage->pool);
+}
+
+/* Error handling */
+
+struct sieve_error_handler *sieve_storage_get_error_handler(struct sieve_storage *storage)
+{
+	struct sieve_storage_ehandler *ehandler;
+
+	if ( storage->ehandler == NULL ) {
+		pool_t pool = pool_alloconly_create("sieve_storage_ehandler", 512);
+		ehandler = p_new(pool, struct sieve_storage_ehandler,1);
+		sieve_error_handler_init(&ehandler->handler, pool, 1);
+
+		ehandler->handler.verror = sieve_storage_verror;
+		ehandler->storage = storage;
+		
+		storage->ehandler = (struct sieve_error_handler *) ehandler;
+	}
+
+	return storage->ehandler;
+}
+
+static void sieve_storage_verror
+(struct sieve_error_handler *ehandler, const char *location ATTR_UNUSED,
+    const char *fmt, va_list args)
+{
+	struct sieve_storage_ehandler *sehandler = (struct sieve_storage_ehandler *) ehandler; 
+	struct sieve_storage *storage = sehandler->storage;
+
+	sieve_storage_clear_error(storage);
+	
+	if (fmt != NULL) {
+        storage->error = i_strdup_vprintf(fmt, args);
+    }
+}
+
+void sieve_storage_clear_error(struct sieve_storage *storage)
+{
+	i_free(storage->error);
+	storage->error = NULL;
+}
+
+void sieve_storage_set_error
+(struct sieve_storage *storage, enum sieve_storage_error error, const char *fmt, ...)
+{
+	va_list va;
+
+	sieve_storage_clear_error(storage);
+
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		storage->error = i_strdup_vprintf(fmt, va);
+		va_end(va);
+	}
+
+	storage->error_code = error;
+}
+
+void sieve_storage_set_internal_error(struct sieve_storage *storage)
+{
+	struct tm *tm;
+	char str[256];
+
+	tm = localtime(&ioloop_time);
+
+	i_free(storage->error);
+	storage->error_code = SIEVE_STORAGE_ERROR_TEMP;
+	storage->error =
+	  strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+	  i_strdup(str) : i_strdup(CRITICAL_MSG);
+}
+
+void sieve_storage_set_critical(struct sieve_storage *storage,
+             const char *fmt, ...)
+{
+	va_list va;
+	
+	sieve_storage_clear_error(storage);
+	if (fmt != NULL) {
+		va_start(va, fmt);
+		i_error("sieve-storage: %s", t_strdup_vprintf(fmt, va));
+		va_end(va);
+		
+		/* critical errors may contain sensitive data, so let user
+		   see only "Internal error" with a timestamp to make it
+		   easier to look from log files the actual error message. */
+		sieve_storage_set_internal_error(storage);
+	}
+}
+
+const char *sieve_storage_get_last_error
+	(struct sieve_storage *storage, enum sieve_storage_error *error_r)
+{
+	/* We get here only in error situations, so we have to return some
+	   error. If storage->error is NULL, it means we forgot to set it at
+	   some point.. 
+	 */
+  
+	if ( error_r != NULL ) 
+		*error_r = storage->error_code;
+
+	return storage->error != NULL ? storage->error : "Unknown error";
+}
+
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-error.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_ERROR_H
+#define __SIEVE_STORAGE_ERROR_H
+
+enum sieve_storage_error {
+	SIEVE_STORAGE_ERROR_NONE = 0,
+
+        /* Temporary internal error */
+        SIEVE_STORAGE_ERROR_TEMP,
+
+        /* It's not possible to do the wanted operation */
+        SIEVE_STORAGE_ERROR_IMPOSSIBLE,
+
+	/* Quota exceeded */
+        SIEVE_STORAGE_ERROR_QUOTA,
+
+        /* Out of disk space */	
+        SIEVE_STORAGE_ERROR_NOSPACE,
+
+	/* Script does not exist */
+        SIEVE_STORAGE_ERROR_NOTFOUND,
+
+	/* Operation not allowed on active script */
+	SIEVE_STORAGE_ERROR_ACTIVE,
+
+	/* Operation not allowed on existing script */
+	SIEVE_STORAGE_ERROR_EXISTS
+};
+
+#endif /* __SIEVE_STORAGE_ERROR_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_H
+#define __SIEVE_STORAGE_H
+
+#include "sieve-storage-error.h"
+
+struct sieve_storage *sieve_storage_create_from_mail(const char *data, const char *user);
+struct sieve_storage *sieve_storage_create(const char *data, const char *user);
+void sieve_storage_free(struct sieve_storage *storage);
+
+struct sieve_error_handler *sieve_storage_get_error_handler(struct sieve_storage *storage);
+
+/* Set error message in storage. Critical errors are logged with i_error(),
+   but user sees only "internal error" message. */
+void sieve_storage_clear_error(struct sieve_storage *storage);
+
+void sieve_storage_set_error
+	(struct sieve_storage *storage, enum sieve_storage_error error, const char *fmt, ...)
+		ATTR_FORMAT(3, 4);
+
+void sieve_storage_set_critical(struct sieve_storage *storage,
+	const char *fmt, ...) ATTR_FORMAT(2, 3);
+
+void sieve_storage_set_internal_error(struct sieve_storage *storage);
+
+const char *sieve_storage_get_last_error
+	(struct sieve_storage *storage, enum sieve_storage_error *error_r);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.c	2009-07-12 15:15:47.000000000 +0200
@@ -0,0 +1,113 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-list.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context {
+	pool_t pool;
+	struct sieve_storage *storage;
+
+	const char *active;
+	const char *dir;
+	DIR *dirp;
+
+	unsigned int seen_active:1; // Just present for assertions
+};
+
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage)
+{	
+	struct sieve_list_context *ctx;
+	const char *active;
+	pool_t pool;
+	DIR *dirp;
+
+	/* Open the directory */
+	if ( (dirp = opendir(storage->dir)) == NULL ) {
+		sieve_storage_set_critical(storage, "opendir(%s) failed: %m",
+					   storage->dir);
+		return NULL;
+	}
+
+	T_BEGIN {
+
+		/* Get the name of the active script */
+		if ( (active = sieve_storage_get_active_scriptfile(storage)) 
+			== NULL ) {
+			ctx = NULL;
+		} else {
+			pool = pool_alloconly_create("sieve_list_context", 4096);
+			ctx = p_new(pool, struct sieve_list_context, 1);
+			ctx->pool = pool;
+			ctx->storage = storage;
+			ctx->dirp = dirp;
+			ctx->active = p_strdup(pool, active);
+			ctx->seen_active = FALSE;
+		}
+	} T_END;
+		
+	return ctx;
+}
+
+const char *sieve_storage_list_next
+	(struct sieve_list_context *ctx, bool *active)
+{
+	const struct sieve_storage *storage = ctx->storage;
+	struct dirent *dp;
+	const char *scriptname;
+
+	*active = FALSE;
+
+	for (;;) {
+		if ( (dp = readdir(ctx->dirp)) == NULL )
+			return NULL;
+
+		scriptname = sieve_storage_file_get_scriptname
+			(storage, dp->d_name);	
+		
+		if (scriptname != NULL ) {
+			/* Don't list our active sieve script link if the link 
+			 * resides in the script dir (generally a bad idea).
+			 */
+			if ( *(storage->link_path) == '\0' && 
+				strcmp(storage->active_fname, dp->d_name) == 0 )
+				continue;
+		
+			break;
+		}
+	}
+
+	if ( ctx->active != NULL && 
+		strcmp(dp->d_name, ctx->active) == 0 ) {
+		*active = TRUE;
+		ctx->active = NULL;
+	}
+
+	return scriptname;
+}
+
+int sieve_storage_list_deinit(struct sieve_list_context **ctx)
+{
+	if (closedir((*ctx)->dirp) < 0) {
+		sieve_storage_set_critical((*ctx)->storage, "closedir(%s) failed: %m",
+					   (*ctx)->storage->dir);
+	}
+
+	pool_unref(&(*ctx)->pool);
+	*ctx = NULL;
+	return 1;
+}
+
+
+	
+    
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-list.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,32 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_LIST_H
+#define __SIEVE_STORAGE_LIST_H
+
+#include "lib.h"
+#include "str.h"
+#include "sieve-storage.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+struct sieve_list_context;
+
+/* Create a context for listing the scripts in the storage */
+struct sieve_list_context *sieve_storage_list_init
+	(struct sieve_storage *storage);
+
+/* Get the next script in the storage. */
+const char *sieve_storage_list_next(struct sieve_list_context *ctx, bool *active);
+
+/* Destroy the listing context */
+int sieve_storage_list_deinit(struct sieve_list_context **ctx);
+
+#endif
+
+
+	
+    
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-private.h	2009-06-28 15:35:39.000000000 +0200
@@ -0,0 +1,58 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_PRIVATE_H
+#define __SIEVE_STORAGE_PRIVATE_H
+
+#include "sieve.h"
+#include "sieve-error-private.h"
+
+#include "sieve-storage.h"
+
+
+enum sieve_storage_flags {
+	/* Print debugging information while initializing the storage */
+	SIEVE_STORAGE_FLAG_DEBUG     = 0x01,
+	/* Use CRLF linefeeds when saving mails. */
+	SIEVE_STORAGE_FLAG_SAVE_CRLF   = 0x02,
+};
+
+#define SIEVE_READ_BLOCK_SIZE (1024*8)
+
+struct sieve_storage;
+
+struct sieve_storage_ehandler {
+	struct sieve_error_handler handler;
+	struct sieve_storage *storage;
+};
+
+/* All methods returning int return either TRUE or FALSE. */
+struct sieve_storage {
+	pool_t pool;
+	char *name;
+	char *dir;
+
+	/* Private */	
+	char *active_path;
+	char *active_fname;
+	char *link_path;
+	char *error;
+	char *user; /* name of user accessing the storage */
+
+	mode_t dir_create_mode;
+	mode_t file_create_mode;
+	gid_t dir_create_gid;
+
+	enum sieve_storage_error error_code;
+
+	struct sieve_error_handler *ehandler;
+
+	enum sieve_storage_flags flags;
+};
+
+struct sieve_script *sieve_storage_script_init_from_path
+	(struct sieve_storage *storage, const char *path, 
+		const char *scriptname, bool *exists_r);
+
+#endif
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.c	2009-07-12 15:50:26.000000000 +0200
@@ -0,0 +1,347 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "array.h"
+#include "buffer.h"
+#include "ostream.h"
+#include "str.h"
+
+#include "sieve-script.h"
+
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-save.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <utime.h>
+#include <sys/stat.h>
+
+struct sieve_save_context {
+	pool_t pool;
+
+	struct sieve_storage *storage;
+	const char *scriptname;
+	struct sieve_script *scriptobject;
+
+	struct istream *input;
+	struct ostream *output;
+	int fd;
+	const char *tmp_path;
+
+	unsigned int failed:1;
+	unsigned int moving:1;
+	unsigned int finished:1;
+};
+
+static const char *sieve_generate_tmp_filename(const char *scriptname)
+{
+	static struct timeval last_tv = { 0, 0 };
+	struct timeval tv;
+
+	/* use secs + usecs to guarantee uniqueness within this process. */
+	if (ioloop_timeval.tv_sec > last_tv.tv_sec ||
+		(ioloop_timeval.tv_sec == last_tv.tv_sec &&
+		ioloop_timeval.tv_usec > last_tv.tv_usec)) {
+		tv = ioloop_timeval;
+	} else {
+		tv = last_tv;
+		if (++tv.tv_usec == 1000000) {
+			tv.tv_sec++;
+			tv.tv_usec = 0;
+		}
+	}
+	last_tv = tv;
+
+	if ( scriptname == NULL )
+		return t_strdup_printf("NULL_%s.M%sP%s.%s.sieve", dec2str(tv.tv_sec), 
+			dec2str(tv.tv_usec), my_pid, my_hostname);
+
+	return t_strdup_printf("%s-%s.M%sP%s.%s.sieve", scriptname, dec2str(tv.tv_sec), 
+		dec2str(tv.tv_usec), my_pid, my_hostname);
+}
+
+static int sieve_storage_create_tmp
+(struct sieve_storage *storage, const char *scriptname, const char **fpath_r)
+{
+	struct stat st;
+	unsigned int prefix_len;
+	const char *tmp_fname = NULL;
+	string_t *path;
+	int fd;
+
+	path = t_str_new(256);	
+	str_append(path, storage->dir);
+	str_append(path, "/tmp/");
+	prefix_len = str_len(path);
+
+	for (;;) {
+		tmp_fname = sieve_generate_tmp_filename(scriptname);
+		str_truncate(path, prefix_len);
+		str_append(path, tmp_fname);
+
+		/* stat() first to see if it exists. pretty much the only
+		   possibility of that happening is if time had moved
+		   backwards, but even then it's highly unlikely. */
+		if (stat(str_c(path), &st) == 0) {
+			/* try another file name */	
+		} else if (errno != ENOENT) {
+			sieve_storage_set_critical(storage,
+				"stat(%s) failed: %m", str_c(path));
+			return -1;
+		} else {
+			/* doesn't exist */
+			mode_t old_mask = umask(0777 & ~(storage->file_create_mode));
+			fd = open(str_c(path),
+				O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0777);
+			umask(old_mask);
+
+			if (fd != -1 || errno != EEXIST)
+				break;
+			/* race condition between stat() and open().
+				highly unlikely. */
+		}
+	}
+
+    *fpath_r = str_c(path);
+    if (fd == -1) {
+        if (ENOSPACE(errno)) {
+            sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_NOSPACE,
+							"Not enough disk space");
+        } else {
+            sieve_storage_set_critical(storage,
+							"open(%s) failed: %m", str_c(path));
+        }
+    } 
+
+    return fd;
+}
+
+
+static int sieve_storage_script_move(struct sieve_save_context *ctx,
+  const char *dst)
+{
+	int failed;
+
+	T_BEGIN {
+
+		/* Using rename() to ensure existing files are replaced
+		 * without conflicts with other processes using the same
+		 * file. The kernel wont fully delete the original until
+		 * all processes have closed the file.
+		 */
+		if (rename(ctx->tmp_path, dst) == 0)
+			failed = FALSE;
+		else {
+			failed = TRUE;
+			if (ENOSPACE(errno)) {
+				sieve_storage_set_error
+				  (ctx->storage, SIEVE_STORAGE_ERROR_NOSPACE, "Not enough disk space");
+			} else {
+				sieve_storage_set_critical
+				  (ctx->storage, "link(%s, %s) failed: %m", ctx->tmp_path, dst);
+			}
+		}
+
+		/* Always destroy temp file */
+		(void)unlink(ctx->tmp_path);
+
+	} T_END;
+
+	return !failed;
+}
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input)
+{
+	struct sieve_save_context *ctx;
+	pool_t pool;
+	const char *path;
+
+	if ( scriptname != NULL ) {
+		/* Disallow '/' characters in script name */
+		if ( strchr(scriptname, '/') != NULL ) {
+			sieve_storage_set_error(storage, 
+				SIEVE_STORAGE_ERROR_IMPOSSIBLE,
+				"Invalid script name '%s'.", scriptname);
+			return NULL;
+		}
+
+		/* Prevent overwriting the active script link when it resides in the 
+		 * sieve storage directory.
+		 */
+		if ( *(storage->link_path) == '\0' ) {
+			const char *svext;
+			size_t namelen;
+
+			svext = strrchr(storage->active_fname, '.');
+			namelen = svext - storage->active_fname;
+			if ( svext != NULL && strncmp(svext+1, "sieve", 5) == 0 &&
+				strlen(scriptname) == namelen && 
+				strncmp(scriptname, storage->active_fname, namelen) == 0 ) 
+			{
+				sieve_storage_set_error(
+					storage, SIEVE_STORAGE_ERROR_IMPOSSIBLE, 
+					"Script name '%s' is reserved for internal use.", scriptname); 
+				return NULL;
+			}
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_save_context", 4096);
+	ctx = p_new(pool, struct sieve_save_context, 1);
+	ctx->pool = pool;
+	ctx->storage = storage;
+	ctx->scriptname = scriptname;
+	ctx->scriptobject = NULL;
+
+	T_BEGIN {
+		ctx->fd = sieve_storage_create_tmp(storage, scriptname, &path);
+		if (ctx->fd == -1) {
+			ctx->failed = TRUE;
+			pool_unref(&pool);
+			ctx = NULL;
+		} else {
+			ctx->input = input;
+			ctx->output = o_stream_create_fd(ctx->fd, 0, FALSE);
+			ctx->tmp_path = p_strdup(pool, path);
+			ctx->failed = FALSE;
+		}
+	} T_END;
+
+	return ctx;
+}
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx)
+{
+	if (o_stream_send_istream(ctx->output, ctx->input) < 0) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", ctx->tmp_path);
+		ctx->failed = TRUE;
+		return -1;
+	}
+	return 0;
+}
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx)
+{
+	int output_errno;
+
+	ctx->finished = TRUE;
+	if ( ctx->failed && ctx->fd == -1 ) {
+		/* tmp file creation failed */
+		return -1;
+	}
+
+	T_BEGIN {
+		output_errno = ctx->output->stream_errno;
+		o_stream_destroy(&ctx->output);
+
+		if ( fsync(ctx->fd) < 0 ) {
+			sieve_storage_set_critical(ctx->storage,
+				"fsync(%s) failed: %m", ctx->tmp_path);
+			ctx->failed = TRUE;
+		}
+		if ( close(ctx->fd) < 0 ) {
+			sieve_storage_set_critical(ctx->storage,
+				"close(%s) failed: %m", ctx->tmp_path);
+			ctx->failed = TRUE;
+		}
+		ctx->fd = -1;
+
+		if ( ctx->failed ) {
+			/* delete the tmp file */
+			if (unlink(ctx->tmp_path) < 0 && errno != ENOENT) 
+				i_warning("sieve-storage: Unlink(%s) failed: %m", ctx->tmp_path);
+
+			errno = output_errno;
+			if ( ENOSPACE(errno) ) {
+				sieve_storage_set_error(ctx->storage, SIEVE_STORAGE_ERROR_NOSPACE,
+					"Not enough disk space");
+			} else if ( errno != 0 ) {
+				sieve_storage_set_critical(ctx->storage,
+					"write(%s) failed: %m", ctx->tmp_path);
+			}
+		}
+	} T_END;
+
+	return ( ctx->failed ? -1 : 0 );
+}
+
+static void sieve_storage_save_destroy(struct sieve_save_context **ctx)
+{
+	if ((*ctx)->scriptobject != NULL)
+		sieve_script_unref(&((*ctx)->scriptobject));
+
+	pool_unref(&(*ctx)->pool);
+	*ctx = NULL;
+}
+
+struct sieve_script *sieve_storage_save_get_tempscript
+(struct sieve_save_context *ctx)
+{
+	const char *scriptname = 
+		( ctx->scriptname == NULL ? "" : ctx->scriptname ); 
+	bool exists = FALSE;
+
+	if (ctx->failed) 
+		return NULL;
+
+	if ( ctx->scriptobject != NULL )
+		return ctx->scriptobject;
+
+	ctx->scriptobject = sieve_storage_script_init_from_path
+		(ctx->storage, ctx->tmp_path, scriptname, &exists);	
+
+	if ( !exists ) {
+		sieve_storage_set_critical(ctx->storage, 
+			"save: Temporary script file with name '%s' got lost, "
+			"which should not happen (possibly deleted externally).", 
+			ctx->tmp_path);
+		sieve_script_unref(&ctx->scriptobject);
+		return NULL;
+	}
+
+	return ctx->scriptobject;
+}
+
+int sieve_storage_save_commit(struct sieve_save_context **ctx)
+{
+	const char *dest_path;
+	bool failed = FALSE;
+
+	i_assert((*ctx)->output == NULL);
+	i_assert((*ctx)->finished);
+	i_assert((*ctx)->scriptname != NULL);
+
+	T_BEGIN {
+		dest_path = t_strconcat((*ctx)->storage->dir, "/", 
+			(*ctx)->scriptname, ".sieve", NULL);
+
+		failed = !sieve_storage_script_move((*ctx), dest_path);
+	} T_END;
+
+	sieve_storage_save_destroy(ctx);
+
+	return !failed;
+}
+
+void sieve_storage_save_cancel(struct sieve_save_context **ctx)
+{
+	(*ctx)->failed = TRUE;
+
+	if (!(*ctx)->finished) 
+		(void)sieve_storage_save_finish(*ctx);
+	else
+		(void)unlink((*ctx)->tmp_path);
+
+	i_assert((*ctx)->output == NULL);
+
+	sieve_storage_save_destroy(ctx);
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-save.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,27 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_SAVE_H
+#define __SIEVE_SAVE_H
+
+#include "sieve-storage.h"
+
+struct sieve_save_context;
+
+struct sieve_save_context *
+sieve_storage_save_init(struct sieve_storage *storage,
+	const char *scriptname, struct istream *input);
+
+int sieve_storage_save_continue(struct sieve_save_context *ctx);
+
+int sieve_storage_save_finish(struct sieve_save_context *ctx);
+
+struct sieve_script *sieve_storage_save_get_tempscript
+  (struct sieve_save_context *ctx);
+
+void sieve_storage_save_cancel(struct sieve_save_context **ctx);
+
+int sieve_storage_save_commit(struct sieve_save_context **ctx);
+
+#endif
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.c	2009-07-12 15:51:59.000000000 +0200
@@ -0,0 +1,617 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "mempool.h"
+#include "hostpid.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "file-copy.h"
+
+#include "sieve-script-private.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-private.h"
+#include "sieve-storage-script.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <time.h>
+#include <fcntl.h>
+
+struct sieve_storage_script {
+	struct sieve_script script;	
+
+    struct sieve_storage *storage;
+};
+
+struct sieve_script *sieve_storage_script_init_from_path
+(struct sieve_storage *storage, const char *path, 
+	const char *scriptname, bool *exists_r)
+{
+	pool_t pool;
+	struct sieve_storage_script *st_script = NULL;	
+
+	/* Prevent initializing the active script link as a script when it
+	 * resides in the sieve storage directory.
+	 */
+	if ( *(storage->link_path) == '\0' ) {
+		const char *fname;
+
+		fname = strrchr(path, '/');
+		if ( fname == NULL )
+			fname = path;
+		else
+			fname++;
+
+		if ( strcmp(fname, storage->active_fname) == 0 ) {
+			if ( exists_r != NULL )
+				*exists_r = FALSE;
+			return NULL;
+		}
+	}
+
+	pool = pool_alloconly_create("sieve_storage_script", 4096);	
+	st_script = p_new(pool, struct sieve_storage_script, 1);
+	st_script->script.pool = pool;
+	st_script->storage = storage;
+
+	if ( sieve_script_init(&st_script->script, path, scriptname, 
+		sieve_storage_get_error_handler(storage), exists_r) != NULL ) {
+
+		return &st_script->script;
+	}
+
+	pool_unref(&pool);
+
+	return NULL;
+}
+
+struct sieve_script *sieve_storage_script_init
+(struct sieve_storage *storage, const char *scriptname, bool *exists_r)
+{	
+	struct sieve_script *script;
+	const char *path;
+
+	/* Disallow '/' characters in script name */	
+	if ( strchr(scriptname, '/') != NULL ) {
+		sieve_storage_set_error(storage, 
+			SIEVE_STORAGE_ERROR_IMPOSSIBLE,
+			"Invalid script name '%s'.", scriptname);
+		return NULL;
+	}
+
+	T_BEGIN {
+		path = t_strconcat( storage->dir, "/", scriptname, ".sieve", NULL );
+
+		script = sieve_storage_script_init_from_path
+			(storage, path, NULL, exists_r);
+	} T_END;
+
+	return script;
+}
+
+static struct sieve_script *sieve_storage_script_init_from_file
+(struct sieve_storage *storage, const char *scriptfile, bool *exists_r)
+{	
+	struct sieve_script *script;
+	const char *path;
+
+	T_BEGIN {
+		path = t_strconcat( storage->dir, "/", scriptfile, NULL );
+
+		script = sieve_storage_script_init_from_path
+			(storage, path, NULL, exists_r);
+	} T_END;
+
+	return script;
+}
+
+const char *sieve_storage_file_get_scriptname
+(const struct sieve_storage *storage ATTR_UNUSED, const char *filename)
+{
+	const char *ext;
+
+	ext = strrchr(filename, '.');
+
+	if ( ext == NULL || ext == filename || strcmp(ext,".sieve") != 0 ) 
+		return NULL;
+	
+	return t_strdup_until(filename, ext);
+}
+
+static const char *sieve_storage_read_active_link
+(struct sieve_storage *storage, bool *not_link)
+{
+  char linkbuf[PATH_MAX];
+  int ret;
+
+	if ( not_link != NULL )
+		*not_link = FALSE;
+
+	ret = readlink(storage->active_path, linkbuf, sizeof(linkbuf));
+
+	if ( ret < 0 ) {
+		if (errno == EINVAL) {
+			/* Our symlink is no symlink. Report 'no active script'.
+			 * Activating a script will automatically resolve this, so
+			 * there is no need to panic on this one.
+			 */
+			i_warning
+			  ("sieve-storage: Active sieve script symlink %s is no symlink.",
+			   storage->active_path);
+			if ( not_link != NULL )
+				*not_link = TRUE;
+			return "";
+		}
+
+		if (errno != ENOENT ) {
+			/* We do need to panic otherwise */
+			sieve_storage_set_critical
+			  (storage,
+			  	"Performing readlink() on active sieve symlink '%s' failed: %m", 
+					storage->active_path);
+			return NULL;
+		}
+
+		return "";
+	}
+
+	/* ret is now assured to be valid, i.e. > 0 */
+	return t_strndup(linkbuf, ret);
+}
+
+static const char *sieve_storage_parse_link
+(struct sieve_storage *storage, const char *link)
+{
+	const char *fname, *scriptname, *scriptpath;
+
+	/* Split link into path and filename */
+	fname = strrchr(link, '/');
+	if ( fname != NULL ) {
+		scriptpath = t_strdup_until(link, fname+1);
+		fname++;
+	} else {
+		scriptpath = "";
+		fname = link;
+	}
+
+	/* Check the script name */
+	scriptname = sieve_storage_file_get_scriptname(storage, fname);
+
+	/* Warn if link is deemed to be invalid */
+	if ( scriptname == NULL ) {
+		i_warning
+			("sieve-storage: Active sieve script symlink %s is broken: "
+				"invalid scriptname (points to %s).",
+				storage->active_path, link);
+		return NULL;
+	}
+
+	/* Check whether the path is any good */
+	if ( strcmp(scriptpath, storage->link_path) != 0 &&
+		strcmp(scriptpath, storage->dir) != 0 ) {
+		i_warning
+			("sieve-storage: Active sieve script symlink %s is broken: "
+				"invalid/unknown path to storage (points to %s).",
+				storage->active_path, link);
+		return NULL; 
+	}
+
+	return fname;
+}
+
+const char *sieve_storage_get_active_scriptfile
+(struct sieve_storage *storage)
+{
+	const char *link, *scriptfile;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, NULL);
+
+	if ( link == NULL || *link == '\0' ) 
+		return link;
+
+	/* Parse the link */
+	scriptfile = sieve_storage_parse_link(storage, link);
+
+	if (scriptfile == NULL) {
+		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 * Activation should fix this situation.
+		 */
+		return "";
+	}
+
+	return scriptfile;
+}
+
+struct sieve_script *sieve_storage_get_active_script
+(struct sieve_storage *storage, bool *no_active)
+{
+	bool exists, no_link;
+	struct sieve_script *script;
+	const char *scriptfile, *link;
+
+	*no_active = FALSE;
+
+	/* Read the active link */
+	link = sieve_storage_read_active_link(storage, &no_link);
+	
+	if ( link == NULL )
+		/* Error */
+		return NULL;
+
+	if ( *link == '\0' )
+	{
+		if (no_link) {
+			/* Try to open the active_path as a regular file */
+			return sieve_storage_script_init_from_path
+				(storage, storage->active_path, NULL, NULL);
+		}
+
+		*no_active = TRUE;
+		return NULL;
+	}
+
+	/* Parse the link */
+	scriptfile = sieve_storage_parse_link(storage, link);
+
+	if (scriptfile == NULL) {
+  		/* Obviously someone has been playing with our symlink,
+		 * ignore this situation and report 'no active script'.
+		 */
+		*no_active = TRUE;
+		return NULL;
+	}
+	
+	exists = TRUE;
+	script = sieve_storage_script_init_from_file(storage, scriptfile, &exists);	
+
+	if ( !exists ) {
+		i_warning
+		  ("sieve-storage: Active sieve script symlink %s "
+		   "points to non-existent script (points to %s).",
+		   storage->active_path, link);
+	}
+	
+	*no_active = !exists;
+	return script;
+}
+
+int sieve_storage_script_is_active(struct sieve_script *script)
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	const char *afile;
+	int ret = 0;
+
+	T_BEGIN {
+		afile = sieve_storage_get_active_scriptfile(st_script->storage);
+	
+		if (afile == NULL) {
+			/* Critical error */
+			ret = -1;
+		} else {
+		 	/* Is the requested script active? */
+			if ( strcmp(script->filename, afile) == 0 ) 
+				ret = 1;
+		}
+	} T_END;
+
+	return ret;
+}
+
+int sieve_storage_script_delete(struct sieve_script **script) 
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) *script;
+	struct sieve_storage *storage = st_script->storage;
+	int ret = 0;
+
+	/* Is the requested script active? */
+	if ( sieve_storage_script_is_active(*script) ) {
+		sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_ACTIVE,
+			"Cannot delete the active sieve script.");
+		ret = -1;
+	} else {
+		ret = unlink((*script)->path);
+
+		if ( ret < 0 ) {
+			if ( errno == ENOENT ) 
+				sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_NOTFOUND,
+					"Sieve script does not exist.");
+			else
+				sieve_storage_set_critical(
+					storage, "Performing unlink() failed on sieve file '%s': %m", 
+					(*script)->path);
+		}	
+	}
+
+	/* Always deinitialize the script object */
+	sieve_script_unref(script);
+
+	return ret;	
+}
+
+static bool sieve_storage_rescue_regular_file(struct sieve_storage *storage)
+{
+	struct stat st;
+	
+	/* Stat the file */
+	if ( lstat(storage->active_path, &st) != 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_critical(storage, 
+				"Failed to stat active sieve script symlink (%s): %m.", 
+				storage->active_path); 
+			return FALSE;	
+		} 
+		return TRUE;
+	}
+
+  	if ( S_ISLNK( st.st_mode ) ) {
+		if ( getenv("DEBUG") != NULL )
+	    	i_info( "sieve-storage: nothing to rescue %s.", storage->active_path);
+    	return TRUE; /* Nothing to rescue */
+  	}
+
+	/* Only regular files can be rescued */
+	if ( S_ISREG( st.st_mode ) ) {
+		const char *dstpath;
+		bool result = TRUE;
+
+ 		T_BEGIN {
+
+			dstpath = t_strconcat
+				( storage->dir, "/dovecot.orig.sieve", NULL );
+			if ( file_copy(storage->active_path, dstpath, 1) < 1 ) {
+				sieve_storage_set_critical(storage, 
+					"Active sieve script file '%s' is a regular file and copying it to the "
+					"script storage as '%s' failed. This needs to be fixed manually.",
+						storage->active_path, dstpath);
+				result = FALSE;	
+			} else {
+				i_info("sieve-storage: Moved active sieve script file '%s' "
+					"to script storage as '%s'.",
+					storage->active_path, dstpath); 
+    		}
+		} T_END;
+
+		return result;
+  	}
+
+	sieve_storage_set_critical( storage,
+		"Active sieve script file '%s' is no symlink nor a regular file. "
+		"This needs to be fixed manually.", storage->active_path );
+	return FALSE;	
+}
+
+int sieve_storage_deactivate(struct sieve_storage *storage)
+{
+	int ret;
+
+	if ( !sieve_storage_rescue_regular_file(storage) ) 
+		return -1;
+
+	/* Delete the symlink, so no script is active */
+	ret = unlink(storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno != ENOENT ) {
+			sieve_storage_set_critical(storage, "sieve_storage_deactivate(): "
+				"error on unlink(%s): %m", storage->active_path);
+			return -1;
+		} else 
+			return 0;
+	} 
+
+	return 1;
+}
+
+static int sieve_storage_replace_active_link
+	(struct sieve_storage *storage, const char *link_path)
+{
+	const char *active_path_new;
+	struct timeval *tv, tv_now;
+	int ret = 0;	
+
+	tv = &ioloop_timeval;
+
+	for (;;) {	
+		/* First the new symlink is created with a different filename */
+		active_path_new = t_strdup_printf
+			("%s-new.%s.P%sM%s.%s.sieve",
+				storage->active_path,
+				dec2str(tv->tv_sec), my_pid,
+				dec2str(tv->tv_usec), my_hostname);
+
+		ret = symlink(link_path, active_path_new);
+		
+		if ( ret < 0 ) {
+			/* If link exists we try again later */
+			if ( errno == EEXIST ) {
+				/* Wait and try again - very unlikely */
+				sleep(2);
+				tv = &tv_now;
+				if (gettimeofday(&tv_now, NULL) < 0)
+					i_fatal("gettimeofday(): %m");
+				continue;
+			}
+
+			/* Other error, critical */
+			sieve_storage_set_critical
+				(storage, "Creating symlink() %s to %s failed: %m", 
+				active_path_new, link_path);
+			return -1;
+		}
+	
+		/* Link created */
+		break;
+	}
+
+	/* Replace the existing link. This activates the new script */
+	ret = rename(active_path_new, storage->active_path);
+
+	if ( ret < 0 ) {
+		/* Failed; created symlink must be deleted */
+		(void)unlink(active_path_new);
+		sieve_storage_set_critical
+			(storage, "Performing rename() %s to %s failed: %m", 
+			active_path_new, storage->active_path);
+		return -1;
+	}	
+
+	return 1;
+}
+
+static int _sieve_storage_script_activate(struct sieve_script *script)
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	struct sieve_storage *storage = st_script->storage;
+	struct stat st;
+	const char *link_path, *afile;
+	int activated = 0;
+	int ret;
+
+	/* Find out whether there is an active script, but recreate
+	 * the symlink either way. This way, any possible error in the symlink
+	 * resolves automatically. This step is only necessary to provide a
+	 * proper return value indicating whether the script was already active.
+	 */
+	afile = sieve_storage_get_active_scriptfile(storage);
+
+	/* Is the requested script already active? */
+	if ( afile == NULL || strcmp(script->filename, afile) != 0 ) 
+		activated = 1; 
+
+	/* Check the scriptfile we are trying to activate */
+	if ( lstat(script->path, &st) != 0 ) {
+		sieve_storage_set_critical(storage, 
+		  "Stat on sieve script %s failed, but it is to be activated: %m.", 
+			script->path);
+		return -1;
+	}
+
+	/* Rescue a possible .dovecot.sieve regular file remaining from old 
+	 * installations.
+	 */
+	if ( !sieve_storage_rescue_regular_file(storage) ) {
+		/* Rescue failed, manual intervention is necessary */
+		return -1;
+	}
+
+	/* Just try to create the symlink first */
+	link_path = t_strconcat
+	  ( storage->link_path, script->filename, NULL );
+		
+ 	ret = symlink(link_path, storage->active_path);
+
+	if ( ret < 0 ) {
+		if ( errno == EEXIST ) {
+			ret = sieve_storage_replace_active_link(storage, link_path);
+			if ( ret < 0 ) {
+				return ret;
+			}
+		} else {
+			/* Other error, critical */
+			sieve_storage_set_critical
+				(storage,
+					"Creating symlink() %s to %s failed: %m",
+					storage->active_path, link_path);
+			return -1;
+		}
+	}
+
+	return activated;
+}
+
+int sieve_storage_script_activate(struct sieve_script *script)
+{
+	int ret;
+	
+	T_BEGIN { 
+		ret = _sieve_storage_script_activate(script);
+	} T_END;
+
+	return ret;
+}
+
+int sieve_storage_script_rename(struct sieve_script *script, const char *newname) 
+{
+	struct sieve_storage_script *st_script = (struct sieve_storage_script *) script;
+	struct sieve_storage *storage = st_script->storage;
+	const char *newpath, *newfile, *link_path;
+	int ret = 0;
+
+	/* Disallow '/' characters in script name */
+	if ( strchr(newname, '/') != NULL ) {
+		sieve_storage_set_error(storage, 
+			SIEVE_STORAGE_ERROR_IMPOSSIBLE, 
+			"Invalid new script name '%s'.", newname);
+		return -1;
+	}
+
+	T_BEGIN {
+		newfile = t_strconcat( newname, ".sieve", NULL );
+		newpath = t_strconcat( storage->dir, "/", newfile, NULL );
+
+		/* The normal rename() system call overwrites the existing file without notice. 
+		 * Also, active scripts must not be disrupted by renaming a script. That is why
+		 * we use a link(newpath) [activate newpath] unlink(oldpath)
+		 */
+
+		/* Link to the new path */
+		ret = link(script->path, newpath);
+		if ( ret >= 0 ) {
+			/* Is the requested script active? */
+			if ( sieve_storage_script_is_active(script) ) {
+				/* Active; make active link point to the new copy */
+				link_path = t_strconcat
+					( storage->link_path, newfile, NULL );
+
+				ret = sieve_storage_replace_active_link(storage, link_path);
+			}
+
+			if ( ret >= 0 ) {
+				/* If all is good, remove the old link */
+				if ( unlink(script->path) < 0 ) {
+					i_error("Failed to clean up old file link '%s' after rename: %m", 
+						script->path);
+				}
+
+				if ( script->name != NULL && *script->name != '\0' )
+					script->name = p_strdup(script->pool, newname);
+				script->path = p_strdup(script->pool, newpath);
+				script->filename = p_strdup(script->pool, newfile);
+				script->basename = p_strdup(script->pool, newname);
+			} else {
+				/* If something went wrong, remove the new link to restore previous state */
+				if ( unlink(newpath) < 0 ) {
+					i_error("Failed to clean up new file link '%s'"
+						" after failed rename: %m", newpath);
+				}
+			}
+		} else {
+			/* Our efforts failed right away */
+			switch ( errno ) {
+			case ENOENT: 
+				sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_NOTFOUND, 
+					"Sieve script does not exist.");
+				break;
+			case EEXIST:
+				sieve_storage_set_error(storage, SIEVE_STORAGE_ERROR_EXISTS,
+					"A sieve script with that name already exists.");
+				break;
+			default:
+				sieve_storage_set_critical(
+					storage, "Performing link(%s, %s) failed: %m", 
+						script->path, newpath);
+			}				
+		}
+	} T_END;
+
+	return ret;	
+}
+
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/lib-sievestorage/sieve-storage-script.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,34 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __SIEVE_STORAGE_SCRIPT_H
+#define __SIEVE_STORAGE_SCRIPT_H
+
+#include "sieve-script.h"
+
+#include "sieve-storage.h"
+
+struct sieve_script *sieve_storage_script_init
+    (struct sieve_storage *storage, const char *scriptname, bool *exists_r);
+
+const char *sieve_storage_file_get_scriptname
+	(const struct sieve_storage *storage, const char *filename);
+
+const char *
+	sieve_storage_get_active_scriptfile(struct sieve_storage *storage);
+
+struct sieve_script *
+	sieve_storage_get_active_script(struct sieve_storage *storage, bool *no_active);
+
+int sieve_storage_script_is_active(struct sieve_script *script);
+
+int sieve_storage_script_delete(struct sieve_script **script);
+
+int sieve_storage_deactivate(struct sieve_storage *storage);
+
+int sieve_storage_script_activate(struct sieve_script *script);
+
+int sieve_storage_script_rename(struct sieve_script *script, const char *newname);
+
+#endif
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/Makefile.am dovecot-1.2.4/dovecot-managesieve/src/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/src/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/Makefile.am	2008-07-18 12:09:52.000000000 +0200
@@ -0,0 +1,5 @@
+if HAVE_OLD_SIEVE_PLUGIN
+OLDPLUGIN = lib-cmusieve
+endif
+
+SUBDIRS = $(OLDPLUGIN) lib-managesieve lib-sievestorage managesieve managesieve-login
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/Makefile.in dovecot-1.2.4/dovecot-managesieve/src/Makefile.in
--- dovecot-1.2.4.orig/dovecot-managesieve/src/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/Makefile.in	2009-08-21 01:05:44.000000000 +0200
@@ -0,0 +1,500 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = lib-cmusieve lib-managesieve lib-sievestorage \
+	managesieve managesieve-login
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SIEVE_PLUGIN_TOP = @SIEVE_PLUGIN_TOP@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+@HAVE_OLD_SIEVE_PLUGIN_TRUE@OLDPLUGIN = lib-cmusieve
+SUBDIRS = $(OLDPLUGIN) lib-managesieve lib-sievestorage managesieve managesieve-login
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/client.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/client.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/client.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/client.c	2009-07-12 15:41:31.000000000 +0200
@@ -0,0 +1,578 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "str.h"
+#include "ioloop.h"
+#include "network.h"
+#include "istream.h"
+#include "ostream.h"
+#include "var-expand.h"
+#include "commands.h"
+
+#include "managesieve-quote.h"
+#include "sieve-storage.h"
+
+#include "client.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+static struct client *my_client; /* we don't need more than one currently */
+
+static void client_idle_timeout(struct client *client)
+{
+	client_send_bye(client, "Disconnected for inactivity.");
+	client_destroy(client, "Disconnected for inactivity");
+}
+
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage)
+{
+	struct client *client;
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd_in, TRUE);
+	net_set_nonblock(fd_out, TRUE);
+
+	client = i_new(struct client, 1);
+	client->fd_in = fd_in;
+	client->fd_out = fd_out;
+	client->input = i_stream_create_fd(fd_in, managesieve_max_line_length, FALSE);
+	client->output = o_stream_create_fd(fd_out, (size_t)-1, FALSE);
+
+	o_stream_set_flush_callback(client->output, client_output, client);
+
+	client->io = io_add(fd_in, IO_READ, client_input, client);
+	client->parser = managesieve_parser_create(client->input, client->output,
+					    managesieve_max_line_length);
+	client->to_idle = timeout_add(CLIENT_IDLE_TIMEOUT_MSECS,
+				      client_idle_timeout, client);
+
+	client->cmd.pool = pool_alloconly_create("command pool", 8192);
+	client->cmd.client = client;
+
+	client->storage = storage;
+
+	i_assert(my_client == NULL);
+	my_client = client;
+
+	if (hook_client_created != NULL)
+		hook_client_created(&client);
+	return client;
+}
+
+static const char *client_stats(struct client *client)
+{	
+	static struct var_expand_table static_tab[] = {
+		{ 'i', NULL, "input" },
+		{ 'o', NULL, "output" },
+		{ '\0', NULL, NULL }
+	};
+	struct var_expand_table *tab;
+	string_t *str;
+
+	tab = t_malloc(sizeof(static_tab));
+	memcpy(tab, static_tab, sizeof(static_tab));
+
+	tab[0].value = dec2str(client->input->v_offset);
+	tab[1].value = dec2str(client->output->offset);
+
+	str = t_str_new(128);
+	var_expand(str, logout_format, tab);
+	return str_c(str);
+}
+
+static const char *client_get_disconnect_reason(struct client *client)
+{
+	errno = client->input->stream_errno != 0 ?
+		client->input->stream_errno :
+		client->output->stream_errno;
+	return errno == 0 || errno == EPIPE ? "Connection closed" :
+		t_strdup_printf("Connection closed: %m");
+}
+
+void client_destroy(struct client *client, const char *reason)
+{
+	int ret;
+
+ 	i_assert(!client->handling_input);
+	i_assert(!client->destroyed);
+	client->destroyed = TRUE;
+
+	if (!client->disconnected) {
+		client->disconnected = TRUE;
+		if (reason == NULL)
+			reason = client_get_disconnect_reason(client);
+		i_info("%s %s", reason, client_stats(client));	
+	}
+
+	if (client->command_pending) {
+		/* try to deinitialize the command */
+		i_assert(client->cmd.func != NULL);
+		i_stream_close(client->input);
+		o_stream_close(client->output);
+		client->input_pending = FALSE;
+
+		ret = client->cmd.func(&client->cmd);
+		i_assert(ret);
+	}
+
+	managesieve_parser_destroy(&client->parser);
+	if (client->io != NULL)
+		io_remove(&client->io);
+	if (client->to_idle_output != NULL)
+		timeout_remove(&client->to_idle_output);
+	timeout_remove(&client->to_idle);
+
+	i_stream_destroy(&client->input);
+	o_stream_destroy(&client->output);
+
+	if (close(client->fd_in) < 0)
+		i_error("close(client in) failed: %m");
+	if (client->fd_in != client->fd_out) {
+		if (close(client->fd_out) < 0)
+			i_error("close(client out) failed: %m");
+	}
+
+	pool_unref(&client->cmd.pool);
+	i_free(client);
+
+	/* quit the program */
+	my_client = NULL;
+	io_loop_stop(ioloop);
+}
+
+void client_disconnect(struct client *client, const char *reason)
+{
+	i_assert(reason != NULL);
+
+	if (client->disconnected)
+		return;
+
+	i_info("Disconnected: %s %s", reason, client_stats(client));
+	client->disconnected = TRUE;
+	(void)o_stream_flush(client->output);
+
+	i_stream_close(client->input);
+	o_stream_close(client->output);
+}
+
+void client_disconnect_with_error(struct client *client, const char *msg)
+{
+	client_send_bye(client, msg);
+	client_disconnect(client, msg);
+}
+
+int client_send_line(struct client *client, const char *data) 
+{
+	struct const_iovec iov[2];
+
+	if (client->output->closed)
+		return -1;
+
+	iov[0].iov_base = data;
+	iov[0].iov_len = strlen(data);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	if (o_stream_sendv(client->output, iov, 2) < 0)
+		return -1;
+	client->last_output = ioloop_time;
+
+	if (o_stream_get_buffer_used_size(client->output) >=
+	    CLIENT_OUTPUT_OPTIMAL_SIZE) {
+		/* buffer full, try flushing */
+		return o_stream_flush(client->output);
+	}
+	return 1;
+}
+
+void client_send_response
+(struct client *client, const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+	
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL ) {
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL ) {
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void client_send_command_error
+(struct client_command_context *cmd, const char *msg)
+{
+	struct client *client = cmd->client;
+	const char *error, *cmd_name;
+	bool fatal;
+
+	if (msg == NULL) {
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_disconnect_with_error(client, msg);
+			return;
+		}
+	}
+
+	if (cmd->name == NULL)
+		error = t_strconcat
+			("Error in MANAGESIEVE command: ", msg, NULL);
+	else {
+		cmd_name = t_str_ucase(cmd->name);
+		error = t_strconcat
+			("Error in MANAGESIEVE command ", cmd_name, ": ", msg, NULL);
+	}
+
+	client_send_no(client, error);
+
+	if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+		client_disconnect_with_error(client,
+			"Too many invalid MANAGESIEVE commands.");
+	}
+
+	/* client_read_args() failures rely on this being set, so that the
+	   command processing is stopped even while command function returns
+	   FALSE. */
+	cmd->param_error = TRUE;
+}
+
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage)
+{
+	enum sieve_storage_error error_code;
+	const char *error;
+
+	error = sieve_storage_get_last_error(storage, &error_code);
+
+	switch ( error_code ) {
+	case SIEVE_STORAGE_ERROR_TEMP:
+		client_send_noresp(client, "TRYLATER", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_QUOTA:
+	case SIEVE_STORAGE_ERROR_NOSPACE: /* Not sure if this is appropriate */
+		client_send_noresp(client, "QUOTA", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_NOTFOUND:
+		client_send_noresp(client, "NONEXISTENT", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_ACTIVE:
+		client_send_noresp(client, "ACTIVE", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_EXISTS:
+		client_send_noresp(client, "ALREADYEXISTS", error);
+		break;
+
+	case SIEVE_STORAGE_ERROR_IMPOSSIBLE:
+	default:
+		client_send_no(client, error);
+		break;
+	}
+}
+
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args)
+{
+	int ret;
+
+	i_assert(count <= INT_MAX);
+
+	ret = managesieve_parser_read_args(cmd->client->parser, count, flags, args);
+	if (ret >= (int)count) {
+		/* all parameters read successfully */
+		return TRUE;
+	} else if (ret == -2) {
+		/* need more data */
+		if (cmd->client->input->closed) {
+            /* disconnected */
+            cmd->param_error = TRUE;
+        }
+		return FALSE;
+	} else {
+		/* error, or missing arguments */
+		client_send_command_error(cmd, ret < 0 ? NULL :
+					  "Missing arguments");
+		return FALSE;
+	}
+}
+
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...)
+{
+	struct managesieve_arg *managesieve_args;
+	va_list va;
+	const char *str;
+	unsigned int i;
+	bool result = TRUE;
+
+	if (!client_read_args(cmd, count, 0, &managesieve_args))
+		return FALSE;
+
+	va_start(va, count);
+	for (i = 0; i < count; i++) {
+		const char **ret = va_arg(va, const char **);
+
+		if (managesieve_args[i].type == MANAGESIEVE_ARG_EOL) {
+			client_send_command_error(cmd, "Missing arguments.");
+			result = FALSE;
+			break;
+		}
+
+		str = managesieve_arg_string(&managesieve_args[i]);
+		if (str == NULL) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			result = FALSE;
+			break;
+		}
+
+		if (ret != NULL)
+			*ret = str;
+	}
+	va_end(va);
+
+	if (result && managesieve_args[i].type != MANAGESIEVE_ARG_EOL) {
+		client_send_command_error(cmd, "Too many arguments.");
+		result = FALSE;
+	}
+
+	return result;
+}
+
+void _client_reset_command(struct client *client)
+{
+	pool_t pool;
+	size_t size;
+
+	/* reset input idle time because command output might have taken a
+	   long time and we don't want to disconnect client immediately then */
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	client->command_pending = FALSE;
+    if (client->io == NULL && !client->disconnected) {
+        i_assert(i_stream_get_fd(client->input) >= 0);
+        client->io = io_add(i_stream_get_fd(client->input),
+                    IO_READ, client_input, client);
+    }
+    o_stream_set_flush_callback(client->output, client_output, client);
+
+	pool = client->cmd.pool;
+	memset(&client->cmd, 0, sizeof(client->cmd));
+
+	p_clear(pool);
+	client->cmd.pool = pool;
+	client->cmd.client = client;
+
+	managesieve_parser_reset(client->parser);
+
+	/* if there's unread data in buffer, remember that there's input
+	   pending and we should get around to calling client_input() soon.
+	   This is mostly for APPEND/IDLE. */
+	(void)i_stream_get_data(client->input, &size);
+	if (size > 0 && !client->destroyed)
+		client->input_pending = TRUE;
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+static bool client_skip_line(struct client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			client->input_skip_line = FALSE;
+			i++;
+			break;
+		}
+	}
+
+	i_stream_skip(client->input, i);
+	return !client->input_skip_line;
+}
+
+static bool client_handle_input(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	if (cmd->func != NULL) {
+		/* command is being executed - continue it */
+		if (cmd->func(cmd) || cmd->param_error) {
+			/* command execution was finished */
+			if (!cmd->param_error)
+				client->bad_counter = 0;
+			_client_reset_command(client);
+			return TRUE;
+		}
+
+		/* unfinished */
+        if (client->command_pending)
+            o_stream_set_flush_pending(client->output, TRUE);
+		return FALSE;
+	}
+
+	if (client->input_skip_line) {
+		/* we're just waiting for new line.. */
+		if (!client_skip_line(client))
+			return FALSE;
+
+		/* got the newline */
+		_client_reset_command(client);
+
+		/* pass through to parse next command */
+	}
+
+	if (cmd->name == NULL) {
+		cmd->name = managesieve_parser_read_word(client->parser);
+		if (cmd->name == NULL)
+			return FALSE; /* need more data */
+		cmd->name = p_strdup(cmd->pool, cmd->name);
+	}
+
+	if (cmd->name == '\0') {
+        /* command not given - cmd_func is already NULL. */
+    } else {
+        /* find the command function */
+        struct command *command = command_find(cmd->name);
+
+        if (command != NULL) {
+            cmd->func = command->func;
+        }
+    }
+
+	client->input_skip_line = TRUE;
+	if (cmd->func == NULL) {
+		/* unknown command */
+		client_send_command_error(cmd, "Unknown command.");
+		_client_reset_command(client);
+	} else {
+		i_assert(!client->disconnected);
+
+		client_handle_input(cmd);
+	}
+
+	return TRUE;
+}
+
+void client_input(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+
+	if (client->command_pending) {
+		/* already processing one command. wait. */
+		io_remove(&client->io);
+		return;
+	}
+
+	client->input_pending = FALSE;
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		client_destroy(client, NULL);
+		return;
+	case -2:
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		_client_reset_command(client);
+		break;
+	}
+
+	client->handling_input = TRUE;
+	o_stream_cork(client->output);
+	do {
+		T_BEGIN {
+			ret = client_handle_input(cmd);
+		} T_END;
+	} while (ret && !client->disconnected);
+    o_stream_uncork(client->output);
+    client->handling_input = FALSE;
+
+	if (client->command_pending)
+		client->input_pending = TRUE;
+
+	if (client->output->closed)
+		client_destroy(client, NULL);
+}
+
+int client_output(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+	int ret;
+	bool finished;
+
+	client->last_output = ioloop_time;
+    timeout_reset(client->to_idle);
+    if (client->to_idle_output != NULL)
+        timeout_reset(client->to_idle_output);
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, NULL);
+		return 1;
+	}
+
+	if (!client->command_pending)
+		return 1;
+
+	/* continue processing command */
+	o_stream_cork(client->output);
+	client->output_pending = TRUE;
+	finished = cmd->func(cmd) || cmd->param_error;
+
+	/* a bit kludgy check. normally we would want to get back to this
+	   output handler, but IDLE is a special case which has command
+	   pending but without necessarily anything to write. */
+	if (!finished && client->output_pending)
+		o_stream_set_flush_pending(client->output, TRUE);
+
+	o_stream_uncork(client->output);
+
+	if (finished) {
+		/* command execution was finished */
+		client->bad_counter = 0;
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			client_input(client);
+	}
+	return ret;
+}
+
+void clients_init(void)
+{
+	my_client = NULL;
+}
+
+void clients_deinit(void)
+{
+	if (my_client != NULL) {
+		client_send_bye(my_client, "Server shutting down.");
+		client_destroy(my_client, "Server shutting down");
+	}
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/client.h dovecot-1.2.4/dovecot-managesieve/src/managesieve/client.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/client.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/client.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,105 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "commands.h"
+
+struct client;
+struct sieve_storage;
+struct managesieve_parser;
+struct managesieve_arg;
+
+struct client_command_context {
+	struct client *client;
+
+	pool_t pool;
+	const char *name;
+
+	command_func_t *func;
+	void *context;
+
+	unsigned int param_error:1;
+};
+
+struct client {
+	int fd_in, fd_out;
+	struct sieve_storage *storage;
+
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+	struct timeout *to_idle, *to_idle_output;
+
+	time_t last_input, last_output;
+	unsigned int bad_counter;
+
+	struct managesieve_parser *parser;
+	struct client_command_context cmd;
+
+	unsigned int disconnected:1;
+	unsigned int destroyed:1;
+	unsigned int command_pending:1;
+	unsigned int input_pending:1;
+	unsigned int output_pending:1;
+	unsigned int handling_input:1;
+	unsigned int input_skip_line:1; /* skip all the data until we've
+					   found a new line */
+};
+
+/* Create new client with specified input/output handles. socket specifies
+   if the handle is a socket. */
+struct client *client_create(int fd_in, int fd_out, struct sieve_storage *storage);
+void client_destroy(struct client *client, const char *reason);
+
+/* Disconnect client connection */
+void client_disconnect(struct client *client, const char *reason);
+void client_disconnect_with_error(struct client *client, const char *msg);
+
+/* Send a line of data to client. Returns 1 if ok, 0 if buffer is getting full,
+   -1 if error */
+int client_send_line(struct client *client, const char *data);
+
+void client_send_response(struct client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+  client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(cmd, resp_code, msg) \
+  client_send_response(client, "BYE", resp_code, msg)
+
+/* Send BAD command error to client. msg can be NULL. */
+void client_send_command_error(struct client_command_context *cmd,
+			       const char *msg);
+
+/* Send storage or sieve related errors to the client */
+void client_send_storage_error(struct client *client,
+             struct sieve_storage *storage);
+
+/* Read a number of arguments. Returns TRUE if everything was read or
+   FALSE if either needs more data or error occurred. */
+bool client_read_args(struct client_command_context *cmd, unsigned int count,
+		      unsigned int flags, struct managesieve_arg **args);
+/* Reads a number of string arguments. ... is a list of pointers where to
+   store the arguments. */
+bool client_read_string_args(struct client_command_context *cmd,
+			     unsigned int count, ...);
+
+void clients_init(void);
+void clients_deinit(void);
+
+void _client_reset_command(struct client *client);
+void client_input(void *context);
+int client_output(void *context);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-capability.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-capability.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-capability.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-capability.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,49 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "ostream.h"
+
+#include "sieve.h"
+
+bool cmd_capability(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	const char *sievecap, *notifycap;
+
+	o_stream_cork(client->output);
+
+	T_BEGIN {
+		/* Get capabilities */
+		sievecap = sieve_get_capabilities(NULL);
+		notifycap = sieve_get_capabilities("notify");
+
+
+		/* Default capabilities */
+  		client_send_line(client, t_strconcat("\"IMPLEMENTATION\" \"", 
+			managesieve_implementation_string, "\"", NULL));
+		client_send_line(client, t_strconcat("\"SIEVE\" \"", 
+			( sievecap == NULL ? "" : sievecap ), "\"", NULL));
+
+		/* Notify methods */
+		if ( notifycap != NULL ) {
+			client_send_line(client, t_strconcat("\"NOTIFY\" \"", 
+				notifycap, "\"", NULL));
+		}
+
+		/* Protocol version */
+		client_send_line(client, "\"VERSION\" \"1.0\"");
+
+		/* Finish */
+		client_send_line(client, "OK \"Capability completed.\"");
+	} T_END;
+
+	o_stream_uncork(client->output);
+
+	return TRUE;
+
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-deletescript.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-deletescript.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-deletescript.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-deletescript.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+bool cmd_deletescript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+
+	/* <scrip name>*/
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	exists = TRUE;
+	script = sieve_storage_script_init(storage, scriptname, &exists);
+
+	if (script == NULL) {
+		if (!exists) 
+			client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+		else 
+			client_send_storage_error(client, storage);
+
+		return TRUE;
+	}
+
+	if (sieve_storage_script_delete(&script) < 0) {
+		client_send_storage_error(client, storage);
+	} else {
+		client_send_ok(client, "Deletescript completed.");
+	}
+
+	/* Script object is deleted no matter what in 
+	 * sieve_script_delete()
+	 */
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-getscript.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-getscript.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-getscript.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-getscript.c	2009-07-07 21:40:30.000000000 +0200
@@ -0,0 +1,129 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+#include "istream.h"
+
+#include "sieve-storage-script.h"
+
+struct cmd_getscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;	
+	uoff_t script_size, script_offset;
+
+	struct sieve_script *script;
+	struct istream *script_stream;
+	bool failed;
+	bool exists;
+};
+
+static bool cmd_getscript_finish(struct cmd_getscript_context *ctx)
+{
+	struct client *client = ctx->client;
+
+	if (ctx->script != NULL)
+		sieve_script_unref(&ctx->script);
+
+	if (ctx->failed) {
+		if (client->output->closed) {
+			client_disconnect(client, "Disconnected");
+			return TRUE;
+		}
+
+		if (!ctx->exists) {
+			client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+			return TRUE;
+		}
+		
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	client_send_line(client, "");
+	client_send_ok(client, "Getscript completed.");
+	return TRUE;
+}
+
+static bool cmd_getscript_continue(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx = cmd->context;
+	off_t ret;
+
+	ret = o_stream_send_istream(client->output, ctx->script_stream);
+
+	if ( ret < 0 ) {
+		sieve_storage_set_critical(ctx->storage,
+			"o_stream_send_istream(%s) failed: %m", sieve_script_filename(ctx->script));
+		ctx->failed = TRUE;
+		return cmd_getscript_finish(ctx);
+	}
+
+	ctx->script_offset += ret;
+
+	if ( ctx->script_offset != ctx->script_size && !ctx->failed ) {
+		/* unfinished */
+		if (!i_stream_have_bytes_left(ctx->script_stream)) {
+            /* Input stream gave less data than expected */
+            i_error("GETSCRIPT for SCRIPT %s got too little data: "
+                "%"PRIuUOFF_T" vs %"PRIuUOFF_T,
+                sieve_script_name(ctx->script),
+                ctx->script_offset, ctx->script_size);
+
+            client_disconnect(ctx->client, "GETSCRIPT failed");
+			ctx->failed = TRUE;
+            return cmd_getscript_finish(ctx);
+        }
+
+        return FALSE;
+	}
+
+	return cmd_getscript_finish(ctx);
+}
+
+bool cmd_getscript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_getscript_context *ctx;
+	const char *scriptname;
+	bool deleted_r;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	ctx = p_new(cmd->pool, struct cmd_getscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->failed = FALSE;
+	ctx->exists = TRUE;
+	ctx->script = sieve_storage_script_init(client->storage, scriptname, &ctx->exists);
+
+	if (ctx->script == NULL) {
+		ctx->failed = TRUE;
+		return cmd_getscript_finish(ctx);
+	}
+			
+	ctx->script_stream = sieve_script_open(ctx->script, &deleted_r);
+
+	if ( ctx->script_stream == NULL ) {
+		ctx->failed = TRUE;
+		ctx->exists = !deleted_r;
+		return cmd_getscript_finish(ctx);
+	}
+
+	ctx->script_size = sieve_script_get_size(ctx->script);
+	ctx->script_offset = 0;	
+
+	client_send_line(client, t_strdup_printf("{%"PRIuUOFF_T"}", ctx->script_size));
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_getscript_continue;
+	cmd->context = ctx;
+
+	return cmd_getscript_continue(cmd);
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-havespace.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-havespace.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-havespace.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-havespace.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+
+bool cmd_havespace(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct managesieve_arg *args;
+	const char *scriptname;
+	uoff_t size;
+	int ret;
+
+	/* <scriptname> <size> */
+	if (!(ret=client_read_args(cmd, 2, 0, &args)))
+	  return FALSE;
+
+	if ( ret > 2 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( (scriptname = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid string for scriptname.");
+		return TRUE;
+	}
+
+	if ( managesieve_arg_number(&args[1], &size) < 0 ) {
+		client_send_no(client, "Invalid scriptsize argument.");
+		return TRUE;
+	}
+
+	if ( size == 0 ) {
+		client_send_no(client, "Cannot upload empty script.");
+		return TRUE;
+	}
+
+	client_send_ok(client, "Putscript would succeed.");
+	return TRUE;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-listscripts.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-listscripts.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-listscripts.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-listscripts.c	2009-07-12 15:42:17.000000000 +0200
@@ -0,0 +1,49 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+#include "str.h"
+#include "sieve-storage.h"
+#include "sieve-storage-list.h"
+#include "managesieve-quote.h"
+
+bool cmd_listscripts(struct client_command_context *cmd)
+{
+  struct client *client = cmd->client;
+	struct sieve_list_context *ctx;
+	const char *scriptname;
+	bool active;
+	string_t *str;
+
+	if ( (ctx = sieve_storage_list_init(client->storage))
+		== NULL ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+
+	/* FIXME: This will be quite slow for large script lists. Implement
+	 * some buffering to fix this. Wont truely be an issue with managesieve
+	 * though.
+	 */
+	while ((scriptname = sieve_storage_list_next(ctx, &active)) != NULL) {
+		T_BEGIN {
+			str = t_str_new(128);
+	  
+			managesieve_quote_append_string(str, scriptname, FALSE);
+			
+			if ( active ) 
+				str_append(str, " ACTIVE");
+		
+			client_send_line(client, str_c(str));
+		} T_END;
+	}
+  
+	if ( sieve_storage_list_deinit(&ctx) < 0 ) {
+		client_send_storage_error(client, client->storage);
+		return TRUE;
+	}
+	
+	client_send_ok(client, "Listscripts completed.");
+	return TRUE;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-logout.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-logout.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-logout.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-logout.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,15 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "ostream.h"
+#include "commands.h"
+
+bool cmd_logout(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+
+	client_send_line(client, "OK \"Logout completed.\"");
+	client_disconnect(client, "Logged out");
+	return TRUE;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-noop.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-noop.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-noop.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-noop.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "str.h"
+#include "managesieve-quote.h"
+#include "commands.h"
+
+#include <stdlib.h>
+
+bool cmd_noop(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct managesieve_arg *args;
+	const char *text;
+	string_t *resp_code;
+	int ret;
+
+	/* [<echo string>] */
+	if (!(ret=client_read_args(cmd, 0, 0, &args)))
+		return FALSE;
+
+	if ( ret > 1 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( args[0].type == MANAGESIEVE_ARG_EOL ) {
+		client_send_ok(client, "NOOP Completed");
+		return TRUE;
+	}
+
+	if ( (text = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid echo tag.");
+		return TRUE;
+	}
+
+	resp_code = t_str_new(256);
+	str_append(resp_code, "TAG ");
+	managesieve_quote_append_string(resp_code, text, FALSE);
+
+	client_send_okresp(client, str_c(resp_code), "Done");
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-putscript.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-putscript.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-putscript.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-putscript.c	2009-07-12 20:02:35.000000000 +0200
@@ -0,0 +1,428 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* NOTE: this file also contains the checkscript command due to its obvious
+ * similarities.
+ */
+
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "commands.h"
+#include "managesieve-parser.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+#include "sieve-storage-save.h"
+#include "sieve.h"
+
+#include <sys/time.h>
+
+struct cmd_putscript_context {
+	struct client *client;
+	struct client_command_context *cmd;
+	struct sieve_storage *storage;
+
+	struct istream *input;
+
+	const char *scriptname;
+	uoff_t script_size;	
+
+	struct managesieve_parser *save_parser;
+	struct sieve_save_context *save_ctx;
+};
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx);
+static bool cmd_putscript_continue_script(struct client_command_context *cmd);
+
+static void client_input_putscript(void *context)
+{
+	struct client *client = context;
+	struct client_command_context *cmd = &client->cmd;
+
+	i_assert(!client->destroyed);
+
+	client->last_input = ioloop_time;
+	timeout_reset(client->to_idle);
+
+	switch (i_stream_read(client->input)) {
+	case -1:
+		/* disconnected */
+		cmd_putscript_finish(cmd->context);
+		/* Reset command so that client_destroy() doesn't try to call
+		   cmd_putscript_continue_script() anymore. */
+		_client_reset_command(client);
+		client_destroy(client, "Disconnected in PUTSCRIPT/SCRIPT");
+		return;
+	case -2:
+		cmd_putscript_finish(cmd->context);
+		if (client->command_pending) {
+			/* uploaded script data, this is handled internally by
+			   mailbox_save_continue() */
+			break;
+		}
+
+		/* parameter word is longer than max. input buffer size.
+		   this is most likely an error, so skip the new data
+		   until newline is found. */
+		client->input_skip_line = TRUE;
+
+		client_send_command_error(cmd, "Too long argument.");
+		cmd->param_error = TRUE;
+		_client_reset_command(client);
+		return;
+	}
+
+	if (cmd->func(cmd)) {
+		/* command execution was finished. Note that if cmd_sync()
+		   didn't finish, we didn't get here but the input handler
+		   has already been moved. So don't do anything important
+		   here..
+
+		   reset command once again to reset cmd_sync()'s changes. */
+		_client_reset_command(client);
+
+		if (client->input_pending)
+			client_input(client);
+	}
+}
+
+static void cmd_putscript_finish(struct cmd_putscript_context *ctx)
+{
+	managesieve_parser_destroy(&ctx->save_parser);
+	
+	io_remove(&ctx->client->io);
+	o_stream_set_flush_callback(ctx->client->output,
+				    client_output, ctx->client);
+
+	if (ctx->input != NULL)
+		i_stream_unref(&ctx->input);
+
+	if (ctx->save_ctx != NULL)
+	{
+		ctx->client->input_skip_line = TRUE;
+		sieve_storage_save_cancel(&ctx->save_ctx);
+	}
+}
+
+static bool cmd_putscript_continue_cancel(struct client_command_context *cmd)
+{
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+
+	(void)i_stream_read(ctx->input);
+	(void)i_stream_get_data(ctx->input, &size);
+	i_stream_skip(ctx->input, size);
+
+	if ( cmd->client->input->closed ||
+		ctx->input->v_offset == ctx->script_size ) {
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	return FALSE;
+}
+
+static bool cmd_putscript_cancel(struct cmd_putscript_context *ctx, bool nonsync)
+{
+	ctx->client->input_skip_line = TRUE;
+
+	if (!nonsync) { /* Rediculous for managesieve */
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* we have to read the nonsynced literal so we don't treat the uploaded script
+	   as commands. */
+	ctx->input = i_stream_create_limit(ctx->client->input, ctx->script_size);
+
+	ctx->client->command_pending = TRUE;
+	ctx->cmd->func = cmd_putscript_continue_cancel;
+	ctx->cmd->context = ctx;
+	return cmd_putscript_continue_cancel(ctx->cmd);
+}
+
+static bool cmd_putscript_finish_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	int ret;
+	
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+	
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+          MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1 || client->output->closed) {
+		if (ctx->storage != NULL)
+			client_send_command_error(cmd, NULL);
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args[0].type == MANAGESIEVE_ARG_EOL) {
+		struct sieve_script *script;
+
+		/* Last (and only) script */
+		bool success = TRUE;
+
+		/* Eat away the trailing CRLF */
+		client->input_skip_line = TRUE;
+
+		/* Obtain script object for uploaded script */
+		script = sieve_storage_save_get_tempscript(ctx->save_ctx);
+
+		/* Check result */
+		if ( script == NULL ) {
+			client_send_storage_error(client, ctx->storage);
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		}
+
+		/* Try to compile script */
+		T_BEGIN {
+			struct sieve_error_handler *ehandler;
+			struct sieve_binary *sbin;
+			string_t *errors;
+
+			/* Prepare error handler */
+			errors = str_new(default_pool, 1024);
+			ehandler = sieve_strbuf_ehandler_create
+				(errors, TRUE, DEFAULT_MANAGESIEVE_SIEVE_MAX_ERRORS);
+
+			/* Compile */
+			if ( (sbin=sieve_compile_script(script, ehandler)) == NULL ) {
+				client_send_no(client, str_c(errors));
+				success = FALSE;
+			} else {
+				sieve_close(&sbin);
+
+				/* Commit to save only when this is a putscript command */
+				if ( ctx->scriptname != NULL ) { 
+					ret = sieve_storage_save_commit(&ctx->save_ctx);
+
+					/* Check commit */			
+					if (ret < 0) {
+						client_send_storage_error(client, ctx->storage);
+						success = FALSE;
+					}
+				} 
+			}
+
+			/* Finish up */
+			cmd_putscript_finish(ctx);
+
+			/* Report result to user */
+			if ( success ) {
+				if ( sieve_get_warnings(ehandler) > 0 ) 
+					client_send_okresp(client, "WARNINGS", str_c(errors));
+				else {
+					if ( ctx->scriptname != NULL )
+						client_send_ok(client, "PUTSCRIPT completed.");
+					else
+						client_send_ok(client, "Script checked successfully.");						
+				}
+			}
+
+			sieve_error_handler_unref(&ehandler);
+			str_free(&errors);
+		} T_END;
+
+		return TRUE;
+	}
+
+	client_send_command_error(cmd, "Too many command arguments.");
+	cmd_putscript_finish(ctx);
+	return TRUE;
+}
+
+static bool cmd_putscript_continue_parsing(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	struct managesieve_arg *args;
+	bool nonsync = FALSE;
+	int ret;
+
+	/* if error occurs, the CRLF is already read. */
+	client->input_skip_line = FALSE;
+
+	/* <script literal> */
+	ret = managesieve_parser_read_args(ctx->save_parser, 0,
+				    MANAGESIEVE_PARSE_FLAG_LITERAL_SIZE, &args);
+	if (ret == -1 || client->output->closed) {
+		cmd_putscript_finish(ctx);
+		client_send_command_error(cmd, "Invalid arguments.");
+		client->input_skip_line = TRUE;
+		return TRUE;
+	}
+	if (ret < 0) {
+		/* need more data */
+		return FALSE;
+	}
+
+	if (args->type != MANAGESIEVE_ARG_STRING) {
+		/* Validate the script argument */
+	  	if (args->type != MANAGESIEVE_ARG_LITERAL_SIZE ) {
+			client_send_command_error(cmd, "Invalid arguments.");
+			return cmd_putscript_cancel(ctx, FALSE);
+		}
+
+		ctx->script_size = MANAGESIEVE_ARG_LITERAL_SIZE(args);
+		nonsync = TRUE;
+	} else {
+		/* FIXME */
+		client_send_no(client, 
+			"This MANAGESIEVE implementation currently does not allow "
+			"quoted strings to be used for script contents.");
+		return cmd_putscript_cancel(ctx, FALSE);		
+	}
+
+	if (ctx->script_size == 0) {
+		/* no script content, abort */
+		if ( ctx->scriptname != NULL ) 
+			client_send_no(client, "PUTSCRIPT aborted (empty script).");
+		else
+			client_send_no(client, "CHECKSCRIPT aborted (empty script).");
+
+		cmd_putscript_finish(ctx);
+		return TRUE;
+	}
+
+	/* save the script */
+	ctx->input = i_stream_create_limit(client->input, ctx->script_size);
+	ctx->save_ctx = sieve_storage_save_init
+		(ctx->storage, ctx->scriptname, ctx->input);
+
+	if ( ctx->save_ctx == NULL ) {
+		/* save initialization failed */
+		client_send_storage_error(client, ctx->storage);
+		return cmd_putscript_cancel(ctx, nonsync);
+	}
+
+	/* after literal comes CRLF, if we fail make sure we eat it away */
+	client->input_skip_line = TRUE;
+
+	client->command_pending = TRUE;
+	cmd->func = cmd_putscript_continue_script;
+	return cmd_putscript_continue_script(cmd);
+}
+
+static bool cmd_putscript_continue_script(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct cmd_putscript_context *ctx = cmd->context;
+	size_t size;
+	bool failed;
+	int ret;
+
+	if (ctx->save_ctx != NULL) {
+		while (ctx->input->v_offset != ctx->script_size) {
+			ret = i_stream_read(ctx->input);
+			if (sieve_storage_save_continue(ctx->save_ctx) < 0) {
+				/* we still have to finish reading the script
+			   	  from client */
+				sieve_storage_save_cancel(&ctx->save_ctx);
+				break;
+			}
+			if (ret == -1 || ret == 0)
+                break;
+		}
+	}
+
+	if (ctx->save_ctx == NULL) {
+		(void)i_stream_read(ctx->input);
+		(void)i_stream_get_data(ctx->input, &size);
+		i_stream_skip(ctx->input, size);
+	}
+
+	if (ctx->input->eof || client->input->closed) {
+		bool all_written = ctx->input->v_offset == ctx->script_size;
+
+		/* finished */
+		i_stream_unref(&ctx->input);
+		ctx->input = NULL;
+
+		if (ctx->save_ctx == NULL) {
+			/* failed above */
+			client_send_storage_error(client, ctx->storage);
+			failed = TRUE;
+		} else if (!all_written) {
+			/* client disconnected before it finished sending the
+			   whole script. */
+			failed = TRUE;
+			sieve_storage_save_cancel(&ctx->save_ctx);
+			client_disconnect(client, "EOF while appending in PUTSCRIPT/CHECKSCRIPT");
+		} else if (sieve_storage_save_finish(ctx->save_ctx) < 0) {
+			failed = TRUE;
+			client_send_storage_error(client, ctx->storage);
+		} else {
+			failed = client->input->closed;
+		}
+
+		if (failed) {
+			cmd_putscript_finish(ctx);
+			return TRUE;
+		}
+
+		/* finish */
+		client->command_pending = FALSE;
+		managesieve_parser_reset(ctx->save_parser);
+		cmd->func = cmd_putscript_finish_parsing;
+		return cmd_putscript_finish_parsing(cmd);
+	}
+
+	return FALSE;
+}
+
+static bool cmd_putscript_start
+(struct client_command_context *cmd, const char *scriptname)
+{
+	struct cmd_putscript_context *ctx;
+	struct client *client = cmd->client;
+
+	ctx = p_new(cmd->pool, struct cmd_putscript_context, 1);
+	ctx->cmd = cmd;
+	ctx->client = client;
+	ctx->storage = client->storage;
+	ctx->scriptname = scriptname;
+
+	io_remove(&client->io);
+	client->io = io_add(i_stream_get_fd(client->input), IO_READ,
+			    client_input_putscript, client);
+	/* putscript is special because we're only waiting on client input, not
+	   client output, so disable the standard output handler until we're
+	   finished */
+	o_stream_unset_flush_callback(client->output);
+
+	ctx->save_parser = managesieve_parser_create(client->input, client->output,
+					      managesieve_max_line_length);
+
+	cmd->func = cmd_putscript_continue_parsing;
+	cmd->context = ctx;
+	return cmd_putscript_continue_parsing(cmd);
+
+}
+
+bool cmd_putscript(struct client_command_context *cmd)
+{
+	const char *scriptname;
+
+	/* <scriptname> */
+	if ( !client_read_string_args(cmd, 1, &scriptname) || *scriptname == '\0' )
+		return FALSE;
+
+	return cmd_putscript_start(cmd, scriptname);
+}
+
+bool cmd_checkscript(struct client_command_context *cmd)
+{
+	return cmd_putscript_start(cmd, NULL);
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-renamescript.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-renamescript.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-renamescript.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-renamescript.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,45 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "str.h"
+
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+#include <stdlib.h>
+
+bool cmd_renamescript(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname, *newname;
+	struct sieve_script *script;
+	bool exists;
+
+	/* <oldname> <newname> */
+	if (!client_read_string_args(cmd, 2, &scriptname, &newname))
+		return FALSE;
+
+	exists = TRUE;
+	script = sieve_storage_script_init(storage, scriptname, &exists);
+
+	if (script == NULL) {
+		if (!exists)
+			client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+		else
+			client_send_storage_error(client, storage);
+
+		return TRUE;
+	}
+
+	if (sieve_storage_script_rename(script, newname) < 0)
+		client_send_storage_error(client, storage);
+	else    
+		client_send_ok(client, "Renamescript completed.");
+
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-setactive.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-setactive.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/cmd-setactive.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/cmd-setactive.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,57 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "commands.h"
+
+#include "sieve-storage.h"
+#include "sieve-storage-script.h"
+
+bool cmd_setactive(struct client_command_context *cmd)
+{
+	struct client *client = cmd->client;
+	struct sieve_storage *storage = client->storage;
+	const char *scriptname;
+	struct sieve_script *script;
+	bool exists;
+	int ret;
+
+	/* <scriptname> */
+	if (!client_read_string_args(cmd, 1, &scriptname))
+		return FALSE;
+
+	if ( *scriptname != '\0' ) {
+		exists = TRUE;
+		script = sieve_storage_script_init(storage, scriptname, &exists);
+
+		if ( script == NULL ) {
+			if (!exists)
+				client_send_noresp(client, "NONEXISTENT", "Script does not exist.");
+			else
+				client_send_storage_error(client, storage);
+
+			return TRUE;
+		}
+	
+		ret = sieve_storage_script_activate(script);
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ? 
+				"Setactive completed." :
+				"Script is already active.");
+
+		sieve_script_unref(&script);
+	} else {
+		ret = sieve_storage_deactivate(storage);
+		
+		if ( ret < 0 )
+			client_send_storage_error(client, storage);
+		else
+			client_send_ok(client, ret ?
+ 				"Active script is now deactivated." :
+				"No scripts currently active.");	
+	}
+
+	return TRUE;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/commands.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/commands.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/commands.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/commands.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,115 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "array.h"
+#include "commands.h"
+
+#include <stdlib.h>
+
+/* Might want to combine this somewhere in a commands-common.c 
+ * to avoid duplicate code 
+ */
+
+const struct command managesieve_commands[] = {
+	{ "CAPABILITY", cmd_capability },
+	{ "LOGOUT", cmd_logout },
+	{ "PUTSCRIPT", cmd_putscript },
+	{ "CHECKSCRIPT", cmd_checkscript },
+	{ "GETSCRIPT", cmd_getscript },
+	{ "SETACTIVE", cmd_setactive },
+	{ "DELETESCRIPT", cmd_deletescript },
+	{ "LISTSCRIPTS", cmd_listscripts },
+	{ "HAVESPACE", cmd_havespace },
+	{ "RENAMESCRIPT", cmd_renamescript },
+	{ "NOOP", cmd_noop }
+};
+
+#define MANAGESIEVE_COMMANDS_COUNT N_ELEMENTS(managesieve_commands) 
+
+static ARRAY_DEFINE(commands, struct command);
+static bool commands_unsorted;
+
+void command_register(const char *name, command_func_t *func)
+{
+	struct command cmd;
+
+	cmd.name = name;
+	cmd.func = func;
+	array_append(&commands, &cmd, 1);
+
+	commands_unsorted = TRUE;
+}
+
+void command_unregister(const char *name)
+{
+	const struct command *cmd;
+	unsigned int i, count;
+
+	cmd = array_get(&commands, &count);
+	for (i = 0; i < count; i++) {
+		if (strcasecmp(cmd[i].name, name) == 0) {
+			array_delete(&commands, i, 1);
+			return;
+		}
+	}
+
+	i_error("Trying to unregister unknown command '%s'", name);
+}
+
+void command_register_array(const struct command *cmdarr, unsigned int count)
+{
+	commands_unsorted = TRUE;
+	array_append(&commands, cmdarr, count);
+}
+
+void command_unregister_array(const struct command *cmdarr, unsigned int count)
+{
+	while (count > 0) {
+		command_unregister(cmdarr->name);
+		count--; cmdarr++;
+	}
+}
+
+static int command_cmp(const void *p1, const void *p2)
+{
+	const struct command *c1 = p1, *c2 = p2;
+
+	return strcasecmp(c1->name, c2->name);
+}
+
+static int command_bsearch(const void *name, const void *cmd_p)
+{
+	const struct command *cmd = cmd_p;
+
+	return strcasecmp(name, cmd->name);
+}
+
+struct command *command_find(const char *name)
+{
+    void *base;
+    unsigned int count;
+
+    base = array_get_modifiable(&commands, &count);
+    if (commands_unsorted) {
+        qsort(base, count, sizeof(struct command), command_cmp);
+                commands_unsorted = FALSE;
+    }
+
+    return bsearch(name, base, count, sizeof(struct command),
+               command_bsearch);
+}
+
+void commands_init(void)
+{
+	i_array_init(&commands, 16);
+	commands_unsorted = FALSE;
+	
+	command_register_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+}
+
+void commands_deinit(void)
+{
+	command_unregister_array(managesieve_commands, MANAGESIEVE_COMMANDS_COUNT);
+	array_free(&commands);
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/commands.h dovecot-1.2.4/dovecot-managesieve/src/managesieve/commands.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/commands.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/commands.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,49 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __COMMANDS_H
+#define __COMMANDS_H
+
+struct client_command_context;
+
+#include "managesieve-parser.h"
+
+typedef bool command_func_t(struct client_command_context *cmd);
+
+struct command {
+	const char *name;
+	command_func_t *func;
+};
+
+/* Register command. Given name parameter must be permanently stored until
+   command is unregistered. */
+void command_register(const char *name, command_func_t *func);
+void command_unregister(const char *name);
+
+/* Register array of commands. */
+void command_register_array(const struct command *cmdarr, unsigned int count);
+void command_unregister_array(const struct command *cmdarr, unsigned int count);
+
+struct command *command_find(const char *name);
+
+void commands_init(void);
+void commands_deinit(void);
+
+/* MANAGESIEVE commands: */
+
+/* Non-Authenticated State */
+extern bool cmd_logout(struct client_command_context *cmd);
+extern bool cmd_capability(struct client_command_context *cmd);
+extern bool cmd_noop(struct client_command_context *cmd);
+
+/* Authenticated State */
+extern bool cmd_putscript(struct client_command_context *cmd);
+extern bool cmd_checkscript(struct client_command_context *cmd);
+extern bool cmd_getscript(struct client_command_context *cmd);
+extern bool cmd_setactive(struct client_command_context *cmd);
+extern bool cmd_deletescript(struct client_command_context *cmd);
+extern bool cmd_listscripts(struct client_command_context *cmd);
+extern bool cmd_havespace(struct client_command_context *cmd);
+extern bool cmd_renamescript(struct client_command_context *cmd);
+
+#endif /* __COMMANDS_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/common.h dovecot-1.2.4/dovecot-managesieve/src/managesieve/common.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/common.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/common.h	2009-01-27 17:03:40.000000000 +0100
@@ -0,0 +1,46 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#include "lib.h"
+#include "client.h"
+
+#include "dmanagesieve-config.h"
+
+/* Disconnect client after idling this many milliseconds */
+#define CLIENT_IDLE_TIMEOUT_MSECS (60*30*1000)
+
+/* If we can't send anything to client for this long, disconnect the client */
+#define CLIENT_OUTPUT_TIMEOUT_MSECS (5*60*1000)
+
+/* Stop buffering more data into output stream after this many bytes */
+#define CLIENT_OUTPUT_OPTIMAL_SIZE 2048
+
+/* Disconnect client when it sends too many bad commands in a row */
+#define CLIENT_MAX_BAD_COMMANDS 20
+
+/* RFC-2683 recommends at least 8000 bytes. Some clients however don't
+   break large message sets to multiple commands, so we're pretty liberal
+   by default. */
+#define DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH 65536
+
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING MANAGESIEVE_NAME
+
+#define DEFAULT_MANAGESIEVE_SIEVE_MAX_ERRORS 10
+
+enum client_workarounds {
+  WORKAROUND_NONE    = 0x00,
+};
+
+extern struct ioloop *ioloop;
+extern unsigned int managesieve_max_line_length;
+extern const char *managesieve_implementation_string;
+extern enum client_workarounds client_workarounds;
+extern const char *logout_format;
+
+//extern void (*hook_mail_storage_created)(struct sieve_storage *storage);
+extern void (*hook_client_created)(struct client **client);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/main.c dovecot-1.2.4/dovecot-managesieve/src/managesieve/main.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/main.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/main.c	2009-07-12 20:37:57.000000000 +0200
@@ -0,0 +1,350 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "ioloop.h"
+#include "network.h"
+#include "ostream.h"
+#include "str.h"
+#include "lib-signals.h"
+#include "restrict-access.h"
+#include "fd-close-on-exec.h"
+#include "process-title.h"
+#include "randgen.h"
+#include "module-dir.h"
+#include "dict-client.h"
+
+#include "sieve-storage.h"
+#include "sieve.h"
+
+#include "commands.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+
+#define IS_STANDALONE() \
+        (getenv("LOGGED_IN") == NULL)
+
+#define CRITICAL_MSG \
+  "Internal error occured. Refer to server log for more information."
+#define CRITICAL_MSG_STAMP CRITICAL_MSG " [%Y-%m-%d %H:%M:%S]"
+
+struct client_workaround_list {
+	const char *name;
+	enum client_workarounds num;
+};
+
+struct client_workaround_list client_workaround_list[] = {
+	{ NULL, 0 }
+};
+
+struct ioloop *ioloop;
+unsigned int managesieve_max_line_length;
+const char *managesieve_implementation_string;
+enum client_workarounds client_workarounds = 0;
+const char *logout_format;
+
+static struct io *log_io = NULL;
+static struct module *modules = NULL;
+static char log_prefix[128]; /* syslog() needs this to be permanent */
+
+void (*hook_client_created)(struct client **client) = NULL;
+
+static void sig_die(const siginfo_t *si, void *context ATTR_UNUSED)
+{
+	/* Warn about being killed because of some signal, except SIGINT (^C) */
+	if (si->si_signo != SIGINT) {
+		i_warning("Killed with signal %d (by pid=%s uid=%s code=%s)",
+			si->si_signo, dec2str(si->si_pid),
+			dec2str(si->si_uid),
+			lib_signal_code_to_str(si->si_signo, si->si_code));
+	}
+	io_loop_stop(ioloop);
+}
+
+static void log_error_callback(void *context ATTR_UNUSED)
+{
+	/* the log fd is closed, don't die when trying to log later */
+	i_set_failure_ignore_errors(TRUE);
+	
+	io_loop_stop(ioloop);
+}
+
+static void parse_workarounds(void)
+{
+	struct client_workaround_list *list;
+	const char *env, *const *str;
+
+	env = getenv("MANAGESIEVE_CLIENT_WORKAROUNDS");
+	if (env == NULL)
+		return;
+
+	for (str = t_strsplit_spaces(env, " ,"); *str != NULL; str++) {
+		list = client_workaround_list;
+		for (; list->name != NULL; list++) {
+			if (strcasecmp(*str, list->name) == 0) {
+				client_workarounds |= list->num;
+				break;
+			}
+		}
+		if (list->name == NULL)
+			i_fatal("Unknown client workaround: %s", *str);
+	}
+}
+
+static void open_logfile(void)
+{
+	const char *user;
+
+	if (getenv("LOG_TO_MASTER") != NULL) {
+		i_set_failure_internal();
+		return;
+	}
+
+ 	if (getenv("LOG_PREFIX") != NULL)
+		strncpy(log_prefix, getenv("LOG_PREFIX"), sizeof(log_prefix));
+	else {
+		user = getenv("USER");
+		if (user == NULL) {
+			if (IS_STANDALONE())
+				user = getlogin();
+			if (user == NULL)
+				user = "??";
+		}
+		if (strlen(user) >= sizeof(log_prefix)-6) {	
+			/* quite a long user name, cut it */
+ 			user = t_strndup(user, sizeof(log_prefix)-6-2);
+			user = t_strconcat(user, "..", NULL);
+		}
+		i_snprintf(log_prefix, sizeof(log_prefix), "imap(%s): ", user);
+	}
+
+	if (getenv("USE_SYSLOG") != NULL) {
+		const char *env = getenv("SYSLOG_FACILITY");
+		i_set_failure_syslog(log_prefix, LOG_NDELAY,
+				     env == NULL ? LOG_MAIL : atoi(env));
+	} else {
+		/* log to file or stderr */
+		i_set_failure_file(getenv("LOGFILE"), log_prefix);
+	}
+
+	if (getenv("INFOLOGFILE") != NULL)
+		i_set_info_file(getenv("INFOLOGFILE"));
+
+	i_set_failure_timestamp_format(getenv("LOGSTAMP"));
+}
+
+static void drop_privileges(void)
+{
+	const char *version;
+
+	version = getenv("DOVECOT_VERSION");
+	if (version != NULL && strcmp(version, PACKAGE_VERSION) != 0) {
+		i_fatal("Dovecot version mismatch: "
+			"Master is v%s, managesieve is v"PACKAGE_VERSION" "
+			"(if you don't care, set version_ignore=yes)", version);
+	}
+
+	/* Log file or syslog opening probably requires roots */
+	open_logfile();
+
+	/* Load the plugins before chrooting. Their init() is called later. */
+	/* FIXME: MAIL_PLUGINS is a rather odd config value for a MANAGESIEVE
+	 * server 
+	 */
+	if (getenv("MAIL_PLUGINS") != NULL) {
+		const char *plugin_dir = getenv("MAIL_PLUGIN_DIR");
+
+		if (plugin_dir == NULL)
+			plugin_dir = MODULEDIR"/managesieve";
+		modules = module_dir_load(plugin_dir, getenv("MAIL_PLUGINS"),
+			TRUE, version);
+	}	
+
+	restrict_access_by_env(!IS_STANDALONE());
+    restrict_access_allow_coredumps(TRUE);
+}
+
+static void internal_error()
+{
+  struct tm *tm;
+  char str[256];
+
+  tm = localtime(&ioloop_time);
+
+  printf("BYE \"%s\"\n",
+    strftime(str, sizeof(str), CRITICAL_MSG_STAMP, tm) > 0 ?
+    i_strdup(str) : i_strdup(CRITICAL_MSG));
+}
+
+static void main_init(void)
+{
+	struct sieve_storage *storage;
+	struct client *client;
+	const char *username, *home, *str, *sieve_storage, *mail;
+	const char *extensions;
+
+	lib_signals_init();
+	lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+	lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+	lib_signals_ignore(SIGPIPE, TRUE);
+	lib_signals_ignore(SIGALRM, FALSE);
+
+	username = getenv("USER");
+	if (username == NULL) {
+		if (IS_STANDALONE())
+			username = getlogin();
+		if (username == NULL) {
+			internal_error();
+			i_fatal("USER environment missing");
+		}
+	}
+
+    home = getenv("HOME");
+	if (getenv("DEBUG") != NULL) {
+		i_info("Effective uid=%s, gid=%s, home=%s",
+			dec2str(geteuid()), dec2str(getegid()),
+ 			home != NULL ? home : "(none)");
+    }
+
+	if (getenv("STDERR_CLOSE_SHUTDOWN") != NULL) {
+		/* If master dies, the log fd gets closed and we'll quit */
+		log_io = io_add(STDERR_FILENO, IO_ERROR,
+				log_error_callback, NULL);
+	}
+
+	sieve_init();
+	dict_drivers_register_builtin();
+	clients_init();
+	commands_init();
+
+	module_dir_init(modules);
+
+	/* Sieve settings */
+	
+	extensions = getenv("SIEVE_EXTENSIONS");
+	if ( extensions != NULL ) {
+		sieve_set_extensions(extensions);
+	}
+
+	/* Dump capabilities if requested */
+
+	if ( getenv("DUMP_CAPABILITY") != NULL ) {
+		const char *notify_cap = sieve_get_capabilities("notify");
+
+		if ( notify_cap == NULL ) 
+			printf("SIEVE: %s\n", sieve_get_capabilities(NULL));
+		else
+			printf("SIEVE: %s, NOTIFY: %s\n", sieve_get_capabilities(NULL),
+				sieve_get_capabilities("notify"));
+		exit(0);
+	}
+
+	/* Service settings */
+
+	str = getenv("MANAGESIEVE_MAX_LINE_LENGTH");
+	managesieve_max_line_length = str != NULL ?
+		(unsigned int)strtoul(str, NULL, 10) :
+		DEFAULT_MANAGESIEVE_MAX_LINE_LENGTH;
+
+	logout_format = getenv("MANAGESIEVE_LOGOUT_FORMAT");
+	if (logout_format == NULL)
+		logout_format = "bytes=%i/%o";
+
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+		str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	parse_workarounds();
+
+	/* Obtain Sieve storage */		
+
+	mail = getenv("MAIL");
+	sieve_storage = getenv("SIEVE_DIR");
+	
+	if ( sieve_storage == NULL || *sieve_storage == '\0' ) {
+		/* Storage perhaps specified as depricated sieve_storage? */
+		sieve_storage = getenv("SIEVE_STORAGE");
+	}		
+
+	if ( (sieve_storage == NULL || *sieve_storage == '\0') &&
+		!(mail == NULL || *mail == '\0') ) {
+		storage = sieve_storage_create_from_mail(mail, username);
+	} else 
+		storage = sieve_storage_create(sieve_storage, username);
+
+	if (storage == NULL) {
+		internal_error();
+
+		/* failed */
+		if (sieve_storage != NULL && *sieve_storage != '\0')
+			i_fatal("Failed to create sieve storage with data: %s", sieve_storage);
+		else if (mail != NULL && *mail != '\0')
+			i_fatal("Failed to create sieve storage with mail-data: %s", mail);
+		else {
+			const char *home;
+	    
+			home = getenv("HOME");
+			if (home == NULL) home = "not set";
+	    
+			i_fatal("SIEVE_STORAGE and MAIL environment missing and "
+				"autodetection failed (home %s)", home);
+		}
+	}
+	
+	client = client_create(0, 1, storage);
+	
+	client_send_ok(client, "Logged in.");
+}
+
+static void main_deinit(void)
+{
+	if (log_io != NULL)
+		io_remove(&log_io);
+	clients_deinit();
+
+	module_dir_unload(&modules);
+	commands_deinit();
+	dict_drivers_unregister_builtin();
+	sieve_deinit();
+
+	lib_signals_deinit();
+	closelog();
+}
+
+int main(int argc ATTR_UNUSED, char *argv[], char *envp[])
+{
+#ifdef DEBUG
+	if (getenv("LOGGED_IN") != NULL && getenv("GDB") == NULL)
+		fd_debug_verify_leaks(3, 1024);
+#endif
+	if (IS_STANDALONE() && getuid() == 0 &&
+		net_getpeername(1, NULL, NULL) == 0) {
+		printf("NO \"managesieve binary must not be started from "
+		       "inetd, use managesieve-login instead.\"\n");
+		return 1;
+	}
+
+	/* NOTE: we start rooted, so keep the code minimal until
+	   restrict_access_by_env() is called */
+	lib_init();
+	drop_privileges();
+
+	process_title_init(argv, envp);
+	ioloop = io_loop_create();
+
+    /* fake that we're running, so we know if client was destroyed
+       while initializing */
+	io_loop_set_running(ioloop);
+	main_init();
+	if (io_loop_is_running(ioloop))
+		io_loop_run(ioloop);
+	main_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+
+	return 0;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/Makefile.am dovecot-1.2.4/dovecot-managesieve/src/managesieve/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/Makefile.am	2008-11-21 22:25:03.000000000 +0100
@@ -0,0 +1,64 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-DMODULEDIR=\""$(moduledir)"\" \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_LDFLAGS = -export-dynamic
+
+libs = \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+
+managesieve_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS) 
+
+managesieve_DEPENDENCIES = $(libs)
+
+cmds = \
+	cmd-capability.c \
+	cmd-logout.c \
+	cmd-putscript.c \
+	cmd-getscript.c \
+	cmd-setactive.c \
+	cmd-deletescript.c \
+	cmd-listscripts.c \
+	cmd-havespace.c \
+	cmd-renamescript.c \
+	cmd-noop.c
+
+managesieve_SOURCES = \
+	$(cmds) \
+	client.c \
+	commands.c \
+	main.c 
+
+noinst_HEADERS = \
+	client.h \
+	commands.h \
+	common.h 
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/Makefile.in dovecot-1.2.4/dovecot-managesieve/src/managesieve/Makefile.in
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve/Makefile.in	2009-08-21 01:05:45.000000000 +0200
@@ -0,0 +1,571 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+pkglibexec_PROGRAMS = managesieve$(EXEEXT)
+subdir = src/managesieve
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(pkglibexecdir)"
+pkglibexecPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(pkglibexec_PROGRAMS)
+am__objects_1 = cmd-capability.$(OBJEXT) cmd-logout.$(OBJEXT) \
+	cmd-putscript.$(OBJEXT) cmd-getscript.$(OBJEXT) \
+	cmd-setactive.$(OBJEXT) cmd-deletescript.$(OBJEXT) \
+	cmd-listscripts.$(OBJEXT) cmd-havespace.$(OBJEXT) \
+	cmd-renamescript.$(OBJEXT) cmd-noop.$(OBJEXT)
+am_managesieve_OBJECTS = $(am__objects_1) client.$(OBJEXT) \
+	commands.$(OBJEXT) main.$(OBJEXT)
+managesieve_OBJECTS = $(am_managesieve_OBJECTS)
+am__DEPENDENCIES_1 =
+am__DEPENDENCIES_2 =  \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(am__DEPENDENCIES_1) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+managesieve_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(managesieve_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(managesieve_SOURCES)
+DIST_SOURCES = $(managesieve_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SIEVE_PLUGIN_TOP = @SIEVE_PLUGIN_TOP@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+pkglibexecdir = $(libexecdir)/dovecot
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-dict \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-DMODULEDIR=\""$(moduledir)"\" \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(top_srcdir)/src/lib-sievestorage \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_LDFLAGS = -export-dynamic
+libs = \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-dict/libdict.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib/liblib.a
+
+managesieve_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS) 
+
+managesieve_DEPENDENCIES = $(libs)
+cmds = \
+	cmd-capability.c \
+	cmd-logout.c \
+	cmd-putscript.c \
+	cmd-getscript.c \
+	cmd-setactive.c \
+	cmd-deletescript.c \
+	cmd-listscripts.c \
+	cmd-havespace.c \
+	cmd-renamescript.c \
+	cmd-noop.c
+
+managesieve_SOURCES = \
+	$(cmds) \
+	client.c \
+	commands.c \
+	main.c 
+
+noinst_HEADERS = \
+	client.h \
+	commands.h \
+	common.h 
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/managesieve/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/managesieve/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pkglibexecPROGRAMS: $(pkglibexec_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkglibexecdir)" || $(MKDIR_P) "$(DESTDIR)$(pkglibexecdir)"
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(pkglibexecPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(pkglibexecPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(pkglibexecdir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-pkglibexecPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pkglibexecdir)/$$f"; \
+	done
+
+clean-pkglibexecPROGRAMS:
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+managesieve$(EXEEXT): $(managesieve_OBJECTS) $(managesieve_DEPENDENCIES) 
+	@rm -f managesieve$(EXEEXT)
+	$(managesieve_LINK) $(managesieve_OBJECTS) $(managesieve_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-capability.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-deletescript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-getscript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-havespace.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-listscripts.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-logout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-noop.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-putscript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-renamescript.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-setactive.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/commands.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(pkglibexecdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pkglibexecPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am: install-pkglibexecPROGRAMS
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-pkglibexecPROGRAMS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pkglibexecPROGRAMS ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-pkglibexecPROGRAMS \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-pkglibexecPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client-authenticate.c dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client-authenticate.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client-authenticate.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client-authenticate.c	2009-08-12 22:43:59.000000000 +0200
@@ -0,0 +1,423 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "base64.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "str-sanitize.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+#include "auth-client.h"
+#include "client.h"
+#include "client-authenticate.h"
+#include "managesieve-proxy.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+
+#define AUTH_FAILURE_DELAY_INCREASE_MSECS 5000
+
+#define MANAGESIEVE_SERVICE_NAME "sieve"
+
+/* FIXME: The use of the ANONYMOUS mechanism is currently denied 
+ */
+static bool _sasl_mechanism_acceptable
+	(const struct auth_mech_desc *mech, bool secured) {
+
+	/* a) transport is secured
+	   b) auth mechanism isn't plaintext
+       c) we allow insecure authentication
+	 */
+
+	if ((mech->flags & MECH_SEC_PRIVATE) == 0 &&
+		(mech->flags & MECH_SEC_ANONYMOUS) == 0 &&
+ 		(secured || !disable_plaintext_auth ||
+		(mech->flags & MECH_SEC_PLAINTEXT) == 0)) {
+    		return 1;     
+	}  
+
+	return 0;
+}
+
+const char *client_authenticate_get_capabilities(bool secured)
+{
+	const struct auth_mech_desc *mech;
+	unsigned int i, count;
+	string_t *str;
+
+	str = t_str_new(128);
+	mech = auth_client_get_available_mechs(auth_client, &count);
+
+	if ( count > 0 ) {
+		if ( _sasl_mechanism_acceptable(&(mech[0]), secured) ) {
+			str_append(str, mech[0].name);
+		}
+     
+		for (i = 1; i < count; i++) {
+			if ( _sasl_mechanism_acceptable(&(mech[i]), secured) ) {
+				str_append_c(str, ' ');
+				str_append(str, mech[i].name);
+			}
+		}
+	}
+
+	return str_c(str);
+}
+
+static void client_auth_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	char *line;
+	bool fatal;
+
+	if (!client_read(client))
+		return;
+
+	if (client->skip_line) {
+		if (i_stream_next_line(client->common.input) == NULL)
+			return;
+
+		client->skip_line = FALSE;
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			/* FIXME: What to do? */
+		}
+	  
+		sasl_server_auth_failed(&client->common, msg);
+		return;
+	case -2:
+		/* not enough data */
+		return;
+	}
+
+	client->skip_line = TRUE;
+
+	if (args[0].type != MANAGESIEVE_ARG_STRING || 
+		args[1].type != MANAGESIEVE_ARG_EOL) {
+		sasl_server_auth_failed(&client->common, 
+			"Invalid AUTHENTICATE client response.");
+		return;
+	}
+
+	line = MANAGESIEVE_ARG_STR(&args[0]);
+
+  	if (strcmp(line, "*") == 0)
+		sasl_server_auth_abort(&client->common);
+    else {
+		client_set_auth_waiting(client);
+		auth_client_request_continue(client->common.auth_request, line);
+		io_remove(&client->io);
+	
+		/* clear sensitive data */
+		safe_memset(line, 0, strlen(line));
+	}
+}
+
+static void client_authfail_delay_timeout(struct managesieve_client *client)
+{
+	timeout_remove(&client->to_authfail_delay);
+
+	/* get back to normal client input. */
+	i_assert(client->io == NULL);
+	client->io = io_add(client->common.fd, IO_READ, client_input, client);
+	client_input(client);
+}
+
+void client_auth_failed(struct managesieve_client *client, bool nodelay)
+{
+	unsigned int delay_msecs;
+
+	client->common.auth_command_tag = NULL;
+
+	if ( client->auth_initializing )
+		return;
+
+	if ( client->io != NULL )
+		io_remove(&client->io);
+	if ( nodelay ) {
+		client->io = io_add(client->common.fd, IO_READ, client_input, client);
+ 		client_input(client);
+		return;
+	}
+
+	/* increase the timeout after each unsuccessful attempt, but don't
+		increase it so high that the idle timeout would be triggered */
+	delay_msecs = client->common.auth_attempts *
+		AUTH_FAILURE_DELAY_INCREASE_MSECS;
+	if (delay_msecs > CLIENT_LOGIN_IDLE_TIMEOUT_MSECS)
+		delay_msecs = CLIENT_LOGIN_IDLE_TIMEOUT_MSECS - 1000;
+
+	i_assert(client->to_authfail_delay == NULL);
+	client->to_authfail_delay =
+		timeout_add(delay_msecs, client_authfail_delay_timeout, client);
+}
+
+static bool client_handle_args(struct managesieve_client *client,
+	const char *const *args, bool success, bool *nodelay_r)
+{
+	const char *reason = NULL, *host = NULL, *destuser = NULL, *pass = NULL;
+	const char *master_user = NULL;
+	const char *key, *value, *p;
+	enum login_proxy_ssl_flags ssl_flags = 0;
+	unsigned int port = 2000;
+	unsigned int proxy_timeout_msecs = 0;
+	bool proxy = FALSE, temp = FALSE, nologin = !success;
+	bool authz_failure = FALSE;
+
+	*nodelay_r = FALSE;
+	for (; *args != NULL; args++) {
+		p = strchr(*args, '=');
+		if (p == NULL) {
+			key = *args;
+			value = "";
+		} else {
+			key = t_strdup_until(*args, p);
+			value = p + 1;
+		}
+		if (strcmp(key, "nologin") == 0)
+			nologin = TRUE;
+		else if (strcmp(key, "nodelay") == 0)
+			*nodelay_r = TRUE;
+		else if (strcmp(key, "proxy") == 0)
+			proxy = TRUE;
+		else if (strcmp(key, "temp") == 0)
+			temp = TRUE;
+		else if (strcmp(key, "authz") == 0)
+			authz_failure = TRUE;
+		else if (strcmp(key, "reason") == 0)
+			reason = value + 7;
+		else if (strcmp(key, "host") == 0)
+			host = value;
+		else if (strcmp(key, "port") == 0)
+			port = atoi(value);
+		else if (strcmp(key, "destuser") == 0)
+			destuser = value;
+		else if (strcmp(key, "pass") == 0)
+			pass = value;
+		else if (strcmp(key, "proxy_timeout") == 0)
+			proxy_timeout_msecs = 1000*atoi(value);
+		else if (strcmp(key, "master") == 0)
+			master_user = value;
+		else if (strcmp(key, "ssl") == 0) {
+			if (strcmp(value, "yes") == 0)
+				ssl_flags |= PROXY_SSL_FLAG_YES;
+			else if (strcmp(value, "any-cert") == 0) {
+				ssl_flags |= PROXY_SSL_FLAG_YES |
+					PROXY_SSL_FLAG_ANY_CERT;
+			}
+		} else if (strcmp(key, "starttls") == 0) {
+			ssl_flags |= PROXY_SSL_FLAG_STARTTLS;
+		} else if (strcmp(key, "user") == 0) {
+			/* already handled in login-common */
+		} else if (auth_debug) {
+			i_info("Ignoring unknown passdb extra field: %s", key);
+		}
+	}
+
+	if (destuser == NULL)
+		destuser = client->common.virtual_user;
+
+	if (proxy) {
+		/* we want to proxy the connection to another server.
+		don't do this unless authentication succeeded. with
+		master user proxying we can get FAIL with proxy still set.
+
+		proxy host=.. [port=..] [destuser=..] pass=.. */
+		if (!success)
+			return FALSE;
+		if ( managesieve_proxy_new(client, host, port, destuser, master_user,
+			pass, ssl_flags, proxy_timeout_msecs) < 0 )
+			client_auth_failed(client, TRUE);
+		return TRUE;
+	}
+
+	if (host != NULL) {
+		string_t *resp_code;
+
+		/* MANAGESIEVE referral
+
+		   [nologin] referral host=.. [port=..] [destuser=..]
+		   [reason=..]
+
+		   NO (REFERRAL sieve://user;AUTH=mech@host:port/) Can't login.
+		   OK (...) Logged in, but you should use this server instead.
+		   .. [REFERRAL ..] (Reason from auth server)
+		*/
+		resp_code = t_str_new(128);
+		str_printfa(resp_code, "REFERRAL sieve://%s;AUTH=%s@%s",
+			    destuser, client->common.auth_mech_name, host);
+		if (port != 2000)
+			str_printfa(resp_code, ":%u", port);
+
+		if (reason == NULL) {
+			if (nologin)
+				reason = "Try this server instead.";
+			else 
+				reason = "Logged in, but you should use "
+					"this server instead.";
+		}
+
+		if (!nologin) {
+			client_send_okresp(client, str_c(resp_code), reason);
+			client_destroy_success(client, "Login with referral");
+			return TRUE;
+ 		}
+		client_send_noresp(client, str_c(resp_code), reason);
+	} else if (nologin) {
+		/* Authentication went ok, but for some reason user isn't
+		   allowed to log in. Shouldn't probably happen. */
+		if (reason != NULL)
+			client_send_no(client, reason);
+		else if (temp)
+			client_send_no(client, AUTH_TEMP_FAILED_MSG);
+		else if (authz_failure) 
+			client_send_no(client, "Authorization failed.");
+		else
+			client_send_no(client, AUTH_FAILED_MSG);
+	} else {
+		/* normal login/failure */
+		return FALSE;
+	}
+
+	i_assert(nologin);
+
+	managesieve_parser_reset(client->parser);
+
+	if (!client->destroyed) 
+		client_auth_failed(client, *nodelay_r);
+	return TRUE;
+}
+
+static void sasl_callback(struct client *_client, enum sasl_server_reply reply,
+			  const char *data, const char *const *args)
+{
+	struct managesieve_client *client = (struct managesieve_client *)_client;
+	string_t *str;
+	bool nodelay;
+
+	i_assert(!client->destroyed ||
+		reply == SASL_SERVER_REPLY_AUTH_ABORTED ||
+		reply == SASL_SERVER_REPLY_MASTER_FAILED);
+
+	switch (reply) {
+	case SASL_SERVER_REPLY_SUCCESS:
+		if ( client->to_auth_waiting != NULL )
+			timeout_remove(&client->to_auth_waiting);
+		if (args != NULL) {
+			if (client_handle_args(client, args, TRUE, &nodelay))
+				break;
+		}
+
+		client_destroy_success(client, "Login");
+		break;
+
+	case SASL_SERVER_REPLY_AUTH_FAILED:
+	case SASL_SERVER_REPLY_AUTH_ABORTED:
+		if ( client->to_auth_waiting != NULL )
+			timeout_remove(&client->to_auth_waiting);
+		if (args != NULL) {
+			if (client_handle_args(client, args, FALSE, &nodelay))
+				break;
+		}
+
+
+		if ( reply == SASL_SERVER_REPLY_AUTH_ABORTED )
+			client_send_no(client, "Authentication aborted by client.");
+		else
+			client_send_no(client, data != NULL ? data : AUTH_FAILED_MSG);
+
+		managesieve_parser_reset(client->parser);
+
+		if (!client->destroyed) 
+			client_auth_failed(client, nodelay);
+		break;
+
+	case SASL_SERVER_REPLY_MASTER_FAILED:
+		if (data == NULL)
+			client_destroy_internal_failure(client);
+		else {
+			client_send_no(client, data);
+			client_destroy_success(client, data);
+		}
+		break;
+
+	case SASL_SERVER_REPLY_CONTINUE:
+		T_BEGIN {
+			str = t_str_new(256);
+			managesieve_quote_append_string(str, data, TRUE);
+			str_append(str, "\r\n");
+				
+			/* don't check return value here. it gets tricky if we try
+			   to call client_destroy() in here. */
+			(void)o_stream_send(client->output, str_c(str), str_len(str));
+		} T_END;
+
+		managesieve_parser_reset(client->parser);
+
+		i_assert(client->io == NULL);
+		client->io = io_add(client->common.fd, IO_READ, client_auth_input, client);
+		client_auth_input(client);
+		return;
+	}
+
+	client_unref(client);
+}
+
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args)
+{
+	const char *mech_name, *init_resp = NULL;
+
+	/* one mandatory argument: authentication mechanism name */
+	if (args[0].type != MANAGESIEVE_ARG_STRING)
+		return -1;
+	if (args[1].type != MANAGESIEVE_ARG_EOL) {
+		/* optional SASL initial response */
+		if (args[1].type != MANAGESIEVE_ARG_STRING ||
+		    args[2].type != MANAGESIEVE_ARG_EOL)
+			return -1;
+		init_resp = MANAGESIEVE_ARG_STR(&args[1]);
+	}
+
+	mech_name = MANAGESIEVE_ARG_STR(&args[0]);
+	if (*mech_name == '\0') 
+		return -1;
+
+	/* FIXME: This refuses the ANONYMOUS mechanism. 
+	 *   This can be removed once anonymous login is implemented according to the 
+	 *   draft RFC. - Stephan
+	 */
+	if ( strncasecmp(mech_name, "ANONYMOUS", 9) == 0 ) {
+		client_send_no(client, "ANONYMOUS mechanism is not implemented.");		
+		return 0;
+	}
+
+	client_ref(client);
+	client->auth_initializing = TRUE;
+	sasl_server_auth_begin(&client->common, MANAGESIEVE_SERVICE_NAME, mech_name,
+		init_resp, sasl_callback);
+	client->auth_initializing = FALSE;
+	if (!client->common.authenticating)
+		return 1;
+
+	/* don't handle input until we get the initial auth reply */
+	if (client->io != NULL)
+		io_remove(&client->io);
+	client_set_auth_waiting(client);
+
+	managesieve_parser_reset(client->parser);
+
+	return 0;
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client-authenticate.h dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client-authenticate.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client-authenticate.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client-authenticate.h	2009-05-03 15:58:06.000000000 +0200
@@ -0,0 +1,14 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __CLIENT_AUTHENTICATE_H
+#define __CLIENT_AUTHENTICATE_H
+
+const char *client_authenticate_get_capabilities(bool secured);
+
+int cmd_login(struct managesieve_client *client, struct managesieve_arg *args);
+int cmd_authenticate(struct managesieve_client *client, struct managesieve_arg *args);
+
+void client_auth_failed(struct managesieve_client *client, bool nodelay);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client.c dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client.c	2009-07-10 09:08:29.000000000 +0200
@@ -0,0 +1,731 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "common.h"
+#include "buffer.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "process-title.h"
+#include "safe-memset.h"
+#include "str.h"
+#include "strfuncs.h"
+#include "strescape.h"
+
+#include "sieve.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+#include "client.h"
+#include "client-authenticate.h"
+#include "commands.h"
+#include "auth-client.h"
+#include "ssl-proxy.h"
+
+#include "managesieve-capability.h"
+#include "managesieve-proxy.h"
+
+#include <stdlib.h>
+
+/* max. size of output buffer. if it gets full, the client is disconnected.
+   SASL authentication gives the largest output. */
+#define MAX_OUTBUF_SIZE 4096
+
+/* Disconnect client when it sends too many bad commands */
+#define CLIENT_MAX_BAD_COMMANDS 10
+
+/* When max. number of simultaneous connections is reached, few of the
+   oldest connections are disconnected. Since we have to go through all of the
+   clients, it's faster if we disconnect multiple clients. */
+#define CLIENT_DESTROY_OLDEST_COUNT 16
+
+/* If we've been waiting auth server to respond for over this many milliseconds,
+   send a "waiting" message. */
+#define AUTH_WAITING_TIMEOUT_MSECS (30*1000)
+
+#if CLIENT_LOGIN_IDLE_TIMEOUT_MSECS < AUTH_REQUEST_TIMEOUT*1000
+#  error client idle timeout must be larger than authentication timeout
+#endif
+
+const char *login_protocol = "MANAGESIEVE";
+const char *capability_string = NULL;
+
+const char *managesieve_implementation_string;
+
+static void client_set_title(struct managesieve_client *client)
+{
+	const char *addr;
+
+	if (!verbose_proctitle || !process_per_connection)
+		return;
+
+	addr = net_ip2addr(&client->common.ip);
+	if (addr == NULL)
+		addr = "??";
+
+	process_title_set(t_strdup_printf(client->common.tls ?
+					  "[%s TLS]" : "[%s]", addr));
+}
+
+static void client_open_streams(struct managesieve_client *client, int fd)
+{
+	client->common.input =
+		i_stream_create_fd(fd, LOGIN_MAX_INBUF_SIZE, FALSE);
+	client->output = o_stream_create_fd(fd, MAX_OUTBUF_SIZE, FALSE);
+	client->parser = managesieve_parser_create(client->common.input, client->output,
+					    MAX_MANAGESIEVE_LINE);
+}
+
+/* Skip incoming data until newline is found,
+   returns TRUE if newline was found. */
+bool client_skip_line(struct managesieve_client *client)
+{
+	const unsigned char *data;
+	size_t i, data_size;
+
+	data = i_stream_get_data(client->common.input, &data_size);
+
+	for (i = 0; i < data_size; i++) {
+		if (data[i] == '\n') {
+			i_stream_skip(client->common.input, i+1);
+			return TRUE;
+		}
+	}
+
+	return FALSE;
+}
+
+static void client_send_capabilities(struct managesieve_client *client)
+{
+	const char *saslcap, *sievecap, *notifycap;
+
+	T_BEGIN {
+		/* Get capabilities */
+		sievecap = managesieve_capability_sieve;
+		saslcap = client_authenticate_get_capabilities(client->common.secured);
+		notifycap = managesieve_capability_notify;
+
+		/* Default capabilities */
+		client_send_line(client, t_strconcat("\"IMPLEMENTATION\" \"", 
+			managesieve_implementation_string, "\"", NULL));
+		client_send_line(client, t_strconcat("\"SIEVE\" \"",
+			( sievecap == NULL ? "" : sievecap ), "\"", NULL));
+		client_send_line(client, t_strconcat("\"SASL\" \"", 
+			saslcap, "\"", NULL));
+
+		/* STARTTLS */
+		if (ssl_initialized && !client->common.tls)
+			client_send_line(client, "\"STARTTLS\"" );
+
+		/* Notify methods */
+		if ( notifycap != NULL ) {
+			client_send_line(client, t_strconcat("\"NOTIFY\" \"", 
+				notifycap, "\"", NULL));
+		}
+
+		/* Protocol version */
+		client_send_line(client, "\"VERSION\" \"1.0\"");
+	} T_END;
+}
+
+static int cmd_capability(struct managesieve_client *client)
+{
+	o_stream_cork(client->output);
+
+	client_send_capabilities(client);
+	client_send_ok(client, "Capability completed.");
+
+	o_stream_uncork(client->output);
+
+	return 1;
+}
+
+static void client_start_tls(struct managesieve_client *client)
+{
+	int fd_ssl;
+
+	client_ref(client);
+	connection_queue_add(1);
+	if (!client_unref(client) || client->destroyed)
+		return;
+
+	fd_ssl = ssl_proxy_new(client->common.fd, &client->common.ip,
+			       &client->common.proxy);
+	if (fd_ssl == -1) {
+		client_send_bye(client, "TLS initialization failed.");
+		client_destroy(client, "Disconnected: TLS initialization failed.");
+		return;
+	}
+
+	client->common.tls = TRUE;
+	client->common.secured = TRUE;
+	client_set_title(client);
+
+	client->common.fd = fd_ssl;
+	i_stream_unref(&client->common.input);
+	o_stream_unref(&client->output);
+	managesieve_parser_destroy(&client->parser);
+
+	/* CRLF is lost from buffer when streams are reopened. */
+	client->skip_line = FALSE;
+
+	client_open_streams(client, fd_ssl);
+	client->io = io_add(client->common.fd, IO_READ, client_input, client);
+}
+
+static int client_output_starttls(void *context)
+{
+	struct managesieve_client *client = context;
+	int ret;
+
+	if ((ret = o_stream_flush(client->output)) < 0) {
+		client_destroy(client, "Disconnected");
+		return 1;
+	}
+
+	if (ret > 0) {
+		o_stream_unset_flush_callback(client->output);
+		client_start_tls(client);
+	}
+	return 1;
+}
+
+static int cmd_starttls(struct managesieve_client *client)
+{
+	if (client->common.tls) {
+		client_send_no(client, "TLS is already active.");
+		return 1;
+	}
+
+	if (!ssl_initialized) {
+		client_send_no(client, "TLS support isn't enabled.");
+		return 1;
+	}
+
+	/* remove input handler, SSL proxy gives us a new fd. we also have to
+	   remove it in case we have to wait for buffer to be flushed */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	client_send_ok(client, "Begin TLS negotiation now.");
+
+	/* uncork the old fd */
+	o_stream_uncork(client->output);
+
+	if (o_stream_flush(client->output) <= 0) {
+		/* the buffer has to be flushed */
+		o_stream_set_flush_pending(client->output, TRUE);
+		o_stream_set_flush_callback(client->output,
+					    client_output_starttls, client);
+	} else {
+		client_start_tls(client);
+	}
+
+	/* Cork the stream to send the capability data as a single tcp frame
+	 *   Some naive clients break if we don't.
+	 */
+	o_stream_cork(client->output);
+
+	client_send_capabilities(client);
+	client_send_ok(client, "TLS negotiation successful.");
+
+	o_stream_uncork(client->output);
+
+	return 1;
+}
+
+static int cmd_logout(struct managesieve_client *client)
+{
+	client_send_ok(client, "Logout completed.");
+	client_destroy(client, "Aborted login");
+	return 1;
+}
+
+static int client_command_execute(struct managesieve_client *client, const char *cmd,
+				  struct managesieve_arg *args)
+{
+	cmd = t_str_ucase(cmd);
+	if (strcmp(cmd, "AUTHENTICATE") == 0)
+		return cmd_authenticate(client, args);
+	if (strcmp(cmd, "CAPABILITY") == 0)
+		return cmd_capability(client);
+	if (strcmp(cmd, "STARTTLS") == 0)
+		return cmd_starttls(client);
+	if (strcmp(cmd, "LOGOUT") == 0)
+		return cmd_logout(client);
+	if (strcmp(cmd, "NOOP") == 0)
+		return cmd_noop(client);
+
+	return -1;
+}
+
+static bool client_handle_input(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *msg;
+	int ret;
+	bool fatal;
+
+	i_assert(!client->common.authenticating);
+
+	if (client->cmd_finished) {
+		/* clear the previous command from memory. don't do this
+		   immediately after handling command since we need the
+		   cmd_tag to stay some time after authentication commands. */
+		client->cmd_name = NULL;
+		managesieve_parser_reset(client->parser);
+
+		/* remove \r\n */
+		if (client->skip_line) {
+			if (!client_skip_line(client))
+				return FALSE;
+			client->skip_line = FALSE;
+		}
+
+		client->cmd_finished = FALSE;
+	}
+
+	if (client->cmd_name == NULL) {
+		client->cmd_name = managesieve_parser_read_word(client->parser);
+		if (client->cmd_name == NULL)
+			return FALSE; /* need more data */
+	}
+
+	switch (managesieve_parser_read_args(client->parser, 0, 0, &args)) {
+	case -1:
+		/* error */
+		msg = managesieve_parser_get_error(client->parser, &fatal);
+		if (fatal) {
+			client_send_bye(client, msg);
+			client_destroy(client, t_strconcat("Disconnected: ",
+				msg, NULL));
+			return FALSE;
+		}
+
+		client_send_no(client, msg);
+		client->cmd_finished = TRUE;
+		client->skip_line = TRUE;
+		return TRUE;
+	case -2:
+		/* not enough data */
+		return FALSE;
+	}
+	/* we read the entire line - skip over the CRLF */
+	if (!client_skip_line(client))
+		i_unreached();
+
+	ret = client_command_execute(client, client->cmd_name, args);
+
+	client->cmd_finished = TRUE;
+	if (ret < 0) {
+		if (++client->bad_counter >= CLIENT_MAX_BAD_COMMANDS) {
+			client_send_bye(client,	
+				"Too many invalid MANAGESIEVE commands.");
+			client_destroy(client, "Disconnected: "
+				"Too many invalid commands.");
+			return FALSE;
+		}  
+		client_send_no(client,
+			"Error in MANAGESIEVE command received by server.");
+	}
+
+	return ret != 0;
+}
+
+bool client_read(struct managesieve_client *client)
+{
+	switch (i_stream_read(client->common.input)) {
+	case -2:
+		/* buffer full */
+		client_send_bye(client, "Input buffer full, aborting");
+		client_destroy(client, "Disconnected: Input buffer full");
+		return FALSE;
+	case -1:
+		/* disconnected */
+		client_destroy(client, "Disconnected");
+		return FALSE;
+	case 0:
+		/* nothing new read */
+		return TRUE;
+	default:
+		/* something was read */
+		timeout_reset(client->to_idle_disconnect);
+		return TRUE;
+	}
+}
+
+void client_input(struct managesieve_client *client)
+{
+	if (!client_read(client))
+		return;
+
+	client_ref(client);
+
+	if (!auth_client_is_connected(auth_client)) {
+		/* we're not yet connected to auth process -
+		   don't allow any commands */
+		/* FIXME: Can't do this with managesieve. Any other ways?
+		client_send_ok(client, AUTH_WAITING_MSG);
+		*/
+		if (client->to_auth_waiting != NULL)
+			timeout_remove(&client->to_auth_waiting);
+		
+		client->input_blocked = TRUE;
+	} else {
+		o_stream_cork(client->output);
+		while (client_handle_input(client)) ;
+		o_stream_uncork(client->output);
+	}
+
+	client_unref(client);
+}
+
+void client_destroy_oldest(void)
+{
+	struct client *client;
+	struct managesieve_client *destroy_buf[CLIENT_DESTROY_OLDEST_COUNT];
+	unsigned int i, destroy_count;
+
+	/* find the oldest clients and put them to destroy-buffer */
+	memset(destroy_buf, 0, sizeof(destroy_buf));
+
+ 	destroy_count = max_connections > CLIENT_DESTROY_OLDEST_COUNT*2 ?
+		CLIENT_DESTROY_OLDEST_COUNT : I_MIN(max_connections/2, 1);
+	for (client = clients; client != NULL; client = client->next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *) client;
+
+		for (i = 0; i < destroy_count; i++) {
+			if (destroy_buf[i] == NULL ||
+				destroy_buf[i]->created > msieve_client->created) {
+				/* @UNSAFE */
+				memmove(destroy_buf+i+1, destroy_buf+i,
+					sizeof(destroy_buf) -
+					(i+1) * sizeof(struct managesieve_client *));
+				destroy_buf[i] = msieve_client;
+				break;
+			}
+		}
+	}
+
+	/* then kill them */
+	for (i = 0; i < destroy_count; i++) {
+		if (destroy_buf[i] == NULL)
+			break;
+
+		client_destroy(destroy_buf[i], "Disconnected: Connection queue full");
+	}
+}
+
+static void client_send_greeting(struct managesieve_client *client)
+{
+	/* Cork the stream to send the capability data as a single tcp frame
+	 *   Some naive clients break if we don't.
+	 */
+	o_stream_cork(client->output);
+
+	/* Send initial capabilities */   
+	client_send_capabilities(client);
+	client_send_ok(client, greeting);
+	client->greeting_sent = TRUE;
+
+	o_stream_uncork(client->output);
+}
+
+static void client_idle_disconnect_timeout(struct managesieve_client *client)
+{
+	client_send_bye(client, "Disconnected for inactivity.");
+	client_destroy(client, "Disconnected: Inactivity");
+}
+
+static void client_auth_waiting_timeout(struct managesieve_client *client)
+{
+	timeout_remove(&client->to_auth_waiting);
+}
+
+void client_set_auth_waiting(struct managesieve_client *client)
+{
+	i_assert(client->to_auth_waiting == NULL);
+	client->to_auth_waiting =
+		timeout_add(AUTH_WAITING_TIMEOUT_MSECS,
+			client_auth_waiting_timeout, client);
+}
+
+struct client *client_create(int fd, bool ssl, const struct ip_addr *local_ip,
+			     const struct ip_addr *ip)
+{
+	struct managesieve_client *client;
+
+	i_assert(fd != -1);
+
+	connection_queue_add(1);
+
+	/* always use nonblocking I/O */
+	net_set_nonblock(fd, TRUE);
+
+	client = i_new(struct managesieve_client, 1);
+	client->created = ioloop_time;
+	client->refcount = 1;
+
+	client->common.local_ip = *local_ip;
+	client->common.ip = *ip;
+	client->common.fd = fd;
+	client->common.tls = ssl;
+	client->common.trusted = client_is_trusted(&client->common);
+	client->common.secured = ssl || client->common.trusted ||
+		net_ip_compare(ip, local_ip);
+
+	client_open_streams(client, fd);
+	client->io = io_add(fd, IO_READ, client_input, client);
+
+	client_link(&client->common);
+
+	main_ref();
+
+	if (auth_client_is_connected(auth_client))
+		client_send_greeting(client);
+	else
+		client_set_auth_waiting(client);
+	client_set_title(client);
+
+	client->to_idle_disconnect =
+		timeout_add(CLIENT_LOGIN_IDLE_TIMEOUT_MSECS,
+			client_idle_disconnect_timeout, client);
+	return &client->common;
+}
+
+void client_destroy(struct managesieve_client *client, const char *reason)
+{
+	if (client->destroyed)
+		return;
+	client->destroyed = TRUE;
+
+	if (!client->login_success && reason != NULL) {
+		reason = t_strconcat(reason, " ",
+			client_get_extra_disconnect_reason(&client->common),
+			NULL);
+	}
+	if (reason != NULL)
+		client_syslog(&client->common, reason);
+
+	client_unlink(&client->common);
+
+	if (client->common.input != NULL)
+		i_stream_close(client->common.input);
+	if (client->output != NULL)
+		o_stream_close(client->output);
+
+	if (client->common.master_tag != 0) {
+		i_assert(client->common.auth_request == NULL);
+		i_assert(client->common.authenticating);
+		master_request_abort(&client->common);
+	} else if (client->common.auth_request != NULL) {
+		i_assert(client->common.authenticating);
+		sasl_server_auth_abort(&client->common);
+	} else {
+		i_assert(!client->common.authenticating);
+	}
+
+	if (client->io != NULL)
+		io_remove(&client->io);
+	if (client->to_idle_disconnect != NULL)
+		timeout_remove(&client->to_idle_disconnect);
+	if (client->to_auth_waiting != NULL)
+		timeout_remove(&client->to_auth_waiting);
+	if (client->to_authfail_delay != NULL)
+		timeout_remove(&client->to_authfail_delay);
+
+	if (client->common.fd != -1) {
+		net_disconnect(client->common.fd);
+		client->common.fd = -1;
+	}
+
+	if (client->proxy_password != NULL) {
+		safe_memset(client->proxy_password, 0, strlen(client->proxy_password));
+		i_free(client->proxy_password);
+		client->proxy_password = NULL;
+	}
+
+	i_free_and_null(client->proxy_user);
+	i_free_and_null(client->proxy_master_user);
+
+	if (client->proxy != NULL)
+		login_proxy_free(&client->proxy);
+
+	if (client->common.proxy != NULL) {
+		ssl_proxy_free(client->common.proxy);
+		client->common.proxy = NULL;
+	}
+
+	client_unref(client);
+
+	main_listen_start();
+	main_unref();
+}
+
+void client_destroy_success(struct managesieve_client *client, const char *reason)
+{   
+    client->login_success = TRUE;
+    client_destroy(client, reason);
+}
+
+bool client_read_args(struct managesieve_client *client, unsigned int count,
+	unsigned int flags, struct managesieve_arg **args)
+{
+	int ret;
+	bool fatal;
+	const char *msg;
+
+	i_assert(count <= INT_MAX);
+
+	ret = managesieve_parser_read_args(client->parser, count, flags, args);
+	if (ret >= (int)count) {
+		/* all parameters read successfully */
+		return TRUE;
+	} else if (ret == -2) {
+		/* need more data */
+		return FALSE;
+	} else {
+		/* error, or missing arguments */
+		if ( ret < 0 ) {
+			msg = managesieve_parser_get_error(client->parser, &fatal);
+			client_send_no(client, msg);
+		} else {
+			client_send_no(client, "Missing arguments");
+		}
+		return FALSE;
+	}
+}
+
+void client_destroy_internal_failure(struct managesieve_client *client)
+{
+	client_send_byeresp(client, "TRYLATER", "Internal login failure. "
+		"Refer to server log for more information.");
+	client_destroy(client, "Internal login failure");
+}
+
+void client_ref(struct managesieve_client *client)
+{
+	client->refcount++;
+}
+
+bool client_unref(struct managesieve_client *client)
+{
+	i_assert(client->refcount > 0);
+	if (--client->refcount > 0)
+		return TRUE;
+
+	i_assert(client->destroyed);
+
+	managesieve_parser_destroy(&client->parser);
+
+	if (client->common.input != NULL)
+		i_stream_unref(&client->common.input);
+	if (client->output != NULL)
+		o_stream_unref(&client->output);
+
+	i_free(client->common.virtual_user);
+	i_free(client->common.auth_mech_name);
+	i_free(client);
+
+	return FALSE;
+}
+
+void client_send_line(struct managesieve_client *client, const char *line)
+{
+	struct const_iovec iov[2];
+	ssize_t ret;
+
+	iov[0].iov_base = line;
+	iov[0].iov_len = strlen(line);
+	iov[1].iov_base = "\r\n";
+	iov[1].iov_len = 2;
+
+	ret = o_stream_sendv(client->output, iov, 2);
+	if (ret < 0 || (size_t)ret != iov[0].iov_len + iov[1].iov_len) {
+		/* either disconnection or buffer full. in either case we
+		   want this connection destroyed. however destroying it here
+		   might break things if client is still tried to be accessed
+		   without being referenced.. */
+		i_stream_close(client->common.input);
+	}
+}
+
+void _client_send_response(struct managesieve_client *client, 
+	const char *oknobye, const char *resp_code, const char *msg)
+{
+	string_t *str;
+
+	str = t_str_new(128);
+	str_append(str, oknobye);
+
+	if ( resp_code != NULL )
+	{
+		str_append(str, " (");
+		str_append(str, resp_code);
+		str_append_c(str, ')');
+	}
+
+	if ( msg != NULL )	
+	{
+		str_append_c(str, ' ');
+		managesieve_quote_append_string(str, msg, TRUE);
+	}
+
+	client_send_line(client, str_c(str));
+}
+
+void clients_notify_auth_connected(void)
+{
+	struct client *client;
+
+	for (client = clients; client != NULL; client = client->next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *)client;
+
+		if (msieve_client->to_auth_waiting != NULL)
+			timeout_remove(&msieve_client->to_auth_waiting);
+		if (!msieve_client->greeting_sent)
+			client_send_greeting(msieve_client);
+		if (msieve_client->input_blocked) {
+			msieve_client->input_blocked = FALSE;
+			client_input(msieve_client);
+		}
+	}
+}
+
+void clients_destroy_all(void)
+{
+	struct client *client, *next;
+
+	for (client = clients; client != NULL; client = next) {
+		struct managesieve_client *msieve_client = 
+			(struct managesieve_client *) client;
+
+		next = client->next;
+		client_destroy(msieve_client, "Disconnected: Shutting down");
+	}
+}
+
+void clients_init(void)
+{
+	const char *str;
+
+	/* Specific MANAGESIEVE settings */
+	str = getenv("MANAGESIEVE_IMPLEMENTATION_STRING");
+	managesieve_implementation_string = str != NULL ?
+    	str : DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING;
+
+	/* Parse CAPABILITY_STRING */	
+	managesieve_capabilities_init(capability_string);
+}
+
+void clients_deinit(void)
+{
+	clients_destroy_all();
+
+	/* Free allocated capability strings */
+	managesieve_capabilities_deinit();
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client.h dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/client.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/client.h	2009-08-03 14:29:52.000000000 +0200
@@ -0,0 +1,95 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __CLIENT_H
+#define __CLIENT_H
+
+#include "network.h"
+#include "master.h"
+
+#include "client-common.h"
+
+#include "managesieve-parser.h"
+
+#include "dmanagesieve-config.h"
+
+/* maximum length for IMAP command line. */
+#define MAX_MANAGESIEVE_LINE 8192
+
+/* Disconnect client after idling this many milliseconds */
+#define CLIENT_LOGIN_IDLE_TIMEOUT_MSECS (3*60*1000)
+
+/* FIXME: Duplicate, also defined in src/managesieve */
+#define DEFAULT_MANAGESIEVE_IMPLEMENTATION_STRING MANAGESIEVE_NAME
+
+struct managesieve_client {
+	struct client common;
+
+	time_t created;
+	int refcount;
+
+	struct io *io;
+	struct ostream *output;
+	struct managesieve_parser *parser;
+	struct timeout *to_idle_disconnect, *to_auth_waiting;
+	struct timeout *to_authfail_delay;
+
+	struct login_proxy *proxy;
+	char *proxy_user, *proxy_master_user, *proxy_password;
+
+	unsigned int proxy_state;	
+
+	unsigned int bad_counter;
+
+	const char *cmd_name;
+
+	unsigned int login_success:1;
+	unsigned int cmd_finished:1;
+	unsigned int skip_line:1;
+	unsigned int input_blocked:1;
+	unsigned int destroyed:1;
+	unsigned int greeting_sent:1;
+	unsigned int id_logged:1;
+	unsigned int auth_initializing:1;
+	unsigned int capability_command_used:1;
+
+	unsigned int proxy_starttls:1;
+	unsigned int proxy_sasl_plain:1;
+
+};
+
+void client_destroy(struct managesieve_client *client, const char *reason);
+void client_destroy_success(struct managesieve_client *client, const char *reason);
+void client_destroy_internal_failure(struct managesieve_client *client);
+
+void client_send_line(struct managesieve_client *client, const char *line);
+
+bool client_read(struct managesieve_client *client);
+bool client_skip_line(struct managesieve_client *client);
+void client_input(struct managesieve_client *client);
+
+bool client_read_args(struct managesieve_client *client, unsigned int count,
+	unsigned int flags, struct managesieve_arg **args);
+
+void client_ref(struct managesieve_client *client);
+bool client_unref(struct managesieve_client *client);
+
+void client_set_auth_waiting(struct managesieve_client *client);
+
+void _client_send_response(struct managesieve_client *client,
+  const char *oknobye, const char *resp_code, const char *msg);
+
+#define client_send_ok(client, msg) \
+	_client_send_response(client, "OK", NULL, msg)
+#define client_send_no(client, msg) \
+  _client_send_response(client, "NO", NULL, msg)
+#define client_send_bye(client, msg) \
+  _client_send_response(client, "BYE", NULL, msg)
+
+#define client_send_okresp(client, resp_code, msg) \
+  _client_send_response(client, "OK", resp_code, msg)
+#define client_send_noresp(client, resp_code, msg) \
+  _client_send_response(client, "NO", resp_code, msg)
+#define client_send_byeresp(client, resp_code, msg) \
+  _client_send_response(client, "BYE", resp_code, msg)
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/cmd-noop.c dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/cmd-noop.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/cmd-noop.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/cmd-noop.c	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,48 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+/* FIXME: Duplicate! */
+
+#include "common.h"
+#include "str.h"
+
+#include "managesieve-parser.h"
+#include "managesieve-quote.h"
+
+#include "client.h"
+#include "commands.h"
+
+int cmd_noop(struct managesieve_client *client)
+{
+	struct managesieve_arg *args;
+	const char *text;
+	string_t *resp_code;
+	int ret;
+
+	/* [<echo string>] */
+	if (!(ret=client_read_args(client, 0, 0, &args)))
+		return FALSE;
+
+	if ( ret > 1 ) {
+		client_send_no(client, "Too many arguments");
+		return TRUE;
+	}
+
+	if ( args[0].type == MANAGESIEVE_ARG_EOL ) {
+		client_send_ok(client, "NOOP Completed");
+		return TRUE;
+	}
+
+	if ( (text = managesieve_arg_string(&args[0])) == NULL ) {
+		client_send_no(client, "Invalid echo tag.");
+		return TRUE;
+	}
+
+	resp_code = t_str_new(256);
+	str_append(resp_code, "TAG ");
+	managesieve_quote_append_string(resp_code, text, FALSE);
+
+	client_send_okresp(client, str_c(resp_code), "Done");
+	return TRUE;
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/commands.h dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/commands.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/commands.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/commands.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,11 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __COMMANDS_H
+#define __COMMANDS_H
+
+struct managesieve_client;
+
+extern int cmd_noop(struct managesieve_client *client);
+
+#endif /* __COMMANDS_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/Makefile.am dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/Makefile.am
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/Makefile.am	2008-12-27 12:32:39.000000000 +0100
@@ -0,0 +1,46 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+pkglibexec_PROGRAMS = managesieve-login
+
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/login-common \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_login_LDADD = \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a \
+	$(SSL_LIBS)
+
+commands = \
+	cmd-noop.c
+
+managesieve_login_SOURCES = \
+	client.c \
+	client-authenticate.c \
+	managesieve-capability.c \
+	managesieve-proxy.c \
+	$(commands)
+
+noinst_HEADERS = \
+	commands.h \
+	client.h \
+	client-authenticate.h \
+	managesieve-capability.h \
+	managesieve-proxy.h
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/Makefile.in dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/Makefile.in
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/Makefile.in	2009-08-21 01:05:45.000000000 +0200
@@ -0,0 +1,539 @@
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+pkglibexec_PROGRAMS = managesieve-login$(EXEEXT)
+subdir = src/managesieve-login
+DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/dummy-config.h \
+	$(top_builddir)/dmanagesieve-config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(pkglibexecdir)"
+pkglibexecPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(pkglibexec_PROGRAMS)
+am__objects_1 = cmd-noop.$(OBJEXT)
+am_managesieve_login_OBJECTS = client.$(OBJEXT) \
+	client-authenticate.$(OBJEXT) managesieve-capability.$(OBJEXT) \
+	managesieve-proxy.$(OBJEXT) $(am__objects_1)
+managesieve_login_OBJECTS = $(am_managesieve_login_OBJECTS)
+am__DEPENDENCIES_1 =
+managesieve_login_DEPENDENCIES = $(am__DEPENDENCIES_1) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a $(am__DEPENDENCIES_1)
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(managesieve_login_SOURCES)
+DIST_SOURCES = $(managesieve_login_SOURCES)
+HEADERS = $(noinst_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MODULE_LIBS = @MODULE_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RAND_LIBS = @RAND_LIBS@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SIEVE_PLUGIN_INCLUDE = @SIEVE_PLUGIN_INCLUDE@
+SIEVE_PLUGIN_LIB = @SIEVE_PLUGIN_LIB@
+SIEVE_PLUGIN_TOP = @SIEVE_PLUGIN_TOP@
+SSL_LIBS = @SSL_LIBS@
+STORAGE_LIBS = @STORAGE_LIBS@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dovecot_incdir = @dovecot_incdir@
+dovecot_sievedir = @dovecot_sievedir@
+dovecotdir = @dovecotdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+moduledir = @moduledir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+pkglibexecdir = $(libexecdir)/dovecot
+AM_CPPFLAGS = \
+	-I$(dovecot_incdir) \
+	-I$(dovecot_incdir)/src/lib \
+	-I$(dovecot_incdir)/src/lib-auth \
+	-I$(dovecot_incdir)/src/lib-mail \
+	-I$(dovecot_incdir)/src/lib-index \
+	-I$(dovecot_incdir)/src/lib-storage \
+	-I$(dovecot_incdir)/src/login-common \
+	-I$(top_srcdir)/src/lib-managesieve \
+	-I$(SIEVE_PLUGIN_TOP) \
+	-I$(SIEVE_PLUGIN_INCLUDE)
+
+managesieve_login_LDADD = \
+	$(SIEVE_PLUGIN_LIB) \
+	$(dovecot_incdir)/src/login-common/liblogin-common.a \
+	$(top_srcdir)/src/lib-managesieve/libmanagesieve.a \
+	$(top_srcdir)/src/lib-sievestorage/libsievestorage.a \
+	$(dovecot_incdir)/src/lib-storage/libstorage.a \
+	$(dovecot_incdir)/src/lib-index/libindex.a \
+	$(dovecot_incdir)/src/lib-imap/libimap.a \
+	$(dovecot_incdir)/src/lib-mail/libmail.a \
+	$(dovecot_incdir)/src/lib-charset/libcharset.a \
+	$(dovecot_incdir)/src/lib-auth/libauth.a \
+	$(dovecot_incdir)/src/lib/liblib.a \
+	$(SSL_LIBS)
+
+commands = \
+	cmd-noop.c
+
+managesieve_login_SOURCES = \
+	client.c \
+	client-authenticate.c \
+	managesieve-capability.c \
+	managesieve-proxy.c \
+	$(commands)
+
+noinst_HEADERS = \
+	commands.h \
+	client.h \
+	client-authenticate.h \
+	managesieve-capability.h \
+	managesieve-proxy.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/managesieve-login/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/managesieve-login/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pkglibexecPROGRAMS: $(pkglibexec_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkglibexecdir)" || $(MKDIR_P) "$(DESTDIR)$(pkglibexecdir)"
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	     || test -f $$p1 \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(pkglibexecPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(pkglibexecPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(pkglibexecdir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-pkglibexecPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(pkglibexecdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pkglibexecdir)/$$f"; \
+	done
+
+clean-pkglibexecPROGRAMS:
+	@list='$(pkglibexec_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  echo " rm -f $$p $$f"; \
+	  rm -f $$p $$f ; \
+	done
+managesieve-login$(EXEEXT): $(managesieve_login_OBJECTS) $(managesieve_login_DEPENDENCIES) 
+	@rm -f managesieve-login$(EXEEXT)
+	$(LINK) $(managesieve_login_OBJECTS) $(managesieve_login_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client-authenticate.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cmd-noop.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-capability.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/managesieve-proxy.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(pkglibexecdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pkglibexecPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am: install-pkglibexecPROGRAMS
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-pkglibexecPROGRAMS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pkglibexecPROGRAMS ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-pkglibexecPROGRAMS \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-pkglibexecPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-capability.c dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-capability.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-capability.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-capability.c	2009-01-27 14:21:24.000000000 +0100
@@ -0,0 +1,89 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include "lib.h"
+#include "str.h"
+
+#include "managesieve-capability.h"
+
+char *managesieve_capability_sieve = NULL;
+char *managesieve_capability_notify = NULL;
+
+typedef	enum { CAP_SIEVE, CAP_NOTIFY } capability_type_t;
+
+static void _capability_assign(capability_type_t cap_type, const char *value)
+{
+	const char *duplicate = NULL;
+	
+	switch ( cap_type ) {
+	case CAP_SIEVE:
+		if ( managesieve_capability_sieve == NULL )
+			managesieve_capability_sieve = i_strdup(value);
+		else
+			duplicate = "SIEVE";
+		break;
+	case CAP_NOTIFY:
+		if ( managesieve_capability_notify == NULL )
+			managesieve_capability_notify = i_strdup(value);
+		else
+			duplicate = "NOTIFY";
+		break;
+	}
+	
+	if ( duplicate != NULL ) 
+		i_warning("managesieve-login: duplicate capability '%s' listed in "
+			"capability string (ignored).", duplicate);
+}
+
+void managesieve_capabilities_init(const char *cap_string)
+{
+	capability_type_t cap_type = CAP_SIEVE;
+	const char *p = cap_string;
+	string_t *part = t_str_new(256);
+
+	if ( cap_string == NULL || *cap_string == '\0' ) {
+		i_warning("managesieve-login: capability string is empty.");
+		return;
+	}
+	
+	while ( *p != '\0' ) {
+		if ( *p == '\\' ) {
+			p++;
+			if ( *p != '\0' ) {
+				str_append_c(part, *p);
+				p++;
+			} else break;
+		} else if ( *p == ':' ) {
+			if ( strcasecmp(str_c(part), "SIEVE") == 0 )
+				cap_type = CAP_SIEVE;
+			else if ( strcasecmp(str_c(part), "NOTIFY") == 0 )
+				cap_type = CAP_NOTIFY;
+			else
+				i_warning("managesieve-login: unknown capability '%s' listed in "
+					"capability string (ignored).", str_c(part));
+			str_truncate(part, 0); 
+		} else if ( *p == ',' ) {
+			_capability_assign(cap_type, str_c(part));
+			str_truncate(part, 0);
+		} else {
+			/* Append character, but omit leading spaces */
+			if ( str_len(part) > 0 || *p != ' ' )
+				str_append_c(part, *p);
+		}
+		p++;
+	}
+	
+	if ( str_len(part) > 0 ) {
+		_capability_assign(cap_type, str_c(part));
+	}
+}
+
+void managesieve_capabilities_deinit(void)
+{
+	if ( managesieve_capability_sieve != NULL ) 
+		i_free(managesieve_capability_sieve);
+	
+	if ( managesieve_capability_notify != NULL )
+		i_free(managesieve_capability_notify);	
+}
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-capability.h dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-capability.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-capability.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-capability.h	2009-01-16 00:34:41.000000000 +0100
@@ -0,0 +1,13 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MANAGESIEVE_CAPABILITY_H
+#define __MANAGESIEVE_CAPABILITY_H
+
+extern char *managesieve_capability_sieve;
+extern char *managesieve_capability_notify;
+
+void managesieve_capabilities_init(const char *capabilities);
+void managesieve_capabilities_deinit(void);
+
+#endif /* __MANAGESIEVE_CAPABILITY_H */
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-proxy.c	2009-08-12 22:35:17.000000000 +0200
@@ -0,0 +1,515 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#include <string.h>
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "safe-memset.h"
+#include "buffer.h"
+#include "base64.h"
+
+#include "client.h"
+#include "client-authenticate.h"
+
+#include "managesieve-quote.h"
+#include "managesieve-proxy.h"
+#include "managesieve-parser.h"
+
+#define PROXY_FAILURE_MSG \
+	"Account is temporarily unavailable. Try again later."
+
+enum {
+	PROXY_STATE_INITIAL,
+	PROXY_STATE_TLS_START,
+	PROXY_STATE_TLS_READY,
+	PROXY_STATE_AUTHENTICATE,
+};
+
+typedef enum {
+	MANAGESIEVE_RESPONSE_NONE,
+	MANAGESIEVE_RESPONSE_OK,
+	MANAGESIEVE_RESPONSE_NO,
+	MANAGESIEVE_RESPONSE_BYE
+} managesieve_response_t;
+
+static void proxy_free_password(struct managesieve_client *client)
+{   
+	if (client->proxy_password == NULL)
+		return;
+
+	safe_memset(client->proxy_password, 0, strlen(client->proxy_password));
+	i_free_and_null(client->proxy_password);
+}
+
+static void proxy_failed(struct managesieve_client *client, bool send_tagline)
+{   
+	if (send_tagline)
+		client_send_noresp(client, "TRYLATER", PROXY_FAILURE_MSG);
+
+	login_proxy_free(&client->proxy);
+	proxy_free_password(client);
+	i_free_and_null(client->proxy_user);
+	i_free_and_null(client->proxy_master_user);
+
+	/* call this last - it may destroy the client */
+	client_auth_failed(client, TRUE);
+}
+
+static void get_plain_auth(struct managesieve_client *client, string_t *dest)
+{   
+	string_t *str, *base64;
+
+	str = t_str_new(128);
+	if ( client->proxy_master_user == NULL ) {
+		str_append_c(str, '\0');
+		str_append(str, client->proxy_user);
+	} else {
+		str_append(str, client->proxy_user);
+		str_append_c(str, '\0');
+		str_append(str, client->proxy_master_user);
+	}
+	str_append_c(str, '\0');
+	str_append(str, client->proxy_password);
+
+	base64 = t_str_new(128);
+	base64_encode(str_data(str), str_len(str), base64);
+
+	managesieve_quote_append_string(dest, str_c(base64), FALSE);
+}
+
+static int proxy_write_login(struct managesieve_client *client, string_t *str)
+{   
+	if ( !client->proxy_sasl_plain ) {
+		client_syslog_err(&client->common, "proxy: "
+			"Server does not support required PLAIN SASL mechanism");
+		return -1;
+	}
+
+	/*   Send command */
+	str_append(str, "AUTHENTICATE \"PLAIN\" ");
+	get_plain_auth(client, str);
+	proxy_free_password(client);
+	str_append(str, "\r\n");
+
+	return 1;
+}
+
+static managesieve_response_t proxy_read_response
+(struct managesieve_arg *args)
+{
+	if ( args[0].type == MANAGESIEVE_ARG_ATOM ) {
+		const char *response = MANAGESIEVE_ARG_STR(&(args[0]));
+
+		if ( strcasecmp(response, "OK") == 0 ) {
+			/* Received OK response; greeting is finished */
+			return MANAGESIEVE_RESPONSE_OK; 
+
+        } else if ( strcasecmp(response, "NO") == 0 ) {
+			/* Received OK response; greeting is finished */
+			return MANAGESIEVE_RESPONSE_NO; 
+
+        } else if ( strcasecmp(response, "BYE") == 0 ) {
+			/* Received OK response; greeting is finished */
+			return MANAGESIEVE_RESPONSE_BYE;
+ 
+		}
+	}
+
+	return MANAGESIEVE_RESPONSE_NONE;
+}
+
+static int proxy_input_capability
+(struct managesieve_client *client, const char *line, managesieve_response_t *resp_r)
+{   
+	struct istream *input;
+	struct managesieve_parser *parser;
+ 	struct managesieve_arg *args;
+	int ret;
+	bool fatal = FALSE;
+
+	*resp_r = MANAGESIEVE_RESPONSE_NONE;
+
+	/* Build an input stream for the managesieve parser 
+	 *  FIXME: It would be nice if the line-wise parsing could be
+	 *    substituded by something similar to the command line interpreter.
+	 *    However, the current login_proxy structure does not make streams
+	 *    known until inside proxy_input handler.
+	 */
+	line = t_strconcat(line, "\r\n", NULL);
+	input = i_stream_create_from_data(line, strlen(line));
+	parser = managesieve_parser_create(input, NULL, MAX_MANAGESIEVE_LINE);
+	managesieve_parser_reset(parser);
+
+	/* Parse input 
+	 *  FIXME: Theoretically the OK response could include a 
+	 *   response code which could be rejected by the parser. 
+	 */ 
+	(void)i_stream_read(input);
+	ret = managesieve_parser_read_args(parser, 2, 0, &args);
+		
+	if ( ret >= 1 ) {
+		if ( args[0].type == MANAGESIEVE_ARG_ATOM ) {
+			*resp_r = proxy_read_response(args);
+
+			if ( *resp_r == MANAGESIEVE_RESPONSE_NONE ) {
+				client_syslog_err(&client->common, t_strdup_printf("proxy: "
+					"Remote sent invalid response: %s",
+					str_sanitize(line,160)));
+		
+				fatal = TRUE;
+			}
+      	} else if ( args[0].type == MANAGESIEVE_ARG_STRING ) {
+			const char *capability = MANAGESIEVE_ARG_STR(&(args[0]));
+
+        	if ( strcasecmp(capability, "SASL") == 0 ) {
+				/* Check whether the server supports the SASL mechanism 
+		    	 * we are going to use (currently only PLAIN supported). 
+				 */
+				if ( ret == 2 && args[1].type == MANAGESIEVE_ARG_STRING ) {
+					const char *const *mechs = 
+						t_strsplit(MANAGESIEVE_ARG_STR(&(args[1])), " "); 
+
+					if ( str_array_icase_find(mechs, "PLAIN") )
+						client->proxy_sasl_plain = TRUE;
+					else
+						client->proxy_sasl_plain = FALSE;
+
+				} else {
+					client_syslog_err(&client->common, "proxy: "
+		         		"Server returned erroneous SASL capability");
+					fatal = TRUE;
+				}
+
+			} else if ( strcasecmp(capability, "STARTTLS") == 0 ) {
+				client->proxy_starttls = TRUE;
+			}
+
+		} else {
+			/* Do not accept faulty server */
+			client_syslog_err(&client->common, t_strdup_printf("proxy: "
+				"Remote returned with invalid capability/greeting line: %s",
+				str_sanitize(line,160)));
+			fatal = TRUE;
+		}
+
+	} else if ( ret == -2 ) {
+		/* Parser needs more data (not possible on mem stream) */
+		i_unreached();
+
+    } else if ( ret < 0 ) {
+		const char *error_str = managesieve_parser_get_error(parser, &fatal);
+		error_str = (error_str != NULL ? error_str : "unknown (bug)" );
+	
+		/* Do not accept faulty server */
+		client_syslog_err(&client->common, t_strdup_printf("proxy: "
+			"Protocol parse error(%d) in capability/greeting line: %s (line='%s')",
+			ret, error_str, line));
+		fatal = TRUE;
+	}
+
+	/* Cleanup parser */
+    managesieve_parser_destroy(&parser);
+	i_stream_destroy(&input);
+
+	/* Time to exit if greeting was not accepted */
+	if ( fatal ) return -1;
+
+	/* Wait until greeting is received completely */
+	if ( *resp_r == MANAGESIEVE_RESPONSE_NONE ) return 1;
+
+	return 0;
+}
+
+static int proxy_input_line
+(struct managesieve_client *client, const char *line)
+{
+	struct ostream *output; 
+    enum login_proxy_ssl_flags ssl_flags;
+	managesieve_response_t response = MANAGESIEVE_RESPONSE_NONE;
+	string_t *command;
+	int ret = 0;
+
+	i_assert(!client->destroyed);
+
+    output = login_proxy_get_ostream(client->proxy);
+	switch ( client->proxy_state ) {
+	case PROXY_STATE_INITIAL:
+		if ( (ret=proxy_input_capability(client, line, &response)) < 0 ) {
+			proxy_failed(client, TRUE);
+			return -1;
+		}
+
+		if ( ret == 0 ) {
+			if ( response != MANAGESIEVE_RESPONSE_OK ) {
+				client_syslog_err(&client->common,
+					"proxy: Remote sent unexpected NO/BYE in stead of capability response");
+				proxy_failed(client, TRUE);
+				return -1;		
+			}
+
+			command = t_str_new(128);
+
+    		ssl_flags = login_proxy_get_ssl_flags(client->proxy);
+    		if ((ssl_flags & PROXY_SSL_FLAG_STARTTLS) != 0) {
+        		if ( !client->proxy_starttls ) {
+            		client_syslog_err(&client->common,
+                		"proxy: Remote doesn't support STARTTLS");
+					proxy_failed(client, TRUE);
+					return -1;
+        		}
+        	
+				str_append(command, "STARTTLS\r\n");
+				client->proxy_state = PROXY_STATE_TLS_START;
+    		} else {
+				if ( proxy_write_login(client, command) < 0 ) {
+					proxy_failed(client, TRUE);
+					return -1;
+				}
+				client->proxy_state = PROXY_STATE_AUTHENTICATE;
+			}
+
+			(void)o_stream_send(output, str_data(command), str_len(command));
+		}
+
+		return 0;
+
+	case PROXY_STATE_TLS_START:
+		if ( strncasecmp(line, "OK", 2) == 0 && ( strlen(line) == 2 || line[2] == ' ' ) ) {
+
+			/* STARTTLS successful, begin TLS negotiation. */
+			if ( login_proxy_starttls(client->proxy) < 0 ) {
+				proxy_failed(client, TRUE);
+				return -1;
+			}
+	
+			client->proxy_state = PROXY_STATE_TLS_READY;
+			return 1;
+		}
+
+		client_syslog_err(&client->common,
+			"proxy: Remote refused STARTTLS command");
+		proxy_failed(client, TRUE);
+		return -1;		
+
+	case PROXY_STATE_TLS_READY:
+		if ( (ret=proxy_input_capability(client, line, &response)) < 0 ) {
+			proxy_failed(client, TRUE);
+			return -1;
+		}
+
+		if ( ret == 0 ) {
+			if ( response != MANAGESIEVE_RESPONSE_OK ) {
+				/* STARTTLS failed */
+				client_syslog_err(&client->common, t_strdup_printf(
+					"proxy: Remote STARTTLS failed: %s",
+					str_sanitize(line, 160)));
+				proxy_failed(client, TRUE);
+				return -1;
+			}
+
+			command = t_str_new(128);
+			if ( proxy_write_login(client, command) < 0 ) {
+				proxy_failed(client, TRUE);
+				return -1;
+			}
+
+			(void)o_stream_send(output, str_data(command), str_len(command));
+		
+			client->proxy_state = PROXY_STATE_AUTHENTICATE;
+		}
+
+		return 0;
+	
+	case PROXY_STATE_AUTHENTICATE:
+
+		/* Check login status */
+		if ( strncasecmp(line, "OK", 2) == 0 && ( strlen(line) == 2 || line[2] == ' ' ) ) {
+			string_t *str = t_str_new(128);
+
+			/* Login successful */
+
+			/* FIXME: some SASL mechanisms cause a capability response to be sent */
+
+			/* Send this line to client. */
+			o_stream_cork(client->output);
+			(void)o_stream_send_str(client->output, line);
+			(void)o_stream_send(client->output, "\r\n", 2);
+			o_stream_uncork(client->output);
+
+			str_printfa(str, "proxy(%s): Started proxying to %s:%u",
+				client->common.virtual_user,
+				login_proxy_get_host(client->proxy),
+				login_proxy_get_port(client->proxy));
+			if ( strcmp(client->common.virtual_user, client->proxy_user) != 0 ) {
+				/* remote username is different, log it */
+				str_append_c(str, '/');
+				str_append(str, client->proxy_user);
+        	}
+			if (client->proxy_master_user != NULL) {
+				str_printfa(str, " (master %s)", client->proxy_master_user);
+			}
+
+			(void)client_skip_line(client);
+			login_proxy_detach(client->proxy, client->common.input,
+				client->output);
+
+			client->proxy = NULL;
+			client->common.input = NULL;
+			client->output = NULL;
+			client->common.fd = -1;
+			client_destroy_success(client, str_c(str));
+			
+			return 1;
+		} 
+		
+		/* Login failed */
+
+		if (verbose_auth) {
+			string_t *str = t_str_new(128);
+				
+			str_printfa(str, "proxy(%s): Login failed to %s:%u",
+				client->common.virtual_user,
+ 				login_proxy_get_host(client->proxy),
+				login_proxy_get_port(client->proxy));
+			if (strcmp(client->common.virtual_user, client->proxy_user) != 0) {
+				/* remote username is different, log it */
+				str_append_c(str, '/');
+				str_append(str, client->proxy_user);
+			}
+			if (client->proxy_master_user != NULL) {
+				str_printfa(str, " (master %s)", client->proxy_master_user);
+			}
+			str_append(str, ": ");
+
+			if (strncasecmp(line, "NO ", 3) == 0)
+				str_append(str, line + 3);
+			else
+				str_append(str, line);
+	    
+			i_info("%s", str_c(str));
+		}
+
+		/* Login failed. Send our own failure reply so client can't
+		 * figure out if user exists or not just by looking at the
+		 * reply string.
+		 */
+		client_send_no(client, AUTH_FAILED_MSG);
+
+		proxy_failed(client, FALSE);
+		return -1;
+
+	default:
+		/* Not supposed to happen */
+		break;
+	}
+
+	i_unreached();
+	return -1;
+}
+
+
+static void proxy_input(struct managesieve_client *client)
+{   
+	struct istream *input;
+	const char *line;
+
+	if (client->proxy == NULL) {
+		/* we're just freeing the proxy */
+		return;
+	}
+
+	input = login_proxy_get_istream(client->proxy);
+	if (input == NULL) {
+		if (client->destroyed) {
+			/* we came here from client_destroy() */
+			return;
+ 		}
+
+		/* failed for some reason, probably server disconnected */
+		proxy_failed(client, TRUE);
+		return;
+	}
+
+	i_assert(!client->destroyed);
+
+	switch (i_stream_read(input)) {
+	case -2:
+		client_syslog_err(&client->common, 
+			"proxy: Remote input buffer full");
+ 		proxy_failed(client, TRUE);
+		return;
+	case -1:
+		client_syslog_err(&client->common,
+			"proxy: Remote disconnected");
+		proxy_failed(client, TRUE);
+		return;
+	}
+
+	while ((line = i_stream_next_line(input)) != NULL) {
+		if (proxy_input_line(client, line) != 0)
+			break;
+	}
+}
+
+int managesieve_proxy_new
+(struct managesieve_client *client, const char *host,
+	unsigned int port, const char *user, const char *master_user,
+	const char *password, enum login_proxy_ssl_flags ssl_flags,
+	unsigned int connect_timeout_msecs)
+{
+	i_assert(user != NULL);
+	i_assert(!client->destroyed);
+
+	if (password == NULL) {
+		client_syslog(&client->common, "proxy: Password not given");
+		client_send_noresp(client, "TRYLATER", PROXY_FAILURE_MSG);
+		return -1;
+	}
+
+	if ( (ssl_flags & PROXY_SSL_FLAG_YES) > 0 
+		&& (ssl_flags & PROXY_SSL_FLAG_STARTTLS) == 0 ) {
+		client_syslog(&client->common, 
+			"proxy: SSL is enabled, but STARTTLS is not; "
+			"not using SSL for managesieve");
+		ssl_flags = 0;
+	}
+
+	i_assert(client->refcount > 1);
+	connection_queue_add(1);
+
+	if (client->destroyed) {
+		/* connection_queue_add() decided that we were the oldest
+		   connection and killed us. */
+		return -1;
+	}
+
+	if ( login_proxy_is_ourself(&client->common, host, port, user )) {
+        client_syslog_err(&client->common, "Proxying loops to itself");
+		client_send_noresp(client, "TRYLATER", PROXY_FAILURE_MSG);
+        return -1;
+    }
+
+	client->proxy = login_proxy_new
+		(&client->common, host, port, ssl_flags, connect_timeout_msecs,
+			proxy_input, client);
+    if (client->proxy == NULL) {
+		client_send_noresp(client, "TRYLATER", PROXY_FAILURE_MSG);
+        return -1;
+    }
+
+	client->proxy_starttls = FALSE;
+	client->proxy_state = PROXY_STATE_INITIAL;
+	client->proxy_user = i_strdup(user);
+	client->proxy_master_user = i_strdup(master_user);
+	client->proxy_password = i_strdup(password);
+
+	/* disable input until authentication is finished */
+	if (client->io != NULL)
+		io_remove(&client->io);
+
+	return 0;
+}
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h
--- dovecot-1.2.4.orig/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/src/managesieve-login/managesieve-proxy.h	2009-08-12 22:34:51.000000000 +0200
@@ -0,0 +1,15 @@
+/* Copyright (c) 2002-2009 Dovecot Sieve authors, see the included COPYING file
+ */
+
+#ifndef __MANAGESIEVE_PROXY_H
+#define __MANAGESIEVE_PROXY_H
+
+#include "login-proxy.h"
+
+int managesieve_proxy_new
+	(struct managesieve_client *client, const char *hosts,
+		unsigned int port, const char *user, const char *master_user,
+		const char *password, enum login_proxy_ssl_flags ssl_flags,
+		unsigned int connect_timeout_msecs);
+
+#endif
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/stamp.h.in dovecot-1.2.4/dovecot-managesieve/stamp.h.in
--- dovecot-1.2.4.orig/dovecot-managesieve/stamp.h.in	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/stamp.h.in	2009-08-29 17:25:54.000000000 +0200
@@ -0,0 +1,2 @@
+
+
diff -urN dovecot-1.2.4.orig/dovecot-managesieve/TODO dovecot-1.2.4/dovecot-managesieve/TODO
--- dovecot-1.2.4.orig/dovecot-managesieve/TODO	1970-01-01 01:00:00.000000000 +0100
+++ dovecot-1.2.4/dovecot-managesieve/TODO	2009-04-07 22:54:51.000000000 +0200
@@ -0,0 +1,25 @@
+Next (in order of descending priority/precedence):
+
+* Fix proxy to recognize response codes from the backend and forward
+  them to the user if appropriate/safe.
+* Implement new capabilities
+	- MAXREDIRECTS capability
+* Implement new script name rules
+* Implement the HAVESPACE command properly. Currently it always says ok.
+  Maybe this should be linked to the mail quota system. 
+* Enforce protocol syntax better with some of the commands. Some 
+  commands still allow spurious extra arguments
+  --> Full protocol syntax conformance review. 
+* Implement proper support for anonymous login.
+* Make the sieve storage a base class with (possibly) various
+  implementations, just like mail-storage. Currently not very useful. 
+
+* Thorough testing...
+  - Test pipelined behavior
+  - Test proxy authentication
+
+* Resolve exessive code duplication
+	- Between imap and managesieve (Timo?)
+	- Between managesieve and managesieve-login
+* Create proper process interface to dovecot for generic non-mail protocols 
+  (Timo).
