#! /bin/sh -e

## DP: Include dovecot-lda
## DP: Author: Fabio Tranchitella <kobold@debian.org>

. $(dirname $0)/DPATCH

exit 0
@DPATCH@
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/AUTHORS dovecot-1.0.beta5/src/dovecot-lda/AUTHORS
--- dovecot-1.0.beta5.orig/src/dovecot-lda/AUTHORS	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/AUTHORS	2005-04-23 16:30:01.000000000 -0400
@@ -0,0 +1,2 @@
+Timo Sirainen <tss@iki.fi>
+CMU Sieve people, see src/libsieve/AUTHORS
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/autogen.sh dovecot-1.0.beta5/src/dovecot-lda/autogen.sh
--- dovecot-1.0.beta5.orig/src/dovecot-lda/autogen.sh	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/autogen.sh	2006-01-13 06:14:19.000000000 -0500
@@ -0,0 +1,4 @@
+aclocal
+autoheader
+automake --add-missing --foreign
+autoconf
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/configure.in dovecot-1.0.beta5/src/dovecot-lda/configure.in
--- dovecot-1.0.beta5.orig/src/dovecot-lda/configure.in	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/configure.in	2006-02-08 06:39:20.000000000 -0500
@@ -0,0 +1,52 @@
+AC_INIT(dovecot-lda, 0.1, [dovecot@dovecot.org])
+AC_CONFIG_SRCDIR([src])
+
+AC_CONFIG_HEADERS([lda-config.h])
+AM_INIT_AUTOMAKE
+
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+AC_PROG_CPP
+AC_PROG_LEX
+AC_PROG_YACC
+AC_PROG_RANLIB
+
+AC_ARG_WITH(dovecot,
+[  --with-dovecot[=DIR]    Dovecot base directory (../)],
+	dovecotdir="$withval",
+	dovecotdir=../dovecot
+)
+old=`pwd`
+cd $dovecotdir
+dovecotdir=`pwd`
+cd $old
+AC_SUBST(dovecotdir)
+
+if ! test -f "$dovecotdir/dovecot-config"; then
+  echo
+  echo "dovecot-config not found from $dovecotdir, use --with-dovecot=PATH"
+  echo "to give path to compiled Dovecot sources."
+  AC_MSG_ERROR([dovecot-config not found])
+fi
+
+dnl replace relative ../ paths in the file with full paths
+eval `cat $dovecotdir/dovecot-config|sed 's,\$(top_builddir)/,$dovecotdir/,g'`
+
+dnl * Regexp library check, from Cyrus IMAP
+AC_SEARCH_LIBS(regcomp, rx regex, [
+		AC_DEFINE(ENABLE_REGEX,[],[Do we have a decent regex library?])
+		AC_CHECK_HEADER(rxposix.h, AC_DEFINE(HAVE_RX,[],[Do we have rxposix.h?]))])
+
+AC_SUBST(STORAGE_LIBS)
+AC_SUBST(LIBICONV)
+AC_SUBST(RAND_LIBS)
+AC_SUBST(MODULE_LIBS)
+AC_SUBST(dovecotdir)
+
+AC_CONFIG_FILES([
+Makefile
+src/Makefile
+src/libsieve/Makefile])
+
+AC_OUTPUT
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/COPYING dovecot-1.0.beta5/src/dovecot-lda/COPYING
--- dovecot-1.0.beta5.orig/src/dovecot-lda/COPYING	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/COPYING	2005-04-23 16:30:01.000000000 -0400
@@ -0,0 +1,4 @@
+src/libsieve/ is CMU's Sieve implementation, see src/libsieve/COPYING
+
+Everything else is LGPLv2.1 (see COPYING.LGPL) unless otherwise mentioned
+at the beginning of the file.
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/COPYING.LGPL dovecot-1.0.beta5/src/dovecot-lda/COPYING.LGPL
--- dovecot-1.0.beta5.orig/src/dovecot-lda/COPYING.LGPL	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/COPYING.LGPL	2005-04-23 16:30:01.000000000 -0400
@@ -0,0 +1,510 @@
+
+                  GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations
+below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+^L
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it
+becomes a de-facto standard.  To achieve this, non-free programs must
+be allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+^L
+                  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control
+compilation and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+^L
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+^L
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at least
+    three years, to give the same user the materials specified in
+    Subsection 6a, above, for a charge no more than the cost of
+    performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+^L
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+^L
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply, and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License
+may add an explicit geographical distribution limitation excluding those
+countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+^L
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+                            NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+^L
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms
+of the ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.
+It is safest to attach them to the start of each source file to most
+effectively convey the exclusion of warranty; and each file should
+have at least the "copyright" line and a pointer to where the full
+notice is found.
+
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or
+your school, if any, to sign a "copyright disclaimer" for the library,
+if necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James
+  Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/Makefile.am dovecot-1.0.beta5/src/dovecot-lda/Makefile.am
--- dovecot-1.0.beta5.orig/src/dovecot-lda/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/Makefile.am	2005-04-23 16:30:01.000000000 -0400
@@ -0,0 +1,4 @@
+SUBDIRS = src
+
+EXTRA_DIST = \
+	COPYING.LGPL
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/common.h dovecot-1.0.beta5/src/dovecot-lda/src/common.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/common.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/common.h	2006-02-08 06:39:29.000000000 -0500
@@ -0,0 +1,24 @@
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#include "lib.h"
+#include "mail-storage.h"
+
+struct sieve_settings {
+	const char *hostname;
+	const char *postmaster_address;
+};
+
+extern struct sieve_settings *sieve_set;
+
+int dovecot_sieve_run(struct mail_storage *storage, struct mail *mail,
+		      const char *script_path, const char *username,
+		      const char *mailbox);
+
+int save_mail(struct mail_storage *storage, const char *mailbox,
+	      struct mail *mail, enum mail_flags flags,
+	      const char *const *keywords);
+
+const char *get_return_path(struct mail *mail);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/deliver.c dovecot-1.0.beta5/src/dovecot-lda/src/deliver.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/deliver.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/deliver.c	2006-04-02 05:20:03.000000000 -0400
@@ -0,0 +1,695 @@
+/* Copyright (C) 2005 Timo Sirainen */
+
+/* FIXME: pretty ugly thing. */
+
+#include "common.h"
+#include "lib-signals.h"
+#include "ioloop.h"
+#include "hostpid.h"
+#include "home-expand.h"
+#include "env-util.h"
+#include "network.h"
+#include "restrict-access.h"
+#include "istream.h"
+#include "istream-seekable.h"
+#include "ostream.h"
+#include "module-dir.h"
+#include "dict-client.h"
+#include "str.h"
+#include "var-expand.h"
+#include "message-address.h"
+#include "mbox-from.h"
+#include "duplicate.h"
+#include "mail-send.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pwd.h>
+#include <syslog.h>
+#include <sysexits.h>
+#include <sys/stat.h>
+
+#define SIEVE_SCRIPT_PATH "~/.dovecot.sieve"
+
+#define DEFAULT_CONFIG_FILE SYSCONFDIR"/dovecot.conf"
+#define DEFAULT_AUTH_SOCKET_PATH "/var/run/dovecot-auth-master"
+
+/* After buffer grows larger than this, create a temporary file to /tmp
+   where to read the mail. */
+#define MAIL_MAX_MEMORY_BUFFER (1024*128)
+
+#define MAX_INBUF_SIZE 8192
+#define MAX_OUTBUF_SIZE 512
+
+struct auth_connection {
+	int fd;
+	struct io *io;
+	struct istream *input;
+	struct ostream *output;
+
+	unsigned int handshaked:1;
+};
+
+struct sieve_settings *sieve_set;
+struct et_list *_et_list = NULL;
+
+void (*hook_mail_storage_created)(struct mail_storage *storage) = NULL;
+
+static struct module *modules;
+static struct ioloop *ioloop;
+static int return_value = EX_SOFTWARE;
+
+static void sig_die(int signo, void *context __attr_unused__)
+{
+	/* warn about being killed because of some signal, except SIGINT (^C)
+	   which is too common at least while testing :) */
+	if (signo != SIGINT)
+		i_warning("Killed with signal %d", signo);
+	io_loop_stop(ioloop);
+}
+
+static int sync_quick(struct mailbox *box)
+{
+	struct mailbox_sync_context *ctx;
+        struct mailbox_sync_rec sync_rec;
+	struct mailbox_status status;
+
+	ctx = mailbox_sync_init(box, 0);
+	while (mailbox_sync_next(ctx, &sync_rec) > 0)
+		;
+	return mailbox_sync_deinit(&ctx, &status);
+}
+
+int save_mail(struct mail_storage *storage, const char *mailbox,
+	      struct mail *mail, enum mail_flags flags,
+	      const char *const *keywords)
+{
+	struct mailbox *box;
+	struct mailbox_transaction_context *t;
+	struct mail_keywords *kw;
+	int ret = 0;
+
+	box = mailbox_open(storage, mailbox, NULL, MAILBOX_OPEN_FAST |
+			   MAILBOX_OPEN_KEEP_RECENT);
+	if (box == NULL) {
+		bool syntax, temp;
+
+		(void)mail_storage_get_last_error(storage, &syntax, &temp);
+		if (syntax || temp)
+			return -1;
+
+		/* probably the mailbox just doesn't exist. try creating it. */
+		if (mail_storage_mailbox_create(storage, mailbox, FALSE) < 0)
+			return -1;
+
+		/* and try opening again */
+		box = mailbox_open(storage, mailbox, NULL, MAILBOX_OPEN_FAST |
+				   MAILBOX_OPEN_KEEP_RECENT);
+		if (box == NULL)
+			return -1;
+	}
+
+	if (sync_quick(box) < 0) {
+		mailbox_close(&box);
+		return -1;
+	}
+
+	t = mailbox_transaction_begin(box, MAILBOX_TRANSACTION_FLAG_EXTERNAL);
+
+	kw = strarray_length(keywords) == 0 ? NULL :
+		mailbox_keywords_create(t, keywords);
+	if (mailbox_copy(t, mail, flags, kw, NULL) < 0)
+		ret = -1;
+	mailbox_keywords_free(t, &kw);
+
+	if (ret < 0)
+		mailbox_transaction_rollback(&t);
+	else
+		ret = mailbox_transaction_commit(&t, 0);
+
+	mailbox_close(&box);
+	return ret;
+}
+
+const char *get_return_path(struct mail *mail)
+{
+	struct message_address *addr;
+	const char *str;
+
+	str = mail_get_first_header(mail, "Return-Path");
+	addr = str == NULL ? NULL :
+		message_address_parse(pool_datastack_create(),
+				      (const unsigned char *)str,
+				      strlen(str), 1);
+	return addr == NULL || addr->mailbox == NULL || addr->domain == NULL ?
+		NULL : t_strconcat(addr->mailbox, "@", addr->domain, NULL);
+}
+
+static void auth_connection_destroy(struct auth_connection *conn)
+{
+	io_loop_stop(ioloop);
+
+	io_remove(&conn->io);
+	i_stream_unref(&conn->input);
+	o_stream_unref(&conn->output);
+	if (close(conn->fd) < 0)
+		i_error("close() failed: %m");
+	i_free(conn);
+}
+
+static void auth_parse_input(const char *args)
+{
+	const char *const *tmp, *key, *value;
+	int home_found = FALSE;
+
+	for (tmp = t_strsplit(args, "\t"); *tmp != NULL; tmp++) {
+		if (strncmp(*tmp, "uid=", 4) == 0) {
+			env_put(t_strconcat("RESTRICT_SETUID=",
+					    *tmp + 4, NULL));
+		} else if (strncmp(*tmp, "gid=", 4) == 0) {
+			env_put(t_strconcat("RESTRICT_SETGID=",
+					    *tmp + 4, NULL));
+		} else if (strncmp(*tmp, "chroot=", 7) == 0) {
+			env_put(t_strconcat("RESTRICT_CHROOT=",
+					    *tmp + 7, NULL));
+		} else if (strncmp(*tmp, "home=", 5) == 0) {
+			home_found = TRUE;
+			env_put(t_strconcat("HOME=", *tmp + 5, NULL));
+		} else {
+			key = t_str_ucase(t_strcut(*tmp, '='));
+			value = strchr(*tmp, '=');
+			if (value != NULL)
+				env_put(t_strconcat(key, "=", value+1, NULL));
+		}
+	}
+
+	if (!home_found) {
+		/* we must have a home directory */
+		i_error("userdb didn't return a home directory");
+		return_value = EX_TEMPFAIL;
+		return;
+	}
+
+	restrict_access_by_env(TRUE);
+	return_value = EX_OK;
+}
+
+static void auth_input(void *context)
+{
+	struct auth_connection *conn = context;
+	const char *line;
+
+	switch (i_stream_read(conn->input)) {
+	case 0:
+		return;
+	case -1:
+		/* disconnected */
+		auth_connection_destroy(conn);
+		return;
+	case -2:
+		/* buffer full */
+		i_error("BUG: Auth master sent us more than %d bytes",
+			MAX_INBUF_SIZE);
+		auth_connection_destroy(conn);
+		return;
+	}
+
+	if (!conn->handshaked) {
+		while ((line = i_stream_next_line(conn->input)) != NULL) {
+			if (strncmp(line, "VERSION\t", 8) == 0) {
+				if (strncmp(line + 8, "1\t", 2) != 0) {
+					i_error("Auth master version mismatch");
+					auth_connection_destroy(conn);
+					return;
+				}
+			} else if (strncmp(line, "SPID\t", 5) == 0) {
+				conn->handshaked = TRUE;
+				break;
+			}
+		}
+	}
+
+	line = i_stream_next_line(conn->input);
+	if (line != NULL) {
+		if (strncmp(line, "USER\t1\t", 7) == 0) {
+			auth_parse_input(line + 7);
+		} else if (strcmp(line, "NOTFOUND\t1") == 0)
+			return_value = EX_NOUSER;
+		else if (strncmp(line, "FAIL\t1\t", 7) == 0)
+			return_value = EX_TEMPFAIL;
+		else {
+			i_error("BUG: Unexpected input from auth master: %s",
+				line);
+		}
+		auth_connection_destroy(conn);
+	}
+}
+
+static struct auth_connection *auth_connection_new(const char *auth_socket)
+{
+	struct auth_connection *conn;
+	int fd;
+
+	fd = net_connect_unix(auth_socket);
+	if (fd < 0) {
+		i_error("net_connect(%s) failed: %m", auth_socket);
+		return NULL;
+	}
+
+	conn = i_new(struct auth_connection, 1);
+	conn->fd = fd;
+	conn->input =
+		i_stream_create_file(fd, default_pool, MAX_INBUF_SIZE, FALSE);
+	conn->output =
+		o_stream_create_file(fd, default_pool, MAX_OUTBUF_SIZE, FALSE);
+	conn->io = io_add(fd, IO_READ, auth_input, conn);
+	return conn;
+}
+
+static int user_init(const char *auth_socket, const char *destination)
+{
+        struct auth_connection *conn;
+
+	conn = auth_connection_new(auth_socket);
+	if (conn == NULL)
+		return EX_TEMPFAIL;
+
+	o_stream_send_str(conn->output,
+			  t_strconcat("VERSION\t1\t0\n"
+				      "USER\t1\t", destination, "\t"
+				      "service=deliver\n", NULL));
+
+	io_loop_run(ioloop);
+	return return_value;
+}
+
+#define IS_WHITE(c) ((c) == ' ' || (c) == '\t')
+
+static void config_file_init(const char *path)
+{
+	struct istream *input;
+	const char *key, *value;
+	char *line, *p, quote;
+	int fd, sections = 0, lda_section = FALSE;
+	size_t len;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		i_fatal_status(EX_CONFIG, "open(%s) failed: %m", path);
+
+	t_push();
+	input = i_stream_create_file(fd, default_pool, 1024, TRUE);
+	while ((line = i_stream_read_next_line(input)) != NULL) {
+		/* @UNSAFE: line is modified */
+
+		/* skip whitespace */
+		while (IS_WHITE(*line))
+			line++;
+
+		/* ignore comments or empty lines */
+		if (*line == '#' || *line == '\0')
+			continue;
+
+		/* strip away comments. pretty kludgy way really.. */
+		for (p = line; *p != '\0'; p++) {
+			if (*p == '\'' || *p == '"') {
+				quote = *p;
+				for (p++; *p != quote && *p != '\0'; p++) {
+					if (*p == '\\' && p[1] != '\0')
+						p++;
+				}
+				if (*p == '\0')
+					break;
+			} else if (*p == '#') {
+				*p = '\0';
+				break;
+			}
+		}
+
+		/* remove whitespace from end of line */
+		len = strlen(line);
+		while (IS_WHITE(line[len-1]))
+			len--;
+		line[len] = '\0';
+
+		value = p = strchr(line, '=');
+		if (value == NULL) {
+			if (strchr(line, '{') != NULL) {
+				if (strcmp(line, "protocol lda {") == 0)
+					lda_section = TRUE;
+				sections++;
+			}
+			if (*line == '}') {
+				sections--;
+				lda_section = FALSE;
+			}
+			continue;
+		}
+
+		if (sections > 0 && !lda_section)
+			continue;
+
+		while (p > line && p[-1] == ' ') p--;
+		key = t_strdup_until(line, p);
+
+		do {
+			value++;
+		} while (*value == ' ');
+
+		env_put(t_strconcat(t_str_ucase(key), "=", value, NULL));
+	}
+	i_stream_unref(&input);
+	t_pop();
+}
+
+static const struct var_expand_table *
+get_var_expand_table(const char *user, const char *home)
+{
+	static struct var_expand_table static_tab[] = {
+		{ 'u', NULL },
+		{ 'n', NULL },
+		{ 'd', NULL },
+		{ 's', NULL },
+		{ 'h', NULL },
+		{ 'l', NULL },
+		{ 'r', NULL },
+		{ 'p', NULL },
+		{ '\0', NULL }
+	};
+	struct var_expand_table *tab;
+
+	tab = t_malloc(sizeof(static_tab));
+	memcpy(tab, static_tab, sizeof(static_tab));
+
+	tab[0].value = user;
+	tab[1].value = t_strcut(user, '@');
+	tab[2].value = strchr(user, '@');
+	if (tab[2].value != NULL) tab[2].value++;
+	tab[3].value = "DELIVER";
+	tab[4].value = home;
+	tab[5].value = NULL;
+	tab[6].value = NULL;
+	tab[7].value = dec2str(getpid());
+
+	return tab;
+}
+
+static const char *
+expand_mail_env(const char *env, const struct var_expand_table *table)
+{
+	string_t *str;
+	const char *p;
+
+	str = t_str_new(256);
+
+	/* it's either type:data or just data */
+	p = strchr(env, ':');
+	if (p != NULL) {
+		while (env != p) {
+			str_append_c(str, *env);
+			env++;
+		}
+
+		str_append_c(str, *env++);
+	}
+
+	if (env[0] == '~' && env[1] == '/') {
+		/* expand home */
+		env = t_strconcat("%h", env+1, NULL);
+	}
+
+	/* expand %vars */
+	var_expand(str, env, table);
+	return str_c(str);
+}
+
+static struct istream *create_mbox_stream(int fd)
+{
+	const char *mbox_hdr;
+	struct istream *input_list[4], *input;
+
+	net_set_nonblock(fd, FALSE);
+
+	mbox_hdr = mbox_from_create("dovecot.deliver", ioloop_time);
+
+	input_list[0] = i_stream_create_from_data(default_pool, mbox_hdr,
+						  strlen(mbox_hdr));
+	input_list[1] = i_stream_create_file(fd, default_pool, 4096, FALSE);
+	input_list[2] = i_stream_create_from_data(default_pool, "\n", 1);
+	input_list[3] = NULL;
+
+	input = i_stream_create_seekable(input_list, default_pool,
+					 MAIL_MAX_MEMORY_BUFFER,
+					 "/tmp/dovecot.deliver.");
+	i_stream_unref(&input_list[0]);
+	i_stream_unref(&input_list[1]);
+	i_stream_unref(&input_list[2]);
+	return input;
+}
+
+static void open_logfile(void)
+{
+	if (getenv("LOG_PATH") == NULL)
+		i_set_failure_syslog("deliver", LOG_NDELAY, LOG_MAIL);
+	else {
+		/* log to file or stderr */
+		i_set_failure_file(getenv("LOG_PATH"), "deliver");
+	}
+
+	if (getenv("INFO_LOG_PATH") != NULL)
+		i_set_info_file(getenv("INFO_LOG_PATH"));
+
+	i_set_failure_timestamp_format(getenv("LOG_TIMESTAMP"));
+}
+
+static const char *get_sieve_path(void)
+{
+	const char *script_path;
+	struct stat st;
+
+	/* userdb may specify Sieve path */
+	script_path = getenv("SIEVE");
+	if (script_path != NULL) {
+		if (*script_path == '\0') {
+			/* disabled */
+			return NULL;
+		}
+
+		if (*script_path != '/' && *script_path != '\0') {
+			/* relative path. change to absolute. */
+			script_path = t_strconcat(getenv("HOME"), "/",
+						  script_path, NULL);
+		}
+	} else {
+		script_path = home_expand(SIEVE_SCRIPT_PATH);
+	}
+
+	if (stat(script_path, &st) < 0) {
+		if (errno != ENOENT)
+			i_error("stat(%s) failed: %m", script_path);
+
+		/* use global script instead, if one exists */
+		script_path = getenv("GLOBAL_SCRIPT_PATH");
+	}
+
+	return script_path;
+}
+
+static void print_help(void)
+{
+	printf("Usage: deliver [-c <config file>] [-d <destination user>] [-m <mailbox>]\n");
+}
+
+int main(int argc, char *argv[])
+{
+	const char *config_path = DEFAULT_CONFIG_FILE;
+	const char *mailbox = "INBOX";
+	const char *auth_socket;
+	const char *home, *destination, *mail_env, *str, *script_path;
+        const struct var_expand_table *table;
+        enum mail_storage_flags flags;
+        enum mail_storage_lock_method lock_method;
+	struct mail_storage *storage, *mbox_storage;
+	struct mailbox *box;
+	struct istream *input;
+	struct mailbox_transaction_context *t;
+	struct mail *mail;
+	int i, ret;
+
+	lib_init();
+	ioloop = io_loop_create(default_pool);
+
+	lib_signals_init();
+        lib_signals_set_handler(SIGINT, TRUE, sig_die, NULL);
+        lib_signals_set_handler(SIGTERM, TRUE, sig_die, NULL);
+        lib_signals_set_handler(SIGPIPE, FALSE, NULL, NULL);
+        lib_signals_set_handler(SIGALRM, FALSE, NULL, NULL);
+
+	destination = NULL;
+	for (i = 1; i < argc; i++) {
+		if (strcmp(argv[i], "-d") == 0) {
+			/* destination user */
+			i++;
+			if (i == argc) {
+				i_fatal_status(EX_USAGE,
+					       "Missing destination argument");
+			}
+			destination = argv[i];
+		} else if (strcmp(argv[i], "-c") == 0) {
+			/* config file path */
+			i++;
+			if (i == argc) {
+				i_fatal_status(EX_USAGE,
+					"Missing config file path argument");
+			}
+			config_path = argv[i];
+		} else if (strcmp(argv[i], "-m") == 0) {
+			/* destination mailbox */
+			i++;
+			if (i == argc) {
+				i_fatal_status(EX_USAGE,
+					       "Missing mailbox argument");
+			}
+			mailbox = argv[i];
+		} else {
+			print_help();
+			i_fatal_status(EX_USAGE,
+				       "Unknown argument: %s", argv[1]);
+		}
+	}
+
+	config_file_init(config_path);
+	open_logfile();
+
+	if (destination != NULL) {
+		auth_socket = getenv("AUTH_SOCKET_PATH");
+		if (auth_socket == NULL)
+			auth_socket = DEFAULT_AUTH_SOCKET_PATH;
+
+		ret = user_init(auth_socket, destination);
+		if (ret != 0)
+			return ret;
+
+		home = getenv("HOME");
+		if (home != NULL) {
+			/* If possible chdir to home directory so core file
+			   could be written. If it fails, don't worry. */
+			(void)chdir(home);
+		}
+	} else if (geteuid() != 0) {
+		/* we're non-root. get our username. */
+		struct passwd *pw;
+
+		pw = getpwuid(geteuid());
+		if (pw != NULL)
+			destination = t_strdup(pw->pw_name);
+	} 
+
+	if (destination == NULL) {
+		i_fatal_status(EX_USAGE,
+			"destination user parameter (-d user) not given");
+	}
+
+	sieve_set = i_new(struct sieve_settings, 1);
+	sieve_set->hostname = my_hostname; /* FIXME: configurable */
+	sieve_set->postmaster_address = getenv("POSTMASTER_ADDRESS");
+	if (sieve_set->postmaster_address == NULL) {
+		i_fatal_status(EX_CONFIG,
+			       "postmaster_address setting not given");
+	}
+
+	dict_client_register();
+        mail_storage_init();
+	mail_storage_register_all();
+        duplicate_init();
+
+	/* MAIL comes from userdb, DEFAULT_MAIL_ENV from dovecot.conf */
+	mail_env = getenv("MAIL");
+	if (mail_env == NULL) 
+		mail_env = getenv("DEFAULT_MAIL_ENV");
+	if (mail_env != NULL) {
+		table = get_var_expand_table(destination, getenv("HOME"));
+		mail_env = expand_mail_env(mail_env, table);
+	}
+
+	str = getenv("POP3_UIDL_FORMAT");
+	if (str != NULL && (str = strchr(str, '%')) != NULL &&
+	    str != NULL && var_get_key(str + 1) == 'm')
+		flags |= MAIL_STORAGE_FLAG_KEEP_HEADER_MD5;
+
+	modules = getenv("MODULE_DIR") == NULL ? NULL :
+		module_dir_load(getenv("MODULE_DIR"), NULL, TRUE);
+
+	/* FIXME: how should we handle namespaces? */
+	mail_storage_parse_env(&flags, &lock_method);
+	storage = mail_storage_create_with_data(mail_env, destination,
+						flags, lock_method);
+	if (storage == NULL) {
+		i_fatal_status(EX_CONFIG,
+			"Failed to create storage for '%s' with mail '%s'",
+			destination, mail_env == NULL ? "(null)" : mail_env);
+	}
+
+	if (hook_mail_storage_created != NULL)
+		hook_mail_storage_created(storage);
+
+	mbox_storage = mail_storage_create("mbox", "/tmp", destination, 0,
+					   MAIL_STORAGE_LOCK_FCNTL);
+	input = create_mbox_stream(0);
+	box = mailbox_open(mbox_storage, "Dovecot Delivery Mail", input,
+			   MAILBOX_OPEN_NO_INDEX_FILES);
+	if (box == NULL)
+		i_fatal("Can't open delivery mail as mbox");
+        if (sync_quick(box) < 0)
+		i_fatal("Can't sync delivery mail");
+
+	t = mailbox_transaction_begin(box, 0);
+	mail = mail_alloc(t, 0, NULL);
+	if (mail_set_seq(mail, 1) < 0)
+		i_fatal("mail_set_seq() failed");
+
+	script_path = get_sieve_path();
+
+	ret = dovecot_sieve_run(storage, mail, script_path, destination,
+				mailbox);
+	if (ret <= 0) {
+		/* sieve script didn't handle this. store into inbox. */
+		i_stream_seek(input, 0);
+		if (save_mail(storage, mailbox, mail, 0, NULL) < 0) {
+			const char *error;
+			bool syntax, temporary_error;
+			int ret;
+
+			error = mail_storage_get_last_error(storage, &syntax,
+							    &temporary_error);
+			if (temporary_error)
+				return EX_TEMPFAIL;
+
+			/* we'll have to reply with permanent failure */
+			ret = mail_send_rejection(mail, destination, error);
+			if (ret != 0)
+				return ret < 0 ? EX_TEMPFAIL : ret;
+			/* ok, rejection sent */
+		}
+	}
+	i_stream_unref(&input);
+
+	mail_free(&mail);
+	mailbox_transaction_rollback(&t);
+	mailbox_close(&box);
+
+        duplicate_deinit();
+	module_dir_unload(&modules);
+        mail_storage_destroy(&mbox_storage);
+        mail_storage_destroy(&storage);
+        mail_storage_deinit();
+	dict_client_unregister();
+	lib_signals_deinit();
+
+	io_loop_destroy(&ioloop);
+	lib_deinit();
+
+        return EX_OK;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/duplicate.c dovecot-1.0.beta5/src/dovecot-lda/src/duplicate.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/duplicate.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/duplicate.c	2006-02-08 11:00:49.000000000 -0500
@@ -0,0 +1,248 @@
+#include "common.h"
+#include "ioloop.h"
+#include "istream.h"
+#include "ostream.h"
+#include "home-expand.h"
+#include "file-dotlock.h"
+#include "hash.h"
+#include "duplicate.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+
+#define DUPLICATE_PATH "~/.dovecot.lda-dupes"
+#define COMPRESS_PERCENTAGE 10
+
+struct duplicate {
+	const void *id;
+	unsigned int id_size;
+
+	const char *user;
+	time_t time;
+};
+
+struct duplicate_file {
+	pool_t pool;
+	struct hash_table *hash;
+	const char *path;
+
+	int new_fd;
+	struct dotlock *dotlock;
+	unsigned int changed:1;
+};
+
+static struct dotlock_settings duplicate_dotlock_set = {
+	MEMBER(temp_prefix) NULL,
+	MEMBER(lock_suffix) NULL,
+
+	MEMBER(timeout) 10,
+	MEMBER(stale_timeout) 60,
+
+	MEMBER(callback) NULL,
+	MEMBER(context) NULL,
+
+	MEMBER(use_excl_lock) FALSE
+};
+static struct duplicate_file *duplicate_file = NULL;
+
+static int duplicate_cmp(const void *p1, const void *p2)
+{
+	const struct duplicate *d1 = p1, *d2 = p2;
+
+	return (d1->id_size == d2->id_size &&
+		memcmp(d1->id, d2->id, d1->id_size) == 0 &&
+		strcasecmp(d1->user, d2->user) == 0) ? 0 : 1;
+}
+
+static unsigned int duplicate_hash(const void *p)
+{
+	/* a char* hash function from ASU -- from glib */
+	const struct duplicate *d = p;
+        const unsigned char *s = d->id, *end = s + d->id_size;
+	unsigned int g, h = 0;
+
+	while (s != end) {
+		h = (h << 4) + *s;
+		if ((g = h & 0xf0000000UL)) {
+			h = h ^ (g >> 24);
+			h = h ^ g;
+		}
+		s++;
+	}
+
+	return h ^ strcase_hash(d->user);
+}
+
+static int duplicate_read(struct duplicate_file *file)
+{
+	int fd;
+	struct istream *input;
+	const unsigned char *data;
+	size_t size;
+	time_t stamp;
+	unsigned int offset, id_size, user_size, change_count;
+
+	fd = open(file->path, O_RDONLY);
+	if (fd == -1) {
+		if (errno == ENOENT)
+			return 0;
+		i_error("open(%s) failed: %m", file->path);
+		return -1;
+	}
+
+	/* <timestamp> <id_size> <user_size> <id> <user> */
+	input = i_stream_create_file(fd, default_pool, 4096, FALSE);
+
+	change_count = 0;
+	while (i_stream_read_data(input, &data, &size, sizeof(stamp) +
+				  sizeof(id_size) + sizeof(user_size)) > 0) {
+		offset = 0;
+		memcpy(&stamp, data, sizeof(stamp));
+		offset += sizeof(stamp);
+		memcpy(&id_size, data + offset, sizeof(id_size));
+		offset += sizeof(id_size);
+		memcpy(&user_size, data + offset, sizeof(user_size));
+		offset += sizeof(user_size);
+
+		i_stream_skip(input, offset);
+
+		if (i_stream_read_data(input, &data, &size,
+				       id_size + user_size - 1) <= 0) {
+			i_error("unexpected end of file in %s", file->path);
+			break;
+		}
+
+		if (stamp >= ioloop_time) {
+			/* still valid, save it */
+			struct duplicate *d;
+			void *new_id;
+
+			new_id = p_malloc(file->pool, id_size);
+			memcpy(new_id, data, id_size);
+
+			d = p_new(file->pool, struct duplicate, 1);
+			d->id = new_id;
+			d->id_size = id_size;
+			d->user = p_strndup(file->pool,
+					    data + id_size, user_size);
+			hash_insert(file->hash, d, d);
+		} else {
+                        change_count++;
+		}
+		i_stream_skip(input, id_size + user_size);
+	}
+
+	if (hash_size(file->hash) * COMPRESS_PERCENTAGE / 100 > change_count)
+		file->changed = TRUE;
+
+	i_stream_unref(&input);
+	if (close(fd) < 0)
+		i_error("close(%s) failed: %m", file->path);
+	return 0;
+}
+
+static struct duplicate_file *duplicate_new(const char *path)
+{
+	struct duplicate_file *file;
+	pool_t pool;
+
+	pool = pool_alloconly_create("duplicates", 10240);
+
+	file = p_new(pool, struct duplicate_file, 1);
+	file->pool = pool;
+	file->path = p_strdup(pool, path);
+	file->new_fd = file_dotlock_open(&duplicate_dotlock_set, path, 0,
+					 &file->dotlock);
+	file->hash = hash_create(default_pool, pool, 0,
+				 duplicate_hash, duplicate_cmp);
+	(void)duplicate_read(file);
+	return file;
+}
+
+static void duplicate_free(struct duplicate_file *file)
+{
+	if (file->dotlock != NULL)
+		file_dotlock_delete(&file->dotlock);
+
+	hash_destroy(file->hash);
+	pool_unref(file->pool);
+}
+
+int duplicate_check(const void *id, size_t id_size, const char *user)
+{
+	struct duplicate d;
+
+	if (duplicate_file == NULL)
+		duplicate_file = duplicate_new(home_expand(DUPLICATE_PATH));
+
+	d.id = id;
+	d.id_size = id_size;
+	d.user = user;
+
+	return hash_lookup(duplicate_file->hash, &d) != NULL;
+}
+
+void duplicate_mark(const void *id, size_t id_size,
+                    const char *user, time_t time)
+{
+	struct duplicate *d;
+	void *new_id;
+
+	if (duplicate_file == NULL)
+		duplicate_file = duplicate_new(home_expand(DUPLICATE_PATH));
+
+	new_id = p_malloc(duplicate_file->pool, id_size);
+	memcpy(new_id, id, id_size);
+
+	d = p_new(duplicate_file->pool, struct duplicate, 1);
+	d->id = new_id;
+	d->id_size = id_size;
+	d->user = p_strdup(duplicate_file->pool, user);
+	d->time = time;
+
+	duplicate_file->changed = TRUE;
+	hash_insert(duplicate_file->hash, d, d);
+}
+
+void duplicate_flush(void)
+{
+	struct duplicate_file *file = duplicate_file;
+	struct ostream *output;
+        struct hash_iterate_context *iter;
+	void *key, *value;
+
+	if (duplicate_file == NULL || !file->changed || file->new_fd == -1)
+		return;
+
+	output = o_stream_create_file(file->new_fd, default_pool, 4096, FALSE);
+	iter = hash_iterate_init(file->hash);
+	while (hash_iterate(iter, &key, &value)) {
+		struct duplicate *d = value;
+		unsigned int user_size = strlen(d->user);
+
+		o_stream_send(output, &d->time, sizeof(d->time));
+		o_stream_send(output, &d->id_size, sizeof(d->id_size));
+		o_stream_send(output, &user_size, sizeof(user_size));
+		o_stream_send(output, d->id, d->id_size);
+		o_stream_send(output, d->user, user_size);
+	}
+	hash_iterate_deinit(iter);
+	o_stream_unref(&output);
+
+	file->changed = FALSE;
+	if (file_dotlock_replace(&file->dotlock, 0) < 0)
+		i_error("file_dotlock_replace(%s) failed: %m", file->path);
+	file->new_fd = -1;
+}
+
+void duplicate_init(void)
+{
+}
+
+void duplicate_deinit(void)
+{
+	if (duplicate_file != NULL) {
+		duplicate_flush();
+		duplicate_free(duplicate_file);
+	}
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/duplicate.h dovecot-1.0.beta5/src/dovecot-lda/src/duplicate.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/duplicate.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/duplicate.h	2005-04-12 05:55:40.000000000 -0400
@@ -0,0 +1,13 @@
+#ifndef __DUPLICATE_H
+#define __DUPLICATE_H
+
+int duplicate_check(const void *id, size_t id_size, const char *user);
+void duplicate_mark(const void *id, size_t id_size,
+                    const char *user, time_t time);
+
+void duplicate_flush(void);
+
+void duplicate_init(void);
+void duplicate_deinit(void);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/imparse.c dovecot-1.0.beta5/src/dovecot-lda/src/imparse.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/imparse.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/imparse.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+#include "imparse.h"
+
+int imparse_isatom(const char *s)
+{
+    int len = 0;
+
+    if (!*s) return 0;
+    for (; *s; s++) {
+	len++;
+	if (*s & 0x80 || *s < 0x1f || *s == 0x7f ||
+	    *s == ' ' || *s == '{' || *s == '(' || *s == ')' ||
+	    *s == '\"' || *s == '%' || *s == '*' || *s == '\\') return 0;
+    }
+    if (len >= 1024) return 0;
+    return 1;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/imparse.h dovecot-1.0.beta5/src/dovecot-lda/src/imparse.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/imparse.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/imparse.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,6 @@
+#ifndef __IMPARSE_H
+#define __IMPARSE_H
+
+extern int imparse_isatom (const char *s);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libconfig.h dovecot-1.0.beta5/src/dovecot-lda/src/libconfig.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libconfig.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libconfig.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,8 @@
+#ifndef __LIBCONFIG_H
+#define __LIBCONFIG_H
+
+#define IMAPOPT_RFC3028_STRICT 1
+
+#define config_getswitch(n) 1
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/addr-lex.l dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/addr-lex.l
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/addr-lex.l	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/addr-lex.l	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,91 @@
+%{
+/*
+ * addr-lex.l -- RFC 822 address lexer
+ * Ken Murchison
+ * $Id: addr-lex.l,v 1.2 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include "addr.h"
+#include <string.h>
+
+#undef YY_INPUT
+#define YY_INPUT(b, r, ms) (r = addrinput(b, ms))
+
+int addrinput(char *buf, int max_size);
+void addrerror(const char *);
+
+static int ncom;	/* number of open comments */
+%}
+
+%option noyywrap
+%option nounput
+%option prefix="addr"
+
+%x QSTRING DOMAINLIT COMMENT
+
+%%
+
+\"				{ BEGIN QSTRING; return yytext[0]; }
+\[				{ BEGIN DOMAINLIT; return yytext[0]; }
+\(				{ ncom = 1; BEGIN COMMENT; }
+\)				{ addrerror("address parse error, "
+					  "unexpected `')'' "
+					  "(unbalanced comment)");
+				  yyterminate(); }
+
+[^\(\)<>@,;:\\".\[\] \n\r]+	return ATOM;
+
+[\t \n\r]+			/* ignore whitespace */
+.				return yytext[0];
+
+<QSTRING>([^\n\r"\\]|\\.)*	return QTEXT;
+<QSTRING>\"			{ BEGIN INITIAL; return yytext[0]; }
+
+<DOMAINLIT>([^\[\]\n\r\\]|\\.)*	return DTEXT;
+<DOMAINLIT>\]			{ BEGIN INITIAL; return yytext[0]; }
+
+<COMMENT>([^\(\)\n\0\\]|\\.)*	/* ignore comments */
+<COMMENT>\(			ncom++;
+<COMMENT>\)			{ ncom--; if (ncom == 0) BEGIN INITIAL; }
+<COMMENT><<EOF>>		{ addrerror("address parse error, "
+					  "expecting `')'' "
+					  "(unterminated comment)");
+				  yyterminate(); }
+
+%%
+
+/* take input from address string provided by sieve parser */
+int addrinput(char *buf, int max_size)
+{
+    extern char *addrptr;	/* current position in address string */
+    size_t n;			/* number of characters to read from string */
+
+    n = (int)strlen(addrptr) < max_size ? (int)strlen(addrptr) : max_size;
+    if (n > 0) {
+	memcpy(buf, addrptr, n);
+	addrptr += n;
+    }
+    return n;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/addr.y dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/addr.y
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/addr.y	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/addr.y	2005-05-17 06:06:04.000000000 -0400
@@ -0,0 +1,91 @@
+%{
+/*
+ * addr.y -- RFC 822 address parser
+ * Ken Murchison
+ * $Id: addr.y,v 1.2 2005/05/17 10:06:04 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "addr.h"
+#include "script.h"
+#include "xmalloc.h"
+    
+int addrerror(char *msg);
+extern int yylex(void);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+%}
+
+%token ATOM QTEXT DTEXT
+
+%%
+sieve_address: addrspec			/* simple address */
+	| phrase '<' addrspec '>'	/* name & addr-spec */
+	;
+
+addrspec: localpart '@' domain		/* global-address */
+	;
+
+localpart: word				/* uninterpreted, case-preserved */
+	| word '.' localpart
+	;
+
+domain: subdomain
+	| subdomain '.' domain
+	;
+
+subdomain: domainref
+	| domainlit
+	;
+
+domainref: ATOM				/* symbolic reference */
+	;
+
+domainlit: '[' DTEXT ']'
+	;
+
+phrase: word
+	| word phrase
+	;
+
+word: ATOM
+	| qstring
+	;
+
+qstring: '"' QTEXT '"'
+	;
+
+%%
+
+/* copy address error message into buffer provided by sieve parser */
+int addrerror(char *s)
+{
+    extern char addrerr[ADDRERR_SIZE];
+    
+    strlcpy(addrerr, s, sizeof(addrerr));
+    return 0;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/AUTHORS dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/AUTHORS
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/AUTHORS	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/AUTHORS	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,9 @@
+$Id: AUTHORS,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+
+Larry Greenfield <leg+sieve@andrew.cmu.edu> wrote the first pass.
+
+Alexy Melnikov <alexey.melnikov@isode.com> submitted some bug fixes and 
+improvements.
+
+Ken Murchison <ken@oceana.com> took the ball, added more extensions
+than existed in the known world, and overall improved the code mightily.
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_dump.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_dump.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_dump.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_dump.c	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,304 @@
+/* bc_generate.c -- sieve bytecode- almost flattened bytecode
+ * Rob Siemborski
+ * $Id: bc_dump.c,v 1.2 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+ 
+#include "sieve_interface.h"
+#include "bytecode.h"
+
+ 
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+#if DUMPCODE
+
+/*this would work a lot better if we actually could tell how many levels deep in if statements we were.  currently it doesn't know*/
+
+static void print_spaces(int n)
+{
+    int temp_n=0;
+    while(temp_n++ < (n))
+	putchar(' ');
+}
+
+
+/* Dump a stringlist.  Return the last address used by the list */
+static int dump_sl(bytecode_info_t *d, int ip, int level) 
+{
+    int numstr = d->data[ip].listlen;
+    int i;
+    
+    for(i=0; i<numstr; i++) {
+	print_spaces(level*4);
+	printf(" {%d}",d->data[++ip].len);
+	printf("%s\n",d->data[++ip].str);
+    }
+    
+    return ip;
+}
+
+static int dump_test(bytecode_info_t *d, int ip, int level);
+
+/* Dump a testlist.  Return the last address used by the list */
+static int dump_tl(bytecode_info_t *d, int ip, int level) 
+{
+    int numtest = d->data[ip].listlen;
+    int i;
+    
+    for(i=0; i<numtest; i++) {
+	print_spaces(level*4);
+	printf(" (until %d)\n", d->data[++ip].jump);
+	ip = dump_test(d, ++ip, level);
+    }
+    
+    return ip;
+}
+
+/* Dump a test, return the last address used by the test */
+static int dump_test(bytecode_info_t *d, int ip, int level ) {
+
+    print_spaces(level*4);
+    switch(d->data[ip].op) {
+    case BC_TRUE:
+	printf("%d: TRUE\n",ip);
+	break;
+
+    case BC_FALSE:
+	printf("%d: FALSE\n",ip);
+	break;
+
+    case BC_NOT:
+	printf("%d: NOT TEST(\n",ip++);
+	/*   printf("  (until %d)\n", d->data[ip++].jump);*/
+	ip = dump_test(d,ip, level);
+	print_spaces(level*4);
+	printf("    )\n");
+	break;
+
+    case BC_SIZE:
+	printf("%d: SIZE TAG(%d) NUM(%d)\n",ip,
+	       d->data[ip+1].value, d->data[ip+2].value);
+	ip+=2;
+	break;
+
+    case BC_EXISTS:
+	printf("%d: EXISTS\n",ip++);
+	ip = dump_sl(d,ip,level);
+	break;
+
+    case BC_ALLOF:
+	printf("%d: ALLOF (\n",ip++);
+	ip = dump_tl(d,ip,level);
+	print_spaces(level*4);
+	printf(")\n");
+	break;
+
+    case BC_ANYOF:
+	printf("%d: ANYOF (\n",ip++);
+	ip = dump_tl(d,ip, level);
+	  print_spaces(level*4);
+	printf(")\n");
+	break;
+	    
+    case BC_HEADER:
+	printf("%d: HEADER (\n",ip++);
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d  RELATION:%d  COMP:%d HEADERS:\n", 
+		   d->data[ip].value, d->data[ip+1].value,d->data[ip+2].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d HEADERS:\n",d->data[ip].value, d->data[ip+2].value);
+	}
+	ip+=3;
+	ip = dump_sl(d,ip,level);
+	ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+	
+    case BC_ADDRESS:
+    case BC_ENVELOPE:
+	printf("%d: %s (\n",ip++,
+	       d->data[ip].op == BC_ADDRESS ? "ADDRESS" : "ENVELOPE");
+	print_spaces(level*4);
+	if (d->data[ip].value == B_COUNT || d->data[ip].value == B_VALUE)
+	{
+	    printf("      MATCH:%d RELATION: %d COMP: %d TYPE: %d HEADERS:\n", 
+		   d->data[ip].value, d->data[ip+1].value, d->data[ip+2].value, d->data[ip+3].value);
+	} else {
+	    printf("      MATCH:%d COMP:%d TYPE:%d HEADERS:\n",
+		   d->data[ip].value,d->data[ip+1].value,d->data[ip+3].value);
+	}
+	ip+=4;
+	ip = dump_sl(d,ip,level); ip++;
+	print_spaces(level*4);
+	printf("      DATA:\n");
+	ip = dump_sl(d,ip,level);
+	break;
+
+    default:
+	printf("%d: TEST(%d)\n",ip,d->data[ip].op);
+	break;
+    }
+
+    return ip;
+}
+
+void dump(bytecode_info_t *d, int level) 
+{
+    int i;
+    printf("Dumping almost flattened bytecode\n\n");
+    
+    if(!d) return;
+    
+    for(i=0; i<d->scriptend; i++) {
+	print_spaces(level*4);
+	switch(d->data[i].op) {
+	case B_REJECT:
+	    printf("%d: REJECT {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+	case B_IF:
+	    if (d->data[i+3].jump== -1)
+	    {
+		printf("%d: IF THEN(%d) POST(%d) TEST(\n",i,
+		       d->data[i+1].jump,d->data[i+2].jump);
+	    }
+	    else
+	    {
+		printf("%d: IF THEN(%d) ELSE(%d) POST(%d) TEST(\n",i,
+		       d->data[i+1].jump,d->data[i+2].jump,
+		       d->data[i+3].jump);
+	    }
+	    i = dump_test(d,i+4, level+1);
+	    printf(")\n");
+	    break;
+
+	case B_STOP:
+	    printf("%d: STOP\n",i);
+	    break;
+
+	case B_DISCARD:
+	    printf("%d: DISCARD\n",i);
+	    break;
+	    
+	case B_KEEP:
+	    printf("%d: KEEP\n",i);
+	    break;
+
+	case B_MARK:
+	    printf("%d: MARK\n",i);
+	    break;
+
+	case B_UNMARK:
+	    printf("%d: UNMARK\n",i);
+	    break;
+
+	case B_FILEINTO:
+	    printf("%d: FILEINTO {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+
+	case B_REDIRECT:
+	    printf("%d: REDIRECT {%d}%s\n",i,
+		   d->data[i+1].len,d->data[i+2].str);
+	    i+=2;
+	    break;
+
+	case B_SETFLAG:
+	    printf("%d: SETFLAG\n",i);
+	    i=dump_sl(d,++i, level);
+	    break;
+
+	case B_ADDFLAG:
+	    printf("%d: ADDFLAG\n",i);
+	    i=dump_sl(d,++i,level);
+	    break;
+
+	case B_REMOVEFLAG:
+	    printf("%d: REMOVEFLAG\n",i);
+	    i=dump_sl(d,++i,level);
+	    break;
+
+	case B_DENOTIFY:
+	    printf("%d: DENOTIFY priority %d,comp %d %d  %s\n", 
+		   i,
+		   d->data[i+1].value,
+		   d->data[i+2].value,
+		   d->data[i+3].value,
+		   (d->data[i+4].len == -1 ? "[nil]" : d->data[i+5].str));
+	    i+=5;
+	    break;
+
+	case B_NOTIFY: 
+	    printf("%d: NOTIFY\n   METHOD(%s),\n   ID(%s),\n   OPTIONS",
+		   i,
+		   d->data[i+2].str,
+		   (d->data[i+3].len == -1 ? "[nil]" : d->data[i+4].str));
+	    i+=5;
+	    i=dump_sl(d,i,level);
+	    printf("   PRIORITY(%d),\n   MESSAGE({%d}%s)\n", 
+		   d->data[i+1].value, d->data[i+2].len,d->data[i+3].str);
+	    i+=3;
+	    break;
+
+	case B_VACATION:
+	    printf("%d:VACATION\n",i);
+	    i++;
+	    i=dump_sl(d,i,level);
+	    printf("SUBJ({%d}%s) MESG({%d}%s)\n DAYS(%d) MIME(%d)\n", 
+		   d->data[i+1].len, (d->data[i+1].len == -1 ? "[nil]" : d->data[i+2].str),
+		   d->data[i+3].len, (d->data[i+3].len == -1 ? "[nil]" : d->data[i+4].str),
+		   d->data[i+5].value, d->data[i+6].value);
+	    i+=6;
+	
+	    break;
+	case B_JUMP:
+	    printf("%d: JUMP HUH?  this shouldn't be here>?!",i);
+	    break;
+	case B_NULL:
+	    printf("%d: NULL\n",i);
+	    break;
+	default:
+	    printf("%d: %d\n",i,d->data[i].op);
+	    break;
+	}
+    }
+    printf("full len is: %d\n", d->scriptend);
+}
+#endif
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_emit.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_emit.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_emit.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_emit.c	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,673 @@
+/* bc_emit.c -- sieve bytecode - pass 2 of the compiler
+ * Rob Siemborski
+ * Jen Smith
+ * $Id: bc_emit.c,v 1.2 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xmalloc.h"
+#include "sieve_interface.h"
+
+ 
+#include "bytecode.h"
+
+#include <syslog.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+
+#if DUMPCODE
+void dump(bytecode_info_t *d);
+#endif
+
+static inline int write_int (int fd, int x)
+{
+    int y=htonl(x);
+    return (write(fd, &y, sizeof(int)));
+}
+ 
+    
+
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode  */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+/* Pad null bytes onto the end of the string we just wrote */
+/* returns -1 on failure or number of bytes written on success */
+static int align_string(int fd, int string_len) 
+{
+    /* Keep in mind that we always want to pad a string with *at least*
+     * one zero, that's why sometimes we have to pad with 4 */
+    int needed = sizeof(int) - (string_len % sizeof(int));
+    if (needed>= 0 && needed <=4)
+    {
+    	if(write(fd, "\0\0\0\0", needed) == -1) return -1;
+    }
+    return needed;
+}
+
+/*all functions keep codep up to date as they use it.
+  the amount that has been written to the file is maintained by the
+  filelen variable in bc_action_emit
+  the other bc_xxx_emit funtions keep track of how much they (and any functions they call) have written and return this value
+*/
+
+
+/* Write out a stringlist to a given file descriptor.
+ * return # of bytes written on success and -1 on error */
+
+/* stringlist: <# listitems>
+               <pos of listend (bytes)>
+               <string:(size)(aligned string)>
+*/
+static int bc_stringlist_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int len = bc->data[(*codep)++].len;
+    int i;
+    int ret;
+    int wrote = 2*sizeof(int);
+    int begin,end;
+
+    /* Write out number of items in the list */
+    if (write_int(fd, len)== -1) return -1 ;
+    
+    /* skip one spot end of list position*/
+    begin=lseek(fd,0,SEEK_CUR);
+    lseek(fd,sizeof(int),SEEK_CUR);
+    
+    /* Loop through all the items of the list, writing out length and string
+     * in sequence */
+    for(i=0; i < len; i++)
+    {
+	int datalen = bc->data[(*codep)++].len;
+	
+	if(write_int(fd, datalen) == -1) return -1;
+	wrote += sizeof(int);
+	
+	if(write(fd, bc->data[(*codep)++].str, datalen) == -1) return -1;
+	wrote += datalen;
+	
+	ret = align_string(fd,datalen);
+	if(ret == -1) return -1;
+	
+	wrote+=ret;
+    }
+    end=lseek(fd,0,SEEK_CUR);
+ 
+    /* go back and write end of list position */
+    lseek(fd,begin,SEEK_SET);
+    if(write_int(fd, end) == -1) return -1;
+
+    /* return to the end */
+    lseek(fd,end,SEEK_SET);
+    return wrote;
+}
+
+static int bc_test_emit(int fd, int *codep, bytecode_info_t *bc);
+
+/* Write out a testlist to a given file descriptor.
+ * return # of bytes written on success and -1 on error */
+static int bc_testlist_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int len = bc->data[(*codep)++].len;
+    int i;
+    int ret;
+    int begin, end;
+    int wrote = 2*sizeof(int);
+        
+    /* Write out number of items in the list */
+    if(write_int(fd, len)== -1) return -1;
+
+    /* skip one spot for end of list position*/
+    begin = lseek(fd, 0, SEEK_CUR);
+    lseek(fd, sizeof(int), SEEK_CUR);
+      
+    /* Loop through all the items of the list, writing out each
+     * test as we reach it in sequence. */
+    for(i=0; i < len; i++) {
+	int nextcodep = bc->data[(*codep)++].jump;
+	
+	ret = bc_test_emit(fd, codep, bc);
+	if(ret < 0 ) return -1;
+	
+	wrote+=ret;
+	*codep = nextcodep;
+    }
+    end = lseek(fd, 0, SEEK_CUR);
+
+    /* go back and write the end of list position */
+    lseek(fd,begin,SEEK_SET);
+    if(write_int(fd, end) == -1) return -1;
+
+    /*return to the end */
+    lseek(fd,end,SEEK_SET);
+
+    return wrote;
+}
+
+/* emit the bytecode for a test.  returns -1 on failure or size of
+ * emitted bytecode on success */
+static int bc_test_emit(int fd, int *codep, bytecode_info_t *bc) 
+{
+    int wrote=0;/* Relative offset to account for interleaved strings */
+    
+    
+    int ret; /* Temporary Return Value Variable */
+    
+    /* Output this opcode */
+    if(write_int(fd, bc->data[(*codep)].op) == -1)
+	return -1;
+    wrote += sizeof(int);
+    
+    switch(bc->data[(*codep)++].op) {
+    case BC_TRUE:
+    case BC_FALSE:
+	/* No parameter opcodes */
+	break;
+	
+    case BC_NOT:
+    {
+	/* Single parameter: another test */
+	ret = bc_test_emit(fd, codep, bc);
+	if(ret < 0)
+	    return -1;
+	else
+	    wrote+=ret;
+	break;
+    }
+    
+    case BC_ALLOF:
+    case BC_ANYOF:
+	/*where we jump to?*/
+	/* Just drop a testlist */
+	ret = bc_testlist_emit(fd, codep, bc);
+	if(ret < 0)
+	    return -1;
+	else
+	    wrote+=ret;
+	break;
+	
+    case BC_SIZE:
+	/* Drop tag and number */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	if(write_int(fd, bc->data[(*codep)+1].value) == -1)
+	    return -1;
+	
+	wrote += 2 * sizeof(int);
+	(*codep) += 2;
+	break;
+	
+    case BC_EXISTS:
+    {
+	int ret;
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote += ret;
+	break;
+    }
+    
+    case BC_HEADER:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;    
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/* Now drop headers */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    case BC_ADDRESS:
+    case BC_ENVELOPE:
+    {
+	int ret;
+	/* Drop match type */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*drop comparator */
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop relation*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/*now drop address part*/
+	if(write_int(fd, bc->data[(*codep)].value) == -1)
+	    return -1;
+	wrote += sizeof(int);
+	(*codep)++;
+	/* Now drop headers */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	/* Now drop data */
+	ret = bc_stringlist_emit(fd, codep, bc);
+	if(ret < 0) return -1;
+	wrote+=ret;
+	break;
+    }
+    
+    default:
+	/* Unknown testcode? */
+	return -1;
+    }
+    return wrote;
+}
+
+/* emit the bytecode to a file descriptor given a flattened parse tree
+ * returns -1 on failure, size of emitted bytecode on success.
+ *
+ * this takes care of everything except the comparisons */
+static int bc_action_emit(int fd, int codep, int stopcodep,
+			  bytecode_info_t *bc, int filelen) 
+{
+    int len; /* Temporary Length Variable */
+    int ret; /* Temporary Return Value Variable */
+    int start_filelen = filelen;
+    int i;
+    
+    /*debugging variable to check filelen*/
+    /*int location;*/
+    
+    syslog(LOG_DEBUG, "entered bc_action_emit with filelen: %d", filelen);
+    
+    /* All non-string data MUST be sizeof(int)
+       byte alligned so the end of each string may require a pad */
+    /*
+     * Note that for purposes of jumps you must multiply codep by sizeof(int)
+     */
+    while(codep < stopcodep) {
+	/* Output this opcode */
+	if(write_int(fd, bc->data[codep].op) == -1)
+	    return -1; 
+	
+	filelen+=sizeof(int);
+	
+	switch(bc->data[codep++].op) {
+
+	case B_IF:
+	{
+	    /* IF
+	     *  test
+	     *  jump (false condition)
+	     *  then
+	     * (if there is an else) jump(finish) 
+	     * (if there is an else) else
+	     */
+
+	    int testEndLoc=-1;
+	    int testdist, thendist, elsedist;
+	    int c;
+	    
+	    int jumpFalseLoc=-1;/*this is the location that is being reserved
+				  for the first jump command
+				  we jump to the false condition of the test*/
+	    
+	    int jumpEndLoc=-1; /* this is the location that is being reserved
+				  for the optional jump command
+				  it jumps over the else statement to the end*/
+	    int jumpto=-1;
+	    int jumpop= B_JUMP;
+
+	    /*leave space to store the location of end of the test*/
+	    ret = lseek(fd, sizeof(int), SEEK_CUR);
+	    if(ret == -1) return ret;
+	    
+	    testEndLoc=filelen;
+	    filelen+=sizeof(int);
+	    
+	    /* spew the test */
+
+	    c=codep+3;
+	    testdist = bc_test_emit(fd, &c, bc);
+	    if(testdist == -1)return -1;
+	    filelen +=testdist;
+	    
+            /*store the location for hte end of the test
+	     *this is important for short circuiting of allof/anyof*/
+	    jumpto=filelen/4;
+	    if(lseek(fd, testEndLoc, SEEK_SET) == -1)
+		return -1;
+	    if(write_int(fd,jumpto) == -1)
+		return -1;
+
+	    if(lseek(fd,filelen,SEEK_SET) == -1)
+		return -1;
+
+	    /* leave space for jump */
+	    if(write_int(fd, jumpop) == -1)
+		return -1;
+	    ret = lseek(fd, sizeof(int), SEEK_CUR);
+	    if(ret == -1)
+		return ret;
+	    jumpFalseLoc=filelen+sizeof(int);
+	    
+	    filelen +=2*sizeof(int); /*jumpop + jump*/
+	    
+	    /* spew the then code */ 
+	    thendist = bc_action_emit(fd, bc->data[codep].value,
+				      bc->data[codep+1].value, bc,
+				      filelen);
+	 
+	    filelen+=thendist;
+	  	    
+	    /* there is an else case */
+	    if(bc->data[codep+2].value != -1)
+	    {
+		/* leave space for jump */
+		if(write_int(fd, jumpop) == -1)
+		    return -1;
+		ret = lseek(fd, sizeof(int), SEEK_CUR);
+		if(ret == -1)
+		    return ret;
+
+		jumpEndLoc=filelen+sizeof(int);
+		filelen+=2*sizeof(int);/*jumpop + jump*/
+	    }
+	  
+	    /*put previous jump to the end of the then code,
+	     *or the end of the jump if there is an else case */
+	    jumpto=filelen/4;
+	    if(lseek(fd, jumpFalseLoc, SEEK_SET) == -1)
+		return -1;
+	    if(write_int(fd,jumpto) == -1)
+		return -1;
+	    if(lseek(fd,filelen,SEEK_SET) == -1)
+		return -1;
+	    
+	    /* there is an else case */
+	    if(bc->data[codep+2].value != -1) {
+		/* spew the else code */
+		elsedist = bc_action_emit(fd, bc->data[codep+1].value,
+					 bc->data[codep+2].value, bc,
+					 filelen);
+	
+		filelen+=elsedist;
+		
+		/*put jump to the end of the else code*/
+	        jumpto=filelen/4;
+		if(lseek(fd, jumpEndLoc, SEEK_SET) == -1)
+		    return -1;
+		if(write_int(fd,jumpto) == -1)
+		    return -1;
+		if(lseek(fd,filelen,SEEK_SET) == -1)
+		    return -1;
+		
+		codep = bc->data[codep+2].value;
+	    } else {
+		codep = bc->data[codep+1].value;
+	    }
+	    
+	    break;
+	}
+	
+	case B_REJECT:
+	case B_FILEINTO:
+	case B_REDIRECT:
+	    /*just a string*/
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+
+	    filelen+=sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1)
+		return -1;
+
+	    filelen += len + ret;
+	    
+	    break; 
+
+	case B_SETFLAG:
+	case B_ADDFLAG:
+	case B_REMOVEFLAG:
+	    /* Dump just a stringlist */
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0)
+		return -1;
+	    filelen += ret;
+	    break;
+	    
+	case B_NOTIFY:
+	    /* method string, id string, options string list,
+	       priotity, Message String */
+	    /*method and id*/
+	    for(i=0; i<2; i++) {
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		if(len == -1)
+		{
+                    /* this will probably only happen for the id */
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{	
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1)
+			return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    /*options */
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0)
+		return -1;
+	    filelen+=ret;
+	    
+	    /*priority*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+	    
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    
+	    if(write(fd,bc->data[codep++].str,len) == -1)
+		return -1;
+	    
+	    ret = align_string(fd, len);
+	    if(ret == -1) return -1;
+	    
+ 	    filelen += len + ret;
+	    break;
+
+		
+	case B_DENOTIFY:
+	    /* priority num,comptype  num,relat num, comp string*/ 
+
+	    /* priority*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* comptype */
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* relational*/
+	    if(write_int(fd, bc->data[codep].value) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    codep++;
+	    /* comp string*/
+	    
+	    len = bc->data[codep++].len;
+	    if(write_int(fd,len) == -1)
+		return -1;
+	    filelen += sizeof(int);
+	    
+	    if(len == -1)
+	    {
+		/* this is a nil string */
+		/* skip the null pointer and make up for it 
+		 * by adjusting the offset */
+		codep++;
+	    }
+	    else
+	    {
+		if(write(fd,bc->data[codep++].str,len) == -1)
+		    return -1;
+		
+		ret = align_string(fd, len);
+		if(ret == -1) return -1;
+		
+		filelen += len + ret;
+	    }
+	    	    break;
+	case B_VACATION:
+	    /* Address list, Subject String, Message String,
+	       Days (word), Mime (word) */
+	   
+	        /*new code-this might be broken*/
+	    ret = bc_stringlist_emit(fd, &codep, bc);
+	    if(ret < 0) return -1;
+	    filelen += ret;
+	    /*end of new code*/
+
+	    for(i=0; i<2; i++) {/*writing strings*/
+
+		/*write length of string*/
+		len = bc->data[codep++].len;
+		if(write_int(fd,len) == -1)
+		    return -1;
+		filelen += sizeof(int);
+		    
+		if(len == -1)
+		{
+		    /* this is a nil string */
+		    /* skip the null pointer and make up for it 
+		     * by adjusting the offset */
+		    codep++;
+		}
+		else
+		{
+		    /*write string*/
+		    if(write(fd,bc->data[codep++].str,len) == -1)
+			return -1;
+		    
+		    ret = align_string(fd, len);
+		    if(ret == -1) return -1;
+		    
+		    filelen += len + ret;
+		}
+		
+	    }
+	    /* Days*/
+	    if(write_int(fd,bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+            /*Mime */
+	    if(write_int(fd,bc->data[codep].value) == -1)
+		return -1;
+	    codep++;
+	    filelen += sizeof(int);
+	    
+	    break;
+	case B_NULL:
+	case B_STOP:
+	case B_DISCARD:
+	case B_KEEP:
+	case B_MARK:
+	case B_UNMARK:
+	    /* No Parameters! */
+	    break;
+
+	default:
+	    /* Unknown opcode? */
+	    return -1;
+	}
+    }
+    return filelen - start_filelen;
+}
+
+/* spew the bytecode to disk */
+int sieve_emit_bytecode(int fd, bytecode_info_t *bc)  
+{
+    /* First output version number (4 bytes) */
+    int data = BYTECODE_VERSION;
+
+    /*this is a string, so it is happy*/
+    if(write(fd, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN) == -1)
+	return -1;
+
+    if(write_int(fd, data) == -1) return -1;
+
+#if DUMPCODE
+    dump(bc);
+#endif
+
+    /*the sizeof(int) is to account for the version # at the begining*/
+    return bc_action_emit(fd, 0, bc->scriptend, bc, sizeof(int) + BYTECODE_MAGIC_LEN);
+}
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_eval.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_eval.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_eval.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_eval.c	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,1146 @@
+/* bc_eval.c - evaluate the bytecode
+ * $Id: bc_eval.c,v 1.3 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "message.h"
+
+#include "bytecode.h"
+
+#include "xmalloc.h"
+
+#include <string.h>
+#include <ctype.h>
+
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************EXECUTING BYTECODE******************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+
+/* Given a bytecode_input_t at the beginning of a string (the len block),
+ * return the string, the length, and the bytecode index of the NEXT
+ * item */
+static int unwrap_string(bytecode_input_t *bc, int pos, const char **str, int *len)
+{
+    int local_len = ntohl(bc[pos].value);
+
+    pos++;
+    
+    if(local_len == -1) {
+	/* -1 length indicates NULL */
+	*str = NULL;
+    } else {
+	/* This cast is ugly, but necessary */
+	*str = (const char *)&bc[pos].str;
+	
+	/* Compute the next index */
+	pos += ((ROUNDUP(local_len+1))/sizeof(bytecode_input_t));
+    }
+    
+    if(len) *len = local_len;
+    
+    return pos;
+}
+
+
+/* this is used by notify to pass the options list to do_notify
+ * do_notify needs null-terminated (char *)[],
+ *  we have a stringlist, the beginning of which is pointed at by pos */
+static const char ** bc_makeArray(bytecode_input_t *bc, int *pos)
+{
+    int i;
+    const char** array;
+    int len = ntohl(bc[*pos].value);
+
+    (*pos)+=2; /* Skip # Values and Total Byte Length */
+  
+    array=(const char **)xmalloc((len+1) * sizeof(char *));
+
+    for (i=0; i<len; i++) {
+	*pos = unwrap_string(bc, *pos, &(array[i]), NULL);
+    }
+
+    array[i] = NULL;
+  
+    return array;
+}
+
+/* Compile a regular expression for use during parsing */
+static regex_t * bc_compile_regex(const char *s, int ctag,
+				  char *errmsg, size_t errsiz)
+{
+    int ret;
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+    
+    if ( (ret=regcomp(reg, s, ctag)) != 0)
+    {
+	(void) regerror(ret, reg, errmsg, errsiz);
+	free(reg);
+	return NULL;
+    }
+    return reg;
+}
+
+/* Determine if addr is a system address */
+static int sysaddr(const char *addr)
+{
+    if (!strncasecmp(addr, "MAILER-DAEMON", 13))
+	return 1;
+
+    if (!strncasecmp(addr, "LISTSERV", 8))
+	return 1;
+
+    if (!strncasecmp(addr, "majordomo", 9))
+	return 1;
+
+    if (strstr(addr, "-request"))
+	return 1;
+
+    if (!strncmp(addr, "owner-", 6))
+	return 1;
+
+    return 0;
+}
+
+/* look for myaddr and myaddrs in the body of a header - return the match */
+static char* look_for_me(char *myaddr, int numaddresses,
+			       bytecode_input_t *bc, int i, const char **body)
+{
+    char *found = NULL;
+    int l;
+    int curra,x ;
+
+    /* loop through each TO header */
+    for (l = 0; body[l] != NULL && !found; l++) {
+	void *data = NULL, *marker = NULL;
+	char *addr;
+	
+	parse_address(body[l], &data, &marker);
+
+	/* loop through each address in the header */
+	while (!found &&
+	       ((addr = get_address(ADDRESS_ALL,&data, &marker, 1))!= NULL)) {
+
+	    if (!strcasecmp(addr, myaddr)) {
+		found = xstrdup(myaddr);
+		break;
+	    }
+
+	    curra=i;
+
+	    for(x=0; x<numaddresses; x++)
+	    {
+		void *altdata = NULL, *altmarker = NULL;
+		char *altaddr;
+		const char *str;
+
+		curra = unwrap_string(bc, curra, &str, NULL);
+		
+		/* is this address one of my addresses? */
+      		parse_address(str, &altdata, &altmarker);
+
+		altaddr = get_address(ADDRESS_ALL, &altdata, &altmarker, 1);
+
+		if (!strcasecmp(addr,altaddr)) {
+		    found=xstrdup(str);
+		    break;
+		}
+
+		free_address(&altdata, &altmarker);
+	    }
+
+	}
+	free_address(&data, &marker);
+    }
+
+    return found;
+}
+ 
+/* Determine if we should respond to a vacation message */
+static int shouldRespond(void * m, sieve_interp_t *interp,
+			 int numaddresses, bytecode_input_t* bc,
+			 int i, char **from, char **to)
+{
+    const char **body;
+    char buf[128];
+    char *myaddr = NULL;
+    int l = SIEVE_OK;
+    void *data = NULL, *marker = NULL;
+    char *tmp;
+    int curra, x;
+    char *found=NULL;
+    char *reply_to=NULL;
+  
+    /* is there an Auto-Submitted keyword other than "no"? */
+    strcpy(buf, "auto-submitted");
+    if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	/* we don't deal with comments, etc. here */
+	/* skip leading white-space */
+	while (*body[0] && isspace((int) *body[0])) body[0]++;
+	if (strcasecmp(body[0], "no")) l = SIEVE_DONE;
+    }
+
+    /* is there a Precedence keyword of "junk | bulk | list"? */
+    strcpy(buf, "precedence");
+    if (interp->getheader(m, buf, &body) == SIEVE_OK) {
+	/* we don't deal with comments, etc. here */
+	/* skip leading white-space */
+	while (*body[0] && isspace((int) *body[0])) body[0]++;
+	if (!strcasecmp(body[0], "junk") ||
+	    !strcasecmp(body[0], "bulk") ||
+	    !strcasecmp(body[0], "list"))
+	    l = SIEVE_DONE;
+    }
+
+    /* Note: the domain-part of all addresses are canonicalized */
+    /* grab my address from the envelope */
+    if (l == SIEVE_OK) {
+	strcpy(buf, "to");
+	l = interp->getenvelope(m, buf, &body);
+	
+	if (body[0]) {  
+	    parse_address(body[0], &data, &marker);
+	    tmp = get_address(ADDRESS_ALL, &data, &marker, 1);
+	    myaddr = (tmp != NULL) ? xstrdup(tmp) : NULL;
+	    free_address(&data, &marker);
+	}  
+    }  
+  
+    if (l == SIEVE_OK) {
+	strcpy(buf, "from");
+	l = interp->getenvelope(m, buf, &body);
+    }
+    if (l == SIEVE_OK && body[0]) {
+	/* we have to parse this address & decide whether we
+	   want to respond to it */
+	parse_address(body[0], &data, &marker);
+	tmp = get_address(ADDRESS_ALL, &data, &marker, 1);
+	reply_to = (tmp != NULL) ? xstrdup(tmp) : NULL;
+	free_address(&data, &marker);
+
+	/* first, is there a reply-to address? */
+	if (reply_to == NULL) {
+	    l = SIEVE_DONE;
+	}
+    
+	/* first, is it from me? */
+	if (l == SIEVE_OK && !strcmp(myaddr, reply_to)) {
+	    l = SIEVE_DONE;
+	}
+   
+	/* ok, is it any of the other addresses i've
+	   specified? */
+	if (l == SIEVE_OK)
+	{
+	    curra=i;
+	    for(x=0; x<numaddresses; x++) {
+		const char *address;
+
+		curra = unwrap_string(bc, curra, &address, NULL);
+		
+		if (!strcmp(address, reply_to))
+		    l=SIEVE_DONE;
+	    }
+	}
+   
+	/* ok, is it a system address? */
+	if (l == SIEVE_OK && sysaddr(reply_to)) {
+	    l = SIEVE_DONE;
+	}
+    }
+    if (l == SIEVE_OK) {
+	/* ok, we're willing to respond to the sender.
+	   but is this message to me?  that is, is my address
+	   in the TO, CC or BCC fields? */
+	if (strcpy(buf, "to"), 
+	    interp->getheader(m, buf, &body) == SIEVE_OK)
+	    found = look_for_me(myaddr, numaddresses ,bc, i, body);
+	if (!found && (strcpy(buf, "cc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found && (strcpy(buf, "bcc"),
+		       (interp->getheader(m, buf, &body) == SIEVE_OK)))
+	    found = look_for_me(myaddr, numaddresses, bc, i, body);
+	if (!found)
+	    l = SIEVE_DONE;
+    }
+    /* ok, ok, if we got here maybe we should reply */
+    if (myaddr) free(myaddr);
+    *from=found;
+    *to=reply_to;
+    return l;
+}
+
+/* Evaluate a bytecode test */
+static int eval_bc_test(sieve_interp_t *interp, void* m,
+			bytecode_input_t * bc, int * ip)
+{
+    int res=0; 
+    int i=*ip;
+    int x,y,z;/* loop variable */
+    int list_len; /* for allof/anyof/exists */
+    int list_end; /* for allof/anyof/exists */
+    int address=0;/*to differentiate between address and envelope*/
+    comparator_t * comp=NULL;
+    void * comprock=NULL;
+    int op= ntohl(bc[i].op);
+    
+    switch(op)
+    {
+    case BC_FALSE:
+	res=0; i++; break;
+
+    case BC_TRUE:
+	res=1; i++; break;
+
+    case BC_NOT:/*2*/
+	i+=1;
+	res = eval_bc_test(interp,m, bc, &i);
+	if(res >= 0) res = !res; /* Only invert in non-error case */
+	break;
+
+    case BC_EXISTS:/*3*/
+    {
+	int headersi=i+1;
+	const char** val;
+	int currh;
+
+	res=1;
+
+	list_len=ntohl(bc[headersi].len);
+	list_end=ntohl(bc[headersi+1].value)/4;
+
+	currh=headersi+2;
+
+	for(x=0; x<list_len && res; x++)
+	{
+	    const char *str;
+
+	    currh = unwrap_string(bc, currh, &str, NULL);
+	    
+	    if(interp->getheader(m,str, &val) != SIEVE_OK)
+		res = 0;
+	}
+
+	i=list_end; /* adjust for short-circuit */
+	break;
+    }
+    case BC_SIZE:/*4*/
+    {
+	int s;
+	int sizevar=ntohl(bc[i+1].value);
+	int x=ntohl(bc[i+2].value);
+	
+	if (interp->getsize(m, &s) != SIEVE_OK)
+	    break;
+	
+	if (sizevar ==B_OVER) {
+	    /* over */
+	    res= s > x;
+	} else {
+            /* under */
+	    res= s < x;
+	}
+	i+=3;
+	break;
+    }
+    case BC_ANYOF:/*5*/
+	res = 0;
+	list_len=ntohl(bc[i+1].len);
+	list_end=ntohl(bc[i+2].len)/4;
+	i+=3;
+
+	/* need to process all of them, to ensure our instruction pointer stays
+	 * in the right place */
+	for (x=0; x<list_len && !res; x++) { 
+	    int tmp;
+	    tmp = eval_bc_test(interp,m,bc,&i);
+	    if(tmp < 0) {
+		res = tmp;
+		break;
+	    }
+	    res = res || tmp;
+	}
+
+	i = list_end; /* handle short-circuting */
+
+	break; 
+    case BC_ALLOF:/*6*/ 
+        res = 1;     
+	list_len=ntohl(bc[i+1].len);
+	list_end=ntohl(bc[i+2].len)/4;
+	i+=3;
+
+	/* return 1 unless you find one that isn't true, then return 0 */
+	for (x=0; x<list_len && res; x++) {
+	    int tmp;
+	    tmp = eval_bc_test(interp,m,bc,&i);
+	    if(tmp < 0) {
+		res = tmp;
+		break;
+	    }
+	    res = res && tmp; 
+	}
+
+	i = list_end; /* handle short-circuiting */
+	
+	break;
+    case BC_ADDRESS:/*7*/
+	address=1;
+	/* fall through */
+    case BC_ENVELOPE:/*8*/
+    {
+	const char ** val;
+	void * data=NULL;
+	void * marker=NULL;
+	char * addr;
+	int addrpart=ADDRESS_ALL;/* XXX correct default behavior?*/
+
+ 	int headersi=i+5;/* the i value for the begining of the headers */
+	int datai=(ntohl(bc[headersi+1].value)/4);
+
+	int numheaders=ntohl(bc[headersi].len);
+	int numdata=ntohl(bc[datai].len);
+
+	int currh, currd; /* current header, current data */
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int apart=ntohl(bc[i+4].value);
+	int count=0;
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, as regexps are tested at compile */
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag = REG_EXTENDED | REG_NOSUB;
+	    }
+	}
+
+	/*find the correct comparator fcn*/
+	comp = lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+	
+	/*find the part of the address that we want*/
+	switch(apart)
+	{
+	case B_ALL:
+	    addrpart = ADDRESS_ALL; break;
+	case B_LOCALPART:
+	    addrpart = ADDRESS_LOCALPART; break;
+	case B_DOMAIN:
+	    addrpart = ADDRESS_DOMAIN; break;
+	case B_USER:
+	    addrpart = ADDRESS_USER; break;
+	case B_DETAIL:
+	    addrpart = ADDRESS_DETAIL; break;
+	default:
+	    /* this shouldn't happen with correcct bytecode */
+	    res = SIEVE_RUN_ERROR;
+	}
+
+	if(res == SIEVE_RUN_ERROR) break;
+
+	/*loop through all the headers*/
+	currh=headersi+2;
+#if VERBOSE
+	printf("about to process %d headers\n", numheaders);
+#endif
+	for (x=0; x<numheaders && !res; x++)
+	{
+	    const char *this_header;
+
+	    currh = unwrap_string(bc, currh, &this_header, NULL);
+	    
+	    /* Try the next string if we don't have this one */
+	    if(address) {
+		/* Header */
+		if(interp->getheader(m, this_header, &val) != SIEVE_OK)
+		    continue;
+#if VERBOSE
+                printf(" [%d] header %s is %s\n", x, this_header, val[0]);
+#endif
+	    } else {
+		/* Envelope */
+		if(interp->getenvelope(m, this_header, &val) != SIEVE_OK)
+		    continue;
+	    }
+	
+	    /*header exists, now to test it*/
+	    /*search through all the headers that match*/
+	    
+	    for (y=0; val[y]!=NULL && !res; y++) {
+		
+#if VERBOSE
+		printf("about to parse %s\n", val[y]);
+#endif
+		    
+		if (parse_address(val[y], &data, &marker)!=SIEVE_OK) 
+		    return 0;
+		    
+		while (!res &&
+		       (addr = get_address(addrpart, &data, &marker, 0))) {
+#if VERBOSE
+		    printf("working addr %s\n", (addr ? addr : "[nil]"));
+#endif
+			
+		    if (match == B_COUNT) {
+			count++;
+		    } else {
+			/*search through all the data*/ 
+			currd=datai+2;
+			for (z=0; z<numdata && !res; z++)
+			{
+			    const char *data_val;
+			    
+			    currd = unwrap_string(bc, currd, &data_val, NULL);
+
+			    if (isReg) {
+				reg = bc_compile_regex(data_val, ctag,
+						       errbuf, sizeof(errbuf));
+				if (!reg) {
+				    /* Oops */
+				    res=-1;
+				    goto alldone;
+				}
+
+				res |= comp(val[y], (const char *)reg,
+					    comprock);
+				free(reg);
+			    } else {
+#if VERBOSE
+				printf("%s compared to %s(from script)\n",
+				       addr, data_val);
+#endif 
+				res |= comp(addr, data_val, comprock);
+			    }
+			} /* For each data */
+		    }
+		} /* For each address */
+
+		free_address(&data, &marker);
+	    }/* For each message header */
+	    
+#if VERBOSE
+	    printf("end of loop, res is %d, x is %d (%d)\n", res, x, numheaders);
+#endif	    
+	} /* For each script header */
+     
+	if  (match == B_COUNT)
+	{
+	    sprintf(scount, "%u", count);
+	    /* search through all the data */ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    {
+		const char *data_val;
+		
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+
+		res |= comp(scount, data_val, comprock);
+	    }
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    case BC_HEADER:/*9*/
+    {
+	const char** val;
+
+	int headersi=i+4;/*the i value for the begining of hte headers*/
+	int datai=(ntohl(bc[headersi+1].value)/4);
+
+	int numheaders=ntohl(bc[headersi].len);
+	int numdata=ntohl(bc[datai].len);
+
+	int currh, currd; /*current header, current data*/
+
+	int match=ntohl(bc[i+1].value);
+	int relation=ntohl(bc[i+2].value);
+	int comparator=ntohl(bc[i+3].value);
+	int count=0;	
+	char scount[3];
+	int isReg = (match==B_REGEX);
+	int ctag = 0;
+	regex_t *reg;
+	char errbuf[100]; /* Basically unused, regexps tested at compile */ 
+
+	/* set up variables needed for compiling regex */
+	if (isReg)
+	{
+	    if (comparator== B_ASCIICASEMAP)
+	    {
+		ctag= REG_EXTENDED | REG_NOSUB | REG_ICASE;
+	    }
+	    else
+	    {
+		ctag= REG_EXTENDED | REG_NOSUB;
+	    }
+     
+	}
+	
+	/*find the correct comparator fcn*/
+	comp=lookup_comp(comparator, match, relation, &comprock);
+
+	if(!comp) {
+	    res = SIEVE_RUN_ERROR;
+	    break;
+	}
+
+	/*search through all the flags for the header*/
+	currh=headersi+2;
+	for(x=0; x<numheaders && !res; x++)
+	{
+	    const char *this_header;
+	    
+	    currh = unwrap_string(bc, currh, &this_header, NULL);
+	   
+	    if(interp->getheader(m, this_header, &val) != SIEVE_OK) {
+		continue; /*this header does not exist, search the next*/ 
+	    }
+#if VERBOSE
+	    printf ("val %s %s %s\n", val[0], val[1], val[2]);
+#endif
+	    
+	    /* search through all the headers that match */
+	    
+	    for (y=0; val[y]!=NULL && !res; y++)
+	    {
+		if  (match == B_COUNT) {
+		    count++;
+		} else {
+		    /*search through all the data*/ 
+		    currd=datai+2;
+		    for (z=0; z<numdata && !res; z++)
+		    {
+			const char *data_val;
+			
+			currd = unwrap_string(bc, currd, &data_val, NULL);
+			
+			if (isReg) {
+			    reg= bc_compile_regex(data_val, ctag, errbuf,
+						  sizeof(errbuf));
+			    if (!reg)
+			    {
+				/* Oops */
+				res=-1;
+				goto alldone;
+			    }
+			    
+			    res |= comp(val[y], (const char *)reg,
+					comprock);
+			    free(reg);
+			} else {
+			    res |= comp(val[y], data_val, comprock);
+			}
+		    }
+		}
+	    }
+	}
+	
+	if  (match == B_COUNT )
+	{
+	    sprintf(scount, "%u", count);
+	    /*search through all the data*/ 
+	    currd=datai+2;
+	    for (z=0; z<numdata && !res; z++)
+	    { 	
+		const char *data_val;
+			
+		currd = unwrap_string(bc, currd, &data_val, NULL);
+#if VERBOSE
+		printf("%d, %s \n", count, data_val);
+#endif
+		res |= comp(scount, data_val, comprock);
+	    }
+	      
+	}
+
+	/* Update IP */
+	i=(ntohl(bc[datai+1].value)/4);
+	
+	break;
+    }
+    default:
+#if VERBOSE
+	printf("WERT, can't evaluate if statement. %d is not a valid command",
+	       op);
+#endif     
+	return SIEVE_RUN_ERROR;
+    }
+    
+  
+ alldone:
+    
+    *ip=i;
+    return res;
+}
+
+/* The entrypoint for bytecode evaluation */
+int sieve_eval_bc(sieve_interp_t *i, const void *bc_in, unsigned int bc_len,
+		  void *m, sieve_imapflags_t * imapflags,
+		  action_list_t *actions,
+		  notify_list_t *notify_list,
+		  const char **errmsg)
+{
+    const char *data;
+    int ip = 0, ip_max = (bc_len/sizeof(bytecode_input_t));
+    int res=0;
+    int op;
+    int version;
+    
+    bytecode_input_t *bc = (bytecode_input_t *)bc_in;
+    
+    /* Check that we
+     * a) have bytecode
+     * b) it is atleast long enough for the magic number, the version
+     *    and one opcode */
+    if(!bc) return SIEVE_FAIL;
+    if(bc_len < (BYTECODE_MAGIC_LEN + 2*sizeof(bytecode_input_t)))
+       return SIEVE_FAIL;
+
+    if(memcmp(bc, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	*errmsg = "Not a bytecode file";
+	return SIEVE_FAIL;
+    }
+
+    ip = BYTECODE_MAGIC_LEN / sizeof(bytecode_input_t);
+
+    version= ntohl(bc[ip].op);
+
+    /* this is because there was a time where integers were not network byte
+       order.  all the scripts written then would have version 0x01 written
+       in host byte order.*/
+
+     if(version == (int)ntohl(1)) {
+	if(errmsg) {
+	    *errmsg =
+		"Incorrect Bytecode Version, please recompile (use sievec)";
+	    
+	}
+	return SIEVE_FAIL;
+    }
+    
+    if( version != BYTECODE_VERSION) {
+	if(errmsg) {
+	    *errmsg =
+		"Incorrect Bytecode Version, please recompile (use sievec)";
+	}
+	return SIEVE_FAIL;
+    }
+
+#if VERBOSE
+    printf("version number %d\n",version); 
+#endif
+
+    for(ip++; ip<ip_max; ) { 
+	op=ntohl(bc[ip].op);
+	switch(op) {
+	case B_STOP:/*0*/
+	    res=1;
+	    break;
+
+	case B_KEEP:/*1*/
+	    res = do_keep(actions, imapflags);
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Keep can not be used with Reject";
+	    ip++;
+	    break;
+
+	case B_DISCARD:/*2*/
+	    res=do_discard(actions);
+	    ip++;
+	    break;
+
+	case B_REJECT:/*3*/
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+	    
+	    res = do_reject(actions, data);
+	
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Reject can not be used with any other action";  
+
+	    break;
+
+	case B_FILEINTO:/*4*/
+	{
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+
+	    res = do_fileinto(actions, data, imapflags);
+
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Fileinto can not be used with Reject";
+
+	    break;
+	}
+
+	case B_REDIRECT:/*5*/
+	{
+	    ip = unwrap_string(bc, ip+1, &data, NULL);
+
+	    res = do_redirect(actions, data);
+
+	    if (res == SIEVE_RUN_ERROR)
+		*errmsg = "Redirect can not be used with Reject";
+
+	    break;
+	}
+
+	case B_IF:/*6*/
+	{
+	    int testend=ntohl(bc[ip+1].value);
+	    int result;
+	   
+	    ip+=2;
+	    result=eval_bc_test(i, m, bc, &ip);
+	    
+	    if (result<0) {
+		*errmsg = "Invalid test";
+		return SIEVE_FAIL;
+	    } else if (result) {
+	    	/*skip over jump instruction*/
+		testend+=2;
+	    }
+	    ip=testend;
+	    
+	    break;
+	}
+
+	case B_MARK:/*8*/
+	    res = do_mark(actions);
+	    ip++;
+	    break;
+
+	case B_UNMARK:/*9*/
+	    res = do_unmark(actions);
+	    ip++;
+	    break;
+
+	case B_ADDFLAG:/*10*/ 
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    for (x=0; x<list_len; x++) {
+		ip = unwrap_string(bc, ip, &data, NULL);
+		
+		res = do_addflag(actions, data);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "addflag can not be used with Reject";
+	    } 
+	    break;
+	}
+
+	case B_SETFLAG:
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    ip = unwrap_string(bc, ip, &data, NULL);
+
+	    res = do_setflag(actions, data);
+
+	    if (res == SIEVE_RUN_ERROR) {
+		*errmsg = "setflag can not be used with Reject";
+	    } else {
+		for (x=1; x<list_len; x++) {
+		    ip = unwrap_string(bc, ip, &data, NULL);
+
+		    res = do_addflag(actions, data);
+
+		    if (res == SIEVE_RUN_ERROR)
+			*errmsg = "setflag can not be used with Reject";
+		} 
+	    }
+	    
+	    break;
+	}
+
+	case B_REMOVEFLAG:
+	{
+	    int x;
+	    int list_len=ntohl(bc[ip+1].len);
+
+	    ip+=3; /* skip opcode, list_len, and list data len */
+
+	    for (x=0; x<list_len; x++) {
+		ip = unwrap_string(bc, ip, &data, NULL);
+
+		res = do_removeflag(actions, data);
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "removeflag can not be used with Reject";
+	    } 
+	    break;
+	}
+
+	case B_NOTIFY:
+	{
+	    const char * id;
+	    const char * method;
+	    const char **options = NULL;
+	    const char *priority = NULL;
+	    const char * message;
+	    int pri;
+	    
+	    ip++;
+
+	    /* method */
+	    ip = unwrap_string(bc, ip, &method, NULL);
+
+	    /* id */
+	    ip = unwrap_string(bc, ip, &id, NULL);
+
+	    /*options*/
+	    options=bc_makeArray(bc, &ip); 
+
+	    /* priority */
+	    pri=ntohl(bc[ip].value);
+	    ip++;
+	    
+	    switch (pri)
+	    {
+	    case B_LOW:
+		priority="low";
+	    case B_NORMAL:
+		priority="normal";
+		break;
+	    case B_HIGH: 
+		priority="high";
+		break; 
+	    case B_ANY:
+		priority="any";
+		break;
+	    default:
+		res=SIEVE_RUN_ERROR;
+	    }
+
+	    /* message */
+	    ip = unwrap_string(bc, ip, &message, NULL);
+	  
+	    res = do_notify(notify_list, id, method, options,
+			    priority, message);
+
+	    break;
+	}
+	case B_DENOTIFY:
+	{
+         /*
+	  * i really have no idea what the count matchtype should do here.
+	  * the sanest thing would be to use 1.
+	  * however that would require passing on the match type to do_notify.
+	  *  -jsmith2
+	  */
+
+	    comparator_t *comp = NULL;
+	    
+	    const char *pattern;
+	    regex_t *reg;
+	    
+	    const char *priority = NULL;
+	    void *comprock = NULL;
+	    
+	    int comparator;
+	    int pri;
+	    
+	    ip++;
+	    pri=ntohl(bc[ip].value);
+	    ip++;
+	    
+	    switch (pri)
+	    {
+	    case B_LOW:
+		priority="low";		
+	    case B_NORMAL:
+		priority="normal";
+		break;
+	    case B_HIGH: 
+		priority="high";
+		break; 
+	    case B_ANY:
+		priority="any";
+		break;
+	    default:
+		res=SIEVE_RUN_ERROR;
+	    }
+
+	    if(res == SIEVE_RUN_ERROR)
+		break;
+	   
+	    comparator =ntohl( bc[ip].value);
+	    ip++;
+	    
+	    if (comparator == B_ANY)
+	    { 
+		ip++;/* skip placeholder this has no comparator function */
+		comp=NULL;
+	    } else {
+		int x= ntohl(bc[ip].value);
+		ip++;
+		
+		comp=lookup_comp(B_ASCIICASEMAP,comparator,
+				 x, &comprock);
+	    }
+	    
+	    ip = unwrap_string(bc, ip, &pattern, NULL);
+	  
+	    if (comparator == B_REGEX)
+	    {	
+		char errmsg[1024]; /* Basically unused */
+		
+		reg=bc_compile_regex(pattern,
+				     REG_EXTENDED | REG_NOSUB | REG_ICASE,
+				     errmsg, sizeof(errmsg));
+		if (!reg) {
+		    res = SIEVE_RUN_ERROR;
+		} else {
+		    res = do_denotify(notify_list, comp, reg,
+				      comprock, priority);
+		    free(reg);
+		}
+	    } else {
+		res = do_denotify(notify_list, comp, pattern,
+				  comprock, priority);
+	    }
+	    
+	    break;
+	}
+	case B_VACATION:
+	{
+	    int respond;
+	    char *fromaddr = NULL; /* relative to message we send */
+	    char *toaddr = NULL; /* relative to message we send */
+	    const char *message = NULL;
+	    char buf[128];
+	    char subject[1024];
+	    int x;
+	    
+	    ip++;
+
+	    x=ntohl( bc[ip].len);
+	    
+	    respond=shouldRespond(m, i, x, bc, ip+2,
+				  &fromaddr, &toaddr);
+	    
+	    ip=(ntohl(bc[ip+1].value)/4);	
+	    if (respond==SIEVE_OK)
+	    {	 
+		ip = unwrap_string(bc, ip, &data, NULL);
+		
+		if (!data) 
+		{
+		    /* we have to generate a subject */
+		    const char **s;	    
+		    strlcpy(buf, "subject", sizeof(buf));
+		    if (i->getheader(m, buf, &s) != SIEVE_OK ||
+			s[0] == NULL) {
+			strlcpy(subject, "Automated reply", sizeof(subject));
+		    } else {
+			/* s[0] contains the original subject */
+			const char *origsubj = s[0];
+
+			while (!strncasecmp(origsubj, "Re: ", 4)) 
+			    origsubj += 4;
+
+			snprintf(subject, sizeof(subject), "Re: %s", origsubj);
+		    }
+		} else {
+		    /* user specified subject */
+		    strlcpy(subject, data, sizeof(subject));
+		}
+		
+		ip = unwrap_string(bc, ip, &message, NULL);
+
+		res = do_vacation(actions, toaddr, fromaddr,
+				  xstrdup(subject), message,
+				  ntohl(bc[ip].value), ntohl(bc[ip+1].value));
+
+		ip+=2;		
+
+		if (res == SIEVE_RUN_ERROR)
+		    *errmsg = "Vacation can not be used with Reject or Vacation";
+	    } else if (respond == SIEVE_DONE) {
+                /* skip subject and message */
+
+		ip = unwrap_string(bc, ip, &data, NULL);
+		ip = unwrap_string(bc, ip, &data, NULL);
+
+		ip+=2;/*skip days and mime flag*/
+	    } else {
+		res = SIEVE_RUN_ERROR; /* something is bad */ 
+	    }
+
+	    break;
+	}
+	case B_NULL:/*15*/
+	    ip++;
+	    break;
+
+	case B_JUMP:/*16*/
+	    ip= ntohl(bc[ip+1].jump);
+	    break;
+	    
+	default:
+	    if(errmsg) *errmsg = "Invalid sieve bytecode";
+	    return SIEVE_FAIL;
+	}
+      
+	if (res) /* we've either encountered an error or a stop */
+	    break;
+    }
+    return res;      
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_generate.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_generate.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bc_generate.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bc_generate.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,708 @@
+/* bc_generate.c -- sieve bytecode- almost flattened bytecode
+ * Rob Siemborski
+ * $Id: bc_generate.c,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 2001 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xmalloc.h"
+#include "sieve_interface.h"
+
+#include "script.h"
+#include "tree.h"
+#include "sieve.h"
+
+#include "bytecode.h"
+
+#include <assert.h>
+#include <string.h>
+
+
+
+struct bytecode_info 
+{
+    bytecode_t *data;/* pointer to almost-flat bytecode */
+    size_t scriptend; /* used by emit code to know final length of bytecode */
+    size_t reallen; /* allocated length of 'data' */
+};
+
+static int bc_test_generate(int codep, bytecode_info_t *retval, test_t *t);
+
+/* returns false if the request can't be satisfied, true if it can. */
+
+static int atleast(bytecode_info_t *arr, size_t len) 
+{
+    if(arr->reallen < len) {
+	/* too small; double if that's big enough, otherwise increase to the
+	   requested size. */
+	arr->reallen = (len > arr->reallen * 2 ? len : arr->reallen * 2);
+	arr->data = xrealloc(arr->data, arr->reallen*sizeof(bytecode_t));
+	if(!arr->data) 
+	{ /* out of memory? */
+	    return 0;
+	}
+    }
+    
+    return 1;
+}
+
+/*
+ * functions of the form bc_XXX_generate have the following properties:
+ * on success they return an int that corresponds to the next empty location
+ * for code, and on failure they return -1.
+ *
+ *  they will take a  bytecode_info_t as a parameter and modify it by
+ *  making it larger and adding more bytecommands in the pass 1 form
+ */
+
+/* given a location and a string list, compile it into almost-flat form.
+ * <list len> <string len><string ptr><string len><string ptr> etc... */
+static int bc_stringlist_generate(int codep, bytecode_info_t *retval,
+				  stringlist_t *sl) 
+{
+    int len_codep = codep;
+    int strcount = 0;
+    stringlist_t *cur;
+    
+    codep++;
+
+    /* Bounds check the string list length */
+    if(!atleast(retval,codep+1)) 
+	return -1;
+
+    for(cur=sl; cur; cur=cur->next) 
+    {
+	strcount++;
+	assert((cur->s)!=NULL);
+	
+	/* Bounds check for each string before we allocate it */
+	if(!atleast(retval,codep+2)) 
+	    return -1;
+
+	retval->data[codep++].len = strlen(cur->s);
+	retval->data[codep++].str = cur->s;
+    }
+    
+    retval->data[len_codep].listlen = strcount;
+    return codep;
+}
+
+
+/* write a list of tests into almost-flat form, starting at codep.
+ * returns the next code location, -1 on error. */
+
+/* <list len> <next test ptr> <test ...> <next test ptr> <test ...> ... */
+static int bc_testlist_generate(int codep, bytecode_info_t *retval, 
+				testlist_t *tl) 
+{
+    int len_codep = codep;
+    int testcount = 0;
+    testlist_t *cur;
+    
+    codep++;
+
+    /* Bounds check the test list length */
+    if(!atleast(retval,codep+1)) 
+	return -1;
+       
+    for(cur=tl; cur; cur=cur->next) {
+	int oldcodep = codep;
+
+	/* Make room for tail marker */
+	if(!atleast(retval,codep+1)) 
+	    return -1;
+
+	testcount++;
+	codep = bc_test_generate(codep+1, retval, cur->t);
+
+	retval->data[oldcodep].jump = codep;
+    }
+
+    retval->data[len_codep].listlen = testcount;
+        
+    return codep;
+}
+/* output a relation into almost-flat form at codep.
+ * returns new codep on success, -1 on failure. */
+static int bc_relation_generate(int codep, bytecode_info_t *retval, int relat)
+{
+    if (!atleast(retval, codep + 1)) return -1;
+    switch (relat)
+    {
+    case GT:
+	retval->data[codep++].value= B_GT;
+	break;
+    case GE:
+	retval->data[codep++].value= B_GE;
+	break; 
+    case LT:
+	retval->data[codep++].value= B_LT;
+	break;
+    case LE:
+	retval->data[codep++].value= B_LE;
+	break;
+    case EQ:
+	retval->data[codep++].value= B_EQ;
+	break;
+    case NE:
+	retval->data[codep++].value= B_NE;
+	break;
+    default:
+	/* comparator has no relational field */
+	retval->data[codep++].value=  -1;
+	break;
+    }
+    return codep;
+}
+/* writes a single comparator into almost-flat form starting at codep.
+ * will always write out 3 words
+ * returns the next code location or -1 on error. */
+static int bc_comparator_generate(int codep, bytecode_info_t *retval,
+                                  int comptag, int relat,
+                                  const char *comparator)
+{
+    assert(retval != NULL);
+
+    /* comptag */
+    if (!atleast(retval, codep + 1)) return -1;
+
+    switch (comptag) {
+    case IS:
+        retval->data[codep++].value = B_IS;
+        break;
+    case CONTAINS:
+        retval->data[codep++].value = B_CONTAINS;
+        break;
+    case MATCHES:
+        retval->data[codep++].value = B_MATCHES;
+        break;
+#ifdef ENABLE_REGEX
+    case REGEX:
+        retval->data[codep++].value = B_REGEX;
+        break;
+#endif
+    case COUNT:
+        retval->data[codep++].value = B_COUNT;
+        break;
+    case VALUE:
+        retval->data[codep++].value = B_VALUE;
+        break;
+
+    default:
+        return -1;
+    }
+  
+    /*relation*/
+    codep = bc_relation_generate(codep, retval, relat);
+  
+    /* comparator (value specified with :comparator) */
+    if (!atleast(retval, codep + 1)) return -1;
+  
+    /* xxx perhaps extend comparator.h to have
+       lookup_comp return an index, and then
+       lookup_by_index return the actual comparator?
+       
+       we can then eliminate the comptag above, too. */
+    
+    if (!strcmp (comparator, "i;octet"))
+        retval->data[codep++].value = B_OCTET;
+    else if (!strcmp (comparator, "i;ascii-casemap"))
+        retval->data[codep++].value = B_ASCIICASEMAP;
+    else if (!strcmp (comparator, "i;ascii-numeric"))
+        retval->data[codep++].value = B_ASCIINUMERIC;
+
+    return codep;
+}
+
+
+
+/* writes a single test into almost-flat form starting at codep.
+ * returns the next code location or -1 on error. */
+static int bc_test_generate(int codep, bytecode_info_t *retval, test_t *t)
+{
+    if(!retval) return -1;
+    switch(t->type) {
+    case STRUE: /* BC_TRUE */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_TRUE;
+	break;
+    case SFALSE:/* BC_FALSE */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_FALSE;
+	break;
+    case NOT: /* BC_NOT {subtest : test} */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_NOT;
+	codep = bc_test_generate(codep, retval, t->u.t);
+	if (codep == -1) return -1;
+	break;
+    case SIZE: /* BC_SIZE (B_OVER | B_UNDER) {size : int} */
+	if(!atleast(retval,codep+3)) return -1;
+	retval->data[codep++].op = BC_SIZE;
+	retval->data[codep++].value = (t->u.sz.t == OVER
+				       ? B_OVER : B_UNDER);
+	retval->data[codep++].value = t->u.sz.n;
+	break;
+    case EXISTS:/* BC_EXISTS { headers : string list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_EXISTS;
+	codep= bc_stringlist_generate(codep, retval, t->u.sl);
+	break;
+    case ANYOF:/* BC_ANYOF { tests : test list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_ANYOF;
+	codep=bc_testlist_generate(codep, retval, t->u.tl);
+	if (codep == -1) return -1;
+	break;
+    case ALLOF: /* BC_ALLOF { tests : test list } */
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = BC_ALLOF;
+	codep= bc_testlist_generate(codep, retval, t->u.tl);
+	if (codep == -1) return -1;
+	break;
+    case HEADER:
+	/* BC_HEADER { c: comparator } { headers : string list }
+	   { patterns : string list } 
+	*/
+      
+	if(!atleast(retval,codep + 1)) return -1;
+	retval->data[codep++].op = BC_HEADER;
+      
+	/* comparator */
+	codep = bc_comparator_generate(codep, retval,
+				       t->u.h.comptag,
+				       t->u.h.relation,
+				       t->u.h.comparator);
+	if (codep == -1) return -1;
+      
+	/* headers */
+	codep = bc_stringlist_generate(codep, retval, t->u.h.sl);
+	if (codep == -1) return -1;
+      
+	/* pattern */
+	codep = bc_stringlist_generate(codep, retval, t->u.h.pl);
+	if (codep == -1) return -1;
+	break;
+    case ADDRESS:
+    case ENVELOPE:
+	/* (BC_ADDRESS | BC_ENVELOPE) {c : comparator} 
+	   (B_ALL | B_LOCALPART | ...) { header : string list }
+	   { pattern : string list } */
+      
+	if(!atleast(retval,codep+1)) return -1;
+      
+	retval->data[codep++].op = (t->type == ADDRESS)
+	    ? BC_ADDRESS : BC_ENVELOPE;
+            
+	codep = bc_comparator_generate(codep, retval,t->u.ae.comptag,
+				       t->u.ae.relation, 
+				       t->u.ae.comparator);
+	if (codep == -1) return -1;
+
+	if(!atleast(retval,codep+1)) return -1;
+
+	/*address part*/
+	switch(t->u.ae.addrpart) {
+	case ALL:
+	    retval->data[codep++].value = B_ALL;
+	    break;
+	case LOCALPART:
+	    retval->data[codep++].value = B_LOCALPART;
+	    break;
+	case DOMAIN:
+	    retval->data[codep++].value = B_DOMAIN;
+	    break;
+	case USER:
+	    retval->data[codep++].value = B_USER;
+	    break;
+	case DETAIL:
+	    retval->data[codep++].value = B_DETAIL;
+	    break;
+	default:
+	    return -1;
+	}
+
+	/*headers*/
+	codep = bc_stringlist_generate(codep, retval, t->u.ae.sl);
+	if (codep == -1) return -1;
+
+	/*patterns*/
+	codep = bc_stringlist_generate(codep, retval, t->u.ae.pl);
+	if (codep == -1) return -1;
+     
+	break;
+    default:
+	return -1;
+      
+    }
+    return codep;
+}
+
+
+/* generate a not-quite-flattened bytecode */
+/* returns address of next instruction or -1 on error*/
+/* needs current instruction, buffer for the code, and a current parse tree */
+/* sieve is cool because everything is immediate! */
+static int bc_action_generate(int codep, bytecode_info_t *retval,
+			      commandlist_t *c) 
+{
+    int jumploc,baseloc;
+
+    if(!retval) return -1;
+    if (c==NULL)
+    {
+	if(!atleast(retval,codep+1)) return -1;
+	retval->data[codep++].op = B_NULL;
+    }
+    else
+    {
+	do {
+	    switch(c->type) {
+	    case STOP:
+		/* STOP (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_STOP;
+		break;
+	    case DISCARD:
+		/* DISCARD (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_DISCARD;
+		break;
+	    case KEEP:
+		/* KEEP (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_KEEP;
+		break;
+	    case MARK:
+		/* MARK (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_MARK;
+		break;
+	    case UNMARK:
+		/* UNMARK (no arguments) */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_UNMARK;
+		break;
+	    case DENOTIFY:
+		/* DENOTIFY  */
+		if(!atleast(retval,codep+6)) return -1;
+		retval->data[codep++].op = B_DENOTIFY;
+		switch(c->u.d.priority) {
+		case LOW:
+		    retval->data[codep++].value = B_LOW;
+		    break;
+		case NORMAL:
+		    retval->data[codep++].value = B_NORMAL;
+		    break;
+		case HIGH:
+		    retval->data[codep++].value = B_HIGH;
+		    break;
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break;
+		default:
+		    return -1;
+		}
+		switch(c->u.d.comptag) {
+		case IS:
+		    retval->data[codep++].value = B_IS;
+		    break;
+		case CONTAINS:
+		    retval->data[codep++].value = B_CONTAINS;
+		    break;
+		case MATCHES:
+		    retval->data[codep++].value = B_MATCHES;
+		    break;
+#ifdef ENABLE_REGEX
+		case REGEX:
+		    retval->data[codep++].value = B_REGEX;
+		    break;
+#endif
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break; 
+		default:
+		    return -1;
+		}
+		codep = bc_relation_generate(codep, retval, c->u.d.relation);
+	
+		if(c->u.d.pattern)
+		{
+		    retval->data[codep++].len = strlen(c->u.d.pattern);
+		    retval->data[codep++].str = c->u.d.pattern;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		break;
+	    case REJCT:
+		/* REJECT (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_REJECT;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case FILEINTO:
+		/* FILEINTO (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_FILEINTO;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case REDIRECT:
+		/* REDIRECT (STRING: len + dataptr) */
+		if(!atleast(retval,codep+3)) return -1;
+		retval->data[codep++].op = B_REDIRECT;
+		retval->data[codep++].len = strlen(c->u.str);
+		retval->data[codep++].str = c->u.str;
+		break;
+	    case ADDFLAG:
+		/* ADDFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_ADDFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case SETFLAG:
+		/* SETFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_SETFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case REMOVEFLAG:
+		/* REMOVEFLAG stringlist */
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_REMOVEFLAG;
+		codep = bc_stringlist_generate(codep,retval,c->u.sl);
+
+		if(codep == -1) return -1;
+		break;
+	    case NOTIFY:
+		/* NOTIFY 
+		   (STRING: len + dataptr)
+		   (STRING: len + dataptr)
+		   stringlist
+		   (STRING: len + dataptr)
+		   (STRING: len + dataptr)
+		   method/id /options list/priority/message 
+		*/
+			
+		if(!atleast(retval,codep+5)) return -1;
+		retval->data[codep++].op = B_NOTIFY;
+		
+		retval->data[codep++].len = strlen(c->u.n.method);
+		retval->data[codep++].str = c->u.n.method;
+				
+		if (c->u.n.id)
+		{
+		    retval->data[codep++].len = strlen(c->u.n.id);
+		    retval->data[codep++].str = c->u.n.id;
+		}
+		else
+		{
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+		
+		codep = bc_stringlist_generate(codep,retval,c->u.n.options);
+		if(codep == -1) return -1;
+
+		if(!atleast(retval,codep+3)) return -1;
+
+		switch(c->u.n.priority) {
+		case LOW:
+		    retval->data[codep++].value = B_LOW;
+		    break;
+		case NORMAL:
+		    retval->data[codep++].value = B_NORMAL;
+		    break;
+		case HIGH:
+		    retval->data[codep++].value = B_HIGH;
+		    break;
+		case ANY:
+		    retval->data[codep++].value = B_ANY;
+		    break;
+		default:
+		    return -1;
+		}
+		
+		retval->data[codep++].len = strlen(c->u.n.message);
+		retval->data[codep++].str = c->u.n.message;
+		break;
+	    case VACATION:
+		/* VACATION
+		   STRINGLIST addresses
+		   STRING subject (if len is -1, then subject was NULL)
+		   STRING message (again, len == -1 means subject was NULL)
+		   VALUE days
+		   VALUE mime
+		*/
+
+		if(!atleast(retval,codep+1)) return -1;
+		retval->data[codep++].op = B_VACATION;
+	    
+		codep = bc_stringlist_generate(codep,retval,c->u.v.addresses);
+		if (codep == -1) return -1;
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.subject) {
+		    retval->data[codep++].len = strlen(c->u.v.subject);
+		    retval->data[codep++].str = c->u.v.subject;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		if(c->u.v.message) {
+		    retval->data[codep++].len = strlen(c->u.v.message);
+		    retval->data[codep++].str = c->u.v.message;
+		} else {
+		    retval->data[codep++].len = -1;
+		    retval->data[codep++].str = NULL;
+		}
+
+		if (!atleast(retval,codep+2)) return -1;
+		retval->data[codep++].value = c->u.v.days;
+		retval->data[codep++].value = c->u.v.mime;
+	    
+
+		if(codep == -1) return -1;
+		break;
+	    case IF:
+	    {
+		int jumpVal; 	    
+		/* IF
+		   (int: begin then block)
+		   (int: end then block/begin else block)
+		   (int:end else block) (-1 if no else block)
+		   (test)
+		   (then block)
+		   (else block)(optional)
+		*/
+		baseloc = codep;
+	    
+		/* Allocate operator + jump table offsets */
+		if(!atleast(retval,codep+4)) return -1;
+		
+		jumploc = codep+4;
+		retval->data[codep++].op = B_IF;
+		    
+		/* begining of then  code */
+		jumpVal= bc_test_generate(jumploc,retval,c->u.i.t);
+		if(jumpVal == -1) 
+		    return -1;
+		else {
+		    retval->data[codep].jump = jumpVal;
+		    codep++;
+		}
+	    
+		/* find then code and offset to else code,
+		 * we want to write this code starting at the offset we
+		 * just found */
+	
+		jumpVal= bc_action_generate(jumpVal,retval, c->u.i.do_then);
+		if(jumpVal == -1) 
+		    return -1;
+		else 
+		    retval->data[codep].jump = jumpVal;
+		
+		codep++;
+		/* write else code if its there*/
+		if(c->u.i.do_else) {
+	
+		    jumpVal= bc_action_generate(jumpVal,retval, c->u.i.do_else);
+		    if(jumpVal == -1) 
+		    {
+			return -1;
+		    } else 
+		    {
+			retval->data[codep].jump = jumpVal;
+		    }
+		    
+		    /* Update code pointer to end of else code */
+		    codep = retval->data[codep].jump;
+		} else {
+		    /*there is no else block, so its -1*/
+		    retval->data[codep].jump = -1;
+		    /* Update code pointer to end of then code */
+		    codep = retval->data[codep-1].jump;
+		}
+	    
+		break;
+	    }
+	    default:
+		/* no such action known */
+		return -1;
+	    }
+	  
+	    /* generate from next command */
+	    c = c->next;
+	} while(c);
+    }
+    /*scriptend may be updated before the end, but it will be updated at the end, which is what matters.*/
+    retval->scriptend=codep;
+    return codep;
+   
+}
+
+
+
+/* Entry point to the bytecode emitter module */	
+int sieve_generate_bytecode(bytecode_info_t **retval, sieve_script_t *s) 
+{
+    commandlist_t *c;
+
+    if(!retval) return -1;
+    if(!s) return -1;
+    c = s->cmds;
+    /* if c is NULL, it is handled in bc_action_generate and a script
+       with only BC_NULL is returned
+    */
+
+    
+    *retval = xmalloc(sizeof(bytecode_info_t));
+    if(!(*retval)) return -1;
+
+    memset(*retval, 0, sizeof(bytecode_info_t));
+
+    return bc_action_generate(0, *retval, c);
+}
+
+
+void sieve_free_bytecode(bytecode_info_t **p) 
+{
+    if(!p || !*p) return;
+    if((*p)->data) free((*p)->data);
+    free(*p);
+    *p = NULL;
+}
+ 
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bytecode.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bytecode.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/bytecode.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/bytecode.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,191 @@
+/* bytecode.h -- bytecode definition
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+#ifndef SIEVE_BYTECODE_H
+#define SIEVE_BYTECODE_H
+
+
+/* for debugging*/
+#define DUMPCODE 0
+#define VERBOSE 0
+
+/*for finding correctly aligned bytes on strings*/
+/* bump to the next multiple of 4 bytes */
+#define ROUNDUP(num) (((num) + 3) & 0xFFFFFFFC)
+
+
+/* yes, lots of these are superfluous, it's for clarity */
+typedef union 
+{
+    int op; /* OPTYPE */
+    int value;
+
+    int jump;
+
+    int listlen;
+
+    /* store strings (need 2 consecutive bytecodes) */
+    int len;
+    char *str;
+} bytecode_t;
+
+/* For sanity during input on 64-bit platforms.
+ * str should only be accessed as (char *)&str, but given the use of
+ * unwrap_string, this should be OK */
+typedef union 
+{
+    int op; /* OPTYPE */
+    int value;
+
+    int jump;
+
+    int listlen;
+
+    /* store strings (need 2 consecutive bytecodes) */
+    int len;
+    int str;
+} bytecode_input_t;
+
+
+   /*version 0x01 scripts were written in host byte order.
+   we don't want to use this version number again and cause a mess
+   this isn't a huge concern, since this is version ntohl(1), or 16777216*/
+#define BYTECODE_VERSION 0x03
+#define BYTECODE_MAGIC "CyrSBytecode"
+#define BYTECODE_MAGIC_LEN 12 /* Should be multiple of 4 */
+
+/* IMPORTANT: To maintain forward compatibility of bytecode, please only add
+ * new instructions to the end of these enums.  (The reason these values
+ * are all duplicated here is to avoid silliness if this caveat is forgotten
+ * about in the other tables.) */
+enum bytecode {
+    B_STOP,
+
+    B_KEEP,
+    B_DISCARD,
+    B_REJECT,/* require reject*/
+    B_FILEINTO,/*require fileinto*/
+    B_REDIRECT,
+
+    B_IF,
+  
+    B_MARK,/* require imapflags */
+    B_UNMARK,/* require imapflags */
+
+    B_ADDFLAG,/* require imapflags */
+    B_SETFLAG,/* require imapflags */
+    B_REMOVEFLAG,/* require imapflags */
+
+    B_NOTIFY,/* require notify */
+    B_DENOTIFY,/* require notify */
+
+    B_VACATION,/* require vacation*/
+    B_NULL,
+    B_JUMP
+};
+
+enum bytecode_comps {
+    BC_FALSE,
+    BC_TRUE,
+    BC_NOT,
+    BC_EXISTS,
+    BC_SIZE,
+    BC_ANYOF,
+    BC_ALLOF,
+    BC_ADDRESS,
+    BC_ENVELOPE,  /* require envelope*/
+    BC_HEADER    
+};
+
+/* currently one enum so as to help determine where values are being misused.
+ * we have left placeholders incase we need to add more later to the middle */
+enum bytecode_tags {
+    /* Sizes */
+    B_OVER,
+    B_UNDER,
+
+    B_SIZE_PLACEHOLDER_1,
+    B_SIZE_PLACEHOLDER_2,
+     
+    /* sizes, pt 2 */
+    B_GT, /* require relational*/
+    B_GE,  /* require relational*/
+    B_LT,  /* require relational*/
+    B_LE,  /* require relational*/
+    B_EQ,  /* require relational*/
+    B_NE,  /* require relational*/
+ 
+    B_RELATIONAL_PLACEHOLDER_1,
+    B_RELATIONAL_PLACEHOLDER_2,
+   
+    /* priorities */
+    B_LOW,
+    B_NORMAL,
+    B_HIGH,
+    B_ANY,
+
+    B_PRIORITY_PLACEHOLDER_1,
+    B_PRIORITY_PLACEHOLDER_2,
+    B_PRIORITY_PLACEHOLDER_3,
+    B_PRIORITY_PLACEHOLDER_4,
+    
+    /* Address Part Tags */
+    B_ALL,
+    B_LOCALPART,
+    B_DOMAIN,
+    B_USER,  /* require subaddress */
+    B_DETAIL, /* require subaddress */
+    
+    B_ADDRESS_PLACEHOLDER_1,
+    B_ADDRESS_PLACEHOLDER_2,
+    B_ADDRESS_PLACEHOLDER_3,
+    B_ADDRESS_PLACEHOLDER_4,
+
+    /* Comparators */
+    B_ASCIICASEMAP,
+    B_OCTET,
+    B_ASCIINUMERIC, /* require comparator-i;ascii-numeric */
+    
+    B_COMPARATOR_PLACEHOLDER_1,
+    B_COMPARATOR_PLACEHOLDER_2,
+    B_COMPARATOR_PLACEHOLDER_3,
+    B_COMPARATOR_PLACEHOLDER_4,
+ 
+    /* match types */
+    B_IS,
+    B_CONTAINS,
+    B_MATCHES,
+    B_REGEX,/* require regex*/
+    B_COUNT,/* require relational*/
+    B_VALUE,/* require relational*/
+
+    B_MATCH_PLACEHOLDER_1,
+    B_MATCH_PLACEHOLDER_2,
+    B_MATCH_PLACEHOLDER_3,
+    B_MATCH_PLACEHOLDER_4
+  
+};
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/comparator.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/comparator.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/comparator.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/comparator.c	2005-10-15 09:12:26.000000000 -0400
@@ -0,0 +1,447 @@
+/* comparator.c -- comparator functions
+ * Larry Greenfield
+ * $Id: comparator.c,v 1.2 2005/10/15 13:12:26 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "comparator.h"
+#include "tree.h"
+#include "sieve.h"
+#include "bytecode.h"
+
+/*!!! uses B_CONTAINS not CONTAINS, etc, only works with bytecode*/
+
+extern int strcasecmp(const char *, const char *);
+
+typedef int (*compare_t)(const void *, const void *);
+
+/* --- relational comparators --- */
+
+/* these are generic wrappers in which 'rock' is the compare function */
+
+static int rel_eq(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) == 0);
+}
+
+static int rel_ne(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) != 0);
+}
+
+static int rel_gt(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) > 0);
+}
+
+static int rel_ge(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) >= 0);
+}
+
+static int rel_lt(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) < 0);
+}
+
+static int rel_le(const char *text, const char *pat, void *rock)
+{
+    compare_t compar = (compare_t) rock;
+
+    return (compar(text, pat) <= 0);
+}
+
+/* --- i;octet comparators --- */
+
+/* just compare the two; these should be NULL terminated */
+static int octet_cmp(const char *text, const char *pat)
+{
+    size_t sl;
+    int r;
+
+    sl = strlen(text) < strlen(pat) ? strlen(text) : strlen(pat);
+
+    r = memcmp(text, pat, sl);
+
+    if (r == 0)
+	return (strlen(text) - strlen(pat));
+    else 
+	return r;
+}
+
+/* we implement boyer-moore for hell of it, since this is probably
+ not very useful for sieve */
+#if 0
+int boyer_moore(char *text, char *pat)
+{
+    int i, j; /* indexes */
+    int M = strlen(pat); /* length of pattern */
+    int N = strlen(text); /* length of text */
+    int skip[256]; /* table of how much to skip, based on each character */
+
+    /* initialize skip table */
+    for (i = 0; i < 256; i++)
+	skip[i] = M;
+    for (i = 0; i < M; i++)
+	skip[(int) pat[i]] = M-i-1;
+    
+    /* look for pat in text */
+    i = j = M-1;
+    do {
+	if (pat[j] == text[i]) {
+	    i--;
+	    j--;
+	} else {
+	    if (M-j > skip[(int) text[i]]) {
+		i = i + M - j;
+	    } else {
+		i = i + skip[(int) text[i]];
+	    }
+	    j = M-1;
+	}
+    } while (!((j < 0) || (i >= N)));
+    /* i+1 is the position of the match if i < N */
+    return (i < N) ? 1 : 0;
+}
+#endif
+
+/* we do a brute force attack */
+static int octet_contains(const char *text, const char *pat, 
+                          void *rock __attribute__((unused)))
+{
+    return (strstr(text, pat) != NULL);
+}
+
+static int octet_matches_(const char *text, const char *pat, int casemap)
+{
+    const char *p;
+    const char *t;
+    char c;
+
+    t = text;
+    p = pat;
+    for (;;) {
+	if (*p == '\0') {
+	    /* ran out of pattern */
+	    return (*t == '\0');
+	}
+	c = *p++;
+	switch (c) {
+	case '?':
+	    if (*t == '\0') {
+		return 0;
+	    }
+	    t++;
+	    break;
+	case '*':
+	    while (*p == '*' || *p == '?') {
+		if (*p == '?') {
+		    /* eat the character now */
+		    if (*t == '\0') {
+			return 0;
+		    }
+		    t++;
+		}
+		/* coalesce into a single wildcard */
+		p++;
+	    }
+	    if (*p == '\0') {
+		/* wildcard at end of string, any remaining text is ok */
+		return 1;
+	    }
+
+	    while (*t != '\0') {
+		/* recurse */
+		if (octet_matches_(t, p, casemap)) return 1;
+		t++;
+	    }
+	case '\\':
+	    p++;
+	    /* falls through */
+	default:
+	    if (casemap && (toupper(c) == toupper(*t))) {
+		t++;
+	    } else if (!casemap && (c == *t)) {
+		t++;
+	    } else {
+		/* literal char doesn't match */
+		return 0;
+	    }
+	}
+    }
+    /* never reaches */
+    abort();
+}
+
+static int octet_matches(const char *text, const char *pat, 
+                         void *rock __attribute__((unused)))
+{
+    return octet_matches_(text, pat, 0);
+}
+
+
+#ifdef ENABLE_REGEX
+static int octet_regex(const char *text, const char *pat, 
+                       void *rock __attribute__((unused)))
+{
+    return (!regexec((regex_t *) pat, text, 0, NULL, 0));
+}
+#endif
+
+
+/* --- i;ascii-casemap comparators --- */
+
+
+/* use strcasecmp() as the compare function */
+
+/* sheer brute force */
+static int ascii_casemap_contains(const char *text, const char *pat,
+				  void *rock __attribute__((unused)))
+{
+    int N = strlen(text);
+    int M = strlen(pat);
+    int i, j;
+
+    i = 0, j = 0;
+    while ((j < M) && (i < N)) {
+              if (toupper(text[i]) == toupper(pat[j])) {
+	  	  i++; j++;
+	} else {
+	    i = i - j + 1;
+	    j = 0;
+	}
+    }    
+
+    return (j == M); /* we found a match! */
+}
+
+static int ascii_casemap_matches(const char *text, const char *pat, 
+                                 void *rock __attribute__((unused)))
+{
+    return octet_matches_(text, pat, 1);
+}
+
+/* i;ascii-numeric; only supports relational tests
+ *
+ *  A \ B    number   not-num 
+ *  number   A ? B    B > A 
+ *  not-num  A > B    A == B
+ */
+
+ /* From RFC 2244:
+  *
+  * The i;ascii-numeric comparator interprets strings as decimal
+  * positive integers represented as US-ASCII digits.  All values
+  * which do not begin with a US-ASCII digit are considered equal
+  * with an ordinal value higher than all non-NIL single-valued
+  * attributes.  Otherwise, all US-ASCII digits (octet values
+  * 0x30 to 0x39) are interpreted starting from the beginning of
+  * the string to the first non-digit or the end of the string.
+  */
+
+static int ascii_numeric_cmp(const char *text, const char *pat)
+{
+    unsigned text_digit_len;
+    unsigned pat_digit_len;
+
+    if (isdigit((int) *pat)) {
+	if (isdigit((int) *text)) {
+	    /* Count how many digits each string has */
+	    for (text_digit_len = 0;
+		 isdigit((int) text[text_digit_len]);
+		 text_digit_len++);
+	    for (pat_digit_len = 0;
+		 isdigit((int) pat[pat_digit_len]);
+		 pat_digit_len++);
+
+	    if (text_digit_len < pat_digit_len) {
+		/* Pad "text" with leading 0s */
+		while (pat_digit_len > text_digit_len) {
+		    /* "text" can only be less or equal to "pat" */
+		    if ('0' < *pat) {
+			return (-1); 
+		    }
+		    pat++;
+		    pat_digit_len--;
+		}
+	    } else if (text_digit_len > pat_digit_len) {
+		/* Pad "pad" with leading 0s */
+		while (text_digit_len > pat_digit_len) {
+		    /* "pad" can only be greater or equal to "text" */
+		    if (*text > '0') {
+			return 1;
+		    }
+		    text++;
+		    text_digit_len--;
+		}
+	    }
+
+	    /* CLAIM: If we here, we have two non-empty digital suffixes
+	       of equal length */
+	    while (text_digit_len > 0) {
+		if (*text < *pat) {
+			return -1;
+		} else if (*text > *pat) {
+			return 1;
+		}
+		/* Characters are equal, carry on */
+		text++;
+		pat++;
+		text_digit_len--;
+	    }
+
+	    return (0);
+	} else {
+	    return 1;
+	}
+    } else if (isdigit((int) *text)) {
+	return -1;
+    } else {
+	return 0; /* both not digits */
+    }
+}
+
+static comparator_t *lookup_rel(int relation)
+{
+    comparator_t *ret;
+
+    ret = NULL;
+    switch (relation)
+      {
+      case B_EQ:
+	ret = &rel_eq;
+	break;
+      case B_NE:
+	ret = &rel_ne; 
+	break;
+      case B_GT: 
+	ret = &rel_gt; 
+	break;
+      case B_GE:
+         ret = &rel_ge; 
+	 break;
+      case B_LT:
+	ret = &rel_lt; 
+	break;
+      case B_LE:
+	ret = &rel_le; 
+      }
+
+    return ret;
+}
+
+comparator_t *lookup_comp(int comp, int mode, int relation,
+			  void **comprock)
+{
+    comparator_t *ret;
+
+    ret = NULL;
+    *comprock = NULL;
+#if VERBOSE
+    printf("comp%d mode%d relat%d     \n", comp, mode, relation); 
+#endif
+    switch (comp)
+      {
+      case B_OCTET:    
+ 	switch (mode) {
+	  case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &octet_cmp;
+	    break;
+	  case B_CONTAINS:
+	    ret = &octet_contains;
+	    break;
+	  case B_MATCHES:
+	    ret = &octet_matches;
+	    break;
+#ifdef ENABLE_REGEX
+	  case B_REGEX:
+	    ret = &octet_regex;
+	    break;
+#endif
+	  case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &octet_cmp;
+	    break;
+	}
+	break; /*end of octet */
+      case B_ASCIICASEMAP:
+     	switch (mode) {
+	case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &strcasecmp;
+	    break;
+	case B_CONTAINS:
+	    ret = &ascii_casemap_contains;
+	    break;
+	case B_MATCHES:
+	    ret = &ascii_casemap_matches;
+	    break;
+#ifdef ENABLE_REGEX
+	case B_REGEX:
+	    /* the ascii-casemap destinction is made during
+	       the compilation of the regex in verify_regex() */
+	    ret = &octet_regex;
+	    break;
+#endif
+	case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = &strcasecmp;
+	    break;
+	}
+	break;/*end of ascii casemap */
+      case B_ASCIINUMERIC:
+	switch (mode) {
+	case B_IS:
+	    ret = &rel_eq;
+	    *comprock = (void **) &ascii_numeric_cmp;
+	    break;
+	case B_COUNT:
+	case B_VALUE:
+	    ret = lookup_rel(relation);
+	    *comprock = (void **) &ascii_numeric_cmp;
+	    break;
+	}
+	break;
+      }
+    return ret;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/comparator.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/comparator.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/comparator.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/comparator.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,48 @@
+/* comparator.h
+ * Larry Greenfield
+ * $Id: comparator.h,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef COMPARATOR_H
+#define COMPARATOR_H
+
+#ifdef ENABLE_REGEX
+#ifdef HAVE_RX
+#include <rxposix.h>
+#else
+#include <sys/types.h>
+#include <regex.h>
+#endif
+#endif
+
+/* compares pat to text; returns 1 if it's true, 0 otherwise 
+   first arg is text, second arg is pat, third arg is rock */
+typedef int comparator_t(const char *, const char *, void *);
+
+/* returns a pointer to a comparator function given it's name */
+comparator_t *lookup_comp(int comp, int mode,
+			  int relation, void **rock);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/COPYING dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/COPYING
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/COPYING	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/COPYING	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,26 @@
+/* cmu-sieve
+ * Larry Greenfield
+ * $Id: COPYING,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1998 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/interp.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/interp.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/interp.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/interp.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,203 @@
+/* interp.c -- sieve script interpretor builder
+ * Larry Greenfield
+ * $Id: interp.c,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#include "xmalloc.h"
+
+#include "sieve_interface.h"
+#include "interp.h"
+
+/* build a sieve interpretor */
+int sieve_interp_alloc(sieve_interp_t **interp, void *interp_context)
+{
+    sieve_interp_t *i;
+    static int initonce;
+
+    if (!initonce) {
+	initialize_siev_error_table();
+	initonce = 1;
+    }
+
+    *interp = NULL;
+    i = (sieve_interp_t *) xmalloc(sizeof(sieve_interp_t));
+    if (i == NULL) {
+	return SIEVE_NOMEM;
+    }
+
+    i->redirect = i->discard = i->reject = i->fileinto = i->keep = NULL;
+    i->getsize = NULL;
+    i->getheader = NULL;
+    i->getenvelope = NULL;
+    i->vacation = NULL;
+    i->notify = NULL;
+
+    i->markflags = NULL;
+
+    i->interp_context = interp_context;
+    i->err = NULL;
+
+    *interp = i;
+    return SIEVE_OK;
+}
+
+static const char *sieve_extensions = "fileinto reject envelope vacation"
+                                      " imapflags notify subaddress relational"
+                                      " comparator-i;ascii-numeric"
+#ifdef ENABLE_REGEX
+" regex";
+#else
+"";
+#endif /* ENABLE_REGEX */
+
+const char *sieve_listextensions(void)
+{
+    return sieve_extensions;
+}
+
+int sieve_interp_free(sieve_interp_t **interp)
+{
+    free(*interp);
+    
+    return SIEVE_OK;
+}
+
+/* add the callbacks */
+int sieve_register_redirect(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->redirect = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_discard(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->discard = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_reject(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->reject = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_fileinto(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->fileinto = f;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_keep(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->keep = f;
+ 
+    return SIEVE_OK;
+}
+
+static char *default_markflags[] = { "\\flagged" };
+static sieve_imapflags_t default_mark = { default_markflags, 1 };
+
+int sieve_register_imapflags(sieve_interp_t *interp, sieve_imapflags_t *mark)
+{
+    interp->markflags =
+	(mark && mark->flag && mark->nflags) ? mark : &default_mark;
+
+    return SIEVE_OK;
+}
+
+int sieve_register_notify(sieve_interp_t *interp, sieve_callback *f)
+{
+    interp->notify = f;
+ 
+    return SIEVE_OK;
+}
+
+/* add the callbacks for messages. again, undefined if used after
+   sieve_script_parse */
+int sieve_register_size(sieve_interp_t *interp, sieve_get_size *f)
+{
+    interp->getsize = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_header(sieve_interp_t *interp, sieve_get_header *f)
+{
+    interp->getheader = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_envelope(sieve_interp_t *interp, sieve_get_envelope *f)
+{
+    interp->getenvelope = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_vacation(sieve_interp_t *interp, sieve_vacation_t *v)
+{
+    if (!interp->getenvelope) {
+	return SIEVE_NOT_FINALIZED; /* we need envelope for vacation! */
+    }
+
+    if (v->min_response == 0) v->min_response = 3;
+    if (v->max_response == 0) v->max_response = 90;
+    if (v->min_response < 0 || v->max_response < 7 || !v->autorespond
+	|| !v->send_response) {
+	return SIEVE_FAIL;
+    }
+
+    interp->vacation = v;
+    return SIEVE_OK;
+}
+
+int sieve_register_parse_error(sieve_interp_t *interp, sieve_parse_error *f)
+{
+    interp->err = f;
+    return SIEVE_OK;
+}
+
+int sieve_register_execute_error(sieve_interp_t *interp, sieve_execute_error *f)
+{
+    interp->execute_err = f;
+    return SIEVE_OK;
+}
+
+int interp_verify(sieve_interp_t *i)
+{
+    if (i->redirect && i->keep && i->getsize && i->getheader) {
+	return SIEVE_OK;
+    } else {
+	return SIEVE_NOT_FINALIZED;
+    }
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/interp.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/interp.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/interp.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/interp.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,56 @@
+/* interp.h -- interpretor definition
+ * Larry Greenfield
+ * $Id: interp.h,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+#ifndef SIEVE_INTERP_H
+#define SIEVE_INTERP_H
+
+#include "sieve_interface.h"
+
+struct sieve_interp {
+    /* standard callbacks for actions */
+    sieve_callback *redirect, *discard, *reject, *fileinto, *keep;
+    sieve_callback *notify;
+    sieve_vacation_t *vacation;
+
+    sieve_get_size *getsize;
+    sieve_get_header *getheader;
+    sieve_get_envelope *getenvelope;
+
+    sieve_parse_error *err;
+
+    /* site-specific imapflags for mark/unmark */
+    sieve_imapflags_t *markflags;
+
+    sieve_execute_error *execute_err;
+
+    /* context to pass along */
+    void *interp_context;
+};
+
+int interp_verify(sieve_interp_t *interp);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/Makefile.am dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/Makefile.am
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/Makefile.am	2005-10-17 09:59:10.000000000 -0400
@@ -0,0 +1,52 @@
+noinst_LIBRARIES = libsieve.a
+
+AM_YFLAGS = -d -p $*
+
+AM_CPPFLAGS = \
+	-I$(dovecotdir) \
+	-I$(dovecotdir)/src/lib \
+	-I$(top_srcdir)/src
+
+addr-lex.c: addr-lex.l
+	$(LEX) -t -Paddr addr-lex.l > addr-lex.c
+
+sieve-lex.c: sieve-lex.l
+	$(LEX) -t sieve-lex.l > sieve-lex.c
+
+libsieve_a_SOURCES = \
+	addr.y \
+	sieve.y \
+	addr-lex.l \
+	sieve-lex.l \
+	bc_dump.c \
+	bc_emit.c \
+	bc_eval.c \
+	bc_generate.c \
+	comparator.c \
+	interp.c \
+	message.c \
+	parseaddr.c \
+	script.c \
+	sieve_err.c \
+	tree.c
+
+noinst_HEADERS = \
+	addr.h \
+	bytecode.h \
+	comparator.h \
+	interp.h \
+	message.h \
+	parseaddr.h \
+	script.h \
+	sieve.h \
+	sieve_err.h \
+	sieve_interface.h \
+	tree.h
+
+EXTRA_DIST = \
+	addr-lex.l \
+	sieve-lex.l \
+	AUTHORS \
+	COPYING \
+	NEWS \
+	README
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/message.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/message.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/message.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/message.c	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,580 @@
+/* message.c -- message parsing functions
+ * Larry Greenfield
+ * $Id: message.c,v 1.2 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "message.h"
+#include "parseaddr.h"
+#include "xmalloc.h"
+
+/* reject message m with message msg
+ *
+ * incompatible with: fileinto, redirect
+ */
+int do_reject(action_list_t *a, const char *msg)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_FILEINTO ||
+	    a->a == ACTION_KEEP ||
+	    a->a == ACTION_REDIRECT ||
+	    a->a == ACTION_REJECT ||
+	    a->a == ACTION_VACATION ||
+	    a->a == ACTION_SETFLAG ||
+	    a->a == ACTION_ADDFLAG ||
+	    a->a == ACTION_REMOVEFLAG ||
+	    a->a == ACTION_MARK ||
+	    a->a == ACTION_UNMARK
+	    )
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REJECT;
+    a->u.rej.msg = msg;
+    b->next = a;
+    a->next =  NULL;
+    return 0;
+}
+
+/* fileinto message m into mailbox 
+ *
+ * incompatible with: reject
+ */
+int do_fileinto(action_list_t *a, const char *mbox,
+		sieve_imapflags_t *imapflags)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_FILEINTO;
+    a->u.fil.mailbox = mbox;
+    a->u.fil.imapflags = imapflags;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* redirect message m to to addr
+ *
+ * incompatible with: reject
+ */
+int do_redirect(action_list_t *a, const char *addr)
+{
+    action_list_t *b = NULL;
+
+    /* xxx we should validate addr */
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REDIRECT;
+    a->u.red.addr = addr;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* keep message
+ *
+ * incompatible with: reject
+ */
+int do_keep(action_list_t *a, sieve_imapflags_t *imapflags)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	if (a->a == ACTION_KEEP) /* don't bother doing it twice */
+	    return 0;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_KEEP;
+    a->u.keep.imapflags = imapflags;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* discard message m
+ *
+ * incompatible with: nothing---it doesn't cancel any actions
+ */
+int do_discard(action_list_t *a)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_DISCARD) /* don't bother doing twice */
+	    return 0;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_DISCARD;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+int do_vacation(action_list_t *a, char *addr, char *fromaddr,
+		char *subj, const char *msg, int days,
+		int mime)
+{
+    action_list_t *b = NULL;
+
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT ||
+	    a->a == ACTION_VACATION) /* vacation can't be used twice */
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_VACATION;
+    a->u.vac.send.addr = addr;
+    a->u.vac.send.fromaddr = fromaddr;
+    a->u.vac.send.subj = subj;	/* user specified subject */
+    a->u.vac.send.msg = msg;
+    a->u.vac.send.mime = mime;
+    a->u.vac.autoresp.days = days;
+    a->next = NULL;
+    b->next = a;
+    return 0;
+}
+
+/* setflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_setflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_SETFLAG;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* addflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_addflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_ADDFLAG;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* removeflag f on message m
+ *
+ * incompatible with: reject
+ */
+int do_removeflag(action_list_t *a, const char *flag)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_REMOVEFLAG;
+    a->u.fla.flag = flag;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+
+/* mark message m
+ *
+ * incompatible with: reject
+ */
+int do_mark(action_list_t *a)
+{
+    action_list_t *b = NULL;
+ 
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_MARK;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+
+/* unmark message m
+ *
+ * incompatible with: reject
+ */
+int do_unmark(action_list_t *a)
+{
+
+    action_list_t *b = NULL;
+    /* see if this conflicts with any previous actions taken on this message */
+    while (a != NULL) {
+	b = a;
+	if (a->a == ACTION_REJECT)
+	    return SIEVE_RUN_ERROR;
+	a = a->next;
+    }
+ 
+    /* add to the action list */
+    a = (action_list_t *) xmalloc(sizeof(action_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+    a->a = ACTION_UNMARK;
+    b->next = a;
+    a->next = NULL;
+    return 0;
+}
+
+/* notify
+ *
+ * incompatible with: none
+ */
+int do_notify(notify_list_t *a, const char *id,
+	      const char *method, const char **options,
+	      const char *priority, const char *message)
+{
+    notify_list_t *b = NULL;
+
+    /* find the end of the notify list */
+    while (a != NULL) {
+	b = a;
+	a = a->next;
+    }
+
+    /* add to the notify list */
+    a = (notify_list_t *) xmalloc(sizeof(notify_list_t));
+    if (a == NULL)
+	return SIEVE_NOMEM;
+
+    b->next = a;
+    a->isactive = 1;
+    a->id = id;
+    a->method = method;
+    a->options = options;
+    a->priority = priority;
+    a->message = message;
+    a->next = NULL;
+    return 0;
+}
+
+/* denotify
+ *
+ * incomaptible with: none
+ */
+int do_denotify(notify_list_t *n, comparator_t *comp, const void *pat,
+		void *comprock, const char *priority)
+{
+    while (n != NULL) {
+	if (n->isactive && 
+	    (!priority || !strcasecmp(n->priority, priority)) &&
+	    (!comp || (n->id && comp(n->id, pat, comprock)))) {
+	    n->isactive = 0;
+	}
+	n = n->next;
+    }
+
+    return 0;
+}
+
+
+
+/* given a header, extract an address out of it.  if marker points to NULL,
+   extract the first address.  otherwise, it's an index into the header to
+   say where to start extracting */
+struct addr_marker {
+    struct address *where;
+    char *freeme;
+};
+
+int parse_address(const char *header, void **data, void **marker)
+{
+    struct addr_marker *am = (struct addr_marker *) *marker;
+
+    parseaddr_list(header, (struct address **) data);
+    am = (void *) xmalloc(sizeof(struct addr_marker));
+    am->where = *data;
+    am->freeme = NULL;
+    *marker = am;
+    return SIEVE_OK;
+}
+
+char *get_address(address_part_t addrpart,
+		  void **data __attribute__((unused)),
+		  void **marker,
+		  int canon_domain)
+{
+    char *ret = NULL;
+    struct address *a;
+    struct addr_marker *am = *marker;
+
+    a = am->where;
+    if (am->freeme) {
+	free(am->freeme);
+	am->freeme = NULL;
+    }
+
+    if (a == NULL) {
+	ret = NULL;
+    } else {
+	if (canon_domain && a->domain)
+	    lcase(a->domain);
+
+	switch (addrpart) { 
+	case ADDRESS_ALL:
+#define U_DOMAIN "unspecified-domain"
+#define U_USER "unknown-user"
+	    if (a->mailbox || a->domain) {
+		char *m = a->mailbox ? a->mailbox : U_USER;
+		char *d = a->domain ? a->domain : U_DOMAIN;
+		am->freeme = (char *) xmalloc(strlen(m) + strlen(d) + 2);
+
+		sprintf(am->freeme, "%s@%s", m, d);
+		ret = am->freeme;
+	    } else {
+		ret = NULL;
+	    }
+	    break;
+
+	case ADDRESS_LOCALPART:
+	    ret = a->mailbox;
+	    break;
+	    
+	case ADDRESS_DOMAIN:
+	    ret = a->domain;
+	    break;
+
+	case ADDRESS_USER:
+	    if (a->mailbox) {
+		char *p = strchr(a->mailbox, '+');
+		int len = p ? p - a->mailbox : (int)strlen(a->mailbox);
+
+		am->freeme = (char *) xmalloc(len + 1);
+		strncpy(am->freeme, a->mailbox, len);
+		am->freeme[len] = '\0';
+		ret = am->freeme;
+	    } else {
+		ret = NULL;
+	    }
+	    break;
+
+	case ADDRESS_DETAIL:
+	    if (a->mailbox)
+	    {	    
+		char *p = strchr(a->mailbox, '+');
+		ret = (p ? p + 1 : NULL);
+	    }
+	    else
+	    {
+		ret = NULL;
+	    }
+	    break;
+	}
+	a = a->next;
+	am->where = a;
+    }
+    *marker = am;
+    return ret;
+}
+
+int free_address(void **data, void **marker)
+{
+    struct addr_marker *am = (struct addr_marker *) *marker;
+
+    if (*data)
+	parseaddr_free((struct address *) *data);
+    *data = NULL;
+    if (am->freeme) free(am->freeme);
+    free(am);
+    *marker = NULL;
+    return SIEVE_OK;
+}
+
+notify_list_t *new_notify_list(void)    
+{
+    notify_list_t *ret = xmalloc(sizeof(notify_list_t));
+
+    if (ret != NULL) {
+	ret->isactive = 0;
+	ret->id       = NULL;
+	ret->method   = NULL;
+	ret->options  = NULL;
+	ret->priority = NULL;
+	ret->message  = NULL;
+	ret->next     = NULL;
+    }
+    return ret;
+}
+
+void free_notify_list(notify_list_t *n)
+{
+    while (n) {
+	notify_list_t *b = n->next;
+	free(n->options); /* strings live in bytecode, only free the array */
+	free(n);
+	n = b;
+    }
+}
+
+action_list_t *new_action_list(void)
+{
+    action_list_t *ret = xmalloc(sizeof(action_list_t));
+
+    if (ret != NULL) {
+	ret->a = ACTION_NONE;
+	ret->param = NULL;
+	ret->next = NULL;
+    }
+    return ret;
+}
+
+void free_action_list(action_list_t *a)
+{
+    while (a) {
+	action_list_t *b = a->next;
+
+	if(a->a == ACTION_VACATION) {
+	    if(a->u.vac.send.subj) free(a->u.vac.send.subj);
+	    if(a->u.vac.send.addr) free(a->u.vac.send.addr);
+	    if(a->u.vac.send.fromaddr) free(a->u.vac.send.fromaddr);
+	}
+
+	free(a);
+	a = b;
+    }
+}
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/message.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/message.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/message.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/message.h	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,140 @@
+/* message.h
+ * Larry Greenfield
+ * $Id: message.h,v 1.2 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef MESSAGE_H
+#define MESSAGE_H
+
+#include "sieve_interface.h"	/* for action contexts */
+#include "tree.h"		/* for stringlist_t */
+
+typedef struct Action action_list_t;
+
+typedef enum {
+    ACTION_NULL = -1,
+    ACTION_NONE = 0,
+    ACTION_REJECT,
+    ACTION_FILEINTO,
+    ACTION_KEEP,
+    ACTION_REDIRECT,
+    ACTION_DISCARD,
+    ACTION_VACATION,
+    ACTION_SETFLAG,
+    ACTION_ADDFLAG,
+    ACTION_REMOVEFLAG,
+    ACTION_MARK,
+    ACTION_UNMARK,
+    ACTION_NOTIFY,
+    ACTION_DENOTIFY
+} action_t;
+
+/* information */
+action_list_t *new_action_list(void);
+void free_action_list(action_list_t *actions);
+
+/* invariant: always have a dummy element when free_action_list, param
+   and vac_subj are freed.  none of the others are automatically freed.
+
+   the do_action() functions should copy param */
+struct Action {
+    action_t a;
+    union {
+	sieve_reject_context_t rej;
+	sieve_fileinto_context_t fil;
+	sieve_keep_context_t keep;
+	sieve_redirect_context_t red;
+	struct {
+	    /* addr, fromaddr, subj - freed! */
+	    sieve_send_response_context_t send;
+	    sieve_autorespond_context_t autoresp;
+	} vac;
+	struct {
+	    const char *flag;
+	} fla;
+    } u;
+    char *param;		/* freed! */
+    struct Action *next;
+    char *vac_subj;		/* freed! */
+    char *vac_msg;
+    int vac_days;
+};
+
+typedef struct notify_list_s {
+    int isactive;
+    const char *id;
+    const char *method;
+    const char **options;
+    const char *priority;
+    const char *message;
+    struct notify_list_s *next;
+} notify_list_t;
+
+/* header parsing */
+typedef enum {
+    ADDRESS_ALL,
+    ADDRESS_LOCALPART,
+    ADDRESS_DOMAIN,
+    ADDRESS_USER,
+    ADDRESS_DETAIL
+} address_part_t;
+
+int parse_address(const char *header, void **data, void **marker);
+char *get_address(address_part_t addrpart, void **data, void **marker,
+		  int canon_domain);
+int free_address(void **data, void **marker);
+notify_list_t *new_notify_list(void);
+void free_notify_list(notify_list_t *n);
+
+/* actions; return negative on failure.
+ * these don't actually perform the actions, they just add it to the
+ * action list */
+int do_reject(action_list_t *m, const char *msg);
+int do_fileinto(action_list_t *m, const char *mbox,
+		sieve_imapflags_t *imapflags);
+int do_redirect(action_list_t *m, const char *addr);
+int do_keep(action_list_t *m, sieve_imapflags_t *imapflags);
+int do_discard(action_list_t *m);
+int do_vacation(action_list_t *m, char *addr, char *fromaddr,
+		char *subj, const char *msg, int days, int mime);
+int do_setflag(action_list_t *m, const char *flag);
+int do_addflag(action_list_t *m, const char *flag);
+int do_removeflag(action_list_t *m, const char *flag);
+int do_mark(action_list_t *m);
+int do_unmark(action_list_t *m);
+int do_notify(notify_list_t *n, const char *id,
+	      const char *method, const char **options,
+	      const char *priority, const char *message);
+int do_denotify(notify_list_t *n, comparator_t *comp, const void *pat,
+		void *comprock, const char *priority);
+
+/* execute some bytecode */
+int sieve_eval_bc(sieve_interp_t *i, const void *bc_in, unsigned int bc_len,
+		  void *m, sieve_imapflags_t * imapflags,
+		  action_list_t *actions,
+		  notify_list_t *notify_list,
+		  const char **errmsg);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/NEWS dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/NEWS
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/NEWS	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/NEWS	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,84 @@
+$Id: NEWS,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+
+CMU Sieve 2.1
+-------------
+
+- Compliant with RFC 3028.  As a result, fileinto and redirect only
+  accept a single string and NOT a string-list.
+
+- Compliant with draft-martin-sieve-notify-01.  As a result, notify
+  actions will need to be updated to the new syntax.
+
+CMU Sieve 2.0
+-------------
+
+- Compliant with draft-showalter-sieve-11.txt and 
+  draft-showalter-sieve-vacation-03.txt.
+
+- Added support for the regex, imapflags, notify and subaddress extensions.
+  See README for references.
+
+- Verifies email addresses in redirect and vacation actions are syntactically
+  correct (compliant with RFC822).
+
+- Run-time error reporting.
+
+- Changed callback interface to use callback contexts instead of individual
+  parameters.  Also added an error string buffer for run-time error reporting.
+
+- Vacation will not reply to any message containing an "auto-submitted"
+  header containing anything other than "no".
+
+CMU Sieve 1.4
+-------------
+
+Now included with imapd distribution (hell, why not?).
+
+Error returning and recovering:
+	added error recovering to the parser (but not much!)
+	added error messages to the parser
+
+Working on error returning and error recovering.
+	run-time errors
+	detect some errors in lexer?
+
+Working on even better parsing:
+	verify addresses could be addresses
+	verify mailboxes could be mailboxes
+	verify outgoing headers can be headers
+
+CMU Sieve 1.3
+-------------
+
+Changed for integration with cyrus deliver.
+
+CMU Sieve 1.2
+-------------
+
+Added additional callbacks (ok, so I want to make my integration with deliver
+easier) and envelope and vacation support.
+
+Made it compile without libcyrus.
+It should compile without libcyrus, but then it does not implement the
+"address" test.	 That's just too much work to do when I have a neato
+library to do it for me.
+
+Todo:
+- regex matching
+
+CMU Sieve 1.1
+-------------
+
+- Updated to draft-showalter-sieve-07bis.txt
+
+- Simple API (see sieve_interface.h; currently mostly undocumented)
+
+- Implements all of the optional features except "envelope"
+
+- Maintains "if it parses, it probably runs" behavior. (Goal: minimize
+  run-time errors.)
+
+CMU Sieve 1.0
+-------------
+
+- prototype implementation
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/parseaddr.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/parseaddr.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/parseaddr.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/parseaddr.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,370 @@
+/* parseaddr.c -- RFC 822 address parser
+ * $Id: parseaddr.c,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ *
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "parseaddr.h"
+
+#define xmalloc malloc
+#define xstrdup strdup
+
+static char parseaddr_unspecified_domain[] = "unspecified-domain";
+
+static void parseaddr_append (struct address ***addrpp, char *name,
+				char *route, char *mailbox, char *domain,
+				char **freemep);
+static int parseaddr_phrase (char **inp, char **phrasep, char *specials);
+static int parseaddr_domain (char **inp, char **domainp, char **commmentp);
+static int parseaddr_route (char **inp, char **routep);
+
+/*
+ * Parse an address list in 's', appending address structures to
+ * the list pointed to by 'addrp'.
+ */
+void
+parseaddr_list(str, addrp)
+const char *str;
+struct address **addrp;
+{
+    char *s;
+    int ingroup = 0;
+    char *freeme;
+    int tok = ' ';
+    char *phrase, *route, *mailbox, *domain, *comment;
+
+    /* Skip down to the tail */
+    while (*addrp) {
+	addrp = &(*addrp)->next;
+    }
+
+    s = freeme = xstrdup(str);
+
+    while (tok) {
+	tok = parseaddr_phrase(&s, &phrase, ingroup ? ",@<;" : ",@<:");
+	switch (tok) {
+	case ',':
+	case '\0':
+	case ';':
+	    if (*phrase) {
+		parseaddr_append(&addrp, 0, 0, phrase, "", &freeme);
+	    }
+	    if (tok == ';') {
+		parseaddr_append(&addrp, 0, 0, 0, 0, &freeme);
+		ingroup = 0;
+	    }
+	    continue;
+
+	case ':':
+	    parseaddr_append(&addrp, 0, 0, phrase, 0, &freeme);
+	    ingroup++;
+	    continue;
+
+	case '@':
+	    tok = parseaddr_domain(&s, &domain, &comment);
+	    parseaddr_append(&addrp, comment, 0, phrase, domain, &freeme);
+	    continue;
+
+	case '<':
+	    tok = parseaddr_phrase(&s, &mailbox, "@>");
+	    if (tok == '@') {
+		route = 0;
+		if (!*mailbox) {
+		    *--s = '@';
+		    tok = parseaddr_route(&s, &route);
+		    if (tok != ':') {
+			parseaddr_append(&addrp, phrase, route, "", "", &freeme);
+			while (tok && tok != '>') tok = *s++;
+			continue;
+		    }
+		    tok = parseaddr_phrase(&s, &mailbox, "@>");
+		    if (tok != '@') {
+			parseaddr_append(&addrp, phrase, route, mailbox, "",
+					 &freeme);
+			continue;
+		    }
+		}
+		tok = parseaddr_domain(&s, &domain, 0);
+		parseaddr_append(&addrp, phrase, route, mailbox, domain,
+				 &freeme);
+		while (tok && tok != '>') tok = *s++;
+		continue; /* effectively auto-inserts a comma */
+	    }
+	    else {
+		parseaddr_append(&addrp, phrase, 0, mailbox, "", &freeme);
+	    }
+	}
+    }
+    if (ingroup) parseaddr_append(&addrp, 0, 0, 0, 0, &freeme);
+
+    if (freeme) free(freeme);
+}
+
+/*
+ * Free the address list 'addr'
+ */
+void
+parseaddr_free(addr)
+struct address *addr;
+{
+    struct address *next;
+
+    while (addr) {
+	if (addr->freeme) free(addr->freeme);
+	next = addr->next;
+	free((char *)addr);
+	addr = next;
+    }
+}
+
+/*
+ * Helper function to append a new address structure to and address list.
+ */
+static void
+parseaddr_append(addrpp, name, route, mailbox, domain, freemep)
+struct address ***addrpp;
+char *name;
+char *route;
+char *mailbox;
+char *domain;
+char **freemep;
+{
+    struct address *newaddr;
+
+    newaddr = (struct address *)xmalloc(sizeof(struct address));
+    if (name && *name) {
+	newaddr->name = name;
+    }
+    else {
+	newaddr->name = 0;
+    }
+
+    if (route && *route) {
+	newaddr->route = route;
+    }
+    else {
+	newaddr->route = 0;
+    }
+
+    newaddr->mailbox = mailbox;
+
+    if (domain && !*domain) {
+	domain = parseaddr_unspecified_domain;
+    }
+    newaddr->domain = domain;
+
+    newaddr->next = 0;
+    newaddr->freeme = *freemep;
+    *freemep = 0;
+
+    **addrpp = newaddr;
+    *addrpp = &newaddr->next;
+}
+
+/* Macro to skip white space and rfc822 comments */
+
+#define SKIPWHITESPACE(s) \
+{ \
+    int _c, _comment = 0; \
+ \
+    while ((_c = *(s))) { \
+	if (_c == '(') { \
+	    _comment = 1; \
+	    (s)++; \
+	    while ((_comment && (_c = *(s)))) { \
+		(s)++; \
+		if (_c == '\\' && *(s)) (s)++; \
+		else if (_c == '(') _comment++; \
+		else if (_c == ')') _comment--; \
+	    } \
+	    (s)--; \
+	} \
+	else if (!isspace(_c)) break; \
+	(s)++; \
+    } \
+}
+
+/*
+ * Parse an RFC 822 "phrase", stopping at 'specials'
+ */
+static int parseaddr_phrase(inp, phrasep, specials)
+char **inp;
+char **phrasep;
+char *specials;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+
+    SKIPWHITESPACE(src);
+
+    *phrasep = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (c == '\"') {
+	    while ((c = *src)) {
+		src++;
+		if (c == '\"') break;
+		if (c == '\\') {
+		    if (!(c = *src)) break;
+		    src++;
+		}
+		*dst++ = c;
+	    }
+	}
+	else if (isspace(c) || c == '(') {
+	    src--;
+	    SKIPWHITESPACE(src);
+	    *dst++ = ' ';
+	}
+	else if (!c || strchr(specials, c)) {
+	    if (dst > *phrasep && dst[-1] == ' ') dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+	else {
+	    *dst++ = c;
+	}
+    }
+}
+
+/*
+ * Parse a domain.  If 'commentp' is non-nil, parses any trailing comment
+ */
+static int parseaddr_domain(inp, domainp, commentp)
+char **inp;
+char **domainp;
+char **commentp;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+    char *cdst;
+    int comment;
+
+    if (commentp) *commentp = 0;
+    SKIPWHITESPACE(src);
+
+    *domainp = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (isalnum(c) || c == '-' || c == '[' || c == ']' || c == ':') {
+	    *dst++ = c;
+	    if (commentp) *commentp = 0;
+	}
+	else if (c == '.') {
+	    if (dst > *domainp && dst[-1] != '.') *dst++ = c;
+	    if (commentp) *commentp = 0;
+	}
+	else if (c == '(') {
+	    if (commentp) {
+		*commentp = cdst = src;
+		comment = 1;
+		while (comment && (c = *src)) {
+		    src++;
+		    if (c == '(') comment++;
+		    else if (c == ')') comment--;
+		    else if (c == '\\' && (c = *src)) src++;
+
+		    if (comment) *cdst++ = c;
+		}
+		*cdst = '\0';
+	    }
+	    else {
+		src--;
+		SKIPWHITESPACE(src);
+	    }
+	}
+	else if (!isspace(c)) {
+	    if (dst > *domainp && dst[-1] == '.') dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+    }
+}
+	
+/*
+ * Parse a source route (at-domain-list)
+ */
+static int parseaddr_route(inp, routep)
+char **inp;
+char **routep;
+{
+    int c;
+    char *src = *inp;
+    char *dst;
+
+    SKIPWHITESPACE(src);
+
+    *routep = dst = src;
+
+    for (;;) {
+        c = *src++;
+	if (isalnum(c) || c == '-' || c == '[' || c == ']' ||
+	    c == ',' || c == '@') {
+	    *dst++ = c;
+	}
+	else if (c == '.') {
+	    if (dst > *routep && dst[-1] != '.') *dst++ = c;
+	}
+	else if (isspace(c) || c == '(') {
+	    src--;
+	    SKIPWHITESPACE(src);
+	}
+	else {
+	    while (dst > *routep &&
+		   (dst[-1] == '.' || dst[-1] == ',' || dst[-1] == '@')) dst--;
+	    *dst = '\0';
+	    *inp = src;
+	    return c;
+	}
+    }
+}
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/parseaddr.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/parseaddr.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/parseaddr.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/parseaddr.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,69 @@
+/* parseaddr.h -- RFC 822 address parser
+ $Id: parseaddr.h,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *
+ */
+
+#ifndef INCLUDED_PARSEADDR_H
+#define INCLUDED_PARSEADDR_H
+
+#ifndef P
+#ifdef __STDC__
+#define P(x) x
+#else
+#define P(x) ()
+#endif
+#endif
+
+struct address {
+    char *name;
+    char *route;
+    char *mailbox;
+    char *domain;
+    struct address *next;
+    char *freeme;		/* If non-nil, free */
+};
+
+extern void parseaddr_list P((const char *s, struct address **addrp));
+extern void parseaddr_free P((struct address *addr));
+
+
+#endif /* INCLUDED_PARSEADDR_H */
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/README dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/README
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/README	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/README	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,59 @@
+$Id: README,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+
+CMU Sieve 2.1
+-------------
+
+This code is typically distributed as part of Cyrus imapd 1.6 and higher.
+This code will be configured and compiled from the cyrus-imapd directory.
+
+Notes on implementation
+-----------------------
+
+This is an implementation of a simple Sieve API.  This API is
+well-suited for incorporating in other programs, but is not
+extensible.  (If there is interest, we may implement an extensible API
+in the future.)
+
+If you wish to compile Sieve without compiling all of imapd, you'll
+have to create a Makefile for it.  I recommend you use Makefile.in as
+a guide.
+
+It should compile without libcyrus, but then it does not implement the
+"address" test.	 That's just too much work to do when I have a neato
+library to do it for me.
+
+There's a simple "test" application included, which is not built by
+default (type "make test" to build it).  It expects:
+
+test <message> <script>
+
+And prints out the actions taken or errors encountered.  (This
+implementation will attempt all the actions or no actions.)
+
+Questions and comments to:
+Derrick Brashear (shadow+sieve@andrew.cmu.edu)
+
+References:
+
+[SIEVE] Showalter, T., "Sieve: A Mail Filtering Language",
+RFC 3028, January, 2001.
+
+[VACATION] Showalter, T., "Sieve: Vacation Extension",
+draft-showalter-sieve-vacation-04.txt, August, 2000.
+
+[IMAPFLAGS] Melnikov, A., "Sieve -- IMAP flag extension",
+draft-melnikov-sieve-imapflags-03.txt, July, 2000.
+
+[NOTIFY] Martin, T., Segmuller, W.,
+"Sieve -- An extension for providing instant notifications",
+draft-martin-sieve-notify-01.txt, June, 2001.
+
+[REGEX] Murchison, K., "Sieve: Regular Expression Extension",
+draft-murchison-sieve-regex-04.txt, August, 2001.
+
+[RELATIONAL] Segmuller, W., "Sieve Extension: Relational Tests",
+RFC 3431, December 2002.
+
+[SUBADDR] Murchison, K., "Sieve Email Filtering -- Subaddress Extension",
+RFC 3598, September 2003.
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/script.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/script.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/script.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/script.c	2005-10-15 09:31:26.000000000 -0400
@@ -0,0 +1,815 @@
+/* script.c -- sieve script functions
+ * Larry Greenfield
+ * $Id: script.c,v 1.4 2005/10/15 13:31:26 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <syslog.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <assert.h>
+
+#include "xmalloc.h"
+
+#include "md5.h"
+#include "sieve_interface.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+#include "map.h"
+#include "sieve.h"
+#include "message.h"
+#include "bytecode.h"
+
+/* does this interpretor support this requirement? */
+int script_require(sieve_script_t *s, char *req)
+{
+    if (!strcmp("fileinto", req)) {
+	if (s->interp.fileinto) {
+	    s->support.fileinto = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("reject", req)) {
+	if (s->interp.reject) {
+	    s->support.reject = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("envelope", req)) {
+	if (s->interp.getenvelope) {
+	    s->support.envelope = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("vacation", req)) {
+	if (s->interp.vacation) {
+	    s->support.vacation = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("imapflags", req)) {
+	if (s->interp.markflags->flag) {
+	    s->support.imapflags = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+    } else if (!strcmp("notify",req)) {
+	if (s->interp.notify) {
+	    s->support.notify = 1;
+	    return 1;
+	} else {
+	    return 0;
+	}
+#ifdef ENABLE_REGEX
+    } else if (!strcmp("regex", req)) {
+	s->support.regex = 1;
+	return 1;
+#endif
+    } else if (!strcmp("subaddress", req)) {
+	s->support.subaddress = 1;
+	return 1;
+    } else if (!strcmp("relational", req)) {
+	s->support.relational = 1;
+	return 1;
+    } else if (!strcmp("comparator-i;octet", req)) {
+	return 1;
+    } else if (!strcmp("comparator-i;ascii-casemap", req)) {
+	return 1;
+    } else if (!strcmp("comparator-i;ascii-numeric", req)) {
+	s->support.i_ascii_numeric = 1;
+	return 1;
+    }
+    return 0;
+}
+
+/* given an interpretor and a script, produce an executable script */
+int sieve_script_parse(sieve_interp_t *interp, FILE *script,
+		       void *script_context, sieve_script_t **ret)
+{
+    sieve_script_t *s;
+    int res = SIEVE_OK;
+    extern int yylineno;
+
+    res = interp_verify(interp);
+    if (res != SIEVE_OK) {
+	return res;
+    }
+
+    s = (sieve_script_t *) xmalloc(sizeof(sieve_script_t));
+    s->interp = *interp;
+    s->script_context = script_context;
+    /* clear all support bits */
+    memset(&s->support, 0, sizeof(struct sieve_support));
+
+    s->err = 0;
+
+    yylineno = 1;		/* reset line number */
+    s->cmds = sieve_parse(s, script);
+    if (s->err > 0) {
+	if (s->cmds) {
+	    free_tree(s->cmds);
+	}
+	s->cmds = NULL;
+	res = SIEVE_PARSE_ERROR;
+    }
+
+    *ret = s;
+    return res;
+}
+
+static void free_imapflags(sieve_imapflags_t *imapflags)
+{
+    while (imapflags->nflags)
+	free(imapflags->flag[--imapflags->nflags]);
+    free(imapflags->flag);
+    
+    imapflags->flag = NULL;
+}
+  
+int sieve_script_free(sieve_script_t **s)
+{
+    if (*s) {
+	if ((*s)->cmds) {
+	    free_tree((*s)->cmds);
+	}
+	free(*s);
+    }
+
+    return SIEVE_OK;
+}
+ 
+#define GROW_AMOUNT 100
+
+static void add_header(sieve_interp_t *i, int isenv, char *header, 
+		       void *message_context, char **out, 
+		       int *outlen, int *outalloc)
+{
+    const char **h;
+    int addlen;
+    /* get header value */
+    if (isenv)
+	i->getenvelope(message_context, header, &h);	
+    else
+	i->getheader(message_context, header, &h);	
+
+    if (!h || !h[0])
+	return;
+
+    addlen = strlen(h[0]) + 1;
+
+    /* realloc if necessary */
+    if ( (*outlen) + addlen >= *outalloc)
+    {
+	*outalloc = (*outlen) + addlen + GROW_AMOUNT;
+	*out = xrealloc(*out, *outalloc);
+    }
+
+    /* add header value */
+    strcat(*out,h[0]);
+
+    *outlen += addlen;
+}
+
+static int fillin_headers(sieve_interp_t *i, const char *msg, 
+			  void *message_context, char **out, int *outlen)
+{
+    int allocsize = GROW_AMOUNT;
+    const char *c;
+    int n;
+
+    *out = xmalloc(GROW_AMOUNT);
+    *outlen = 0;
+    (*out)[0]='\0';
+
+    if (msg == NULL) return SIEVE_OK;
+
+    /* construct the message */
+    c = msg;
+    while (*c) {
+	/* expand variables */
+	if (!strncasecmp(c, "$from$", 6)) {
+	    add_header(i, 0 ,"From", message_context, out, outlen, &allocsize);
+	    c += 6;
+	}
+	else if (!strncasecmp(c, "$env-from$", 10)) {
+	    add_header(i, 1, "From", message_context, out, outlen, &allocsize);
+	    c += 10;
+	}
+	else if (!strncasecmp(c, "$subject$", 9)) {
+	    add_header(i, 0, "Subject", message_context, out, outlen, &allocsize);
+	    c += 9;
+	}
+	/* XXX need to do $text$ variables */
+	else {
+	    /* find length of plaintext up to next potential variable */
+	    n = strcspn(c+1, "$") + 1; /* skip opening '$' */
+	    /* realloc if necessary */
+	    if ( (*outlen) + n+1 >= allocsize) {
+		allocsize = (*outlen) + n+1 + GROW_AMOUNT;
+		*out = xrealloc(*out, allocsize);
+	    }
+	    /* copy the plaintext */
+	    strncat(*out, c, n);
+	    (*out)[*outlen+n]='\0';
+	    (*outlen) += n;
+	    c += n;
+	}
+    }
+
+    return SIEVE_OK;
+}
+
+static int sieve_addflag(sieve_imapflags_t *imapflags, const char *flag)
+{
+    int n;
+    /* search for flag already in list */
+    for (n = 0; n < imapflags->nflags; n++) {
+	if (!strcmp(imapflags->flag[n], flag))
+	    break;
+    }
+ 
+    /* add flag to list, iff not in list */
+    if (n == imapflags->nflags) {
+	imapflags->nflags++;
+	imapflags->flag =
+	    (char **) xrealloc((char *)imapflags->flag,
+			       imapflags->nflags*sizeof(char *));
+	imapflags->flag[imapflags->nflags-1] = xstrdup(flag);
+    }
+ 
+    return SIEVE_OK;
+}
+
+static int sieve_removeflag(sieve_imapflags_t *imapflags, const char *flag)
+{
+    int n;
+    /* search for flag already in list */
+    for (n = 0; n < imapflags->nflags; n++) {
+      if (!strcmp(imapflags->flag[n], flag))
+	break;
+    }
+    
+     /* remove flag from list, iff in list */
+    if (n < imapflags->nflags) 
+      {
+	free(imapflags->flag[n]);
+	imapflags->nflags--;
+	
+	for (; n < imapflags->nflags; n++)
+	  imapflags->flag[n] = imapflags->flag[n+1];
+	
+	if (imapflags->nflags)
+	  {imapflags->flag =
+	     (char **) xrealloc((char *)imapflags->flag,
+				imapflags->nflags*sizeof(char *));}
+	else
+	  {free(imapflags->flag);
+	  imapflags->flag=NULL;}
+      }
+    
+    return SIEVE_OK;
+}
+
+static int send_notify_callback(sieve_interp_t *interp, void *message_context, 
+				void * script_context, notify_list_t *notify, 
+				char *actions_string, const char **errmsg)
+{
+    sieve_notify_context_t nc;
+    char *out_msg, *build_msg;
+    int out_msglen;    
+    int ret;
+
+    assert(notify->isactive);
+
+    if (!notify->method || !notify->options ||
+	!notify->priority || !notify->message) {
+	return SIEVE_RUN_ERROR;
+    }
+
+    nc.method = notify->method;
+    nc.options = notify->options ? notify->options : NULL;
+    nc.priority = notify->priority;
+
+    fillin_headers(interp, notify->message, message_context, 
+		   &out_msg, &out_msglen);
+
+    build_msg = xmalloc(out_msglen + strlen(actions_string) + 30);
+
+    strcpy(build_msg, out_msg);
+    strcat(build_msg, "\n\n");
+    strcat(build_msg, actions_string);
+
+    nc.message = build_msg;
+
+    free(out_msg);
+
+    ret = interp->notify(&nc,
+			 interp->interp_context,
+			 script_context,
+			 message_context,
+			 errmsg);    
+
+    free(build_msg);
+
+    return ret;
+}
+
+static char *action_to_string(action_t action)
+{
+    switch(action)
+	{
+	case ACTION_REJECT: return "Reject";
+	case ACTION_FILEINTO: return "Fileinto";
+	case ACTION_KEEP: return "Keep";
+	case ACTION_REDIRECT: return "Redirect";
+	case ACTION_DISCARD: return "Discard";
+	case ACTION_VACATION: return "Vacation";
+	case ACTION_SETFLAG: return "Setflag";
+	case ACTION_ADDFLAG: return "Addflag";
+	case ACTION_REMOVEFLAG: return "Removeflag";
+	case ACTION_MARK: return "Mark";
+	case ACTION_UNMARK: return "Unmark";
+	case ACTION_NOTIFY: return "Notify";
+	case ACTION_DENOTIFY: return "Denotify";
+	default: return "Unknown";
+	}
+
+    return "Error!";
+}
+
+static char *sieve_errstr(int code)
+{
+    switch (code)
+	{
+	case SIEVE_FAIL: return "Generic Error";
+	case SIEVE_NOT_FINALIZED: return "Sieve not finalized";
+	case SIEVE_PARSE_ERROR: return "Parse error";
+	case SIEVE_RUN_ERROR: return "Run error";
+	case SIEVE_INTERNAL_ERROR: return "Internal Error";
+	case SIEVE_NOMEM: return "No memory";
+	default: return "Unknown error";
+	}
+
+    return "Error!";
+}
+
+#define HASHSIZE 16
+
+static int makehash(unsigned char hash[HASHSIZE],
+		    const char *s1, const char *s2)
+{
+    struct md5_context ctx;
+
+    md5_init(&ctx);
+    md5_update(&ctx, s1, strlen(s1));
+    md5_update(&ctx, s2, strlen(s2));
+    md5_final(&ctx, hash);
+
+    return SIEVE_OK;
+}
+
+
+/******************************bytecode functions*****************************
+ *****************************************************************************/
+
+/* Load a compiled script */
+int sieve_script_load(const char *fname, sieve_bytecode_t **ret) 
+{
+    struct stat sbuf;
+    sieve_bytecode_t *r;
+    int fd;
+   
+    if (!fname || !ret) return SIEVE_FAIL;
+    
+    fd = open(fname, O_RDONLY);
+    if (fd == -1) {
+	if (errno != ENOENT)
+	    i_error("IOERROR: can not open sieve script %s: %m", fname);
+	return SIEVE_FAIL;
+    }
+
+    if (fstat(fd, &sbuf) == -1) {
+	i_error("IOERROR: fstating sieve script %s: %m", fname);
+	close(fd);
+	return SIEVE_FAIL;
+    }
+
+    r = (sieve_bytecode_t *) xzmalloc(sizeof(sieve_bytecode_t));
+
+    r->fd = fd;
+    
+    map_refresh(fd, 1, &r->data, &r->len, sbuf.st_size, fname, "sievescript");
+
+    if ((r->len < (BYTECODE_MAGIC_LEN + 2*sizeof(bytecode_input_t))) ||
+	memcmp(r->data, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	i_error("IOERROR: not a sieve bytecode file %s", fname);
+	sieve_script_unload(&r);
+	return SIEVE_FAIL;
+    }
+
+    *ret = r;
+    return SIEVE_OK;
+}
+
+
+
+int sieve_script_unload(sieve_bytecode_t **s) 
+{
+    if(s && *s) {
+	map_free(&((*s)->data), &((*s)->len));
+	close((*s)->fd);
+	free(*s);
+	*s = NULL;
+    } 
+    /*i added this else, i'm not sure why, but this function always returned SIEVE_FAIL*/
+    else
+      return SIEVE_FAIL;
+    return SIEVE_OK;
+}
+
+
+#define ACTIONS_STRING_LEN 4096
+
+static int do_sieve_error(int ret,
+			  sieve_interp_t *interp,
+			  void *script_context,
+			  void *message_context,
+			  sieve_imapflags_t * imapflags,
+			  action_list_t *actions,
+			  notify_list_t *notify_list,
+			  /* notify_action_t *notify_action,*/
+			  int lastaction,
+			  int implicit_keep,
+			  char *actions_string,
+			  const char *errmsg
+			  ) 
+{
+   if (ret != SIEVE_OK) {
+	if (lastaction == -1) /* we never executed an action */
+	    snprintf(actions_string+strlen(actions_string),
+		     ACTIONS_STRING_LEN-strlen(actions_string),
+		     "script execution failed: %s\n",
+		     errmsg ? errmsg : sieve_errstr(ret));
+	else
+	    snprintf(actions_string+strlen(actions_string),
+		     ACTIONS_STRING_LEN-strlen(actions_string),
+		     "%s action failed: %s\n",
+		     action_to_string(lastaction),
+		     errmsg ? errmsg : sieve_errstr(ret));
+    }
+ 
+   
+    /* Process notify actions */
+    if (interp->notify && notify_list) 
+      {
+	notify_list_t *n = notify_list;
+	int notify_ret = SIEVE_OK;
+	
+	while (n != NULL) 
+	  {
+	    if (n->isactive) 
+	      {
+	      lastaction = ACTION_NOTIFY;
+	       notify_ret = send_notify_callback(interp, message_context, 
+						script_context,n,
+						actions_string, &errmsg);
+	      ret |= notify_ret;
+	      }
+	    n = n->next;
+	  }
+	
+	if (notify_list) free_notify_list(notify_list);
+	notify_list = NULL;	/* don't try any notifications again */
+	
+	
+	if (notify_ret != SIEVE_OK) 
+	  return do_sieve_error(ret, interp, script_context, message_context,
+				imapflags, actions, notify_list, lastaction,
+				implicit_keep, actions_string, errmsg);
+      
+      }
+    
+    if ((ret != SIEVE_OK) && interp->err) {
+	char buf[1024];
+	if (lastaction == -1) /* we never executed an action */
+	    sprintf(buf, "%s", errmsg ? errmsg : sieve_errstr(ret));
+	else
+	    sprintf(buf, "%s: %s", action_to_string(lastaction),
+		    errmsg ? errmsg : sieve_errstr(ret));
+ 
+	ret |= interp->execute_err(buf, interp->interp_context,
+				   script_context, message_context);
+    }
+
+    if (implicit_keep) {
+	sieve_keep_context_t keep_context;
+	int keep_ret;
+	keep_context.imapflags = imapflags;
+ 
+	lastaction = ACTION_KEEP;
+	keep_ret = interp->keep(&keep_context, interp->interp_context,
+				script_context, message_context, &errmsg);
+	ret |= keep_ret;
+        if (keep_ret == SIEVE_OK)
+            snprintf(actions_string+strlen(actions_string),
+		     sizeof(actions_string)-strlen(actions_string),
+		     "Kept\n");
+	else {
+	    implicit_keep = 0;	/* don't try an implicit keep again */
+	    return do_sieve_error(ret, interp, script_context, message_context,
+				  imapflags, actions, notify_list, lastaction,
+				  implicit_keep, actions_string, errmsg);
+	}
+    }
+
+    if (actions)
+	free_action_list(actions);
+
+    return ret;
+}
+
+
+static int do_action_list(sieve_interp_t *interp,
+			  void *script_context,
+			  void *message_context,
+			  sieve_imapflags_t *imapflags,
+			  action_list_t *actions,
+			  notify_list_t *notify_list,
+			  /* notify_action_t *notify_action,*/
+			  char *actions_string,
+			  const char *errmsg) 
+{
+    action_list_t *a;
+    action_t lastaction = -1;
+    int ret = 0;
+    int implicit_keep = 0;
+    
+    strcpy(actions_string,"Action(s) taken:\n");
+  
+    /* now perform actions attached to m */
+    a = actions;
+    implicit_keep = 1;
+    while (a != NULL) {
+	lastaction = a->a;
+	errmsg = NULL;
+	switch (a->a) {
+	case ACTION_REJECT:
+	    implicit_keep = 0;
+	    if (!interp->reject)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->reject(&a->u.rej,
+				 interp->interp_context,
+				 script_context,
+				 message_context,
+				 &errmsg);
+	    
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string), 
+			 "Rejected with: %s\n", a->u.rej.msg);
+
+	    break;
+	case ACTION_FILEINTO:
+	    implicit_keep = 0;
+	    if (!interp->fileinto)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->fileinto(&a->u.fil,
+				   interp->interp_context,
+				   script_context,
+				   message_context,
+				   &errmsg);
+
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Filed into: %s\n",a->u.fil.mailbox);
+	    break;
+	case ACTION_KEEP:
+	    implicit_keep = 0;
+	    if (!interp->keep)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->keep(&a->u.keep,
+			       interp->interp_context,
+			       script_context,
+			       message_context,
+			       &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Kept\n");
+	    break;
+	case ACTION_REDIRECT:
+	    implicit_keep = 0;
+	    if (!interp->redirect)
+		return SIEVE_INTERNAL_ERROR;
+	    ret = interp->redirect(&a->u.red,
+				   interp->interp_context,
+				   script_context,
+				   message_context,
+				   &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Redirected to %s\n", a->u.red.addr);
+	    break;
+	case ACTION_DISCARD:
+	    implicit_keep = 0;
+	    if (interp->discard) /* discard is optional */
+		ret = interp->discard(NULL, interp->interp_context,
+				      script_context,
+				      message_context,
+				      &errmsg);
+	    if (ret == SIEVE_OK)
+		snprintf(actions_string+strlen(actions_string),
+			 sizeof(actions_string)-strlen(actions_string),
+			 "Discarded\n");
+	    break;
+
+	case ACTION_VACATION:
+	    {
+		unsigned char hash[HASHSIZE];
+
+		if (!interp->vacation)
+		    return SIEVE_INTERNAL_ERROR;
+
+		/* first, let's figure out if we should respond to this */
+		ret = makehash(hash, a->u.vac.send.addr,
+			       a->u.vac.send.msg);
+
+		if (ret == SIEVE_OK) {
+		    a->u.vac.autoresp.hash = hash;
+		    a->u.vac.autoresp.len = HASHSIZE;
+		    ret = interp->vacation->autorespond(&a->u.vac.autoresp,
+							interp->interp_context,
+							script_context,
+							message_context,
+							&errmsg);
+		}
+		if (ret == SIEVE_OK) {
+		    /* send the response */
+		    ret = interp->vacation->send_response(&a->u.vac.send,
+							  interp->interp_context,
+							  script_context, 
+							  message_context,
+							  &errmsg);
+
+		    if (ret == SIEVE_OK)
+			snprintf(actions_string+strlen(actions_string),
+				 sizeof(actions_string)-strlen(actions_string),
+				 "Sent vacation reply\n");
+
+		} else if (ret == SIEVE_DONE) {
+		    snprintf(actions_string+strlen(actions_string),
+			     sizeof(actions_string)-strlen(actions_string),
+			     "Vacation reply suppressed\n");
+
+		    ret = SIEVE_OK;
+		}
+	    
+		break;
+	    }
+
+ 
+	case ACTION_SETFLAG:
+	    free_imapflags(imapflags);
+	    ret = sieve_addflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_ADDFLAG:
+	    ret = sieve_addflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_REMOVEFLAG:
+	    ret = sieve_removeflag(imapflags, a->u.fla.flag);
+	    break;
+	case ACTION_MARK:
+	    {
+		int n = interp->markflags->nflags;
+
+		ret = SIEVE_OK;
+		while (n && ret == SIEVE_OK) {
+		    ret = sieve_addflag(imapflags,
+					interp->markflags->flag[--n]);
+		}
+		break;
+	    }
+	case ACTION_UNMARK:
+	  {
+	   
+		int n = interp->markflags->nflags;
+		ret = SIEVE_OK;
+		while (n && ret == SIEVE_OK) {
+		    ret = sieve_removeflag(imapflags,
+					   interp->markflags->flag[--n]);
+		}
+		break;
+	    }
+
+	case ACTION_NONE:
+	    break;
+
+	default:
+	    ret = SIEVE_INTERNAL_ERROR;
+	    break;
+	}
+	a = a->next;
+
+	if (ret != SIEVE_OK) {
+	    /* uh oh! better bail! */
+	    break;
+	}
+    }
+
+    return do_sieve_error(ret, interp, script_context, message_context, 
+			  imapflags, actions, notify_list, lastaction, 
+			  implicit_keep, actions_string, errmsg);
+}
+
+
+int sieve_execute_bytecode(sieve_bytecode_t *bc, sieve_interp_t *interp,
+			   void *script_context, void *message_context) 
+{
+    action_list_t *actions = NULL;
+    notify_list_t *notify_list = NULL;
+    /*   notify_action_t *notify_action;*/
+    action_t lastaction = -1;
+    int ret;
+    char actions_string[ACTIONS_STRING_LEN] = "";
+    const char *errmsg = NULL;
+    sieve_imapflags_t imapflags;
+    
+    if (!interp) return SIEVE_FAIL;
+
+    imapflags.flag = NULL; 
+    imapflags.nflags = 0;
+    
+    if (interp->notify)
+    {
+	notify_list = new_notify_list();
+	if (notify_list == NULL)
+	    {
+		ret = SIEVE_NOMEM;
+		return do_sieve_error(ret, interp, script_context,
+				      message_context, &imapflags,
+				      actions, notify_list, lastaction, 0,
+				      actions_string, errmsg);
+	    }
+    }
+
+    actions = new_action_list();
+    if (actions == NULL) 
+    {
+	ret = SIEVE_NOMEM;
+	return do_sieve_error(ret, interp, script_context,
+			      message_context, &imapflags,
+			      actions, notify_list, lastaction, 0,
+			      actions_string, errmsg);
+    }
+    
+    if (sieve_eval_bc(interp, bc->data, bc->len, message_context, 
+		      &imapflags, actions, notify_list, &errmsg) < 0)
+    {
+	ret = SIEVE_RUN_ERROR;
+	return do_sieve_error(ret, interp, script_context,
+			      message_context, &imapflags,
+			      actions, notify_list, lastaction, 0,
+			      actions_string, errmsg);
+    }
+    
+    return do_action_list(interp, script_context, message_context, 
+			  &imapflags, actions, notify_list, actions_string,
+			  errmsg);
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/script.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/script.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/script.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/script.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,74 @@
+/* script.h -- script definition
+ * Larry Greenfield
+ * $Id: script.h,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef SIEVE_SCRIPT_H
+#define SIEVE_SCRIPT_H
+
+#include "sieve_interface.h"
+#include "interp.h"
+#include "tree.h"
+
+#define ADDRERR_SIZE 500
+
+struct sieve_script {
+    sieve_interp_t interp;
+
+    /* was a "require" done for these? */
+    struct sieve_support {
+	int fileinto       : 1;
+	int reject         : 1;
+	int envelope       : 1;
+	int vacation       : 1;
+	int imapflags      : 1;
+	int notify         : 1;
+	int regex          : 1;
+	int subaddress     : 1;
+	int relational     : 1;
+	int i_ascii_numeric: 1;
+    } support;
+
+    void *script_context;
+    commandlist_t *cmds;
+
+    int err;
+};
+
+struct sieve_bytecode
+{
+    sieve_interp_t *interp;
+    void *script_context;
+
+    const char *data;
+    unsigned long len;
+    int fd;
+};
+
+/* generated by the yacc script */
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f);
+int script_require(sieve_script_t *s, char *req);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sievec.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sievec.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sievec.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sievec.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,288 @@
+/* sievec.c -- compile a sieve script to bytecode manually
+ * Rob Siemborski
+ * $Id: sievec.c,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/*
+ * Copyright (c) 1999-2000 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "sieve_interface.h"
+#include <syslog.h>
+
+#include "libconfig.h"
+#include "xmalloc.h"
+
+#include "script.h"
+#include <string.h> 
+#include <stdlib.h>
+#include <sys/file.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+/* config.c stuff */
+const int config_need_data = 0;
+
+int is_script_parsable(FILE *stream, char **errstr, sieve_script_t **ret);
+
+#define TIMSIEVE_FAIL -1
+#define TIMSIEVE_OK 0
+
+int main(int argc, char **argv) 
+{
+    FILE *instream;
+    char *err = NULL;
+    sieve_script_t *s;
+    bytecode_info_t *bc;
+    int c, fd, usage_error = 0;
+    char *alt_config = NULL;
+
+    while ((c = getopt(argc, argv, "C:")) != EOF)
+	switch (c) {
+	case 'C': /* alt config file */
+	    alt_config = optarg;
+	    break;
+	default:
+	    usage_error = 1;
+	    break;
+	}
+
+    if (usage_error || (argc - optind) < 2) {
+	printf("Syntax: %s [-C <altconfig>] <filename> <outputfile>\n",
+	       argv[0]);
+	exit(1);
+    }
+
+    instream = fopen(argv[optind++],"r");
+    if(instream == NULL) {
+	printf("Unable to open %s for reading\n", argv[1]);
+	exit(1);
+    }
+    
+    /* Load configuration file. */
+    config_read(alt_config);
+
+    if(is_script_parsable(instream, &err, &s) == TIMSIEVE_FAIL) {
+	if(err) {
+	    printf("Unable to parse script: %s\n", err);
+	} else {
+	    printf("Unable to parse script.\n");
+	}
+	 
+	exit(1);
+    }
+    
+    /* Now, generate the bytecode */
+    if(sieve_generate_bytecode(&bc, s) == -1) {
+	printf("bytecode generate failed\n");
+	exit(1);
+    }
+
+    /* Now, open the new file */
+    fd = open(argv[optind], O_CREAT | O_TRUNC | O_WRONLY, 0644);
+    if(fd < 0) {
+	printf("couldn't open bytecode output file\n");
+	exit(1);
+    }  
+
+    /* Now, emit the bytecode */
+    if(sieve_emit_bytecode(fd, bc) == -1) {
+	printf("bytecode emit failed\n");
+	exit(1);
+    }
+
+    close(fd);
+    
+    return 0;
+}
+
+/* to make larry's stupid functions happy :) */ 
+void foo(void)
+{
+    fatal("stub function called", 0);
+}
+sieve_vacation_t vacation = {
+    0,				/* min response */
+    0,				/* max response */
+    (sieve_callback *) &foo,	/* autorespond() */
+    (sieve_callback *) &foo	/* send_response() */
+};
+
+static int sieve_notify(void *ac __attribute__((unused)), 
+			void *interp_context __attribute__((unused)), 
+			void *script_context __attribute__((unused)),
+			void *message_context __attribute__((unused)),
+			const char **errmsg __attribute__((unused)))
+{
+    fatal("stub function called", 0);
+    return SIEVE_FAIL;
+}
+
+int mysieve_error(int lineno, const char *msg,
+		  void *i __attribute__((unused)), void *s)
+{
+    char buf[1024];
+    char **errstr = (char **) s;
+
+    snprintf(buf, 80, "line %d: %s\r\n", lineno, msg);
+    *errstr = xrealloc(*errstr, strlen(*errstr) + strlen(buf) + 30);
+    syslog(LOG_DEBUG, "%s", buf);
+    strcat(*errstr, buf);
+
+    return SIEVE_OK;
+}
+
+void fatal(const char *s, int code)
+{  
+    printf("Fatal error: %s (%d)\r\n", s, code);
+                           
+    exit(1);
+}
+/* end the boilerplate */
+
+/* returns TRUE or FALSE */
+int is_script_parsable(FILE *stream, char **errstr, sieve_script_t **ret)
+{
+    sieve_interp_t *i;
+    sieve_script_t *s;
+    int res;
+  
+    res = sieve_interp_alloc(&i, NULL);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_interp_alloc() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_redirect(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_redirect() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_discard(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_discard() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_reject(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_reject() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_fileinto(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_fileinto() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+    res = sieve_register_keep(i, (sieve_callback *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_keep() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_imapflags(i, NULL);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_imapflags() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_size(i, (sieve_get_size *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_size() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_header(i, (sieve_get_header *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_header() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_envelope(i, (sieve_get_envelope *) &foo);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_envelope() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+  
+    res = sieve_register_vacation(i, &vacation);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_vacation() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_notify(i, &sieve_notify);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_notify() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    res = sieve_register_parse_error(i, &mysieve_error);
+    if (res != SIEVE_OK) {
+	syslog(LOG_ERR, "sieve_register_parse_error() returns %d\n", res);
+	return TIMSIEVE_FAIL;
+    }
+
+    rewind(stream);
+
+    *errstr = (char *) xmalloc(20 * sizeof(char));
+    strcpy(*errstr, "script errors:\r\n");
+
+    res = sieve_script_parse(i, stream, errstr, &s);
+
+    if (res == SIEVE_OK) {
+	if(ret) {
+	    *ret = s;
+	} else {
+	    sieve_script_free(&s);
+	}
+	free(*errstr);
+	*errstr = NULL;
+    }
+
+    /* free interpreter */
+    sieve_interp_free(&i);
+
+    return (res == SIEVE_OK) ? TIMSIEVE_OK : TIMSIEVE_FAIL;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieved.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieved.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieved.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieved.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,447 @@
+/* dump.c -- bytecode decompiler
+ * Jen Smith
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*****************************************************************/
+
+
+
+#include "sieve_interface.h"
+
+#include "bytecode.h"
+#include "script.h"
+
+#include "xmalloc.h"
+#include <sys/types.h> 
+#include <sys/stat.h>
+#include <fcntl.h> 
+#include <unistd.h> 
+#include <netinet/in.h>
+
+#include <string.h>
+
+#include "map.h"
+
+void dump2(bytecode_input_t *d, int len);
+int dump2_test(bytecode_input_t * d, int i);
+ 
+/* from bc_eval.c */
+int unwrap_string(bytecode_input_t *bc, int pos, const char **str, int *len);
+
+/*this is called by xmalloc*/
+void fatal(const char *s, int code)
+{  
+    printf("Fatal error: %s (%d)\r\n", s, code);
+                           
+    exit(1);
+}
+
+int load(int fd, bytecode_input_t ** d)
+{  
+    const char * data=NULL;
+    struct stat sbuf;
+    unsigned long len=0;
+    
+    if (fstat(fd, &sbuf) == -1) {
+	printf("IOERROR: fstating sieve script: %m");
+	return SIEVE_FAIL;
+    }
+    
+    /*this reads in data and length from file*/
+    map_refresh(fd, 1, &(data), &len, sbuf.st_size,
+		"sievescript", "");
+    *d=(bytecode_input_t *)data;
+    
+    printf("\n");
+    
+    return (len/sizeof(int));
+}
+
+
+int main(int argc, char * argv[])
+{
+    bytecode_input_t * bc;
+    int script_fd;
+    
+    unsigned long len;
+    
+    if (argc!=2) {
+	 fprintf(stderr, "usage:\n %s script\n", argv[0]);
+	 exit(1);
+    }
+
+    /*get script*/
+    script_fd = open(argv[1], O_RDONLY);
+    if (script_fd == -1) 
+    {
+	printf("can not open script '%s'\n", argv[1]);
+	exit(1);
+    }
+    
+    len=load(script_fd,&bc);
+    close(script_fd);
+    
+    if (bc) {
+	dump2(bc, len );
+	exit(0);
+    } else {
+	exit(1);
+    }
+}
+
+int write_list(int list_len, int i, bytecode_input_t * d)
+{
+    int x;
+    i++;
+    for (x=0; x<list_len; x++)
+    {
+	const char *data;
+	int len;
+	
+	i = unwrap_string(d, i, &data, &len);
+	
+	printf("{%d}%s\n", len, data);
+    }
+    return i;
+}
+
+int printComparison(bytecode_input_t *d ,int i)
+{
+    printf("Comparison: ");
+    switch(ntohl(d[i].value))
+    {
+    case B_IS: printf("Is"); break;
+    case B_CONTAINS:printf("Contains"); break;
+    case B_MATCHES: printf("Matches"); break;
+    case B_REGEX: printf("Regex"); break;
+    case B_COUNT:
+	printf("Count");
+	
+	switch(ntohl(d[i+1].value))
+	{
+	case B_GT: printf(" greater than "); break;   
+	case B_GE: printf(" greater than or equal "); break;
+	case B_LT: printf(" less than "); break;
+	case B_LE: printf(" less than or equal "); break;
+	case B_NE: printf(" not equal "); break;
+	case B_EQ: printf(" equal "); break;
+	}
+
+	break;
+    case B_VALUE:
+	printf("Value");
+	
+	switch(ntohl(d[i+1].value))
+	{
+	case B_GT: printf(" greater than "); break;   
+	case B_GE: printf(" greater than or equal ");break;
+	case B_LT: printf(" less than ");    break;
+	case B_LE: printf(" less than or equal ");break;
+	case B_NE: printf(" not equal ");    break;
+	case B_EQ: printf(" equal ");break;
+	}
+	
+	break;
+    default:
+	exit(1);
+    }
+
+    switch (ntohl(d[i+2].value))
+    {
+    case B_ASCIICASEMAP: printf("   (ascii-casemap) "); break;
+    case B_OCTET: printf("    (octet) "); break;
+    case B_ASCIINUMERIC:  printf("   (ascii-numeric) "); break;
+    default: exit(1);
+    }
+    
+    printf("\n");
+    return i+3;
+}
+
+
+int dump2_test(bytecode_input_t * d, int i)
+{
+    int l,x;
+    switch(ntohl(d[i].value)) {
+    case BC_FALSE:
+	printf("false");
+	i++;
+	break;
+    case BC_TRUE:
+	printf("true");
+	i++;
+	break;
+    case BC_NOT:/*2*/
+	/* XXX 
+	   there is a value being skipped in the second pass...
+	   no idea what it does, but it isn't carried to here...
+	   see bytecodee.c */
+	printf(" not(");
+	i=dump2_test(d, i+1);
+	printf(")\n");
+	break;
+    case BC_EXISTS:
+	printf("exists");
+	i=write_list(ntohl(d[i+1].len), i+2, d);
+	break;
+    case BC_SIZE:
+	printf("size");
+	if (ntohl(d[i+1].value)==B_OVER) {
+	    /* over */
+	    printf("over %d", ntohl(d[i+2].value));
+	} else {
+	    /* under */
+	    printf("under %d", ntohl(d[i+2].value));
+	}
+	i+=3;
+	break;
+    case BC_ANYOF:/*5*/
+	printf("any of \n(");
+	l=ntohl(d[i+1].len);
+	i+=3;
+	
+	for (x=0; x<l; x++)
+	{
+	    i=dump2_test(d,i);
+	    if((x+1)<l)
+		printf(" OR ");
+	}
+	
+	printf(")\n");	 
+	break;
+    case BC_ALLOF:/*6*/
+	printf("all of \n(");
+	l=ntohl(d[i+1].len);
+	i+=3;
+	
+	for (x=0; x<l; x++)
+	{
+	    i=dump2_test(d,i);
+	    if((x+1)<l)
+		printf(" AND ");
+	}
+	
+	printf(")\n");
+	break;
+    case BC_ADDRESS:/*7*/
+	printf("Address (");
+	i=printComparison(d, i+1);
+	printf("               type: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_ALL: printf("all"); break;
+	case B_LOCALPART:printf("localpart"); break;
+	case B_DOMAIN:printf("domain"); break;
+	case B_USER:printf("user"); break;
+	case B_DETAIL:printf("detail"); break;
+	}
+	printf("              Headers:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_ENVELOPE:/*8*/
+	printf("Envelope (");
+	i=printComparison(d, i+1);
+	printf("                type: ");
+	switch(ntohl(d[i++].value))
+	{
+	case B_ALL: printf("all"); break;
+	case B_LOCALPART:printf("localpart"); break;
+	case B_DOMAIN:printf("domain"); break;
+	case B_USER:printf("user"); break;
+	case B_DETAIL:printf("detail"); break;
+	}
+	printf("              Headers:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data:");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    case BC_HEADER:/*9*/
+	printf("Header [");
+	i= printComparison(d, i+1);
+	printf("              Headers: ");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("              Data: ");
+	i=write_list(ntohl(d[i].len), i+1, d);
+	printf("             ]\n");
+	break;
+    default:
+	printf("WERT %d ", ntohl(d[i].value));
+    }   
+    return i;
+}
+
+void dump2(bytecode_input_t *d, int bc_len) 
+{
+    int i;
+    const char *data;
+    int len;
+    
+    if(memcmp(d, BYTECODE_MAGIC, BYTECODE_MAGIC_LEN)) {
+	printf("not a bytecode file [magic number test failed]\n");
+	return;
+    }
+
+    i = BYTECODE_MAGIC_LEN / sizeof(bytecode_input_t);
+
+    printf("Sievecode version %d\n", ntohl(d[i].op));
+    if(!d) return;
+    
+    for(i++; i<bc_len;) 
+    {
+	switch(ntohl(d[i].op)) {
+	    
+	case B_STOP:/*0*/
+	    printf("%d: STOP\n",i);
+	    i++;
+	    break;
+	    
+	case B_KEEP:/*1*/
+	    printf("%d: KEEP\n",i);
+	    i++;
+	    break;
+	    
+	case B_DISCARD:/*2*/
+	    printf("%d: DISCARD\n",i);
+	    i++;
+	    break;
+	    
+	case B_REJECT:/*3*/
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf("%d: REJECT {%d}%s\n", i, len, data);
+	    break;
+
+	case B_FILEINTO: /*4*/
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf("%d: FILEINTO {%d}%s\n",i, len, data);
+	    break;
+
+	case B_REDIRECT: /*5*/
+	    i = unwrap_string(d, i+1, &data, &len);
+	    printf("%d: REDIRECT {%d}%s\n",i,len,data);
+	    break;
+	     
+	case B_IF:/*6*/
+	    printf("%d: IF (ends at %d)",i, ntohl(d[i+1].value));
+
+            /* there is no short circuiting involved here*/
+	    i = dump2_test(d,i+2);
+	    printf("\n");
+
+	    break;
+
+	case B_MARK:/*7*/
+	    printf("%d: MARK\n",i);
+	    i++;
+	    break;
+
+	case B_UNMARK:/*8*/
+	    printf("%d: UNMARK\n",i);
+	    i++;
+	    break;
+
+	case B_ADDFLAG: /*9*/
+	    printf("%d: ADDFLAG  {%d}\n",i,ntohl(d[i+1].len));
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+	    break;
+
+	case B_SETFLAG: /*10*/
+	    printf("%d: SETFLAG  {%d}\n",i,ntohl(d[i+1].len));
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+	    break;
+	    
+	case B_REMOVEFLAG: /*11*/
+	    printf("%d: REMOVEFLAG  {%d}\n",i,ntohl(d[i+1].len));
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+	    break;
+	    
+	case B_DENOTIFY:/*12*/
+	    printf("%d: DENOTIFY\n",i);
+	    i++; 
+	    printf("            PRIORITY(%d) Comparison type %d (relat %d)\n",
+		   ntohl(d[i].value), ntohl(d[i+1].value), ntohl(d[i+2].value));
+	    i+=3;
+
+	    i = unwrap_string(d, i+1, &data, &len);
+	    
+	    printf("           ({%d}%s)\n", len, (!data ? "[nil]" : data));
+	    break;
+	    
+	case B_NOTIFY: /*13*/
+	    i = unwrap_string(d, i+1, &data, &len);
+
+	    printf("%d: NOTIFY METHOD({%d}%s)\n",i,len,data);
+
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("            ID({%d}%s) OPTIONS ", len,
+		   (!data ? "[nil]" : data));
+
+	    i=write_list(ntohl(d[i].len),i+1,d);
+	    
+	    printf("            PRIORITY(%d)\n", ntohl(d[i].value));
+      	    i++;
+		  
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("            MESSAGE({%d}%s)\n", len, data);
+
+	    break;
+
+	case B_VACATION:/*14*/
+	    printf("%d: VACATION\n",i);
+	    /*add address list here!*/
+	    i=write_list(ntohl(d[i+1].len),i+2,d);
+
+	    i = unwrap_string(d, i, &data, &len);
+	  
+	    printf("%d SUBJ({%d}%s) \n",i, len, (!data ? "[nil]" : data));
+	    
+	    i = unwrap_string(d, i, &data, &len);
+
+	    printf("%d MESG({%d}%s) \n", i, len, (!data ? "[nil]" : data));
+
+	    printf("DAYS(%d) MIME(%d)\n", ntohl(d[i].value), ntohl(d[i+1].value));
+	    i+=2;
+
+	    break;
+	case B_NULL:/*15*/
+	    printf("%d:NULL\n",i);
+	    i++;
+	    break;
+	case B_JUMP:/*16*/
+	    printf("%d:JUMP %d\n",i, ntohl(d[i+1].jump));
+	    i+=2;
+	    break;		  
+	default:
+	    printf("%d: %d (NOT AN OP)\n",i,ntohl(d[i].op));
+	    exit(1);
+	}
+    }
+    printf("full len is: %d\n", bc_len);
+}
+
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_err.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_err.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_err.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_err.c	2005-03-29 13:42:51.000000000 -0500
@@ -0,0 +1,60 @@
+/*
+ * sieve_err.c:
+ * This file is automatically generated; please do not edit it.
+ */
+
+#include <stdlib.h>
+
+static const char * const text[] = {
+	   "Generic Sieve error",
+	   "Sieve interpretor not finalized",
+	   "Parse error in Sieve script",
+	   "Run-time error during Sieve execution",
+	   "Internal error in Sieve subsystem",
+	   "Memory exhausted in Sieve subsystem",
+	   "Sieve action already taken",
+    0
+};
+
+struct error_table {
+    char const * const * msgs;
+    long base;
+    int n_msgs;
+};
+struct et_list {
+    struct et_list *next;
+    const struct error_table * table;
+};
+extern struct et_list *_et_list;
+
+const struct error_table et_siev_error_table = { text, -1237848064L, 7 };
+
+static struct et_list link = { 0, 0 };
+
+void initialize_siev_error_table(void);
+
+void initialize_siev_error_table(void) {
+    if (!link.table) {
+        link.next = _et_list;
+        link.table = &et_siev_error_table;
+        _et_list = &link;
+    }
+}
+
+/* For Heimdal compatibility */
+void initialize_siev_error_table_r(struct et_list **list);
+
+void initialize_siev_error_table_r(struct et_list **list)
+{
+    struct et_list *et, **end;
+
+    for (end = list, et = *list; et; end = &et->next, et = et->next)
+        if (et->table->msgs == text)
+            return;
+    et = malloc(sizeof(struct et_list));
+    if (et == 0)
+        return;
+    et->table = &et_siev_error_table;
+    et->next = 0;
+    *end = et;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_err.et dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_err.et
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_err.et	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_err.et	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,31 @@
+# sieve_err.et -- Error codes for the Sieve subsystem
+# $Id: sieve_err.et,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+#
+# Copyright 2000 Carnegie Mellon University
+# 
+error_table siev
+
+ec SIEVE_FAIL,
+   "Generic Sieve error"
+
+ec SIEVE_NOT_FINALIZED,
+   "Sieve interpretor not finalized"
+
+ec SIEVE_PARSE_ERROR,
+   "Parse error in Sieve script"
+
+ec SIEVE_RUN_ERROR,
+   "Run-time error during Sieve execution"
+
+ec SIEVE_INTERNAL_ERROR,
+   "Internal error in Sieve subsystem"
+
+ec SIEVE_NOMEM,
+   "Memory exhausted in Sieve subsystem"
+
+ec SIEVE_DONE,
+   "Sieve action already taken"
+
+end
+
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_err.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_err.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_err.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_err.h	2006-01-13 10:16:01.000000000 -0500
@@ -0,0 +1,24 @@
+/*
+ * sieve_err.h:
+ * This file used to be automatically generated from sieve_er.et.
+ */
+struct et_list;
+
+#define SIEVE_FAIL                               (-1237848064L)
+#define SIEVE_NOT_FINALIZED                      (-1237848063L)
+#define SIEVE_PARSE_ERROR                        (-1237848062L)
+#define SIEVE_RUN_ERROR                          (-1237848061L)
+#define SIEVE_INTERNAL_ERROR                     (-1237848060L)
+#define SIEVE_NOMEM                              (-1237848059L)
+#define SIEVE_DONE                               (-1237848058L)
+extern const struct error_table et_siev_error_table;
+extern void initialize_siev_error_table(void);
+
+/* For compatibility with Heimdal */
+extern void initialize_siev_error_table_r(struct et_list **list);
+
+#define ERROR_TABLE_BASE_siev (-1237848064L)
+
+/* for compatibility with older versions... */
+#define init_siev_err_tbl initialize_siev_error_table
+#define siev_err_base ERROR_TABLE_BASE_siev
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_interface.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_interface.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve_interface.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve_interface.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,172 @@
+/* sieve_interface.h -- interface for deliver
+ * $Id: sieve_interface.h,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef SIEVE_H
+#define SIEVE_H
+
+#include <stdio.h>
+
+#define SIEVE_VERSION "CMU Sieve 2.2"
+
+/* error codes */
+#define SIEVE_OK (0)
+
+#include "sieve_err.h"
+
+/* external sieve types */
+typedef struct sieve_interp sieve_interp_t;
+typedef struct sieve_script sieve_script_t;
+typedef struct sieve_bytecode sieve_bytecode_t;
+typedef struct bytecode_info bytecode_info_t;
+
+typedef int sieve_callback(void *action_context, void *interp_context, 
+			   void *script_context,
+			   void *message_context, const char **errmsg);
+typedef int sieve_get_size(void *message_context, int *size);
+typedef int sieve_get_header(void *message_context, 
+			     const char *header,
+			     const char ***contents);
+typedef int sieve_get_envelope(void *message_context, 
+			       const char *field,
+			       const char ***contents);
+
+typedef struct sieve_vacation {
+    int min_response;		/* 0 -> defaults to 3 */
+    int max_response;		/* 0 -> defaults to 90 */
+
+    /* given a hash, say whether we've already responded to it in the last
+       days days.  return SIEVE_OK if we SHOULD autorespond (have not already)
+       or SIEVE_DONE if we SHOULD NOT. */
+    sieve_callback *autorespond;
+
+    /* mail the response */
+    sieve_callback *send_response;
+} sieve_vacation_t;
+
+typedef struct sieve_imapflags {
+    char **flag;		/* NULL -> defaults to \flagged */
+    int nflags;
+} sieve_imapflags_t;
+
+typedef struct sieve_redirect_context {
+    const char *addr;
+} sieve_redirect_context_t;
+
+typedef struct sieve_reject_context {
+    const char *msg;
+} sieve_reject_context_t;
+
+typedef struct sieve_fileinto_context {
+    const char *mailbox;
+    sieve_imapflags_t *imapflags;
+} sieve_fileinto_context_t;
+
+typedef struct sieve_keep_context {
+    sieve_imapflags_t *imapflags;
+} sieve_keep_context_t;
+
+typedef struct sieve_notify_context {
+    const char *method;
+    const char **options;
+    const char *priority;
+    const char *message;
+} sieve_notify_context_t;
+
+typedef struct sieve_autorespond_context {
+    unsigned char *hash;
+    int len;
+    int days;
+} sieve_autorespond_context_t;
+
+typedef struct sieve_send_response_context {
+    char *addr;
+    char *fromaddr;
+    const char *msg;
+    char *subj;
+    int mime;
+} sieve_send_response_context_t;
+
+/* build a sieve interpretor */
+int sieve_interp_alloc(sieve_interp_t **interp, void *interp_context);
+int sieve_interp_free(sieve_interp_t **interp);
+
+/* add the callbacks for actions. undefined behavior results if these
+   are called after sieve_script_parse is called! */
+int sieve_register_redirect(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_discard(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_reject(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_fileinto(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_keep(sieve_interp_t *interp, sieve_callback *f);
+int sieve_register_vacation(sieve_interp_t *interp, sieve_vacation_t *v);
+int sieve_register_imapflags(sieve_interp_t *interp, sieve_imapflags_t *mark);
+int sieve_register_notify(sieve_interp_t *interp, sieve_callback *f);
+
+/* add the callbacks for messages. again, undefined if used after
+   sieve_script_parse */
+int sieve_register_size(sieve_interp_t *interp, sieve_get_size *f);
+int sieve_register_header(sieve_interp_t *interp, sieve_get_header *f);
+int sieve_register_envelope(sieve_interp_t *interp, sieve_get_envelope *f);
+
+typedef int sieve_parse_error(int lineno, const char *msg, 
+			      void *interp_context,
+			      void *script_context);
+int sieve_register_parse_error(sieve_interp_t *interp, sieve_parse_error *f);
+
+typedef int sieve_execute_error(const char *msg, void *interp_context,
+				void *script_context, void *message_context);
+int sieve_register_execute_error(sieve_interp_t *interp, 
+				 sieve_execute_error *f);
+ 
+/* given an interpretor and a script, produce an executable script */
+int sieve_script_parse(sieve_interp_t *interp, FILE *script,
+		       void *script_context, sieve_script_t **ret);
+
+/* given a bytecode file descriptor, setup the sieve_bytecode_t */
+int sieve_script_load(const char *fname, sieve_bytecode_t **ret);
+
+/* Unload a sieve_bytecode_t */
+int sieve_script_unload(sieve_bytecode_t **s);
+
+/* Free a sieve_script_t */
+int sieve_script_free(sieve_script_t **s);
+
+/* execute bytecode on a message */
+int sieve_execute_bytecode(sieve_bytecode_t *script, sieve_interp_t *interp,
+			   void *script_context, void *message_context);
+
+/* Get space separated list of extensions supported by the implementation */
+const char *sieve_listextensions(void);
+
+/* Create a bytecode structure given a parsed commandlist */
+int sieve_generate_bytecode(bytecode_info_t **retval, sieve_script_t *s);
+
+/* Emit bytecode to a file descriptor */
+int sieve_emit_bytecode(int fd, bytecode_info_t *bc);
+
+/* Free a bytecode_info_t */
+void sieve_free_bytecode(bytecode_info_t **p);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve-lex.l dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve-lex.l
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve-lex.l	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve-lex.l	2005-10-14 16:11:42.000000000 -0400
@@ -0,0 +1,162 @@
+%{
+/* sieve.l -- sieve lexer
+ * Larry Greenfield
+ * $Id: sieve-lex.l,v 1.2 2005/10/14 20:11:42 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h> /* for strdup */
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+#define yylval sievelval
+#define yylex sievelex
+#define yyerror sieveerror
+
+static int tonum(char *c);
+static char *chkstr(char *);
+static char *mlbuf;
+static int mlbufsz, mlcur;
+extern int yyerror(char *);
+%}
+
+%option yylineno
+%option noyywrap
+%option nounput
+
+ws		[ \t]+
+ident		[a-zA-Z_][a-zA-Z_0-9]*
+CRLF		(\r\n|\r|\n)
+
+%state MULTILINE
+%state QSTRING
+
+%%
+<MULTILINE>^\.{CRLF}	{ BEGIN INITIAL; 
+                          if (mlbuf) mlbuf[mlcur] = '\0';
+                          yylval.sval = chkstr(mlbuf); return STRING; }
+<MULTILINE>^\.\.  { /* dot stuffing! we want one . */ yyless(1); }
+<MULTILINE>(.|\n) { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+<MULTILINE><<EOF>> { yyerror("unexpected end of file in string"); 
+		     yyterminate(); }
+<QSTRING>\"        { BEGIN INITIAL;
+                     if (mlbuf) mlbuf[mlcur] = '\0';
+		     yylval.sval = chkstr(mlbuf); return STRING; }
+<QSTRING>\\.      { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[1]; }
+<QSTRING>(.|\n)   { if (mlcur == mlbufsz) 
+			mlbuf = xrealloc(mlbuf, 1 + (mlbufsz+=1024));
+		    mlbuf[mlcur++] = yytext[0]; }
+<INITIAL>text:{ws}?(#.*)?{CRLF}	{ BEGIN MULTILINE;
+			  mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+<INITIAL>\"        { BEGIN QSTRING;
+                    mlcur = 0; mlbufsz = 0; mlbuf = NULL; }
+<INITIAL>[0-9]+[KMG]?	{ yylval.nval = tonum(yytext); return NUMBER; }
+<INITIAL>if		return IF;
+<INITIAL>elsif		return ELSIF;
+<INITIAL>else		return ELSE;
+<INITIAL>anyof		return ANYOF;
+<INITIAL>allof		return ALLOF;
+<INITIAL>exists		return EXISTS;
+<INITIAL>false		return SFALSE;
+<INITIAL>true		return STRUE;
+<INITIAL>address	return ADDRESS;
+<INITIAL>envelope	return ENVELOPE;
+<INITIAL>header		return HEADER;
+<INITIAL>not		return NOT;
+<INITIAL>size		return SIZE;
+<INITIAL>reject		return REJCT;
+<INITIAL>fileinto	return FILEINTO;
+<INITIAL>redirect	return REDIRECT;
+<INITIAL>keep		return KEEP;
+<INITIAL>require	return REQUIRE;
+<INITIAL>stop		return STOP;
+<INITIAL>discard	return DISCARD;
+<INITIAL>setflag	return SETFLAG;
+<INITIAL>addflag	return ADDFLAG;
+<INITIAL>removeflag	return REMOVEFLAG;
+<INITIAL>mark		return MARK;
+<INITIAL>unmark		return UNMARK;
+<INITIAL>notify		return NOTIFY;
+<INITIAL>denotify	return DENOTIFY;
+<INITIAL>:id		return ID;
+<INITIAL>:method	return METHOD;
+<INITIAL>:options	return OPTIONS;
+<INITIAL>:low		return LOW;
+<INITIAL>:normal	return NORMAL;
+<INITIAL>:high		return HIGH;
+<INITIAL>:message	return MESSAGE;
+<INITIAL>vacation	return VACATION;
+<INITIAL>:days		return DAYS;
+<INITIAL>:addresses	return ADDRESSES;
+<INITIAL>:subject	return SUBJECT;
+<INITIAL>:mime		return MIME;
+<INITIAL>:comparator	return COMPARATOR;
+<INITIAL>:is		return IS;
+<INITIAL>:contains	return CONTAINS;
+<INITIAL>:matches	return MATCHES;
+<INITIAL>:regex		return REGEX;
+<INITIAL>:count		return COUNT;
+<INITIAL>:value		return VALUE;
+<INITIAL>:over		return OVER;
+<INITIAL>:under		return UNDER;
+<INITIAL>:all		return ALL;
+<INITIAL>:localpart	return LOCALPART;
+<INITIAL>:domain	return DOMAIN;
+<INITIAL>:user		return USER;
+<INITIAL>:detail	return DETAIL;
+<INITIAL>[ \t\n\r] ;	/* ignore whitespace */
+<INITIAL>#.* ;		/* ignore hash comments */
+<INITIAL>"/*"([^\*]|\*[^\/])*\*?"*/" ;	/* ignore bracket comments */
+.			return yytext[0];
+
+%%
+/*  */
+static int tonum(char *c)
+{
+  int val = atoi(c);
+  switch (c[strlen(c)-1]) {
+  case 'K': val *= (1 << 10); break;
+  case 'M': val *= (1 << 20); break;
+  case 'G': val *= (1 << 30); break;
+  default: break;
+  }
+  return val;
+}
+
+/* convert NULL strings to "" */
+static char *chkstr(char *str)
+{
+    if (!str) return xstrdup("");
+    else return str;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve.y dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve.y
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/sieve.y	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/sieve.y	2005-10-12 13:17:57.000000000 -0400
@@ -0,0 +1,1090 @@
+%{
+/* sieve.y -- sieve parser
+ * Larry Greenfield
+ * $Id: sieve.y,v 1.3 2005/10/12 17:17:57 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include "xmalloc.h"
+#include "comparator.h"
+#include "interp.h"
+#include "script.h"
+#include "tree.h"
+
+#include "imparse.h"
+#include "libconfig.h"
+
+    /* definitions */
+    extern int addrparse(void);
+
+struct vtags {
+    int days;
+    stringlist_t *addresses;
+    char *subject;
+    int mime;
+};
+
+struct htags {
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct aetags {
+    int addrtag;
+    char *comparator;
+    int comptag;
+    int relation;
+};
+
+struct ntags {
+    char *method;
+    char *id;
+    stringlist_t *options;
+    int priority;
+    char *message;
+};
+
+struct dtags {
+    int comptag;
+    int relation;
+    void *pattern;
+    int priority;
+};
+
+static commandlist_t *ret;
+static sieve_script_t *parse_script;
+static int check_reqs(stringlist_t *sl);
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl);
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl);
+static commandlist_t *build_vacation(int t, struct vtags *h, char *s);
+static commandlist_t *build_notify(int t, struct ntags *n);
+static commandlist_t *build_denotify(int t, struct dtags *n);
+static struct aetags *new_aetags(void);
+static struct aetags *canon_aetags(struct aetags *ae);
+static void free_aetags(struct aetags *ae);
+static struct htags *new_htags(void);
+static struct htags *canon_htags(struct htags *h);
+static void free_htags(struct htags *h);
+static struct vtags *new_vtags(void);
+static struct vtags *canon_vtags(struct vtags *v);
+static void free_vtags(struct vtags *v);
+static struct ntags *new_ntags(void);
+static struct ntags *canon_ntags(struct ntags *n);
+static void free_ntags(struct ntags *n);
+static struct dtags *new_dtags(void);
+static struct dtags *canon_dtags(struct dtags *d);
+static void free_dtags(struct dtags *d);
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *));
+static int verify_mailbox(char *s);
+static int verify_address(char *s);
+static int verify_header(char *s);
+static int verify_addrheader(char *s);
+static int verify_envelope(char *s);
+static int verify_flag(char *s);
+static int verify_relat(char *s);
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags);
+static int verify_regexs(stringlist_t *sl, char *comp);
+#endif
+static int verify_utf8(char *s);
+
+int yyerror(char *msg);
+extern int yylex(void);
+extern void yyrestart(FILE *f);
+
+#define YYERROR_VERBOSE /* i want better error messages! */
+%}
+
+%union {
+    int nval;
+    char *sval;
+    stringlist_t *sl;
+    test_t *test;
+    testlist_t *testl;
+    commandlist_t *cl;
+    struct vtags *vtag;
+    struct aetags *aetag;
+    struct htags *htag;
+    struct ntags *ntag;
+    struct dtags *dtag;
+}
+
+%token <nval> NUMBER
+%token <sval> STRING
+%token IF ELSIF ELSE
+%token REJCT FILEINTO REDIRECT KEEP STOP DISCARD VACATION REQUIRE
+%token SETFLAG ADDFLAG REMOVEFLAG MARK UNMARK
+%token NOTIFY DENOTIFY
+%token ANYOF ALLOF EXISTS SFALSE STRUE HEADER NOT SIZE ADDRESS ENVELOPE
+%token COMPARATOR IS CONTAINS MATCHES REGEX COUNT VALUE OVER UNDER
+%token GT GE LT LE EQ NE
+%token ALL LOCALPART DOMAIN USER DETAIL
+%token DAYS ADDRESSES SUBJECT MIME
+%token METHOD ID OPTIONS LOW NORMAL HIGH ANY MESSAGE
+
+%type <cl> commands command action elsif block
+%type <sl> stringlist strings
+%type <test> test
+%type <nval> comptag relcomp sizetag addrparttag addrorenv
+%type <testl> testlist tests
+%type <htag> htags
+%type <aetag> aetags
+%type <vtag> vtags
+%type <ntag> ntags
+%type <dtag> dtags
+%type <nval> priority
+
+%%
+
+start: reqs			{ ret = NULL; }
+	| reqs commands		{ ret = $2; }
+	;
+
+reqs: /* empty */
+	| require reqs
+	;
+
+require: REQUIRE stringlist ';'	{ if (!check_reqs($2)) {
+                                    yyerror("unsupported feature");
+				    YYERROR; 
+                                  } }
+	;
+
+commands: command		{ $$ = $1; }
+	| command commands	{ $1->next = $2; $$ = $1; }
+	;
+
+command: action ';'		{ $$ = $1; }
+	| IF test block elsif   { $$ = new_if($2, $3, $4); }
+	| error ';'		{ $$ = new_command(STOP); }
+	;
+
+elsif: /* empty */               { $$ = NULL; }
+	| ELSIF test block elsif { $$ = new_if($2, $3, $4); }
+	| ELSE block             { $$ = $2; }
+	;
+
+action: REJCT STRING             { if (!parse_script->support.reject) {
+				     yyerror("reject require missing");
+				     YYERROR;
+				   }
+				   if (!verify_utf8($2)) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+				   $$ = new_command(REJCT);
+				   $$->u.str = $2; }
+	| FILEINTO STRING	 { if (!parse_script->support.fileinto) {
+				     yyerror("fileinto require missing");
+	                             YYERROR;
+                                   }
+				   if (!verify_mailbox($2)) {
+				     YYERROR; /* vm should call yyerror() */
+				   }
+	                           $$ = new_command(FILEINTO);
+				   $$->u.str = $2; }
+	| REDIRECT STRING         { $$ = new_command(REDIRECT);
+				   if (!verify_address($2)) {
+				     YYERROR; /* va should call yyerror() */
+				   }
+				   $$->u.str = $2; }
+	| KEEP			 { $$ = new_command(KEEP); }
+	| STOP			 { $$ = new_command(STOP); }
+	| DISCARD		 { $$ = new_command(DISCARD); }
+	| VACATION vtags STRING  { if (!parse_script->support.vacation) {
+				     yyerror("vacation require missing");
+				     YYERROR;
+				   }
+				   if (($2->mime == -1) && !verify_utf8($3)) {
+				     YYERROR; /* vu should call yyerror() */
+				   }
+  				   $$ = build_vacation(VACATION,
+					    canon_vtags($2), $3); }
+        | SETFLAG stringlist     { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                   }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(SETFLAG);
+                                  $$->u.sl = $2; }
+         | ADDFLAG stringlist     { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(ADDFLAG);
+                                  $$->u.sl = $2; }
+         | REMOVEFLAG stringlist  { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  if (!verify_stringlist($2, verify_flag)) {
+                                    YYERROR; /* vf should call yyerror() */
+                                  }
+                                  $$ = new_command(REMOVEFLAG);
+                                  $$->u.sl = $2; }
+         | MARK                   { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  $$ = new_command(MARK); }
+         | UNMARK                 { if (!parse_script->support.imapflags) {
+                                    yyerror("imapflags require missing");
+                                    YYERROR;
+                                    }
+                                  $$ = new_command(UNMARK); }
+
+         | NOTIFY ntags           { if (!parse_script->support.notify) {
+				       yyerror("notify require missing");
+				       $$ = new_command(NOTIFY); 
+				       YYERROR;
+	 			    } else {
+				      $$ = build_notify(NOTIFY,
+				             canon_ntags($2));
+				    } }
+         | DENOTIFY dtags         { if (!parse_script->support.notify) {
+                                       yyerror("notify require missing");
+				       $$ = new_command(DENOTIFY);
+				       YYERROR;
+				    } else {
+					$$ = build_denotify(DENOTIFY, canon_dtags($2));
+					if ($$ == NULL) { 
+			yyerror("unable to find a compatible comparator");
+			YYERROR; } } }
+	;
+
+ntags: /* empty */		 { $$ = new_ntags(); }
+	| ntags ID STRING	 { if ($$->id != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { $$->id = $3; } }
+	| ntags METHOD STRING	 { if ($$->method != NULL) { 
+					yyerror("duplicate :method"); YYERROR; }
+				   else { $$->method = $3; } }
+	| ntags OPTIONS stringlist { if ($$->options != NULL) { 
+					yyerror("duplicate :options"); YYERROR; }
+				     else { $$->options = $3; } }
+        | ntags priority	 { if ($$->priority != -1) { 
+                                 yyerror("duplicate :priority"); YYERROR; }
+                                   else { $$->priority = $2; } }
+	| ntags MESSAGE STRING	 { if ($$->message != NULL) { 
+					yyerror("duplicate :message"); YYERROR; }
+				   else { $$->message = $3; } }
+	;
+
+dtags: /* empty */		 { $$ = new_dtags(); }
+	| dtags priority	 { if ($$->priority != -1) { 
+				yyerror("duplicate priority level"); YYERROR; }
+				   else { $$->priority = $2; } }
+	| dtags comptag STRING 	 { if ($$->comptag != -1)
+	                             { 
+					 yyerror("duplicate comparator type tag"); YYERROR;
+				     }
+	                           $$->comptag = $2;
+#ifdef ENABLE_REGEX
+				   if ($$->comptag == REGEX)
+				   {
+				       int cflags = REG_EXTENDED |
+					   REG_NOSUB | REG_ICASE;
+				       if (!verify_regex($3, cflags)) { YYERROR; }
+				   }
+#endif
+				   $$->pattern = $3;
+	                          }
+	| dtags relcomp STRING  { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	;
+
+priority: LOW                   { $$ = LOW; }
+        | NORMAL                { $$ = NORMAL; }
+        | HIGH                  { $$ = HIGH; }
+        ;
+
+vtags: /* empty */		 { $$ = new_vtags(); }
+	| vtags DAYS NUMBER	 { if ($$->days != -1) { 
+					yyerror("duplicate :days"); YYERROR; }
+				   else { $$->days = $3; } }
+	| vtags ADDRESSES stringlist { if ($$->addresses != NULL) { 
+					yyerror("duplicate :addresses"); 
+					YYERROR;
+				       } else if (!verify_stringlist($3,
+							verify_address)) {
+					  YYERROR;
+				       } else {
+					 $$->addresses = $3; } }
+	| vtags SUBJECT STRING	 { if ($$->subject != NULL) { 
+					yyerror("duplicate :subject"); 
+					YYERROR;
+				   } else if (!verify_utf8($3)) {
+				        YYERROR; /* vu should call yyerror() */
+				   } else { $$->subject = $3; } }
+	| vtags MIME		 { if ($$->mime != -1) { 
+					yyerror("duplicate :mime"); 
+					YYERROR; }
+				   else { $$->mime = MIME; } }
+	;
+
+stringlist: '[' strings ']'      { $$ = $2; }
+	| STRING		 { $$ = new_sl($1, NULL); }
+	;
+
+strings: STRING			 { $$ = new_sl($1, NULL); }
+	| STRING ',' strings	 { $$ = new_sl($1, $3); }
+	;
+
+block: '{' commands '}'		 { $$ = $2; }
+	| '{' '}'		 { $$ = NULL; }
+	;
+
+test:     ANYOF testlist	 { $$ = new_test(ANYOF); $$->u.tl = $2; }
+        | ALLOF testlist	 { $$ = new_test(ALLOF); $$->u.tl = $2; }
+        | EXISTS stringlist      { $$ = new_test(EXISTS); $$->u.sl = $2; }
+        | SFALSE		 { $$ = new_test(SFALSE); }
+	| STRUE			 { $$ = new_test(STRUE); }
+	| HEADER htags stringlist stringlist
+				 {
+				     if (!verify_stringlist($3, verify_header)) {
+					 YYERROR; /* vh should call yyerror() */
+				     }
+				     if (!verify_stringlist($4, verify_utf8)) {
+					 YYERROR; /* vu should call yyerror() */
+				     }
+				     
+				     $2 = canon_htags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!(verify_regexs($4, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_header(HEADER, $2, $3, $4);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+
+        | addrorenv aetags stringlist stringlist
+				 { 
+				     if (($1 == ADDRESS) &&
+					 !verify_stringlist($3, verify_addrheader))
+					 { YYERROR; }
+				     else if (($1 == ENVELOPE) &&
+					      !verify_stringlist($3, verify_envelope))
+					 { YYERROR; }
+				     $2 = canon_aetags($2);
+#ifdef ENABLE_REGEX
+				     if ($2->comptag == REGEX)
+				     {
+					 if (!( verify_regexs($4, $2->comparator)))
+					 { YYERROR; }
+				     }
+#endif
+				     $$ = build_address($1, $2, $3, $4);
+				     if ($$ == NULL) { 
+					 yyerror("unable to find a compatible comparator");
+					 YYERROR; } 
+				 }
+
+	| NOT test		 { $$ = new_test(NOT); $$->u.t = $2; }
+	| SIZE sizetag NUMBER    { $$ = new_test(SIZE); $$->u.sz.t = $2;
+		                   $$->u.sz.n = $3; }
+	| error			 { $$ = NULL; }
+	;
+
+addrorenv: ADDRESS		 { $$ = ADDRESS; }
+	| ENVELOPE		 {if (!parse_script->support.envelope)
+	                              {yyerror("envelope require missing"); YYERROR;}
+	                          else{$$ = ENVELOPE; }
+	                         }
+
+	;
+
+aetags: /* empty */              { $$ = new_aetags(); }
+        | aetags addrparttag	 { $$ = $1;
+				   if ($$->addrtag != -1) { 
+			yyerror("duplicate or conflicting address part tag");
+			YYERROR; }
+				   else { $$->addrtag = $2; } }
+	| aetags comptag         { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| aetags relcomp STRING{ $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+        | aetags COMPARATOR STRING { $$ = $1;
+	if ($$->comparator != NULL) { 
+			yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) {
+			yyerror("comparator-i;ascii-numeric require missing");
+			YYERROR; }
+				   else { $$->comparator = $3; } }
+	;
+
+htags: /* empty */		 { $$ = new_htags(); }
+	| htags comptag		 { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2; } }
+	| htags relcomp STRING { $$ = $1;
+				   if ($$->comptag != -1) { 
+			yyerror("duplicate comparator type tag"); YYERROR; }
+				   else { $$->comptag = $2;
+				   $$->relation = verify_relat($3);
+				   if ($$->relation==-1) 
+				     {YYERROR; /*vr called yyerror()*/ }
+				   } }
+	| htags COMPARATOR STRING { $$ = $1;
+				   if ($$->comparator != NULL) { 
+			 yyerror("duplicate comparator tag"); YYERROR; }
+				   else if (!strcmp($3, "i;ascii-numeric") &&
+					    !parse_script->support.i_ascii_numeric) { 
+			 yyerror("comparator-i;ascii-numeric require missing");  YYERROR; }
+				   else { 
+				     $$->comparator = $3; } }
+        ;
+
+
+addrparttag: ALL                 { $$ = ALL; }
+	| LOCALPART		 { $$ = LOCALPART; }
+	| DOMAIN                 { $$ = DOMAIN; }
+	| USER                   { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   $$ = USER; }  
+	| DETAIL                { if (!parse_script->support.subaddress) {
+				     yyerror("subaddress require missing");
+				     YYERROR;
+				   }
+				   $$ = DETAIL; }
+	;
+comptag: IS			 { $$ = IS; }
+	| CONTAINS		 { $$ = CONTAINS; }
+	| MATCHES		 { $$ = MATCHES; }
+	| REGEX			 { if (!parse_script->support.regex) {
+				     yyerror("regex require missing");
+				     YYERROR;
+				   }
+				   $$ = REGEX; }
+	;
+
+relcomp: COUNT			 { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   $$ = COUNT; }
+	| VALUE			 { if (!parse_script->support.relational) {
+				     yyerror("relational require missing");
+				     YYERROR;
+				   }
+				   $$ = VALUE; }
+	;
+
+
+sizetag: OVER			 { $$ = OVER; }
+	| UNDER			 { $$ = UNDER; }
+	;
+
+testlist: '(' tests ')'		 { $$ = $2; }
+	;
+
+tests: test                      { $$ = new_testlist($1, NULL); }
+	| test ',' tests         { $$ = new_testlist($1, $3); }
+	;
+
+%%
+commandlist_t *sieve_parse(sieve_script_t *script, FILE *f)
+{
+    commandlist_t *t;
+
+    parse_script = script;
+    yyrestart(f);
+    if (yyparse()) {
+	t = NULL;
+    } else {
+	t = ret;
+    }
+    ret = NULL;
+    return t;
+}
+
+int yyerror(char *msg)
+{
+    extern int yylineno;
+    int ret;
+
+    parse_script->err++;
+    if (parse_script->interp.err) {
+	ret = parse_script->interp.err(yylineno, msg, 
+				       parse_script->interp.interp_context,
+				       parse_script->script_context);
+    }
+
+    return 0;
+}
+
+static int check_reqs(stringlist_t *sl)
+{
+    int i = 1;
+    stringlist_t *s;
+    
+    while (sl != NULL) {
+	s = sl;
+	sl = sl->next;
+
+	i &= script_require(parse_script, s->s);
+
+	if (s->s) free(s->s);
+	free(s);
+    }
+    return i;
+}
+
+static test_t *build_address(int t, struct aetags *ae,
+			     stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be either ADDRESS or ENVELOPE */
+
+    assert((t == ADDRESS) || (t == ENVELOPE));
+
+    if (ret) {
+	ret->u.ae.comptag = ae->comptag;
+	ret->u.ae.relation=ae->relation;
+	ret->u.ae.comparator=strdup(ae->comparator);
+	ret->u.ae.sl = sl;
+	ret->u.ae.pl = pl;
+	ret->u.ae.addrpart = ae->addrtag;
+	free_aetags(ae);
+
+    }
+    return ret;
+}
+
+static test_t *build_header(int t, struct htags *h,
+			    stringlist_t *sl, stringlist_t *pl)
+{
+    test_t *ret = new_test(t);	/* can be HEADER */
+
+    assert(t == HEADER);
+
+    if (ret) {
+	ret->u.h.comptag = h->comptag;
+	ret->u.h.relation=h->relation;
+	ret->u.h.comparator=strdup(h->comparator);
+	ret->u.h.sl = sl;
+	ret->u.h.pl = pl;
+	free_htags(h);
+    }
+    return ret;
+}
+
+static commandlist_t *build_vacation(int t, struct vtags *v, char *reason)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == VACATION);
+
+    if (ret) {
+	ret->u.v.subject = v->subject; v->subject = NULL;
+	ret->u.v.days = v->days;
+	ret->u.v.mime = v->mime;
+	ret->u.v.addresses = v->addresses; v->addresses = NULL;
+	free_vtags(v);
+	ret->u.v.message = reason;
+    }
+    return ret;
+}
+
+static commandlist_t *build_notify(int t, struct ntags *n)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == NOTIFY);
+       if (ret) {
+	ret->u.n.method = n->method; n->method = NULL;
+	ret->u.n.id = n->id; n->id = NULL;
+	ret->u.n.options = n->options; n->options = NULL;
+	ret->u.n.priority = n->priority;
+	ret->u.n.message = n->message; n->message = NULL;
+	free_ntags(n);
+    }
+    return ret;
+}
+
+static commandlist_t *build_denotify(int t, struct dtags *d)
+{
+    commandlist_t *ret = new_command(t);
+
+    assert(t == DENOTIFY);
+
+    if (ret) {
+	ret->u.d.comptag = d->comptag;
+	ret->u.d.relation=d->relation;
+	ret->u.d.pattern = d->pattern; d->pattern = NULL;
+	ret->u.d.priority = d->priority;
+	free_dtags(d);
+    }
+    return ret;
+}
+
+static struct aetags *new_aetags(void)
+{
+    struct aetags *r = (struct aetags *) xmalloc(sizeof(struct aetags));
+
+    r->addrtag = r->comptag = r->relation=-1;
+    r->comparator=NULL;
+
+    return r;
+}
+
+static struct aetags *canon_aetags(struct aetags *ae)
+{
+    if (ae->addrtag == -1) { ae->addrtag = ALL; }
+    if (ae->comparator == NULL) {
+        ae->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (ae->comptag == -1) { ae->comptag = IS; }
+    return ae;
+}
+
+static void free_aetags(struct aetags *ae)
+{
+    free(ae->comparator);
+     free(ae);
+}
+
+static struct htags *new_htags(void)
+{
+    struct htags *r = (struct htags *) xmalloc(sizeof(struct htags));
+
+    r->comptag = r->relation= -1;
+    
+    r->comparator = NULL;
+
+    return r;
+}
+
+static struct htags *canon_htags(struct htags *h)
+{
+    if (h->comparator == NULL) {
+	h->comparator = xstrdup("i;ascii-casemap");
+    }
+    if (h->comptag == -1) { h->comptag = IS; }
+    return h;
+}
+
+static void free_htags(struct htags *h)
+{
+    free(h->comparator);
+    free(h);
+}
+
+static struct vtags *new_vtags(void)
+{
+    struct vtags *r = (struct vtags *) xmalloc(sizeof(struct vtags));
+
+    r->days = -1;
+    r->addresses = NULL;
+    r->subject = NULL;
+    r->mime = -1;
+
+    return r;
+}
+
+static struct vtags *canon_vtags(struct vtags *v)
+{
+    assert(parse_script->interp.vacation != NULL);
+
+    if (v->days == -1) { v->days = 7; }
+    if (v->days < parse_script->interp.vacation->min_response) 
+       { v->days = parse_script->interp.vacation->min_response; }
+    if (v->days > parse_script->interp.vacation->max_response)
+       { v->days = parse_script->interp.vacation->max_response; }
+    if (v->mime == -1) { v->mime = 0; }
+
+    return v;
+}
+
+static void free_vtags(struct vtags *v)
+{
+    if (v->addresses) { free_sl(v->addresses); }
+    if (v->subject) { free(v->subject); }
+    free(v);
+}
+
+static struct ntags *new_ntags(void)
+{
+    struct ntags *r = (struct ntags *) xmalloc(sizeof(struct ntags));
+
+    r->method = NULL;
+    r->id = NULL;
+    r->options = NULL;
+    r->priority = -1;
+    r->message = NULL;
+
+    return r;
+}
+
+static struct ntags *canon_ntags(struct ntags *n)
+{
+    if (n->priority == -1) { n->priority = NORMAL; }
+    if (n->message == NULL) { n->message = strdup("$from$: $subject$"); }
+    if (n->method == NULL) { n->method = strdup("default"); }
+    return n;
+}
+static struct dtags *canon_dtags(struct dtags *d)
+{
+    if (d->priority == -1) { d->priority = ANY; }
+    if (d->comptag == -1) { d->comptag = ANY; }
+       return d;
+}
+
+static void free_ntags(struct ntags *n)
+{
+    if (n->method) { free(n->method); }
+    if (n->id) { free(n->id); }
+    if (n->options) { free_sl(n->options); }
+    if (n->message) { free(n->message); }
+    free(n);
+}
+
+static struct dtags *new_dtags(void)
+{
+    struct dtags *r = (struct dtags *) xmalloc(sizeof(struct dtags));
+
+    r->comptag = r->priority= r->relation = -1;
+    r->pattern  = NULL;
+
+    return r;
+}
+
+static void free_dtags(struct dtags *d)
+{
+    if (d->pattern) free(d->pattern);
+    free(d);
+}
+
+static int verify_stringlist(stringlist_t *sl, int (*verify)(char *))
+{
+    for (; sl != NULL && verify(sl->s); sl = sl->next) ;
+    return (sl == NULL);
+}
+
+char *addrptr;		/* pointer to address string for address lexer */
+char addrerr[500];	/* buffer for address parser error messages */
+
+static int verify_address(char *s)
+{
+    char errbuf[500];
+
+    addrptr = s;
+    addrerr[0] = '\0';	/* paranoia */
+    if (addrparse()) {
+	snprintf(errbuf, sizeof(errbuf), "address '%s': %s", s, addrerr);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+
+static int verify_mailbox(char *s)
+{
+    if (!verify_utf8(s)) return 0;
+
+    /* xxx if not a mailbox, call yyerror */
+    return 1;
+}
+
+static int verify_header(char *hdr)
+{
+    char *h = hdr;
+    char errbuf[100];
+
+    while (*h) {
+	/* field-name      =       1*ftext
+	   ftext           =       %d33-57 / %d59-126         
+	   ; Any character except
+	   ;  controls, SP, and
+	   ;  ":". */
+	if (!((*h >= 33 && *h <= 57) || (*h >= 59 && *h <= 126))) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "header '%s': not a valid header", hdr);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	h++;
+    }
+    return 1;
+}
+ 
+static int verify_addrheader(char *hdr)
+{
+    const char **h, *hdrs[] = {
+	"from", "sender", "reply-to",	/* RFC2822 originator fields */
+	"to", "cc", "bcc",		/* RFC2822 destination fields */
+	"resent-from", "resent-sender",	/* RFC2822 resent fields */
+	"resent-to", "resent-cc", "resent-bcc",
+	"return-path",			/* RFC2822 trace fields */
+	"disposition-notification-to",	/* RFC2298 MDN request fields */
+	"delivered-to",			/* non-standard (loop detection) */
+	"approved",			/* RFC1036 moderator/control fields */
+	NULL
+    };
+    char errbuf[100];
+
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT))
+	return verify_header(hdr);
+
+    for (lcase(hdr), h = hdrs; *h; h++) {
+	if (!strcmp(*h, hdr)) return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "header '%s': not a valid header for an address test", hdr);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_envelope(char *env)
+{
+    char errbuf[100];
+
+    lcase(env);
+    if (!config_getswitch(IMAPOPT_RFC3028_STRICT) ||
+	!strcmp(env, "from") || !strcmp(env, "to") || !strcmp(env, "auth")) {
+	return 1;
+    }
+
+    snprintf(errbuf, sizeof(errbuf),
+	     "env-part '%s': not a valid part for an envelope test", env);
+    yyerror(errbuf);
+    return 0;
+}
+ 
+static int verify_relat(char *r)
+{/* this really should have been a token to begin with.*/
+    char errbuf[100];
+	lcase(r);
+	if (!strcmp(r, "gt")) {return GT;}
+	else if (!strcmp(r, "ge")) {return GE;}
+	else if (!strcmp(r, "lt")) {return LT;}
+	else if (!strcmp(r, "le")) {return LE;}
+	else if (!strcmp(r, "ne")) {return NE;}
+	else if (!strcmp(r, "eq")) {return EQ;}
+	else{
+	  sprintf(errbuf, "flag '%s': not a valid relational operation", r);
+	  yyerror(errbuf);
+	  return -1;
+	}
+	
+}
+
+
+
+
+static int verify_flag(char *f)
+{
+    char errbuf[100];
+ 
+    if (f[0] == '\\') {
+	lcase(f);
+	if (strcmp(f, "\\seen") && strcmp(f, "\\answered") &&
+	    strcmp(f, "\\flagged") && strcmp(f, "\\draft") &&
+	    strcmp(f, "\\deleted")) {
+	    snprintf(errbuf, sizeof(errbuf),
+		     "flag '%s': not a system flag", f);
+	    yyerror(errbuf);
+	    return 0;
+	}
+	return 1;
+    }
+    if (!imparse_isatom(f)) {
+	snprintf(errbuf, sizeof(errbuf), "flag '%s': not a valid keyword", f);
+	yyerror(errbuf);
+	return 0;
+    }
+    return 1;
+}
+ 
+#ifdef ENABLE_REGEX
+static int verify_regex(char *s, int cflags)
+{
+    int ret;
+    char errbuf[100];
+    regex_t *reg = (regex_t *) xmalloc(sizeof(regex_t));
+
+     if ((ret = regcomp(reg, s, cflags)) != 0) {
+	(void) regerror(ret, reg, errbuf, sizeof(errbuf));
+	yyerror(errbuf);
+	free(reg);
+	return 0;
+	}
+    free(reg);
+    return 1;
+}
+
+static int verify_regexs(stringlist_t *sl, char *comp)
+{
+    stringlist_t *sl2;
+    int cflags = REG_EXTENDED | REG_NOSUB;
+ 
+
+    if (!strcmp(comp, "i;ascii-casemap")) {
+	cflags |= REG_ICASE;
+    }
+
+    for (sl2 = sl; sl2 != NULL; sl2 = sl2->next) {
+	if ((verify_regex(sl2->s, cflags)) == 0) {
+	    break;
+	}
+    }
+    if (sl2 == NULL) {
+	return 1;
+    }
+    return 0;
+}
+#endif
+
+/*
+ * Valid UTF-8 check (from RFC 2640 Annex B.1)
+ *
+ * The following routine checks if a byte sequence is valid UTF-8. This
+ * is done by checking for the proper tagging of the first and following
+ * bytes to make sure they conform to the UTF-8 format. It then checks
+ * to assure that the data part of the UTF-8 sequence conforms to the
+ * proper range allowed by the encoding. Note: This routine will not
+ * detect characters that have not been assigned and therefore do not
+ * exist.
+ */
+static int verify_utf8(char *s)
+{
+    const unsigned char *buf = (const unsigned char *)s;
+    const unsigned char *endbuf = buf + strlen(s);
+    unsigned char byte2mask = 0x00, c;
+    int trailing = 0;  /* trailing (continuation) bytes to follow */
+
+    while (buf != endbuf) {
+	c = *buf++;
+	if (trailing) {
+	    if ((c & 0xC0) == 0x80) {		/* Does trailing byte
+						   follow UTF-8 format? */
+		if (byte2mask) {		/* Need to check 2nd byte
+						   for proper range? */
+		    if (c & byte2mask)		/* Are appropriate bits set? */
+			byte2mask = 0x00;
+		    else
+			break;
+		}
+		trailing--;
+	    }
+	    else
+		break;
+	}
+	else {
+	    if ((c & 0x80) == 0x00)		/* valid 1 byte UTF-8 */
+		continue;
+	    else if ((c & 0xE0) == 0xC0)	/* valid 2 byte UTF-8 */
+		if (c & 0x1E) {			/* Is UTF-8 byte
+						   in proper range? */
+		    trailing = 1;
+		}
+		else
+		    break;
+	    else if ((c & 0xF0) == 0xE0) {	/* valid 3 byte UTF-8 */
+		if (!(c & 0x0F)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x20;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 2;
+	    }
+	    else if ((c & 0xF8) == 0xF0) {	/* valid 4 byte UTF-8 */
+		if (!(c & 0x07)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x30;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 3;
+	    }
+	    else if ((c & 0xFC) == 0xF8) {	/* valid 5 byte UTF-8 */
+		if (!(c & 0x03)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x38;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 4;
+	    }
+	    else if ((c & 0xFE) == 0xFC) {	/* valid 6 byte UTF-8 */
+		if (!(c & 0x01)) {		/* Is UTF-8 byte
+						   in proper range? */
+		    byte2mask = 0x3C;		/* If not, set mask
+						   to check next byte */
+		}
+		trailing = 5;
+	    }
+	    else
+		break;
+	}
+    }
+
+    if ((buf != endbuf) || trailing) {
+	char errbuf[100];
+
+	snprintf(errbuf, sizeof(errbuf),
+		 "string '%s': not valid utf8", s);
+	yyerror(errbuf);
+	return 0;
+    }
+
+    return 1;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/tree.c dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/tree.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/tree.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/tree.c	2005-10-14 16:21:47.000000000 -0400
@@ -0,0 +1,224 @@
+/* tree.c -- abstract syntax tree handling
+ * Larry Greenfield
+ * $Id: tree.c,v 1.2 2005/10/14 20:21:47 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include "xmalloc.h"
+
+#include "tree.h"
+#include "sieve.h"
+
+stringlist_t *new_sl(char *s, stringlist_t *n)
+{
+    stringlist_t *p = (stringlist_t *) xmalloc(sizeof(stringlist_t));
+    p->s = s;
+    p->next = n;
+    return p;
+}
+
+
+tag_t *new_tag(int type, char *s)
+{
+    tag_t *p = (tag_t *) xmalloc(sizeof(tag_t));
+    p->type = type;
+    p->arg = s;
+    return p;
+}
+
+taglist_t *new_taglist(tag_t *t, taglist_t *n)
+{
+    taglist_t *p = (taglist_t *) xmalloc(sizeof(taglist_t));
+    p->t = t;
+    p->next = n;
+    return p;
+}
+
+test_t *new_test(int type) 
+{
+    test_t *p = (test_t *) xmalloc(sizeof(test_t));
+    p->type = type;
+    return p;
+}
+
+testlist_t *new_testlist(test_t *t, testlist_t *n)
+{
+    testlist_t *p = (testlist_t *) xmalloc(sizeof(testlist_t));
+    p->t = t;
+    p->next = n;
+    return p;
+}
+
+commandlist_t *new_command(int type)
+{
+    commandlist_t *p = (commandlist_t *) xmalloc(sizeof(commandlist_t));
+    p->type = type;
+    p->next = NULL;
+    return p;
+}
+
+commandlist_t *new_if(test_t *t, commandlist_t *y, commandlist_t *n)
+{
+    commandlist_t *p = (commandlist_t *) xmalloc(sizeof(commandlist_t));
+    p->type = IF;
+    p->u.i.t = t;
+    p->u.i.do_then = y;
+    p->u.i.do_else = n;
+    p->next = NULL;
+    return p;
+}
+
+void free_sl(stringlist_t *sl) 
+{
+    stringlist_t *sl2;
+    
+    while (sl != NULL) {
+	sl2 = sl->next;
+
+	if (sl->s) free(sl->s);
+
+	free(sl);
+	sl = sl2;
+    }
+}
+
+
+void free_test(test_t *t);
+
+static void free_tl(testlist_t *tl)
+{
+    testlist_t *tl2;
+
+    while (tl) {
+	tl2 = tl->next;
+
+	if (tl->t) free_test(tl->t);
+
+	free(tl);
+	tl = tl2;
+    }
+}
+
+void free_test(test_t *t)
+{
+    if (t == NULL) return;
+
+    switch (t->type) {
+    case ANYOF:
+    case ALLOF:
+	free_tl(t->u.tl);
+	break;
+
+    case EXISTS:
+	free_sl(t->u.sl);
+	break;
+
+    case SIZE:
+    case SFALSE:
+    case STRUE:
+	break;
+
+    case HEADER:
+	free_sl(t->u.h.sl);
+	free_sl(t->u.h.pl);
+	
+	break;
+
+    case ADDRESS:
+	free_sl(t->u.ae.sl);
+	free_sl(t->u.ae.pl);
+	break;
+
+    case NOT:
+	free_test(t->u.t);
+	break;
+    }
+
+    free(t);
+}
+
+void free_tree(commandlist_t *cl)
+{
+    commandlist_t *cl2;
+
+    while (cl != NULL) {
+	cl2 = cl->next;
+	switch (cl->type) {
+	case IF:
+	    free_test(cl->u.i.t);
+	    free_tree(cl->u.i.do_then);
+	    free_tree(cl->u.i.do_else);
+	    break;
+
+	case FILEINTO:
+	case REDIRECT:
+	case REJCT:
+	    if (cl->u.str) free(cl->u.str);
+	    break;
+
+	case VACATION:
+	    if (cl->u.v.subject) free(cl->u.v.subject);
+	    if (cl->u.v.addresses) free_sl(cl->u.v.addresses);
+	    if (cl->u.v.message) free(cl->u.v.message);
+	    break;
+	    
+	case SETFLAG:
+	case ADDFLAG:
+	case REMOVEFLAG:
+	    free_sl(cl->u.sl);
+	    break;
+
+	case KEEP:
+	case STOP:
+	case DISCARD:
+	    break;
+
+	case NOTIFY:
+	    if (cl->u.n.method) free(cl->u.n.method);
+	    if (cl->u.n.id) free(cl->u.n.id);
+	    if (cl->u.n.options) free_sl(cl->u.n.options);
+	    if (cl->u.n.message) free(cl->u.n.message);
+	    break;
+
+	case DENOTIFY:
+	    if (cl->u.d.pattern) {
+#ifdef ENABLE_REGEX
+		if (cl->u.d.comptag == REGEX) {
+		    regfree((regex_t *) cl->u.d.pattern);
+		}
+#endif
+		free(cl->u.d.pattern);
+	    }
+	    break;
+	}
+
+	free(cl);
+	cl = cl2;
+    }
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/tree.h dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/tree.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/libsieve/tree.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/libsieve/tree.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,139 @@
+/* tree.h -- abstract syntax tree
+ * Larry Greenfield
+ * $Id: tree.h,v 1.1.1.1 2005/03/29 18:37:59 cras Exp $
+ */
+/***********************************************************
+        Copyright 1999 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Carnegie Mellon
+University not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior
+permission.
+
+CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE FOR
+ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+
+#ifndef TREE_H
+#define TREE_H
+
+#include "comparator.h"
+
+/* abstract syntax tree for sieve */
+typedef struct Stringlist stringlist_t;
+typedef struct Commandlist commandlist_t;
+typedef struct Test test_t;
+typedef struct Testlist testlist_t;
+typedef struct Tag tag_t;
+typedef struct Taglist taglist_t;
+
+struct Stringlist {
+    char *s;
+    stringlist_t *next;
+};
+
+ 
+struct Tag {
+    int type;
+    char *arg;
+};
+
+struct Taglist {
+    tag_t *t;
+    taglist_t *next;
+};
+
+struct Test {
+    int type;
+    union {
+	testlist_t *tl; /* anyof, allof */
+	stringlist_t *sl; /* exists */
+	struct { /* it's a header test */
+	    int comptag;
+	    char * comparator;
+	    int relation;
+	    void *comprock;
+	    stringlist_t *sl;
+	    stringlist_t *pl;
+	} h;
+	struct { /* it's an address or envelope test */
+	    int comptag;
+	    char * comparator;
+	    int relation; 
+	    void *comprock;
+	    stringlist_t *sl;
+	    stringlist_t *pl;
+            int addrpart;
+	} ae; 
+	test_t *t; /* not */
+	struct { /* size */
+	    int t; /* tag */
+	    int n; /* param */
+	} sz;
+    } u;
+};
+
+struct Testlist {
+    test_t *t;
+    testlist_t *next;
+};
+
+struct Commandlist {
+    int type;
+    union {
+        char *str;
+	stringlist_t *sl; /* the parameters */
+	struct { /* it's an if statement */
+	    test_t *t;
+	    commandlist_t *do_then;
+	    commandlist_t *do_else;
+	} i;
+	struct { /* it's a vacation action */
+	    char *subject;
+	    int days;
+	    stringlist_t *addresses;
+	    char *message;
+	    int mime;
+	} v;
+	struct { /* it's a notify action */
+	    char *method;
+	    char *id;
+	    stringlist_t *options;
+	    int priority;
+	    char *message;
+	} n;
+	struct { /* it's a denotify action */
+	    int comptag;
+	    int relation;
+	    void *comprock;
+	    void *pattern;
+	    int priority;
+	} d;
+    } u;
+    struct Commandlist *next;
+};
+
+stringlist_t *new_sl(char *s, stringlist_t *n);
+tag_t *new_tag(int type, char *s);
+taglist_t *new_taglist(tag_t *t, taglist_t *n);
+test_t *new_test(int type);
+testlist_t *new_testlist(test_t *t, testlist_t *n);
+commandlist_t *new_command(int type);
+commandlist_t *new_if(test_t *t, commandlist_t *y, commandlist_t *n);
+
+void free_sl(stringlist_t *sl);
+void free_test(test_t *t);
+void free_tree(commandlist_t *cl);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/mail-send.c dovecot-1.0.beta5/src/dovecot-lda/src/mail-send.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/mail-send.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/mail-send.c	2006-01-14 18:25:25.000000000 -0500
@@ -0,0 +1,179 @@
+/* Copyright (C) 2005 Timo Sirainen */
+
+#include "common.h"
+#include "ioloop.h"
+#include "hostpid.h"
+#include "istream.h"
+#include "message-date.h"
+#include "message-size.h"
+#include "duplicate.h"
+#include "istream-header-filter.h"
+#include "smtpclient.h"
+#include "mail-send.h"
+
+#include <sys/wait.h>
+
+int global_outgoing_count = 0;
+
+int mail_send_rejection(struct mail *mail, const char *mailreceip,
+			const char *reason)
+{
+    struct istream *input;
+    FILE *sm;
+    struct message_size hdr_size;
+    const char *origid, *rejto, *origreceip;
+    const unsigned char *data;
+    const char *smbuf[10];
+    const char *msgid;
+    int ret, sm_stat;
+    pid_t sm_pid;
+    size_t size;
+
+    origid = mail_get_first_header(mail, "Message-ID");
+    rejto = get_return_path(mail);
+    origreceip = mail_get_first_header(mail, "original-recipient");
+
+    if (rejto == NULL) {
+	    i_info("Return-Path missing, rejection reason: %s", reason);
+	    return -1;
+    }
+
+    smbuf[0] = "sendmail";
+    smbuf[1] = "-i";		/* ignore dots */
+    smbuf[2] = "-f";
+    smbuf[3] = "<>";
+    smbuf[4] = "--";
+    smbuf[5] = rejto;
+    smbuf[6] = NULL;
+    sm_pid = open_sendmail(smbuf, &sm);
+    if (sm == NULL)
+	return -1;
+
+    msgid = t_strdup_printf("<cmu-sieve-%s-%s-%d@%s>",
+			    my_pid, dec2str(ioloop_time),
+			    global_outgoing_count++, sieve_set->hostname);
+
+    duplicate_mark(msgid, strlen(msgid), mailreceip,
+		   ioloop_time + DUPLICATE_DEFAULT_KEEP);
+    fprintf(sm, "Message-ID: %s\r\n", msgid);
+
+    fprintf(sm, "Date: %s\r\n", message_date_create(ioloop_time));
+
+    fprintf(sm, "From: Mail Sieve Subsystem <%s>\r\n",
+	    sieve_set->postmaster_address);
+    fprintf(sm, "To: <%s>\r\n", rejto);
+    fprintf(sm, "MIME-Version: 1.0\r\n");
+    fprintf(sm, "Content-Type: "
+	    "multipart/report; report-type=disposition-notification;"
+	    "\r\n\tboundary=\"%s/%s\"\r\n", my_pid, sieve_set->hostname);
+    fprintf(sm, "Subject: Automatically rejected mail\r\n");
+    fprintf(sm, "Auto-Submitted: auto-replied (rejected)\r\n");
+    fprintf(sm, "Precedence: bulk\r\n");
+    fprintf(sm, "\r\nThis is a MIME-encapsulated message\r\n\r\n");
+
+    /* this is the human readable status report */
+    fprintf(sm, "--%s/%s\r\n", my_pid, sieve_set->hostname);
+    fprintf(sm, "Content-Type: text/plain; charset=utf-8\r\n");
+    fprintf(sm, "Content-Disposition: inline\r\n");
+    fprintf(sm, "Content-Transfer-Encoding: 8bit\r\n\r\n");
+
+    fprintf(sm, "Your message was automatically rejected by Sieve, a mail\r\n"
+	    "filtering language.\r\n\r\n");
+    fprintf(sm, "The following reason was given:\r\n%s\r\n\r\n", reason);
+
+    /* this is the MDN status report */
+    fprintf(sm, "--%s/%s\r\n"
+	    "Content-Type: message/disposition-notification\r\n\r\n",
+	    my_pid, sieve_set->hostname);
+    fprintf(sm, "Reporting-UA: %s; Dovecot LDA %s\r\n",
+	    sieve_set->hostname, VERSION);
+    if (origreceip)
+	fprintf(sm, "Original-Recipient: rfc822; %s\r\n", origreceip);
+    fprintf(sm, "Final-Recipient: rfc822; %s\r\n", mailreceip);
+    if (origid)
+	fprintf(sm, "Original-Message-ID: %s\r\n", origid);
+    fprintf(sm, "Disposition: "
+	    "automatic-action/MDN-sent-automatically; deleted\r\n");
+    fprintf(sm, "\r\n");
+
+    /* this is the original message */
+    fprintf(sm, "--%s/%s\r\nContent-Type: message/rfc822\r\n\r\n",
+	    my_pid, sieve_set->hostname);
+
+    /* keep only headers */
+    input = mail_get_stream(mail, &hdr_size, NULL);
+    if (input != NULL) {
+	    input = i_stream_create_limit(default_pool, input,
+					  0, hdr_size.physical_size);
+	    while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+		    fwrite(data, size, 1, sm);
+		    i_stream_skip(input, size);
+	    }
+	    i_stream_unref(&input);
+
+	    i_assert(ret != 0);
+    }
+
+    fprintf(sm, "\r\n\r\n");
+    fprintf(sm, "--%s/%s--\r\n", my_pid, sieve_set->hostname);
+
+    fclose(sm);
+    while (waitpid(sm_pid, &sm_stat, 0) < 0);
+
+    return sm_stat;	/* sendmail exit value */
+}
+
+int mail_send_forward(struct mail *mail, const char *forwardto)
+{
+    static const char *hide_headers[] = {
+        "Return-Path"
+    };
+    struct istream *input;
+    FILE *sm;
+    const char *return_path;
+    const char *smbuf[10];
+    const unsigned char *data;
+    int sm_stat;
+    pid_t sm_pid;
+    size_t size;
+    int ret;
+
+    return_path = mail_get_first_header(mail, "Return-Path");
+
+    input = mail_get_stream(mail, NULL, NULL);
+    if (input == NULL)
+	    return -1;
+
+    smbuf[0] = "sendmail";
+    smbuf[1] = "-i";		/* ignore dots */
+    if (return_path && *return_path) {
+	smbuf[2] = "-f";
+	smbuf[3] = return_path;
+    } else {
+	smbuf[2] = "-f";
+	smbuf[3] = "<>";
+    }
+    smbuf[4] = "--";
+    smbuf[5] = forwardto;
+    smbuf[6] = NULL;
+    sm_pid = open_sendmail(smbuf, &sm);
+	
+    if (sm == NULL)
+	return -1;
+
+    input = i_stream_create_header_filter(input, HEADER_FILTER_EXCLUDE |
+                                          HEADER_FILTER_NO_CR, hide_headers,
+                                          sizeof(hide_headers) /
+                                          sizeof(hide_headers[0]), NULL, NULL);
+
+    while ((ret = i_stream_read_data(input, &data, &size, 0)) > 0) {
+	    fwrite(data, size, 1, sm);
+	    i_stream_skip(input, size);
+    }
+
+    fclose(sm);
+    while (waitpid(sm_pid, &sm_stat, 0) < 0);
+
+    return sm_stat;	/* sendmail exit value */
+}
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/mail-send.h dovecot-1.0.beta5/src/dovecot-lda/src/mail-send.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/mail-send.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/mail-send.h	2005-07-29 04:43:47.000000000 -0400
@@ -0,0 +1,12 @@
+#ifndef __MAIL_SEND_H
+#define __MAIL_SEND_H
+
+#define DUPLICATE_DEFAULT_KEEP (3600 * 24)
+
+extern int global_outgoing_count;
+
+int mail_send_rejection(struct mail *mail, const char *mailreceip,
+			const char *reason);
+int mail_send_forward(struct mail *mail, const char *forwardto);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/Makefile.am dovecot-1.0.beta5/src/dovecot-lda/src/Makefile.am
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/Makefile.am	2006-01-02 08:39:07.000000000 -0500
@@ -0,0 +1,53 @@
+pkglibexecdir = $(libexecdir)/dovecot
+
+SUBDIRS = libsieve
+
+pkglibexec_PROGRAMS = deliver
+
+AM_CPPFLAGS = \
+	-I$(dovecotdir) \
+	-I$(dovecotdir)/src/lib \
+	-I$(dovecotdir)/src/lib-dict \
+	-I$(dovecotdir)/src/lib-mail \
+	-I$(dovecotdir)/src/lib-storage \
+	-I$(dovecotdir)/src/lib-storage/index/mbox \
+	-DSYSCONFDIR=\""$(sysconfdir)"\"
+
+libs = \
+	libsieve/libsieve.a \
+	$(dovecotdir)/src/lib-storage/register/libstorage-register.a \
+	$(STORAGE_LIBS) \
+	$(dovecotdir)/src/lib-storage/libstorage.a \
+	$(dovecotdir)/src/lib-storage/subscription-file/libstorage_subscription_file.a \
+	$(dovecotdir)/src/lib-imap/libimap.a \
+	$(dovecotdir)/src/lib-mail/libmail.a \
+	$(dovecotdir)/src/lib-dict/libdict.a \
+	$(dovecotdir)/src/lib-charset/libcharset.a \
+	$(dovecotdir)/src/lib/liblib.a
+
+deliver_LDADD = \
+	$(libs) \
+	$(LIBICONV) \
+	$(RAND_LIBS) \
+	$(MODULE_LIBS)
+
+deliver_DEPENDENCIES = $(libs)
+
+deliver_SOURCES = \
+	deliver.c \
+	duplicate.c \
+	imparse.c \
+	mail-send.c \
+	map.c \
+	sieve-cmu.c \
+	smtpclient.c
+
+noinst_HEADERS = \
+	common.h \
+	duplicate.h \
+	imparse.h \
+	mail-send.h \
+	libconfig.h \
+	map.h \
+	smtpclient.h \
+	xmalloc.h
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/map.c dovecot-1.0.beta5/src/dovecot-lda/src/map.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/map.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/map.c	2005-04-10 12:06:24.000000000 -0400
@@ -0,0 +1,49 @@
+#include "lib.h"
+#include "map.h"
+
+#include <unistd.h>
+
+static ssize_t read_full_n(int fd, void *data, size_t size)
+{
+	ssize_t ret, all_ret = 0;
+
+	while (size > 0) {
+		ret = read(fd, data, size);
+		if (ret <= 0)
+			return ret;
+
+		data = PTR_OFFSET(data, ret);
+		all_ret += ret;
+		size -= ret;
+	}
+
+	return all_ret;
+}
+
+void map_refresh(int fd, int onceonly __attr_unused__, const char **base,
+		 unsigned long *len, unsigned long newlen,
+		 const char *name, const char *mboxname __attr_unused__)
+{
+	ssize_t ret;
+	void *p;
+
+	*base = p = i_malloc(newlen);
+	*len = newlen;
+
+	ret = read_full_n(fd, p, newlen);
+	if (ret < 0) {
+		i_error("read_full_n(%s) failed: %m", name);
+		ret = 0;
+	}
+
+	*len = ret;
+}
+
+void map_free(const char **base, unsigned long *len __attr_unused__)
+{
+	char *x = (char *) *base;
+
+	i_free(x);
+	*base = NULL;
+}
+
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/map.h dovecot-1.0.beta5/src/dovecot-lda/src/map.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/map.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/map.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,10 @@
+#ifndef __MAP_H
+#define __MAP_H
+
+extern void map_refresh(int fd, int onceonly, const char **base,
+			unsigned long *len, unsigned long newlen,
+			const char *name, const char *mboxname);
+
+extern void map_free(const char **base, unsigned long *len);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/sieve-cmu.c dovecot-1.0.beta5/src/dovecot-lda/src/sieve-cmu.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/sieve-cmu.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/sieve-cmu.c	2006-02-08 06:39:29.000000000 -0500
@@ -0,0 +1,612 @@
+/* Copyright (C) 2005 Timo Sirainen */
+
+#include "common.h"
+#include "ioloop.h"
+#include "array.h"
+#include "hostpid.h"
+#include "str.h"
+#include "str-sanitize.h"
+#include "write-full.h"
+#include "message-date.h"
+#include "duplicate.h"
+#include "mail-send.h"
+#include "smtpclient.h"
+#include "libsieve/sieve_interface.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+/* data per script */
+typedef struct script_data {
+	const char *username;
+	struct mail_storage *storage;
+	string_t *errors;
+} script_data_t;
+
+typedef struct {
+	struct mail *mail;
+	const char *mailbox;
+	const char *id;
+	const char *return_path;
+	const char *authuser;
+
+	const char *temp[10];
+} sieve_msgdata_t;
+
+/* gets the header "head" from msg. */
+static int getheader(void *v, const char *phead, const char ***body)
+{
+    sieve_msgdata_t *m = v;
+
+    if (phead==NULL) return SIEVE_FAIL;
+    *body = (const char **)mail_get_headers(m->mail, phead);
+
+    if (*body) {
+	return SIEVE_OK;
+    } else {
+	return SIEVE_FAIL;
+    }
+}
+
+static int getsize(void *mc, int *size)
+{
+    sieve_msgdata_t *md = mc;
+    uoff_t psize;
+
+    psize = mail_get_physical_size(md->mail);
+    if (psize == (uoff_t)-1)
+	    return SIEVE_FAIL;
+
+    *size = psize;
+    return SIEVE_OK;
+}
+
+/* we use the temp field in message_data to avoid having to malloc memory
+   to return, and we also can't expose our the receipients to the message */
+static int getenvelope(void *mc, const char *field, const char ***contents)
+{
+    sieve_msgdata_t *m = (sieve_msgdata_t *) mc;
+
+    if (!strcasecmp(field, "from")) {
+	*contents = m->temp;
+	m->temp[0] = m->return_path;
+	m->temp[1] = NULL;
+	return SIEVE_OK;
+    } else if (!strcasecmp(field, "to")) {
+	*contents = m->temp;
+	m->temp[0] = /*FIXME:msg_getrcptall(m, m->cur_rcpt)*/m->authuser;
+	m->temp[1] = NULL;
+	return SIEVE_OK;
+    } else if (!strcasecmp(field, "auth") && m->authuser) {
+	*contents = m->temp;
+	m->temp[0] = m->authuser;
+	m->temp[1] = NULL;
+	return SIEVE_OK;
+    } else {
+	*contents = NULL;
+	return SIEVE_FAIL;
+    }
+}
+
+static int sieve_redirect(void *ac, 
+			  void *ic __attribute__((unused)), 
+			  void *sc, void *mc, const char **errmsg)
+{
+    sieve_redirect_context_t *rc = (sieve_redirect_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *m = mc;
+    const char *dupeid;
+    int res;
+
+    /* if we have a msgid, we can track our redirects */
+    dupeid = m->id == NULL ? NULL : t_strdup_printf("%s-%s", m->id, rc->addr);
+    if (dupeid != NULL) {
+	/* ok, let's see if we've redirected this message before */
+	if (duplicate_check(dupeid, strlen(dupeid), sd->username)) {
+	    /*duplicate_log(m->id, sd->username, "redirect");*/
+            i_info("Duplicated redirection (%s: %s -> %s)", m->id,
+                   sd->username, rc->addr);
+            return SIEVE_OK;
+	}
+    }
+
+    if ((res = mail_send_forward(m->mail, rc->addr)) == 0) {
+	/* mark this message as redirected */
+        if (dupeid != NULL) {
+            duplicate_mark(dupeid, strlen(dupeid), sd->username,
+                           ioloop_time + DUPLICATE_DEFAULT_KEEP);
+        }
+	return SIEVE_OK;
+    } else {
+	if (res == -1) {
+	    *errmsg = "Could not spawn sendmail process";
+	} else {
+	    *errmsg = sendmail_errstr(res);
+	}
+	return SIEVE_FAIL;
+    }
+}
+
+static int sieve_discard(void *ac __attribute__((unused)), 
+			 void *ic __attribute__((unused)), 
+			 void *sc, void *mc, 
+			 const char **errmsg __attribute__((unused)))
+{
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = mc;
+
+    /* ok, we won't file it, but log it */
+    if (md->id && strlen(md->id) < 80) {
+	i_info("sieve: discarded message to %s id %s",
+	       sd->username, str_sanitize(md->id, 80));
+    }
+    else {
+	i_info("sieve: discarded message to %s",
+	       sd->username);
+    }	
+
+    return SIEVE_OK;
+}
+
+static int sieve_reject(void *ac, 
+			void *ic __attribute__((unused)), 
+			void *sc, void *mc, const char **errmsg)
+{
+    sieve_reject_context_t *rc = (sieve_reject_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+    int res;
+
+    if (md->return_path == NULL) {
+	/* return message to who?!? */
+	*errmsg = "No return-path for reply";
+	return SIEVE_FAIL;
+    }
+
+    if (strlen(md->return_path) == 0) {
+	i_info("sieve: discarded reject to <> for %s id %s",
+	       sd->username, str_sanitize(md->id, 80));
+        return SIEVE_OK;
+    }
+
+    if ((res = mail_send_rejection(md->mail, sd->username, rc->msg)) == 0) {
+	return SIEVE_OK;
+    } else {
+	if (res == -1) {
+	    *errmsg = "Could not spawn sendmail process";
+	} else {
+	    *errmsg = sendmail_errstr(res);
+	}
+	return SIEVE_FAIL;
+    }
+    return SIEVE_FAIL;
+}
+
+static void get_flags(const sieve_imapflags_t *sieve_flags,
+		      enum mail_flags *flags_r, const char *const **keywords_r)
+{
+	array_t ARRAY_DEFINE(keywords, const char *);
+        const char *name;
+	int i;
+
+	*flags_r = 0;
+
+	ARRAY_CREATE(&keywords, default_pool, const char *, 16);
+	for (i = 0; i < sieve_flags->nflags; i++) {
+		name = sieve_flags->flag[i];
+
+		if (name != NULL && *name != '\\') {
+			/* keyword */
+			array_append(&keywords, &name, 1);
+		} else {
+			/* system flag */
+			if (name == NULL || strcasecmp(name, "\\flagged") == 0)
+				*flags_r |= MAIL_FLAGGED;
+			else if (strcasecmp(name, "\\answered") == 0)
+				*flags_r |= MAIL_ANSWERED;
+			else if (strcasecmp(name, "\\deleted") == 0)
+				*flags_r |= MAIL_DELETED;
+			else if (strcasecmp(name, "\\seen") == 0)
+				*flags_r |= MAIL_SEEN;
+			else if (strcasecmp(name, "\\draft") == 0)
+				*flags_r |= MAIL_DRAFT;
+		}
+	}
+
+	name = NULL;
+	array_append(&keywords, &name, 1);
+
+	*keywords_r = array_count(&keywords) == 1 ? NULL :
+		array_get(&keywords, 0);
+}
+
+static int sieve_fileinto(void *ac, 
+			  void *ic __attr_unused__,
+			  void *sc, 
+			  void *mc,
+			  const char **errmsg __attr_unused__)
+{
+    sieve_fileinto_context_t *fc = (sieve_fileinto_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+    enum mail_flags flags;
+    const char *const *keywords;
+
+    get_flags(fc->imapflags, &flags, &keywords);
+
+    if (save_mail(sd->storage, fc->mailbox, md->mail, flags, keywords) < 0)
+	    return SIEVE_FAIL;
+    return SIEVE_OK;
+}
+
+static int sieve_keep(void *ac, 
+		      void *ic __attr_unused__,
+		      void *sc, void *mc, const char **errmsg __attr_unused__)
+{
+    sieve_keep_context_t *kc = (sieve_keep_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    sieve_msgdata_t *md = (sieve_msgdata_t *) mc;
+    enum mail_flags flags;
+    const char *const *keywords;
+
+    get_flags(kc->imapflags, &flags, &keywords);
+
+    if (save_mail(sd->storage, md->mailbox, md->mail, flags, keywords) < 0)
+	    return SIEVE_FAIL;
+
+    return SIEVE_OK;
+}
+
+static int sieve_notify(void *ac __attr_unused__,
+			void *interp_context __attr_unused__,
+			void *script_context __attr_unused__,
+			void *mc __attr_unused__,
+			const char **errmsg __attr_unused__)
+{
+#if 0
+    const char *notifier = config_getstring(IMAPOPT_SIEVENOTIFIER);
+
+    if (notifier) {
+	sieve_notify_context_t *nc = (sieve_notify_context_t *) ac;
+	script_data_t *sd = (script_data_t *) script_context;
+	int nopt = 0;
+
+	/* count options */
+	while (nc->options[nopt]) nopt++;
+
+	/* "default" is a magic value that implies the default */
+	notify(!strcmp("default",nc->method) ? notifier : nc->method,
+	       "SIEVE", nc->priority, sd->username, NULL,
+	       nopt, nc->options, nc->message);
+    }
+#endif
+    return SIEVE_FAIL;
+}
+
+static int autorespond(void *ac, 
+		       void *ic __attr_unused__,
+		       void *sc,
+		       void *mc __attr_unused__,
+		       const char **errmsg __attr_unused__)
+{
+    sieve_autorespond_context_t *arc = (sieve_autorespond_context_t *) ac;
+    script_data_t *sd = (script_data_t *) sc;
+    int ret;
+
+    /* ok, let's see if we've responded before */
+    ret = duplicate_check(arc->hash, arc->len,  sd->username) ?
+	    SIEVE_DONE : SIEVE_OK;
+
+    if (ret == SIEVE_OK) {
+	duplicate_mark(arc->hash, arc->len, sd->username,
+		       ioloop_time + arc->days * (24 * 60 * 60));
+    }
+
+    return ret;
+}
+
+static int send_response(void *ac, 
+			 void *ic __attribute__((unused)), 
+			 void *sc, void *mc,
+			 const char **errmsg)
+{
+    FILE *sm;
+    const char *smbuf[10];
+    char outmsgid[8192];
+    int sm_stat;
+    pid_t sm_pid;
+    sieve_send_response_context_t *src = (sieve_send_response_context_t *) ac;
+    script_data_t *sdata = (script_data_t *) sc;
+    sieve_msgdata_t *md = mc;
+
+    smbuf[0] = "sendmail";
+    smbuf[1] = "-i";		/* ignore dots */
+    smbuf[2] = "-f";
+    smbuf[3] = "<>";
+    smbuf[4] = "--";
+    smbuf[5] = src->addr;
+    smbuf[6] = NULL;
+    sm_pid = open_sendmail(smbuf, &sm);
+    if (sm == NULL) {
+	*errmsg = "Could not spawn sendmail process";
+	return -1;
+    }
+
+    snprintf(outmsgid, sizeof(outmsgid), "<cmu-sieve-%s-%s-%d@%s>",
+	     my_pid, dec2str(ioloop_time),
+	     global_outgoing_count++, sieve_set->hostname);
+    
+    fprintf(sm, "Message-ID: %s\r\n", outmsgid);
+    fprintf(sm, "Date: %s\r\n", message_date_create(ioloop_time));
+    
+    fprintf(sm, "X-Sieve: %s\r\n", SIEVE_VERSION);
+    fprintf(sm, "From: <%s>\r\n", src->fromaddr);
+    fprintf(sm, "To: <%s>\r\n", src->addr);
+    fprintf(sm, "Subject: %s\r\n", str_sanitize(src->subj, 80));
+    if (md->id) fprintf(sm, "In-Reply-To: %s\r\n", md->id);
+    fprintf(sm, "Auto-Submitted: auto-replied (vacation)\r\n");
+    fprintf(sm, "Precedence: bulk\r\n");
+    fprintf(sm, "MIME-Version: 1.0\r\n");
+    if (src->mime) {
+	fprintf(sm, "Content-Type: multipart/mixed;"
+		"\r\n\tboundary=\"%s/%s\"\r\n", my_pid, sieve_set->hostname);
+	fprintf(sm, "\r\nThis is a MIME-encapsulated message\r\n\r\n");
+	fprintf(sm, "--%s/%s\r\n", my_pid, sieve_set->hostname);
+    } else {
+	fprintf(sm, "Content-Type: text/plain; charset=utf-8\r\n");
+	fprintf(sm, "Content-Transfer-Encoding: 8bit\r\n");
+	fprintf(sm, "\r\n");
+    }
+
+    fprintf(sm, "%s\r\n", src->msg);
+
+    if (src->mime) {
+	fprintf(sm, "\r\n--%s/%s--\r\n", my_pid, sieve_set->hostname);
+    }
+    fclose(sm);
+    while (waitpid(sm_pid, &sm_stat, 0) < 0);
+
+    if (sm_stat == 0) { /* sendmail exit value */
+        duplicate_mark(outmsgid, strlen(outmsgid),
+                       sdata->username, ioloop_time + DUPLICATE_DEFAULT_KEEP);
+	return SIEVE_OK;
+    } else {
+	*errmsg = sendmail_errstr(sm_stat);
+	return SIEVE_FAIL;
+    }
+}
+
+/* vacation support */
+sieve_vacation_t vacation = {
+    1,				/* min response */
+    31,				/* max response */
+    &autorespond,		/* autorespond() */
+    &send_response		/* send_response() */
+};
+
+/* imapflags support */
+static char *markflags[] = { "\\flagged" };
+static sieve_imapflags_t mark = { markflags, 1 };
+
+static int sieve_parse_error_handler(int lineno, const char *msg, 
+				     void *ic __attribute__((unused)),
+				     void *sc)
+{
+    script_data_t *sd = (script_data_t *) sc;
+
+    if (sd->errors == NULL) {
+	    sd->errors = str_new(default_pool, 1024);
+	    i_info("sieve parse error for %s: line %d: %s",
+		   sd->username, lineno, msg);
+    }
+
+    str_printfa(sd->errors, "line %d: %s\n", lineno, msg);
+    return SIEVE_OK;
+}
+
+static int sieve_execute_error_handler(const char *msg, 
+				       void *ic __attr_unused__,
+				       void *sc, void *mc __attr_unused__)
+{
+    script_data_t *sd = (script_data_t *) sc;
+    
+    i_info("sieve runtime error for %s: %s",
+	   sd->username, msg);
+    
+    return SIEVE_OK;
+}
+ 
+static sieve_interp_t *setup_sieve(void)
+{
+    sieve_interp_t *interp = NULL;
+    int res;
+
+    res = sieve_interp_alloc(&interp, NULL);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_interp_alloc() returns %d\n", res);
+
+    res = sieve_register_redirect(interp, &sieve_redirect);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_redirect() returns %d\n", res);
+    res = sieve_register_discard(interp, &sieve_discard);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_discard() returns %d\n", res);
+    res = sieve_register_reject(interp, &sieve_reject);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_reject() returns %d\n", res);
+    res = sieve_register_fileinto(interp, &sieve_fileinto);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_fileinto() returns %d\n", res);
+    res = sieve_register_keep(interp, &sieve_keep);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_keep() returns %d\n", res);
+    res = sieve_register_imapflags(interp, &mark);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_imapflags() returns %d\n", res);
+    res = sieve_register_notify(interp, &sieve_notify);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_notify() returns %d\n", res);
+    res = sieve_register_size(interp, &getsize);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_size() returns %d\n", res);
+    res = sieve_register_header(interp, &getheader);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_header() returns %d\n", res);
+
+    res = sieve_register_envelope(interp, &getenvelope);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_envelope() returns %d\n", res);
+    res = sieve_register_vacation(interp, &vacation);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_vacation() returns %d\n", res);
+    res = sieve_register_parse_error(interp, &sieve_parse_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_parse_error() returns %d\n", res);
+    res = sieve_register_execute_error(interp,  &sieve_execute_error_handler);
+    if (res != SIEVE_OK)
+	i_fatal("sieve_register_execute_error() returns %d\n", res);
+
+    return interp;
+}
+
+static int
+dovecot_sieve_compile(sieve_interp_t *interp, script_data_t *sdata,
+		      const char *script_path, const char *compiled_path)
+{
+	struct stat st, st2;
+	sieve_script_t *script;
+	bytecode_info_t *bc;
+	const char *temp_path;
+	FILE *f;
+	int fd, ret;
+
+	if (stat(script_path, &st) < 0) {
+		if (errno == ENOENT)
+			return 0;
+		i_error("stat(%s) failed: %m", script_path);
+		return -1;
+	}
+	if (stat(compiled_path, &st2) < 0) {
+		if (errno != ENOENT) {
+			i_error("stat(%s) failed: %m", script_path);
+			return -1;
+		}
+	} else {
+		if (st.st_mtime < st2.st_mtime)
+			return 1;
+	}
+
+	/* need to compile */
+	f = fopen(script_path, "r");
+	if (f == NULL) {
+		i_error("fopen(%s) failed: %m", script_path);
+		return -1;
+	}
+
+	ret = sieve_script_parse(interp, f, sdata, &script);
+	if (ret != SIEVE_OK) {
+		if (sdata->errors == NULL) {
+			sdata->errors = str_new(default_pool, 128);
+			str_printfa(sdata->errors, "parse error %d", ret);
+		}
+		return -1;
+	}
+
+	if (sieve_generate_bytecode(&bc, script) < 0) {
+		i_error("sieve_generate_bytecode() failed");
+		return -1;
+	}
+
+	/* write to temp file */
+	temp_path = t_strconcat(compiled_path, ".tmp", NULL);
+	fd = open(temp_path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+	if(fd == -1) {
+		i_error("open(%s) failed: %m", temp_path);
+		return -1;
+	}
+
+	if (sieve_emit_bytecode(fd, bc) < 0) {
+		i_error("sieve_emit_bytecode() failed");
+		return -1;
+	}
+
+	if (close(fd) < 0)
+		i_error("close() failed: %m");
+
+	/* and finally replace the script */
+	if (rename(temp_path, compiled_path) < 0) {
+		i_error("rename(%s, %s) failed: %m", temp_path, compiled_path);
+		return -1;
+	}
+	return 1;
+}
+
+static void
+dovecot_sieve_write_error_file(script_data_t *sdata, const char *path)
+{
+	int fd;
+
+	fd = open(path, O_CREAT | O_TRUNC | O_WRONLY, 0600);
+	if (fd == -1) {
+		i_error("open(%s) failed: %m", path);
+		return;
+	}
+
+	if (write_full(fd, str_data(sdata->errors), str_len(sdata->errors)) < 0)
+		i_error("write_full(%s) failed: %m", path);
+
+	if (close(fd) < 0)
+		i_error("close() failed: %m");
+}
+
+int dovecot_sieve_run(struct mail_storage *storage, struct mail *mail,
+		      const char *script_path, const char *username,
+		      const char *mailbox)
+{
+	sieve_interp_t *interp;
+	sieve_bytecode_t *bytecode;
+	script_data_t sdata;
+	sieve_msgdata_t mdata;
+	const char *compiled_path, *path;
+	int ret;
+
+	if (script_path == NULL)
+		return 0;
+
+	interp = setup_sieve();
+
+	memset(&sdata, 0, sizeof(sdata));
+	sdata.username = username;
+	sdata.storage = storage;
+
+	compiled_path = t_strconcat(script_path, "c", NULL);
+	ret = dovecot_sieve_compile(interp, &sdata, script_path, compiled_path);
+
+	if (sdata.errors != NULL) {
+		path = t_strconcat(script_path, ".err", NULL);
+		dovecot_sieve_write_error_file(&sdata, path);
+		str_free(&sdata.errors);
+	}
+	if (ret <= 0)
+		return ret;
+
+	memset(&mdata, 0, sizeof(mdata));
+	mdata.mail = mail;
+	mdata.mailbox = mailbox;
+	mdata.authuser = username;
+	mdata.id = mail_get_first_header(mail, "Message-ID");
+	mdata.return_path = get_return_path(mail);
+
+	if ((ret = sieve_script_load(compiled_path, &bytecode)) != SIEVE_OK) {
+		i_error("sieve_script_load(%s) failed: %d", compiled_path, ret);
+		return -1;
+	}
+
+	if (sieve_execute_bytecode(bytecode, interp,
+				   &sdata, &mdata) != SIEVE_OK)
+		return -1;
+
+	return 1;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/sieve-mailutils.c dovecot-1.0.beta5/src/dovecot-lda/src/sieve-mailutils.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/sieve-mailutils.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/sieve-mailutils.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,9 @@
+/* Copyright (C) 2005 Timo Sirainen */
+
+#include "common.h"
+
+int dovecot_sieve_run(struct mail_storage *storage, struct istream *input,
+		      const char *script_path)
+{
+	return 0;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/sieve-none.c dovecot-1.0.beta5/src/dovecot-lda/src/sieve-none.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/sieve-none.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/sieve-none.c	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,10 @@
+/* Copyright (C) 2005 Timo Sirainen */
+
+#include "common.h"
+
+int dovecot_sieve_run(struct mail_storage *storage __attr_unused__,
+		      struct istream *input __attr_unused__,
+		      const char *script_path __attr_unused__)
+{
+	return 0;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/smtpclient.c dovecot-1.0.beta5/src/dovecot-lda/src/smtpclient.c
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/smtpclient.c	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/smtpclient.c	2006-01-13 10:15:52.000000000 -0500
@@ -0,0 +1,120 @@
+/* smtpclient.c -- Routines for sending a message via SMTP
+ * 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * $Id: smtpclient.c,v 1.3 2006/01/13 15:15:52 cras Exp $
+ */
+
+#include "common.h"
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include "smtpclient.h"
+
+extern void fatal(const char *buf, int code);
+
+pid_t open_sendmail(const char *argv[], FILE **sm)
+{
+    int fds[2];
+    FILE *ret;
+    pid_t p;
+
+    if (pipe(fds) < 0)
+	    i_fatal("pipe() failed: %m");
+
+    if ((p = fork()) == 0) {
+	/* i'm the child! run sendmail! */
+	close(fds[1]);
+	/* make the pipe be stdin */
+	dup2(fds[0], 0);
+	execv("/usr/lib/sendmail", (char **) argv);
+
+	/* if we're here we suck */
+	printf("451 lmtpd: didn't exec() sendmail?!?\r\n");
+	i_fatal("couldn't exec() sendmail");
+    }
+
+    if (p < 0) {
+	/* failure */
+	*sm = NULL;
+	return p;
+    }
+
+    /* parent */
+    close(fds[0]);
+    ret = fdopen(fds[1], "w");
+    *sm = ret;
+
+    return p;
+}
+
+/* sendmail_errstr.  create a descriptive message given 'sm_stat': 
+   the exit code from wait() from sendmail.
+
+   not thread safe, but probably ok */
+char *sendmail_errstr(int sm_stat)
+{
+    static char errstr[200];
+
+    if (WIFEXITED(sm_stat)) {
+	snprintf(errstr, sizeof errstr,
+		 "Sendmail process terminated normally, exit status %d\n",
+		 WEXITSTATUS(sm_stat));
+    } else if (WIFSIGNALED(sm_stat)) {
+	snprintf(errstr, sizeof errstr,
+		"Sendmail process terminated abnormally, signal = %d %s\n",
+		WTERMSIG(sm_stat),
+#ifdef WCOREDUMP
+		WCOREDUMP(sm_stat) ? " -- core file generated" :
+#endif
+		"");
+    } else if (WIFSTOPPED(sm_stat)) {
+	snprintf(errstr, sizeof errstr,
+		 "Sendmail process stopped, signal = %d\n",
+		WTERMSIG(sm_stat));
+    } else {
+	return NULL;
+    }
+    
+    return errstr;
+}
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/smtpclient.h dovecot-1.0.beta5/src/dovecot-lda/src/smtpclient.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/smtpclient.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/smtpclient.h	2005-07-29 04:43:47.000000000 -0400
@@ -0,0 +1,54 @@
+/* smtpclient.h -- Routines for sending a message via SMTP
+ * 
+ * Copyright (c) 1998-2003 Carnegie Mellon University.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The name "Carnegie Mellon University" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For permission or any other legal
+ *    details, please contact  
+ *      Office of Technology Transfer
+ *      Carnegie Mellon University
+ *      5000 Forbes Avenue
+ *      Pittsburgh, PA  15213-3890
+ *      (412) 268-4387, fax: (412) 268-7395
+ *      tech-transfer@andrew.cmu.edu
+ *
+ * 4. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by Computing Services
+ *     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
+ *
+ * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+ * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * $Id: smtpclient.h,v 1.2 2005/07/29 08:43:47 cras Exp $
+ */
+
+#ifndef INCLUDED_SMTPCLIENT_H
+#define INCLUDED_SMTPCLIENT_H
+
+#include <stdio.h>
+
+pid_t open_sendmail(const char *argv[], FILE **sm);
+char *sendmail_errstr(int sm_stat);
+
+#endif
diff -urN dovecot-1.0.beta5.orig/src/dovecot-lda/src/xmalloc.h dovecot-1.0.beta5/src/dovecot-lda/src/xmalloc.h
--- dovecot-1.0.beta5.orig/src/dovecot-lda/src/xmalloc.h	1969-12-31 19:00:00.000000000 -0500
+++ dovecot-1.0.beta5/src/dovecot-lda/src/xmalloc.h	2005-03-29 13:37:59.000000000 -0500
@@ -0,0 +1,25 @@
+#ifndef __XMALLOC_H
+#define __XMALLOC_H
+
+#include <stdlib.h>
+#include <string.h>
+
+#define xmalloc(n) malloc(n)
+#define xrealloc(n, m) realloc(n, m)
+#define xzmalloc(n) calloc(n, 1)
+#define xstrdup(s) strdup(s)
+
+/* missing headers.. */
+#include <netinet/in.h>
+#include <regex.h>
+#include <fcntl.h>
+
+/* dovecot kludges */
+#include "lib.h"
+
+/* we don't have strlcpy, but strocpy is the same except for return value */
+#define strlcpy strocpy
+
+#define lcase str_lcase
+
+#endif
